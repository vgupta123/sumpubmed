BACKGROUND
assembling genomic sequences from a set of overlapping reads is one of the most fundamental problems in computational biology. algorithms addressing the assembly problem fall into two broad categories - based on the data structures which they employ. the first class uses an overlap/string graph and the second type uses a de bruijn graph. however with the recent advances in short read sequencing technology, de bruijn graph based algorithms seem to play a vital role in practice. efficient algorithms for building these massive de bruijn graphs are very essential in large sequencing projects based on short reads. in an earlier work, an o time parallel algorithm has been given for this problem. here n is the size of the input and p is the number of processors. this algorithm enumerates all possible bi-directed edges which can overlap with a node and ends up generating Θ messages .


RESULTS
in this paper we present a Θ time parallel algorithm with a communication complexity that is equal to that of parallel sorting and is not sensitive to Σ. the generality of our algorithm makes it very easy to extend it even to the out-of-core model and in this case it has an optimal i/o complexity of Θblog) . we demonstrate the scalability of our parallel algorithm on a sgi/altix computer. a comparison of our algorithm with the previous approaches reveals that our algorithm is faster - both asymptotically and practically. we demonstrate the scalability of our sequential out-of-core algorithm by comparing it with the algorithm used by velvet to build the bi-directed de bruijn graph. our experiments reveal that our algorithm can build the graph with a constant amount of memory, which clearly outperforms velvet. we also provide efficient algorithms for the bi-directed chain compaction problem.


CONCLUSIONS
the bi-directed de bruijn graph is a fundamental data structure for any sequence assembly program based on eulerian approach. our algorithms for constructing bi-directed de bruijn graphs are efficient in parallel and out of core settings. these algorithms can be used in building large scale bi-directed de bruijn graphs. furthermore, our algorithms do not employ any all-to-all communications in a parallel setting and perform better than the prior algorithms. finally our out-of-core algorithm is extremely memory efficient and can replace the existing graph construction algorithm in velvet.

