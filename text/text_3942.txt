BACKGROUND
computer programs that can simulate genotypes with phenotypes based on user-specified disease or quantitative trait models are essential in genetic studies. they can be used to evaluate statistical power when planning a study design based on the proposed sample size, the assumed genotypic relative risks , and allele frequencies. they are also useful for evaluating type i error rates for new statistical association tests and power comparisons between the new tests and other existing tests. therefore, many simulation programs have been developed, mostly aiming to generate genome-wide association study  data with dichotomous or quantitative traits  <cit> .

next-generation sequencing  has become a popular technique for identifying novel rare variants associated with complex diseases  <cit> . statistical association tests that can account for rare variants have also been developed rapidly  <cit> . these tests aim to identify multiple rare causal variants in a group of variants selected by biological functions, such as exons, genes, and pathways. a common approach is to pool all the variants in the group to increase the statistical power for associations. to evaluate the statistical power for new tests, a simulation tool that can simulate multiple rare casual variants based on sequence data is necessary. however, simulation programs developed for gwas may not be appropriate for evaluating statistical properties for ngs studies, because they were designed to simulate common variants based on gwas panels  or hapmap project data  <cit> . thus, computer software that can simulate sequence data based on realistic models with phenotypes becomes important.

to our knowledge, simrare is the only existing public software designed specifically to simulate sequence data with phenotypes  <cit> . simrare has three modules, including a sequence generation module, a module for phenotype generation based on genotypes, and a module for evaluating association methods. the forward-time simulation algorithm  <cit>  is used in simrare to generate variant data. simrare focuses on generating unrelated samples and on evaluating association methods developed for unrelated samples. as more and more family-based association studies using ngs are conducted  <cit> , software that can generate sequence data in families will be very useful for evaluating the properties of family-based ngs analysis.

we developed the sequence and phenotype simulator, seqsimla, which can simulate sequence data in unrelated case–control or family samples with user-specified disease or quantitative trait models. seqsimla uses genome  <cit>  as the default sequence generator, which efficiently generates data using the coalescent model. seqsimla also accepts a population of sequences generated by other sequence generators. seqsimla can simulate multiple causal variants in regions on different chromosomes, where the recombination rates between regions are based on the rates estimated from the hap map project  <cit>  or a user-specified fixed rate. we compared the features between seqsimla and simrare and used simulations to demonstrate that seqsimla can generate data in a reasonable time frame.

implementation
sequence generation
genome is used as the default tool to simulate a population of sequences based on the coalescent model. alternatively, as other sequence simulators can have their own unique features, seqsimla also accepts a population of sequences generated by other programs. genome either accepts different recombination rates among chromosomal blocks or assumes a fixed rate across the genome. there is no recombination within each of the chromosomal blocks. to simulate block structures similar to real populations, we downloaded the recombination hotspots across the genome from the hapmap project  <cit> , with the highest recombination rate in each hotspot region used as the recombination rate for the center of the hotspot. crossovers during meiosis are simulated based on the recombination rates for the centers of hotspots. alternatively, the user can assume that the recombination rates are uniform across the chromosomes, which is the default setting in genome.

disease models
we do not have restrictions on the number of disease loci to be simulated. a logistic function as follows is used to calculate the penetrance:

 paffected|x=expα+bx/1+expα+bx 

where x =  is a vector of genotype coding for n disease variants, b=  is a vector of the conditional log of odds ratios for the associated genotypes, and α determines the disease prevalence k. the parameter α is ln ), which is the log odds of the penetrance for x with no mutant alleles. the odds ratio eβi represents the increased odds for the disease for an additional mutant allele at variant i <cit> . for the prevalence model , the disease prevalence k is specified by the user. we iteratively search for α in the range between − <dig> and  <dig> and calculate disease prevalence ki based on αi in iteration i. the value αi is selected for α if |ki − k| < ϵ, where ϵ is small . alternatively, the user can specify f <dig> directly, and uses the population attributable risk  to determine the grrs for the disease loci . the logistic function can be represented by the function of f <dig> and grr :

 paffected|x=f0×∏i=1ngrrik1−f0+f0×∏i=1ngrrik 

 grri=pari1−pari×ri+ <dig>  

 where f <dig> is the baseline penetrance specified by the user, grri is the grr for the genotype at marker i, pari is the population attributable risk, and ri is the risk allele frequency for marker i. the sum of pari for the disease loci is equal to the overall par specified by the user. the parameter k is coded as the number of mutant allele counts  for an additive model, the presence/absence of an mutant allele  for a dominant model, and the presence/absence of a homozygous mutant genotype  for a recessive model. the model can assume that rarer variants have higher grr values, given all causal variants contribute equally to the total par. seqsimla can also randomly generate a par for each of the disease loci, while keeping the overall par fixed. alternatively, the user can specify a fixed grr across all disease loci.

the user can simulate dominant, recessive, or additive models for the disease loci under models  <dig> and  <dig>  the disease model is determined by the genotype coding in x for model  <dig> and by the parameter k for model  <dig>  for model  <dig>  the user can specify whether a variant has a risk or protective effect using the parameters in b. for model  <dig>  the grr for variant i with a protective effect is the inverse of grri. the user can also specify the proportion of risk variants in all variants with effects.

quantitative trait
we also do not have restrictions on the number of quantitative trait loci . the user needs to specify the total phenotypic variance vp and the proportion of variance explained by each of the qtl. assuming that the proportion of variance explained by qtl j is fj and the allele frequencies for qtl j are pj and qj, the genotypic value aj can be calculated for additive, dominant, and recessive models as follows  <cit> :

additive model: aj=vpj2pjqj

dominant model: aj=vpj8pjqj3+4pj2qj2

recessive model: aj=vpj8pj3qj+4pj2qj2

where vpj=vpfj.

assume qtl j has two alleles a <dig> and a <dig>  where a <dig> is the minor allele responsible for the larger value in the trait. for a set of m qtl, the phenotypic value y is a random variable defined as:

 y=μ+∑j=1mgj+p+e, 

 where μ is the general mean specified by the user, gj follows a normal distribution with mean μj and variance vpj, p follows a normal distribution with mean  <dig> and variance vpoly specified by the user, and e follows a normal distribution with mean  <dig> and variance vp−∑j=1mvpj−vpoly. p and e model the polygenic and environmental components, respectively. the mean μj for gj is defined as:

 μj=aj, <dig> −ajforgenotypesa1a <dig> a1a <dig> a2a2undertheadditivemodelaj,aj,−ajforgenotypesa1a <dig> a1a <dig> a2a2underthedominantmodelaj,−aj,−ajforgenotypesa1a <dig> a1a <dig> a2a2undertherecessivemodel 

data types
seqsimla can simulate two data types – three-generation family data with  <dig> members and unrelated cases and controls. the structure for each family is shown in figure  <dig>  we assume random mating in a population of haplotypes generated by genome to simulate family data. for the disease models, a family is ascertained if there is a user-specified number of affected siblings  in the third generation. to generate case–control data, we simulate cases by randomly selecting unrelated affected individuals and simulate controls by randomly selecting unrelated unaffected individuals in the third generations of unrelated families. for the quantitative trait model, the user can decide whether the families will be ascertained based on affection status in family members, which is the same procedure as in the disease models, or randomly from the population.

efficiency improvements
seqsimla determines that an individual is affected by comparing the probability calculated from the penetrance function given the person’s genotypes to a random number. this process can be inefficient for a rare disease with low penetrance. we implemented a similar strategy as in edwards et al.  <cit>  to efficiently simulate unrelated cases. we first simulated a small set of cases  using the penetrance function in model  <dig> or  <dig>  the conditional probability p can be calculated based on the set of cases, where x is a multilocus genotype observed at the disease variants in the set of cases. then a multilocus genotype at the disease variants for a case is simulated based on the conditional distribution, and two sequence haplotypes, which are consistent with the multilocus genotype, are randomly selected from the population of sequences. the advantage of this method is that the run time is not affected by the disease prevalence. however, the conditional probability is subject to sampling error as it is estimated in a small set of samples.

as generating each of the families, unrelated cases, and unrelated controls is an independent process, the procedures can be parallelized with threads on a multi-core computer. we used java thread to parallelize the code. each thread generates about the same amount of families, cases, and controls. we used simulations to evaluate the performance of seqsimla running with threads.

RESULTS
seqsimla is implemented in java, which is portable on different operating systems, including linux and windows. the parameters required for seqsimla can be specified in the command line. alternatively, the user can specify the parameters using a control file so that they can be saved and reused. seqsimla writes the variant data in standard plink file format   <cit> , which has been widely adopted in genetic analysis. map distance between two variants is calculated by haldane’s mapping function  <cit> . an additional phenotype file with quantitative trait values, which is also in the same format as the plink phenotype file, is generated if the user chooses to simulate a quantitative trait.

we evaluated the performance of seqsimla for generating datasets. we used the parameters provided in the best-fitting population-genetics model  <cit> , which includes estimates of ancestral population sizes, duration of population expansion, migration rates, recombination rates, final population sizes, and gene conversion rate, to simulate a population of sequences with an allele frequency spectrum similar to the european population in genome. we simulated  <dig> block and  <dig> adjacent blocks on chromosome  <dig>  based on the recombination rates from the hapmap project. as more than  <dig> functional variants in coding regions can be identified in resequencing studies for complex diseases  <cit> , we simulated  <dig> disease loci with minor allele frequencies less than  <dig>  using model  <dig>  the overall par was set as  <dig> . the baseline penetrance f <dig> was set as  <dig> ,  <dig> , and  <dig> , reflecting prevalence of different complex diseases. we also simulated two different types of study samples:  <dig> families with at least one affected sib, and  <dig> cases and  <dig> controls. the average time  spent on generating a dataset was shown in table  <dig>  the simulations were performed on a linux server with intel xeon  <dig>  ghz cpus  and 96 gb of memory. as shown in table  <dig>  seqsimla can generate a dataset in a  <dig> block region with  <dig>  snps in 8 seconds with  <dig> threads. even with a rare disease , seqsimla with threads can generate a dataset in a larger region  in 5 minutes.

1the estimated prevalence based on  <dig>  prospective cohorts generated under model  <dig> 

 <dig> families generated with  <dig> thread.

 <dig> families generated with  <dig> threads.

 <dig> cases and  <dig> controls generated with  <dig> thread.

 <dig> cases and  <dig> controls generated with  <dig> threads.

 <dig> cases and  <dig> controls generated with the conditional probability of multilocus genotypes given the disease status.

7run time  and the percentage of run time spent on i/o.

8run time  and the percentage of run time spent on i/o.

we performed linkage and rare-variant association analysis on the data simulated by seqsimla to verify that seqsimla is properly implemented. for linkage analysis,  <dig> families with at least two affected siblings were simulated. we simulated two regions  on the same chromosome, where the recombination fraction between the two regions was  <dig> . we simulated  <dig> disease loci using model  <dig> with maf between  <dig>  and  <dig>  in region <dig>  which has  <dig> variants. the disease prevalence was  <dig> . all disease loci were assumed to have an effect size of  <dig> , which was commonly observed in gwas studies  <cit> . region <dig> has  <dig> variants. for association analysis, we simulated  <dig> cases and  <dig> controls. we also simulated two regions  on the same chromosome, where the recombination fraction between the two regions was  <dig>  we simulated  <dig> disease loci using model  <dig> with maf <  <dig>  in region <dig>  which has  <dig> variants. the baseline penetrance f <dig> and the population attributable risk  were specified as  <dig> . region <dig> has  <dig> variants. a total of  <dig> replicates of family and case–control data were simulated for linkage and association analysis, respectively. merlin  <cit>  was used to perform linkage analysis ; and the sequence kernel association test   <cit>  implemented in the skat r package was used to perform association analysis. table  <dig> shows the results of type i error rates and power calculated for the null and alternative models, respectively. as shown in table  <dig>  both merlin and skat have power for region <dig> and region <dig>  where the disease loci are located. merlin also has power for region <dig>  which is linked to region <dig>  skat has the correct type i error rate for region <dig>  which is not linked to the disease loci.

1the proportion of tests being rejected at the  <dig>  significance level over  <dig> replicates.

two penetrance functions, models  <dig> and  <dig>  are used to determine disease status in seqsimla. model  <dig>  which is based on the logistic function and has been used extensively in many simulation studies  <cit> , allows the user to determine the conditional odds ratio for each of the disease variants and the disease prevalence. therefore, the user can simulate disease models based on estimated odds ratios of candidate variants from previous association studies and estimated disease prevalence from a prevalence study. model  <dig>  which is based on the population attributable risk, has the advantage of controlling the overall par for a group of disease variants. the model can assume that rarer disease variants have higher grrs, given that all of the variants have the same par  <cit> . the model can also assume disease variants contribute unequally to the overall par. therefore, the model is suitable to simulate a large number of rare disease variants with different odds ratios, while keeping the overall par in a specified value.

both seqsimla and simrare are able to generate sequence data for independent samples, but with some different underlying settings. simrare uses the forward-time simulation program srv implemented in the simupop environment to generate sequence data. the srv program provides multi-locus selection models with random fitness effects, which are ideal for simulating multiple rare variants under selection. the default sequence generator, genome, in seqsimla is a backward-time simulator. similar to the limitation in other backward-time simulators, selection is not modeled in genome  <cit> . however, the backward-time simulators are generally faster than the forward-time simulators. for simulating disease status, both seqsimla and simrare allow the user to specify the odds ratios or population attributable risk for disease variants, the proportion of protective variants, the mode of inheritance, and the disease prevalence. for simulating quantitative trait values, seqsimla allows the user to specify the total phenotypic variance, the proportion of variance explained by each of the causal variants, and the mean of the trait values, while simrare allows the user to specify the deviations from the mean.

table  <dig> shows the comparisons of features between seqsimla and simrare. both tools provide multiple disease and quantitative trait models with flexible parameter settings. however, seqsimla has two major advantages over simrare. first, seqsimla can simulate three-generation families in addition to case–control data, while simrare simulates only case–control samples. therefore, seqsimla will be very useful for studying the statistical properties for family-based design. second, seqsimla is able to simulate different recombination rates between chromosomal blocks, while simrare assumes a fixed recombination rate. this feature in seqsimla will enable the user to simulate different linkage disequilibrium  structures among chromosomal blocks. on the other hand, simrare has some unique properties that can be potentially implemented in seqsimla. for example, the power comparison module allows the user to perform a power study based on existing and newly developed statistical tests, and the graphical user interface provides a user friendly interface for parameter settings.

CONCLUSIONS
we implemented two disease models in seqsimla, in which the user can flexibly specify the number of disease loci, effect sizes or par, disease prevalence, and risk or protective loci. we also implemented a quantitative trait model, in which the user can specify the number of qtl, proportions of variance explained by the qtl, and genetic models. we compiled recombination rates from the hapmap project, so that genomic structures similar to real data can be simulated. future development of seqsimla includes more flexibility in simulating family structures, such as twins or multi-generation families. seqsimla can be used as a complementary tool to simrare. if the user would like to perform a power study based on case–control design for new and existing statistical methods, simrare is ideal. if the user would like to perform a power study for family-based design, or to simulate causal variants in multiple genes with different ld patterns among genes, seqsimla is more suitable. in summary, as statistical methods for rare variant association analysis are developing rapidly, seqsimla will be useful for evaluating statistical properties for the new methods based on case–control or family designs. seqsimla will also be useful for power studies when planning association studies based on ngs.

availability and requirements
project name: seqsimla

project home page:http://seqsimla.sourceforge.net

operating system: unix, linux, windows

programming language: java

other requirements: java jdk 7

license: gnu gpl

any restrictions to use by non-academics: none

competing interests
the authors declare that they have no competing interests.

authors’ contributions
rhc was the primary author on the manuscript and designed the algorithm of the program. ccs contributed to the implementation of the software and discussions of the algorithm. both authors read and approved the final manuscript.

