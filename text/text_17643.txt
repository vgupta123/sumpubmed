BACKGROUND
microarray gene expression data has been analyzed in a wide variety of problems in bioinformatics fields. an important application is to develop a classifier to discriminate instances of different classes  <cit> . some classification approaches in machine learning have been applied on the microarray data sets, such as support vector machine , k-nearest neighbor , naive bayes, etc. the published microarray data sets, such as colon tumor  <cit> , gli-85/gse <dig>  <cit> , and breast cancer  <cit> , usually have high dimensionalities and small sample sizes because of the significant cost and effort required to collect and genotype specimens. for microarray data sets with ten thousands of genes but only tens of observations , reducing the high-dimensional gene space is an important issue in terms of classification. not all the genes make significant contributions to recognizing the target diseases, and only a few of genes with multiple genomic mutations determine biological or clinical properties  <cit> . gene selection can interpret the original characteristics of genes and improve the performance of classification by removing the irrelevant and redundant genes  <cit> . gene selection is equivalent to feature selection in pattern recognition and machine learning. many feature selection approaches have been used to select genes. traditional gene selection approaches rank genes based on some classic criteria, including t-test  <cit> , non-parametric statics  <cit> , p-value  <cit> , information gain  <cit> , etc. they can find the excellent genes and select the top ranked ones for discriminating the target diseases. recently, many effective approaches utilizing the filter evaluation framework have been studied by researchers .

the roc curve which is strongly related with non-parametric hypothesis testing has shown special attractiveness. as a non-parametric measure, roc curve has exhibited favorable evaluation characteristics on the imbalanced and cost-sensitive data classification problems  <cit> . this superiority is obtained mainly because roc curve compares classifiers’ performance through the entire range of class distributions and error costs. the roc curve and auc  have been widely used to determine the classification accuracy in supervised learning  <cit> . through analyzing a two-dimensional graph, it is hard to compare two roc curves directly. auc, which is denoted as a quantitative measurement, provides a good summary for examining the roc curves  <cit> . as a scalar measure, auc has been widely exploited to evaluate the relevance between features and target class in feature selection approaches, especially for the microarray data sets .

since roc curve and auc are effective in selecting discriminative features that make less recognition errors, dozens of feature selection approaches are proposed based on the two metrics. the feature assessment by sliding thresholds  approach  <cit>  and the statistical gene ranking approach  <cit>  use the technique of roc analysis to measure the relevance of features with the target class. they evaluate features by calculating the aucs of the single feature classifiers and then sort them in a descending order according to their auc values. the top-ranked features are selected into the feature subset. however, a significant flaw is that the selected features may highly correlate with each other, which are sometimes too redundant to be fed into a classifier. the auc and rank correlation coefficient optimization  approach  <cit>  and the feature selection based-on roc-curves  approach  <cit>  are both roc-based feature selection approaches, which consider the redundancy analysis that cannot be solved in fast. in arco, the redundancy between features is measured by the spearman’s rank correlation coefficient . features with maximum auc and minimum rcc are selected into the feature subset. however, rcc determines all instances’ ranks on two features without differentiating whether or not the instances are misclassified by the single feature classifiers. this leads to an inevitable problem, that is, redundant features may also have small rccs due to the instances which can be correctly classified by the single feature classifiers. in froc, features are ranked according to the area between the roc curve and the diagonal line  which is equal to auc− <dig> , and then the redundant features are eliminated using the markov blanket analysis. note that the redundancy between a pair of features is measured and reduced in terms of the area between the roc curves  by froc. for each feature in the candidate subset, froc computes its abr with other features, and the feature with minimal abr will be removed. this approach can find pairwise redundant features from the candidate subset, yet which one should be removed still remains a difficult problem.

the aforementioned approaches mainly focus on alleviating the redundant information of features, but ignore the global classification performance of the combination of the irredundant features. the roc curve of one feature may go above or under the curve of another feature, which may convey that this one is more or less discriminative than the other one. when the two curves cross, two features show to be complementary to each other in classification. when analyzing two features as given one feature as selected, we are only interested in whether another one is complementary in classifying the instances that the selected one cannot classify. in this case, the abr measure in froc turns to be inapplicable. this leads to the notion of feature complementarity, which is in some sense closely related to feature redundancy. from the classification perspective, complementarity evaluates whether a combination of features can return more joint information about the target class rather than the information carried by each feature individually  <cit> . intuitively, instead of examining the relevance between features for determining whether or not one is redundant with another, feature complementary is more direct and applicable in ascertaining the global classification abilities of the selected features. it is a promising way to improve the recognition performance of the roc-based approaches by evaluating feature complementarity for classification. in view of the above analysis, we propose a new feature selection approach based on the roc analysis for feature complementarity in this paper.

the proposed approach, named feature selection with auc-based variable complementarity , uses the technique of roc analysis to assess the relevance of features with the target class. moreover, it exploits the information of the instances misclassified by the single feature classifiers based on the roc curve to analyze the complementarity of features. apparently, when taking an individual feature as the observation dimension, more or less instances will be misclassified. thus, we lay the emphasis on the common misclassified instances for two features when evaluating their complementarity for classification. one nearest neighbor from different class  for each common misclassified instance is found out with respect to each feature. then, two manhattan distances for each common misclassified instance to its two nearest misses are compared, and the larger one is adopted to calculate the complementarity of the features. it should be pointed out that such technology of analyzing the nearest neighbors is also adopted by some state-of-the-art feature selection methods, such as relieff  <cit> , llbfs  <cit> , nnfrfs  <cit> , etc. intuitively, we average these manhattan distances for all the common misclassified instances and exploit them as two features’ complementarity. the instances misclassified by both features are focused on to lay stress on their influences on the accuracies of the classifiers. and the impacts of the instances that can be classified correctly by both features are reduced, because these instances provide little valuable information for recognizing the target class. in addition, we use the greedy sequential forward search approach to find the optimal feature subset, in which classes are maximally separated from each other. this issue is critical for enhancing the global discriminative performance of the selected feature subset. we compare our approach with four state-of-the-art feature selection approaches, that is, three popular approaches based on the roc curve, fast, arco and froc, and one well-known approach relieff. the experimental results on a broad range of the microarray data sets show that our approach can effectively select small feature subsets, and the performance of the classifiers built on these subsets is obviously improved.

methods
a complicated problem in the roc-based feature selection methods mentioned above is that the feature subsets selected by the existing methods cannot promise the global optimal performance for recognizing the target classes. to overcome this problem, we present a new feature selection method based on the auc and variable  complementarity analysis, which is called as feature selection with auc-based variable complementarity . avc combines the feature relevance and feature complementarity by making the best use of the non-parametric property of auc. in this section, we describe avc on the binary-class problem first, and then extend it to the multi-class problem.

before pinning down the method, some notions are lists as follows: 

x: the set of the instances, containing n instances {xi}i=1n characterized by m features f={fj}j=1m, and x
ij is the instance x
i’s observation value on the feature f
j.


c: the set of the classes, including q classes c={c
 <dig> …,c
q}∈i
r
n×q.


n
 <dig> n
1: the number of the positive instances and the negative instances in the data set. note that n=n
0+n
 <dig> 




roc curve
roc curve was first used in signal detection theory to represent the tradeoff between the hit rates and false alarm rates. it has been extensively studied and applied in medical diagnosis and evaluation of machine learning algorithms  <cit> . roc curves are two-dimensional graphs in which true positive rate  is plotted on the y-axis and false positive rate  is plotted on the x-axis. the good performance of a classifier is reflected by an roc curve which lies in the upper left triangle of the square. auc provides a value description for the performance of the roc curve. auc is a portion of the area of the unit square, so its value will always between  <dig> and  <dig>  and usually larger than  <dig>   <cit> . due to its several nice properties, auc has been used in feature selection for microarray analysis. firstly, auc is insensitive to the costs unknown problem, because it focuses on the comparison of the distributions of two classes. secondly, auc can be used to reflect how well the feature differentiates between the distributions of two classes. thirdly, auc is a non-parametric measure index, which is obtained by counting the tpr and fpr of the given samples. so it is appropriate to class imbalanced and costs unknown problems especially in bioinformatics. besides, the auc measure of performance is closely related to the gini coefficient  <cit> , which is most commonly defined as twice the area between the roc curve and the diagonal .

consider a binary classification problem with n instances and m features. to generate the roc curve of a classifier, the classifier gives every instance an estimated probability p^, that represents the degree to which an instance is a member of a class. there is a threshold t and the instances whose p^ are larger than t are predicted as positive class and others are predicted as negative class. for a fixed threshold t, there is a point  in roc space. if we vary t from  <dig> to  <dig>  and calculate tpr and fpr at each t, we can get the roc curve of the classifier. to computing auc, a direct method is to measure the area by applying a rectangle or trapezoid area on each point. but this is too complex and costly. hand, et al.  <cit>  has proposed a simple method to compute the auc. in this method, the instances are sorted in increasing order according to their p^. and the auc is calculated according to the eq. : 
  <dig> auc=∑i=1n0n0×n1=∑i=1n0ri−n0×2n0×n <dig>  


where r
i is the rank of the ith positive instance in the ranked list, and n
 <dig> and n
 <dig> are the numbers of the positive and negative instances. this method shows that auc is equivalent to the probability that a randomly chosen positive instance will have a higher estimated probability of belonging to the positive class than a randomly chosen negative instance.

in the cases of multi-class classification problems, there have been many extensions to the multi-class auc such as the average weighted auc  <cit>  and the volume under the roc surface  <cit> . a simple generalisation formulation of auc for multi-class classification problems was proposed in  <cit> . it has been widely used to evaluate the performance of classifiers  <cit> . mauc directly divides a multi-class problem with q classes into q <dig> binary-class sub-problems. auc of a binary-class sub-problem with the ith and jth class are represented by auc
ij and auc
ji. they are calculated by eq.  with the ith and jth class seen as positive class respectively. mauc is calculated according to the eq. : 
  <dig> mauc=1q∑i<jaucij+aucji. 


in the feature selection problem, when a method uses auc as the metric to evaluate the relevance between a feature and target class, the instances’ values for this feature are viewed as the output of a classifier which is equivalent to p^. if a feature is irrelevant to the target class, its auc is close to  <dig> , and if a feature is highly relevant to the target class, its auc is closer to  <dig>  we use auc for binary-class problem and mauc for multi-class problem to represent the auc of feature f
i in this paper.

binary-class problem
in feature selection, a single feature’s predictive power can be ascertained according to this feature’s classification performance taken individually as a classifier  <cit> . the single feature classifier built by feature f
j can choose a proper threshold θ. if x
ij≥θ,x
i is classified into the positive class. and if x
ij<θ,x
i is classified into the negative class. this critical parameter θ can be determined in terms of some metrics, such as auc, classification accuracy, etc. in this paper, auc is used to measure features’ predictive power which is superior in the evaluation of imbalanced and cost-sensitive data.

similar with arco, we also employ the auc of a single feature as the relevance metric. instances are ranked according to their observation values on feature f
i. and then, auc is calculated with eq. . figure  <dig> shows an example of the microarray data set colon  <cit>  for further illustrating the characteristic of auc. we can observe from fig.  <dig>  that, when θ= <dig> , a majority of instances can be correctly divided into two classes on the gene r <dig>  in fig.  <dig> , only about half of instances can be correctly divided into two classes on the gene u <dig>  even though when θ= <dig> , the maximal classification accuracy obtained by the gene u <dig> as a single feature classifier is equal to  <dig> . correspondingly, we can calculate the aucs of two features by eq.  as auc= <dig>  and auc = <dig> . considering the existing feature selection methods based-on roc curve, the larger the auc is, the more relevant feature f
i is with the target class. thus, we can assume that gene r <dig> is more relevant than gene u <dig> 
fig.  <dig> one-dimensional instances distribution. different distribution of instances on two features. the vertical lines represent the threshold θ of two single feature classifiers of two features.  shows the distribution of instances on gene r <dig> and  shows the distribution of instances on gene u33429




using auc as the criterion to measure the relevance of features and target class can find the most significant features to discriminate the given classes, but these features are sometimes too redundant to be inputted to a classifier. different from the existing roc-based feature selection methods which reduce feature redundancy, our approach avc analyzes features’ complementarity, which denotes the joint classification information provided by features. it is more or less than the sum of the information taken by features individually. our aim is to find out the most complementary features that jointly provide maximal classification information  <cit> .

in order to show the importance of feature complementarity, we take fig.  <dig> as an example. in fig.  <dig>  a group of artificial data sets containing  <dig> random instances characterized by different pairwise features are constructed. figure  <dig>  to  show the class distributions in different two-dimensional feature space. the histograms of the instances projected on the subspace constructed by the corresponding two features are demonstrated in fig.  <dig>  to , respectively. note that both classes have the same number of instances and submit to the gaussian distributions with equal covariance. it can be observed that when projecting the instances to different pairwise features, the class distributions are rather different. in fig.  <dig> , the distributions of the two classes overlap between each other. it means that a majority of the instances belonging to the two classes cannot be correctly recognized in the subspace constructed by feature f
 <dig> and f
 <dig>  in fig.  <dig> , the class conditional distributions have a high covariance in the direction of the line of the two class centers. we can see that classes also cannot be separated in the subspace of feature f
 <dig> and f
 <dig>  compared with fig.  <dig>  and ,  shows a special case, that is, one feature has completely overlapping class distributions. it means that neither feature f
 <dig> nor feature f
 <dig> can scatter two classes individually. yet all the instances can be correctly classified in the subspace collaboratively constructed by f
 <dig> and f
 <dig>  another special case is given in fig.  <dig> , in which two classes overlap perfectly no matter projected on feature f
 <dig> or feature f
 <dig>  similar with the case in fig.  <dig> , they can be separated perfectly in the subspace of the two features. thus, we can draw the conclusion from the subfigures  and  that, two individually inferior features can be superior when combined together. the histograms in fig.  <dig>  to  also exhibit this property as in fig.  <dig>  to . therefore, even if some individual features may have bad separability capabilities, their combinational feature subset may probably provide good class separability performance. just on the basis of this important characteristics of the features, our new approach avc pays emphasis on the complementarity between features in pair, which is expected to effectively improve the classification performance of the selected feature subset.
fig.  <dig> illustration of feature complementarity. 2-dimensional instances’ distributions on different combination of features:  to  describe the class distributions when the instances are projected to different pairwise features, and  to  are the corresponding histograms




it is critical to analyze the data distributions on pairwise features to evaluate the complementarity between them. as aforementioned, a feature’s auc indicates the distribution of the positive class and negative class on this feature dimension. if all the positive class instances rank higher than the negative class instances, auc will be equal to  <dig>  which means that all the instances can be correctly classified into two classes. if a feature’s auc is smaller than  <dig>  it implies that more or less instances will be misclassified by this single feature classifier. for a data set with n instances, there exist n
0×n
 <dig> instance pairs, in which a positive instance and a negative instance are simultaneously included. the special pairs in which the positive instances are ranked higher than the negative ones are drawn attentions from auc. auc actually denotes the ratio of these special pairs out of all the instance pairs. in the pair of instances that positive class instance ranked lower than the negative class instance, there must be a misclassified instance. we focus on the distribution of these misclassified cases under the different combination of features to find out the features which have the maximal complementarity of classification capability such as the features in fig.  <dig>  and . the basic idea is, if the instances from different classes that are close to each other on one feature dimension are far apart on another feature dimension, the two features are regarded as complementary to each other. in order to find out such features, we introduce a new metric to evaluate the complementarity between two features. this metric is based on the similarity of instances inspired by the state-of-the-art feature selection method relieff  <cit> , which adopts the nearest neighbor rule to evaluate features. we use the nearest neighbor rule on the set of the misclassified instances according to the single feature classifiers to analyze the complementarity between two features. specifically, the average manhattan distance between the misclassified instances and their nearest neighbors from the other class  are exploited to represent the complementarity between two features.

we use the matrix ℋ to represent the complementarity of the feature classification capability as follows: 
  <dig> ℋ≜0h12h13…h1m00h23…h2m⋮⋮⋮⋱⋮000…hm000… <dig>  


where h
ij is the complementarity between feature f
i and f
j, defined as: 
  <dig> hij=∑k=1|s|dk·mdxk,iik,ijk|s|,dk= <dig> iik=ijk <dig> iik≠ijk,mdxk,iik,ijk=maxdis,dis, 


where s is the intersection of instances misclassified by both feature f
i and f
j, and x
k is an instance in s. i
ik and i
jk are x
k’s nearest misses respectively obtained from the angle of features f
i and f
j, and dis is the manhattan distance between the two involved variables.

to get the intersection s, we focus on the set of misclassified instances of each feature. all instances are ranked according to their values of feature f
i and get the rank of instances {xr <dig> xr <dig> …,xrn}. then we consider the percentage of instances from each class in the sequence {xr|n/2|,…,xrn} and define the class with larger percentage as the positive class. clearly, we can simply classify the instances {xr <dig> xr <dig> …,xrn1} into the negative class and other instances into positive class. then, we can easily distinguish the misclassified instances whose predictive information is inconsistent with the original one. for each instance x
k in s, we find the nearest miss i
ik from dimension f
i and i
jk from dimension f
j. in the two-dimensional feature space, as shown in fig.  <dig>  we calculate the manhattan distance between two pairs of points  and , and use the larger one to compute the complementarity. if i
ik and i
jk are different instances as shown in fig.  <dig> , dis is taken as the complementarity, which is denoted as the red solid line in the figure. if i
ik and i
jk are the same instance as shown in fig.  <dig> , the distance is not involved in complementarity. this implies that the two features provide little complementarity to each other in classifying instance x
k.
fig.  <dig> illustration of the manhattan distance measurement used in avc. given that x
k is a misclassified instance in the intersection s. then we can easily find out its nearest neighbors on both features i
ik and i
jk.  shows that i
ik and i
jk are two separate instances. the red solid line represents the manhattan distance between two pair of points  and .  shows that i
ik and i
jk are the same instance, so we discard x
k in the next calculation




in eq. , the numerator of h
ij is the sum of distances over the instances in the intersection s, whose nearest misses are different according to the two features. the denominator of h
ij is the size of s. for any pair of strongly complementary features, the number of nonzero items in the numerator is equal or a little less than the size of s. but for the pair of features with weak complementarity, this number may much less than the size of s. evidently, it is reasonable that h
ij can be used to measure the complementarity between two features.

we illustrate the computation process of the complementarity by using a simple example data set in fig.  <dig> . the data set contains  <dig> instances, in which  <dig> instances belong to class “+1” and  <dig> instances to class “-1”. figure  <dig>  and  show the ranking results of these instances. in fig.  <dig> , the class “+1” is deemed as the positive class. correspondingly, the class “-1” is deemed as the negative class. we classify the top- <dig> instances to class “+1”, and classify the other  <dig> instances to class “-1”. then, we get the misclassified instances subset of f
i as {x
 <dig> x
 <dig> x
 <dig> x
 <dig> x
 <dig> x
16}. in fig.  <dig> , the class “-1” is taken as the positive one. so, the misclassified instances subset is obtained as {x
 <dig> x
 <dig> x
 <dig> x
13}. the intersection s includes the only one instance x
 <dig>  as shown in fig. 4
d. x
 <dig> is an instance of class “+1”. in fig.  <dig> , according to feature f
i we can find the nearest neighbor of x
 <dig> from class “-1” is instance x
 <dig>  in fig.  <dig> , according to feature f
j, the nearest neighbor of x
 <dig> from the class “-1” is instance x
 <dig>  the manhattan distance between pairwise instances  is “ <dig> ”, and the distance of  is “ <dig> ”. it is obvious that the manhattan distance between x
 <dig> and x
 <dig> is larger than that between x
 <dig> and x
 <dig>  so we use the distance dis to compute h
ij for feature f
i and f
j.
fig.  <dig> an example of artificial data set.  shows the instances’ values in the data set. in , instances are sorted according to the value of feature f
i. and in , instances are sorted according to the value of feature f
j.  shows the misclassified instances subset of sample data in , and s is the intersection of two subsets




the procedure of avc is illustrated in algorithm  <dig>  directly, we employ an efficient heuristic search strategy to select optimal features with highest complementarities. we select the most significant feature with the maximal auc at the initial state. then we iteratively select the features which have the maximal complementarities with the features selected in the prior state. in line  <dig> in algorithm  <dig>  when searching the optimal feature in the current state, we use the sum value of two features’ auc as their complementarity weight. the purpose is that, for a certain feature, if there are more than one feature have the same complementarity with it, we prefer to the one with the maximal auc value.

for the input data set containing n instances, the time complexity of calculating m features’ aucs of line  <dig> in algorithm  <dig> is o. for lines  <dig> to  <dig>  selecting the top- t
∗ features costs o time. then, for lines  <dig> to  <dig>  calculating h
ij for the t
∗ features costs o2) time. to get the optimal feature set, it takes o for lines  <dig> to  <dig>  usually, the number of the candidate features t
∗ and the number of the selected features t is much smaller than m and n. therefore, the complexity of the method is approximately equal to o.





multi-class problem
our approach avc can deal with not only the binary-class problem but also the multi-class problem. in this section, we use new strategies on the relevance analysis and complementarity analysis for the multi-class problem, which are different from those adopted in the binary-class problem.

as to the relevance analysis, we use mauc to measure the relevance between features and target class. as a metric to measure the performance of classifiers, mauc in eq.  is the average auc over all sub-problems that consist of pairwise classes. so in avc, a multi-class problem is also divided into a batch of binary-class sub-problems in one-versus-one manner, in which each sub-problem consists of a pair of classes. a multi-class problem with q classes can be divided into q <dig> binary sub-problems. we use the same way as the binary-class problem to calculate the mauc of features with eq. .

in the complementarity analysis, we should get the misclassified instances by each feature. for each feature, it corresponds to a misclassified instance set for each binary-class sub-problem. we use b
s
ab to represent the misclassified instance set of feature f
i in a binary-class sub-problem with respect to the ath class and the bth class. and we define the union of a feature’s misclassified instances sets in all binary-class sub-problems as the global misclassified instances set, which is represent by eq. : 
  <dig> ms=bs12⋃bs13⋯⋃bsq 


for each pair of features f
i and f
j, the intersection s is defined as s=ms⋂ms. same as the binary-class problem, for each instance x
k in s, we find the nearest miss i
ik from feature f
i and i
jk from feature f
j. note that we only use the nearest one no matter which class it belongs to. if we use the nearest neighbors from every other classes, such as the relieff method, it may bring some useless information to the complementarity analysis. suppose that some nearest misses of x
k have large distances f
i, they may make little contributions to the analysis of the complementarity. in order to find the features with the optimal complementarity, we only pay attention to the nearest neighbor from the closest different class.

for the input multi-class data set with n instances characterized by m features and classified to q classes, the time complexity of calculating m features’ mauc is o, corresponding to line  <dig> in algorithm  <dig>  since the other steps have the same computational complexity as the binary-class problem, the complexity of our method for multi-class problem is o.

RESULTS
benchmark data sets
we use  <dig> publicly available microarray data sets to evaluate the performance of the selected features, as shown in table  <dig>  these data sets are widely used in the studies of gene selection problems .



comparisons with the state-of-the-art methods
fast
fast  <cit>  is a feature selection method for small samples and imbalanced data classification problems. it directly calculates the auc of each feature by plotting the roc curve and summing up the area under it. for small samples data, in order to avoid the redundant thresholds, fast divides instances into k bins according to instances’ values and fixes the number of instances to fall in each bin. then, the mean of instances in each bin is used as the threshold to get the point  on the roc curve. after ranking the features according to their aucs in descending order, the top-k features are selected. although fast can perform well for some microarray data sets on svm and 1-nn classifiers, the computation process of auc is complex and imprecise. besides, fast does not take into account the redundancy in the feature set. fast can find the most significant features to discriminate given two classes, however, the selected features are sometimes too redundant. and previous studies have emphasized that considering both relevance and redundancy in the feature selection procedure leads to better feature subset in most cases  <cit> .

arco
for overcoming the problems in the fast feature selection method, wang et al.  <cit>  proposed arco feature selection method. arco uses eq.  to calculate the auc for each feature. in this way, arco not only guarantees the precision of the auc, but also simplifies the computational process. moreover, arco removes the redundant features using the spearman’s rank correlation coefficient . given two features f
 <dig> and f
 <dig>  arco sorts the instances on each feature based on their values. rcc can be calculated by eq. : 
  <dig> rcc=1−6∑i=1ndi2n×, 


where d
i is the difference between an instance x
i’s ranks on two features, and n is the number of instances.

to select k features from the whole feature set whose size is m, arco starts from the feature with the largest auc. it iteratively evaluates every previously unselected feature f
i with eq. , and selects the feature with the largest value of e: 
  <dig> e=auc−∑fj∈srcc|s|, 


where auc is the auc when taking the single feature f
i as a classifier, s is the current selected feature subset, and |s| is its cardinality.

in every iteration, aroc selects the feature with the smallest redundancy to the features in the subset. the redundancy is represented by the rcc, which mainly shows the different positions of instances on the two features’ ranking sequences. for two features, the large the difference is, the small the redundancy is. consider an extreme situation, two features can both classify all instances from two classes. on one feature, the values of instances from one class are all larger than instances from the other class, but on the other feature these values are smaller than the others. we can see that ranks of the instances are totally different on the two features, so the rcc of them indicates that they are not redundant. but to build a classifier, any one of them is enough to separate all instances. so sometimes arco cannot exactly recognize the redundant features. and it is necessary to differentiate the correctly classified and misclassified instances by each feature.

froc
another feature selection method based on roc analysis is froc  <cit> , which is developed to overcome the redundancy problem in small samples microarray data sets. this method also has two steps. the first step is a one-gene-at-a-time filtering which uses the roc curve as a criterion to evaluate the relevance of features to the target class. different from arco, froc chooses to calculate the area between the roc curve and the diagonal line , which is equal to auc− <dig> . instances are also sorted in increasing order according to the values for feature f
i and ard is calculated by eq. : 
  <dig> ard=∑i=1n1qi−2in0×n1=∑i=1n1qi−n1×n0×n <dig> 


where n
 <dig> and n
 <dig> are the numbers of positive and negative instances respectively, and q
i is the rank of the ith negative instance. all features are sorted by the ard of feature f
i in descending order and the top of the sorted features are chosen as a candidate feature set. the second step in froc is a roc-curve-based markov blanket filtering. this step removes the redundant features using the definition of markov blanket that if m
i is a markov blanket of f
i, the probabilistic distribution p of classes is invariant under no matter what value f
i takes: 
 pf−mi−{fi},c|fi,mi=pf−mi−{fi},c|mi. 


froc uses the area between the roc curves  to measure the redundancy of two features. for example, abr of two features is the gray area in fig.  <dig>  the smaller the abr is, the more redundant the two features are. froc iteratively removes the redundant features from the candidate feature set selected in the first step.
fig.  <dig> abr of two features. the gray area is the abr area, and two curves are the roc curves respectively obtained by two features




in  <cit> , the author argued that it is not able to find an exact markov blanket of a given feature. the alternative method is to find an approximation to markov blanket of the feature. this may cause a problem that after finding out the redundant features, removing different features may bring different influence to the combination of features in subset when building the classifier. to overcome this problem, the analysis on the complementarity of feature classification capability maybe a feasible choice.

experimental settings
the efficacy of our new method avc was empirically evaluated by comparing it to four state-of-the-art feature selection methods. three methods, fast, arco and froc, are all based on the roc curve and auc. these three methods are all particularly designed for the binary-class classification problems. so in our experiments, we extend them to solve the multi-class classification problems with the same strategy as our method. that is, for the multi-class problem, the mauc of features will be computed by eq. . the fourth method is relieff, which has been widely used as the compared algorithm that uses the criterion of preserving sample similarity  <cit> . we compare the performance on four widely used classifiers to test the robustness of the five methods. the classifiers are naive bayes, support vector machine , 1-nearest neighbor  and c <dig>  decision tree. due to the small number of instances in these microarray data sets, we use 10-fold cross-validation to evaluate the classification performance of the classifiers.

we perform our comparisons in two sub-experiments. in the first sub-experiment, we compare four feature weighting methods, i.e., avc, fast, arco and relieff. these methods select features according to their weights, so we evaluate their classification performance in the condition of increasing the number of features. in the second sub-experiment, we evaluate their classification performance in the condition of fixing the number of features determined by froc. froc is a method which selects a feature subset rather than evaluating features individually, so we fix the number of features to the size of the feature subset selected by froc.

to avoid the influence of the imbalanced class issue on the classification accuracy, we choose the balance error rate  metric  <cit>  to evaluate the performance of the classifiers on both classes for the binary-class problem, which is defined as follows: 
  <dig> ber=12fpfp+tp+fnfn+tn, 


where fp, tp, fn, and tn are respectively the false positive, the true positive, the false negative, and the true negative. if the classes are balanced, ber is equal to the global error rate. for the multi-class problem, ber can be computed as follows: 
  <dig> ber′=1q∑l=1qnflnl, 


where n
l is the number of the instances in the class c
l, and nfl is the number of the misclassified instances in c
l. another evaluation statistic commonly used on microarray data sets is the area under the roc . this statistic is similar in nature to the ber in that it weights errors differently on the classes. then, we explore the wilcoxon signed-rank test to compare avc with the other three methods, and the significance level is set to  <dig> .

we used the well-known weka software package  <cit>  as our experiments’ platform. our method and other compared methods are all implemented at this platform. for fast and relieff, we select the top- <dig> features as the final feature subset. for arco and our method, we select the top- <dig> features as the candidate feature subset, and select the top- <dig> features as the final feature subset. for froc, we also select the top- <dig> features as the candidate feature subset and the final feature subset is selected from these features. in relieff, every instance is used to update the weights of features and for every instance we find ten nearest neighbors from both the same class and the different classes.

experimental analysis
the classification performance is illustrated in figs.  <dig>   <dig>   <dig> and  <dig>  for the binary-class classification problems, we test across the six binary-class data sets shown in table  <dig>  which are col, cns, lek, ova, gli and brc. we examine  <dig> groups of features with different size in each test. when the size is smaller than  <dig>  we add a feature every time. after the size is larger than  <dig>  we add five features every time until the size is equal to  <dig>  then the averaged performance of each classifier with each data set is calculated. figures  <dig> shows the ber scores for the six binary-class data sets with respect to the four classifiers. we also use auc to evaluate the classifiers on test data. figure  <dig> shows the auc scores averaged over the six binary-class data sets with four chosen classifiers. for the multi-class classification problems, we experiment on the seven multi-class data sets in table  <dig>  i.e., lym, all, car, br <dig>  cll, mll and lun. we examine  <dig> groups of features with different size in each test, and every time we add  <dig> features. same as the binary-class classification problems, we also use the ber and auc to measure the performance of classifiers. figure  <dig> shows the ber scores for the seven multi-class data sets with four classifiers and fig.  <dig> shows the mauc scores averaged over these seven multi-class data sets.
fig.  <dig> averaged ber on binary-class data sets. averaged ber value of the four classifiers on the six binary-class data sets using four classifiers. we choose  <dig> feature subsets with increasing number of features


fig.  <dig> averaged auc on binary-class data sets. averaged auc value of the four classifiers on six binary-class data sets using four classifiers. we choose  <dig> feature subsets with increasing number of features


fig.  <dig> averaged ber on multi-class data sets. averaged ber value of the four classifiers on seven multi-class data sets using four classifiers. we choose  <dig> feature subsets with increasing number of features


fig.  <dig> averaged mauc on multi-class data sets. averaged ber value of the four classifiers on seven multi-class data sets using four classifiers. we choose  <dig> feature subsets with increasing number of features




the average results in figs.  <dig> and  <dig> for binary class classification problem demonstrate that avc significantly outperforms the other compared methods. the features selected by avc reach the best performance with less than  <dig> features, which are much smaller than the number of the features selected by other three feature selection methods. and with more than  <dig> features, although avc features do not improve the ber metric or auc metric of the classifiers, its performance is still better than the three compared feature selection methods. our method is based on the analysis of the roc and auc, so it is reasonable to believe that a learning method using avc-selected features would also maximize the auc.

the average results in figs.  <dig> and  <dig> for multi-class classification problems show that avc features also performe well when the size of feature subset is small. when using the naive bayes classifier, svm classifier and 1-nearest neighbor classifiers, with less than  <dig> features avc performs better than the other three feature selection methods. with more than  <dig> features, the differences between avc and the other compared algorithms are not significant. when using the c <dig>  decision tree classifier, feature subsets selected by different methods perform much different. the feature subsets selected by avc get the best performance when their size is about  <dig>  which is better than other three methods for all  <dig> different sizes of feature subsets.
table  <dig> minimal ber of the four classifiers in the top- <dig> features on the benchmark data sets

col
lym
all
cns
lek
car
br5
cll
mll
lim
ova
gli
brc
avc
 <dig> 
 <dig> 
 <dig> 
0
 <dig> 
 <dig> 
 <dig> 
 <dig> 
 <dig> 
 <dig> 
fast
arco
 <dig> 
 <dig> 
 <dig> 
relieff
avc
 <dig> 
0
 <dig> 
0
 <dig> 
 <dig> 
0
fast
 <dig> 
 <dig> 
arco
 <dig> 
0
 <dig> 
 <dig> 
relieff
avc
 <dig> 
 <dig> 
 <dig> 
 <dig> 
 <dig> 
 <dig> 
fast
0
 <dig> 
arco
 <dig> 
 <dig> 
relieff
 <dig> 
 <dig> 
avc
 <dig> 
 <dig> 
 <dig> 
 <dig> 
 <dig> 
fast
 <dig> 
 <dig> 
arco
 <dig> 
 <dig> 
 <dig> 
relieff
 <dig> 
 <dig> 
 <dig> 
bold data in the table reflect the minimal ber of four classifiers in the top- <dig> features selected by four compared feature selection methods on the benchmark data sets


col
lym
all
cns
lek
car
br5
cll
mll
lim
ova
gli
brc
avc
fast
arco
relieff
avc
fast
arco
relieff
avc
fast
arco
relieff
avc
fast
arco
relieff


fig.  <dig> wilcoxon signed-rank tests on binary-class data sets. the results of the wilcoxon signed-rank tests on six binary-class data sets with  <dig> groups of selected features


fig.  <dig> wilcoxon signed-rank tests on multi-class data sets. the results of the wilcoxon signed-rank tests on seven binary-class data sets with  <dig> groups of selected features




figures  <dig> and  <dig> show the class distributions of the colon cancer data and all-aml- <dig> data with the two best features selected by four methods, respectively. the classes in figs.  <dig>  and  <dig>  are scattered and have little overlapping, which makes it easy to find the optimal boundaries between them. but in figs.  <dig>  to  and  <dig>  to , instances from different classes are overlapping so that it is difficult to classify them by some certain boundaries. this may explain why our method can perform well with a small size of feature subsets.
fig.  <dig> instances distribution of colon cancer data with the two best features selected from four feature selection methods,  shows the instances’ distribution on the best two features selected by avc,  shows the instances’ distribution on the best two features selected by fast,  shows the instances’ distribution on the best two features selected by arco, and  shows the instances’ distribution on the best two features selected by relieff


fig.  <dig> instances distribution of all-aml- <dig> data with the two best features selected from four feature selection methods,  shows the instances’ distribution on the best two features selected by avc,  shows the instances’ distribution on the best two features selected by fast,  shows the instances’ distribution on the best two features selected by arco, and  shows the instances’ distribution on the best two features selected by relieff



table  <dig> averaged ber and auc of the four classifiers on the benchmark data sets

avc
fast
arco
relief
froc
nb
 <dig> 
svm
 <dig> 
1-nn
 <dig> 
c <dig> 
 <dig> 
nb
 <dig> 
svm
 <dig> 
1-nn
 <dig> 
c <dig> 
 <dig> 
bold data in the table reflect the minimal averaged ber and auc of four classifiers in the feature subset selected by five compared feature selection methods on the benchmark data sets




evaluation with lda and mclust
some classifiers can account for the high correlations among features appropriately, such as lda  and mclust . in this sub-experiment, we further evaluate the performance of avc on this kind of classifiers.

we experiment across the thirteen data sets shown in table  <dig>  we examine  <dig> groups of features with different sizes and increase the number of features from  <dig> to  <dig> in interval of  <dig>  figure  <dig> shows the averaged accuracy of the thirteen data sets. the blue line named as top-k reflects the performance of the top-k features with maximal auc. features are sorted according to their auc scores and the top-k features are selected without any redundancy reduction process. the red line reflects the performance of avc. we can observe that avc leads to higher accuracy in all the cases.
fig.  <dig> averaged accuracy of the lda and mclust classifiers. averaged accuracy value of the lda and mclust classifiers on thirteen data sets. we choose  <dig> feature subsets with increasing number of features




besides, fast is a feature selection approach which simply selects the top-k features with maximal aucs. generally speaking, as shown from figs.  <dig>   <dig>   <dig>  and  <dig>  it is clear that fast performs inferior to the other feature selection methods, which involve feature redundancy or complementarity analysis in their selection processes. thus, we can draw the conclusion that reducing feature redundancy or improving feature complementarity conduces to better recognition performance. the feature selection methods exploiting these tricks outperform the top-k methods without any further evaluation strategies. this property still holds on the situations that the feature-correlation-based classifiers are employed for measuring the discriminative performance of the selected features.

CONCLUSIONS
we propose a new feature selection method specific to the recognition problems in the microarray data sets. this method ranks the features according their relevance to the class label and the complementarity between each other. the roc curve and the area under the roc curve  are exploited to evaluate the relevance between a feature and the class label. then the distribution of data on a pair of features is analyzed to measure the complementarity of the pair of features. moreover, the greedy searching strategy is also implemented for finding out the predominant features.

the experiment results show that when the number of selected features is small, the features selected by our method can achieve a better classification performance compared with the state-of-the-art methods. moreover, it is illustrated from the experiments that the reduced subspace constructed by our new method is suitable for the recognition task, in which the classes are mostly separated from each other and a significant boundary between classes can be easily found.

abbreviations
abrarea between the roc curves

ardarea between the roc curve and the diagonal line

arcoauc and rank correlation coefficient optimization

aucarea under the roc curve

avcauc-based variable complementarity

berbalance error rate

fastfeature assessment by sliding thresholds

fprfalse positive rate

frocfeature selection based-on roc-curves

knnk-nearest neighbor

rccspearman’s rank correlation coefficient

rocreceiver operator characteristic

ldalinear discriminant analysis

maucmulti-class auc

mclustmodel-based clustering method

svmsupport vector machine

tprtrue positive rate

