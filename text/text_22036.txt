BACKGROUND
the development of high-throughput array-based technologies such as sga analysis  <cit>  has led to a rapid increase in the popularity of systematic genome-wide genetic interaction screening in yeast. in a typical sga experiment, a query yeast strain containing a single specified gene deletion is mated to the yeast haploid deletion collection of ~ <dig> individual gene deletion mutants arrayed in colonies on agar plates. following diploid selection, sporulation and selection of haploids, a complete set of double mutant strains is generated, which can be used to define the spectrum of genetic interactions for the query gene, thus providing unbiased information about its function in the cell. in recent years, the availability of relatively low-cost robotic platforms such as the singer rotor hda  has led to the uptake of this technology by an increasing number of non-specialist laboratories. however, the lack of availability of specialized software for the analysis and quantitation of array colonies has hampered these efforts.

in an sga experiment, after completion of the robotic pinning steps the experimenter is presented with a substantial number of agar plates containing ordered arrays of differently sized single and double mutant yeast colonies. the relative size of the colonies represents the fitness of each strain, which can be used as measure of the strength of a genetic interaction. in order derive meaningful genetic interaction data from these arrays, the size of each colony needs to be precisely measured and the data normalized and compared with an appropriate control. given that a single sga experiment can result in numerous  replicates of arrays, each containing up to  <dig>  colonies per array, it is desirable that such analyses can be carried out in a high-throughput manner with as much automation as possible. nevertheless, most experimenters will want some degree of control over the measurement process, so providing a level of interactivity will improve overall confidence in the final results.

one problem we encountered when we first attempted to analyze images using existing software packages  was that they tended to be designed with a particular image format in mind. although they were effective at analyzing sample images provided with each program, we were unable to analyze images that we had obtained ourselves. furthermore, if the software was unable to identify the colonies on a plate, the program would fail with little recourse available. while these programs present a simple interface to the user, it is not possible to adjust the imaging parameters that might enable successful analysis of an image.

to that end, we sought to develop a program “balony”, that would be able to analyze images regardless of their specific properties, and with the flexibility to utilize arrays of any possible format. although we find that the default settings used by balony are suitable for analyzing most plates, the ability to manually adjust image analysis parameters allows users to quantify even the most troublesome images.

as a demonstration of the flexibility of our image analysis engine, we were able to use balony to successfully quantify the example image plates provided with both screenmill  <cit>  and sgatools  <cit> , while neither of these packages were able to analyze the sample images provided by any of the other programs.

we also sought to design a program that would enable the complete analysis of a screen, from scanned images of plates to an interactive display of genes of interest, all from a single interface. while both screenmill and sgatools necessarily involve using external web services to carry out some or all portions of their data analysis, balony operates as a single, stand-alone window making it easy to switch between modules to monitor the effects of adjusting settings. although this software is primarily aimed at analyzing high-throughput experiments in yeast, it could also be employed for use with any system that utilizes high-density arrays of microbial colonies.

implementation
balony is a stand-alone java program, which uses libraries from various sources, most notably the imagej library for image manipulation  <cit> , and the apache commons mathematics libraries for statistical analysis. the program has a modular structure, shown in figure  <dig>  data files are generated at each stage of the analysis and can be inspected at will. if a user so chooses, they can merely use parts of the balony package to measure colony sizes and perhaps perform normalization, and then use their own scripts or programs to further score their data.

the data flow starts with composite images of multiple plates or single images of individual plates. in the case of composite images, the “scan” module converts these to images of single plates. this can speed up the image acquisition stage of the analysis by allowing the user to capture images of up to four plates at a time. these images are then analyzed by the “image” module which produces a text file containing raw data listing the pixel area of each colony in each image. these text files are then used as inputs for the “scoring” module which pairs control and experimental data sets and performs normalization to produce one or more tab-delimited text files containing the normalized colony sizes for the experiment. this data can then be viewed directly  or analyzed using the “analysis” module. this enables collation of multiple sets of data and further refinement, e.g. by removal of genes linked to the query gene in an sga experiment. cut-off values to determine “hits”, p-value thresholds and reproducibility across data sets can also be defined to precisely determine “hit lists” of genes. the analysis module enables the direct inspection of individual data points, providing gene information from the saccharomyces genome database   <cit> . the main window of the program is divided into five tabs which are used to sequentially analyze data .

image segmentation: the scan tab
the “scan” section of balony allows users to take composite images of multiple plates and subdivide them into separate images for analysis . we find that images of plates are best captured using a flatbed scanner as the reduced depth of field of a scanner compared to a digital camera results in less optical distortion of the images. it is advisable to scan plates with a black background  to improve contrast between the colonies and the agar.

we find that a final resolution of  <dig> dots per inch  is sufficient for most applications, although for ultra-high density experiments using arrays with  <dig> colonies per plate , higher resolutions may be required. in general, processing time increases with image resolution, and the extra information above  <dig> dpi is unlikely to provide more robust data as the inherent variance in the size of yeast colonies will be more significant than any additional fine detail gained.

when performing sga experiments we use a variety of terms to describe the components of an experiment. each array consists of a number of agar plates. for example, the haploid yeast deletion mutant array  consists of four plates when arrayed at a density of  <dig> cpp, which we would simply refer to as plates 1- <dig>  replicates of each plate are termed sets. thus in a typical sga experiment, one might produce three replicates of a query strain crossed with the dma, i.e.  <dig> sets of  <dig> plates.

to ease downstream processing of images it is important that files are named systematically . input files should be named according to the template “screen_setx.jpg”, which will result in output files with the format “screen_set-x_plate-y.jpg”. if there are more than four plates per set, an offset value can be included in the file name which will be added to each plate number. for example, a file named “yfg1_set1_ <cit> .jpg” will by default number plates starting at  <dig> . however, plates can also be scanned individually, in which case each set of plates should be named in the format “screen_setx_platey.jpg”.

plates can be rotated automatically to ensure the correct orientation with respect to gene index files as the subsequent analysis steps assume that the top left position of a plate is identified as “row  <dig>  column 1”. images can also be resized and, if they are not already, converted to greyscale. by default, the individual plate image files are named according to a scheme to enable tracking of the plate and set number, which is recommended to ensure easy identification of plates in the colony measurement section . however, the “base name” and each individual plate name can be overridden if necessary.

an entire folder of composite images can be analyzed in batch mode to reduce the amount of user input required at this stage. processing time is dependent on a number of factors, such as the resolution of the input images and the speed of the computer, but should not take more than a few minutes for a typical screen.

the user can define different mappings which define how the position of a plate in the scanned image is converted into a plate number based on an array index. the default setting is shown in figure 2b and is ideally suited to the deletion collection maintained at  <dig> cpp format as this consists of exactly four plates. it is important to remember that a scanned image will usually be reflected about its y-axis, so it is advisable that the first time a user uses this module that they visually check that the plates are correctly assigned and oriented in order to prevent mishaps further downstream. if the mapping needs to be changed from the default setting, the new assignments will be remembered for future analyses.

colony measurement: the image tab
balony uses a multi-step process to measure colony sizes on individual plate images. each step can be customized with varying parameters which enables a high degree of compatibility with plates from a variety of sources. the measurement process identifies colonies as elliptical objects, measures the pixel area of each object, and assigns the object to a grid position. the raw data  are saved for subsequent normalization, scoring and analysis. this process can be automated completely, requiring little to no user input, but if this approach is not proving fruitful, each plate can be analyzed manually using a variety of tools to give fine-grained control of the analysis process.

this panel shows a list of image files in the currently selected folder. a colour-coding and suffixing scheme is used to help the user identify which files have been analyzed. if a file has not yet been analyzed, then the filename will simply be displayed in black. if a file has been successfully analyzed, then it will be displayed in green and suffixed with . if a file has been analyzed, but with a certain number of colonies that could not be correctly measured  then it will be displayed in orange and suffixed with , as long as the number of bad spots is below a threshold value. this indicates that a plate has a small number of imperfections that may warrant closer inspection. if the number of bad spots is above the threshold value the file name will be displayed in red and suffixed with . this is usually indicative of a plate which had significant defects, or the program was unable to analyze automatically. the steps necessary to analyze an image are described below.

format correction
the image measurement process requires yeast colonies as black ellipses on a white background. upon opening, images will be converted automatically to greyscale if they are not already in this colour format. as the colonies are usually lighter than the background, the image then needs to be inverted. this can be carried out automatically for each plate and is recommended.

upon loading an image, balony will attempt to decipher the file name to determine a name for that particular experimental set as well as the corresponding set and plate number. this unique name will be the same for all plates across sets for an individual experiment and is generated by stripping away the “set” and “plate” parts of the image file name. it is important that this information is consistent between all plates from a given experiment as the information is written into the meta-data saved after each image is analyzed and is used by the scoring module to identify plates of the same experiment. however, this option can be disabled if so required.

thresholding
images are converted to black-and-white using a procedure known as “thresholding”, which separates the agar plate background from the yeast colonies. in this process each pixel in the image is converted to either black or white depending on whether it falls below or above a defined grey level. the images at this stage are stored at a colour depth of eight bits per pixel, so the grey level will have a value of between  <dig> and  <dig>  as in other programs, balony can automatically define this threshold level using an algorithm based on a digital histogram of the image. additionally, we have provided an option for the user to manually specify this grey level which can salvage the analysis of an image which would otherwise fail if automatic thresholding is not successful. generally, if the thresholding is not successful, it is because the grey level selected is too high, resulting in the plate background merging with the yeast colonies. there is an option to automatically attempt to re-analyze the image with decreasing threshold values until the plate is successfully analyzed. however, care must be taken with this as if too low a value is used then there is a danger of discarding colony size information.

gridding
arrays of yeast are indexed by identifying each strain in terms of its row and column position in a grid, and optionally, a plate number. therefore, a gridding step is required to identify the region of the image that contains the arrayed colonies. balony contains extensive controls not found in other programs to assist in the correct placement of the grid, so that even if an array contains unusual features that may make automatic grid identification difficult  manual intervention can resolve this.

the software is supplied with a number of grid presets corresponding to the most commonly used formats in use, namely  <dig>   <dig> and  <dig> cpp. new presets can be defined and calibrated from sample plates. balony can usually automatically determine the grid position using a particle identifying routine; however, if a plate is proving problematic, the user can manually specify the position of the grid.

the first time a user runs the program and loads an image, they will be prompted to either use an existing preset, or define a new one that matches their particular image acquisition platform. the latter option is recommended as it allows for a more precise fit for different types of imaging hardware. the user will be prompted to enter the dimensions of the array , and then draw a box on the plate image to indicate the boundaries of the array. following this they will be prompted to name and save the settings derived from this. the most important values from this are the mean spacing  between colonies in the horizontal  and vertical  dimensions.

should a user not wish to use the automatic gridding process, or find it ineffective for their plates, they can indicate the position of the array manually, either by dragging a box from one corner to an opposite diagonal corner; or by positioning a grid of fixed dimensions.

after the gridding process has been completed, a grid is drawn over the thresholded image in green . if required, this grid can be moved into a different position using the cursor keys. the user can decide if the gridding process should proceed automatically after a plate has been thresholded. this generally speeds up the quantification process, but it may be advisable not to use it for the first few images so that the user has an opportunity to observe the different steps involved.

colony assignment and measurement
next, colony sizes are measured by analyzing all particles within the grid array and mapping them to their nearest  position within the array. parameters can be set to ensure certain criteria are met for a particle to be identified as a colony, including minimum pixel size, circularity and deviation from the grid position. if a grid position appears not to have a colony present in that position, the program will re-scan that position to look for the presence of an object. this is sometimes necessary because overgrown colonies can and merge with neighbouring colonies and no longer appear as a discrete entity.

this process is usually sufficient to identify the colonies on a plate. however, if there are many grid positions that appear to contain something that does not satisfy the minimum criteria for a yeast colony, the software will offer the option of a low-stringency pass that will attempt to quantify the amount of growth occurring in a position, regardless of its circularity. care should be taken with this option as blemishes on the plate surface may then be counted as colonies.

when this process is complete, the successfully quantified colonies are shown by outlining each colony in green over the original input image . the user can toggle between this final image and the gridded, thresholded image which can be useful to confirm that the gridding and thresholding processes were accurate.

upon satisfactory quantification of an image, a tab-delimited text file is saved which contains the area of each colony  for each row and column position. the resulting data file can be viewed from within the program if so desired.

the colony measurement process can be performed in batch using a set of default parameters to process an entire folder of images. after doing this, a log file is generated which can be inspected to review any problems that occurred during analysis. on a typical test set up, a  <dig> cpp plate scanned at  <dig> dpi takes approximately three seconds to analyze.

there are some additional features to aid with problematic images. if an image requires rotation, this can be achieved manually by a process which uses the positions of two colonies within the same row to determine the appropriate angle required to correct the orientation of the plate.

any existing quantitation of a colony can be manually overridden by drawing an ellipse over the colony. the image can be zoomed to help with this. additionally, if the particle finding algorithm rejected a particular grid location, it will be highlighted as a red square to draw attention to a position that may require this manual intervention. colonies that have been manually defined are highlighted in magenta to differentiate them from those automatically quantified by the program.

data scoring: scoring tab
by default the scoring module will search the folder last used by the image module to load files, although a different folder can be selected. the saved quantitation data files are analyzed to find sets of data corresponding to experimental plates. the user can then select which sets will comprise the control and experimental data and load them by selection from a drop-down menu. upon loading, the software will normalize each plate of data and align the corresponding control and experimental data to produce paired sets.

the scored data can be saved in a variety of ways, listed either by colony grid position  or by the name of the orf pertinent to each strain. in the case of multiple replicates of the same orf, the mean area will be saved, along with the standard deviation. additionally the user can select between two methods for saving experiments comprising multiple sets of plates. the recommended option is to save a separate file for each paired set of data as this retains the most information on individual colony sizes. however, it is also possible to combine multiple data sets, in which case the mean area and standard deviation will also be saved.

the scored data files also specify the gene at each position in the array. this requires a key file that maps the position of each colony in the array to a yeast orf. the format of the key file is a tab delimited text file with four or five columns, with each row containing the following data:

•column 1: plate number

•column 2: row number

•column 3: column number

•column 4: systematic orf name 

•column  <dig> : standard gene name 

an example key file, “ubc- <dig> key” is included with the program. if the gene name is not specified the software will attempt to determine this from the file “sgd_features.tab” which is found in the same folder as the program files. this file can be updated with the latest information from sgd from within the analysis module . if the file is over  <dig> days old, the program will prompt to download a new version. the “refresh data” button will force the program to reload and score the selected control and experimental data files.

screen analysis
the final component of balony is the analysis module . this enables the scored data from an experiment to be interrogated to identify positive and negative genetic interactions. the analysis module requires that each paired data set  is saved as a separate file as this ensures that quantitative data is saved for each individual colony. this is necessary for statistical analysis of colony sizes.

users can elect to open all or a limited sub-set of scored data sets, which may be useful on occasions if there was a suspected technical problem with the plates of a particular set. after selecting files to load, the user is presented with a new window showing a table of the scored data. the data table will show averaged data for each array position along with the systematic orf name and the standard gene name, the mean and standard deviation of the sizes of the control and experimental colonies at this position. the ratio  is displayed as an indication of the extent of any genetic interaction; this is followed by the number of replicates in which the ratio is either below or above a cut-off value.

the difference in colony sizes  is also shown, which is analogous to the standard multiplicative score used in other protocols  <cit> . this is followed by the p-value obtained by performing a paired two-tailed t-test testing for a difference between the normalized colony sizes of the experimental strains vs. the normalized colony sizes of the control strains. finally, whether this position is deemed to be a “hit”  is indicated, followed by a column that will state if a position should be excluded from the analysis. these data can be sorted by any of these criteria.

in the case of sga screens it is useful to define gene linkage at this stage and remove these genes from the analysis. this is accessed from the “filtering” panel which opens a separate window displaying a graphical representation of the colony sizes of double mutants in genes that flank the query gene. because of the reduced rate of recombination between linked genes , fewer double mutant cells are generated compared to unlinked genes, which leads to a characteristic decrease in colony size for these flanking linked genes  <cit> . the users then specifies the range of genes which are to be excluded from the analysis to prevent them from being reported as false positives. in addition, genes can be excluded manually by the user if they are known to be problematic or false positives for some other reason. genes that have been excluded from the analysis can be shown or hidden using a toggle switch.

analyses may benefit from discarding data where the control strain has very poor growth. in these cases it can be difficult to be sure a genuine synthetic lethal interaction is being observed when the growth of the control strain is particularly slow. this filtering can be based on the growth of the control strain, the experimental strain or both strains; this allows for flexibility if the read-out of a screen is something other than synthetic lethality. if the data is to be discarded, the size of both colonies for that paired set is set to zero to exclude them from further analysis.

in addition, maximal and minimal values may be assigned to colony sizes. this is useful if the ratio between colony sizes is being used as a measure of fitness. in the case of a strong aggravating  interaction, the double mutant may be essentially dead. however, there will still be a small amount of yeast present on the plate from the original pinning step. as this amount will vary between different colonies, this can lead to the impression that one synthetic lethal interaction is stronger than another, whereas in fact they are both reporting the same phenotype, i.e. no growth in the double mutant. by assigning a minimum value, all truly lethal interactions will have a similar score.

following this, the user may wish to define cut-off values to define “hits”, which in the case of sga experiments, are genetic interactions. while the difference between experimental and control colony size is often used as a measure for the strength of a genetic interaction, we have found that calculating the ratio of experimental to control colony size is a useful alternative. we find that this parameter is less influenced by the growth rate of control strains. for example, consider two strains ∆x and ∆y which grow with normalized colony sizes of  <dig>   and  <dig>  respectively. if a second mutation is introduced so that the double mutant strain ∆x∆z grows to a colony size of  <dig> , and the ∆y∆z strain grows to  <dig> , it is clear that this mutation has had a greater effect on the ∆y strain than ∆x as it has led to a halving of the growth rate of the ∆y strain. however, if we were to report the difference between colony sizes, then both double mutant strains would yield a difference value of  <dig> . in contrast, by using a ratio score, we find values of  <dig>  and  <dig>  for ∆x∆z and ∆y∆z, respectively, reflecting the relative strength of the observed genetic interactions.

using the analysis function, two types of hits are distinguished between; those where the ratio is below a cut-off value  and those where the ratio is above a second cut-off value . if there is no genetic interaction, the ratio will be close to  <dig>  a plot showing the distribution of ratios can be displayed to aid in screen validation. when first loaded, data files are sorted by array position, so that the distribution of ratios can be inspected to check for any systematic effects. normally, it is expected that the variance between colonies would be distributed randomly, so if any trends are apparent, it is indicative of a systematic effect from either the pinning or imaging process. when arranged by ascending ratio this plot forms a characteristic curve with a steep initial portion representing aggravating interactions which levels off to a portion with a shallow gradient indicating no significant interactions, and then once again returns to a steep portion representing alleviating interactions. the software can estimate an appropriate cut-off value by extrapolating the linear central portion of the distribution and finding the y-intercepts at either end of the x-axis. once these values have been determined, the data table will highlight “hits” in the screen based on criteria chosen by the user. the three criteria for a hit are:

 <dig>  the ratio is below the low cut-off value  or above the high cut-off value  as described above.

 <dig>  the number of replicates in which criterion  is met must be equal to or above a specified value .

 <dig>  the p-value from a paired t-test of the sizes of the experimental colonies and the control colonies must be below a given value.

if all three criteria are met, then hits are highlighted in the table . the table can be sorted to list these hits first, sorted by ratio from strongest to weakest.

from here, many users will find it useful to merely browse the list of genes. to aid in this, more detailed information can be readily accessed from the table. for each array position, a pop-up window can be displayed giving more detailed information on the corresponding. the normalized colony area will be shown for each individual colony, both numerically in a table; and as a graphical representation showing the currently highlighted control/experiment pair  and the individual areas of all control and experimental colonies . the description of the gene as defined by the sgd database is shown and this information can be kept up to date by downloading the latest database file from within the program. if the ratio plot is open, then the currently viewed query can be viewed on this plot to give an overview in the context of the entire screen. this window also contains a link to the corresponding page for the orf in question on the sgd web site. the user can also quickly switch to positions containing duplicates of the current orf elsewhere within the array, or to any other orf of interest if present.

the context menu can be used from the table to select genes of interest to copy  for use in other applications or web sites. for example, a list of orfs can be pasted into the gene ontology analysis utility at the sgd web site . additionally, the entire data table can be exported either as tab-delimited text, or as microsoft excel .xls file. this latter option prevents some formatting errors that can occur when importing tab-delimited text files into excel, such as the interpretation of gene names as dates.

users can also filter the list of genes displayed, based on a text string. only those genes whose description contains this string will be displayed. this provides a quick way to check for interactions between genes involved in a particular function or process.

options
a fifth panel provides for setting of some basic options for operation of the program. this includes the ability to choose the type of user interface offered and a simple procedure to automatically update balony.

RESULTS
colony size measurement
to speed up the quantification of plates with balony, an automated gridding step can be used which attempts to automatically locate the position of the array, using a particle analysis routine to identify objects on the plate that resemble yeast colonies. to avoid counting extraneous plate features  as colonies, only a limited rectangular portion of the plate is scanned at one time. this region is based on the expected dimensions of the array from the grid preset. this routine generates a list of objects with defined x and y coordinates. the program assigns the objects closest to the corners of this region as the corners of the array, and then interrogates the spacing of all the other objects to see if they fit the criteria necessary to be colonies within the array. specifically, if the x and y coordinates are both within 30% of an expected grid position, they are added to a list of valid colonies. after analyzing all the objects, the mean horizontal and vertical deviation of objects from their expected position is calculated and if each of these is within 5% of their expected values, then it is assumed that the array has been correctly established. if parameters are not determined from the initial analysis, the rectangle is progressively repositioned until parameters are correctly established. occasionally, failure to automatically locate the grid may be due to a plate not being placed squarely in the scanner. the program contains an option to try a number of rotations to correct for this if the gridding process fails. this attempts to repeat the gridding process after rotating the plate by up to 3° in  <dig> ° increments. the current version of the algorithm was arrived at by repeated refinement using hundreds of test plates and we find it to be effective in for virtually all images we have encountered.

once the grid has been successfully established, the sizes of colonies can be measured. this uses the same particle analyzer routine as used in the gridding. this generates a list of objects with x and y coordinates, areas and circularity values. the program iterates through this list, testing each object. a number of criteria must be successfully met for an object to be identified as a colony.

first, the centre of an object must be close to the centre of a grid position . second, the colony must be within certain size limits, which again, can be specified. finally, the colony must meet a minimum value for circularity, a parameter determined by the algorithm with possible values between  <dig> and  <dig>  where  <dig> represents a perfectly circular object. the default minimum circularity value is  <dig> . if more than one object is potentially allocated to the same grid position, the software will select the colony which is closest to the centre of the cell.

after interrogation of this list, the program individually analyzes the pixel content of any grid positions that did not have a colony allocated. if any position in the grid exceeds a minimum pixel count–suggesting the possibility of a colony that was not detected in the first pass–then the user is presented with the option to perform a low stringency second pass. in this case, the circularity of the particle finding algorithm is set to zero in order to identify “non-ideal” colonies; we find this helps to identify colonies that have, for example, become smeared during the pinning process.

when we compared the ability of our software to measure colony sizes with screenmill and sgatools, we found near-identical results. we analyzed a 1536-colony example plate provided with each program, and found the correlation between measured colony sizes gave a r <cit>  values of  <dig>  and  <dig>  respectively , indicating that our implementation of colony measuring algorithms is similarly effective.

colony normalization
to demonstrate the fidelity of the normalization procedures employed by balony, we constructed a test array plate of  <dig> colonies of the same wild type yeast strain and scored colony sizes for eight replicates of this test array. first, we quantified growth of all  <dig> wild type colonies across the eight plates, which should all have the same fitness. the mean pixel area per colony was determined to be  <dig>  ±  <dig>  pixels . however, as previously described  <cit> , we found that colonies at the corners and edges of the plate grew more quickly than colonies in the interior and at the centre . this increased growth on the edges of the array is due to decreased competition with neighbouring colonies  <cit> . thus, the non-normalized mean colony size measurement was not a reliable measure of colony fitness because it did not take into account systematic effects of array position on colony growth rate. in addition to the effects of array position, growth conditions can also vary substantially from plate to plate, further confounding attempts to quantify the fitness of individual colonies  <cit> . this was noticeable in our test array in which colonies in corner positions showed a wider range of areas, with a variation of up to  <dig> pixels across the eight replicates. in contrast, colonies in the centre of the array varied by only  <dig> pixels.

to circumvent these problems, we developed colony normalization algorithms which correct for decreased competition resulting from array position and for variability between plates. colony normalization is an essential feature of all protocols developed for analysis of colony-based growth assays  <cit> . the first step in the normalization procedure employed by balony is to divide the pixel area of each colony by the median colony size on each plate. hence, a colony that grows near the average rate for that plate will have a normalized area of ~ <dig>  there are then three optional correction procedures that can be applied to the data, as described previously  <cit> .

first, “row/column” correction can be applied. as we observed in our test array, the colonies at the edges of plates will often grow faster due to decreased competition with other colonies. to compensate for this, a correction factor can be applied based on the deviation of a given row or column compared to all other rows or columns. this is achieved by calculating the median pixel area of the spots in a particular row or column. if this value is greater than  <dig>  then each spot in this row or column is divided by the median value to normalize that row or column with respect to the rest of the array.

the next type of correction is “spatial” correction. this can be necessary in plates where the thickness of the media is variable because yeast colonies will grow at varying rates depending on the thickness of the media. to account for this, we take the median colony size of each row and column and fit these to a smoothed distribution using a loess algorithm  <cit> . this generates a pair of distributions, corresponding to the horizontal and vertical axes of the plate, with each value in the distribution expressed relative to the median colony size on the plate. from these distributions we can determine a correction factor for each position in the array, as the product of the corresponding row and column positions in each of the horizontal and vertical loess distributions.

the final type of correction employed by balony is “competition”. this can be necessary when a colony has a number of slow-growing colonies surrounding it. due to this reduced competition for nutrients, that colony may then grow faster  <cit> . to control for this, we examine the whole plate for colonies whose eight surrounding neighbours have a mean growth rate of <75% of the median colony size. using a simple linear regression analysis, we can determine if colony size correlates with the size of surrounding colonies on a given plate. if this correlation proves sufficiently robust , then any colonies on the plate which have reduced competition  are corrected by applying the parameters derived from the linear regression to its colony size.

to confirm the effectiveness of colony normalization and row/column correction, we applied this algorithm to the raw pixel area data from the test array of wild type yeast shown in figure 3c. while the raw pixel areas showed variations in colony size as high as 67% greater than the plate mean , following row/column correction, each of the representative colonies reported a growth rate within 3% of the plate mean . the low standard error associated with the mean corrected value for the plate  indicates that this algorithm effectively deals with variations caused by growth at the edges of plates. thus, following normalization and row/column correction, we were able to determine with high accuracy that all colonies in the array had similar fitness, as would be expected since they are genetically identical.

now we compared the effects of each normalization algorithm using an actual 1536-density array plate of yeast single deletion mutants routinely used for sga analysis in our lab. the effects of sequentially applying each type of correction are shown in figure  <dig> . applying row/column correction had the expected effect of normalizing the sizes of colonies in the outer rows and columns . subsequently applying spatial and competition correction resulted in much less dramatic corrections, likely because of the fairly uniform growth rates of the individual deletion mutants in the array . for this reason we suggest that users only need to apply row/column correction unless they feel that their images would specifically benefit from the additional steps, such as in the case of unevenly poured plates, or with arrays containing a large number of slow-growing strains or empty spaces. as each correction step has the potential to distort the original data, we feel that it is beneficial to minimize the number of post-processing steps where possible.

genetic interactions of scs2
to demonstrate the utility of this software, we performed an sga experiment using a strain deleted for the gene scs <dig>  the analysis steps are described in a more detailed, step-by-step tutorial online at http://code.google.com/p/balony/wiki/tutorial <dig> where a link to the scanned images is available should a user wish to follow the stages of analyzing a typical screen from start to finish.

the experimental approach is outlined in figure  <dig>  all robotic pinning steps were performed using a singer rotor hda robot with colonies arrayed at a density of  <dig> cpp. an scs2::ura <dig> strain was constructed in the y <dig> strain background  <cit>  and arrayed on sc-ura plates. this was then mated with the dma on ypd medium and diploids selected for on sc-ura medium supplemented with  <dig> mg/l g <dig>  after sporulation, mata haploid cells were germinated. we then generated a set of double mutants by two successive rounds of incubation on medium lacking uracil. simultaneously, we generated single mutant control  strains by first incubating on medium containing  <dig> g/l 5-fluoroorotic acid  to counter-select for strains containing the scs2::ura <dig> allele, and then incubating on medium containing uracil.

each set of double and single mutant plates was scanned at  <dig> dpi and balony was then used to analyze the images using the default image settings. each paired set of data was scored using median row/column correction. we compared over  <dig> single mutant control spots to the corresponding double mutant experimental spots in three biological replicates. we were able to identify significant differences in spot size for  <dig> experimental spots using a maximum p value of  <dig>  . our ability to detect such a large number of potential interactions is a strong indication of the robustness of our methodology and of the high fidelity of the balony colony scoring and normalization system. as expected, as the difference between control and experimental spot size approached zero it became increasingly difficult to define potential interactions with confidence . as has been reported for previous analysis methods  <cit> , we also identified a substantial number of experimental spots that exhibited only small differences in size from the corresponding control spot, but which were measured with unusually high accuracy , which is likely an artifact of using only a small number of replicates . however, these differences were unlikely to represent true genetic interactions because they fell within the 95% confidence interval of the mean difference measurements.

using the analysis module of balony to interrogate genetic interactions, we examined the ratios of spot sizes and used the ratio plot window to automatically define the ‘low’ and ‘high’ cut-off values for hits. the cut-off values obtained were  <dig>  and  <dig> , respectively. using this method we were able to score  <dig> experimental spots that met these cut-off values in three out of three replicates that also had a maximum p value of  <dig>  compared to the corresponding control spot size . this eliminated  <dig> experimental spots that showed only small, but significant differences from the corresponding control spot. due to genetic linkage, a total of  <dig> spots corresponding to genes neighbouring scs <dig> were excluded from the analysis. additionally, the ura <dig>  ura <dig>  ura <dig>  ura <dig> and fur <dig> genes were excluded as these mutants are involved in uracil metabolism and generate false “hits” due to the use of the–ura selection media.

using these ratios and a maximum p-value of  <dig>  for the difference between control and experimental spot sizes, we identified  <dig> aggravating genetic interactions and  <dig> alleviating interactions in three out of three biological replicates. the list of genes responsible for these interactions was copied from the table and pasted into the funspec web site at http://funspec.med.utoronto.ca, to test for enrichment of this hit list for various gene ontology terms. we noted enrichment in a number of categories including “protein retention in golgi apparatus” , and “nuclear migration along microtubule”  giving clues to the potential roles of the scs <dig> gene in the cell.

to determine how our analysis compared with previous sga analyses we downloaded the data for the scs <dig> sga screen performed by the boone lab  <cit>  as part of their high throughput series of sga experiments. to compare the data sets we used the “diff” value for the hits identified using balony from our scs <dig> screen and the “epsilon” value from the costanzo data set . these are approximately equivalent measures of the strength of a genetic interaction as they compare the difference between the normalized colony size of a yeast double mutant and the corresponding single mutant control . we found a high degree of overlap, with both aggravating and alleviating genetic interactions being found in both experiments. of the  <dig> genetic interactions that were common to both screens ,  <dig> were found to have the identical effect, with  <dig> aggravating interactions and  <dig> alleviating. using this information we were able to calculate values estimating the sensitivity and precision of our method, as follows:

the following formulae are used to define the parameters “precision” and “sensitivity”  <cit> :

 precision=tptp+fpandsensitivity=tptp+fn 

where tp represents the number of “true positives” in the data set , and fp represents the number of “false positives” .

given that precision has been determined experimentally for the boone lab data set at  <dig> , and we know this paper reported  <dig> hits for this screen, which comprise a number of true positives and a number of false positives: therefore, tp + fp =  <dig>  so fp = 124-tp

 precision=tptp+124−tp 

so tp =  <dig> and fp =  <dig> 

as the sensitivity of the boone lab set has been estimated at  <dig> , we can estimate the total number of genetic interactions for scs <dig> as 78/ <dig>  =  <dig>  our data set identified  <dig> genetic interactions in common with the boone lab data set and these are likely to be genuine interactions; yet because the sensitivity of this data set is  <dig> , this indicates that our data set contained a total of 32/ <dig>  =  <dig> true positive interactions. so of the  <dig> interactions identified, there are 169-91 =  <dig> false positives. the number of false negatives in our data set, i.e. interactions that we did not identify, must therefore be 223-91 =  <dig> 

applying the above formula, we were able to determine parameters for our screen which are summarized for comparison purposes in table  <dig> alongside the values obtained from the boone lab data set. the sensitivity of our screen compares well with that obtained by the boone lab , as does the value we obtained for precision . this indicates that our protocol is sufficiently robust for routine laboratory usage. we speculate that these differences are largely due to two factors. first, the criteria used to distinguish hits are slightly different between the two methods, with our protocol relying on the ratio of colony sizes, with the boone lab using the difference. second, in our protocol we generate a control data set with each experimental data set, while the boone lab uses a standard reference control set. these differences are likely to impact on the relative rates of false positive and false negative results obtained.

we also compared the balony analysis method to an available method that uses a bayesian framework for the analysis of biological data, which can be applied to any dataset that utilizes paired control and experimental measurements, and is particularly effective when there are only a limited number of replicates  <cit> . we used the cyber-t program to analyze the colony size data for the scs <dig> sga screen that was quantified and normalized using balony, using the suggested parameters of an averaging window equal to  <dig>  a bayesian confidence value equal to  <dig>  and a minimum p value of  <dig>   <cit> .

we plotted the difference between control and experimental spot size versus the bayesian p values and highlighted points with a p value below  <dig>  . as expected, this method increased the significance threshold for small difference measurements compared to t-test alone, eliminating spots with unusually low standard deviations due to having a small number of replicates. by this method  <dig> spots were identified that corresponded to  <dig> potential genetic interactions. we compared the genes identified by this method to the boone lab data set and identified  <dig> genetic interactions in common, compared to  <dig> using balony. thus, making the assumption that the genetic interactions identified by the boone lab were “gold standard” true genetic interactions, the algorithms employed by balony appeared to be particularly well suited for the analysis of genetic interaction data derived from colony size measurements of high density yeast arrays.

CONCLUSIONS
in this paper we have described a software package that makes the analysis of sga data both rapid and flexible. we believe we have devised a complete system that can be employed at a relatively low cost, and in many cases will involve the purchase of no additional equipment. if necessary, the components for a dedicated imaging and computational platform  could be purchased for less than $ <dig> . it is our intention to continue development of the program in response to the needs of the community and to release regular updates offering new features.

using the analysis features in balony it is possible to determine parameters similar to those published for large scale data sets. specifically, our diff measurement is analogous to the epsilon value. the epsilon value is defined as the difference between the observed growth of a double mutant strain and the predicted growth of the strain based on the relative fitness of each single mutant strain according to the multiplicative model for genetic interactions  <cit> . for example, in cases where the query strain has no associated fitness defect, then the difference measurement determined using balony is equivalent to the epsilon value. however, should a query strain be used which does not grow as wild type, the difference measurement can be easily corrected to account for this. if a deletion strain is present in the dma that corresponds to the query gene, then its growth can be used to approximate the growth rate of the query strain; otherwise the growth rate must be determined independently.

as a result it is possible for users of balony to directly compare their results with the large resource of genetic interaction data already available. in this paper we have shown an example of this, comparing our scs <dig> sga screen with the data available in public databases. the extensive correlations between the two data sets provide evidence that the analysis methods we have described here are sufficiently robust for routine analysis of genetic interaction data.

availabilty and requirements
project name:balony

project home page:http://code.google.com/p/balony/

operating system: platform-independent

programming language: java

other requirements: java  <dig>  or higher, >1gb free memory.

licence: gnu gpl

any restrictions to use by non-academics: none

this site also hosts the source and a wiki which serves as a reference manual and contains a tutorial which guides a user through the analysis of a sample screen. this should also be consulted for details of system requirements and installation instructions.

competing interests
the authors’ declare that they have no competing interests.

authors’ contributions
bpy designed and developed balony and wrote the paper. cjrl provided valuable input into the design of balony and assisted with the program validation and writing the manuscript. both authors read and approved the final version of the manuscript.

