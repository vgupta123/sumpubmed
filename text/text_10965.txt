BACKGROUND
multiple sequence alignment  appears as the initial step of almost all biological sequence analyses. however, msa is well known to be a difficult problem, both from the algorithmic point of view and with respect to the biological relevance of the output. the local alignment is a classical paradigm in sequence analysis  <cit> . the idea of including local alignment information into global alignment tools, like in dialign  <cit> , represented an important step in alignment accuracy, and is also at work in more recent tools like t-coffee  <cit> , muscle  <cit>  or mafft  <cit> . a latest trend is to include homology information retrieved from existing databases, such as, e.g., in dbclustal  <cit> . for recent reviews on msa programs see  <cit> . another way to improve the accuracy of existing msa is to include user-specified anchor points, which are specific positions that should turn out to be aligned in the output  <cit> . this information can be composed of a small number of expert-based constraints, or can be used to include additional information, such as secondary structure predictions  or other information derived from external resources  <cit> .

multiple sequence alignment, being np-hard under any reasonable optimisation scheme, must consistently rely on heuristics. the inclusion of anchor points can result in a dramatic improvement on the relevance of the alignment, if it constrains the search of the local optimum to a region that contains the "true" alignment. the number of msa programs that currently accept the inclusion of user-specified anchor points is unfortunately limited. to our knowledge, only dialign  <dig> has such an explicit option  <cit> , while it is also possible to include anchor points in clustalw  <dig>   <cit> , by using the format developed for the blast-based ballast  <cit>  tool, and in t-coffee, by including the anchor points as library files.

anchored alignment is also widely used for whole genome alignment strategies, for which it is almost required, by the sheer size of the input, to start by detecting strong pairwise local similarities for the efficiency of the subsequent algorithm . for instance, exact maximal repeated substrings  can prove to be sufficiently informative, although more recent methods use spaced seeds . in this paper, we follow likewise a combinatorial approach, but our focus concerns however not whole genomes, but sequences that are amenable to traditional multiple alignment methods, such as protein or gene-sized nucleic sequences.

we introduce a method to determine automatically a set of such "anchor points" for multiple alignment software. we base ourselves on a previously introduced algorithm, the n-local decoding, introduced by didier  <cit>  that clusters together positions in the sequences whose contexts of appearance of a given length n are similar but exhibit an a priori unspecified number of mismatches. more precisely, we use a method called ms <dig>  <cit> , which selects multiple local similarities resulting from the n-local decoding, but for an adaptive value of n.

however, specifying contradicting anchor points can prove deleterious. indeed, suggesting or imposing that some positions be aligned while these positions are incompatible with the ordering induced by the sequence can altogether destroy the relevance of the alignment. the simplest kind of incompatibility arises from internal repeats inside sequences. the ms <dig> method is here tuned to accept only similarities occurring at most once in any sequence. usually, anchor points are specified as pairs of aligned residues, or possibly, of aligned segments. in order not to confuse the reader, we will call the output of this procedure partial columns, because they would look as such in a multiple alignment display.

the core of the present paper consists in a graph-theoretic algorithm to tackle the global issues of consistency with a multiple alignment. to do this, we consider the order-theoretic definition of consistency . each sequence is seen as an abstract ordered sequence of positions . a collection of subsets of positions can be added to a given multiple alignment under a technical condition which ensures that the elements of different subsets never appear in contradicting orders. this condition is readily encoded in a directed graph, and the consistency problem amounts to getting a directed acyclic graph  from it. our algorithm starts by implementing a heuristic solution to the np-hard problem known as the minimum feedback arc-set problem. once a dag has been identified, positions that contradict the induced partial order are removed from the corresponding partial column. we call the output of this procedure consistent partial columns.

as a validation of the method, we introduced the partial columns, and the consistent partial columns, into the programs accepting anchoring options. we tested the effect of introducing these two types of anchor points on the performance of these msa tools on the global benchmark balibase  <dig>  <cit> . the results show that the use of either type of partial columns induce improvements of performance for clustalw  <dig>  on balibase, which are better and stabler with the consistent ones. by contrast, we get a consistent degradation of performance for dialign, and almost no variation for t-coffee.

although we used our method only with the ms4-based partial columns, this algorithm can be applied to any other set of partial columns. the ms <dig> approach has the advantage to detect directly multiple similarities with only linear complexity. virtually any scheme for detecting local similarities could produce an input for our method, provided that all internal repetitions be removed. it is for example possible to use pairwise similarities, such as used by most msa programs, and select among them those that involve more than two sequences to construct the partial columns, albeit at some computational cost. in  <cit> , we used the pairwise optimal fragments for dialign, and the consistency algorithm described in the present paper, this time with satisfactory results.

methods
let s be a collection of n sequences over a finite alphabet. the site space

 s={|1≤i≤n,1≤p≤ℓ}, 

where ℓ is the length of the i-th sequence, is the abstract set of positions in the sequences, and is endowed with a natural partial ordering "≼" such that  ≼  holds if and only if i = i' and p ≤ p'. let si be the set of sites of the i-th sequence, i.e. the set {|1≤ p ≤ ℓ}. in the following, we identify si with the i-th sequence.

an alignment of s, in the sense of dialign  <cit> , is a partition a of s that satisfies a consistency condition. as usual, we attach to the partition a the natural equivalence relation ~a defined as x ~ a y if and only if there exists a subset a ∈ a that contains both x and y. then the consistency condition reads as follows: the preorder ≼a= t, where rt denotes the transitive closure of a relation r, coincides with the order ≼ when restricted to any sequence s ∈ s. the equivalence classes of the partition a correspond to parts of columns of aligned positions of s. if only a set of disjoint subsets of positions whose union does not cover the whole set s is given, we implicitly consider the partition obtained by adding the missing singletons. these notions are illustrated for concreteness' sake on the toy example presented in figure  <dig> 

we call a subset c⊂sambiguous if it contains a repetition, that is, there is a sequence si such that the intersection c∩si contains at least two distinct elements  and , which are then also called ambiguous with respect to c. this definition is extended to an equivalence relation e on s by calling e itself ambiguous, if it contains an equivalence class which is an ambiguous subset.

a non-ambiguous subset c⊂s will be called a partial alignment column. a non-ambiguous equivalence relation consists therefore only of partial alignment columns. if an equivalence relation is consistent, it is obviously non-ambiguous. the converse is however in general not true.

the ms <dig> method
our partial column detection scheme is called ms <dig>  and is described in  <cit> . it relies on a fast algorithm for producing partitions of sites, the n-local decoding, that we briefly recall.

a word w∈anoccurs at position i relatively to s =  if s = w. say σ ≃ nσ' whenever there is an identical length n word w at the same position relatively to both σ and σ'. a single length n word induces n instances of the relation ≃n, one for each position in the word. the n-local decoding of s is the partition ℰn of s induced by the transitive closure of ≃n. therefore, two sites σ and σ' are clustered together if there is a chain of occurrences of identical length n words that connects them .

the ms <dig> method combines the different equivalence classes from various values of n by introducing a new construction, the partition tree, which encodes how the equivalence classes for successive values of n are related.

letting ℰ0={s} we can encode the set v = ui≥ ℰi of equivalence classes for different values of n into the partition tree p = , defined by

 ep={∈ℰn×ℰn+1|v⊂u}. 

the leaves of the partition tree are the sites in the sequences. let us say that a node is ambiguous if the leaves of the partition tree that are children of this node form an ambiguous subset of sites.

given k ∈ ℕ, we define the set of ms <dig> partial columns  spanning at least k sequences, as the set of subsets of sites ck corresponding to the children of non-ambiguous nodes v of the partition tree such that their direct ancestor in the tree is ambiguous . this condition ensures that the resulting subsets of sites are indeed partial columns, as illustrated in figures  <dig> and  <dig> 

consistent partial columns
we present now the algorithm that resolves the inconsistencies among a set of partial columns.

the succession graph of a set c of partial columns is the edge-weighted directed graph sg= where we have an edge e =  if and only if there exists a sequence i and sites  ∈ c and  ∈ c' that satisfy p <p'. an edge from c to c' means that there exists at least one sequence where c occurs to the left of c'. the weight  of the edge  is then defined as the number of sequences i with this property. for convenience purposes, we also add an initial vertex vstart and a terminal one vend. the following result is quite easy to establish.

lemma  <dig>  the set c is consistent if and only if sg is a directed acyclic graph .

finding a consistent set of partial columns amounts therefore to finding a set of partial columns whose succession graph is a dag. to turn our possibly inconsistent set of subsets of sites c={c <dig> c <dig> ...,cp} into a consistent one, we proceed in two steps:

 <dig>  delete some edges of the succession graph g = sg to turn it into a dag,

 <dig>  transform the subsets ci themselves so that the succession graph of this new set of partial columns is itself a dag.

for our applications, we will take c=ck described in the previous section, but the procedure we introduce here would work starting with any set of disjoint non-ambiguous subsets of s.

getting a directed acyclic graph
an optimal solution to the first problem would suppress a subset of edges of total minimal weight that yields a dag. however, this is an np-hard problem known as the minimal  feedback arc set problem. as a heuristic substitute, we successively remove the lowest weighted edges from the graph until all cycles have disappeared. namely, let for k ∈ ℕ the edge subset

 ek={∈e|w>k  or  u=vstart or v=vend}, 

and k* = min{k > 0| is a dag}.

removing inconsistencies
we describe now a method that will remove sites from the subsets ci in the set csuch that the resulting set of partial columns c' is consistent. the algorithm tries to make the partial ordering on the partial columns induced by the dag compatible with the linear partial ordering on the sites in the sequences, by removing a minimal set of positions from the partial columns. the subtle point is that deleting the edge  cannot be always interpreted directly as the removal of some positions that belong to partial columns u or v. the procedure is illustrated in figure  <dig> 

the acyclic graph  can turn out to be disconnected, so we reconnect it by adding all the necessary edges of the form  or , and denote with g* the corresponding graph. let ≤* be the partial order defined on c by the dag g*. for each sequence s, let cs be the set of partial columns c of chaving a  site  in s. there are two order relations on vs = cs u { vstart,vend}, namely

• the total order ≼s induced by the natural order ≼ of s defined in section methods,

• the partial order ≤s* induced by the order ≤*defined by g*

the relation r=≼s∩≤s* is the largest order which is a sub-relation of both ≼s and ≤s* the total sub-orders, or chains, of the relation r are those subsets of occurrences of partial columns that are consistent. to minimise the number of lost sites, we choose a maximal chain.

more explicitly, let g+ =  be the transitive closure tc of g*. the graph g+ is also a dag and defines the same partial order on the set of partial columns. the graph gs =  of the relation r is defined on the vertex set vs by

 ∈es⇔u, v∈vs, ∈e+ and u ≼sv. 

chains of r correspond to paths in gs. let gs =  be a path from vstart to vend in gs of maximal length. for all partial columns c∈cs such that c ∉ gs, remove the site  from c. let c∘ be the set of partial columns obtained after applying this procedure for all sequences s ∈ s. the order in which they have been selected does not matter. if we wish to stress the difference between consistent and non-consistent partial columns, we will sometimes refer to the latter as raw partial columns.

lemma  <dig>  the succession graph sg of the resulting partial column set is a dag.

proof. every direct transition between occurrences of partial columns in c∘ is encoded as an edge appearing in some longest path g in some graph gs. therefore, every edge of the succession graph g∘=sg corresponds to a path in the graph g+. since g+ is a dag, the graph g°cannot have any cycle.

all current implementations of anchoring options take as input a list of pairs of matching positions. to obtain a set of anchor points from a set c of partial alignment columns, we consider all maximal segments of consecutive pairs of sites ,..., and ,...,  such that every pair of sites  and , <dig> ≤ l ≤ k, belongs to some partial alignment column cj∈c.

RESULTS
in order to evaluate the effect of introducing the ms <dig> partial columns in multiple alignments, we have used the reference protein multiple alignment benchmark database balibase   <cit> . as is usually done, we have only considered the core regions to assess the effect of the introduction of the partial columns in the msa software. in order to do this, we have slightly waylaid dbclustal from its usual function, by including our ms4-based partial columns as anchors points encoded in ballast files, as explained in  <cit> . we have also used the anchoring option of dialign  <dig> and included the partial columns as library les in t-coffee.

for each of the reference sets in balibase  <dig>  we have examined and analyzed the performances of the aligners that accept anchors before and after the inclusion of two types of position subsets:  raw ms <dig> partial columns, computed according to section ms <dig> method  consistent ms <dig> partial columns, as obtained after applying the algorithm described in section consistent partial columns.

the partial columns must be split into segments of pairwise matching positions, and attributed a weight. for a pair of segments of length l we set the weight to 10|l| for clustalw and dialign, and a uniform value of 100m for t-coffee, where m is the number of sequences in the dataset. for each of the obtained alignments, we have computed the sum-of-pairs  and total-column  scores, and compared it to the scores obtained by the aligner alone. on dialign, the results proved disappointing. with t-coffee, no improvement nor degradation whatsoever was observed in the overwhelming majority of cases: there is a variation on less than  <dig> datasets over the whole balibase <dig> , and a substantial one on about  <dig> only. these results are after all not so surprising, since both dialign and t-coffee already rely on local strategies. we will henceforth focus our discussion on the results obtained with clustalw  <dig>  alone. we omit "ms4" in what follows.

tables  <dig> and  <dig> contain the scores obtained by clustalw  <dig>  with and without our anchors, as well as those obtained by more modern aligners. we have reported the scores obtained for values of smin =  <dig>   <dig> and  <dig>  which are somehow representative of the general trend, that we sum up as graphs in figure  <dig> ,  <dig> & <dig>  the consistency algorithm improves in every case the performance of clustalw, while the partial columns computed by ms <dig> only improve it for smin =  <dig> and  <dig>  although the score improvements of our anchors on clustalw are substantial, they remain inferior to those obtained by modern aligners.

this table gives the mean of the sp score on all data of each of the reference datasets of balibase  <dig>  for several multiple alignment schemes. cw+pc.  refers to the performance scores of clustalw when supplied with the partial columns computed by ms <dig>  for smin = k; while cw+c. pc.  refers to the consistent partial columns for the same value.

same comments as in table  <dig> 

detecting a larger amount of correct similarities does not necessarily mean that the obtained alignment is better. indeed, this effect could be obtained at the cost of including also a lot of wrongly aligned positions. to study this issue, we used the multiple alignment comparison tool aln_compare <cit>  by swapping arguments: usually the call aln_compare ref_al test_al computes among all pairs of aligned residues of the reference alignment ref_al, the proportion of residues which are present in the tested alignment test_al. if the arguments are swapped, the result returned counts the proportion of correct pairs among the core pairs aligned in the test alignment. a similar analysis is valid for the total-column score. these measures can be considered as specificity scores. we have reported in table  <dig> the specificity scores , obtained by the clustalw  <dig>  alignments alone, and for clustalw with our consistent partial columns for smin =  <dig>  which appears from tables  <dig> and  <dig> as being the best overall combination.

the specificity scores obtained by clustalw  <dig>  for sp and tc evaluation schemes, as compared with the scores obtained with the consistent partial columns for smin =  <dig> 

sp scores
we can observe from figure  <dig> that, as a general trend, the inclusion of raw partial columns induces a general degradation of performance for smin <  <dig>  and a global improvement above this threshold . the score degradation for smin <  <dig> shows that the raw partial columns include inconsistent similarities for these values, which are eliminated by requiring that a column span a minimum number of sequences in order to be considered.

this result fits with the expectations, since these two datasets contain respectively large  extensions and large internal deletions. it is well known that supplying local information help global aligners to deal with large indels.

tc scores
figures  <dig> and  <dig> show the variation of tc score with respectively raw and consistent columns. the tc score is much more stringent, since a single mistake in a column as compared to the reference alignment results in a score of  <dig> for the considered column. as for the sp score, the degradation that can be observed for smin <  <dig> with raw partial columns disappears as soon as the columns have been filtered by the consistency algorithm, and gives on the contrary a perceptible improvement . this means that, although the actual number of correctly aligned pairs does not greatly increase , the improvement concerns essential columns of the core reference alignment. if the consistent partial columns are able to improve the tc scores, it shows that they can find previously undetected local similarities for a subset of sequences where the similarity was missed and now can be included for all sequences, because the tc score will only raise if a column is aligned correctly in all sequences. the improvement is more perceptible for rv <dig> and rv <dig>  the dataset rv <dig> contains highly divergent sequences and rv <dig> large indels, as we recalled before.

discussion
it is somehow surprising that we do not get an improvement on the tc score for rv <dig>  since this is the dataset that is used to test large c- and n-terminal insertions. for this set, it often happens that clustalw does not align correctly any single core column, whereas supplied with our consistent partial columns, it will manage to correct this behaviour, resulting in a great improvement in score. however, the weak mean performance of the partial column anchoring on the tc score for rv <dig> is essentially due to  <dig> alignments out of the  <dig> composing the dataset. for bb <dig>  clustalw aligns correctly 84% of the columns, whereas for smin ≤  <dig> our anchors introduce mistakes, resulting in a tc  <dig> score. the same happens with bb <dig> for which clustalw finds 70% of correct columns, and none with our consistent partial columns . a closer examination of the alignments shows that, for bb <dig>  ms <dig> detects  a similar region that extends over  <dig> sequences, but it turns out that for  <dig> sequence it should not be aligned with the  <dig> others. the resulting offset of the positions in this last sequence runs whole columns along the core region . this unexpected phenomenon however only slightly affects the number of aligned pairs, which is consistent with the fact that otherwise the sp score is in the average of the improvements observed on the other reference sets.

it is to be noted that on rv <dig>  on the contrary, the inclusion of consistent partial columns always result in an improvement of the tc score, whatever the considered dataset. here in figure  <dig>  we show the consistent partial columns on the reference set bb <dig>  where the tc score jumps from  <dig> to  <dig>  notice that the columns appear to be split in two groups, which turn out to correspond to the separation between eukaryotes and prokaryotes. this feature illustrates why the ms <dig> can be used as an efficient alignment-free classification tool  <cit> .

finally, the specificity scores reported in table  <dig> seem to indicate that the sensitivity score improvements are indeed a result of a larger number of detected similarities that are relevant. note that the unsatisfactory behaviour of tc on rv <dig> reflects also on the specificity score. in table  <dig>  we have reported the times taken on average by the two steps of our anchor selection algorithm. the consistency step has to be repeated for each sequence: this accounts for the higher figures for rv <dig> and rv <dig>  which consist of more sequences on average than the other datasets. the program used is still a prototype, and has not been optimised for performance; nevertheless, the time required remain reasonable and does not seem to be an obstacle to using this feature on datasets of gene-sized alignable sequences.

mean values of the time  taken by the ms <dig> step and the consistency step for the anchor computation on balibase  <dig> 

we have also used both types of partial columns with dialign. however, as mentioned, probably since this aligner is already based on local similarities, we didn't observe any improvements on balibase  <dig>  further investigations seem to show that ms <dig> is here to blame. when partial alignment columns are constructed from the pairwise similarities computed by dialign, we have shown in  <cit>  that the consistency algorithm successfully removes inconsistencies, resulting this time in an improvement of performance with dialign  <dig>  this supports the idea that a more refined criterion for selecting the nodes in the partition tree than the one currently implemented in the ms <dig> method is required to be successfully applied as a local similarity detector that performs well on more modern aligners. at any rate, ms <dig> seems more adapted to alignment-free classification. according to our experience, the partial columns obtained by ms <dig> are nevertheless useful for the visual expertise of alignments, for they highlight local homologies , which are easier to visualise than the usual simple substitutions schemes used by these editors.

CONCLUSIONS
the introduction of our ms4-based partial columns give therefore encouraging results. the overall influence of their inclusion can be summed up in two principal observations. the introduction of local information results in an improvement of the correctness of clustalw, as already observed by the authors themselves, who developed dbclustal for this goal. initially, dbclustal uses local fragments based on blast searches . the inclusion of user-defined anchor points being also possible, we have in this way been able to assess the improvement of performance that results from the inclusion of these local primary sequence-based similarities, constructed without score matrices or sliding window of predefined length. with the local aligners for which the inclusion of anchor points is possible, the results are not conclusive, especially with dialign, although they happen to have quite a neutral effect on t-coffee. it is unfortunate that the anchoring option is not featured in any other aligner, especially any other global aligner, to be able to give more insight on the usefulness of the construction presented here.

the improvement obtained for clustalw is most perceptible for datasets containing sequences of unequal lengths, and the computation of ms <dig> partial columns seems then justified in view of the gain in accuracy they provide. in other respects, the computation of consistent partial columns can help the eye-expertise of multiple alignments, for the number of obtained position subsets is quite reasonable, and, as the tc score performance seems to indicate, their visualization allows to correct whole columns in the alignment, since they appear to correspond to conserved zones in the considered sequences . we have moreover introduced an algorithmic approach that can be further explored. the consistency algorithm can be used with other local similarities as input, as already tested with success on dialign  <cit> . these results encourage us to improve our approach on several points. in particular, the mere filtering of edges of the succession graph by their weight to get a dag in section getting a directed acyclic graph is overly simplistic . we are currently exploring more refined ways of getting a dag, in order to reduce the number of erased edges. another interesting feature would consist in splitting the contradicting partial columns into subsets of similarly behaved sites. these algorithmic improvements could then fit in a general tool for making local similarities consistent.

authors' contributions
ec and fp have developed the methods and conducted the tests, fp and cd have performed the expertise, and all three authors have drafted, read and approved the manuscript.

