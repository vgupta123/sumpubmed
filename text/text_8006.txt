BACKGROUND
sequence comparison through multiple alignment is an indispensable tool for understanding genomes and their shared histories  <cit> . even though the foundation for genomic sequence alignment was already laid in the 1980s  <cit> , the interest is still ongoing  <cit> , one reason being that it has critical relevance  <cit>  for many bioinformatics analyses. the aim of sequence alignment is to uncover homologies by assigning sequence positions to each other, which implies that these positions derived from a common ancestor.

evolutionary events that change genomic sequences are often classified into small changes and large structural changes  <cit> . small changes affect only one or few sequence positions and include substitutions, insertions, and deletions. they do not influence the order of sequence positions, and thus can be captured by colinear alignment. structural changes involve longer genomic segments, thereby affecting the structure and order of genomic sequences. they include non-colinear changes like inversions, translocations and duplications in addition to insertions and deletions of longer segments.

while colinear multiple sequence alignment has been studied extensively for a long time  <cit> , the problem of non-colinear alignment has been brought into focus only within the last decade  <cit> , after more and more whole genomes started to become available. non-colinear alignments, as opposed to colinear alignments, model all kinds of evolutionary changes and thereby enable correct homology prediction for whole genomes with non-colinear changes. this is comparable to the way global alignments integrate more information than local alignments by assigning all parts of sequences to each other, and the way multiple alignments take information from more than two sequences into account for homology prediction. over and above, non-colinear multiple global alignments of whole genomes, genome alignments for short, integrate as much sequence similarity information as is available.

together with the prediction of homology, genome alignments provide a segmentation of the genomes originating from large structural changes. depending on the similarity of genomes, segments can be shorter or span several genes and reveal local colinearity. rearrangement studies  <cit>  explore the order of such segments and infer genomic distances based on the number of breakpoints  <cit>  or predict scenarios of evolutionary changes  <cit> . these studies often employ graphs, e. g., breakpoint graphs  <cit> , that resemble graph data structures used for genome alignment. despite this similarity in the approach, genome alignments pursue a slightly different goal than rearrangement studies. the goal is homology prediction instead of reconstruction of evolutionary histories. genome alignments, which are the focus of this article, integrate more information than rearrangement studies by combining segmentation and sequence similarity.

considering the large search space, genome alignment is an ambitious task and is usually accomplished using heuristic approaches. the first step in genome alignment is commonly the computation of a set of local alignments. it is essential for most methods that the set of local alignments covers all main genomic similarities, whereas additional spurious similarities have a smaller impact. in colinear alignment, such a set usually constitutes a superposition of several alignment possibilities with some local alignments in conflict regarding the colinearity constraint . the task is then to select the best conflict-free subset according to a given optimization function. in genome alignment, as opposed to colinear alignment, any set of local alignments can be viewed as a valid solution, one that induces a segmentation. however, the induced segmentation can be improved by selecting a subset of local alignments. the subset should contain those local alignments that are most likely to represent homologies when viewed in the context of the whole set of local alignments. the final step is then to find the best segmentation according to the set of local alignments and possibly a subsequent realignment of segments with a colinear alignment method.

for the step of selecting subsets of local alignments and for inducing a segmentation, graphs serve as a convenient tool. the idea is that graphs show substructures indicating errors in the alignment, e. g., specific cycles. once identified in a graph, we can eliminate these substructures, e. g., by removing local alignments, which is a modification of the genome alignment. thus, graphs can assist in improving genome alignments. in addition, graphs provide an intuitive representation of similarities and changes between genomes, and so visualize alignment structures. in comparison to tabular alignments, genome alignment graphs are more versatile insofar that it is possible to model colinear and non-colinear changes without the need of choosing a reference genome.

several graphs have been proposed, each in the context of a specific application such as synteny detection, segmentation, or simply colinear alignment. the earliest graph has been the alignment graph, formally defined for colinear multiple alignment by kececioglu in  <dig>  <cit> . in his definition, the graph contains a vertex for each sequence character and edges for aligned characters. the alignment graph has since been used in various versions, e. g., with additional sequence edges  <cit>  and with genes  <cit>  or segments  <cit>  instead of single characters. in all versions, a colinear alignment can be obtained from the alignment graph by solving the maximum weight trace problem  <cit> , but its structure also allows non-colinear changes to be modeled .

pevzner et al. introduced a-bruijn graphs <cit>  as a generalization of de bruijn graphs  <cit> . the structure of a-bruijn graphs revisits an idea briefly mentioned by kececioglu  <cit> , the idea of merging aligned vertices. consequently, a-bruijn graphs have one vertex for sets of aligned positions, and edges represent sequence adjacencies. for the purpose of genome alignment with a-bruijn graphs, the maximum subgraph with large girth  problem  <cit>  and the sequence modification problem   <cit>  were proposed, both targeting types of short cycles in a-bruijn graphs in order to eliminate local alignments that hide local colinearity.

in the context of a pipeline for genome alignment that consists of the programs enredo and pecan  <cit> , another graph has been published, the enredo graph. the program enredo applies enredo graphs to partition genomes into segments. subsequently, the program pecan provides nucleotide-level colinear alignments of segments. enredo graphs have two vertices per set of aligned segments, a head and a tail vertex, resembling breakpoint graphs from rearrangement studies. the enredo method iteratively eliminates various substructures from the enredo graph before deriving a final genome segmentation.

a recent and slightly dissimilar graph is the cactus graph <cit> . cactus graphs have vertices for adjacencies and edges for genome segments. their structure has two valuable properties. the cactus property subdivides the graph  into independent units by ensuring that any edge is part of at most one simple cycle  <cit> . these units assist in computing genome alignments with the cactus alignment filter  algorithm  <cit> . the second property is the existence of an eulerian circuit. this circuit traverses all genome segments exactly once, even duplicated segments, conveniently providing a consensus genome.

in this paper, we compare the mentioned graph-based genome alignment approaches with an emphasis on the structures of the underlying graphs. our aim is to clarify similarities of the approaches and the underlying graphs but also to work out differences and highlight limitations. we realize our comparison using the same terminology for all graphs and by describing transformations among the graphs . we assess the graphs in terms of their capabilities to display alignment information in their structure alone. for all graphs, substructures and modifications constitute key aspects of corresponding genome alignment approaches. we carefully examine substructures as well as modifications independently from the particular graphs they were first described for. founded on our comparison, we derive a generic framework for graph-based genome alignment. the framework gives an overview of the general graph-based approach to genome alignment and, hence, may assist in the development of future genome alignment tools.

RESULTS
terminology
the biological term homologous denotes two or more genomic positions that derived from a single position in an ancestral genome, or two or more segments that derived from a single segment in an ancestral genome. an alignment of genomes is an assignment of positions from the aligned genomes. usually, the goal is to align only homologous positions to each other, but since the ancestral genome is unknown, an alignment can only be a prediction of homology.

in the following, we formally define a genomic position and give a very general definition of an alignment. next, we define a genomic segment and constrain the alignment definition to colinearity. since colinearity is often too strict for predicting homology in whole genomes, genome aligners use so-called blocks, which are colinear alignments of genomic segments. blocks can be arbitrarily combined to non-colinear genome alignments. we give a general definition of blocks as the basic entities that underlie graph-based genome aligners. finally, we define the terms adjacency and breakpoint.

let  be a set of genomes. each genomeg∈g is a sequence of characters from the dna alphabet Σ={a,c,g,t}. we define the position of the 
s
t
 character in genome g as p= with 0≤i<|g|, where |g| denotes the length of g. to compare two positions with the operators < and >, we assume an arbitrary strict total ordering of the genomes . then, p1<p <dig> where p1= and p2=, if g1<g <dig> or if g1=g <dig> and i1<i <dig>  let pg={p∣p=,g∈g,0≤i<|g|} be the set of all positions of the genomes . an alignment component  a is a subset of pg. for example, all pairs of positions connected by a line in figure  <dig> form alignment components. without any demand for optimality, an alignment is simply a set of alignment components.

an ordered pair of two positions p= and q= from the same genome g defines a segments= of length |i−j|, where min{p,q} is the smallest position and max{p,q} the position directly following the largest position in the segment. if p<q, the segment is in the forward orientation, and if p>q, the segment is in the reverse complemented orientation . as an alternative to an ordered pair , a segment could equivalently be represented by a start position, a length, and an additional orientation bit. two segments s1= and s2=, where without loss of generality min{p <dig> q1}≤ min{p <dig> q2}, are non-overlapping if max{p <dig> q1}≤ min{p <dig> q2}. if max{p <dig> q1}= min{p <dig> q2}, s <dig> and s <dig> are adjacent and define the adjacency at position a= max{p <dig> q1} . two segments fully overlap if both min{p <dig> q1}= min{p <dig> q2} and max{p <dig> q1}= max{p <dig> q2}.

an alignment  of a set of segments s is colinear if each alignment component contains at most one position from each segment s∈s and if it is possible to impose a strict total ordering ≺ on the alignment components a∈a  as follows: the relation a1≺a <dig> holds if for any two positions p1∈a <dig> and p2∈a <dig> from the same segment s∈s, p1<p <dig> if s is in the forward orientation and p2<p <dig> if s is in the reverse complemented orientation. if an alignment violates the conditions for colinearity, it is non-colinear . to put it simply, inversions, duplications, and translocations of parts of the aligned sequences are non-colinear operations that violate colinearity.

non-colinear operations divide an alignment into units that are colinear in themselves but not with respect to each other. we call these units blocks and define a block as a colinear alignment of a set of segments. note that a block may contain multiple segments of the same genome if duplications are present. we refer to the number of segments in a block as the size of a block . in figure  <dig>  areas shaded in blue and red indicate blocks. for example in the left alignment, the two dinucleotides cg form a block and the two dinucleotides at form another block. in the right alignment of figure  <dig>  the segment atcg and its reverse complement in the second sequence form a block.

a block always has two equivalent representations. in the first block representation, some segments are in the forward orientation and some may be in the reverse complemented orientation. in the second block representation all segments are in the reverse complemented orientation that are in the forward orientation in the first block representation and all segments are in the forward orientation that are in the reverse complemented orientation in the first block representation. the essential information about possible inversions is the orientation of segments with respect to each other and not the orientation of the block representation. once we choose one of the two representations, we implicitly assign a tail and a head to a block b. the head is the set of positions {p} of all segments s∈b with s=, and the tail is the set of positions {q}. we refer to the two sets as the ends of b in cases where the orientation of a block is not given.

a set of blocks constitutes a genome alignment and is input for building a genome alignment graph. to simplify the exposition of the graphs below, we define bg as a set of blocks that is a tiling of the genomes : all pairs of blocks b <dig> b2∈bg have to be non-overlapping; for unaligned segments between blocks and unaligned segments at the ends of the genomes, bg includes blocks of size  <dig> 

two blocks b <dig> b2∈bg are adjacent if there are two segments s1∈b <dig> and s2∈b <dig> that are adjacent. since all blocks have two ends, there may be up to four different adjacencies between two blocks: the head of b <dig> can be adjacent to the head of b <dig> or to the tail of b <dig>  or the tail of b <dig> can be adjacent to the head of b <dig> or to the tail of b <dig>  each of the four adjacencies is defined by a set of adjacency positions between segments from the two blocks, e. g., if the tail of b <dig> is adjacent to the head of b <dig>  the adjacency is defined by the set of positions {q1} of segments s1∈b <dig> with s1= for which there is a segment s2∈b <dig> with s2= where p1=q <dig>  since a block can contain more than one segment from the same genome, a block can be adjacent to itself. in the literature, adjacencies of blocks are sometimes defined as segments between two blocks  <cit> . given that the set of blocks bg is a tiling of the genomes, we can refer to an adjacency as a set of single positions.

an adjacency of two blocks b <dig> b2∈bg is called a breakpoint if b <dig> and b <dig> are adjacent in only a subset of the segments. then, the set of positions that define the adjacency is smaller than the size of the block. more formally, let s1∈b <dig> and s2∈b <dig> be two adjacent segments with s1= and s2=. without loss of generality, let q1=p <dig>  then, b <dig> and b <dig> define a breakpoint if there is a segment s1′∈b <dig> with s1′= for which no segment s2′∈b <dig> with s2′= exists where q1′=p2′.

most commonly, genome alignment programs use pairwise local alignment methods to generate blocks. pairwise local alignments are blocks of size two. these blocks can be combined with each other to form blocks of a larger size  if a segment from one block fully overlaps with a segment from another block. we briefly address this preprocessing of blocks in the discussion and conclusions section, and assume that a set bg is given for constructing the graphs.

in the literature, blocks are often referred to as synteny blocks or locally colinear blocks. the definitions of blocks differ, usually depending on the specific type of local alignment method being used for generating blocks. for example, blocks can be defined as gapped or ungapped colinear alignments with or without mismatches, or simply as single alignment components. the graph representations are independent from the precise assignment of positions to alignment components within blocks. only the set of segments including their relative orientation within the block is relevant. for this reason, the different block definitions can be used interchangeably except for preprocessing the set of blocks to obtain bg .

within the graphs described in the following sections, blocks and adjacencies are represented by vertices or edges or a combination of both. for each graph, every genome is a  path through the graph. we use the term to thread for following the path of a genome through the graph  <cit> .

graphs for genome alignment
we limit our comparison to alignment graphs, a-bruijn graphs, enredo graphs, and cactus graphs. the original publications of these graphs use varying terminology. we describe all four graphs using the same terminology, namely the above defined terms segment, block and adjacency. figure  <dig> displays an example alignment with eleven blocks as alignment graph, a-bruijn graph, enredo graph, and cactus graph.


the input for building a graph is a set of non-overlapping blocks bg defined on a given set of genomes . we assume the blocks to be a tiling of . for all four graphs, we define the graph structuresg= as ordered pairs of vertices v and edges e. in addition, we define graph modelsm
g
=, which are ordered pairs of the respective graph structure g and a labeling functionℓ. most original publications remain vague about labels on vertices and edges of the graph structures. we define ℓ such that the set of blocks bg can be recovered from m
g
.

along with the definitions of g and m
g
 for each of the four graphs, we describe how it is possible to transform the different graph structures into each other . a transformation is an operation that has as input one graph structure g and outputs another graph structure g′, where both g and g′ represent the same genome alignment. if it is possible to obtain a graph structure g′ from another graph structure g without the help of bg and without a labeling function, then g provides at least as much alignment information as g′. moreover, if a graph structure g provides less information about the alignment than another graph structure g′, a transformation from g to g′ is ambiguous, thus, impossible.

we examine the transformations that are depicted as arrows in figure  <dig>  straight arrows indicate a possible transformation; the other arrows indicate that a transformation among the structures is impossible, which we prove below by providing examples for ambiguity. nevertheless, we describe all transformations depicted as arrows in figure  <dig>  using additional information from graph labels if necessary to resolve ambiguity. we define the sparse labeling functions ℓ
d
u
p
, ℓ
i
n
v
, or ℓ
a
d
j
 for this purpose. the sparse labeling functions provide sufficient information for the transformation but less information than ℓ in the graph models. note that a transformation among graph models is trivial given that bg can be recovered from the model m
g
 of any of the four graphs. the need for labels to resolve ambiguity proves that the graph structures g differ in their information content.

alignment graphs
in the following section, let g= be an alignment graph structure and m
g
= be an alignment graph model. we define ℓ as a labeling function of the vertices v of g. the set of edges e=e
a
∪e
b
 decomposes into a set of directed adjacency edges e
a
 and a set of undirected block edges e
b
. with both directed and undirected edges, g is a mixed graph.

the vertices v of g represent segments of the genomes. there is a vertex in v for every segment in the set of all segments  from all blocks bg. the function ℓ:v→s
b
 labels each vertex v∈v with the corresponding segment s∈s
b
 such that ℓ=s.

directed adjacency edges e
a
  represent adjacencies of segments. given any pair of vertices v <dig> v2∈v and their labels ℓ= and ℓ=, there is a directed edge e∈e
a
 from v <dig> to v <dig> if max{p <dig> q1}= min{p <dig> q2}, i. e., the segment ℓ is adjacent to the segment ℓ in . adjacency edges thread the genomes through the alignment graph.

finally, undirected block edges e
b
  connect vertices labeled with segments from the same block b∈bg. for each vertex v1∈v with ℓ∈b, there are undirected edges e
b
 between v <dig> and any other vertex v2∈v with ℓ∈b. as a consequence, each block b∈bg forms a block edge connected componentc⊆v in the alignment graph.

the formation of connected components is important for recovering bg from m
g
. let  be the set of block edge connected components of g. it holds v=⋃c∈cc, and c1∩c2=∅ for any c <dig> c2∈c. thus, we may recover bg by forming a block b={ℓ∣v∈c} for every component c∈c.

our definition of the alignment graph structure g models non-colinear changes among the input genomes, in particular translocations and duplications. translocations appear in g as mixed cycles. a mixed cycle is a cycle in a mixed graph formed by both directed and undirected edges. duplications appear as block edges within the set of vertices of one genome. because of these edges our alignment graph is not n-partite as in its original definition  <cit> .

inversions are not visible in the alignment graph structure g; the orientation of segments remains unclear . we define the sparse labeling function ℓ
i
n
v
:v→{+,−} as 

 ℓinv=+ifp<q−ifp>q, 

 where ℓ=. the function ℓ
i
n
v
 assigns bits to the vertices that indicate the orientation of the represented segments. as an alternative to vertex labels, it is possible to label block edges with bits that indicate equal or opposite orientation of the segments in the endpoints .

a-bruijn graphs
let now g= be an a-bruijn graph structure and m
g
= be an a-bruijn graph model. a-bruijn graphs have only one type of edge e. we define ℓ as a labeling function of the vertices v. in contrast, the functions ℓ
i
n
v
 and ℓ
d
u
p
 described below provide labels for the edges e.

the vertices v of g represent blocks. for every block in bg, there is a vertex in v. there is only one vertex per block regardless of the block’s size and of duplications. the function ℓ:v→bg labels each vertex v∈v with the corresponding block b∈bg such that ℓ=b. with this labeling, recovering bg from m
g
 is straightforward.

the edges e of g represent adjacencies just like adjacency edges in alignment graphs. given any pair of vertices v <dig> v2∈v and their labels b1=ℓ and b2=ℓ, there is a directed edge e∈e from v <dig> to v <dig> for every two adjacent segments s1= and s2= with max{p <dig> q1}= min{p <dig> q2} where s1∈b <dig> and s2∈b <dig>  if multiple adjacent pairs of segments exist in b <dig> and b <dig>  e contains multiple edges from v <dig> to v <dig>  thus, g is a multi-graph. in the present paper, we prefer the multi-graph representation with multiple separate edges between two vertices over the multi-graph representation with multiplicity labels on edges.

adjacency edges are essential for threading genomes through g. however, the path from threading one genome is not necessarily simple. it traverses vertices multiple times if duplications are present  making the path ambiguous. thus, threading requires label information that allows incoming and outgoing edges of a vertex to be paired. such information is not required in the alignment graph structure, where each vertex has at most one incoming and one outgoing edge. without duplications it is sufficient to color edges of g by genome  instead of providing the full labels ℓ. in the presence of duplications, g can be ambiguous even with color labels .

to resolve ambiguity of g for threading, we define the sparse labeling function ℓdup:e→ℕ as a total ordering on the edges. this function assigns numbers to the edges that describe the order of the adjacencies in the genomes. in figure  <dig>  for example, the edges could be numbered  <dig> through 8: for genome abdabcebc, one edge from a to b would be labeled with  <dig>  the edge from b to d would be labeled with  <dig>  the edge from d to a would be labeled with  <dig>  and so on; for genome abcebdabc, also one edge from a to b would be labeled with  <dig>  but then the edge from b to c would be labeled with  <dig>  and so on. to describe ℓ
d
u
p
 formally, we use adjacency positions of the edges e that we determine with the help of ℓ. given a pair of vertices v <dig> v2∈v, each edge e∈e from v <dig> to v <dig> corresponds to one pair of adjacent segments s1∈ℓ and s2∈ℓ with s1= and s2=. the adjacency position of e is a= max{p <dig> q1}= min{p <dig> q2}. then, ℓ
d
u
p
 assigns numbers to edges in e such that 

 ℓdup<ℓdupifa1<a <dig>  

 where a <dig> is the adjacency position of e <dig>  and a <dig> is the adjacency position of e <dig> 

furthermore, inversions create ambiguity in g . just like the alignment graph structure, g provides no information about the orientation of segments represented in a vertex. we define the sparse labeling function ℓ
i
n
v
:e→{+,−}×{+,−} for a-bruijn graph edges e. for each pair of adjacent segments s1= and s2= from the labels of two vertices s1∈ℓ and s2∈ℓ, we label an edge e= with 

 ℓinv=ifp1<q1∧p2<q <dig> ifp1<q1∧p2>q <dig> ifp1>q1∧p2<q <dig> ifp1>q1∧p2>q <dig>  

 the first bit in the label ℓ
i
n
v
 indicates the orientation of the segment in the source vertex of e, and the second bit the orientation of the segment in the target vertex. it is not sufficient to solely label vertices of g with one orientation bit per segment of the represented block. figure  <dig> provides an example where this leads to ambiguity.

below, we describe transformations between a-bruijn graphs and alignment graphs. as stated above, the transformation of the graph models is trivial, but the example in figure  <dig> proves that in some cases it is impossible to transform an a-bruijn graph structure into an alignment graph structure. we describe the transformation with the help of the sparse labeling function ℓ
d
u
p
 to resolve ambiguity.

a-bruijn graphs from alignment graphs.
to transform an alignment graph structure g′= into an a-bruijn graph structure g=, we follow the description of a-bruijn graphs in  <cit>  and exploit a many-to-one mapping from alignment graph vertices to a-bruijn graph vertices. the transformation is possible without additional information from a labeling function.

as a first step, compute all block edge connected components  of g′. as described above, each component represents exactly one block, and each vertex v′∈v′ is part of exactly one component. now, add for every component c∈c a vertex to the set of a-bruijn graph vertices v. we obtain a many-to-one mapping of alignment graph vertices to a-bruijn graph vertices. we keep the mapping as a label m=v on each alignment graph vertex v′∈v′. the label indicates the a-bruijn graph vertex v that represents the connected component containing v′.

the remaining task is to transfer adjacency edges from the alignment graph to the a-bruijn graph. using the mapping, add an edge e= to the set of a-bruijn graph edges e for each edge e′= from the set of alignment graph adjacency edges ea′, where u=m and v=m.

a-bruijn graphs to alignment graphs.
we describe the transformation of an a-bruijn graph structure g= into an alignment graph structure g′= given the labeling function ℓ
d
u
p
 for the edges of g in addition to g. in accordance with the transformation from g′ to g, we successively create a one-to-many mapping from a-bruijn graph vertices to alignment graph vertices during the transformation. the mapping m labels each a-bruijn graph vertex v∈v with a set of alignment graph vertices from v′. at the beginning m={} for all v∈v. at the end, a label m={v1′,…,v|b|′} indicates the set of alignment graph vertices {v1′,…,v|b|′} that form the connected component for a block b represented by v in the a-bruijn graph.

we transform the a-bruijn graph by following each genome separately and assume that the edges are given in increasing order of labels: ℓ
d
u
p
<ℓ
d
u
p
<⋯<ℓ
d
u
p
. initially, add for each genome a new vertex u′ to the set of alignment graph vertices v′. if the source vertex u of the a-bruijn graph edge e1= is labeled with a non-empty set of vertices m={u1′,…,uk′}, add undirected edges between u′ and all vertices u1′,…,uk′ to the set of alignment graph block edges eb′. next, add u′ to the set of vertices mapped to u. repeat these three steps for the target vertex v of e1: add a vertex v′, add block edges, and add v′ to the mapping. in addition, add a directed edge from u′ to v′ to the set of alignment graph adjacency edges ea′.

iterate over the a-bruijn graph edges in increasing order of labels and repeatedly add for the target vertex a new vertex, add block edges, add the new vertex to the mapping, and add an adjacency edge from the previous to the new vertex. this way, the genomes are threaded through the a-bruijn graph and the alignment graph structure g is successively built up.

enredo graphs
in this section, let g= be an enredo graph structure and m
g
= be an enredo graph model. in an enredo graph, the set of edges e=e
a
∪e
b
 decomposes again into a set of directed adjacency edges e
a
 and a set of undirected block edges e
b
. we define ℓ as a labeling function of the block edges e
b
.

the block edges e
b
 of g represent blocks, and vertices v of g represent the ends of blocks. in contrast to alignment graphs, a single block edge represents an entire block. for every block b∈bg, there are two vertices in v connected by an undirected block edge e
b
∈e
b
 . the function ℓ:eb→bg labels each block edge e
b
∈e
b
 with the corresponding block b∈bg such that ℓ=b. by choosing one of the two possible block representations as label, the two vertices that are connected by e
b
 are implicitly labeled as head and tail of the block. note that they are not labeled as head or tail in g. given the block labels, recovering bg from m
g
 is again straightforward.

directed adjacency edges e
a
 of g  represent adjacencies. given any pair of block edges e1={u
t
,u
h
} and e2={v
t
,v
h
} and their labels ℓ=b <dig> and ℓ=b <dig>  there is a directed edge e∈e
a
 from an endpoint of e <dig> to an endpoint of e <dig> for every two adjacent segments s1= and s2= with s1∈b <dig> and s2∈b <dig>  in contrast to alignment graphs and a-bruijn graphs, the endpoints of adjacency edges in g indicate in relation to other adjacency edges the orientation of segments in a block. given labels, one endpoint of each block edge is a head vertex and the other a tail vertex. if p1<q <dig>  then the adjacency edge e starts at the head vertex u
h
, and if p1>q <dig>  e starts at the tail vertex u
t
. if p2<q <dig>  then e points to the tail vertex v
t
, and if p2>q <dig>  e points to the head vertex v
h
. in other words, e= if q1=p <dig>  e= if q1=q <dig>  e= if p1=p <dig>  and e= if p1=q <dig>  again, there may be several adjacency edges connecting the same two vertices. thus, the enredo graph is also a multi-graph.

due to its two-vertex concept, the structure of an enredo graph g reflects the relative orientation of blocks as opposed to the alignment graph structure and the a-bruijn graph structure . g is capable of displaying inversions. but just like a-bruijn graphs, threading a genome with duplications through g can be ambiguous . the path from threading a genome through g alternates between block and adjacency edges. therefore, only multiple occurrences of a block in the same orientation create ambiguity in g.

to resolve ambiguity of g, we define the sparse labeling function ℓdup:ea→ℕ as a total ordering on the adjacency edges. as for a-bruijn graphs, we can use the labeling function ℓ to determine the adjacency position of an edge e∈e
a
. the function ℓ
d
u
p
 assigns again numbers to the edges e
a
 such that 

 ℓdup<ℓdupifa1<a <dig>  

 where a <dig> is the adjacency position of e <dig>  and a <dig> is the adjacency positions of e <dig>  as an example, we use again figure  <dig> with labels  <dig> through 8: one of the edges from the head of a to the tail of b would be labeled with 1; for genome abdabcebc, the edge from the head of b to the tail of d would be labeled with  <dig>  and for genome abcebdabc, the edge from the head of b to the tail of c would be labeled with 2; and so on.

we generalize the enredo graph compared to its original definition  <cit>  in some aspects. enredo graphs originally consider blocks of size  <dig> as adjacencies: instead of a block edge with two end vertices that are connected to the rest of the graph by two adjacency edges, the enredo method only adds a single adjacency edge labeled with a segment. this requires another function ℓ
a
:e
a
→s that labels adjacency edges e
a
 with segments s. in addition, in the initial phase of the enredo method segments on adjacency edges between the same two blocks are assumed to be homologous. because of this assumption and to distinguish non-homologous multi-edges later on, the enredo method prefers the multi-graph representation with multiplicity labels on one adjacency edge over multiple separate edges. we argue that all segments that are assumed to be homologous should be defined as blocks. consequently, our description with blocks of size  <dig> is valid and even simplifies the exposition of the method.

furthermore, the enredo method only adds edges for adjacencies that are shorter than a predefined threshold. this results already in a partial segmentation of the genomes bearing several segments per genome in the graph. parts of the genomes may not be represented. we add all adjacencies to the graph and leave it to later stages to modify the graph.

in the transformations below, we include the replacement of labeled adjacencies by blocks of size  <dig>  the transformation from an enredo graph structure to an a-bruijn graph structure is possible without additional labels. the other direction, from a-bruijn graphs to enredo graphs, requires additional information about inversions as shown by the example in figure  <dig> 

enredo graphs from a-bruijn graphs
first, we describe the transformation of an a-bruijn graph structure g′= into an enredo graph structure g= using the labeling function ℓ
i
n
v
:e′→{+,−}×{+,−}. then, we describe the transformation of blocks of size  <dig> to labeled adjacency edges in the enredo graph given full block information by the function ℓ for transferring labels.

to transform g′ into g, add for each a-bruijn graph vertex v′∈v′ a tail vertex v
t
 and a head vertex v
h
 to the set of enredo graph vertices v. additionally, add an undirected edge e
b
 between v
t
 and v
h
 to the set of enredo graph block edges e
b
. we obtain a one-to-one mapping of a-bruijn graph vertices and enredo graph block edges, which we keep as separate labels m:v′→e
b
 on a-bruijn graph vertices such that m=e
b
.

using the labeling function ℓ
i
n
v
 and the mapping m, we can unambiguously transfer adjacency edges to the enredo graph. for each edge e′= in the set of a-bruijn graph edges e′ where m=e
u
 and m=e
v
, add an edge e= to the set of enredo graph adjacency edges e
a
 where u
x
 is an endpoint of e
u
 and v
y
 is an endpoint of e
v
. the vertex u
x
 is the head vertex of e
u
 if the first bit in ℓ is +, and otherwise the tail vertex. the vertex v
y
 is the tail vertex of e
u
 if the second bit in ℓ is +, and otherwise the head vertex.

in another step, we can transform all block edges e
b
={v
t
,v
h
} representing blocks of size  <dig> into adjacency edges. since the size of ℓ is  <dig>  the corresponding vertices v
t
 and v
h
 are incident to exactly one adjacency edge each, e1= and e2=. replace such sets of two vertices v
t
, v
h
 and three edges e <dig>  e <dig>  e
b
 by a new adjacency edge e=. finally, transfer the label of the block edge ℓ={s} to the adjacency edge such that ℓ
a
=s.

enredo graphs to a-bruijn graphs
we start by describing how to recover block edges for blocks of size  <dig> from adjacency edges that are labeled with segments by ℓ
a
 in an enredo graph structure g=. afterwards, we describe the transformation from g to an a-bruijn graph structure g′=, which is possible without additional labels.

replace each edge e= from the set of enredo graph adjacency edges e
a
, where ℓ
a
=s, by two vertices v
t
 and v
h
 and a block edge e
b
=, and set ℓ={s}. further, add e1= and e2= to the set of enredo graph adjacency edges e
a
.

for the transformation to an a-bruijn graph, add for each edge e
b
= in the set of enredo graph block edges e
b
, a vertex v′ to the set of a-bruijn graph vertices v′. again, we obtain a one-to-one mapping of enredo graph block edges and a-bruijn graph vertices, which we keep this time as labels m:e
b
→v′ on enredo graph block edges such that m[ e
b
]=v′. finally, add for each edge e= in the set of enredo graph adjacency edges e
a
 where u
x
 is incident to the block edge e
u
 and v
y
 is incident to the block edge e
v
, an edge e′= to the set of a-bruijn graph vertices, where m[ e
u
]=u′ and m[ e
v
]=v′. in this last step, we lose inversion information in the graph’s structure.

cactus graphs
in this section, let g= be a cactus graph structure and m
g
= be a cactus graph model. cactus graphs have only one type of edges. we define ℓ as a labeling function of the edges e. the cactus graph structure g stands out from the other graph structures by fulfilling well-defined structural properties: every edge e∈e is part of at most one simple cycle, which makes g a cactus graph  <cit> , and g has an eulerian circuit  <cit> . a number of construction steps guarantee these properties.

let a be the set of all adjacencies of segments. the vertices v of g partition a into a set of pairwisely disjoint subsets Ω: each element ν∈Ω is a subset of a, μ∩ν=∅ for any two sets μ,ν∈Ω, and ⋃ν∈aν=a. for each subset ν∈Ω, there is a vertex in v. in addition, g has one distinct vertex, the origin, that represents the start and end of all genomes ϕ. in figure  <dig>  for example, the vertex ϕ represents the start and end, the vertex α∪β represents a subset of twelve adjacencies, the vertex γ represents a subset of eleven adjacencies, and the vertex δ represents a subset of seven adjacencies. in the vertex δ, for example, three of the adjacencies are from the red genome, two from the blue genome, and another two from the green genome as shown in the enlarged vertices. the subsets correspond to subgraphs of the enredo graph . all adjacencies at one end of a block are always part of the same subset. we describe the details on how to determine the subsets below in the transformation from enredo graphs.

the edges e of g represent blocks just like block edges in enredo graphs. for each block b∈bg, there is an undirected edge e={u,v} in the set of cactus graph edges e . the endpoint u∈v of e represents a subset of adjacencies μ∈Ω that contains all adjacencies at one end of b, and the other endpoint v∈v represents ν∈Ω that contains all adjacencies at the other end of b. it is possible that u=v. the function ℓ:e→bg labels each block edge e∈e with the corresponding block b∈bg such that ℓ=b. with this labeling, recovering bg from m
g
 is again straightforward.

the cactus graph has no directed edges as found in other graphs. since vertices of g represent segment adjacencies in sets, the size of blocks and the number and precise set of adjacencies remain unclear in the structure. recovering this information from g is impossible as the following examples from figure  <dig> demonstrate: the cactus graph structure does not tell how many genomes traverse block f and whether block i and k are adjacent in one of the genomes or not.

still, each genome corresponds to a  path through g. with the help of labels we can recover this path. the colored lines in the enlarged vertices in figure  <dig> provide the equivalent information as colored adjacency edges in enredo graphs and would resolve ambiguity for threading if no duplications were present. more information is necessary to resolve all ambiguity. we suggest ℓadj:e→2{+,−}×ℕ, where 2
x
 denotes the power set of a set x, to label the edges with lists of pairs of an orientation bit and a positive number. the lists have an entry for each segment of the blocks b=ℓ. the orientation bits are necessary to determine the relative orientation of segments within blocks that are represented by edges e= . the numbers impose a strict total ordering ≺ on all genome segments s <dig> s2∈s where s1≺s <dig> if s <dig> is left of s <dig> 

cactus graphs are not as independently used as the other genome alignment graphs. the cactus method operates on two graphs, the cactus graph and another graph called the adjacency graph  <cit> . interestingly, the latter has the same structure as an enredo graph. we view the cactus graph, which enables the characterization and detection of new substructures, as a supergraph on top of the enredo graph. the transformation of enredo graph structures to cactus graph structures conforms with the construction of a cactus graph  <cit>  and does not require additional labels. the transformation back to enredo graphs is ambiguous as the above mentioned examples from figure  <dig> show. for this reason, our description of this transformation uses the sparse labeling ℓ
a
d
j
 in addition to the graph structure.

cactus graphs from enredo graphs
to transform an enredo graph structure g′= into a cactus graph structure g=, we follow three steps described in  <cit> . first, we transform the enredo graph into a precursor cactus graph. the second and third steps modify the precursor to ensure the structural properties of cactus graphs. the second step guarantees that every edge is part of at most one simple cycle. after the third step, the graph is eulerian. throughout all steps, we make use of a many-to-one mapping m:v′→v from enredo graph vertices v′ to cactus graph vertices v, which labels each enredo graph vertex v′∈v′ with a cactus graph vertex v∈v such that m=v.

first, compute all adjacency-edge connected componentsca in the enredo graph structure g′. each component c∈ca is a subset of the vertices v′. for each c∈ca, add a vertex to the set of cactus graph vertices v. assuming that the start and end of all genomes are connected, add only one origin vertex for all of them to v. we obtain the many-to-one mapping that indicates the cactus vertex representing the adjacency edge connected component of any enredo graph vertex. given this mapping, transfer the enredo graph block edges e
b
 to the cactus graph: for each edge e′={u′,v′} in the set of enredo graph block edges e
b
, where m=u and m=v, add an edge e={u,v} to the set of cactus graph edges e. it is possible that u=v even if u′≠v′. this yields the precursor cactus graph in figure  <dig> 

in the second step, remove sets of vertices from v that are 3-edge-connected and add instead a single vertex v to v . correct the mapping m and redirect block edges that were incident to any vertex in the 3-edge connected component, to be incident to v.

finally, replace connected components formed only by edges whose removal disconnect the graph . each such component is a tree with leaf and branching vertices v <dig> …,v
c
. remove v <dig> …,v
c
 and add instead a new vertex v to v. just as before, correct the mapping m and redirect incident block edges to v.

cactus graphs to enredo graphs
in the transformation from a cactus graph structure g= to an enredo graph structure g′=, we use the labels ℓ
a
d
j
 to separate the sets of adjacencies represented by cactus graph vertices v and to add edges ea′ that represent single adjacencies to the enredo graph structure. in addition, we create a one-to-one edge mapping m:e→eb′ that labels each cactus graph edge e∈e with an enredo graph block edge eb′∈eb′ where eb′={u′,v′}. in this mapping, we store a direction of each enredo graph block edge and distinguish the tail vertex u′ from the head vertex v′ such that m=. the direction is not present in the enredo graph structure g′. the transformation proceeds by threading the genomes  through g.

initially, identify among all cactus graph edges incident to the origin vertex u∈v the edge e0={u,v} whose label contains the smallest number n0∈ℓ
a
d
j
 where n0<n and n∈ℓ
a
d
j
 with e={u,x}. add two vertices u′ and v′ to the set of enredo graph vertices v′ and an edge eb′={u′,v′} to the set of enredo graph block edges eb′. update the mapping such that m=. keep a reference to v′ for the next step.

among all edges incident to v, identify the next edge e1= whose label contains the next larger number n1∈ℓ
a
d
j
 such that n1>n <dig> but n1<n where n≠n <dig> and n∈ℓ
a
d
j
 with e={v,x}. if the mapping for e <dig> is undefined, add two vertices v′′ and w′ to the set of enredo graph vertices v′ and an edge eb′={v′′,w′} to the set of enredo graph block edges eb′. update the mapping such that m=. further, add an edge ea′= to the set of enredo graph adjacency edges e
a
 and keep w′ for the next step. if the mapping for e <dig> is already defined with m=, only add an adjacency edge: if the orientation bit in ℓ
a
d
j
 is +, add the edge ea′= to the set of enredo graph adjacency edges e
a
 and keep w′ for the next step. if the orientation bit is −, add an edge ea′= and keep v′′ for the next step.

next, repeat the same for incident edges of w. proceed like this until reaching the end of all genomes to obtain the full enredo graph structure g′.

all in all, the need for labels shows that the four graphs markedly differ in the information represented in their structures. complete duplication information  is only present in alignment graph structures, and only the structure of enredo graphs reveals inversion information . a-bruijn graphs are a compact and intuitive representation but lack both inversion and duplication information. finally, cactus graph structures do not represent parts of the adjacency information . despite these structural differences, all graph models, which include labels, can be transformed into each other.

based on these observations, some advantages or disadvantages of the graph structures become apparent. for example, for a genome aligner intended to reveal inversions, an enredo graph structure appears to be more suitable, whereas a more general analysis of the genetic content of genomes will work well with the more compact a-bruijn graph structure. duplications are best visible in an alignment graph structure. the advantage and information provided by cactus graphs subdivides genomes into independent regions revealing specific and unique substructures as described in the following.

graph substructures
we collected substructures from graph-based genome alignment approaches and classify them here into four types: colinear paths, visiting blocks, short cycles, and cactus groups. substructures are useful for deriving a meaningful genome segmentation or they indicate misalignment, i. e., the alignment of non-homologous segments. furthermore, they pinpoint parts of genome alignments that can be improved through modification.

some substructures have been described for several graph-based approaches, while others are unique to only one approach. we conjecture that it is possible to identify all substructures in all graph models. if the time complexity for detecting occurrences of the substructures was the same in all graphs models, they could be used interchangeably. here, our aim is to analyze abilities of the graph structures to reveal potential misalignments without additional information from labels.


colinear paths
we refer to the first type of substructures as colinear paths. colinear paths are sets of blocks that appear in one or more genomes consecutively in the same orientation and without breakpoints in between. a sequence of blocks b <dig> …,b
k
 forms a colinear path if there is an adjacency but no breakpoint between b
i
 and b
i+ <dig> for all i= <dig> …,k− <dig>  consequently, all blocks along a colinear path have the same size and there are segments s1∈b <dig> and s
k
∈b
k
 with s1= and s
k
= such that s= is a consecutive genome segment that concatenates one segment from each block b <dig> …,b
k
. we also consider a single block as a colinear path.

a colinear path is maximal if it cannot be further extended by other adjacent blocks, but is bounded by breakpoints. note that alignment modifications often remove bounding breakpoints such that a colinear path can again be further extended. the set of maximal colinear paths of a genome alignment determines the final genome segmentation. independent from the underlying graph structure, all graph-based genome alignment methods have the common aim to maximize colinear paths both in terms of size  and length .

in enredo graphs, simple non-branching paths are colinear paths. similarly, colinear paths appear as non-branching paths in the a-bruijn graph structure, but here a non-branching path is not necessarily a colinear path. along a non-branching path in a-bruijn graphs, one or more blocks can be inverted in a subset of the genomes. the structure of a-bruijn graphs provides no information about inversions . thus, to detect colinear paths in a-bruijn graphs, information from labels is necessary. only a single vertex is detectable as  colinear path in the structure of a-bruijn graphs. the same holds for the alignment graph structure: the detection of consecutive blocks is straightforward, but in order to avoid the inclusion of inverted blocks that break colinearity, additional information about inversions is necessary. and finally, colinear paths appear in the cactus graph structure as non-branching paths although non-branching paths are not necessarily colinear paths.

visiting blocks
we name the second type of substructure visiting block, which conceptually is a special type of a maximal colinear path. a maximal colinear path {b <dig> …,b
k
} is a visiting block if there is a block b <dig> adjacent to b <dig> and a block b
k+ <dig> adjacent to b
k
 with the following two symmetric conditions : for all segments s= of the colinear path that are adjacent at position p <dig> to a segment s0∈b <dig>  there is a segment s
k+1∈b
k+ <dig> adjacent to s at position q
k
; and for all segments s= that are adjacent at position q
k
 to a segment s
k+1∈b
k+ <dig>  there is a segment s0∈b <dig> adjacent to s at position p <dig>  the important property is that all segments from block b <dig> that are adjacent to segments of the colinear path, continue in the same block b
k+ <dig> at the other end of the colinear path and vice versa.

a visiting block arises from merging blocks from within a colinear path with other blocks. if the merged blocks are short, they often only have spurious similarity. hence, they break colinearity at two positions without providing much evidence for a large structural change. this is a reason why genome aligners address visiting blocks and separate the otherwise colinear paths.

in a-bruijn and enredo graphs, visiting blocks appear as simple non-branching paths bounded by branching vertices. in enredo graphs, the path always starts and ends with a block edge. in both graphs, at least one branch which enters the visiting block at one end must be formed by a set of segments that leaves the visiting block as its own separate branch at the other end . this condition makes it impossible to identify visiting blocks in the a-bruijn and enredo graph structures. likewise, the structure of cactus graphs alone does not reveal visiting blocks. only in the structure of alignment graphs, it is possible to determine whether a given colinear path is a visiting block or not.

visiting blocks have been described for a-bruijn graphs as microblocks  <cit>  and also for enredo graphs both implicitly in the “joining” operation and explicitly as a first type of “aberrant homologies”  <cit> . furthermore, we view another type of “aberrant homologies” from enredo graphs as a special case of this substructure: retrotransposed pseudogenes that cause a series of successive visiting blocks.

short cycles
cycles in genome alignments are indicators for rearrangement. a change in one of two identical genomes often introduces a cycle in the corresponding genome alignment. in the same way, spurious similarity causes cycles and breaks colinearity. if there are many cycles, they often hide significant colinearity. for this reason, many genome aligners eliminate short cycles.

specific types of cycles also play a role for colinear sequence alignment. for example, alignment graphs without mixed cycles are colinear alignments  <cit> . thus, we can compute colinear alignments by eliminating mixed cycles from alignment graphs. similarly, the partial order alignment  program  <cit>  uses directed acyclic graphs  for alignment representation, essentially a-bruijn graphs without directed cycles.

we define a genome alignment cycle as a sequence of blocks b <dig> …,b
k
 where block b
i
 is adjacent to block b
i+ <dig> for all i= <dig> …,k− <dig> and b
k
 is adjacent to b <dig>  further, we require all sets of positions that define adjacencies between two blocks b
i
 and b
i+ <dig> along the cycle to be disjoint. thereby we exclude pairs of adjacent blocks from the set of genome alignment cycles. a cycle is short if the total length of segments along the cycle is below a given length threshold.

the definition of genome alignment cycles corresponds to simple mixed cycles in the enredo graph structure. they mostly appear in the a-bruijn graph structure and alignment graph structure as  simple cycles, too, but there is no one-to-one correspondence: the alignment graph structure can have more than one cycle for a single genome alignment cycle ; and genome alignment cycles that are caused by inversions are not visible in the alignment graph structure and a-bruijn graph structure. figure 9b shows an example for two genome alignment cycles that appear as a single cycle in the a-bruijn graph structure. despite these essential differences, cycles in the alignment graph structure, a-bruijn graph structure, and enredo graph structure always correspond to genome alignment cycles as opposed to cycles in the cactus graph structure. subgraphs in the structures of alignment graphs, a-bruijn graphs, and enredo graphs that correspond to cycles in the cactus graph structure are not even necessarily connected .

in the following, we discuss two characteristics for discriminating between different types of cycles, the orientation of adjacencies and the number of maximal colinear paths. next, we briefly address the special case of palindromes. in addition, we describe how simple cycles in cactus graphs are used as characteristic substructures although they differ from genome alignment cycles.

orientation of adjacencies
a-bruijn graphs represent adjacencies as directed edges. this allows classifying cycles into those that follow the direction of edges and those that ignore the direction of edges. pevzner and colleagues refer to the two types of cycles as whirls and bulges  <cit> . whirls are directed, and bulges ignore the direction of edges. the graph-based genome aligner aba addresses whirls and bulges in a-bruijn graphs  <cit> .

the classification of cycles in whirls and bulges becomes ambiguous when the graph represents multiple genomes. it depends on the initially chosen relative orientations of the genomes. if we invert a subset of the genomes, some whirls become bulges and some bulges become whirls . note that whirls and bulges have been first introduced for repeat resolution within one genome  <cit> , where the classification in whirls and bulges is unambiguous.

number of maximal colinear paths
a genome alignment cycle is formed by complete maximal colinear paths and possibly single additional blocks. for example, the cycle in figure  <dig> is formed by the maximal colinear path consisting of the single block b and two additional blocks a and c. a and c may be part of longer maximal colinear paths. in contrast to the orientation of adjacencies, the number of maximal colinear paths classifies the cycles unambiguously  <cit> .

the a-bruijn graph based approach drimm-synteny  <cit>  uses a classification of cycles into one-way, two-way, and composite cycles, which is similar but not equivalent to a classification according to the number of maximal colinear paths. drimm-synteny focuses only on one-way and two-way cycles even though there can be cycles formed by more than two paths. the “annealing” operation in enredo  <cit>  places special emphasis on cycles formed by two maximal colinear paths after each of these paths has been joined to a single adjacency edge. in addition, enredo addresses all other cycles as the third type of “aberrant homologies”.

palindromes
palindromes in genomes are inverted tandem duplications. hence, they traverse a duplicated block twice and in both directions. palindromes create a special type of cycles in genome alignments formed by only one adjacency at one end of a block. for the detection of palindromes and distinction against tandem repeats, inversion information is necessary. thus, the structure of alignment graphs and a-bruijn graphs alone cannot reveal palindromes. in enredo graphs, we recognize palindromes by an adjacency edge loop . palindromes are separately addressed as “thorns” in a-bruin graphs  <cit>  and mentioned as “aberrant homologies” in enredo  <cit> .

cactus chains
in cactus graphs, simple cycles are named chains <cit> . the corresponding subgraphs of cactus chains in enredo graphs, a-bruijn graphs, and alignment graphs are not necessarily connected . but even though chains do not correspond to continuous segments of genomes, they represent conserved orders of blocks . cactus chains are addressed by the cactus method.

it is possible to identify the subset of blocks forming a cactus chain in the enredo graph structure, for the simple reason that an enredo graph can be transformed into a cactus graph. however, it appears impossible to characterize chains in enredo graphs without computing e. g., 3-edge connected components. in the structure of alignment and a-bruijn graphs, information about the orientation of adjacent blocks is missing for identifying cactus chains.

cactus groups
paten et al. refer to adjacency edge connected components, which are computed for constructing a cactus graph, as groups <cit> . a cactus group is a set of adjacencies that forms an adjacency-edge connected component in the enredo graph. all adjacencies of one group are represented by one vertex in the cactus graph structure, but a cactus graph vertex can represent several groups. strictly speaking, cactus groups are visible in the structure of enredo graphs but not in the structure of cactus graphs. similarly, it is not possible to recognize groups in the alignment graph and a-bruijn graph structures because this requires information about the orientation of adjacent blocks.

in summary, inversion and duplication information is necessary for the complete detection of all substructures. visiting blocks require duplication information, and all other substructures require inversion information. hence, none of the four graphs reveals all substructures solely by its structure.

this concludes our classification of substructures on the basis of a not necessarily exhaustive list of substructures. identification of further substructures or an assessment of their relevance for the accuracy of genome alignments may possibly point towards another way of classifying them.

modifications
graph-based genome aligners modify the genome alignments by eliminating substructures from the graphs. the aim is to reveal long conserved homologies, i. e., blocks of large size and length. as mentioned in the introduction, genome alignment comprises selection of local alignments and segmentation. here, we describe modifications that eliminate substructures either by modifying the set of local alignments represented in blocks  or by determining breakpoint positions that will be part of the final segmentation .

these four modifications derive from the mentioned graph-based genome alignment approaches, but they match the operations described for the approaches only in part. some genome alignment approaches clearly separate block modification and segmentation, other approaches do both tasks together. similarly, some approaches apply compound operations consisting of several of the modifications described here. our intention is to provide small modification entities from which it is possible to assemble more complex operations.

we describe every modification on the set of blocks . furthermore, we mention effects of the modifications in the graph structures although they can be applied to a genome alignment independently from a graph structure. we explain how these modifications correspond to operations in the graph-based genome alignment approaches, especially if the correspondence is not obvious. for example, this is the case for drimm-synteny  <cit> , which solves the sequence modification problem  on a-bruijn graphs. the method modifies the sequences and determines the segmentation on the modified sequences before transforming the sequences back. we transfer the effects directly to the original sequences and set of blocks, and refer to the modifications accordingly. the four modifications cover all operations described in the programs aba, drimm-synteny, enredo, and cactus.


splitting blocks
the most prevalent modification is splitting a block by dividing its set of segments into subsets that form new smaller blocks. formally, the modification replaces a block b={s <dig> …,s
n
}, where n≥ <dig> is the size of b, by two blocks b1={s <dig> …,s
k
} and b2={s
k+ <dig> …,s
n
}, 1≤k<n. the new blocks may have size  <dig>  thus may consist of a single segment. transferred to the original set of local alignments from which the blocks were formed, this modification corresponds to removing local alignments. in some cases, it is enough to remove a single pairwise local alignment to split a block into two blocks. in other cases, a particular subset of the local alignments needs to be removed simultaneously.

splitting blocks has different effects on the genome alignment graphs . in the alignment graph structure, the splitting corresponds to removing all edges between two vertex subsets of a block edge connected component. in a-bruijn graph structures, where vertices represent blocks, the modification replaces a vertex by two new vertices; incoming and outgoing edges are connected to the respective new vertex. the effect of splitting blocks in enredo graph structures is very similar: the modification duplicates a pair of head vertex and tail vertex connected by a block edge, and reconnects incoming and outgoing adjacency edges accordingly. in cactus graph structures, the splitting of block edges can lead to complex rearrangements with both splitting and merging of vertices.

graph-based genome aligners eliminate many substructures using this modification. by splitting blocks, we can clearly modify a graph so as to eliminate visiting blocks , which is done in the programs drimm-synteny and enredo. while enredo splits a block into two blocks of arbitrary size, drimm-synteny splits single segments from a block, thus creating blocks of size  <dig>  additionally, this modification can eliminate small cycles, e. g., whirls in a-bruijn graphs  <cit>  and mixed cycles in alignment graphs. further, the sequence modifications in drimm-synteny for one-path cycles and palindromes result in the splitting of segments from blocks. finally, the “melting” operation in the cactus method splits all blocks along a cactus chain into blocks of size  <dig> 

merging parallel blocks
the opposite to block splitting is a modification that merges blocks by adding local alignments between segments of the blocks. to merge two blocks b1={s <dig> …,s
k
} and b2={s
k+ <dig> …,s
n
} of size k and size n−k, respectively, into a new block b={s <dig> …,s
n
} of size n, it is sufficient to add a local alignment of two segments s
i
∈b <dig> and s
j
∈b <dig>  such local alignments can be new or previously removed by splitting blocks. note that merging of parallel blocks implicitly aligns all segments of the two blocks.

the effect on the graph structures is the reverse of block splitting. in the alignment graph structure, it corresponds to adding block edges. in the a-bruijn graph structure two vertices are replaced by a single vertex. in the enredo graph structure, two block edges with head and tail vertices are being replaced by a single block edge with one head and one tail vertex. in the cactus graph structure, merging of parallel blocks can lead to complex rearrangements just as splitting of blocks. the result is typically a longer chain or a new sub-cactus.

graph-based genome alignment approaches usually merge blocks based on the structure of surrounding blocks. two-way cycles and bulges in a-bruijn graphs and enredo graphs are substructures that suggest to merge parallel blocks  <cit> . furthermore, the genome segments within cactus groups are more likely to be homologous than others, hence, subject to merging  <cit> . both in enredo and in cactus graphs, the modification is termed “annealing”.

merging consecutive blocks
the preceding two modifications often generate new or longer colinear paths. it is possible to replace the consecutive blocks of a colinear path by a new longer block that rules out the possibility of a breakpoint between the merged blocks. the modification replaces two adjacent blocks b1={s <dig> …,s
n
} and b2={s1′,…,sn′} without breakpoint in between by a longer block b that is formed by the concatenation of all adjacent segments s
i
 and si′ where i= <dig> …,n. merging consecutive blocks does not directly affect the alignment of the genomes, but simplifies the graph structures and also genome segmentation.

the effects on the graphs are straightforward. in the alignment graph structure, a single vertex replaces each pair of vertices in two adjacent block edge connected components. in the a-bruijn graph structure, one vertex replaces two consecutive vertices. in the enredo graph structure, one block edge replaces a path consisting of a block edge, adjacency edge, and another block edge. and similarly in the cactus graph structure, one block edge replaces a path of a block edge, a vertex, and another block edge, thereby reducing the number of vertices in a chain.

merging consecutive blocks is part of the “joining” operation in the enredo method  <cit> . the other approaches do not apply this modification.

cutting adjacencies
as opposed to merging consecutive blocks, the last modification fixes a breakpoint in the genome alignment by cutting genomes into several segments. for example, given a block b={s <dig> …s
n
} with s
i
= where i= <dig> …,n and with a breakpoint at the tail of b, the modification cuts the genomes at all positions q
i
. the modification does not affect the set of blocks but rather the set of genomes. thus, it is part of the genome segmentation process.

cutting adjacencies corresponds to removing a single edge from an a-bruijn graph structure, a single adjacency edge from an enredo graph structure, or a set of adjacency edges from an alignment graph structure. again, there are multiple possible effects in a cactus graph structure. in the simplest case, the cactus graph structure remains unchanged. in all graphs, the removal of edges can disconnect the graph structures, generating several components that correspond to disjoint sets of genome segments. thus, it can become impossible to thread the genomes through the graphs without additional effort  <cit> .

cutting adjacencies is used in various ways by genome alignment approaches. the aba method cuts adjacencies for eliminating bulges from a-bruijn graphs and the enredo method for eliminating small cycles in general. in addition, the segmentation processes in a-bruijn and enredo graphs implicitly use this modification: in drimm-synteny, segmentation is realized by coloring the graph. in enredo, it is realized by excluding adjacencies shorter than a given length threshold. genome segmentation in alignment graphs and cactus graphs has not been described explicitly.

discussion and 
CONCLUSIONS
we compared four graph data structures and their usage for genome alignment. our comparison identified that essential pieces of information about duplication and inversion are only present in the structures of some graphs. in addition, we examined substructures in the graph structures that are subject to elimination in various genome alignment approaches, and determined four classes of substructures. we found that information about duplications or information about inversions or even both are necessary for distinguishing any type of substructure in the graphs. thus, it is indeed essential to keep additional information in labels of the vertices or edges, though the different graphs depend on the labels to a lesser or greater extent. finally, we reduced the set of operations applied for eliminating substructures from the graphs to four elementary modifications. overall, it became apparent that many ideas are shared by all graph-based approaches.

these shared ideas allow us to derive a framework for graph-based genome alignment , an abc to g-enome alignment. it begins with the computation of local colinear alignments among the input genomes . the choice of the local alignment method is mostly independent from the following steps though it influences the resulting genome alignments. combining local alignments to blocks, we can build a graph . which graph to choose depends on the respective importance of different substructures for an application. next, a graph-based genome alignment approach always characterizes a set of graph substructures . substructures sometimes have equivalences in other graphs, but may as well be distinguishable in the structure of only one graph. detection of all substructure occurrences  is a requirement for their subsequent elimination . elimination is accomplished by modifying the underlying set of blocks and sometimes also by introducing breakpoints in the genomes. the breakpoints determine already parts of a genome segmentation, which is finished in a last step . the segmentation together with the modified set of blocks defines the genome alignment .

this framework describes the main procedure of graph-based genome alignment. still, it has limitations and there are additional problems to be solved. one such problem addresses blocks and occurs before building a graph. if we do not break up the local colinear alignments into alignment components, blocks may in general partially overlap. it is possible to resolve overlapping blocks by trimming  <cit>  or avoid overlaps by requiring local alignments to be sparse  <cit> . a good alternative, which is for example used by the genome aligner mugsy  <cit> , is to obtain a set of mutually disjoint blocks by refining segment matches  <cit> . a segment match refinement resolves overlaps through modest computation without losing any alignment information.

in addition, the generation of blocks  from pairwise alignments may pose a problem. there are only few exceptions of genome aligners that avoid the problem by directly computing local multiple alignments  <cit> . if we assume transitivity of the alignment relation, it is straightforward to go from local pairwise alignments to alignment components or to multiple ungapped alignments. in the case of gapped alignments however, pairwise alignments can have conflicting gap patterns. this complicates the task of combining them to a single block. heuristic methods such as progressive alignment  <cit>  or transitive alignment  <cit>  carry out this task, but are time consuming. having said that, a colinear realignment for each block carried out after finishing segmentation has proven to significantly improve alignment accuracy  <cit> . this suggests the alternative to ignore gaps in blocks while improving the genome alignment on the level of blocks.

further, we have not covered all aspects of the framework in this paper and left out details on the detection of substructures. for example, aba and drimm-synteny detect small cycles by efficiently computing a maximum spanning tree before heuristically inspecting the remaining edges that create cycles. different detection methods clearly have an influence on the time complexity of an approach and, depending on their sensitivity, also on the accuracy of a genome aligner. thus, a thorough analysis of detection methods is certainly interesting but beyond the scope of this work.

similarly, we have not addressed algorithms for eliminating substructures. these algorithms determine the order in which modifications are applied. the elimination of one type of substructures can create other substructures, which again can create the first type of substructures upon elimination. for this reason, iterative elimination strategies are prevalent in graph-based genome aligners. end criteria for iteration are typically given as parameters of the method, e. g., a maximal length of cycles or an explicit number of iterations.

the parameters usually require customized values for every new input set of genomes. usually, this inhibits broad usage of tools if automatic parameter selection is not offered. a genome aligner has to find a trade-off between size and length of blocks. very similar genomes will have long blocks conserved across many genomes, whereas more diverged genomes show fewer long blocks and conservation across fewer genomes. hence, a factor to consider for parameter selection is genome divergence in addition to genome lengths. given the initial set of local alignments, automatic parameter selection seems possible. it will be necessary to carefully study the influence of all factors to be able to automate the selection, but consequently it will enable a larger community to benefit from graph-based genome aligners.

finally, graph-based genome aligners, just as other genome aligners, have to decide between positional homology alignment  <cit>  or alignment of all repeats. more precisely, they have to decide, for segments with multiple copies in several genomes, whether to align them in one or in multiple blocks. not only do repeats lead to a quadratic explosion in the number of pairwise alignments, but they also hide larger regions of colinearity. for this reason, several genome aligners aim at aligning less and predict positional homology  <cit> . graph-based genome aligners compute positional homology to a certain degree. they do not forbid duplications, but separate blocks into positional homologs when splitting blocks.

in conclusion, our framework demonstrates shared aspects of graph-based genome aligners. it contributes to developing a common view on graph-based genome alignment, an active field of research with currently at least two graph-based tools for genome alignment being actively developed  <cit> . in the future, we might identify the steps that have the greatest influence on alignment accuracy. already now, we believe that the framework provides assistance for the development of new and improved genome aligners.

competing interests
the authors declare that they have no competing interests.

authors’ contributions
bk and kt participated in the design of the study and drafted the manuscript. mh participated in the design of the study and helped editing the manuscript. kr conceived of the study and participated in its design. all authors read and approved the final manuscript.

