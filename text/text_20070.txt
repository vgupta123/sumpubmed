BACKGROUND
the functional annotation of newly sequenced genes is a classic problem in computational biology. even though dozens of annotation protocols exist, many of them are general purpose, not tailored to a special application. one such application is the reconstruction of metabolic or regulatory networks in systems biology. to accurately reconstruct the metabolic network of a given organism, it is necessary to precisely determine its enzyme repertoire. the enzymes in the genome have to be found and their function  has to be determined.

sequence database searching is a standard method for functional annotation that is also used in the reconstruction of metabolic networks. a database of known sequence targets is searched with the genes of the organism in question. if there is sufficient similarity between a query and a target, the function of the target gene can be inferred to the query. our group uses such an approach  to identify the enzymes of a given organism. the results of a blast-dependent  <cit>  search are combined with other results to predict the presence of an enzyme. in many cases, sequence-similarity based methods, however, do not allow an unambiguous decision. one of the reasons is given by the fact that many enzymes have similar sequences, even though their biochemical function differs  <cit> . another source of errors are multidomain proteins. a protein domain is usually defined as a structural and functional unit of structure, folding independently of the rest of the protein chain . many proteins are composed of several domains, and some domains are frequently used in different combinations  <cit> . this often complicates functional annotation.

a classical approach in functional annotation consists of the determination of sequence similarity, followed by sequence clustering into protein families, and the representation of these families by family-specific sequence profiles or patterns . some of these methods include an intermediate step that copes with multidomain proteins. we shortly introduce a number of these methods with emphasis on those using patterns or not being covered by  <cit> .

sequence database searching is often the first step in the annotation protocol, used to determine the similarity or homology of the input sequences. once the homologous sequences are merged into clusters or families, their common properties are captured in some kind of profile. the construction of sequence patterns is one way to do that. sequence patterns can be deterministic or probabilistic  <cit> . deterministic patterns work like a filter or a fingerprint, specifying a set of possible subsequences that will match the pattern or not. they allow a clear "yes" or "no" decision on the question if a given sequence matches the profile, which can be advantageous in some research contexts. despite their lack of flexibility, deterministic sequence patterns have been used in many projects  <cit> .

some approaches for pattern or motif recognition do not include an alignment strategy, pratt  <cit>  and castor  <cit>  are two examples. they require sets of unaligned sequences as input, which usually need to be related to construct biologically meaningful patterns. pratt allows to construct patterns with user-defined properties, e.g. the patterns may contain gaps of variable length or allow ambiguous positions. castor is a clustering protocol using sequence patterns to recursively divide the input sequences. statistically relevant patterns are further refined in each step. castor is an example of an automatic and unsupervised method that does not require manual intervention, as long as the input sequences are known to be related. prosite  <cit>  was initially a repository of manually curated patterns. today, the prosite team also uses automatic and semi-automatic techniques, and many patterns are based on hmm profiles  <cit> .

the methods we have introduced so far are general, not being specialized in a certain class of protein. in contrast, priam  <cit>  represents an approach restricted to enzymes. priam first collects all enzyme entries from the enzyme database  <cit>  and retrieves the sequences for each given enzyme from swissprot. then it identifies the conserved 'modules' in each group of sequences with psi-blast  <cit> . these modules are converted into position-specific scoring matrices , which can be used for functional annotation. we are currently not aware of another method that is specialized on the functional annotation of enzymes.

we present an unsupervised and automatic method for the functional annotation of enzymes, to support the reconstruction of metabolic networks. its name is breps, short for "braunschweig enzyme pattern search". given a small number of parameters, it automatically creates sequence patterns from groups of enzyme sequences. different from priam, breps aims at defining minimal sequence patterns for one or more ec numbers.

in the first step the enzyme sequences in the swiss-prot part of the uniprotkb are identified and sorted into three categories. the enzyme sequences are then compared by an all-vs.-all blast. the resulting e-values of the computed blast alignments are used as distance measure in a complete linkage clustering of the enzymes. the sequences in the clusters of the created trees are aligned with clustalw  <cit> . the conserved positions in the multiple alignment are converted into a sequence pattern corresponding to enzyme function. finally, we estimate the fitness of these patterns by searching the breps database for true- and false positive hits. see figure  <dig> for an overview.

RESULTS
preprocessing
we retrieve the swiss-prot part of the uniprotkb and parse their description  lines. depending on the presence of ec numbers, certain keywords and sequence length we sort the swiss-prot entries into three groups: entries with an ec number are considered as enzymes, if their length is between  <dig> and  <dig> amino acids. no complete enzyme in brenda  <cit>  is shorter than  <dig> positions and only  <dig> % of the swiss-prot sequences in the uniprotkb are longer than  <dig> positions. the enzymes make up the first group .

fragments, regulatory domains without enzymatic activity, or activation peptides are identified by keywords like "putative", "hypothetical" or "fragment". these entries are put into the second, putative group. we assume the function of these proteins to be unknown, they need not even be real expressed proteins. all remaining proteins, which have neither an ec number nor one of the aforementioned keywords, are moved into the third group, proteins without enzymatic activity :

 <dig>  enzymes.

 <dig>  putative proteins/fragments with unknown function.

 <dig>  proteins without enzymatic activity

our protocol proceeds with the enzymes in group one. the proteins in group two and three are only used in the verification of the final patterns . to reduce the computational overhead of the protocol, redundant entries in the source database are excluded from subsequent steps. in group two and three, we define two entries to be redundant if their sequence is identical. this is different in group one, where every entry is associated with one or more ec numbers.

let ec be a function that returns the set of ec numbers associated with an object x. for example, assume this object to be an enzyme q, with ec = {' <dig> . <dig> ', ' <dig> . <dig> -'}. given two enzymes q, r: we call r redundant to q if and only if

a) the sequences of q and r are identical and

b.1) ec = ec, i.e. they are annotated with the same set of ec numbers or

b.2) ec is a subset of ec.

in the following step the enzymes in our database are checked for changes of their ec numbers. for example, a given ec number may have been deleted by the iubmb or replaced by a new one. transferred ec numbers are updated and entries with deleted ec numbers are removed from the database.

then, all enzyme sequences are submitted to a blast all-vs-all comparison. low complexity sequences are removed in this step, by applying the seg filter  <cit> . the start and end indices of the remaining pairwise blast alignments are stored in our database. we also store the associated blast e-value. alignments covering less than  <dig> positions and those with an e-value higher than 1·10- <dig> are discarded .

clustering of the enzyme sequences
after the preprocessing, the enzymes are clustered by complete linkage  clustering . cl clustering is a method for agglomerative clustering. given a set of pairwise distances between the clustered objects, the pair of objects with the smallest distance will be merged into a new cluster in each iteration of the algorithm. then the distances of all nodes to the newly formed cluster have to be recomputed. in cl clustering, the recomputed distance between the newly formed cluster and another object will always be the maximum of all available distances to that object.

agglomerative clustering usually results in a single tree. each enzyme in our database can be thought of being a leaf at the bottom of that tree. the distance measure between the leafs are the blast e-values from the all-against all comparison described above. since we discard similarities higher blast e-values than 1·10- <dig>  the clustering can only proceed until this e-value has been reached. one can think of the complete linkage tree being cut horizontally at an e-value of 1·10- <dig>  our clustering procedure therefore results in many trees that are written into an sql database. every tree node is associated with the blast e-value of the last merge event with another leaf or node .

the blast score s can be asymmetric with respect to the order of query i and target j: s ≠ s. therefore sometimes two different distances are calculated between a pair of enzymes. in this case, we keep the higher e-value  as clustering distance, which corresponds to a symmetrification of the similarity matrix. this also ensures that enzymes with the same domain composition will cluster with a higher priority than single domain enzymes with multidomain enzymes that contain this domain. in spirit, this is somewhat similar to choosing the strongly connected components in the directed graph used in  <cit>  as clusters.

a few enzymes are not very similar enough to any other enzyme in our data set. they generate only a few or no blast hits at all, and are therefore not assigned to any tree. we refer to them as unclustered sequences. each unclustered sequence is put in an artificial tree that has one node.

pattern computation
the trees in the database represent groups of similar enzyme sequences. tree nodes with small e-values are likely to contain a family of evolutionary related enzymes. we conserve a part of the evolutionary information in the family by creating a sequence pattern. if the pattern matches a query sequence, the biochemical function of the query can be inferred from the family.

it is not necessary to compute a pattern for every node in the tree because the set of associated ec numbers does not always change when sequences are added or nodes are merged. if every node had a pattern, this would result in high runtimes when searching a query sequence with unknown function. any tree should however have at least one pattern, even if the tree contains only a few enzymes. otherwise we could not be sure to detect input sequences that are already present in the breps database. we therefore compute a pattern for any qualified node n if:

- n is the root or

- n has fewer ec numbers than its father node

the trees are processed top-down starting with the root node. all sequences within a qualified node are subjected to a multiple alignment procedure using clustalw. highly conserved positions  in the multiple alignment are transferred into a sequence pattern in prosite  <cit>  format . there are however exceptions:

 <dig>  because of the computational overhead, we do not treat nodes with  <dig> or more sequences. these nodes usually contain sequences with low similarity and several ec numbers and result in short and therefore unspecific patterns.

 <dig>  if a pattern covers less than eight positions of a given input sequence, we discard the pattern because of its small significance.

sometimes there is not a single conserved position in the alignment, even if we have aligned several hundreds of non-redundant enzyme sequences. it is therefore possible that a tree root is not represented by a pattern. it is even possible that a tree has no pattern at all, especially if there is only one ec number in the tree. we identify problematic trees by counting the percentage of enzymes that are represented by at least one pattern in the tree, %pce . if %pce is below a predefined constant, we iteratively add  patterns to the tree: first, we identify all candidate nodes that have no pattern. nodes that were already tried in earlier iterations but failed to achieve a valid pattern are excluded. the remaining nodes are sorted by descending e-value, such that the worst e-value are at the top. then, a pattern is computed for all nodes with identical e-values. if at least one pattern could be kept, we check if %pce is still below our threshold. in that case, we continue with the next node, until either %pce is above the threshold, or there are no more nodes to try. after one tree is finished, we continue this procedure until all trees are processed.

the unclustered sequences we described in the "clustering the enzymes" section are also represented by "patterns". their sequence serves as pattern, such that an exact match of a query sequence is possible. the information of these enzymes is therefore not completely lost.

pattern verification
sensitivity and specificity of the patterns are important parameters to judge their quality. unspecific pattern should not be used for functional annotation, except if there is no other source of information. we therefore search the proteins in our database with each of the computed patterns, including the proteins without enzymatic activity and the group of putative proteins. redundant entries are excluded from the verification.

if a pattern matches an entry without enzymatic activity, we score a false positive hit . if one of the entries in the "putative" group is matched, the hit gets a neutral status, because we cannot safely assign a result . if our pattern is matching an enzyme, we have to compare its ec numbers with those of the matched sequence . the result depends on the definition of these relationships. this is not trivial, because every pattern and every enzyme can be associated with more than one ec number. in addition, some of the ec numbers are incomplete, e.g. " <dig> .-.-".

in our definition, an ec number connected to a pattern means that this pattern will find all enzymes with the same level of functional resolution. for example, a pattern p with ec = {' <dig> . <dig> -'} should identify all oxidoreductases that act on compounds carrying a ch-oh group, with a cytochrome as acceptor  <cit> . in this case the 4th part of the ec-number is not specified in more detail. if p matched an enzyme q with ec = { <dig> . <dig> }, we would score a true positive hit . this is not the same if the two ec sets are swapped, i.e. the pattern-associated set ec = { <dig> . <dig> } and the sequence-associated set ec = {' <dig> . <dig> -'}. in that case, the pattern is associated with cytochrome-acting mannitol dehydrogenases. since we do not know if q has that function , a decision is impossible . our pattern verification method is therefore asymmetric with respect to patterns and sequences.

if there is more than one ec number present in either the pattern or the enzyme sequence, we rank the relationships by the following rule: a tp gets precedence over a fp, and a fp gets precedence over a na case. that means that we do not even need to evaluate a match between p and q any further as soon as we have found a tp. on the other hand, we can only assign na if there is neither a tp nor a fp case present. our scoring rules are best shown by the examples in table  <dig> 

the results of the pattern verification are especially important, because the number of true positive  and false positive hits  are the main parameters to judge the quality of a pattern. figure  <dig> shows the sum of tps and fps at pattern lengths up to  <dig>  as expected, the number of fps is decreasing with increasing pattern length. after the patterns have reached a length of  <dig> positions, the number of tps is always above the number of fps recognized by the pattern, which results in the high specificity of the patterns: about 99% of them have a specificity of more than 95%, only  <dig> % of them have a specificity of less than 50%.

two proteins with the same ec number can belong to different sequence families that need not to be closely related. since our approach generates one or more patterns for each sequence family, determining the number of false negatives is not suitable as a quality measure in this setup. we have therefore not determined the number of false negatives .

statistics of the breps database
we ran our protocol on the swiss-prot release  <dig>   of the uniprot knowledge base  <cit> . after parsing the data, we count  <dig>  non-redundant enzymes and  <dig>  non-redundant proteins without enzymatic activity. the group with the putative proteins and the fragments contains  <dig>  non-r entries.

the enzyme sequences are clustered into  <dig>  trees, including  <dig> single-node trees from unclustered sequences. altogether, the trees have about  <dig>  nodes, of which almost  <dig>  are associated with a pattern. from the  <dig> different ec-numbers in swiss-prot release  <dig> ,  <dig>  are represented by at least one pattern. out of the remaining  <dig> ec numbers,  <dig> are missing because they are only present in "putative" sequences, the other four ec numbers could not be represented in valid patterns. the smallest patterns cover nine positions, while the largest one spans as much as  <dig> positions. the average pattern length is  <dig> positions.

we have quantified the number of enzymes for each enzyme class, subclass, and sub-subclass; and the number of trees they are clustered. the ratio sequences/trees reflects the average number of enzymes per tree and indicates the "variability" within an ec class. a high number of sequences in a few trees mean obviously low variability, while the opposite is true if the number of sequences and trees is almost equal. table  <dig> shows the ten enzyme sub-subclasses with the highest and the lowest variability in this swiss-prot version, respectively. we have investigated the sequence lengths in the enzyme class with the highest variability, ec " <dig> . <dig> ". there are  <dig> such sequences in our database, the shortest one being  <dig> positions and the longest one being  <dig> positions long. the average length is  <dig>  positions, with a high standard deviation of  <dig>  positions. this shows the high variability.

implementation and runtime, memory requirements
breps was implemented in python, with mysql as the database management system. the computation of the blast  and clustalw  alignments, as well as the verification step were parallelized to some degree. with a current swiss-prot version as input data, the complete breps database needs about  <dig> gb of storage and takes less than one week to compute . the peak amount of main memory is needed in the clustering step, between four and eight gb.

discussion
the aim of the project was to develop a method to extract function-specific sequence-patterns from enzyme sequences that can be updated frequently in a fully automatic manner. the method combines the use of swissprot-annotated sequences, the calculation of sequence-relatedness by blast, the construction of clusters by complete-linkage clustering and multiple alignment by clustalw.

we are aware that some of the components we used could be modified. however, the use of an alternative to blast would not have changed the result significantly, as we are not looking for remote relationships. blast is more than suitable for the levels of similarity we are dealing with. the use of the clustering approach, though, has a strong impact on the result. we have chosen complete-linkage clustering, because it is very strict and provides clean clusters. this is a required property in our setup, because we do not use a dedicated domain detection protocol in breps. the use of single-linkage clustering, or to less extent, upgma or average-linkage clustering, would lead to clusters that could contain two unrelated sequences a and b if they are connected by a multidomain sequence a-b. the strictness of the complete linkage clustering leads to clusters that remain quite „clean" in terms of domain composition as long as clusters are defined by low e-values. its only drawback may be that - because of its strictness - cl may compute more clusters than necessary and some sequences can remain unclustered. the former just leads to a few more patterns, and we take care of the latter by treating these sequences as described in the results section. the strictly defined clusters should be a good environment for an established and widely used progressive multiple alignment method like clustalw. of course, there may be suboptimal cases where a computed pattern is shorter than it could be. in theory, it is even possible that a multiple alignment contains a conserved position that is not biologically true, i.e. the aligned characters are not homologous. this would lead to a pattern that is not working as desired, maybe even missing its input sequences. we do however take care of these risks by filtering out short patterns, and by the verification step. we also check that all patterns recognize their input sequences. since most of our patterns are specific, clustalw is a good choice - and much faster than simultaneous approaches. as for the source database we are using, the swissprot part of the uniprotkb  <cit>  is the only high-quality annotated large-scale sequence database worldwide, so there was no choice here.

to evaluate the quality of breps, a comparison of pattern-predicted enzyme functions with proven functions is essential. in the following sections, we describe and discuss our experiments, which involve a comparison with another automatic method for the functional annotation of enzymes.

the standards of truth
evaluation procedures require a standard of truth  to rate the prediction quality of the methods under evaluation. in metabolomics, a perfect standard of truth is an experimentally validated set of ec numbers representing the biochemical "toolbox" of a given organism. even for escherichia coli, such a sot does not exist.

the priam  <cit>  authors used the swiss-prot annotation as sot to evaluate their approach. because we already used this annotation in creating the breps patterns, we chose another, independent source of data to serve as sot, one that did not involve sequence comparison in its making. the annotations in brenda  <cit>  are manually extracted from experimental, published work; the amenda predictions are extracted from pubmed abstracts by text mining procedures  <cit> . we believe the brenda annotation to be correct in terms of specificity, i.e. every ec number that is predicted to occur in a given microorganism is really present. unfortunately, there are rather few experimental proven enzyme functions known for many microorganisms, often only about 200- <dig> ec numbers are available. amenda usually contains about twice as many ec numbers for a given organism , but some of the additional predictions may be wrong. for these reasons, brenda serves as our "strict" standard of truth, while amenda serves as our "loose" sot. both sots are however incomplete, we are therefore unable to assert the number of false positives with confidence and prefer to call this experiment a "comparison of breps and priam" instead of an "evaluation".

breps a and b
similar to the concept of a strict and a loose sot described above, we define two sets of breps patterns as well. the smaller breps set with higher quality is called "breps a" and is a subset of the more loosely defined "breps b". the sets are constrained by different specificity thresholds and by the ec content of each pattern:

breps a: this set contains patterns with a specificity of  <dig>  , i.e. patterns that produced no false positive hits in their verification. if a member of breps a has more than one ec number, all ec numbers must be in the same sub-subclass . single, unresolved ec numbers  are not allowed.

breps b: in addition to the breps a patterns, this set contains also patterns that carry ec numbers from multiple sub-subclasses. these patterns may be less specific, requiring only a specificity of  <dig>  or more.

breps a contains  <dig> patterns, breps b contains  <dig> patterns. only  <dig> of the additional  <dig> patterns in breps b have a lower specificity than  <dig> , the other ones have more than one ec sub-subclass.

comparison to other sequence-based enzyme function predictions
a comprehensive evaluation of several methods is somewhat out of scope in this work. we compare breps to priam. breps and priam are automatic and unsupervised methods specialized on enzymes. the prosite patterns, on the other hand, were not generated in an automatic and unsupervised way. pratt and castor are unsupervised methods for pattern extraction, they do however rely on sets of related sequences. these methods lack the similarity search/clustering part of breps and priam and are therefore unable to process the enzymes in the uniprot automatically.

we computed the strict and loose sots of five important microorganisms: corynebacterium glutamicum, escherichia coli, pseudomonas aeruginosa pao <dig>  sulfolobus solfataricus, and thermus thermophilus, see table  <dig>  for each organism, we compare all its protein sequences to the breps patterns and the priam profiles. the priam profiles we use are from the "gene-oriented release" of priam . they are better suited to annotate individual genes, instead of complete genomes. the search is made with rpsblast  <cit> , the results are filtered by e-value thresholds provided in the priam file "profile_infos.txt". this file contains several columns of data per priam-profile. we used the e-values in the 4th column in our comparison, because they provide the "best compromise between sensitivity and specificity"  <cit> .

if either a breps pattern or priam profile matches a gene of the five micro-organisms, we compare the ec number of the profile/pattern to the ec numbers in the sot. if one of the ec numbers in the sot is matched by one of the methods, we count a true positive hit . every ec number can only be identified once, additional hits to the same ec number are ignored. we also define a second case: if an ec number from breps or priam differs from an ec number in the sot only at the fourth position, we count it as "sub-subfamily hit". each sub-subfamily is only be counted once. aside from an interesting insight, this also allows us to deal with unresolved ec numbers in breps patterns, e.g. " <dig> . <dig> -", where a decision would be difficult otherwise. the results of the comparison are shown in table  <dig>  they show that our approach is essentially on par with priam. even though most of the breps a sensitivity values are considerably lower and many of the breps b values are slightly lower than the priam results, there are interesting exceptions: the e. coli values of breps are mostly higher than those of priam, and the breps b results for s. solfataricus are also higher in conjunction with the loose sot. the picture gets more interesting when sub-subclass hits are also allowed : the strictly defined breps a patterns gain less additional hits in contrast to priam, the difference in sensitivity between breps a and priam is even more pronounced in this setting. this does however not hold for breps b, its performance is similar to priam, sometimes reaching even higher sensitivities. that can be explained with the properties of the breps b patterns. since they can be associated with multiple ec sub-subclasses, more sub-subclass hits are likely.

another interesting question is why breps and priam sometimes fail to predict the presence of an enzyme. we did a manual investigation to answer this question: from the five test microorganisms, we randomly picked five ec numbers that priam found, but not breps, and investigated the reason. in analogy, we also investigated five ec numbers where breps scored a true positive hit, but not priam.

our manual investigation of five cases that breps revealed some of the reasons why priam is slightly more sensitive than breps. the main reason is that priam may access more sequence data than breps, because we do not allow "probable" or "putative" enzymes in creating the breps patterns. even though the annotation of most "putative" swiss-prot sequences will probably be correct, we do prefer to use only sequences with maximal credibility. this results in highly specific patterns that produce high-quality annotations - if the patterns do indeed match the query. the high specificity of our patterns reached at the expense of flexibility is the principal trade-off of our approach: on one hand, a single point mutation on a gene, at a position covered by "the right" pattern, is enough to make it impossible to find it. on the other hand, a few changes may also effect the loss of its catalytic activity  <cit> , so specificity is a must in the reconstruction of metabolic networks. we are able to compensate the lack of flexibility to some degree, by computing an average of two patterns per tree. a comprehensive compilation of the breps misses is also attached as additional file  <dig> 

the five cases where priam missed an enzyme also lead to an interesting insight, even though we were not able to analyze the priam profiles  in detail, because of the file format. in all five cases the reason was the same: the suggested e-value thresholds were too strict. for example, ec number  <dig> . <dig>  was missing in t. thermophilus. ec number  <dig> . <dig>  is represented by one priam profile, "pri000625". the suggested e-value threshold of this profile is 7·10- <dig>  which rpsblast missed by less than two orders of magnitude; scoring an e-value of 2·10- <dig>  the difference between the suggested threshold and the rpsblast score was less severe in the other four cases we investigated. for instance, priam missed ec number  <dig> . <dig>  in c. glutamicum. the required threshold of profile pri <dig> was 1·10- <dig>  while rpsblast scored only 5·10- <dig> 

finally, we investigated whether both methods find the same or different ec numbers. we have therefore analyzed the unique and common contributions of true positive ec numbers that both methods provided, see table  <dig>  in summary, priam has a slight advantage in sensitivity. however, the results in table  <dig> show that roughly 10% of the ec numbers that breps found were uniquely found by breps. it therefore makes sense to use breps in addition to other annotation approaches, as our group does.

CONCLUSIONS
we have designed and implemented an automatic protocol "breps" to aid in searching a given genome for enzymes, or verifying the presence of predicted enzymes. breps basically computes sequence patterns of enzymes from swiss-prot that have been clustered at different levels of sequence similarity. in a final, iterative verification step, we ensure that the patterns are specific and cover at least a certain percentage of swiss-prot enzymes.

the verification results in figure  <dig> showed that the quality of the breps patterns is always high if they span at least about  <dig> sequence positions. the occasional fp outliers  could also indicate mis-annotated enzymes instead of being real fps.

a comparison with priam, another method for the functional annotation of enzymes, showed that breps is on average less sensitive than priam. one of the main reasons is that we discard the "putative" input sequences that priam is using. nevertheless, the annotation of the e. coli genome showed an example where breps was able to outperform priam. depending on the organism and the pattern set we used, between 5% and 25% of the joint set of ec numbers found by both methods were unique to breps. we therefore conclude that breps may be beneficial in combination with other approaches for functional annotation. its main advantages are that the protocol runs automatic and unsupervised. high pattern specificity as usual is connected to a smaller sensitivity; in addition, our method relies to some degree on alignment quality, which cannot always be guaranteed.

even though we use the really conservative complete linkage clustering, a future improvement of breps could be to implement a domain detection protocol.

availability and requirements
breps will finally be integrated into other projects of our group and the patterns will be integrated into the brenda website. we have set up a preliminary website  at http://breps.tu-bs.de. it allows the user to submit either an ec number or a protein sequence. if the input is an ec number, broli will retrieve all patterns associated with that ec number. if the input is a protein sequence, broli will search this sequence with all breps patterns and display the matching patterns in a condensed way. the complete information available for interesting patterns can be shown by toggling the corresponding check boxes and clicking "submit" again. the user can also choose to display all patterns of a given tree by clicking on one of the links in the "tree" column.

the source code is available on request  for non-commercial, academic use only. in addition the calculated enzyme-specific patterns will be implemented in and made available in the next update of the brenda enzyme information system.

authors' contributions
cads devised the first part of breps in his phd thesis  <cit> , largely corresponding to the "preprocessing" paragraph in the results section. aw devised the second part of the method during his phd thesis  <cit> , corresponding to the "pattern construction" and "pattern verification" sections in the results section. cb integrated both projects into one protocol and improved some of the existing work. he also implemented the complete linkage clustering and parallelized a part of the code to run on our compute cluster. ds had the initial idea; he supervised and coordinated the work of the other authors. cb, aw, and ds contributed to this paper. all authors have read and approved the final manuscript.

supplementary material
additional file 1
manual analysis of five ec numbers that breps could not detect. the attached .pdf file shows a table that illustrates our manual analysis of five ec numbers from five microorganisms that were found by priam with confidence, but not by breps. it also contains some notes on our analysis process.

click here for file

 acknowledgements
we would like to thank thomas bernard from the priam team and kristian axelsen from the uniprot helpdesk for kindly answering our questions. cb thanks mark poolman for the fruitful discussion of his poster at the gcb  <dig> 
