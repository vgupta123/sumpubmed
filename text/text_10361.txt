BACKGROUND
in recent years, next generation sequencing technologies have been evolving rapidly with the potential to accelerate the research in sequencing biology . however, today’s next generation sequencing technologies such as illumina,  <dig> roche, ion torrent, smrt  from pacific biosciences, have various significant limitations  <cit>  especially amplification biases, short read lengths and genome assembly complexities. for example, illumina – one of the most commonly used technologies for sequencing in recent years, produces read length of 75– <dig> base pairs   <cit>  and hence is believed to suffer from short read lengths resulting in poor assembly of complex regions like long repeats and duplications  <cit> . however, the application of the smrt platform to small microbial as well as complex eukaryotic genomes have improved the quality of genome assembly but the commercial availability and price of sequencing are the major limitations of this approach . similar improvements were also accomplished by the illumina truseq synthetic long-read sequencing strategy  <cit> , but the long range polymerase chain reaction step included in the library preparation will be a limitation in time-constrained projects, thus making it inaccessible to the whole research community. to overcome such limitations efforts are now been made to develop an inexpensive single-molecule nanopore-based fourth generation dna sequencing technology . in fact, the concept of single molecule sequencing using biological nanopores was first proposed by deamer & akeson  <cit>  in the year  <dig>  since then intense efforts have been made to overcome the formidable technical challenges and finally in the year  <dig>  oxford nanopore technologies ltd released the first commercial nanopore sequencer  <cit>  to early access customers. the minion® device, which is no larger than a typical smartphone consists of pores embedded into a membrane which is placed over an electric grid, as the dna bases i.e. a, t, g & c pass through the pores they generate a particular intensity of ionic current, which are further base called using metricorr software  <cit> . the reads generated by this sequencer, can be classified into three types: 2d reads, template reads and complement reads  <cit> . in our study, we analyzed all three types of reads but mainly focussed on 2d reads since they are optimal reads that consist of consensus information of both the strands  <cit> . however, similar results were observed upon analyzing all three types of reads, illustrating the reproducibility of our results irrespective of the type of reads analyzed.

despite the high error content of the minion reads  <cit> , aston et al.  <cit>  have demonstrated the utility of these reads in microbial sequencing, which incited the need for the development of new tools either to correct the erroneous reads or for the downstream analysis. the error correcting algorithms have already emerged  <cit>  while, development of downstream pipelines is at nascent stage. a major computational step in any of the dna sequencing pipelines is assembly and can be defined as a hierarchical data structure that maps the sequence data for the reconstruction of the target genome. this process involves initially grouping the reads into contigs and then contigs into scaffolds thereby generating the assembly. currently, the most common algorithmic frameworks on which assembly algorithms are developed include the overlap layout consensus   <cit> , de bruijn graph   <cit>  which uses some form of k-mer graph method and greedy extension graphs which use either olc or dbg  <cit> . there are about  <dig> academically available de novo assemblers  <cit>  which have been developed by implementing one of these three assembler algorithms. most of the assembler algorithms, generally take a file of sequence reads and a quality-score file as input, but for nanopore data, the quality scores are not available so we failed to test assemblers which insist on the requirement of the quality score file as a compulsory input. an example of one such assembler is pcap, which although is specifically developed for long read data does not accept reads without quality score information  <cit> . on the other hand, most of the assemblers such as newbler failed to assemble nanopore reads due to the length of the reads. due to these constraints we finally employed in our study one or two assemblers for each type of assembly algorithm and analyzed the quality, accuracy and efficiency of each assembler on whole genome nanopore sequencing data for e. coli and yeast. our study unveiled olc as the optimal algorithm, in multiple contexts benchmarked in this study, providing a direction for further development of assembly tools for nanopore data.

methods
data retrieval
through an early access program of nanopore sequencer , quick et al.  <cit>  sequenced the genome of the model organism, escherichia coli k <dig> substr. initially, we have used this dataset to benchmark various assembler algorithms but due to high error rate all the existing assemblers failed to assemble such long erroneous reads    <cit> . later, in january  <dig>  schatz and co-workers, developed a novel hybrid algorithm called ncorr to correct these erroneous reads. by implementing this ncorr algorithm  <cit>  they have error corrected the reads of the e. coli dataset sequenced by quick et al.  <cit>  and the reads of the yeast dataset sequenced by goodwin et al.  <cit> . these error corrected datasets have been retrieved from the schatzlab website  <cit>  in fasta format for all subsequent analysis.

composition of the nanopore sequencing datasets used in this study
the e. coli dataset consisted of  <dig>  2d reads  as well as  <dig>  template and  <dig>  complement reads  while, the yeast dataset consisted of  <dig>  2d reads,  <dig>  and  <dig>  template and complement reads respectively.

assembler algorithms employed in this study
velvet
velvet  is a secure and reliable de bruijn graph-based assembler. it extensively uses graph simplification strategy to scale down non-intersecting paths into single nodes. this simplification compresses the graph without much loss of information. to reduce the time-complexity of the algorithm, velvet implements bubble search  and read threading   <cit> .

abyss
abyss  is a de bruijn graph based assembler mainly developed to address the memory issues while assembling mammalian–size genome. abyss implements a partition approach at the level of individual graph nodes . to overcome the memory requirements, the assignment of graph node to cpu is attained by converting k-mer to an integer using strand-neutral formula i.e. k-mer and its reverse complement map to same integer. abyss also implements graph simplification like velvet and then performs bubble smoothening by bounded search where priority is given to the path supported by more reads  <cit> .

celera
celera is an overlap layout consensus -based assembler, which was developed at the time of sanger sequencing by celera genomics. in recent years, the algorithm has been modified to handle long pac bio reads whose nature is similar to nanopore reads. the revised pipeline is named as cabog . cabog constructs an overlay graph from the reads and reports the best overlaps, which are then used to build unitigs. these unitigs are joined to build contigs and finally these contigs are connected to form scaffolds  <cit> .

ssake
ssake is a greedy graph-based assembler. it does not use the graph explicitly. instead, it iteratively searches for reads with overlap to build the contigs. initially, it will look for reads with end –to –end confirmation by favoring error-free reads and then performs the extension  <cit> .

binning of reads
in order to test the performance of various metrics in relation to the size of the datasets, we have divided the total reads in a dataset into four bins i.e. 25 %, 50 %, 75 % and 100 % of the reads. to avoid the prejudice in selecting the reads, the binning of the data was performed by randomly generating the bins of the reads ten times using python script, and finally the average result of all the ten trials after processing the each trial is reported in the figures.

implementation of the benchmarking pipeline
according to our survey there are at least  <dig> de novo assemblers which can be accessed with a free academic license  <cit> , that have been developed by implementing one among the following three algorithms namely de bruijn graphs, overlap layout consensus  and greedy extension. out of these only few assemblers i.e. velvet  <cit>  , abyss   <cit> , celera   <cit>  and ssake   <cit>  could be successfully run for assembling the nanopore reads. all the other assemblers failed to assemble most likely due to the length of the reads and/or due to their expectation for quality scores or other input parameters not available for nanopore reads. it is important to note that most of the assemblers were developed in view of short read sequencing data whose read lengths range from 500-3000 bp  <cit>  whereas the read length of nanopore reads range from 5000– <dig>  bp. all the assemblers in this study were run on unix command line with default parameters , and the obtained results were analyzed for reliability, quality and accuracy of assemblies.

to evaluate and compare the efficiency of various assembly algorithms the following metrics were employed  <cit> :

calculation of assembly metrics
the contig files which were generated as a result of successful assembly by each assembler were used for statistical analysis of an assembly. the assembly metrics i.e. n <dig> value,which represents 50 % content of the assembly and all the contig metrics including the mean, total length of all generated contigs as well as the number of contigs obtained, were calculated using a perl script.

calculation of performance metrics
running times and memory consumed by each assembler was captured during the assembly process using unix utilities. while limiting the memory usage of each assembler was accomplished using the ulimit program.

calculation of accuracy metrics
to assess the accuracy and quality of the generated assemblies, genome coverage i.e. defined as the percentage of the genome covered when the generated contigs are mapped onto reference genome and the percentage of alignment i.e. the number of contigs mapped to the genome out of the total generated contigs, were computed using shell scripts while mapping to the reference genome was performed using a fast gapped aligner tool bowtie  <cit> .

RESULTS
pipeline implemented for the analysis
our analysis pipeline shown in fig.  <dig>  illustrates the step wise protocol followed for benchmarking the various assembler algorithms for nanopore sequencing data . initially, we have retrieved the non-error corrected and ncorr-error corrected  <cit>  datasets to perform preliminary analysis with all the available assemblers, which helped us to identify few assemblers that can potentially assemble nanopore sequenced reads. after this initial analysis to identify potential assemblers, we analyzed the efficiency of these assemblers as well as the accuracy and quality of the generated assemblies using various metrics on the error-corrected reads. our benchmarking analysis enabled us to unveil the ideal algorithmic frameworks for addressing the various needs in the assembly of nanopore sequencing data.fig.  <dig> illustrates the pipeline implemented in this study for benchmarking various assembler algorithms on nanopore sequenced datasets



comparison of the assembly metrics generated by various assemblers reveals celera as an optimal assembler
the main features that can best explain the quality of an assembly from sequencing reads include the n <dig> value, number of contigs, mean length of contigs and the total sum of the lengths of all the contigs identified in an assembly. hence, we have calculated all of these metrics for the nanopore sequencing reads for the e. coli and yeast genomes to understand the relative performance of the assemblers . in the following sections, we summarize these comparisons.

1) n <dig> value: upon analyzing the 2d reads from e.coli dataset  we observed consistent increase in the n <dig> values of the assemblies generated by various assemblers with an increase in the dataset size measured as the percentage of the total number of reads employed in the analysis. in particular, assembly generated by celera had the highest n <dig> value ranging from  <dig>  bp to  <dig>  bp  while, the assemblies generated by velvet, abyss and ssake consisted of an average n <dig> value of  <dig>  bp , which is eight times lower than n <dig> value of celera generated assembly for e. coli . the differences were found to be even more striking when the results were compared between the assemblers for the yeast genome . since, n <dig> value represents the 50 % content of the assembly, higher the n <dig> value better would be the quality of an assembly. hence, from the above observations based on n <dig> values, it can be concluded that celera assembler is likely to generate better assembly compared to the other assemblers studied here. it is possible to speculate that since olc-based algorithms like the celera assembler have traditionally been used for longer read technologies like sanger sequencing and probably due to recent modifications made to this specific implementation to make it compatible with even longer reads like pacbio reads of length 3000-15000 bp, they are likely to outperform in terms of assembly quality, most short-read assembler implementations for nanopore sequencing data. this is especially likely to be true if the number of allowed mis-matches for building the contigs can be increased - due to high error rates in the ends of the nanopore reads. while, ssake generated assembly is of poor quality with an n <dig> value of approximately  <dig> for the yeast genome, which is  <dig> times less than n <dig> value of celera generated assembly . a similar trend was observed when template  and complement reads  of the e. coli dataset were analyzed, confirming the reproducibility of the results. notably, when 2d reads of yeast dataset were analyzed, we observed that the n <dig> value of an assembly generated by celera for 50 % of the reads is much higher than for the whole dataset. even though the binning of the reads was performed by randomly generating the bins of reads ten times, it is possible to associate this variation due to selection bias or genome-specific variations as this trend was seen only for yeast and not e. coli. however, it is still evident that the n <dig> value of celera generated assembly is much higher than the n <dig> values of the assemblies generated by any other assembler . we found very similar trends for 1d reads namely template and complement reads, further confirming the reproducibility of the results .fig.  <dig> each pair of plots give an overview of the comparisons of the quality of the assemblies across assemblers for e. coli and yeast datasets. a&b: histograms with error bars plotted between % of 2d reads and n50_value of an assembly show the variation in n <dig> value of an assembly among different assembler algorithms and how it varies with respect to the data size. c&d: histograms with error bars plotted between % of 2d reads and number of contigs generated from an assembly, shows how the number of contigs generated vary with respect to the mean contig length for each respective assembler algorithm across various bins of respective datasets. e&f: histograms showing the percentage of 2d reads employed on x-axis versus the average length of the contigs obtained using each algorithm. g&h: histograms showing the sum of the lengths of all the contigs generated by an assembler as a function of the percentage of the total reads employed in the assembly. in each set of plots, left panel corresponds to e. coli dataset while the plots in the right panel correspond to the yeast dataset. in all the plots labeled numeric values on histograms indicate corresponding values of the metric in respective color representing each tool



2) number of contigs: we observed, that the number of contigs and mean contig length of an assembly are inversely proportional . ideally, a good assembler should generate less number of contigs with a high mean and n <dig> values. we found this generally held true for assemblies generated by celera compared to the other assemblers studied here. for instance, velvet followed by abyss were found to consistently show high number of contigs compared to other assemblers at different percentage of reads employed in the assembly. this was in contrast to the assemblies generated from celera and ssake, which were found to show low number of contigs indicating the possibility of low but more comprehensive assemblies from the latter two . these results suggest that velvet and abyss are likely to produce very fragmented assemblies. we found similar trends for all the three types of reads in both the datasets , additional files  <dig> and 2). since celera assembler initially constructs overlay graph among reads and reports the best overlaps, which are further used to build untigs, which are joined to generate contigs, it is possible that data from error-corrected long read sequencing technologies like nanopore are likely better assembled using olc-based methods as the read error-correction methods further improve. indeed, less number of contigs with longer lengths identified in our analysis by celera’s assembler further supports this trend.

3) mean length of the contigs: it is similar to n <dig> value but the weightage is not given to contigs with longer length while calculating the mean. we found that it followed similar trend in both the e. coli and yeast datasets i.e. celera assembler generating contigs with high mean values followed by velvet, abyss and ssake respectively ). the analysis of 1d reads revealed the same overall trend but the increasing trend of mean values were not found to be proportional with data size unlike that seen for 2d read data .

4) total sum of lengths of all contigs: while this metric does not play a specific role in assessing the quality of an assembly mainly when the genomes have several duplicated regions, nevertheless it can provide information which can be useful for downstream analysis and prioritization in the assembly framework. so we compared the total length of the contigs obtained, at varying percentages of sequence data employed, using various assemblers . not surprisingly, this analysis revealed that the assemblers which showed high number of contigs also exhibited a high total contig length suggesting that these assemblers are likely to produce too many fragmented and/or repetitive contigs thereby causing erroneous assemblies.

upon analyzing the assembly metrics of the generated assemblies we observe that, irrespective of the data size and its complexity across genomes, olc based celera assembler generates better quality assembly than other assemblers.

evaluation of the memory and run time requirements of various assemblers reveals celera to be the fastest when sufficient memory is provided
major parameters that can be measured to assess the performance of any computational tool or algorithm are memory  and time consumed by the tool to complete the assigned task. in this study, we observed that irrespective of size of the dataset, the ram and virtual memory required for each tool to perform the task is ~ <dig>  kb and ~ <dig>  kb respectively. while the time required by each tool to complete the task significantly varies with the size of the dataset and complexity of the genome. for 2d reads of the e. coli dataset, the wall time as well the cpu time consumed by velvet is the lowest with ~15–30 sec of wall time and 15–30 sec of cpu time followed by celera with ~90 sec each of wall time and cpu time, abyss with ~50–100 sec of wall time and ~60–100 sec of cpu time and ssake with ~1000–1500 sec of wall time and ~1500 sec of cpu time . values for run times are log transformed in the plots to facilitate easy comparison across tools and datasets. across the assemblers, the time taken to run by each tool increased with the increase in the data size. for yeast dataset, the trend was found to be same but the time consumed by each tool was approximately  <dig> times higher than the time consumed to assemble the e. coli genome, likely due to the differences in the complexity of the genomes and size of the datasets . in addition, we analyzed the performance of the assemblers, by restricting the memory allotment using ulimit utility on unix environment, to study how the run times vary across them when memory allotted is altered between different runs. we observed that the time taken by each tool remains same when more amount of memory is provided except for celera, for which we found that the run times significantly decreased when more memory is provided and this resulted in a trend with celera consuming the lowest time followed by velvet, abyss and ssake . the analysis of 1d reads further confirmed the reproducibility of these results .fig.  <dig> each pair of plots give an overview of the computational requirements of each assembler for assembling e. coli and yeast datasets. a&b: histogram with error bars plotted between % of 2d reads and log values of wall time which represents the actual time consumed by each assembler to execute the task with respect to gradual increase in data size. c&d: histograms with error bars plotted between % of 2d reads and log values of cpu time which represents amount of time the cpu is actually executing instructions for each assembler with variation in data size. e&f: histograms with error bars plotted between varying amount of allotted memory on x-axis and log values of the wall time, showing the influence of memory allocation on wall time consumption by various assembler algorithms. g&h: histograms with error bars plotted between varying amount of memory and log values of the cpu time, illustrating the influence of memory allocation on the cpu time consumed by various assembler algorithms. in each set of these plots, left panel corresponds to e. coli dataset while the plots in the right panel correspond to the yeast dataset



overall, our performance metric analysis revealed that the time taken by the de bruijn graph and olc-based algorithms to generate assembly is low, while the time consumed by greedy-extension algorithms to generate the assembly are likely to be relatively higher for nanopore data. this might be due to the extensive search made by the greedy-extension algorithms to find the end-to-end overlap of the reads while assembling. it is possible that indexing in greedy extension methods might reduce the run times to some extent. on other hand, de bruijin graph based assemblers take less time as they implement bubble search which narrow down the candidate bubbles and help in speeding up the assembly process. while, celera implements olc algorithm which looks for overlap among the reads to join them together. since, nanopore reads are longer but fewer, it is not only easy to find overlaps but are also likely to exhibit longer overlaps among the reads, which facilitates more accurate construction of the contigs. thus, it is possible that olc-based approaches like celera will take lesser run time to generate more accurate assemblies with nanopore data. however, in order to improve performance of these methods, it is important to note that error rates in nanopore reads need to be decreased while allowing increased mismatches in the assembly process.

evaluation of the quality of the generated assemblies reveals olc-based algorithms to be ideal for nanopore data
two specific metrics which can help in assessing the accuracy of an assembly are genome coverage and alignment percentage . surprisingly, the genome coverage of all the generated assemblies was very low, but comparatively the assembly generated by celera for the e. coli 2d read data exhibited better genome coverage  . for the yeast dataset, the percentage of genome coverage for the assemblies generated by abyss, celera and velvet were found to be 80 %, 70 % and 50 % respectively. in contrast, it was found to be only 2 % for the assembly generated by ssake . when the percentage of alignment was compared between the assemblers, the contigs generated by celera and abyss for the e. coli 2d read data showed 100 % alignment to the reference genome while the alignment percentage of the contigs generated by velvet and ssake was found to be 80 % and 0 % respectively . for yeast 2d read data the alignment percentage ranged between 60 %–90 %, with contigs generated by abyss having highest alignment percentage when aligned to the reference genome followed by celera, velvet and ssake . further evaluation of 1d reads for coverage and alignment showed a similar trend, confirming the reproducibility of these results .fig.  <dig> each pair of plots show the accuracy of the assembly generated by various assembler algorithms for e.coli  and yeast  datasets. a&b: line graphs plotted between % of 2d reads and the % of genome covered, showing the extent of genome assembled by each assembler algorithm. c&d: line graphs between the % of 2d reads and % of alignment showing the confidence level of the contigs being assembled by various assembler algorithms



CONCLUSIONS
in this study, we implemented a computational pipeline for the benchmarking of assembler algorithms which revealed several observations which can aid in the development and improvement of frameworks for assembling genomes using nanopore data. in particular, we found that olc-based assembler celera generates an assembly with ten times higher n <dig> value & mean value and five times lower number of contigs. our analysis also confirmed that olc-based approaches can result in high genome coverages with 12 % in e. coli and 70 % in yeast along with moderate alignment percentages of approximately 85 % when compared to other assemblies, indicating a relatively high quality of the assembly compared to other tools studied here. moreover, celera was found to exhibit lesser run times when increased memory was provided to perform the task. thus, overlap layout consensus  based algorithms would be ideal frameworks for building de novo assemblers for nanopore reads followed by de bruijn graph based algorithms since assemblies generated by abyss were found to show high accuracy, moderate quality and reasonable run times and memory requirements. our results also suggest that improvements in greedy-extension algorithms can be implemented by indexing in order to decrease the run times. although this step might reduce the run times for greedy extension methods, accuracy and quality of an assembly generated will be potential issues to be addressed for these methods.

there are several challenges that currently exist in dealing with the nanopore sequencing data. these include high error rate of the long reads and lack of automated computational pipelines for error correction, assembly/alignment as well as downstream analysis of the reads. developing efficient algorithms which can automate the process of error correction and assembly of the reads would pose some potential opportunities in this domain. for instance, an automated pipeline can be developed by implementing hgap  algorithm for error correction, which is already proven to be an optimal algorithm for the error correction in the context to pacbio reads. however, the implementation of hgap algorithm restricts the application of the tool to specific genomes i.e., only those for which short read data is already available in the public domain. hence, there is a need to develop methods which can correct the reads from single molecule sequencing methods without using short read or reference genome sequences and using such implementation in the assembly and alignment process for downstream analysis. indeed, we anticipate rapid development of automated computational pipelines to address various aspects of nanopore sequencing data analysis as new datasets spanning multiple species become available to the scientific community in the coming years. hence, some of the opportunities for computational biologists include:enhancing the error correcting algorithms which don’t require short read sequencing data or reference genomes.

development of olc based assembler algorithms which can consider error-rates in the assembly process, since our results confirm the performance of these methods to be significantly better than other algorithms.

developing automated pipelines for pre- processing of the long reads and downstream analysis.



abbreviations
bp, base pair; kbp - kilobasepair; e. coli, escherichia coli; map, minion® early access program; olc, overlap layout consensus; yeast, saccharomyces cerevisiae

additional files
additional file 1: each pair of plots give an overview of the comparisons of the quality of the assemblies across assemblers for nanopore sequenced template reads from e. coli and yeast datasets. a&b: histograms with error bars plotted between % of template reads and n50_value of an assembly show the variation in n <dig> value of an assembly among different assembler algorithms and how it varies with respect to the data size. c&d: histograms with error bars plotted between % of template reads and number of contigs generated from an assembly showing how the number of contigs generated vary for each respective assembler algorithm across various bins of respective datasets. e&f: histograms showing the percentage of template reads employed on x-axis versus the average length of the contigs represented as mean of the contigs, obtained using each algorithm. mean of the contigs is the average value of the total sum of lengths of all the contigs. g&h: histograms showing the sum of the lengths of all the contigs generated by an assembler as a function of the percentage of the total reads employed in the assembly. in each set of plots, left panel corresponds to e. coli dataset while the plots in the right panel correspond to the yeast dataset. in all the plots labeled numeric values on histograms indicate corresponding values of the metric in respective color representing each tool. 

additional file 2: each pair of plots give an overview of the comparisons of the quality of the assemblies across assemblers for nanopore sequenced complement reads from e. coli and yeast datasets. a&b: histograms with error bars plotted between % of complement reads and n50_value of an assembly show the variation in n <dig> value of an assembly among different assembler algorithms and how it varies with respect to the data size. c&d: histograms with error bars plotted between % of complement reads and number of contigs generated from an assembly showing how the number of contigs generated vary for each respective assembler algorithm across various bins of respective datasets. e&f: histograms showing the percentage of complement reads employed on x-axis versus the average length of the contigs represented as mean of the contigs, obtained using each algorithm. mean of the contigs is the average value of the total sum of lengths of all the contigs. g&h: histograms showing the sum of the lengths of all the contigs generated by an assembler as a function of the percentage of the total reads employed in the assembly. in each set of plots, left panel corresponds to e. coli dataset while the plots in the right panel correspond to the yeast dataset. in all the plots labeled numeric values on histograms indicate corresponding values of the metric in respective color representing each tool. 

additional file 3: overview of the running times for various assemblers. 

additional file 4: overview of the influence of memory allocation on the running times for various assemblers. 

additional file 5: each pair of plots give an overview of the computational requirements of each assembler for assembling nanopore sequenced template reads from e. coli and yeast datasets. a&b: histogram with error bars plotted between % of template reads and log values of wall time which represents the actual time consumed by each assembler to execute the task with respect to gradual increase in data size. c&d: histograms with error bars plotted between % of template reads and log values of cpu time which represents amount of time the cpu is actually executing instructions for each assembler with variation in data size. e&f: histograms with error bars plotted between varying amount of allotted memory on x-axis and log values of the wall time, showing the influence of memory allocation on wall time consumption by various assembler algorithms. g&h: histograms with error bars plotted between varying amount of memory and log values of the cpu time, illustrating the influence of memory allocation on the cpu time consumed by various assembler algorithms. in each set of these plots, left panel corresponds to e. coli dataset while the plots in the right panel correspond to the yeast dataset. 

additional file 6: each pair of plots give an overview of the computational requirements of each assembler for assembling nanopore sequenced complement reads from e. coli and yeast datasets. a&b: histogram with error bars plotted between % of complement reads and log values of wall time which represents the actual time consumed by each assembler to execute the task with respect to gradual increase in data size. c&d: histograms with error bars plotted between % of complement reads and log values of cpu time which represents amount of time the cpu is actually executing instructions for each assembler with variation in data size. e&f: histograms with error bars plotted between varying amount of allotted memory on x-axis and log values of the wall time, showing the influence of memory allocation on wall time consumption by various assembler algorithms. g&h: histograms with error bars plotted between varying amount of memory and log values of the cpu time, illustrating the influence of memory allocation on the cpu time consumed by various assembler algorithms. in each set of these plots, left panel corresponds to e. coli dataset while the plots in the right panel correspond to the yeast dataset. 

additional file 7: each pair of plots show the accuracy of the assembly generated by various assembler algorithms for nanopore sequenced template reads from e.coli  and yeast  datasets. a&b: line graphs plotted between % of template reads and the % of genome covered, showing the extent of genome assembled by each assembler algorithm. c&d: line graphs between the % of template reads and % of alignment showing the confidence level of the contigs being assembled by various assembler algorithms. 

additional file  <dig> each pair of plots show the accuracy of the assembly generated by various assembler algorithms for nanopore sequenced complement reads from e.coli  and yeast  datasets. a&b: line graphs plotted between % of complement reads and the % of genome covered, showing the extent of genome assembled by each assembler algorithm. c&d: line graphs between the % of complement reads and % of alignment showing the confidence level of the contigs being assembled by various assembler algorithms. 



