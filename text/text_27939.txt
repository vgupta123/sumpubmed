BACKGROUND
rna molecules are crucial in different levels of cellular function, ranging from translation and regulation of genes to coding for proteins  <cit> . understanding the structure of an rna molecule is important in inferring its function  <cit> . since experimental methods for determining rna structure, such as x-ray, crystallography and nmr, are time consuming, expensive and in some cases infeasible, computational methods for prediction of rna structure are valuable.

currently computational rna structure prediction methods mainly focus on predicting rna secondary structure—the set of base pairs that form when rna molecules fold. when multiple homologous  rna sequences are available, the secondary structure of the sequences can be predicted using multiple sequence alignment and comparative sequence analysis  <cit> . alternative approaches, which can be used to predict secondary structure of a single sequence, are based on thermodynamic parameters derived in part from experimental data  <cit> . while thermodynamics-based approaches can be less accurate than comparative-based algorithms, thermodynamics-based approaches are applicable in cases of novel rnas such as the many rnas of unknown function recently reported by the encode consortium  <cit> . thermodynamics-based approaches can also be easier to apply to prediction of the structure of interacting rna molecules, for example, in gene knockdown studies.

many computational thermodynamics-based methods find the structures with the minimum free energy  from the set of all possible structures, when each structure feature is assigned a free energy value and the energy of a structure is calculated as the sum of the features’ energies. there has been significant success in prediction of pseudoknot-free secondary structures   <cit> . while many small rna secondary structures are pseudoknot-free, many biologically important rna molecules, both in the cell  <cit> , and in viral rna  <cit>  are found to be pseudoknotted.

since finding the mfe pseudoknotted secondary structure is np-hard  <cit> , polynomial time mfe-based methods for prediction of pseudoknotted secondary structures predict a restricted class of pseudoknotted structures  <cit> . these methods trade off run-time complexity and the generality of the class of structures they can predict. for example, the most general algorithm of rivas and eddy  <cit> , whose running time is Θ on inputs of length n, is not practical for rna sequences of length more than  <dig> nucleotides. this has been the main reason for development of heuristic methods for prediction of pseudoknotted structures  <cit> . although heuristic methods may not find the mfe structure, they usually run faster than the mfe-based methods that handle the same class of structures. for example, hotknots v <dig>   <cit>  is a heuristic approach that uses carefully trained energy parameters, is guided by energy minimization and can handle kissing hairpin structures. however, hotknots is still slow on long sequences.

other methods for prediction of pseudoknotted structures, such as the ipknot method of sato et al.  <cit> , are motivated by the finding of mathews  <cit>  that base pairs with high base pairing probabilities in the thermodynamic ensemble are more likely to be in the known structure. in a comprehensive comparison performed by puton et al.  <cit>  on the performance of publicly available non-comparative rna secondary structure prediction methods that can handle pseudoknotted structures, ipknot ranks first for general length rna sequences.

incorporating known structural information can improve the accuracy of structure prediction. for example, mathews et al.  <cit>  used shape reactivity data to improve the prediction accuracy from  <dig> % to  <dig> % for 5s rrna of e. coli. roughly, the larger the shape reactivity value for a given nucleotide, the more likely it is that the nucleotide is unpaired in the structure. however, limited shape reactivity data is available, and the data does not unambiguously determine whether a base is paired or not or, if it is paired, to what other nucleotide. deigan et al.  <cit>  created pseudo energy terms from shape reactivity data, as a means of integrating such data into prediction software. they reported prediction accuracy of 96% to 100% for three moderate-sized rnas  and for 16s rrna . shapeknots  <cit>  is a new method for incorporating shape reactivity data for pseudoknotted structures that incorporates the pseudo energy terms into a heuristic method similar to that of ren et al.  <cit> .

we previously presented hfold  <cit> , an approach for prediction of pseudoknotted structures, motivated by two goals, namely to avoid the high running time complexity of other methods for pseudoknotted secondary structure prediction and to leverage the hierarchical folding hypothesis. this hypothesis posits that an rna molecule first folds into a pseudoknot-free structure; then additional base pairs are added that may form pseudoknots with the first structure so as to lower the structure’s free energy  <cit> . given a pseudoknot-free structure as input, hfold predicts a possibly pseudoknotted structure from a broad class that contains the given input structure and, relative to that constraint, has minimum free energy. hfold’s running time is o, significantly faster than other methods for predicting pseudoknotted structures. several experts have provided evidence for, and support, the hierarchical folding hypothesis  <cit> . the class of structures that hfold can handle, density- <dig> structures, is quite general and includes many important pseudoknots including h-type pseudoknots, kissing hairpins and infinite chains of interleaved bands, with arbitrary nested  substructures. 

another advantage of hfold over heuristic methods such as hotknots or shapeknots is that unlike these methods, hfold minimizes the free energy of the possibly pseudoknotted output structure relative to the given input structure. therefore hfold’s method of adding pseudoknotted stems is better motivated energetically than that of hotknots or shapeknots.

while hfold is fast, our earlier implementation of hfold had its own shortcomings. first, due to a high pseudoknot initiation penalty in its underlying energy model, many of its predicted structures did not have pseudoknots. also low band penalty  in its energy model encouraged addition of pseudoknotted stems when a pseudoknot was predicted. second, if the first structure input to hfold contains base pairs that are not in the true pseudoknot-free structure for the given rna sequence or is not the complete pseudoknot-free structure , hfold is often unable to predict the known pseudoknotted structure as output.

to summarize, existing methods for prediction of pseudoknotted structures suffer from one or both of the following shortcomings: 1) slow running time, or 2) poor prediction accuracy. moreover there is limited opportunity for the user to provide structural information, or constraints, that can guide prediction. in cases of a prediction method that incorporates user-defined constraints, it is also useful to understand the degree to which the method’s accuracy persists as the input information degrades. we use the term robustness with respect to partial information or robustness to refer to this property of a method.  to the best of our knowledge, the concept of robustness in secondary structure prediction methods has not been studied before.

in this work we present a new method that addresses these shortcomings. our method, iterative hfold, takes a pseudoknot-free input structure and produces a possibly pseudoknotted structure whose energy is at least as low as that of any  pseudoknotted structure containing the input structure. iterative hfold incorporates four different methods and reports as its final structure the structure with the lowest energy, among all structures produced by these methods. while one of its underlying methods, hfold, strictly adheres to the hierarchical folding hypothesis, the other three use iterations to extend or remove the base pairs of input structure, with the goal of finding a structure that has lower energy than the structure found by hfold. thus, unlike hfold, iterative hfold is able to modify the input structure . this is valuable since 1) computationally produced structures may not be completely accurate and 2) while the hierarchical folding hypothesis is a useful guiding principle, there is evidence that allowing for disruption of some base pairs in the initially formed pseudoknot-free secondary structure can improve prediction  <cit> .

all of iterative hfold’s underlying methods use the energy model of hotknots v <dig>  dp <dig>  <cit> ; with this model, hfold obtained predictions with higher accuracy than those obtained with our earlier implementation of hfold. one of iterative hfold’s underlying methods is hfold-pkonly, which given the input structure only adds pseudoknotted base pairs. hfold-pkonly is especially useful for cases when the user has either complete information about the true pseudoknot-free structure or wants to check whether a single stem of the input structure can be part of a pseudoknot since, if the input structure only has the specific stem in question, the output structure of hfold-pkonly will determine if the given stem can be part of a pseudoknot.

based on our experiments on our hk-pk and hk-pk-free data sets that include  <dig> pseudoknotted structures, and  <dig> pseudoknot-free structures respectively, ranging in length from  <dig> to  <dig> nucleotides, a single run of iterative hfold does not take more than  <dig> seconds time and  <dig> mb of memory. in contrast, one of the best heuristic methods, hotknots v <dig> , takes  <dig>  hours and  <dig> gb of memory for a sequence with  <dig> nucleotides. therefore our method is practical for prediction of long rna structures. iterative hfold bootstrap 95% percentile confidence interval for average accuracy of pseudoknotted structures of the hk-pk data set is significantly higher than that of ipknot,  vs. ) and is comparable to that of hotknots v <dig> , ) two of the best prediction methods available. iterative hfold’s accuracy is significantly higher than that of ipknot and hotknots on our ip-pk <dig> data set. iterative hfold also has higher accuracy than hfold even when just partial information about the true pseudoknot-free structure is provided, so it is more robust than hfold. specifically, iterative hfold’s average accuracy on pseudoknotted structures steadily increases from roughly 54% to 79% as the user provides up to 40% of the input structure, and improves with a more modest but still positive improvement in accuracy when further structural information is provided.

methods
we represent an rna molecule by a sequence, s, of its four bases, adenine , cytosine , guanine  and uracil . we denote the length of the rna molecule by n and refer to each base by its index i, 1≤i≤n.

when an rna molecule folds, bonds may form between canonical pairs of bases  . throughout this work, we consider only cases where each base may pair at most with one other base, and represent base pairing between i and j by i.j. we define a secondary structure, r, as a set of pairs i.j, 1≤i<j≤n; i.j and k.j can belong to the same set if and only if i=k.

if i.j and k.l are two base pairs of a secondary structure, r, and 1≤i<k<j<l≤n, we say i.j crosses k.l. we refer to a secondary structure with crossing base pairs as a pseudoknotted secondary structure and a secondary structure with no crossing base pairs as a pseudoknot-free secondary structure . figure  <dig> shows different kinds of loops in a secondary structure. we refer the readers to jabbari et al.  <cit>  or rastegari et al.  <cit>  for precise definition and illustration of terms used in the figure.

energy model
many computational methods for predicting the secondary structure of an rna  molecule are based on models of the free energy of loops  <cit> . table  <dig> summarizes the energy constants and functions used in our energy model for pseudoknotted structures. the values of these energy parameters are those of the dp <dig> parameter set of andronescu et al.  <cit> , used by the hotknots v <dig>  prediction software.

this table provides the names, description and values of the energy parameters and functions that we used in our methods. the names and definitions are the same as in our original hfold  <cit> , and the values were updated based on the work of andronescu et al.  <cit> . these parameters were derived for a temperature of 37°c and  <dig> m salt concentration.

data sets
we use three data sets to analyze performance of our algorithms. our first data set is the test data set of andronescu et al.  <cit> , that contains  <dig> distinct rna sequences and their reference structures, of which  <dig> are pseudoknot-free and  <dig> are pseudoknotted. this set has four structures that are not in the class of structures our methods can handle . since the number of such structures is too small to be useful in an experimental analysis, we removed them from our set of pseudoknotted structures, resulting in a set of size  <dig> 

there are eight cases in this data set for which the original sequence and structure were shortened to accommodate restrictions in length. we removed them from our data set, resulting in a set of size  <dig>  from now on we use “hk-pk” to refer to the pseudoknotted structures in this set  and “hk-pk-free” to refer to the pseudoknot-free structures in this set . rna sequences in hk-pk and hk-pk-free have length between  <dig> and  <dig> nucleotides.

our second data set is the pk <dig> data set of sato et al.  <cit> . this set contains  <dig> pseudoknotted structures from  <dig> categories of pseudoknots. the sequences in this set have at most 85% similarity and have length of at most  <dig> nucleotides. we refer to this data set as “ip-pk168”.

our third data set is the test data set of sperschneider et al.  <cit> . this set contains  <dig> pseudoknotted structures with strong experimental support. rna sequences in this set have length between  <dig> and  <dig> nucleotides. we refer to this data set as “dk-pk16”.

definition of gbig and gsmall
to test the robustness of our methods on a given rna sequence, we need to provide partial information about the true pseudoknot-free structure as input structure for that sequence. to obtain the true pseudoknot-free structure, gbig, we remove the minimum number of pseudoknotted base pairs from the reference structure to make the reference structure pseudoknot-free. if the reference structure is pseudoknot-free, then gbig is the same as the reference structure itself. we call the removed base pairs from the reference structure gsmall. blue base pairs in figure  <dig> represent base pairs of the gbig structure and green base pairs represent the gsmall structure.

accuracy measures
following common practice  <cit> , we measure the accuracy of a predicted rna secondary structure relative to a reference secondary structure by f-measure, which is the harmonic mean of sensitivity and positive predictive value . we define these values as follows: 

 sensitivity=numberofcorrectlypredictedbasepairsnumberofbasepairsinthereferencestructure 

 ppv=numberofcorrectlypredictedbasepairsnumberofpredictedbasepairs 

 and 

 f−measure=2×sensitivity×ppvsensitivity+ppv 

we also define these values as  <dig> when their denominators are  <dig>  when a prediction agrees with the reference structure, the value of f-measure is equal to  <dig> . when the values of sensitivity or ppv is equal to  <dig>  the predicted structure does not have any base pairs in common with the reference structure.

bootstrap percentile confidence intervals
to formally assess the dependency of measured prediction accuracy of results of a method on a given set of rna we use bootstrap confidence intervals, a well-known statistical resampling technique  <cit> . following the recent work of aghaeepour and hoos  <cit>  and hajiaghayi et al.  <cit>  we calculate the bootstrap 95% percentile confidence interval of average f-measure as follows. for each vector f of f-measures  we first take  <dig> resamples with replacement, where the resamples have the same length as the original sample vector f , and then calculate their average f-measures. these  <dig> calculated average f-measures represent the bootstrap distribution for the vector f. we then report the  <dig> th and  <dig> th percentile of this distribution  as the lower and upper bounds of the confidence interval respectively, and call it the bootstrap 95% percentile confidence interval. by reporting the bootstrap 95% percentile confidence interval for average f-measure of a method, a, on a data set, d, we say that we are 95% confident that the average f-measure of method a on data set d is in the reported interval. all calculations are performed using the “boot” package of the r statistics software environment  <cit> .

permutation test
following the recent work of hajiaghayi et al.  <cit> , we use a two sided permutation test to assess the statistical significance of the observed performance differences between two methods. the test proceeds as follows, given a data set and two structure prediction procedures, a and b. first, we calculate the difference mean−mean in means between sets of f-measure values obtained by a and b. then we combine the two sets fa and fb and record the difference in sample means for  <dig> randomly chosen ways of choosing two sets with the same size as |fa| and |fb| from the combined set. the p-value is the proportion of the sampled permutations where the absolute difference was greater than or equal to that of absolute difference of the means of sets fa and fb. then, if the p-value of this test is less than the 5% significance level, we reject the null hypothesis that methods a and b have equal accuracy and thus accept the alternative hypothesis that the difference in accuracy of method a and b is significant. otherwise, we cannot reject the null hypothesis. all calculations are performed using the “perm” package of the r statistics software environment.

iterative hfold
we provide a high level description of our iterative hfold algorithm.

pseudocode of our iterative hfold algorithm is available in additional file  <dig>  the algorithm builds on two simpler methods, the first being our original hfold algorithm  <cit> : 
hfold:
 given an rna sequence, s, and a pseudoknot-free input structure, g, find a pseudoknot-free structure, g′ such that g∪g′ is the lowest energy structure that contains g. we note that g∪g′ might not be pseudoknotted.

the second method on which iterative hfold builds, called hfold-pkonly, is similar to hfold except that g′ may only contain base pairs that cross base pairs in g. the prediction provided by hfold-pkonly can be useful in cases where hfold does not produce a pseudoknotted structure. 
hfold-pkonly:
 given an rna sequence, s, and a pseudoknot-free input structure, g, find a pseudoknot-free structure, g′ such that every base pair in g′ crosses some base pair of g and such that g∪g′ is the lowest energy structure that contains g among all such g′s. note that g′ may contain no base pairs.

iterative hfold also uses the simfold rna secondary structure prediction method  <cit> , which predicts the minimum free energy pseudoknot-free secondary structure for a given rna sequence. simfold uses a dynamic programming method similar to zuker’s mfold method  <cit> . in this work we used the hotknots energy parameters when running simfold. in addition to an rna sequence, s, simfold can also take a pseudoknot-free secondary structure, g, as input and predict the mfe pseudoknot-free secondary structure that contains all base pairs of g.

iterative hfold is distinguished from the above three methods, namely hfold, hfold-pkonly and simfold, in two important ways. first, the output of hfold, hfoldpkonly and simfold methods must contain the given pseudoknot-free input structure, g, whereas iterative hfold may modify the input structure. this can be useful when the given input structure is not a high-accuracy estimate of gbig, the true pseudoknot-free substructure of the reference structure. second, while hfold and hfold-pkonly can add base pairs that cross those in g, they cannot add base pairs that cross each other, and neither can simfold. in contrast, iterative hfold can add base pairs that cross each other. this is particularly useful when the input structure contains limited information about gbig, and so it is necessary both to predict base pairs in gbig and in gsmall in order to get a good prediction.

iterative hfold is comprised of four different iterative methods. following the description of each method, we motivate why we chose to include it as part of our overall algorithm. iterative hfold takes as input both an rna sequence, s and a pseudoknot-free secondary structure, g; later we show that structure g can be produced by computational methods, for example, hotknots hotspots or simfold suboptimal structures, when only the sequence s is initially available. 
iterative hfold:
 given an rna sequence, s, and a pseudoknot free input structure, g, run the following four methods and pick the structure with the lowest free energy among these four as the output structure.

iterative hfold runs in o time, as it runs four methods sequentially, when each one is o. 

method 1: run hfold on s and g, and store the resulting g∪g′.

motivation: this is the core hfold method, motivated by the hierarchical folding hypothesis.

method 2: first run hfold-pkonly on s and g. if hfold-pkonly results in a structure g∪g′ such that g′ is not the empty structure, then run hfold with sequence s and structure g′, and store the result. otherwise, simply store g as the result. see the following example. .)

motivation: when input structure g does not agree with the reference gbig structure, it may still be the case that hfold-pkonly finds the pseudoknotted structure gsmall . a call to hfold with input gsmall may then find a better approximation to gbig.

example 1: example of results of method  <dig> and method  <dig> of iterative hfold.   

 in this example, method  <dig> of iterative hfold outperforms method 1: although both hfold and hfold pkonly produce the same result on sequence s and input structure g, namely the structure g∪g′, the additional iteration in method  <dig>  in which hfold is run with s and g′, finds a structure with lower energy than that of g∪g′.

method 3: first run simfold on s and g to obtain result g′—a pseudoknot-free structure that contains g. then let gupdated be the secondary structure of s containing the relaxed stems of g′ that include the base pairs of g. by a relaxed stem, we mean a secondary structure containing stacked base pairs, bulges of size  <dig> and internal loops of maximum size of  <dig> . then run method  <dig> on s and gupdated, and store the result. see example  <dig> 

motivation: this method can work well when the given input structure has a small number of base pairs from gbig, because gupdated contains stems that includes these base pairs, but avoids “overcrowding” with further base pairs that might prevent hfold-pkonly from finding pseudoknotted stems.

example 2: example of result of method  <dig> compared to all four methods of iterative hfold.   

 in this example, method  <dig> of iterative hfold outperforms the other methods. because the input structure g consists of just one base pair, method  <dig>  outputs a pseudoknot-free structure containing g. the output of both methods  <dig> and  <dig> are pseudoknotted but do not contain the base pair of the input structure g. in contrast, method  <dig> first adds base pairs to g, resulting in the pseudoknot-free structure gupdated, and then adds additional pseudoknotted base pairs via method  <dig> 

method 4: let s <dig> be the subsequence of s obtained by removing bases that are external unpaired bases with respect to input structure g. run simfold on s <dig> and g , to obtain pseudoknot-free structure g′. then continue exactly as in method  <dig>  see example  <dig> 

motivation: this method is very similar to method  <dig>  but further constrains g′ since the base pairs in g′ cannot involve bases that are removed from s to obtain s <dig>  this potentially increases the possibilities for pseudoknotted base pairs to be added by method  <dig> 

example 3: example of result of method  <dig> compared to all four methods of iterative hfold.   

 in this example, method  <dig> of iterative hfold outperforms the other methods. the input structure g has a high energy value and neither method  <dig>  nor method  <dig>  can expand the pseudoknot-free structure to add the pseudoknotted stem. also, by adding too many pseudoknot-free base pairs, method  <dig> fails to find the pseudoknotted base pairs. thus, method  <dig> performs better than methods  <dig>   <dig> and  <dig> 

experimental settings
in this section we explain details of our computational experiments.

robustness test
one of our goals is to understand the degree to which our methods are robust with respect to partial information, that is, provide a reliable prediction even when limited information about the true pseudoknot-free structure, gbig, is available. for this purpose we generate subset structures of the corresponding gbig, for each rna sequence in the hk-pk and hk-pk-free data sets. for each α,  <dig> ≤α≤ <dig>  with  <dig>  steps, we choose each base pair of gbig structure with probability α. we also generate 1% information and 99% information about the gbig structure . we repeat this step  <dig> times to generate  <dig> substructures of gbig for each value of α for each rna sequence in our data sets. we then run our methods on all  <dig> substructures for each rna sequence in our data sets and α value and calculate the bootstrap 95% percentile confidence interval for average f-measure of these  <dig> cases as the accuracy interval for each method and each rna sequence and α value in our data set.

we also compare our methods when the true pseudoknot-free structure, gbig is provided.

accuracy comparison tests
we compare the accuracy of hfold, hfold-pkonly and iterative hfold with each other on different input structures, and with other methods, namely simfold  <cit> , hotknots v <dig>   <cit>  and ipknot  <cit> . we first describe the latter two methods and the settings we choose for our experiments. we then describe the ways in which we choose input structures for hfold and its variants.

hotknots
hotknots is a heuristic program that given an rna sequence, first finds about  <dig> lowest energy stems , called hotspots. then keeping all these stems, it adds other non-overlapping low energy stems to the stems found in the first step, so as to minimize the energy of the overall structure, eventually producing up to  <dig> output structures. in our experiments, we choose the structure with the lowest energy value among the  <dig> output structures as the final structure predicted by hotknots. when reporting prediction accuracy for hotknots, we report the bootstrap 95% percentile confidence interval for the average f-measure of the lowest energy structure for all rna sequences in our data set.

ipknot
ipknot is a secondary structure prediction method based on maximum expected accuracy  of the base pairs. in addition to the rna sequence, ipknot gets several parameters as input. following, we describe each of these parameters and settings briefly. 

•level: if structure g can be decomposed into k disjoint pseudoknot-free structures, g <dig> g <dig> …,gk, such that every base pair in gi crosses the base pairs of gj, 1≤i≤j≤k, sato et al. say that structure g has k levels. for example, a pseudoknot-free structure has level  <dig>  and an h-type pseudoknot has level  <dig>  in another example, when representing the secondary structure in dot bracket format, the number of different brackets used to represent the structure is the level of the structure. ipknot can handle structures up to level  <dig> 

•scoring model: the energy model used to produce posterior probabilities for each base pair is called “scoring model”. ipknot has  <dig> different scoring models, namely “contrafold”, “mccaskill” and “nupack”.

•refining parameters: the procedure of recalculating the base pair probabilities based on the original prediction results is referred to as “refining parameters”.

•base pair weights for each level: positive numbers representing the rate of true base pairs in each level.

we run ipknot using the provided source code and the default parameters for scoring model and level . the default values provided for base pair weights are not the same on the ipknot website , its source code  and the provided perl script . we run ipknot with all of these values with and without refinement and provide ipknot’s bootstrap 95% confidence intervals for average f-measures for all of our data sets as a table in the additional file  <dig>  based on its performance we present ipknot’s results with default settings  and γ1= <dig> and γ2= <dig>  for comparison with other methods.

different versions of hfold
we compare the average accuracy of hfold, hfold-pkonly and iterative hfold with different input structures.

to determine which input structures are good to use when gbig is not known, we compare two different options. since hfold  cannot accept pseudoknotted input structures we use the following methods to produce pseudoknot-free input structures to hfold . first, we use hotknots hotspots  <cit> , i.e., the  <dig> lowest energy pseudoknot-free stems produced in the first phase of hotknots. we choose the lowest free energy structure predicted by each of our methods as their final prediction given these hotspots. second, we use simfold’s mfe structure  <cit>  where the energy parameters of simfold are changed to match that of hotknots v <dig> .

running time
we ran all methods on the same platform . we use the time command to measure the running time of our methods on each sequence, and record the wall clock time.

memory usage
to find the memory usage of the programs, we use the valgrind package  <cit>  and record the total heap usage as memory usage of each program. ipknot and hotknots are completely written in c and so we can easily find their memory usage by running valgrind. however, iterative hfold program is a perl script that runs a few c programs  sequentially. so we find the memory usage of each c component using valgrind and assign the maximum as the memory usage of iterative hfold.

RESULTS
as mentioned in section ‘background’, in the literature on hierarchical folding, there are reports of counter examples to the hierarchical folding hypothesis where bases that are initially part of the pseudoknot-free structure for a molecule later change as the pseudoknot forms. this motivates a comparison of hfold versus iterative hfold, in order to see how a method that sticks strictly with the hypothesis  compares with a method that allows for some base changes . in section ‘robustness comparison’, we compare the robustness of hfold and iterative hfold with respect to partial information; that is, the degree to which they provide accurate predictions as a function of how much information about gbig, the true pseudoknot-free secondary structure, is provided as input. then in section ‘accuracy comparison of different versions of hfold’ we compare hfold, hfold-pkonly and iterative hfold when a  computational prediction of gbig is provided as input. in section ‘accuracy comparison with existing methods’ we compare iterative hfold—the method that performs best overall in sections ‘robustness comparison’ and ‘accuracy comparison of different versions of hfold’ —with existing methods for pseudoknotted secondary structure prediction. sections ‘running time comparison’ and ‘memory consumption comparison’ report on the running time and memory usage of our methods.

robustness comparison
one of our goals is to learn what is the accuracy of each of our methods when partial information about gbig is available . figure  <dig> shows the results of this robustness evaluation, for pseudoknotted structures , pseudoknot-free structures  and the overall results . since hfold-pkonly cannot add pseudoknot-free base pairs to the given input structure, we do not compare its performance here with hfold and iterative hfold. however we provide detailed performance of all versions of hfold including hfold-pkonly in additional file  <dig> 

as shown in figure 2a, which pertains to pseudoknotted structures of the hk-pk data set, when provided with ≈1% of the gbig structure as input, iterative hfold’s bootstrap 95% percentile confidence interval of average f-measures has higher accuracy than those of hfold. iterative hfold continues to be significantly superior to hfold until approximately 90% of gbig is available, after which hfold is more accurate. iterative hfold is most successful when little information about gbig is known because it can add both pseudoknot-free and pseudoknotted base pairs. in particular, using methods  <dig> and  <dig>  iterative hfold first finds a low energy pseudoknot-free structure that includes the given input structure , and then adds pseudoknotted base pairs to further lower the energy of the overall structure. however, when the vast majority of base pairs of gbig are provided as input, hfold dominates as it keeps the base pairs of the input structure, thereby often adding base pairs of gsmall. when 100% of gbig is provided as input, hfold’s bootstrap 95% percentile confidence interval is , compared with  for iterative hfold.as shown in figure 2a, iterative hfold’s average accuracy on pseudoknotted structures steadily increases from about 54% to 79% as the user provides 1% to 40% of the input structure. this improvement in accuracy slows down but still persists when further structural information is provided. if we compare the slope of the curve for iterative hfold’s average accuracy to that of hfold in figure 2a, we can see that hfold’s slope is steeper than that of iterative hfold, making iterative hfold more robust than hfold.

for pseudoknot-free structures of the hk-pk-free data set, as shown in figure 2b, hfold performs better than iterative hfold. even with 1% information about gbig, hfold results in 95% bootstrap confidence interval in comparison with  for iterative hfold with the same inputs. roughly, hfold’s success for pseudoknot-free structures is because it often adds base pairs that do not cross those provided as part of the input, and thus are likely to be in gbig.

when 100% of gbig is provided as input, the overall bootstrap 95% confidence interval for hfold is  compared with  for iterative hfold.

accuracy comparison of different versions of hfold
often, partial information about gbig is not available; this is the case for many rnas of unknown function reported by the encode consortium  <cit> . therefore, we next compare the quality of results obtained by hfold, hfold-pkonly and iterative hfold when given a pseudoknot-free input, g that is predicted by existing computational methods. one way to produce an input structure is to use an mfe pseudoknot-free structure prediction method, such as mfold. we chose simfold as it is an implementation of mfold and, because of its energy parameters, gives more accurate predictions than mfold. of course, when comparative information is available, the user can input such information as structural constraint as a pseudoknot-free structure to iterative hfold and expect a better prediction result. here we compare two methods for predicting g, namely simfold and the hotspots produced by hotknots v <dig> . table  <dig> reports the bootstrap 95% percentile confidence intervals of average f-measures. the accuracy of hfold-pkonly is significantly worse than that of hfold and iterative hfold, both with the output of simfold, and with the hotknots hotspots as input, so we do not discuss hfold-pkonly further.

for pseudoknotted structures, using hotknots hotspots as input is far superior to using simfold as input, for both hfold and iterative hfold. this appears to be because mfe structures predicted by simfold tend to have more base pairs than the true pseudoknot free structure, gbig, so that hfold and iterative hfold are unlikely to add pseudoknotted base pairs to the input structure. for pseudoknot-free structures, using simfold as input is somewhat better than using hotknots hotspots, but the permutation test indicates that the difference is not significant.

the confidence intervals for hfold and iterative hfold with hotknots hotspots are  and , respectively, and on pseudoknot-free structures they are  and  respectively. again, based on the result of the permutation test, the difference in the results of hfold and iterative hfold on pseudoknotted and pseudoknot-free structures are not significant. similarly, the permutation test shows that the difference in prediction accuracy of hfold and iterative hfold on simfold input is not significant.

accuracy comparison with existing methods
for comparisons with other methods already in the literature, we choose to use our iterative hfold method with hotknots hotspots as input structure, based on its overall good accuracies in section ‘accuracy comparison of different versions of hfold’. we compare this method with two of the best-performing methods  <cit>  for prediction of pseudoknotted structures, namely hotknots v <dig>   <cit> , a mfe-based heuristic method, and ipknot  <cit> , a method that is based on maximum expected accuracy. 

running time comparison
since prediction of pseudoknotted structures are of interest to us, we only report running time comparison on pseudoknotted structures of our hk-pk data set. figure  <dig> presents result of time comparison between iterative hfold and hotknots in a log plot . the x axis shows log for hotknots data points and the y axis shows log for iterative hfold on the hk-pk data set. rna sequences in this data set are between  <dig> and  <dig> bases long. hfold runs significantly faster than hotknots and finishes under  <dig>  seconds for even the longest rna sequence in our data set . hotknots is faster than iterative hfold on sequences of up to  <dig> bases, where iterative hfold starts being faster than hotknots. iterative hfold runs in less than  <dig>  seconds for all rna sequences in this data set whereas hotknots runs for over  <dig> seconds  on the longest rna sequence in our data set. the running time of both hfold and iterative hfold grows with sequence length, whereas hotknots’ running time is not directly correlated with rna length. for example, hotknots runs for  <dig>  seconds for one rna sequence of length  <dig> , while it runs for  <dig>  seconds for another rna sequence of length  <dig> .

ipknot is significantly faster than both hfold and iterative hfold. for all sequences in this data set, ipknot produces output in less than  <dig>  seconds. for detailed information about performance of each method see additional file  <dig> 

memory consumption comparison
here we present memory consumption of hfold, iterative hfold and hotknots on our hk-pk pseudoknotted structures. since hotknots predicts and keeps about  <dig> structures in memory, its memory consumption can vary significantly from one sequence to another, and is not predictable. up until  <dig> bases, hotknots some times uses less memory than hfold or iterative hfold, but for rna sequences with  <dig> bases or longer, hotknots uses much more memory than hfold and iterative hfold. iterative hfold’s memory usage is very similar to hfold’s and increases at a very low rate by the length of the rna sequence. it starts from  <dig>  mb for rna sequences of length  <dig> and increases to  <dig>  mb for the longest rna sequence in this data set . hotknots, however, uses as little as  <dig>  mb for an rna of length  <dig> bases  and as much as  <dig> mb for the longest rna sequence in this data set.

ipknot uses much less memory than all other methods. for the longest rna sequence in this data set, ipknot uses less than  <dig>  mb of memory in comparison to  <dig>  mb of hfold and iterative hfold and  <dig> mb of hotknots. for detailed information about memory usage of each method see additional file  <dig> 

discussion
in section ‘comparison with hotknots and ipknot’ we provide more insight on the differences and merits of iterative hfold, hotknots and ipknots. then in section ‘comparison with shapeknots’ we compare accuracy of iterative hfold with shapeknots, a method that incorporates shape reactivity data to predict rna pseudoknotted secondary structure. in section ‘iterative hfold with simfold’s suboptimal structures’ we compare performance accuracy of iterative hfold with two inputs: hotknots hotspots and suboptimal structures. section ‘energy model’ provides more insight into the energy model used in this work.

comparison with hotknots and ipknot
comparing accuracy of iterative hfold and hotknots v <dig>  on hk-pk, hk-pk-free, dk-pk <dig> and ip-pk <dig>  we found that the difference in their accuracies is insignificant on hk-pk, hk-pk-free and dk-pk <dig> data sets when iterative hfold is provided with hotknots hotspots as input. based on our results on the hk-pk data set, with only about 15% information about the true pseudoknot-free structures, iterative hfold’s 95% percentile confidence interval is  . if the user has about 35% information about the true pseudoknot-free structure, iterative hfold’s accuracy is comparable with that of hotknots  vs. ). however iterative hfold’s accuracy  is significantly better than that of hotknots on the ip-pk <dig> data set. one of the advantages of iterative hfold over hotknots is that in iterative hfold base pairs are added to lower the energy of the given structure while in hotknots stems are added in a way that does not take into account the energy of stems in the previous steps.

when reporting on time and memory consumption of iterative hfold and hotknots on the hk-pk data set, we did not include the time and memory required to get the input structures to iterative hfold. since we only run hotknots v <dig>  partially to produce hotspots it does not take as long as running hotknots and does not consume as much memory. for example, for the  <dig> nucleotides long rna sequence in our data set , it only takes  <dig>  seconds time and  <dig> mb of memory to produce the hotspots.  we also note that since calculating hotspots and running iterative hfold are done sequentially, the memory consumption is calculated as the maximum of the two, so the memory consumption of iterative hfold for this sequence is still the same even including the memory needed for calculating hotspots. as we can see based on this example, even including time and memory requirements of calculating hotspots, iterative hfold is still faster than hotknots and uses less memory.

we also compared iterative hfold with ipknot  <cit> . while ipknot is faster than iterative hfold and uses less memory, we found that for the hk-pk and ip-pk <dig> data sets, iterative hfold provides significantly more accurate predictions of pseudoknotted structures, compared with ipknot. based on our results on the hk-pk data set, iterative hfold’s performance with more than 5% information about the true pseudoknot-free structure, is better than that of ipknot with default settings . we note that sato et al.  <cit>  find the performance of ipknot with predictions using “nupack” superior to all versions of ipknot, but since this model can be used for rna sequences of length < <dig> nucleotides, we did not compare our results with this version of ipknot. among all different versions of ipknot we tested, we found all but γ1= <dig> and γ2= <dig> setting producing similar confidence intervals for all but the hk-pk-free data sets, for which γ1= <dig> and γ2= <dig> produces the best result . while running parameter refinement with one iteration improved the confidence intervals in the hk-pk data set, it did not result in any improvement in accuracy in the rest of our data sets as in many cases ipknot failed to produce results. we note that our results on the ip-pk <dig> data set with different weight parameters perfectly match the results of sato et al.  <cit> .

a disadvantage of ipknot over iterative hfold is that being an mea-based method, ipknot does not produce free energy of the predicted structure. also to get the best prediction, the user needs to provide some guidance as to what type of structure to predict for the given sequence, e.g., whether pseudoknot-free or pseudoknotted.

comparison with shapeknots
similar to hotknots, the shapeknots method of hajdin et al.  <cit>  is a heuristic algorithm for prediction of pseudoknotted structures. this method incorporates shape reactivity data as a pseudo energy term into the prediction method. shape reactivity data is only available for a limited number of rna sequences, so we cannot compare iterative hfold with shapeknots on our data set. therefore, we use data set of hajdin et al. to compare these two methods. in their data set hajdin et al. have  <dig> rna sequences in their training set and  <dig> rna sequences in their test set. we run iterative hfold with hotspots for each rna sequence and choose the lowest energy structure as the final output of our program. for shapeknots, we use the sensitivity and positive predictive values reported in the work of hajdin et al.  <cit>  to compare with iterative hfold. table  <dig> shows the results of this comparison. in all but one sequence of the test set, iterative hfold obtains higher accuracy than shapeknots. the exception is the hiv- <dig> 5’ pseudoknot domain; hajdin et al. note that the accepted structure of hiv- <dig> 5’ pseudoknot domain is based on a shape directed prediction and thus an accuracy comparison between shapeknots and iterative hfold may be biased towards shapeknots. in the training set, however, iterative hfold does not perform as well as shapeknots. this might be because parameters of shapeknots were tuned on the training set to achieve the highest possible accuracy. since both the training and test data sets are small, we cannot make more general statements about the significance of the differences in accuracy between the two methods.

iterative hfold with simfold’s suboptimal structures
to further investigate which input structures are good to use when gbig is not known, we use the first  <dig> suboptimal structures produced by simfold . then for each rna sequence we run our methods on all  <dig> suboptimal structures and choose the one with the lowest free energy as the final result for that rna sequence. with this approach, the bootstrap 95% percentile confidence interval of average f-measure of hfold and iterative hfold is  and  respectively for pseudoknotted structures and  and  respectively for pseudoknot-free structures. the permutation test indicates that the difference between these results and the corresponding results when input structures are hotspots is not significant. we also test the significance of results of hfold with first  <dig> suboptimal structures versus iterative hfold with the same input structures and iterative hfold with hotspots for both pseudoknotted and pseudoknot-free structures. although the bootstrap 95% percentile confidence intervals for average f-measures seem different, the permutation test indicates that the difference is not significant. similarly, results of iterative hfold with the first  <dig> suboptimal structures are not significantly better or worse than the result of hfold with hotspots as input structures for both pseudoknotted and pseudoknot-free structures.

energy model
in this paper we use the hotknots v <dig>  dp <dig>  <cit>  energy parameters in our implementation of iterative hfold. to investigate the degree to which the energy model may be causing mis-predictions by hotknots v <dig>  or iterative hfold, we considered the degree to which the maximum accuracy structures produced by these methods, i.e., the structure with highest f-measure, is better than the minimum free energy structures. table  <dig> presents the difference in bootstrap 95% percentile confidence intervals of average f-measure. if we choose the maximum accuracy structure among the  <dig> output structures predicted by hotknots for each rna sequence, the bootstrap 95% percentile confidence intervals of average f-measure of hotknots will increase to  for pseudoknotted structures of the hk-pk data set  when choosing the lowest energy structure) and  for pseudoknot-free structures of the hk-pk-free data set  when choosing the lowest energy structure).

similarly, if we compare the maximum accuracy structure output by iterative hfold with the minimum free energy structure, whether given hotknots hotspots or the first  <dig> suboptimal structures to iterative hfold as input, the bootstrap 95% percentile confidence intervals of average f-measure also show improvement - see table  <dig>  the difference in improvements is significant in all but one case, namely iterative hfold on hotspots structures as input for pseudoknotted structures of the hk-pk data set. we conclude that improvements on the energy parameter values for pseudoknotted structures may further improve accuracy of both hotknots and iterative hfold.

CONCLUSIONS
in this work we present iterative hfold, a fast and robust iterative algorithm that matches the accuracy of the best existing pseudoknot prediction methods. iterative hfold is significantly more accurate than ipknot while matching the accuracy of hotknots on the hk-pk data set. iterative hfold is superior to both ipknot and hotknots on the ip-pk <dig> data set. moreover both iterative hfold and ipknot use less memory and run much faster than hotknots on long sequences.

iterative hfold also has lower rate of accuracy deterioration than hfold with loss of information about the true pseudoknot-free structure, so it is more robust than hfold. this is particularly helpful when the given input structure may be unreliable and/or limited information about the true pseudoknot-free structure is available. iterative hfold is also more accurate than shapeknots  <cit>  on the test set of hajdin et al.  <cit> .

in this work, we compared two different ways to generate pseudoknot-free input structures for input to iterative hfold, namely the first  <dig> suboptimal structures produced by simfold, and hotknots hotspots. on the hk-pk and hk-pk-free data sets, accuracy of iterative hfold is not significantly different on each of these. an alternative approach that may be worth exploring in future work would be to use the most highly probable base pairs, as calculated using the partition function  <cit> . even better may be to calculate base pair probabilities for base pairs of pseudoknotted rna structures; however this requires Θ time. since hfold finds minimum free energy structure in o time, conditional on the given input structure, we are currently investigating ways to develop an o-time partition function version of hfold that can produce pseudoknotted base pair probabilities that are conditional on the given input structure.

comparing accuracy of the minimum free energy structures with the maximum accuracy structures in this work, we found that, on average, the minimum free energy structure has significantly poorer f-measure than the maximum accuracy structure. this suggests that an improved energy model for pseudoknotted structure prediction may improve accuracy of prediction algorithms for pseudoknotted structures.

another direction for future work can be to use iterative hfold for structure prediction of two interacting rna molecules. iterative hfold may be well suited for this purpose because, given input structures for each individual input molecule, it allows for modification of these input structures as it explores potential base pairing interactions between the two molecules.

data and software availability
iterative hfold and all data used in this work are freely available at http://www.cs.ubc.ca/~hjabbari/software.php.

competing interests
the authors declare that they have no competing interests.

authors’ contributions
hj designed and implemented the algorithms, acquired, analyzed and interpreted the data and drafted the manuscript. ac supervised the research, participated in analysis of data and in revising the manuscript. both authors read and approved the final manuscript.

supplementary material
additional file 1
pseudocode. we provide pseudocode of our iterative hfold algorithm in this section.

click here for file

 additional file 2
ipknot performance. table  <dig> provides the bootstrap 95% confidence intervals for average f-measure of ipknot on different data sets and different weight parameters. the energy model in all these experiments is set to mccaskill and level is set to  <dig> .

click here for file

 additional file 3
robustness comparison and correlation to false positives. tables  <dig> and  <dig> provide complete presenting robustness comparison of hfold-pkonly, hfold, and iterative hfold, when provided with different percentage of gbig information of hk-pk and hk-pk-free data

sets. note that the reported interval in each case is the bootstrap 95% confidence interval for f-measure of the  <dig> structures with 1≤α≤ <dig> percent information about the gbig structure. the 100% information is the bootstrap 95% confidence interval for f-measure when input structure is gbig. table  <dig> provides pearson correlation coefficient of hfold and iterative hfold with hotknots hotspots, simfold mfe and simfold first  <dig> suboptimal structures. here fp represents false positive rate and f represents the f-measure as the accuracy measure.

click here for file

 additional file 4
time and memory comparison. tables  <dig> and  <dig> provide complete data presenting running time comparison of hfold, iterative hfold, hotknots v <dig>  and ipknot on the hk-pk data set. timing is presented in seconds. tables  <dig> and  <dig> provide complete data presenting memory  comparison of hfold, iterative hfold, hotknots v <dig>  and ipknot on the hk-pk data set. memory usage is presented in mega bytes.

click here for file

 acknowledgements
the authors thank the reviewers for their very constructive suggestions. the authors also thank and acknowledge dr. holger hoos for his helpful comments and early discussion about the paper. this research was funded by a grant from the natural sciences and engineering research council of canada .
