BACKGROUND
the discovery that rous sarcoma virus can induce cancer in chicken  <cit>  had revolutionized cancer research. although this discovery was met with initial skepticism, the association between cancers and viral infections has been firmly established today. one of the striking facts is that some viruses causing cancers are highly prevalent. for example, the epstein-barr virus infects about 90% of the human population by adolescence and it causes several forms of cancer  <cit> . another example is hepatocellular carcinoma . its leading cause is hepatitis b virus  infection. at least one third of the world population has been infected by hbv at some point in their lives  <cit> . therefore, the study of the relationship between virus integrations and diseases is very important.

the revolution of next generation sequencing  enables us to probe the interactions of viral and human dnas at a molecular level. apart from detecting the presence of viruses, ngs enables the detection of the virus integrations and determination of the actual integration breakpoints at base-pair resolution. however, this analysis is not straightforward. one reason is that the majority of the ngs reads are originated from the host  instead of the virus. another reason is that the integrations might happen in repeat regions, and may produce ambiguous alignments. therefore, it is important to find a method that can effectively use a small number of reads to predict the presence of viral integrations.

several methods were proposed to study the presence of viruses and their integrations. srsa  <cit>  and pathseq  <cit>  are some early programs that were designed to determine the types of viruses and pathogens in ngs samples. recently, virusseq  <cit> , viralfusionseq  <cit>  and virusfinder  <cit>  were proposed to identify virus integration sites. virusseq first aligns reads to a reference genome; then, the unaligned reads are mapped to a virus database to identify the target viral genome. this viral genome is added as a dummy chromosome and all unmapped paired-end reads are realigned to this modified genome. by identifying discordant alignments between human and the viral genome, integration sites are identified. in viralfusionseq, the reads are aligned to viral and human genomes using bwa-sw  <cit> . reads having soft clips in the viral mappings, and reads having one end aligned to human genome while the other end aligned to virus genome are extracted. these reads are clustered and assembled  to find integrations. virusfinder aligns reads to both human and viral genomes. then, virus integrations are found by the structural variation callers svdetect  <cit>  and crest  <cit> .

we identify several drawbacks with existing approaches. first, existing methods use general ngs read aligners to identify reads near the virus integration sites. general ngs real aligners assume each read contains some long seed with low number of mismatches. however, such assumption may not be valid on the virus genome  or near to the virus integration sites. together with the fact that the number of reads covering virus integrations are usually lower, existing methods has difficulty to align reads around virus integration sites, which reduce the sensitivity of existing methods to predict virus integrations. the second problem is the use of soft-clipped reads by viralfusionseq and virusfinder. the soft-clip positions predicted by the aligners may not be accurate. finally, virusseq and virusfinder assume that exactly one virus strain is involved in the integrations. . however, there are cases where a single individual is infected by multiple different strains of the same virus  <cit> . therefore, these methods may fail to call some integration sites.

in this paper, we propose a method batvi to overcome these problems. batvi identifies a set of probable chimeric reads using the sensitive blast aligner  <cit> . blast is able to detect chimeric reads with short viral segments  accurately. therefore, batvi can detect viral integrations having very low coverage. for detecting viral integrations, batvi uses fast clustering and multiple sequence assembly methods. furthermore, batvi does not make any assumption about the strains of the integrated virus.

we compare batvi with virusfinder  <dig> and virusseq. . using simulated data, we show that batvi recovers more viral integrations. furthermore, we note that existing methods may predict many false integrations that occur in repeat regions. on the other hand, batvi can either identify the correct integration or report the fact that the integration is unreliable. we also test the performance of batvi using real datasets. using a list of viral integrations generated by high coverage target sequencing  <cit>  as a benchmark, we compare batvi with other methods. we show that batvi can predict more correct hbv integrations and produce less false positives in the shortest amount of time. in summary, batvi is fast, sensitive and accurate.

methods
the input of batvi consists of a database of viruses, a human reference genome and the raw ngs reads . batvi has three stages. first, it identifies a set of chimeric read pairs that map both to human and virus genomes. next, the chimeric reads that co-localize in the human genome are clustered. finally, integration sites are extracted from these clusters. these stages are described in detail below.

identifying chimeric reads
batvi can start with either the raw reads or a sam/bam file containing the read alignments. if the sam/bam file is given, we extract read pairs with soft-clips and those with at least one read unmapped. otherwise, the whole set of raw reads is taken as the input. these reads are checked for the presence of a virus. this is done by checking if some k-mer from the reads can be mapped to the virus database with at most r mismatches. to be sensitive, we set k= <dig> and r= <dig> by default. once we check one k-mer in the read, we shift by s positions  and check another k-mer on the read. the alignment of k-mers is done using batmis  <cit>  algorithm, which is a bwt-based algorithm that can report all hits. we retain read pairs with at least one k-mer aligned on the virus database. such a set of read pairs is denoted as the set x
 <dig>  after this initial screening, the second step performs a more thorough examination for a viral segment in the reads in x
 <dig> by aligning them to the virus database using blast. all the read pairs that do not have a mapping by blast are discarded and the remaining read pairs are stored in the set x
 <dig>  x
 <dig> is a set of read pairs that possibly originated from the virus. finally we check if the read pairs in x
 <dig> can be mapped to the human genome by blast. if a read or its mate has a hit in human genome by blast, it is stored in the set x
chimera.

although blast is accurate, it is several times slower compared to ngs aligners. hence, this pipeline is carefully adjusted to minimize the usage of blast. we use it sparingly by first removing a set of reads unlikely to be chimeras, and then using blast with a small virus database, and finally with the reference genome. figure  <dig> shows the complete pipeline.
fig.  <dig> a pipeline to identify potential chimeric reads




clustering reads
let d and σ be the mean and standard deviations of the insert size of the read pairs. for each read r
i∈x
chimera that is mapped to human, blast will report a set of locations l1i,l2i,…,lji with expect values e1i,e2i,…,eji. the hit lli is called a rank-n hit if there are n hits whose expect values are smaller than or equal to eli. . if there are multiple hits with the smallest expect value, we retain all hits with the smallest expected value. if there is exactly one hit with the smallest expect value, we also retain hits with the second smallest expect value. .

among all retained hits , we put the hits into the same cluster if they are near each other. precisely, we sort the hits for each chromosome in the ascending order of their location. then we traverse this sorted list chromosome by chromosome, from top to bottom. clusters are formed during this traversal by adding two consecutive hits  and  to the same cluster if |lpi−lqj|<d+2σ.

the next step is to partition the aligned reads in every read cluster c
i into two sub-clusters ci+ and ci− such that ci+ contains all reads that align on human-virus integrations where human is on the 5’ side of the virus. the classification can be done based on the alignment orientations of the reads on the human genome as illustrated in fig.  <dig>  precisely, for every ∈ci, if the prefix of r
a aligns on the +ve strand or the suffix of r
a aligns on the -ve strand of human genome, we add  to the sub-cluster ci+; otherwise, it is added to ci−.
fig.  <dig> this figure illustrates the orientation of the chimera reads when they map on the human genome. for all examples, we orient the human-virus integration fragments such that the human reference is in +ve strain. a–c illustrate cases where human is on the 5’ side of virus. in such cases, for each read r
i aligned on the human genome, we have either the whole read r
i or its prefix aligns on the +ve strand of the human genome or only the prefix of r
i aligns on the -ve strand of the human genome. d–f illustrate cases where human is on the 3’ side of virus. in such cases, for every read r
i aligned on the human, we have either r
i or its suffix aligns on the -ve strain of the human genome or only the suffix of r
i aligns on the +ve strain of the human genome




extract integration sites
after clustering the reads, we follow three steps to identify the possible integrations . first, we refine the clusters to remove noisy and duplicate reads. second, we identify a possible breakpoint from the clusters. finally, if split reads are present, we use them to refine the breakpoints. these steps are detailed below.
fig.  <dig> the work flow showing how clusters are refined and breakpoints are predicted




refining the clusters
the clusters are refined by 1) removing noisy and complex reads, 2) filtering duplicate reads and 3) rescuing split-reads. we describe the details of the three steps below.

 batvi assumes that each single ended read is composed of at most one segment from human and at most one segment from virus. if there are other complex cases, batvi will discard these reads.  if both ends of a read pair are mapped to the human genome, we check to see if they are correctly oriented and whether they map within the same chromosome. if they are not, the reads are discarded.

 due to the low number of viral integrations in a cell population, it is highly unlikely that the datasets contain identically mapped read pairs unless the sequencing was targeted. therefore, whenever there are identical hits , we provide the option to retain only one copy and remove the other reads from the cluster.

 some reads align partially to the human genome or to the virus. blast fails to align the remaining portion of such reads due to several reasons. the first reason is the limits of sensitivity of blast, where sequences of length  <dig> bp is required for an alignment. the second reason is due to a short random sequence inserted within the viral-human integration site. the third reason is that the alignment may be incorrect.  we try to rescue the alignment of the split reads for the first two cases.
fig.  <dig> the figure shows how the human segment of a read may be unaligned by blast. the black and gray lines indicate the human and viral reference genomes, respectively. the red segments are sequences originating from viral genome and the blue segments originate from the human genome. the green segment indicates a random sequence and the blue vertical lines indicate places where reference and the human segment match. in , although the human segment matches the reference, it is too short to be detected by blast. in , a random sequence is present in the integration and the human segment present is too short to be detected by blast. in , their is no human segment at all. this may be due to an insertion or due to a misalignment of the sequence. we will attempt to rescue reads in cases  and  through local alignment




if one side of a read aligns to the virus by blast, and there is at least  <dig> contiguous bases unaligned, we attempt to rescue this read as a split-read. the mate of such a read must be aligned to human. if the mate is not a split-read, we may be able to rescue the split-read as follows. we extract the sequence flanking the mate. the size of the flanking region is set as d+2∗σ. if the split read is real, the unaligned portion of the read should align within this extracted flanking region. we use a fast simd-based implementation of the smith-waterman algorithm to check if this is the case. if no such pattern is found, we discard the read. otherwise, the read is updated as a true split read.

identify integration breakpoints
for each cluster ci+ , we estimate the integration breakpoints on both human and virus as follows. to estimate the human integration breakpoint for a cluster ci+, we report maxlen+lja|∈ci+. similarly, the human integration breakpoint for a cluster ci− is estimated as minlja∣∈ci− . in the case of the clusters containing a split read with a mapping for the human segment, we can estimate the exact breakpoint .
fig.  <dig> the figure shows how the breakpoints are estimated from a cluster of reads. the red segments of a read aligns to human genome , and the blue segments belong to the viral genome . the solid arrows show properly aligned reads and dashed arrows indicate reads that are aligned incorrectly. for a read cluster ci+  we take the 3’-most aligned position of the read cluster as the estimated human breakpoint. in , there is no read passing through the actual breakpoint so the estimation can be off to the 3’ side . this can be as much as the maximum insert size span of the library. however, if there is a split read r
d , the exact human breakpoint can be recovered. to find the viral co-ordinate of the integration following procedure can be used. if a split read is available close to the estimated human breakpoint, the exact viral breakpoint can be found out c. otherwise, the viral mappings of the cluster ci+  will be further sub-divided into two clusters based on the strand of the mapping. the cluster containing the largest number of reads will be considered as correct. then, the viral breakpoints can be estimated using similar method as that for the human breakpoints d





to estimate the virus integration breakpoint, the reads in ci+  and their mates having a viral mapping are considered. similar to the detection of the human integration, these reads are clustered into two groups: those mapping to the positive strand of the viral genome , and those mapping to the reverse strand of the viral genome . if the alignments are accurate, one of these clusters should be empty. however, noisy mappings might make both clusters non-empty. when one cluster contains at least ε reads more than the other cluster , we assume that cluster to be the correct one. otherwise, the viral breakpoint is not reported. the orientation of the viral segment can be determined based on the strand of the reads in the viral cluster and the orientation of the human breakpoint. for example, if the human breakpoint is deduced from a cluster ci+ and the viral segment contains reverse strand reads, the 5’ most position of the viral segment is closest to the breakpoint . if the viral reads are from the +ve strand, the 3’ most position of the viral cluster is the closest to the breakpoint . if there are reads spanning across a breakpoint as shown in fig. 5
c, the exact breakpoint can be found.
fig.  <dig> algorithm showing how the breakpoints are found for ci+ clusters




the clusters generated in the clustering step contain numerous random clusters. we need to filter them out. for each cluster ci+, its median rank is defined as the median of the ranks of lja for all ∈ci+. . the median rank for ci− is similarly defined. we only retain clusters with a median rank of  <dig> 

refining the breakpoints
the predicted breakpoint of each cluster might not be accurate due to a noisy mapping affecting the calculation of the end points of vi+ clusters and vi− clusters. it is possible that virus integrations in different cells are different, but are close to each other. if the final clusters contain split reads, we can use them to refine the predicted breakpoints under such circumstances.

the split reads can predict the integration sites to a high degree of accuracy. however, blast may align split reads to the virus and human genome off by several bases. from all the split reads, we find the human and viral alignments and take their median value m to be the exact breakpoint. we report this median as the actual break point if one of the read clusters contain at least ε split reads more than the other . note that in some cases read clusters may not have a median rank  <dig> when there are many reads mapping to different locations with the same expect values. in such cases or when split reads are not present, breakpoints can be estimated by local assembly. first, we identify aligned reads  and  in a cluster such that r
a and r
b overlap by at least  <dig> bp with similarity >75%. next, we pile-up all these read pairs to generate their consensus sequence. these consensus sequences are mapped to the reference genome with blast. if there exists an alignment with a unique smallest expect value, the unaligned portion of this consensus sequence is mapped to the virus database using blast. if there is a hit, the integration is reported. if there are multiple hits to the human genome with the same expect value, multiple breakpoints are predicted and these breakpoints are marked as ambiguous breakpoints.

RESULTS
this section studies the performance of batvi, virusfinder  <cit>  and virusseq  <cit> . viralfusionseq  <cit>  is not included in the comparison since it cannot finish running within two weeks in our experiments. the details of the simulation and real-data experiments are given below.

generation of simulated data
using the simulator program in virusfusionseq  <cit> , an infected genome is simulated where chromosomes 1– <dig> are infected by four different hbv strains. then, all integrated viral regions, along with their two  <dig> bp flanking human regions were extracted. next, using the default parameters of the mason simulator  <cit> , a 20x coverage dataset of these extracted regions were generated. altogether,  <dig> integration sites were generated in this simulation.

from the simulated dataset, we downsampled it and created two additional simulated datasets that contain 50% and 25% of the original reads.

integration detection in simulated data
this section compares the performance of batvi, virusfinder  <dig>  <cit>  and virusseq  <cit>  on the simulated datasets generated in the previous section. in this comparison, a prediction was considered to be correct if it was within  <dig> bases from the simulated breakpoints of some simulated viral integration and with the correct orientation. virusfinder  <dig> reports two types of integrations designated as high-confident and low-confident. to increase its sensitivity, we pool these two types of integrations together.
fig.  <dig> the change of false positives and true positives with the number of reads used to predict an integration with batvi. the x-axis is log-scaled. the plots for the comparisons except batvi are shown as straight lines for clarity, but they are in fact points with x values not exceeding 0




without downsampling, virusfinder  <dig> and virusseq identify 32% and 35% of the true integrations with about 1% and  <dig> % false positives respectively. for batvi, if we take the viral integrations supported by at least one read, batvi identifies 85% of the true positives, with 28% false positives. however, if we select a more stringent cutoff for batvi by increasing the number of reads supporting the predictions, the false positive rate rapidly goes down . batvi can predict more than twice true positives compared to other programs under 1% false positive rate.

in addition, as the sequencing depth is reduced, the number of predictions by the other programs decrease very rapidly. for virusfinder  <dig>  42% and 84% of predictions are lost at 50% and 25% sampling rates respectively. for virusseq, 60% and 95% of the predictions are lost at 50% and 25% sampling rates respectively. however, batvi is more robust. if we take the number of predictions with read count cutoff chosen so that the false positive rate is kept at less than 1%, batvi loses only 7% and 38% of the integrations at 50% and 25% sampling rates respectively.

next, we study the distance between the actual breakpoints and the predicted breakpoints. figure  <dig> shows the result. the predictions by batvi and virusfinder  <dig> are very close to the actual breakpoint most of the time. however, more than half of the breakpoints reported by virusseq can be as far as  <dig> bp away from the actual breakpoints.
fig.  <dig> the graph shows the distribution of the distance between the exact breakpoint and the predicted breakpoint for different programs




performance on real data
this section compares the performance of batvi, virusfinder and virusseq using real datasets. we ran the tests in the high-performance cluster at genome institute of singapore, allocating 32gb of memory and ten threads with a time limit set at  <dig> days.

in  <cit> , virusfinder  <dig> <cit>  and virusseq  <cit>  were compared using two wgs libraries 198t and 268t from  <cit> . in the first experiment, we run batvi on these two datasets. batvi finished the virus integration calling in several hours. virusfinder took one week to process the library 268t and it crashed on the library 198t. virusseq did not finish even after two weeks. in fact,  <cit>  also failed to process 198t and 268t using virusseq within the allowed time.
table  <dig> comparison of integrations reported by batvi, virusfinder  <dig> and the original paper for the libraries 268t and 198t




the second experiment studies the performance of virusfinder  <dig>  <cit> , virusseq  <cit>  and batvi on  <dig> samples in  <cit>  that have viral integrations reported by hivid  <cit> . . since virusfinder  <dig> and virusseq were slow to run, we downsampled the selected libraries and tested the performance of different methods on them.

each selected sample has two libraries: the first library contained reads having an insert size of  <dig> bp while the other library contained reads having an insert size of  <dig> bp. we downsampled them as follows. first, we align these reads on the human genome using bwa  <cit> . paired-end reads having soft-clips or with at least one side unmapped were extracted. these paired-end read are more likely to be originated from viruses or their integrations in the human genome. in addition to these paired-end reads, one million random paired-end reads were extracted from each library. in total,  <dig> datasets are obtained . then each dataset was processed using batvi, virusfinder  <dig> and virusseq. for batvi, we report integrations supported by at least four paired-end reads. for the  <dig> bp and  <dig> bp datasets, two integrations were considered to be the same if they are within  <dig> bp and  <dig> bp away from each other respectively.
the libraries are sub-samplings of real life data. the libraries with suffix  <dig> have an average insert size of  <dig> bp while those with the suffix  <dig> have an average insert size of  <dig> bp



fig.  <dig> the venn diagrams for the hbv integrations reported by batvi, virusfinder  <dig>  virusseq and hivid. a is the venn diagram for  <dig> samples with insert size  <dig> bp. b is the venn diagram for the same  <dig> samples with insert size  <dig> bp





reanalysis of data from sung et. al.
we ran batvi on all  <dig> samples of liver cancer data from  <cit> . the original analysis reported  <dig> integration sites and our new analysis revealed  <dig> integrations supported by more than one read. batvi detects  <dig> of the original breakpoints . to get a better idea about the predictions, we compared the predictions for hivid, batvi and the original analysis in the samples where hivid validation is available. out of the  <dig> hivid predictions, original analysis found  <dig>  hivid validated integrations while batvi found  <dig>  hivid validated integrations. this shows that batvi is more sensitive in detecting these confident integrations.

the original analysis  <cit>  identified  <dig> out of  <dig> samples containing recurrent hbv integrations with tert, mll <dig> and ccne <dig> oncogenes. batvi was able to identify recurrent hbv integrations in all these samples. furthermore, it identified  <dig> more samples with hbv-tert integration and an extra sample with the hbv-mll <dig> integration. we know that hbv integration will up-regulate the expression of tert and mll <dig>  when we analyze the gene expression data for these  <dig> extra samples, we see that tert and mll <dig> expressions are higher in tumor samples compared to the normal samples, relative to the samples where no such integration were found . this shows that the additional hbv integrations predicted by batvi are likely to be real. our analysis indicates that the original study gave  <dig> false negatives . note that this difference may have clinically significant consequences since the false negatives may lead to incorrect treatment for the patients.
fig.  <dig> the violin plots on the left and on the right show the tumor/normal expression ratios of tert and mll <dig>  respectively. for each plot, the  <dig> samples are partitioned into three violin plots. the second violin plot  corresponds to the original samples where the hbv integrations were detected. the first violin plot  corresponds to the extra samples where the hbv integrations were detected. the third violin plot  corresponds to the samples with no hbv integration detected




speed comparison
this section performs the efficiency comparison of virusfinder  <dig>  virusseq and batvi. for the speed comparison, we used the  <dig> downsampled datasets as stated in table  <dig>  table  <dig> reports the real times taken by each program in seconds.

the table shows that the speeds of the programs differ by at least an order of magnitude in general. virusseq is very slow compared to the other programs. it will be challenging to perform viral integration studied on large datasets using virusseq. virusfinder  <dig> is more efficient but it is clearly much slower than batvi. in practice, we observe that finding viral integrations with batvi can be more efficient than aligning the reads to a human genome using bwa  <cit> .

discussion
batvi uses two criteria for judging the quality of a viral integration: the rank and the number of reads in a cluster. rank  <dig> clusters of batvi are the unambiguous viral integrations. currently, batvi only reports rank  <dig> clusters. for the remaining clusters, they might fall on repeat regions and we currently store them separately. users can inspect these remaining clusters if they want.

for read count, a cluster with a higher read count has higher confident. however, we do not impose a cutoff on reporting integrations based on the read count. the reason is that the read count depends on the depth of sequencing and the frequency of cells with integrations. therefore, the correct cutoff for the read count depends on the experimental setting. the user can adjust the cutoff based on their knowledge on the datasets.

CONCLUSIONS
discovering viral integrations using ngs data has become important especially for disease samples that have strong association with viral infections. however our experiments show that existing methods are slow and are not sensitive enough. we developed an algorithm batvi, and show that it is much faster than existing programs while being more sensitive. also, it does not show any bias towards the insert size of the libraries in contrast to the other methods compared. we believe that batvi will be a useful tool for studying viral integrations in future.

from the fifteenth asia pacific bioinformatics conference shenzhen, china. 16– <dig> january 2017

ct would like to acknowledge the support of the college of information technology, uaeu.

funding
this research and its publication costs were supported by genome institute of singapore, a*star.

availability of data and materials
the ngs data used in this study is publicly available in sra under the accession erp <dig> 

authors’ contributions
ct and wks contributed in developing the algorithms, designing the experiments and writing the manuscript. ct implemented the program and performed the experiments. both authors read and approved the final manuscript.

competing interests
the authors declare that they have no competing interests.

consent for publication
not applicable.

ethics approval and consent to participate
not applicable.

about this supplement
this article has been published as part of bmc bioinformatics volume  <dig> supplement  <dig>   <dig>  selected articles from the 15th asia pacific bioinformatics conference : bioinformatics. the full contents of the supplement are available online https://bmcbioinformatics.biomedcentral.com/articles/supplements/volume-18-supplement- <dig> 
