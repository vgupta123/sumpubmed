BACKGROUND
tilling   <cit>  is a reverse genetics approach to detect effects of globally induced mutations in a population and identify the individuals that have mutations in genes of interest. as long as the dna sequence of the target gene is known and the organism of interest can be mutagenized, tilling provides mutations in species where tools applicable to other model systems are unavailable. importantly, organisms amenable to tilling include both commercially valuable species such as rice  <cit> , wheat  <cit> , soybean  <cit> , brassica  <cit> , oat  <cit> , and melon  <cit> , and species important for research such as medaka  <cit> , zebra fish  <cit> , fruit flies  <cit> , arabidopsis  <cit>  and nematodes  <cit> .

furthermore, tilling produces allelic series of decreasing function allowing functional characterization of genes whose knock-outs are lethal  <cit> .

the tilling approach is based on the ability to detect rare mutations in large populations and thus requires the use of methods that can detect a mutant allele in a pool where it is diluted by many wild-type alleles  <cit> . previously, tilling identified mutations in 8-fold pools of mutagenized individuals by detecting mismatches between annealed wild-type and mutant dna strands. subsequent to identification of a positive pool, all members of the pool were tested to identify the mutant individual. tilling -by -sequencing  <cit>  leverages the illumina sequencing platform and an overlapping pooled experimental design. it follows up the mutagenesis with deep sequencing of pools of individuals or populations of interest. because of the high throughput of current sequencing technologies, deep sequencing to hundred and thousand fold coverage is possible  <cit> . this, in theory, should allow identification of rare mutations present at very low frequency in a sample, such as when a single heterozygous individual is present in a pool of  <dig> . discovery, however, requires resolving true signal from sequencing noise. to identify both the mutations and individuals that carry them at high resolution, overlapping pools of individuals are used. tilling-by-sequencing uses a practical and effective overlapping pools design, where pools of individuals overlap in their dna content in such a way that each individual's dna is present in exactly  <dig> pools. we call this setup bi-dimensional pooling, and illustrate it in figure  <dig>  this design is readily extensible to multi-dimensional pooling, where each individual's dna is present in  <dig> or more pools  <cit> . the general computational problem which arises from tilling-by-sequencing is: given a stretch of dna from a reference genome and a set of deep sequenced, bi-dimensionally overlapping pools, identify the positions with mutations along the dna and their individual carriers, or, equivalently, the position and the row- and column-pool for each mutation. any solution to this problem would focus on identifying significant differences between the reference genome and the sequenced dna. the problem is complicated by sequencing noise , the inter-dependency of pools of the experimental setup, the infrequency of mutations' occurrences with respect to the size of the population under study, and also by variability, or non-uniformity in the sequencing coverage, which is not uncommon for 2nd generation sequencing technologies  <cit> .

for example, in a bi-dimensionally pooled experimental design, a mutation in a single individual is expected to cause a higher base change frequency in one row and one column pool, and many mutations can be recognized in this way, by visual detection of outliers. in figure  <dig> we show the base change frequency for each pool at three positions with confirmed mutations from mutagenized wheat and rice. from left to right, there is apparent increased difficulty in identifying a mutation. the accuracy of calls made by visual inspection depends on the sequencing coverage, or number of nucleotide calls per position per pool. given a fixed probability of base change due to error , at high coverage levels pools with real mutations will usually stand out clearly from the noise. as coverage drops however, in the absence of a real mutation a larger range of base change frequencies may reasonably occur by chance thus increasing the number of false positives. the visual approach cannot distinguish these cases because it does not take coverage levels into account, so a single gene that has low coverage on a few libraries can cause a high overall false positive rate.

here we propose a new method, coverage aware mutation calling using bayesian analysis, camba,  which directly considers the pooled setup and sequencing coverage levels when calculating mutation and noise probabilities. using data from two tilling experiments, one with lower sequencing coverage variablility and data quality and the other with higher, we validate camba's efficacy in identifying mutations, and demonstrate that it does at least as well as other mutation calling methods, and that it outperforms significantly the other methods on sequence data of lower quality and higher variance in coverage across pools.

related work
several methods exist for identifying mutations in pooled experiments. rigola et al.  <cit>  use a poisson distribution based outlier approach to identify mutations and natural variations in individuals using bi-and three-dimensional pooling schemes coupled with high-throughput sequencing. shental et al.  <cit>  apply compressed sensing to create a variant detection technique, comseq, which can handle computationally optimal pooling schemes. unlike the poisson outlier method, camba considers the experiment setup and models configurations that could have yielded the observed data. camba uses sequencing coverage and bi-dimensional pool overlap as model features, whereas comseq uses only base change information, and a more general pooling approach. we compare the performance of these two methods to that of camba in the results section.

a variety of approaches exist for calling snps from non-overlapping pooled samples, e.g. varscan  <cit> , crisp  <cit> , snpseeker  <cit> , the maq alignment tool  <cit> , and others; and non-pooled samples, e.g. polybayes  <cit> , polyscan  <cit> , the method by stephens et al.  <cit> , and others. our approach, camba, is specifically geared to working on pooled experiments with overlap between the dna pools, i.e. dna from the same individual is present in two pools. that is not the case for these other approaches, so we could not compare them directly to camba. moreover, these other approaches identify mutations but not the individuals in the populations that carry them. we modified varscan and crisp, the best performing ones from a previous study  <cit> , in order to compare them to camba and report those studies in the results section.

overlapping pool designs for high-throughput resequencing have been recently proposed by prabhu and pe'er  <cit> , where they focus on optimizing overlaps to increase design efficiency , lower necessary sequencing coverage, decrease false positives and false negatives, and identify mutation carriers with lower ambiguity. they do not provide software for testing their designs and it is not immediately clear that their designs could easily fit into standard wet lab protocols . our overlapping pooling scheme can be evaluated in their theoretical framework, and in terms of the "code efficiency" it is 50% worse than the theoretically optimal binary design .

methods
in a bi-dimensional pooling setup we have nw wells, iwell individuals pooled per well, il individuals in library l, reference base r at the current position, the probabilities pc and pnc with which a mutagen will induce a specific canonical  or non-canonical base change at a given position in a single individual, and the fraction of induced mutations tz for each zygosity z.

the input data, d, is comprised of a set, l, of row and column libraries of short reads, corresponding to the pools of sequences of interest. the reads for each library are aligned to their reference sequences  alignment tool  <cit> ), associating each position in each sequence with a set of nucleotide calls: either the reference nucleotide base, r or a base change r → m, m ≠ r. in the alignment, or pileup, of reads, for each position we count the total number of reads, i.e. coverage, in a given library, denoted by nl, and separately the number of reads that have base b at that position in that library, klb .

to find the carriers and the mutations, given the data, d, and the experimental setup, for each sequence position we model the posterior probabilities of each possible mutation in each well. we assume that at most one individual will have a mutation at any given sequence position.  <dig> thus, at most one well can have a mutation, and that mutation will be for one specific base change. we denote these possibilities, or configurations, as cw, m, where w is the well, and m is the base change from reference . the probabilities corresponding to the configurations are p. we call a mutation at a given position if the probability of at least one mutant configuration cw, m exceeds a predefined threshold indicating that well w contains an individual with base change m at the current position. if more than one cw, m pass the threshold, then the one with highest probability is chosen. the threshold is determined based on the expected number of mutations in an experiment, as described in the methods section.

in the following we calculate the probabilities p. since the experimental procedure makes the expected number of heterozygous mutations equal to twice the number of homozygous mutations, we further distinguish configurations by zygosity, and use cw, m, z to model heterozygous, z = het, and homozygous, z = hom, mutations separately, and p = p + p.

we compute the posterior probability p of a given configuration, using bayes' theorem:  

where c is the set of all possible configurations cw, m, z at the given position. since we exclude all configurations with more than one mutant individual for the current position, the sum of the prior probabilities p do not add up to  <dig>  but normalizing does not affect the result. thus all we need to calculate are the terms in the numerator.

to compute p we need to accurately determine the position-specific sequencing error rate for different base changes. given configuration c, we can estimate the rate at which the reference base r is read as m, rr→m, for a given position, as  

where lc is the set of libraries that do not contain a mutation m at the given position, for the given c.

now, to calculate the base change frequencies expected from a real mutation, we compute mlc, the fraction of mutant alleles in library l under configuration c, from the number of individuals il in library l and the zygosity z of the candidate mutation.

given the sequencing error rates and mutation allele frequencies, we can now compute rlmc, the expected rate of reading a given base change m at the current position in a given library l, for configuration cw, m, z: rlmc = rr→m, c + mlc.

to this, we apply the binomial distribution to estimate the conditional probability of observing klm reads having base m at a given position, given nl coverage for that library and configuration cw, m, z.  

finally, assuming that all base change counts are independent, we have  

to compute p we start from our assumption that at most one well can contain a mutation at any given position. the prior probability of the presence of a particular base substitution r → m at the current position in exactly i out of the iwell individuals in a given well can be estimated as:  

where b is the binomial distribution, i.e. the probability of having i successes out of iwell trials given an individual success probability of pc.

a given well has prior probability ptm = p1m of being a mutant well for base change m and pfm = p0m of being a non-mutant well for base change m. the prior probability of a given configuration cw, m, z is the product of the prior probabilities of each well w with respect to each possible base change for the given position, multiplied by the fraction of induced mutations with the given zygosity, if applicable. converting this description to a formula gives us , where m, m', and m" are the three possible base changes at the given position. note that these probabilities are the same for all wells .

pre-processing
for each library, we compute a low-quality cutoff for base calls to be one standard deviation below the mean quality of the reference base calls. we do not search for candidate mutations at a position if the expected value of the total coverage there over all but two libraries is less than  <dig>  , to avoid inaccurate estimates of rr→m.

the orientation bias of a specific base is the ratio of reads mapping onto the forward strand to those mapping onto the reverse strand of the sequence. if the reference base orientation bias for a given library at the current position is different from the orientation bias of base change m with pvalue < <dig> , then we set p =  <dig> to exclude each configuration c for which a well represented in that library is a mutant well for base change m. we also set p =  <dig> for these configurations if the reference base orientation bias for the given library is greater than  <dig> or less than  <dig> , since a strong reference base orientation bias can make it difficult to detect a significant difference between the orientation biases of the reference base and a given base change. in addition, if a given library has more base reads for the candidate base change than for the reference base at the current position, then we set p =  <dig> for each configuration where a well in that library is a mutant well for any base change.

number of predictions
we construct our initial estimate of the number of real mutations in a given experiment by adding up the probabilities of each possible induced base change at each position across all tilling sequences in all individuals, where the probability of a given canonical or non-canonical base change is determined from cel i screening of an experiment on the same organism using the same mutagen  <cit> , as described in the data section below. by this method, we estimate  <dig> real mutations in rice and  <dig> real mutations in wheat. since cel i has a significant false negative rate, we correct our initial estimate using additional validation information from the wheat experiment. when an older version of our approach was run on the wheat experiment,  <dig> of the  <dig> predictions ranked  <dig> to  <dig> were tested and all  <dig> were confirmed. we drop below this ranking to give the semi-conservative estimate of  <dig> real mutations. we divide  <dig> by  <dig> to get a candidate scaling factor of  <dig> . we predict the number of real mutations for a given experiment to be  <dig>  times our initial estimate of the number of real mutations from cel i screening. the predicted number of mutations is  <dig>  by definition, for wheat, and it is  <dig> for rice. this determines our threshold.

the above approach for determining the appropriate threshold yields very good bounds for our data and can be applied whenever previous cel i screening experiments have been done. in the absence of such prior experiments, one can apply the following method, although the results may include higher false positive rates. the false positive rate at a given number of predictions can be estimated by running camba using as input a scaled down bi-dimensional arrangement using only the row pools. e.g., the row pools in the new scheme could be half of the actual row pools, and the new column pools could be the other half of the original row pools. since we expect few or no instances where the same mutation occurs in two independent row libraries, the number of row/row calls serves as an upper bound on the number of false positives among the row/column candidates. similarly, we could scale down the original arrangement using the original column pools instead of the row pools. we scale up by the ratio of the number of row/column pools versus the number of row/row pools, and choose the largest number of candidates for which the estimated false positive rate is nearest to our goal threshold. as an illustration of this method, we split the wheat data set  <dig> column pools into two groups of  <dig> pools each, and ran camba on this new bi-dimensional pooled data of  <dig> rows and  <dig> columns. at a false positive rate of  <dig> , this method yields a threshold for camba of  <dig> mutations.

we note that although camba yields posterior probabilities for each of thousands or tens of thousands of positions, we never use hypothesis testing to determine the threshold in either of the two approaches above, and thus we need not correct for multiple hypothesis testing.

due to the apparent bimodality of the calculated posterior probabilities, and their clustering around the values of  <dig> and  <dig>  we apply the following function to transform t, the posterior probabilities returned by camba:  

f is effectively the log posterior probability. for both the rice and wheat tilling-by-sequencing experiment, the predictions of camba and the other methods are compared against the corresponding set of confirmed mutations.

RESULTS
using data from two tilling-by-sequencing experiments we analyze the performance of camba and compare it to those of other approaches. we investigate the effect of sequencing quality, sequencing coverage variability, and the overlapping pool design on the fidelity of our and the other methods in resolving mutations from the data.

two tilling experiments
the tilling-by-sequencing setup in one of our labs  uses the mutagen ethyl methanesulphonate  or the combination of sodium azide and methyl-nitrosourea  to induce mutations in a population of 1500- <dig> individuals. m <dig>  the selfed product of mutagen-treated individuals, are inventoried as dna. the mutations in this material will be heterozygous in 2/ <dig> of the cases and homozygous in the rest. units of  <dig> individuals arrayed in a  <dig> well-plate,  <dig> individuals per well, are then screened. the row and column samples are pooled to yield  <dig> row- and  <dig> column-pools , as in figure  <dig> 

dna from each of the  <dig> pools is pcr-amplified with primers designed to amplify 1- <dig>  kb dna segments from up to  <dig> genes of interest, and subsequently sequenced using illumina genetic analyzer apparati. the reads are then mapped onto reference genomes.

using this setup a total of  <dig> rice genes  and  <dig> wheat genes  of interest were sequenced using illumina ga machines to look for mutations in a population of  <dig> individuals. the reads on the average were of length  <dig> bp for the rice and  <dig> bp for the wheat data. there was a significant difference in the read quality between the two: the rice sequence had an average phred quality score of  <dig> and the wheat of  <dig>  there was also a larger variance in coverage between individual libraries in the rice data set than in the wheat data set. also, on average, the coverage was  <dig> × per individual in rice and  <dig> × in wheat. the differences in quality, coverage, etc. between these two data sets make them very good case studies for our method. the tilling-by-sequencing experimental methodology and these two data sets are described in full elsewhere  <cit>  .

using prior tilling experiments we determine the probabilities of a canonical mutation, pc, non-canonical mutation, pnc. we assume position independent values for pc and pnc, as indicated by prior experiments  <cit> . we estimate pc and pnc from ic and inc, the induced mutation rates for canonical and non-canonical mutations, and ptil, the fraction of tilling reference sequences with base b, for each b : pc = ic/ptilg, c and pnc = inc/pnc . we compute ic and inc using previously described methods  <cit> . thus, we get for rice, pc =  <dig>  × 10- <dig> and pnc =  <dig>  ×  <dig> - <dig>  and for wheat, pc =  <dig>  × 10- <dig> and pnc =  <dig>  the fraction of heterozygous mutations is thet = 2/ <dig>  and homozygous mutations is thom = 1/ <dig> 

to evaluate the performance of the mutation calling algorithms, we used two sets of mutations, one set for wheat and one for rice, which have been previously confirmed using an independent method   <cit> . in total we had  <dig> confirmed mutations from the wheat experiment and  <dig> from the rice experiment.  <dig> we note that the confirmed mutations are a fraction of the total expected mutations in these data sets. ideally, all predicted mutations should be tested, but practical resource constraints dictate limits on the validation.

validation of camba's performance
we ran camba on each of the two data sets, tilling on rice and tilling on wheat, for a number of different mutation prediction thresholds, including the recommended one  and a few others above it and below it. for each threshold, we noted the number of predicted mutations , the corresponding value for f, the number of predicted mutations that overlap with the confirmed ones  , and the number of false positives , false negatives , and the sensitivity  and specificity  at that threshold. the results are given in table  <dig> the last four columns were calculated by estimating the false positive and false negative rates from the overlap and the expected mutations,  <dig> in wheat and  <dig> in rice, and the total sequenced dna positions,  <dig> bp in rice,  <dig> bp in wheat. we assume that the confirmed mutations have been randomly chosen from the set of all mutations, thus, we scale the true positives by 107/ <dig>  with the restriction that the number of false positives must be at least  <dig>  at the recommended thresholds, in wheat this gives tp =  <dig>  fp =  <dig>  and fn =  <dig>  for a false negative rate of  <dig>  × 10- <dig> i.e. sensitivity of  <dig> %, and a false positive rate of  <dig> × 10- <dig> i.e. specificity of  <dig> %. similarly, in rice, camba has sensitivity of  <dig> % and specificity of  <dig> %. the good performance of camba is evident around the recommended thresholds.

performance of camba at various thresholds on the rice  and wheat data sets. f = camba threshold, pred = # predicted mutations at that threshold, conf = # of the predicted mutations which overlap with the confirmed mutations , fp = # false positives, fn = # false negatives, sens = sensitivity, spec = specificity. we underscore the line associated with the recommended number of predictions for both rice and wheat. we restrict our estimate of the number of false positives to be at least  <dig> 

it is notable that in rice, camba predicted correctly  <dig> out of the  <dig> confirmed mutations at those thresholds. this is strong evidence that given lower quality data camba can utilize the overlapping pools experimental setup to its advantage better than the other methods could. even the much lower read data quality of the rice data  does not seem to affect camba's performance.

at the recommended threshold of  <dig> mutations in wheat, camba predicted correctly  <dig> out of the  <dig> confirmed mutations. looking closer in the sequence data for the  <dig> false negatives, we found out that one of them is due to strand-specific bias which resulted in wrong frequencies of base changes, and another was due to under-sequencing; the third showed up in the table at a much higher threshold.

methods for comparison
we compare the performance of camba to those of a number of methods, which we describe next. not all of the other methods predict both the mutated positions and the individual carriers. those that do not were either run separately on individual libraries or only predict the mutation positions. hence, either they or camba have been modified to allow for the comparison. in each case we specify the modification undertaken.

we devised the outlier method as a naive competitor to camba. it is inspired by simple visual identification of a row and column library pair that stand out from the rest in terms of the frequency of a given base change, and uses the same preprocessing techniques as camba. when considering a given position in a tilling sequence, if at least one well has a score greater than a fixed threshold t on some base change, then we predict a mutation for the base change and well combination with the highest score. for a given well w and base change m, we find the z-score of the r → m base change frequency for both the associated row and column library with respect to the distribution of the r → m base change frequencies for the remaining libraries, and we set the score of well w on base change m to be the lower of these two z-scores. we add  <dig>  to the sample standard deviation to avoid division by zero.

the poisson outlier method is described in a tilling-by-sequencing pipeline by rigola et al.  <cit> . this method consider only g to a and c to t base changes for the purposes of mutation detection. since mnu can induce any type of base change in rice, we modified the poisson outlier method to search for all possible base changes when detecting mutations in rice. rather than following the procedure for detecting natural variation, which considers all base changes as a whole, we tested for each base change individually, to reflect the assumption that an individual will have at most one mutation at a given position.

varscan is a snp identification method in individual or pools of massively parallel sequence data by koboldt et al  <cit> . it identifies variants based on read counts, base quality, and allele frequency. varscan does not take into account overlap in pools and it does not identify the individuals carrying the mutations. to compare it to camba in a bi-dimensional setting, we ran varscan separately on each row pool and column pool. we then took the intersection of the row and column calls.

crisp  <cit>  is a statistical method for variant detection in pooled dna samples, shown to dominate a number of other methods in a direct comparison of snp detection ability  <cit> . while similar to camba at the modeling level, we note that camba was developed independently and was used in our labs for more than  <dig> months before crisp was published. additionally, pool overlap is inherent to camba's model, while crisp does not utilize overlapping pools. also, in contrast to the other competing methods that we consider, crisp does not identify the mutation carriers. thus, in the comparisons, we considered only the position and base change of each candidate returned by crisp, while requiring the other methods to also predict the correct carrier. this decision allows a more fair comparison between camba and the other methods, though giving crisp a slight advantage. as with the others, we only include results for crisp on its default parameters.

comseq  <cit>  is a computational technique that identifies infrequent variants in complex pools. in contrast to camba and the poisson method  <cit> , comseq allows for the use of computationally optimal pooling schemes  <cit> . given the particular individuals contained within each pool and the observed frequency of a particular base change in each pool, comseq applies the theory of compressed sensing to infer which individuals have that base change. comseq does not appear to be designed to handle experiments with multiple individuals per well, so to simulate the presence of one individual per well, we multiplied the base change frequencies in each library by the number of individuals per well, resulting in increased sensitivity on both the rice and wheat data sets. comseq has no user parameters to vary and does not rank its predictions.

we also attempted comparisons with maq  <cit>  but we could not get any mutation predictions on our data sets with their default settings.

comparison to other methods
we ran camba versus the mentioned competing methods on their default settings, using our set of confirmed mutations and our prediction of the total number of real mutations to estimate the specificity and sensitivity of each method.

to ensure a fair comparison with camba, we post-process all competing methods to return at most one mutation per position, selecting the best scoring candidate mutation for that position, where applicable. varscan  and comseq can return multiple candidates at a given position that cannot be distinguished by score, so in order to give them the best possible advantage, when one of their multiple predictions is a confirmed mutation, we allow them to always predict that confirmed mutation.

in the wheat data set, we adjusted the competing methods to only consider the possibility of ems canonical mutations, reflecting known information that is used in camba. this filtering is accomplished by never considering ems non-canonical base changes in the poisson and outlier methods, which we implemented by hand, and by post-processing the results of the other competing methods.

in table  <dig> we show the number of predictions of each method when run on its default parameters, the overlap between those predictions and the confirmed set of mutation candidates, the false positives, false negatives, sensitivity, and specificity. the last four columns were calculated by estimating the false positive and false negative rates from the overlap and the expected mutations, as illustrated above.

performance comparison of camba to other methods using default parameters, on the rice  and the wheat data sets. the column abbreviations are as in table  <dig>  all methods are evaluated on their ability to predict the carrier of each candidate mutation, except crisp, which cannot make such predictions.

on the rice data set, camba dominates the other methods clearly. crisp and varscan return very few or no predictions on the rice data set, most likely due to the lower sequencing quality. comseq and the poisson method both return a large number of false positives.

on the wheat data set, we see greater overlap between the predictions of camba and the other methods. this is consistent with the fact that the wheat data set is of higher quality, and thus mutations are easier  <dig> to identify.

coverage variability over libraries 
camba shows a small performance advantage over the other methods on the wheat experiment, which has consistently high coverage levels across all libraries and between genes. in contrast, camba has a very clear advantage in the rice experiment, and here we investigate the difference. while we found an explanation that accounts for our observations of the outlier method, the other competing methods do not necessarily conform to the same rule.

in figure  <dig> we show the coverage variance across libraries for all genes in both experiments, wheat in gray, and rice in black. it is apparent that the black lines are overall higher on the plot than the gray lines, especially the line for gene hlp <dig>  to test the hypothesis that insensitivity to sequencing coverage variability gives camba an advantage over the other methods, we performed two computational studies. in the first one, we modify the rice data set to exclude the tilling sequences for gene hlp <dig> which has both the lowest mean coverage and the highest coverage variability across libraries in this experiment. on this modified data set, the outlier method performs as well as camba, although the other competing methods do not significantly improve their performance, as shown in table  <dig> 

performance comparison of camba to other methods using default parameters, on the wheat data set after artificially increasing the coverage variance. the column abbreviations are as in table  <dig>  all methods are evaluated on their ability to predict the carrier of each candidate mutation, except crisp, which cannot make such predictions. we were unable to report results for varscan due to technical issues in generating a modified pileup of reads.

in the second study, we gradually increase the coverage level variance across libraries in the wheat experiment by selectively discarding base reads. we set the new coverage level of each library on a given gene to be the coverage ratio of that library to the library with the highest coverage on that gene, raised to the scaling factor s =  <dig>  multiplied by the coverage of the highest coverage library for that gene. to reach the desired coverage level for a given gene on a given library, we discard each base call with fixed probability.

this level of coverage variance is comparable to that of hlp <dig> in figure  <dig>  we propose that the likeliest reason for the advantage we see in camba's performance over the outlier method, as shown in table  <dig> is due to its insensitivity to coverage variability in the data, an effect of both its explicit use of coverage in the model, and the greater signal sensitivity imparted by the overlapping pool design.

performance comparison of camba to other methods using default parameters, on the rice data set, after excluding hlp <dig> to lower the mean coverage variance. the column abbreviations are as in table  <dig>  all methods are evaluated on their ability to predict the carrier of each candidate mutation, except crisp, which cannot make such predictions.

we note that while the rice experiment uses the mutagen mnu and the wheat experiment uses ems, the choice of mutagen does not seem to have a significant effect on either the overall mutagenesis rate or the proportion of canonical versus non-canonical mutations  <cit> .

attributing performance advantage to model features
coverage variability does not fully explain camba's performance, as its advantage is evident on both the rice and wheat data . the poor quality of the rice sequencing data is likely the reason that varscan and crisp return so few predictions on that data set. other methods did not perform as well as camba on either data set. here we discuss a number of strategies and assumptions whose presence or absence in the various competing methods could account for the observed performance advantage of camba.

camba's advantage compared to competing methods is attributable to the combination of its comprehensive modeling of the data variability over all libraries, effective use of the pooled design, and its ability to simultaneously consider all candidate configurations with and without mutations in order to determine the best one. while each of the comparison methods have some of these properties, none has all three together.

not explicitly considering coverage levels and instead relying directly on base change frequencies , results in decreased performance relative to camba on data sets with increased coverage variance. by contrast, the poisson method, varscan, crisp, and camba all consider coverage directly. camba, outlier, and poisson are the only methods that were designed specifically for a multi-dimensional gridded pooling scheme. varscan is run on individual libraries, crisp is designed to run on one dimension, and comseq was designed with the flexibility that it may be run on a computationally optimal pooling scheme. only camba and comseq simultaneously consider a set of models of different possible mutant configurations and the model of the configuration in which there is no mutation and then use base change information across all libraries to choose the best model. in contrast, the poisson and outlier methods simply test for rejection of the null hypothesis of a configuration with no mutation. interestingly, crisp takes into consideration the model of a configuration with no mutation and models of mutant configurations, but it individually tests for rejection of the null hypothesis, rather than using an integrated approach to determine the best configuration.

CONCLUSIONS
we demonstrated that our probabilistic method, which explicitly takes into account the bi-dimensional, overlapping pools experimental setup, and sequence coverage at each position for each library, can effectively discover rare mutations in large populations, as well as the individuals that carry them. it also has a performance advantage over other methods for detecting mutations from high-throughput sequencing of a tilling population when there is significant coverage variability over libraries or lower quality data. more generally, it follows from our experiments that accounting for sequencing coverage variability can improve mutation detection in overlapping dna pools. it would be interesting to work out the relationship between coverage depth and pool size. likewise, we demonstrated that an overlapping pooling scheme, beyond offering carrier identification, also yields increased sensitivity of mutation detection when the data is less than ideal. this work implies a possible association between the amount of pool overlap  and detection sensitivity, which deserves closer attention, especially for experiments on larger populations.

there are several directions in which our tool can be improved. we can add to our model an explicit account for position dependence of the mutations. also, we can extend the model to allow multiple mutations at any given position . we plan to continue using and improving camba in our tilling-by-sequencing experiments. as other technological issues like higher throughput and sequence tagging get introduced into our pipeline, the issues of coverage sufficiency and higher multi-dimensional tilling will be addressed.

we note that properly accounting for coverage variability may improve results in other genomics problems benefiting from 2nd generation sequencing, like sequence mapping, genome assembly, and motif finding.

competing interests
the authors declare that they have no competing interests.

authors' contributions
the tilling-by-sequencing technology was developed by lc. vm, lc, and vf conceived the computational framework, vm and vf designed the studies. vm developed the software and ran the experiments. vm and vf wrote the paper, lc helped in editing. all authors read and approved the final manuscript.

endnotes
1this is supported by evidence from a previous tilling experiment in tetraploid wheat using the mutagen ems, where slade et al.  <cit>  identified  <dig> positions for which at least one of the  <dig> individuals contained a mutation but only  <dig> for which there was a mutation in two individuals. in rice, which has a significantly lower expected mutagenesis rate at each possible reference base  <cit> , we expect an even smaller percentage of the positions for which there is a mutation in one individual to have a mutation in more than one individual.

2these sets of confirmed mutations come from predictions using prior iterations of our approach, and prior experimental approaches, using cel i, on these data sets, all of which were subsequently confirmed with pcr amplification.

