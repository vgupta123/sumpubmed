BACKGROUND
recently, many closely related prokaryotic and eukaryotic genome sequences have been determined, and detailed comparisons of these sequences are providing useful information regarding genomic evolution. to date, many alignment programs  <cit>  and visualization tools  <cit>  have been developed for large-scale genome comparisons. typically, these tools are designed to extract conserved regions for identifying coding or regulatory regions, and they often assumed a simple collinear one-to-one correspondence between the sequences being compared. however, during prokaryotic evolution , crucial events, such as the acquisition or loss of functions that are related to pathogenicity and antibiotic resistance, symbiosis, and adaptation to new environments, are frequently associated with large chromosomal changes, such as insertions, deletions, substitutions, recombinations, and duplications of chromosomal segments, rather than with single nucleotide substitutions  <cit> .

previously, we conducted detailed comparisons of closely related microbial genomes in order to understand the mechanisms that generate such complex chromosomal changes  <cit> . for these studies, we required a visualization tool that provides both global views that show the correspondence between entire genomes and local views that show individual sequence alignments. we noticed that a combination of dotplot display and schematic alignment display is quite effective to understand complex chromosomal changes. in addition, the existence of characteristic structures, such as short tandem repeats, interspersed repetitive sequences, as well as changes in g+c content or codon usage bias provide valuable information regarding the processes that yield the observed genomic changes. although some alignment visualization tools including pipmaker  <cit> , act  <cit> , gata  <cit>  and genomecomp  <cit>  provide views that are suitable for representing large-scale chromosomal changes, they are not adequate for the detailed analysis of complex changes in terms of the above demands.

in this report, we present a comparative genome analysis tool  for comparisons of closely related genomes . cgat adopts a client-server architecture to provide both easy operability and advanced functionality, which is suitable for a collaborative research team that includes biologists who are willing to explore the genome alignment and informaticians who have some computer skills. cgat visualizes precomputed homologous segment pairs between two genomes on both dotplot and alignment viewers. users can explore the alignments on these viewers using scrolling and zooming functions and can compare the locations of several feature segments, such as repetitive structures identified on each genome. the preliminary versions of cgat have been used in our internal research projects and have proved to be powerful in the analysis of apparently complex genome polymorphisms  <cit> .

implementation
cgat employs a client-server architecture, which consists of alignmentviewer  and dataserver . dataserver is a collection of data construction scripts and cgi scripts. alignmentviewer visualizes the alignment data obtained from the server through the http protocol or from the local file system when the server and client are installed on the same machine.

cgat handles two types of data: sequence alignments between two genomes and feature segments identified on each genome. feature segments are represented as the beginning and ending positions of the segments on each genome, and sequence alignments are represented as sets of two homologous segments. basically, any program can be used to collect these data. cgat dataserver contains a set of data construction scripts that offers a general framework for this task. in fact, the data construction process is almost completely automatic. in particular, when the genomic data to be compared are already stored in the mbgd database  <cit> , cgat automatically downloads data from the mbgd server before constructing the required data. alternatively, users can prepare their own genomic data in the genbank or fasta format.

in the following sections, we first describe the data construction protocol implemented in dataserver and then introduce the alignmentviewer program. in this work, we focus on prokaryotic genome comparisons, although in principle the program can also be applied to eukaryotic genome comparisons.

protocol for constructing genomic alignments
the data construction module of cgat dataserver defines its own protocol for calculating genomic alignments . however, it does not contain a program to calculate directly genome-to-genome alignments; instead, it uses various existing programs as alignment engines. by default, cgat uses blast  <cit>  or megablast  <cit>  to calculate alignments, but optionally it can incorporate fasta  <cit> , mummer  <cit> , waba  <cit> , blat  <cit> , blastz  <cit> , patternhunter  <cit> , chaos  <cit> , game  <cit> , and ssaha  <cit> . in this study, we consider local alignment tools rather than global alignment tools, such as lagan  <cit>  and avid  <cit>  because whole genome alignments generally contain rearrangements that are not handled well by global alignment tools.

for the analysis of long sequences, cgat splits one of the genomic sequences into overlapping segments of appropriate length, performs an all-against-all comparison of the split sequences and the other genome, and then merges the resulting alignments that overlap with each other. the length of split sequences is determined for each program individually in consideration of the limitation of the program. although this is a common protocol for calculating genome-scale alignments using traditional alignment programs, such as fasta, it is still useful for aligning very long sequences using more modern programs.

a problem arises when merging overlapping alignments: the overlapping gapped alignments may not be consistent with each other, since they may be suboptimal or alternative optimal solutions. to solve this problem, cgat decomposes a gapped alignment into a set of ungapped segment pairs  and compares the resulting sets of blocks. the sets of blocks should coincide with each other if and only if the overlapping gapped alignments are completely consistent. to resolve inconsistencies among alignments, cgat constructs a directed acyclic graph  that consists of nodes that contain all the endpoints and some internal points of the blocks and edges representing blocks or gaps that connect two nodes in a gapped alignment , and finds a best-score path along the dag using a dynamic programming algorithm.

in addition to solving the above "split and merge" alignment protocol, the overlap resolution procedure is, in some cases, also useful in simplifying the alignment output. for example, the output of promer, a program that is included in the mummer package and that performs translated sequence comparisons, often contains numerous overlapping alignments that correspond to the same alignment in different reading frames. in this type of case, the merging procedure resolves the overlap and simplifies the output.

typically, the graph is sufficiently simple that the problem can be solved very quickly. however, sometimes the graph is very complex, especially when extremely highly repetitive sequences are present. to avoid this problem, the procedure extracts highly repetitive regions from each of the genomes by similarity searching prior to the main analysis , and eliminates the alignments that are covered in large part by these regions . this "repeat masking" is also important in simplifying the output because without this step, highly repetitive matches, the number of which is the square of the number of repetitive sequences in each sequence, would fill almost the entire region of the alignment and dotplot displays. note that the repeat masking is carried out after the genome-to-genome comparison, and does not affect the alignments that are covered in small part by such repetitive regions.

post-processing of genome-to-genome alignments
in cgat, each aligned segment pair is classified into one of four classes according to the best-hit relationships as follows:  orthologous segments;  segments duplicated only in the first genome;  segments duplicated only in the second genome; and  paralogous segments. an orthologous segment pair is operationally defined by a so-called 'bidirectional best hit', i. e. the segment pair having the best similarity score among the homologs of either of the segments. classes  <dig> and  <dig> are defined by unidirectional best hits, i.e., the segment pair having the best score among the homologs of one of the segments. the other segment pairs are classified as paralogous segments.

the actual procedure for identifying the best-hit segment pairs is as follows:  all homologous segments are mapped onto each genome and the best similarity score is assigned to each region; and  an alignment that has a score >90% of the best score over at least 50% of the segment length is extracted as the best-scoring segment pair . if the segment pair is the best-scoring pair for both of the genomes, then the segment pair is the bidirectional best pair.

prior to the above classification process, cgat attempts to create longer alignments by chaining non-overlapping adjacent alignments. this problem is similar to, but not identical to the overlapping resolution problem described above, since in this case only non-overlapping alignments are considered. we considered as being adjacent a pair of alignments in the same direction that are located within  <dig> kb in each of the sequences, and use the simple two-dimensional chain algorithm  <cit>   to find the optimal chain. the sum of the scores calculated by this procedure is assigned to each alignment and is used to identify orthologous segment pairs.

a similar alignment-chaining procedure is implemented in almost every program that performs large-scale alignments so as to make a longer alignment from initially shorter alignments. in contrast to these programs, cgat does not try to create a longer alignment by concatenating the chained alignments. on the contrary, it splits the resulting alignments into smaller pieces in the final step when they contain large gaps , since eliminating large gaps from the alignments enhances presentation in alignmentviewer. nonetheless, alignmentviewer can display these sequences as a contiguous long alignment by calculating alignment on the fly .

collection of feature segments
basically, the output of any dna sequence analysis program that extracts sequence segments can be incorporated into cgat as a feature segment; these analyses include pattern searching, weight matrix analysis, and detecting segments with atypical base composition.

currently, we focus on the analysis of several types of repetitive structures that are frequently associated with the formation of genomic polymorphisms. the following programs are included in cgat dataserver:

1) interspersed highly repetitive regions  analysis. cgat uses a simple strategy to collect this type of repeat, in that it compares each genome to itself using the alignment protocol described above without the post-processing step , maps the resulting alignment onto each genome, and finally extracts the regions that are covered by alignments at least t times. the resulting regions can include various types of segments, such as trnas, insertion sequences  or other mobile elements, and non-mobile repetitive elements, which include bacterial interspersed mosaic elements   <cit> , depending on the cutoff value t. cgat collects regions using multiple t values and displays them with different colors in alignmentviewer. the resulting set of highrep segments is also used for masking repetitive regions in the alignment construction protocol described above.

2) simple repeats  analysis, which examines short tandem repeats with unit sizes of a few bases. it is well known that simplerep frequently yields polymorphisms for both eukaryotes and prokaryotes  <cit> . cgat uses the rep program  to collect this type of repeat. rep uses a simple algorithm that is similar to xnu  <cit> ; it searches high-scoring segment pairs  between the same sequences shifted by m bp relative to each other, to identify repeats with unit of m bp, and outputs them if the number of repeats is at least r. by default, m is changed from  <dig> to  <dig> and s =  <dig> and r =  <dig> using the following scoring system: match + <dig>  mismatch - <dig> 

3) direct or inverted repeats with an intervening sequence  analysis. this type of repeat is important, as it is frequently associated with insertion/deletion/inversion events. cgat uses the kmatch program  to collect this type of repeat. kmatch uses the algorithm derived by leung et al.  <cit>  for hashing k-tuple words to search occurrences of almost identical sequences of at least l bp, while allowing e errors within an interval of up to i; the region is extended until the ratio of error becomes more than r. by default, we made the following settings: l =  <dig>  e =  <dig>  r =  <dig>  and i =  <dig> for dirrep and l =  <dig>  e =  <dig>  r =  <dig> , and i =  <dig> for invrep.

4) searching for known repetitive sequences. this approach, which is employed by the repeatmasker program  <cit> , is probably the most common way of identifying repetitive sequences in eukaryotic genomes. cgat supports this type of analysis using an alignment engine  when users carry a collection of repetitive sequences. for prokaryotic genomes, insertion sequences  are the most common type of repetitive sequence, and the isfinder database  <cit>  represents a well-established collection of is. alternatively, one can use the gib-is database  <cit>  as a downloadable is database.

genes are also considered to be special feature segments, and some attribute values can be assigned for each gene to be colored by alignmentviewer. by default, cgat uses the function categories assigned in the mbgd database  <cit>  for coloring genes, although any program that characterizes gene or protein sequences can be used to assign attribute values. currently, cgat contains a program that calculates the codon usage bias defined by karlin et al.  <cit>  as well as a program that estimates g+c content at the third codon position ; these values are useful for identifying candidates of horizontally transferred genes from distantly-related organisms.

cgat alignmentviewer
the data derived by the procedure described above are integrated and displayed in alignmentviewer . the main window of alignmentviewer consists of an alignment display panel  and a dotplot display panel , in addition to a common control panel . by default, the alignment and dotplot displays show precomputed alignments that are colored according to the four classes of best-hit relationships . optionally, the alignments can be colored according to the percentage identities. the alignment display panel contains three basic tracks: the central track , which shows a graphical representation of the alignments, and the upper and lower tracks , which show the annotation of the upper and lower genomes, respectively. more annotation tracks can be added to display the locations of several feature segments identified on each genome.

users can change the current view on each display by pressing a scrolling or zooming button; these operations update both the alignment and dotplot displays in a coherent manner. using the zooming function of the alignment display, users can change the scale from the entire genome level to the single nucleotide level. the scale of the dotplot display can also be changed independently of the alignment display. furthermore, the scale of each axis can be changed independently; this feature is useful in visualizing the distribution of homologous regions of a specific segment on one genome against the entirety of the other genome .

navigating the alignment space using the scrolling function is one of the key features of cgat. in cgat, the upper and lower sequences are considered as the reference and target sequences, respectively, and navigation is primarily a move along the reference sequence with a step size that depends on the current window size. then the central position on the target sequence is automatically set according to the following rules:  if the next position is still in the current alignment, take the corresponding target position on that alignment;  if the next position is outside the current alignment but in some adjacent alignment, then set this alignment as the current one and take the corresponding target position on that alignment;  if there is no adjacent alignment, then search an orthologous alignment, and if there is an orthologous alignment, then set that alignment as the current one and take the corresponding target position on it; and  if there is no alignment, move the same extent as the reference sequence.

basically, by continuous movement, users can navigate the entire genomes along the orthologous alignments. in addition, users can specify an arbitrary point on the dotplot display to move. in this manner, cgat allows users to navigate easily within the entire alignment space.

in cgat, there are two modes in the alignment display . in the "region-wise alignment mode" , alignments contained in the current region are displayed with a consecutive region specified in each genome. in the "reference-target alignment mode" , every orthologous region of the target sequence is mapped as a fragment onto the reference sequence. the former mode is similar to act  <cit>  and probably represents a more intuitive mode, whereas the latter mode is similar to pipmaker  <cit>  and possibly represents a more informative mode for displaying large rearrangements; however it can show only orthologous matches.

in the region-wise mode, alignmentviewer generally displays schematically the locations of the precomputed alignments within the region. however, when it displays an alignment at the nucleotide sequence level, alignmentviewer dynamically realigns the displayed sequences using the dynamic programming algorithm for global alignment  <cit> . therefore, in this mode, users can see the longer alignment beyond the boundary of the precomputed alignment. on the other hand, in the reference-target mode, alignmentviewer uses the precomputed results to display the nucleotide sequence alignments.

users can compare the locations of several feature segments, such as several types of repetitive segments, by loading them on the annotation tracks. in addition to retrieving the precomputed data from the server, alignmentviewer can request the server to perform dynamical searches through the cgi interface. for example, users can search for sequences similar to their query sequence in each genome using blast or they can search for a motif using the regular expression pattern search. the results are displayed as feature segments on the annotation track in the alignment display panel. a list of locations for each feature segment can be shown in tabular format, which can be used to locate each segment on the alignment display.

RESULTS
the preliminary versions of cgat  <cit>  have already been used in our several research projects in microbial comparative genomics, including comparisons of helicobacter pylori strains  <cit> , pyrococcus horikoshii and p. abyssi  <cit> , neisseria meningitidis strains, n. meningitidis strains and n. gonorrhoeae  <cit> , and staphylococcus aureus strains  <cit> . to highlight some unique functionalities of cgat, we have chosen the example of a comparison of two strains of h. pylori. further examples can be found on the project home page.

comparison of helicobacter pylori strains  <dig> and j99
helicobacter pylori is the first bacterial species for which the genome sequences of two different strains were determined  <cit> . comparative analysis of these sequences revealed several chromosomal rearrangements  <cit> . in further detailed analysis, nobusato et al. found a characteristic pattern of polymorphisms in the h. pylori genomes, an insertion with long target duplication, which is frequently associated with the insertion of restriction-modification  genes and which suggests a novel mechanism of gene mobility  <cit> . this pattern of polymorphisms is readily detected by cgat with data from the direct repeat  program loaded as feature segments . in this case, in addition to the dirrep track, the duplication can also be seen in the alignment track, in which green rectangles indicate that the aligned regions are duplicated only in the second  genome. one can see the annotation of the inserted gene by moving the mouse cursor over it  and one can access the specified web server  by clicking on it.

the origin of the inserted genes is another interesting issue. many of the strain-specific rm genes identified in the two h. pylori genomes were suggested to be horizontally transferred from distantly related organisms because of unusual codon usage bias and low g+c contents as well as the unusual topology of the phylogenetic trees  <cit> . in cgat, codon usage bias and g+c content at the third codon position are pre-calculated as gene attribute values for each genome. users can load one of these attributes to change gene colors . in this case, the inserted gene showed high codon usage bias  and low g+c content , which suggest a horizontal transfer event.

another interesting feature of the h. pylori genome is the abundance of simple repeat sequences  <cit> , which are suggested to be involved in adaptive evolution by increasing genotypic variation due to slipped-strand mispairing  <cit> . the comparison of the genomes of the two strains revealed variations in the number of sequence repetitions  <cit> . figure 5c and 5d shows the alignment display around the flip genes  with simple repeat data  and glimmer prediction  <cit>  loaded as feature segments. this clearly indicates that an increase in the length of a poly tract results in a frame shift, which disrupts the reading frame of the flip gene in strain  <dig>  it has been shown that this disruption results in loss of motility for this strain  <cit> .

to facilitate the search for interesting structures associated with certain classes of genes or feature segments, cgat provides several functions. by pressing the button farthest to the right on the control panel , one can see the list of genes or specified feature segments in a tabular format. by clicking on each gene or segment on this table, one can change the current view to see alignments around the specified locus. in addition, users can filter genes or feature segments according to keyword or other parameter by choosing 'search => filter gene/segment' from the menu; in this function, only those segments that fulfill the specified conditions are displayed on the annotation track.

while a pair of direct or inverted repeat sequences with a short spacer region can be easily visualized, as shown in figure  <dig>  it is more difficult to visualize repeat sequences that are farther apart. indeed, a simple zoom-out operation to enlarge the displayed region shrinks everything and makes it difficult for users to grasp the relationship between distant points. in this type of case, independent scaling of the x-axis or y-axis in the dotplot display is useful. for example, the  <dig> genome has a pair of inverted repeat sequences  that are located at both ends of the rearranged segment that contains the putative replication terminus , whereas that sequence is located at only one of the ends in the j <dig> genome, which partly accounts for the observed chromosomal inversion  <cit> . while this duplication is difficult to detect in the entire dotplot display , it is clearly evident in the dotplot after zooming in on the y-axis .

comparison of alignment engines
another important feature of cgat is to utilize several alignment programs as alignment engines, including blastn  <cit> , megablast <cit> , fasta  <cit> , mummer   <cit> , waba  <cit> , blat  <cit> , blastz  <cit> , patternhunter   <cit> , chaos  <cit> , game  <cit> , ssaha, and ssaha <dig>  <cit> . these programs use different algorithms or heuristics and different parameters and generally yield different results. therefore, comparisons of alignments by multiple programs can be helpful in avoiding errors. in the following, we compare the performance characteristics of these alignment programs in terms of their usefulness as alignment engines in cgat. for datasets, we used four pairs of closely related bacterial genomes: escherichia coli k- <dig>  <cit>  and o157:h <dig>  <cit> , helicobacter pylori  <dig>  <cit>  and j <dig>  <cit> , escherichia coli k- <dig>  <cit>  and salmonella enterica serovar typhi  ct <dig>  <cit> , and bacillus subtilis  <cit>  and geobacillus kaustophilus  <cit> . in this test, we ran each program with the default parameter set, with the aim of characterizing each program in a standard setting rather than fully investigating the potential performance through extensive changing of parameters. a similar, more extensive test was performed previously with a different set of programs using simulated data  <cit> .

however, comparative studies that yield precise information on elementary processes in evolution of genome structure are primarily those that compare genomes with nucleotide identities of ≥90%. in these types of studies, the sensitivity of the alignment program is not very important since the differences between the programs are small. instead, the selectivity of the programs becomes important for identifying evolutionarily correct alignments. unfortunately, there is usually a trade-off between sensitivity and selectivity, such that a more sensitive program may be less selective. figure 8a and 8b shows an example, in which an apparent permutation found between hp <dig> and its ortholog jhp <dig> by blastn cannot be identified by blastz, which was one of the most sensitive programs in the above tests. similar problems are often encountered when using global alignment programs, and sensitive local alignment programs can also suffer from the same type of problem.

alignment boundaries are often obscure and can vary among different programs. we examined the percentage identities at positions near the alignment boundaries, as calculated by each program , and found conspicuous differences between the sensitive methods  and the less-sensitive methods. in the former methods, identity substantially decreased near the alignment boundary, except in the comparison of the less-similar species of bacillus and geobacillus, whereas in the latter methods, this type of decay was not observed. this tendency, in addition to the increase in identity commonly observed at alignment boundaries, is probably due to the nature of the local alignment algorithm and is dependent upon the scoring systems and other parameters used, as well as the alignment algorithms or heuristics. in any case, it is difficult to say which program or set of parameters generally gives better alignment in terms of identifying true homology. in some cases, the aligned sequences share some conserved motifs that suggest that they are indeed homologous, while in other cases, these sequences may simply be non-homologous segments generated by a substitution or other rearrangement event. therefore, it is recommended to careful researchers that they use multiple programs for choosing better alignments, thereby avoiding program-specific or parameter-specific errors.

in the region-wise mode of cgat, the alignment between the displayed sequences is dynamically recalculated and displayed , so that users can see the alignment beyond the boundaries of the precomputed ones. by simply reloading the alignments, one can compare alignments using different programs, as depicted in figure  <dig>  in addition, it may be helpful for users to load some feature segments calculated by other programs, such as a motif search program. in this way, cgat allows users to validate carefully alignment quality.

CONCLUSIONS
cgat aims to help researchers to come to grips with the complex evolutionary changes that occur between closely related genomes through automated genome-to-genome alignments combined with extensive manual inspection. to achieve this goal, cgat adopts a client-server architecture that comprises dataserver and alignmentviewer, and has the following prominent features:  dataserver provides a general framework that defines a protocol for constructing large-scale genome alignments using various existing alignment programs;  dataserver also contains programs for collecting several feature segments, including several kinds of repetitive structures;  alignmentviewer consists of an alignment display and a dotplot display with scrolling and zooming facilities, which are updated in a coherent fashion by user operations;  the alignment display can contain several annotation tracks that display precomputed or dynamically computed feature segments;  alignmentviewer provides several functions that allow users to navigate efficiently through the alignment space and to filter information so as to focus on specific features;  in addition to displaying precomputed alignments, alignmentviewer can calculate alignments between any specified regions on the fly, which enables users to validate or refine the precomputed alignments.

availability and requirements
project name: cgat

project home page: 

operating systems: the client program is essentially platform-independent. the server program runs in the unix environment; it has been tested with linux, solaris, darwin , and cygwin .

programming languages: java  and perl .

license: bsd.

this program is also available in its source code as additional file  <dig>  for the latest version see the website.

abbreviations
cgat: comparative genome analysis tool

dag: directed acyclic graph

highrep: highly repetitive region

simplerep: simple repeat

dirrep: direct repeat

invrep: inverted repeat

is: insertion sequence

rm: restriction-modification

authors' contributions
iu designed the software and developed the basic methods. iu and th implemented the programs. iu conducted the analysis and wrote the manuscript. ik designed the practical projects using the software, which greatly influenced the program design. all of the authors read and approved the final manuscript.

supplementary material
additional file 1
program source code. the source code of cgat. the latest version can be found on the web site .

click here for file

 acknowledgements
the authors thank mikihiko kawai and takeshi tsuru for valuable comments based upon extensive use of the software. this work was supported by institute for bioinformatics research development, japan science technology agency  and by a grant-in-aid for scientific research from the ministry of education, culture, sports, science and technology of japan . the work in the laboratory of ik was supported by the 21st century coe project of "elucidation of language structure and semantic behind genome and life system" and by grants-in-aid for scientific research  from the japan society for the promotion of science  to ik. the software development was originally funded by human genome center, institute of medical research, the university of tokyo.
