BACKGROUND
biological sequence analysis is the heart of computational biology. many successful algorithms  and data structures  have been developed over the last twenty years. the assemblies of large eucaryotic genomes like drosophila melanogaster  <cit> , human  <cit> , and mouse  <cit>  are prime examples where algorithm research was successfully applied to a biological problem. however, with entire genomes at hand, large scale analysis algorithms that require considerable computing resources are becoming increasingly important . although these tools use slightly different algorithms, nearly all of them require some basic algorithmic components, like suffix arrays, string searches, alignments, or the chaining of fragments. this is illustrated in fig.  <dig> for the case of genome comparison tools. however, it is non-trivial to obtain efficient implementations of these components. therefore, suboptimal data types and ad-hoc algorithms are frequently employed in practice, or one has to resort to stringing standalone tools together. both approaches may be suitable at times, but it would clearly be much more desirable to use an integrated library of state-of-the-art components that can be combined in various ways, either to develop new applications or to compare alternative implementations. in this article we propose seqan, a novel c++ library of efficient data types and algorithms for sequence analysis in computational biology.

in other fields, software libraries have greatly advanced the transfer of algorithmic knowledge to the tool programming process. two of the best known examples are the leda library  <cit>  for algorithms on graphs and efficient data types and the cgal library  <cit>  for computational geometry. in bioinformatics, a comparable library is still missing although there is a need for integrated implementations of algorithms for aligning sequences, computing substring indices in primary and secondary memory, or filter algorithms. in addition, a library that adheres to the principles of algorithm engineering is essential as a means to test and compare existing tools as well as to evaluate the results from algorithmic research. the lack of such a library becomes evident when reviewing the related work of the past years.

a few c++ libraries with sequence analysis features have already been developed, including bio++  <cit> , libcov  <cit> , the bioinformatics template library   <cit> , the ncbi c++ toolkit  <cit> , or the sequence class library   <cit> . bio++ is the most comprehensive library providing re-usable components for phylogenetics, molecular evolution, and population genetics. the sequence analysis part is, however, limited to basic import/export capabilities and string manipulations. in contrast to seqan, which is based upon the generic programming paradigm, bio++ is a purely object-oriented library, favoring ease of development over performance and scalability. libcov focusses on phylogenetics and clustering algorithms. it offers only basic data structures to handle sets of sequences. alignment algorithms, database indices, or scoring matrices are not provided. the btl emphasizes basic mathematical algorithms and data structures. it currently comprises graph classes and linear algebra algorithms but only a single sequence alignment algorithm, needleman-wunsch  <cit>  with cubic running time. the ncbi c++ toolkit also offers, beside other things, some sequence analysis functionality, e.g. alignment algorithms. the scl, providing some basic sequence analysis components, is to our knowledge not activly developed anymore.

besides these c++ libraries, we are aware of alternative approaches like bioperl  <cit>  or biojava  <cit> . the main purpose of bioperl is to ease the development of sequence analysis pipelines by providing an interface to already existing tools. biojava on the other hand is suited for developing new sequence analysis tools by providing many relevant data structures and algorithms and as such is from the overall goals perhaps closest to seqan. some algorithms are shared by both libraries . a closer inspection, however, reveals that biojava does only offer a small part of seqan's functionality . hence both libraries are in this sense complementary. in addition, we show in the result section that our implementations are for standard alignment problems by a factor of  <dig> to  <dig> times faster and by a factor of  <dig> to  <dig> times more space efficient.

the exposition is structured as follows: to emphasize the usefulness of seqan, this article centers around the contents of the library, described in section and the practical application of seqan, exemplified in section. in the following section we start by giving a brief outline of the design principles seqan is based on.

implementation
library design
for developing the basic design, seqan has gone through an extensive conceptual phase in which we evaluated many designs and prototypic implementations. seqan has now a generic programming design that guarantees high performance, generality, extensibility, simplicity, and easy integration with other libraries. this design is based on four design principles which we will describe now.

generic programming
seqan adopts the generic programming paradigm that proved to be a key technique for achieving high performance algorithms in the c++ standard library  <cit> . generic programming refers to a special style of programming where concrete types are substituted by exchangeable template types. hence, classes and algorithms are written only once, but can be applied to different data types.

global function interfaces
seqan uses global functions instead of member functions to access objects . this strategy improves the flexibility and the scalability of our library, since global functions, unlike member functions, can be added to a program at any time and without changing the existing code. moreover, global function interfaces enable us to incorporate the c++ built-in types and handle them like user defined types. it is even possible to adapt arbitrary interfaces, i.e. of classes that are implemented in external libraries, to a common interface by using small global functions called 'shims' . algorithms that access objects only via global functions can therefore be applied to a great variety of types, including built-in types and external classes.

traits
generic algorithms usually have to know certain types that correspond to their arguments: an algorithm on strings may need to know which type of characters are stored in the string, or what kind of iterator can be used to browse it. seqan uses type traits  <cit>  for that purpose. in c++, trait classes are implemented as class templates that map types or constants given by template arguments to other types but also other c++ enties like constants, functions, or objects at compile time. most of the advantages we already stated for global functions also apply to traits, i.e. new traits and new specializations of already existing traits can be added without changing other parts of the library.

template argument subclassing
seqan uses a special kind of hierarchical structure that we call 'template argument subclassing', which means that different specializations of a given class template are specified by template arguments. for example, string<compressed> is a subclass of string in the sense that all functions and traits which are applicable to string can also be applied to string<compressed>, while it is possible to overload some functions especially for string<compressed>. the rules of c++ overload resolution guarantee that the compiler always applies the most specific variant out of all existing implementations when an algorithm or trait has been called. this approach resembles class derivation in standard object-oriented programming, but it is often faster, because it does not require a type conversion for a subclass calling a function that is already defined for the base class, and since the actual type of the object used in a function is therefore already known at compile time, it is not necessary to detect it at run time using virtual functions. non-virtual functions have the advantage that c++ compilers can use function inlining to save their overhead completely. template argument subclassing enables us both to specialize functions and to delegate tasks soundly to base classes while still maintaining static binding.

design goals
these design principles support our design goals in the following way:

• performance: the library produces code that is competitive with manually optimized programs. template argument subclassing makes it possible to plug in optimized specializations for algorithms whenever needed. our generic programming design also speeds up the code in avoiding unnecessary virtual function calls.

• generality: all parts of the library are as flexible as possible. algorithms can be applied to various data types and new types can be added if necessary. for example, generic alignment algorithms in seqan work on strings for arbitrary alphabets. however, specialized implementations that make use of certain attributes of the alphabet can still be developed using template argument subclassing.

• integration: seqan components are designed to fulfill the requirements specified in the c++ standard. in addition, seqan easily interacts with other libraries because the global interface can be expanded. hence, algorithms and classes of other libraries are at hand.

• extensibility: the open-closed principle  is satisfied in so far as it is possible to extend the library by simply adding new code. seqan has this feature because it relies on stand-alone global functions and traits that can be added at any time without changing the existing code.

• simplicity: while a pure object-oriented library may be more familiar to some users, seqan is still simple enough to be used even by developers with average skills in c++.

library contents
seqan is a software library that is supposed to cover all areas of sequence analysis. fig.  <dig> gives an overview of the contents of the library in the current state.

sequences
the storage and manipulation of sequences is essential for all algorithms in the field of sequence analysis. in seqan, sequences are represented as strings of characters over various alphabets. multiple string classes for different settings are available: large sequences can be stored in secondary memory using external strings, bit-packed strings can be used to take advantage of small alphabets, or strings allocated on the stack can be used to guarantee fast access. string modifiers can be used to implement distinct views on a given sequence without copying it. a string segment, for instance, is a string modifier used to get access to an infix, suffix, or prefix of a given sequence.

alignments
alignments require the insertion of gaps into sequences. seqan does not actually insert these gaps directly into the sequence but treats them separately. the benefit is twofold: a single sequence can be used in multiple alignments simultaneously and the actual alphabet of the string must not include a special gap character. seqan offers both pairwise and multiple sequence alignment algorithms. algorithms can be configured for different scoring schemes and different treatments of sequence ends . in the pairwise case, local and global alignment algorithm are available. besides the classical needleman-wunsch algorithm  <cit> , more sophisticated algorithms are available, including an affine gap cost alignment  <cit>  and myer's bit vector algorithm  <cit> . moreover, seqan offers efficient algorithms to chain alignment fragments  <cit> . we are also currently integrating code for motif finding in multiple sequences.

indices
the enhanced suffix array   <cit>  is probably the most fundamental indexing data structure in bioinformatics with various applications, e.g., finding maximal repeats, super maximal repeats, or maximal unique matches in sequences. an enhanced suffix array is a normal suffix array extended with an additional lcp table that stores the length of the longest common prefix of adjacent suffixes in the suffix array. seqan offers an esa that can be build up in primary or in secondary memory, depending on the sequence size. the user has two choices to access the esa, either as a regular suffix array or as a suffix tree. the later view on an esa is realized using the concept of iterators that simulate a tree traversal. a more space and time efficient data structure for top-down traversals through only parts of the suffix tree is the lazy suffix tree  <cit>  which is also implemented in seqan. besides the sophisticated esa, simpler indices are available, including basic hash tables like gapped- and ungapped q-gram indices .

searching
flexible pattern matching algorithms are fundamental to sequence analysis. exact and approximate string matching algorithms are provided. for the exact string matching task, seqan offers the algorithms shift-and, shift-or, horspool, backward oracle matching, and backward nondeterministic dawg machine  <cit> . for searching multiple patterns, seqan currently supports the multiple shift-and, the set horspool, and the aho-corasick algorithm  <cit> . myer's bit vector algorithm  <cit>  can be used for approximate string matching. note that seqan's index data structures can naturally be used to search for strings as well.

graphs
graphs are increasingly important to a number of bioinformatics problems. prime examples are string matching algorithms , phylogenetic algorithms , or alignment representations  <cit> . hence, we decided to include our own graph type implementation, including directed graphs, undirected graphs, trees, automata, alignment graphs, tries, wordgraphs, and oracles. graph algorithms currently comprise breath-first search, depth-first search, topological sort, strongly-connected components, minimum spanning trees , shortest path algorithms , transitive closure, and the ford-fulkerson maximum flow algorithm  <cit> . trees are heavily used in clustering algorithms and as guide trees during a progressive multiple sequence alignment. alignment graphs are used to implement a heuristic multiple sequence alignment algorithm, which is similar to t-coffee  <cit>  but makes use of segments and a sophisticated refinement algorithm  <cit>  to enable large-scale sequence alignments.

biologicals
besides the fundamental alphabets for biological purposes, like dna or amino acids, seqan offers different scoring schemes for evaluating the distance of two characters, e.g., pam, and blosum. seqan also supports several file formats that are common in the field of bioinformatics, e.g., fasta, embl, and genbank. is is possible the access  sequence data stored in such file formats without loading the whole data into memory. the integration of external tools  and the parsing of metainformation is ongoing work.

RESULTS
we anticipate two different user groups for seqan. the first group is the bioinformatics practitioner with some programming knowledge who wants to quickly prototype efficient tools for analyzing genomic or protein sequences using seqan. the other prototypic user is the algorithmicist who is proficient in programming in seqan and wants to test and compare an algorithmic component for a specific well-defined algorithmic problem.

the next examples will demonstrate how things could be done in seqan. we would like to point out the very good performance of seqan as well as the fact that the necessary code is small, easy to understand, generic, and greatly profits from using an integrated algorithmic library.

example: string matching
we start with a small example of how seqan could be used as an experimental platform to test various implementations to solve the same algorithmic problem. in fig.  <dig> we show the results of a runtime comparison between three string matching algorithms implemented in seqan and the find method for strings from the standard template library. different pattern lengths and alphabet sizes were used. it turned out that there is always string matching routines in seqan that is faster than standard library code. this demonstrates that the coding standard used in seqan is competitive to a widely used stl implementation. note that none of the tested algorithms performs the best for all settings. a library like seqan makes it possible to switch between different algorithms easily, so users can apply the best algorithm depending on the requirements. moreover, seqan can act as an experimental platform to compare new string matching methods with the set of well known algorithms present in seqan.

example: global alignments
now we switch to a more biologically motivated example: computing a global alignment between two given dna sequences with minimal edit distance. alignment problems are very popular in the biological context. even libraries with little sequence analysis content support one or more relevant functions that are mostly based on the dynamic programming approach by needleman and wunsch  <cit> , which is certainly one of the most popular algorithms in bioinformatics. gotoh's algorithm  <cit>  extends it by affine gap cost models. some libraries also support hirschberg's algorithm  <cit> , another well-known alignment method that takes only linear space.

example: mummer
in this example, we want to convince the reader that programming using seqan is not difficult and that seqan is simple enough to meet the needs of the first user group while it is efficient and generic enough to allow expert users to use seqan as an experimental platform for testing algorithmic components.

we choose as an example the well-known mummer  <cit>  tool and show in the listing  an implementation of a  version of the tool which reads a number of sequences and computes all maximal unique matches  of length at least  <dig>  for the sake of exposition we only show code pieces that are illustrative for seqan.

a mum of a set of sequences is a subsequence that occurs exactly once in each sequence and that is not part of any longer such subsequence. to find mums mummer builds a suffix tree  <cit>  of a reference sequence and streams one or more query sequences against it. the downside of designating one sequence as the reference is that matches are only unique in the reference sequence but not necessarily in the query sequence. to guarantee the uniqueness of a match in all sequences it is necessary to construct a generalized suffix tree. a generalized suffx tree is a suffix tree of the concatenated sequences seperated by unique characters  <cit> . it is the primary index data structure in seqan and based on an enhanced suffix array  <cit> . in the first part of the example  we build a string index for a set of strings consisting of characters from the dna <dig> alphabet, which is an extension of the dna alphabet including the 'n' character. seqan supports a number of different alphabets of biological relevance . all these alphabets enable us to store sequences efficiently because of the reduced number of characters compared to normal text. the index is first resized to the appropriate number of sequences. subsequently, the sequences are imported using the fasta read function and simultaneously, these sequences are added to the index, which is our enhanced suffix array.

seqan provides iterators that make it possible to traverse the enhanced suffix array like a suffix tree in a bottom-up fashion. this is illustrated in additional file 1: listing  <dig>  the iterator it visits each node u in the generalized suffix tree. to find a mum u, it suffices to test whether u occurs exactly  <dig> times , at most once in each sequence , and cannot be extended to the left  . if the length of the representative string of u is also at least  <dig>  we report the position and length of the mum u . assuming a computational biologist is not all too interested in these algorithmic details but in performance and a simple interface, seqan provides specialized iterators to get all mums , maximal or supermaximal repeats, or multimems  <cit> ). since performance is a crucial issue in any kind of sequence analysis task, we compared our code example with the latest mummer release  <cit>  and multimat of the mga distribution  <cit> . to the best of our knowledge these are the only tools to find mums. none of the libraries introduced in chapter support generalized suffix trees or even algorithms on suffix trees, like those to find mums. our testset consisted of various bacteria strains and vertebrate chromosomes.

index data structures of whole genomes easily reach 10– <dig> gb, so they must rely on external memory. seqan provides such data structures. they can be used by simply exchanging the standard string of seqan by an external memory string in order to construct the generalized suffix tree in external memory. we did this for the last row of table  <dig> and simply replaced dna5string by string<dna <dig>  external<>> in the code example. this reduces the main memory space requirements of the algorithm at the expense of speed. however, this makes it possible to construct generalized suffix trees for sequences of nearly arbitrary length. as can be seen in table  <dig>  these external strings enable seqan to handle long sequences where mummer and mga simply run out of memory.

CONCLUSIONS
we presented a new software library with an efficient and generic design that addresses a wide range of problems in sequence analysis. seqan is under active development and we hope that it will become one of the standard platforms for algorithmic engineering at the interface of stringology, algorithm design and computational biology. besides the planned extensions mentioned in section, we are working on integrating external libraries and plan to intensify our collaborations with other research groups.

availability and requirements
seqan is freely distributed under the gnu lesser general public licence , both for academic and non-academic use. the library and its documentation can be downloaded from . all parts of the library are tested on windows with microsoft visual studio  <dig> and  <dig> and on linux with g++ compilers version  <dig>  and above.

competing interests
the author declares that there are no competing interests.

authors' contributions
ad worked out the overall design of the library and implemented a large part of the kernel functionality. dw took responsibility mainly for the index data structures and the pipelining in seqan. the work of tr includes everything in the library that has to do with graphs. programming seqan was team work, so all three programmers  left tracks in almost every part of the library. kr supervised the project. all authors participated equally in composing this manuscript.

supplementary material
additional file 1
listings. the listings show c++ code that uses seqan to implement a simplified version of the well-known mummer tool  <cit> .

click here for file

 acknowledgements
we would like to acknowledge all students of the bsc and msc program in bioinformatics at the fu berlin who have contributed to seqan so far. amongst others those are most notably stephan aiche, anne-katrin emde, ji-hyun lim, and henrik wöhrle.
