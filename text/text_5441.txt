BACKGROUND
given a number of dna strings, motif recognition is the task of discovering similar substrings without prior knowledge of their consensus or their locations. the following is a combinatorial formulation of the -motif problem  <cit> : let s = {s <dig>  ..., sn} be a set of m-length strings, and s* be the consensus string, a fixed and unknown string of length ℓ that is contained in each si as a substring but is corrupted with at most d substitutions . the aim is to determine s* and the location of the motif instances in each string. the weak motif recognition problem is to find the motif instances when the number of degenerate positions d is large in relation to the motif length ℓ; well-known weak motif recognition problems exist when the parameters  are equal to , , and . this combinatorial problem has application to finding transcription factor binding sites in genomic data  <cit> .

motif recognition is np-complete and therefore cannot be solved in polynomial time unless p = np  <cit> . nonetheless, there are numerous algorithms developed to solve specific instances of the problem, including projection  <cit> , winnower  <cit> , pattern driven approaches  <cit> , mitra  <cit> , psm <dig>  <cit> , pmsprune  <cit> , the voting algorithm  <cit> , mcl-wmr  <cit> , meme  <cit> , vas  <cit> , risotto  <cit> , weeder  <cit>  and several others. li et al. proved the existence of a ptas for an optimization version of the motif recognition problem, though the high degree in the polynomial complexity of the ptas algorithm renders this result only of theoretical interest  <cit> .

closely related to motif recognition is the consensus string decision problem. a consensus string for a set s of strings has hamming distance at most d from all strings in s. consensus string asks, given a parameter d and a set s = {s <dig>  ..., sn} of n strings, each of length ℓ, whether there exists a consensus string for s. consensus string is np-complete even when interest is limited to the binary alphabet  <cit> .

for a given parameter d we say s is a motif set if there exists a consensus string s* at distance at most d from any string in s; we say a set s of strings is pairwise bounded if the distance between any pair of strings in s is at most 2d. every motif set is pairwise bounded; if a pairwise bounded set is not a motif set we say it is a decoy set. for example, for d =  <dig> the set { <dig>   <dig>   <dig>  100} is a motif set because  <dig> is a consensus string for this set. in contrast, the set { <dig>   <dig>   <dig>  110} is a decoy set because it is pairwise bounded  but no consensus string exists.

the focus of this paper is the development and application of a heuristic for the consensus string decision problem . we denote the hamming distance between any pair of strings si and sj as h. we define the weight of a set of strings s as the sum of the hamming distances of each pair of strings in s ). if the weight of a set, which can be calculated in polynomial time, can be used to indicate whether it is a motif set or a decoy set then consensus string can be solved extremely efficiently and accurately in practice--simply calculate the weight of the pairwise bounded set and decide whether the set has a consensus based on this value. for this heuristic to work we need to know how the respective weights of a random motif set and a random decoy set are distributed. further, the distributions need to be adequately separated so that the weight of a set leaves little ambiguity as to whether the set is a motif set or a decoy set.

there exists an algorithm to sample from the set of all motif sets: simply choose any ℓ-length string as the consensus sequence and sample with replacement from the set of all strings that are at distance at most d from that sequence  <cit> . unfortunately we do not know an analogous sampling algorithm, either exact or approximate, for decoy sets. if we could sample pairwise bounded sets uniformly then we could learn the probability distribution of the weight of a random decoy set.

we give a method to generate pairwise bounded sets uniformly, use this method to determine the probability distribution of the weight of a random decoy set, and show the existence of a separation between this distribution and the probability distribution of the weight of a random motif set. thus, we solve consensus string instances extremely accurately and efficiently using the simple heuristic of using the weight as an indicator as to whether a pairwise bounded set is a motif set or a decoy set. the separation of the distributions becomes increasingly more prevalent as the number of strings in the set  increases, so the accuracy of our method increases as the number of strings increases. we significantly extend our earlier motif recognition program, mcl-wmr  <cit> , by incorporating the heuristic for consensus string described in this paper. this new algorithm, referred to as smcl-wmr, detects motifs in data sets with a large number of strings , and finds regulatory strings in genomic data. smcl-wmr represents the input data as a weighted graph and uses graph clustering to narrow the search to smaller problems that can be solved with significantly less computation. an efficient refinement algorithm that distinguishes valid motif sets from decoy sets allows smcl-wmr to detect motifs in very large data sets in significantly less computational time than mcl-wmr.

methods
sampling pairwise bounded sets
in this section we discuss uniform sampling, or generation, of pairwise bounded sets. a standard method used to generate a random motif set is to choose an ℓ-length string u.a.r.  from all possible 4ℓ strings to be the consensus string, and then form a motif set by selecting n strings at random with replacement from the set of all strings with hamming distance at most d from this consensus string  <cit> . this does not sample motif sets uniformly, but rather samples a motif set with probability proportional to the number of distinct consensus strings it has and thus, corresponds to how synthetic problem data sets are constructed and how we expect meaningful motif sets arise in nature. for example, synthetic problem instances are traditionally generated as follows: a random consensus string of length ℓ is chosen, n occurrences of the motif are generated by randomly mutating at most d positions, and each of the n motif instances is embedded at a random location into a different background string of length m. we note that other non-uniform distributions have also been used to generate motif sets  <cit> .

when sampling uniformly from a poorly understood sample set, rejection sampling is a naïve but useful technique. if we can find a superset of the target set that is easy to sample from uniformly, we can sample from this superset and simply throw away  any sampled element that is not in the target set. we show how rejection sampling can be applied to generate pairwise bounded sets uniformly.

uniform sampling of pairwise bounded sets
to sample u.a.r. from all pairwise bounded sets using rejection sampling in the most naïve way, we would generate n random ℓ-length strings and accept the set if it is pairwise bounded, and reject and repeat otherwise . however, since it is unlikely that such a randomly generated set would be pairwise bounded, this method is extremely inefficient. we introduce a heuristic to generate random sets that are more likely to be pairwise bounded, thus speeding up the rejection sampling process enough to be practical.

we generate the first string, s <dig>  u.a.r. from the set of all ℓ-length strings then generate each of s <dig>  ..., sn in turn u.a.r. from the set of all strings at distance at most 2d from s <dig>  this gives us a set of strings generated u.a.r. from the set of all strings that have s <dig> as the first string and each other string at distance at most 2d from s <dig>  if the set is pairwise bounded we keep it; if it is not we reject it and start over. the fact that this method generates pairwise bounded sequences u.a.r. can be verified by induction on n. the number of times a set of n strings is considered and rejected until a pairwise bounded set is generated follows a geometric distribution and therefore, the efficiency of this method is determined by the probability that a set is rejected. though this method is fast enough to work in practice for values of n we are interested in, the expected runtime when generating a single pairwise bounded set grows exponentially with n.

proposition  <dig>  the probability that a set generated using rejection sampling is pairwise bounded decreases at least exponentially fast as a function of n.

proof. for  <dig> ≤ i ≤ n let si be the subset of s containing the first i randomly chosen strings, with sn = s. let ai be the event that si is pairwise bounded. any subset of a pairwise bounded set is pairwise bounded, so ai implies ai- <dig> for  <dig> ≤ i ≤ n. therefore by bayes' law we have ℙ = ℙ ℙ. to prove that ℙ decays exponentially with n we need only show that ℙ is non-increasing in i, since it can easily be verified to be strictly less than  <dig> for i =  <dig>  let ki be the set of strings such that si ∪ {s} is pairwise bounded if and only if s ∈ ki, noting that ki = ∅ if si is not pairwise bounded. we have kj ⊆ ki for any  <dig> ≤ i <j ≤ n. since , where b is the number of strings at distance at most 2d from s <dig>  the result holds.   □

to empirically evaluate the efficiency of our rejection sampling method we determined the portion of sets that will be rejected when generating a sample  of pairwise bounded sets. we performed experiments with varying values of n, ℓ, and d, generated  <dig> pairwise bounded sets in each experiment, and considered the average number of sets rejected before the pairwise bounded set was obtained. the default values for  are .

the results of the empirical tests are shown in figure  <dig>  each of the three plots shows how the average number of rejected sets changes when one of the three parameters is varied and the other two are fixed at their default values. the left plot shows what happens when d varies between  <dig> to  <dig>  for values of d that are either greater than ⌊ℓ/2⌋ or equal to  <dig>  any set we generate is pairwise bounded and hence, we did not plot data for d =  <dig> or d ≥  <dig>  the average number of rejected sets is largest when d is equal to  <dig> and decreases dramatically as d increases. this trend is expected since a large portion of non-pairwise bounded sets would be rejected when d is moderately large. the middle plot shows what happens when ℓ is varied between  <dig> and  <dig>  the number of rejected sets increases steadily when ℓ varies within the range  <cit> , then plateaus when ℓ is above  <dig>  it can be easily shown analytically that increasing ℓ above 2dn will have no effect, however, we see empirically that the effect of ℓ is minimal for values of ℓ greater than  <dig>  the right plot shows the effect of varying n between  <dig> and  <dig>  noting that a logarithmic scale is used, the average number of rejected sets exhibits growth that is clearly exponential in n.

a separation of weight distributions
one of the key motivations for the development of methods to generate pairwise bounded sets from an appropriate distribution is that it can be used to determine whether there is a separation between the probability distribution of the weight of a random valid motif set and that of a random decoy set. we use the sampling method just described to generate  <dig> random motif sets and  <dig> random decoy sets for varying values of  and n. for each random motif and decoy set witnessed we calculated the weight of the set. figure  <dig> depicts, for values considered for  and n, the distribution of the weight of the  <dig> random motif sets and that of the  <dig> random decoy sets. the data illustrate an adequate separation between the distributions.

as the value of n increases, the separation between the distributions becomes more prevalent since the probability distributions become more concentrated around their means and the means themselves diverge. further, the dichotomy is again more evident when  is increased from  to . when n is even moderately large we can use the weight to determine accurately whether the set is a motif set or a decoy set and as n increases this method of using the weight as an indicator will likely increase in accuracy. similar conclusions can be made when ℓ and d increase. these results suggest that the simple heuristic of using the weight to determine whether a pairwise bounded set is a valid motif set or a decoy set will enable computationally challenging instances of the consensus string problem  is equal to ) to be solved efficiently with minimal probability of error.

these empirical trends illustrate the analytical results of boucher et al.  <cit>  that demonstrate that the distribution of the weight of a random motif set is tightly concentrated around its mean. the following theorem proves that the distribution of wm is sharply concentrated around its mean; specifically it provides exponential tail bounds.

theorem  <dig> . let wm be the weight of a random motif set and μm be the expected value of wm. then for any λ >  <dig>   

it is currently open to prove an analogous result to theorem  <dig> for an arbitrary decoy set. this is a considerably more challenging problem due to the lack of a combinatorial characterization of a decoy set.

smcl-wmr: an efficient method to detect motifs in large data sets
in  <dig>  mcl-wmr was developed specifically for the problem of detecting weak motifs in genomic data  <cit> . one of the main contributions of mcl-wmr is the introduction of a novel weighted-graph model for motif recognition. unfortunately, mcl-wmr was unable to detect motifs beyond when ℓ =  <dig>  d =  <dig>  m =  <dig>  and n ≥  <dig>  <cit> . eskin and pevzner reported similar results for various motif recognition programs  <cit> , and feng et al. showed limited accuracy for the  problem with  <dig> strings of length  <dig>  <cit> . specific motif recognition problems--that is, the problem for specific values of n, m, ℓ, and d--have remained intractable. for example, mcl-wmr was unable to solve any instance of the  motif recognition problem with n =  <dig> 

mcl-wmr uses graph clustering to determine pairwise bounded sets that might be valid motifs. the major impediment to the efficiency of mcl-wmr was the exponential-time refinement algorithm used to determine which "candidate motif sets"  have a consensus string  <cit> ; this step becomes a bottleneck for solving challenging weak motif instances, such as , when the number of such candidate sets increases dramatically  <cit> . boucher and brown  <cit>  give a probabilistic heuristic for solving the consensus string problem, which filters candidate sets based on a "majority vote", that has acceptable accuracy when n is significantly large . we propose a probabilistic algorithm that eliminates the need for a strong bound on n; our novel algorithm uses a candidate set's weight to determine quickly and with a small probability of error whether the set is a decoy set or a motif set.

overview of system
smcl-wmr considers a weighted graph representation of the data set, where each substring of length ℓ is represented by a vertex and the construction of our graph  ensures that the motif instances represented by vertices in the graph are connected to each other and form a clique of size n, though the converse need not hold. in this model, the problem of finding pairwise bounded sets in the data reduces to finding cliques of size n in the graph .

 <dig>  the vertex set contains a vertex vi, j representing the ℓ-length substring in string i starting at position j, for each i and j =  <dig>   <dig>  ..., m - ℓ +  <dig>  there are n vertices.

 <dig>  each pair of vertices vi, j and vi', j', for i ≠ i' is joined by an edge if and only if the corresponding substrings are at hamming distance at most 2d.

 <dig>  an edge between vertices having distance k has weight ℓ - k for d <k ≤ 2d, or  <dig> for k ≤ d. this emphasizes substrings at small distances.

we chose to use the markov cluster algorithm   <cit>  to cluster the graph  due to its ability to handle large weighted graphs. we reduce the size of the instance being passed to mcl by considering subgraphs  = {g <dig>  g <dig>  ..., gm-ℓ+1}, where, for some arbitrary choice of reference string r, gj is the subgraph induced by the closed neighborhood of the reference vertex vr, j. this is more efficient than searching all of  at once. mcl then clusters each gi ∈  to determine subgraphs that are highly interconnected . a clique in gi that represents a pairwise bounded set must have size n and have weight at least  since each pair of vertices must be adjacent. we filter out the clusters produced by mcl that do not meet these criteria since they cannot contain sufficiently large cliques. mcl-wmr uses a dynamic programming algorithm to determine which pairwise bounded sets  represent valid motif sets; this computationally intensive step limits its ability to solve many motif recognition instances.

if αm <αd then we can use the weight of a pairwise bounded set of strings to determine whether the set is a decoy or a motif as follows: calculate the weight w of the set and, if w ≤ αm or w ≥ αd then return that the set is a motif or a decoy, respectively; otherwise, use the dynamic programming algorithm to classify the set. hence, if αm <αd then more than 99% of pairwise bounded sets will be classified correctly by considering the weight of the set. typically the gap between αm and αd is large enough to guarantee that this rate is far higher than 99%. in theory it is possible that a set could be misclassified  though in practice the probability of this happening is negligible and does not affect the performance of the algorithm.

to increase the efficiency of smcl-wmr, we include a pre-calculated table storing μm, μd,  and  for common values of ℓ, d, and n . we varied n to be between  <dig> and  <dig>  ℓ to be between  <dig> and  <dig>  and d to be between ⌊ℓ/5⌋ and ⌊ℓ/2⌋ values with weaker motifs or with small data sets  are not considered since it was shown that mcl-wmr performs efficiently for these instances  <cit> .

                              m
                              d
                              m
                              d
                              m
                              d
                              m
                              d
data illustrating the change to the mean and standard deviation of the weight of a random motif set and the weight of a random decoy set as the values of ℓ, d, and n increase. on the left the number of strings is fixed at  <dig> and on the right the values  are fixed at .

RESULTS
performance of smcl-wmr on synthetic data
we follow the experimental methods of pevzner and sze  <cit> , and buhler and tompa  <cit>  by considering the performance of smcl-wmr in comparison to other contemporary and well-known motif recognition programs on synthetic data. we fix n to be equal to  <dig>  m to be  <dig>  and consider varied values of ℓ and d. to produce random motif recognition instances, we generate a random motif consensus of length ℓ, then generate n occurrences of the motif, each generated from the consensus by randomly choosing d positions and for each of the d positions choosing a random replacement base from the four possible bases . we construct m background strings of length n and insert the generated motifs into a random position in the string. for each of the  combinations,  <dig> randomly generated sets of input strings  were generated. the implementation of smcl-wmr is in c++.

we note that all experimental tests were performed on a linux machine with a 64-bit  <dig> mhz processor and  <dig> gbyte of ram running ubuntu. we compared the performance of smcl-wmr with that of the following motif recognition programs: projection  <cit> , mcl-wmr  <cit> , pmsprune  <cit> , and voting  <cit> . all programs were run on the same linux machine with the same data sets. these motif recognition programs were chosen for their availability, performance, and widespread use; they are appropriate for comparison with smcl-wmr because of the previously described capability in solving weak motif instances and because of their availability to be run on the described machine. the results of voting, pmsprune, and projection are similar to the ones reported by davila et al.  <cit> , and to chin and leung  <cit> , both of whose testing was completed on a machine with a slightly slower processor and the same core memory size.

we define the success rate of a given program using the performance coefficient used by pevzner and sze  <cit> , buhler and tompa  <cit> , and others  <cit> . let k denote the set of tℓ base positions in the t occurrences of the planted motif, and let p denote the corresponding set of base positions in the t occurrences predicted by an algorithm. the algorithm's success rate is defined as |k ∩ p|/|k ∪ p|. table  <dig> illustrates the comparison between the running time of smcl-wmr and that of the other programs. our aim was to test the selected programs on their capability to solve challenging motif instances . in table  <dig> "-" implies that the program was not capable of solving the motif instance on the described machine in a reasonable amount of time, which we define to be at most  <dig> hours, or with reasonable accuracy, which we define to be at least 75%. two significant trends are witnessed in the data: smcl-wmr is capable of solving very hard instances of motif recognition  and gives a dramatic improvement over the existing programs for instances where ℓ ≥  <dig> . we note that all programs except projection achieved a 100% success rate on all motif instances; in table  <dig> we put the success rate of projection in brackets.

comparison of the performance of smcl-wmr and other motif recognition programs on synthetic data; other programs tested include projection  <cit> , mcl-wmr  <cit> , voting  <cit> , and pmsprune  <cit> . all programs except projection had a success rate of 100% and for this reason, the success rate was for projection is included in brackets in the table. the time is given in cpu seconds. in all experiments, n =  <dig>  m =  <dig>  and ℓ and d are varied. "-" denotes that the program was not capable of solving the specific problem.

there exist real-genomic data sets which contain a large number of sequences. for example, a data set, labeled as hm <dig>  in the transfac database  <cit>  has  <dig> input strings. unfortunately, it is uncommon to test motif recognition programs with synthetic data sets with greater than  <dig> input strings. for example, the following motif recognition algorithms were tested with data sets with at most  <dig> strings: projection  <cit> , winnower  <cit> , mitra  <cit> , psm <dig>  <cit> , pmsprune  <cit> , the voting algorithm  <cit> , mcl-wmr  <cit> , and vas  <cit> . we aim to investigate the capability of smcl-wmr - as well as other motif recognition programs - in solving motif recognition instances with a large number of strings. the other programs tested include mcl-wmr, voting, and pmsprune. table  <dig> shows that smcl-wmr was capable of solving instance with up to  <dig> strings. again, as in table  <dig> "-" implies that the program was not capable of solving the motif instance on the described machine in a reasonable amount of time, which we define to be at most  <dig> hours, or with reasonable accuracy, which we define to be at least 75%. the capability of smcl-wmr in solving motif recognition instances with a large number of strings can easily be explained by the fact that the runtime of the method used to solve consensus string scales slowly in n and therefore, has efficient running time even when n is large .


                              n
the performance of smcl-wmr as the number of strings increases in comparison to other motif recognition programs. other programs tested include mcl-wmr  <cit> , projection  <cit> , voting  <cit> , and pmsprune  <cit> . the time is given in cpu seconds. in all experiments, ℓ =  <dig>  d =  <dig>  m =  <dig> and n ranges from  <dig> to  <dig> 

using smcl-wmr to find regulatory elements
an important biological challenge is to identify dna binding sites of transcription factors. in this section, we demonstrate the use of smcl-wmr in discovering these dna string "motifs" in data sets with a large number of dna strings. tompa et al. extensively assess  <dig> motif recognition tools  <cit>  using test sets that make use of transcription factor binding sites. the binding sites were obtained from the transfac database  <cit>  which contains only eukaryotic transcription factors. the transfac database is extremely comprehensive, containing data from a large variety of species, including yeast, mus, oryctolagus cuniculus, and homo sapiens  <cit> . for more details concerning the data set, including the selection process for transcription factors and binding sites from transfac, see tompa et al.  <cit> .

we ran smcl-wmr on a randomly selected set of set of transcription factors from those of tompa et al.  <cit> . each transcription factor gives rise to one set of strings. the number of strings varied from  <dig>  to  <dig>  and the string length  varied from  <dig> bp to  <dig> bp. experimental results are shown in table  <dig>  smcl-wmr was capable of discovering motifs for these data sets, as well as many motifs not yet found by the motif recognition programs assessed by tompa et al.  <cit> . the known binding sites shown in table  <dig> are as given by the transfac database tompa et al.  <cit> .

                              d
data collected from transfac and the published motifs are found by the assessment of tompa et. al.  <cit>  of differing motif tools. for each set of data, we determined motifs of the same length using smcl-wmr. the number of strings ranges from  <dig> to  <dig> 

CONCLUSIONS
in this paper we investigate the relationship between the weight of a decoy set and the weight of a motif set by means of random sampling. we discuss a rejection sampling strategy, and propose a means to make this uniform sampling method more efficient. using our proposed sampling algorithm, we study the probability distributions of the respective weights of a random motif set and a random decoy set. we conclude that the weight of a pairwise bounded set can accurately predict whether the set is a valid motif set; we then use this heuristic to develop a program that efficiently detects motifs in large data sets. our focus was to develop an efficient program that solves a combinatorial version of the motif recognition problem. a position weight matrix  is another commonly used representation of motifs in biological strings  <cit> . the application of techniques described in this paper - graph clustering and satistical thresholds - to the pwm model of motif recognition warrants further investigation.

competing interests
the authors declare that they have no competing interests.

authors' contributions
concept, implementation, and experiments: cb. analysis and manuscript preparation: cb and jk.

