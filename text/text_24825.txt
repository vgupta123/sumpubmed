BACKGROUND
software testing issues in bioinformatics
in this post-genomic era, we are experiencing an explosion of biological data in terms of quantity and variety. to date, a lot of bioinformatics programs have been, and are continuously being, developed to support the analysis of these data. most of the research effort in the bioinformatics community focuses on developing advanced computational and statistical methods to support these tools. however, very little work has been reported on how to systematically and effectively test these programs. clearly the correctness of such programs is just as important as using the best algorithm, as incorrectly computed results may lead to wrong biological conclusion, and subsequently misguide downstream experiments.

currently, only a small amount of work has been devoted to software engineering in bioinformatics  <cit> . further, their main focus is on the management of large and complex biological datasets, whereas issues related to the correctness of bioinformatics software is largely ignored.

by its very nature, many bioinformatics programs are developed to organize and to analyze large and complex biological datasets. many of these programs involve  processing large amount of data, and  invoking complex processing procedures to extract useful information. in particular, due to the rapid accumulation of high-throughput datasets and the increasing focus on systems-level biological modeling, the size and complexity of bioinformatics programs are growing rapidly. this poses a great challenge in developing a good testing strategy to ensure the reliability of the software implementation.

software testing involves defining test objectives, selecting some inputs of the software under test as test cases, executing the software with these test cases, and verifying testing results  <cit> . a good testing strategy should actively reveal as many faults as possible using a selected set of test cases. to achieve this goal, many techniques have been developed to guide how to generate good test objectives and select good test cases. some commonly used testing techniques include random testing, domain testing, control-flow testing, data-flow testing, and so on  <cit> . however, many of these techniques implicitly assume that there is a means to verify whether the testing result is correct, which is not necessarily the case in many practical situations. in software testing, an oracle is a mechanism to decide if the output of the target program is correct given any possible input. when a test oracle exists, we can apply a large number and variety of test cases to test a program since the correctness of the output can be verified using the oracle. without a tangible oracle, the choice of test cases is greatly limited to those special test cases  <cit>  where the expected outputs are known or there exists a way to easily verify the correctness of the testing results. in particular, an oracle problem is said to exist when :  "there does not exist an oracle" or  "it is theoretically possible, but practically too difficult to determine the correct output"  <cit> .

the existence of a tangible oracle is essential when performing systematic program testing. since an oracle is a systematic mechanism to verify the testing outputs for all possible program inputs, the presence of an oracle enables a testing strategy to select diverse inputs for testing in a systematic manner. in practice, it is possible to test programs using some simple or special test cases that are incrementally developed along the software development process. however, these test cases most likely only constitute a small portion of the whole input domain, and therefore cannot substitute a systematic oracle.

the oracle problem is a challenging topic for testing programs. unfortunately, many bioinformatics programs has the oracle problem as it is usually very difficult to construct a practical oracle to verify the results of all possible inputs of a program. since most commonly used testing techniques  assume the existence of an oracle, they are not appropriate for testing bioinformatics programs of which the oracles do not exist. this problem is particularly relevant in the area of biological network simulation. the challenge of objective testing of both deterministic and stochastic simulators has been realized by the sbml community  <cit> . to test the reliability of a new sbml capable simulator, the current practice involves executing it with multiple existing simulators on some well studied input models and compare the consistency of the simulation results  <cit> . such a method is called n-version programming  <cit> . although such effort seems to be satisfactory, it is not universally applicable since it relies on the availability of multiple implementations of a program with the same input/output structure, which is often hard to obtain. further, it is difficult to judge what is the correct output when different simulators generate very different results. it has been noted that " s no authoritative result set exists, it is hard to devise a metric based on the simulation results, that would tell us whether a given simulation result is 'correct' or not"  <cit> . visual inspection of the simulation results has been suggested to help us distinguish unreasonable results from reasonable ones. nonetheless, this approach is not automatable, subjective, and requires the tester to have expert knowledge of the underlying algorithm. therefore we need an alternative testing strategy to address the oracle problem.

metamorphic testing
metamorphic testing   <cit>  is an innovative testing approach to alleviate the oracle problem. instead of using the traditional test oracle, mt uses some problem domain specific properties, namely metamorphic relations , to verify the testing outputs. the end-users, together with the testers or program developers, first need to identify some properties of the software under test. then, mrs can be derived according to these properties. some test cases  can be selected according to some traditional testing techniques. further test cases  can be generated based on the source test cases and according to the mrs. all test cases are executed, and then the outputs of the source and follow-up test cases are checked against the mrs. if any pair of source and follow-up test cases violates  their corresponding mr, the tester can say that a failure is detected and hence conclude that the program has bugs.

chen et al.  <cit>  have used some examples to illustrate how to use the mt technique. one example is to test a program that searches for the shortest path between any two nodes in an undirected graph. given a weighted graph g, a source node x, and a destination node y in g, the target program is to output the shortest path and the shortest distance, d, from x to y. in this problem, a practically feasible test oracle does not exist due to the combinatorially large number of possible paths between x and y. therefore testing such a program is difficult due to the oracle problem. using the mt technique, we can define a number of mrs based on some well-known properties in graph theory. here we use two such properties as examples: d = d, and d = d + d where w is a node on the shortest path identified by the program in running d. the idea is that although it is difficult to verify the correctness of each test case , d, d and d), it is much easier to test whether these test cases and their corresponding outputs satisfy the mrs. if the shortest path program violates any of these mrs, we can conclude that the program is incorrect.

our contributions
the main contribution of our paper is to introduce the use of mt as a simple, effective and automatable technique for testing bioinformatics programs, particularly for those bioinformatics programs which suffer from the oracle problem. through two case studies, we give a step-by-step presentation on how mt is used in practice. we explain how to derive mrs from the domain knowledge and program specification, and subsequently how to generate test cases based on these mrs. the effectiveness of mt is demonstrated through analyzing its ability to detect failures in some programs with faults seeded by an automatic process. we also discuss the applicability of mt to various important application domains in bioinformatics.

RESULTS
the general process of mt is very simple. first, the end user and the tester need to come up with some properties involving multiple pairs of inputs and outputs of the target program. these properties are derived from the domain knowledge of the target program. they are referred to as the metamorphic relations . second, the tester needs to design a set of source test cases and their corresponding follow-up test cases based on these mrs. in this study, the source test inputs were either generated randomly, or taken from some real-life cases. finally, all test cases are executed and the outputs of the source and follow-up test cases are compared to check whether the corresponding mr is satisfied. in this section, we demonstrate how mt can be applied in practice through testing of two bioinformatics programs, namely gnlab  <cit>  and seqmap  <cit> . in each of our case studies, the intended behaviour of the target program is briefly described, and the process of mr derivation is explained. it should be noted that these two programs are chosen because they are open-source and represent two important application domains in bioinformatics: network simulation and high-throughput data processing.

case study 1: testing of gnlab
gnlab  <cit>  is a command-line tool for large-scale analysis and simulation of gene regulatory networks . this program consists of separate components for network generation, simulation, analysis, visualization and comparison. here we only focus on testing the deterministic network simulation component of gnlab. the network simulator of gnlab takes a directed weighted graph as input where the type and strength of gene-to-gene interactions are represented by the edge weights. it assumes the following relationships between the input graph structure and the network dynamics:

 <dig>  the weight of an edge represents the influence of the regulator  on the target gene .

 <dig>  an edge should have a weight between - <dig> and  <dig> inclusively, where a positive weight represents activation and a negative weight represents repression.

 <dig>  if two nodes are not connected by a directed path, the expression dynamics of these two nodes should be independent.

this set of grn simulation rules and previous experience in performing network simulation, which together form the domain knowledge in this case study, indicate that changes in the network structure should cause changes to the execution path of the program. therefore, we first aim to devise a set of mrs that capture the behaviours of various types of network structure alteration:

 <dig>  addition of a node
 addition of a disconnected node. given a network g, we add to it a node p, which is not connected to any node in g. the new network is referred to as g'. the output of g should be fully subsumed in the output of g'. that is,  =  + .

 addition of a non-regulator node. given a network g, we add to it a node p, which is not the regulator to any node in g. the new network is referred to as g'. the output of g should be fully subsumed in the output of g'. that is,  =  + .

 <dig>  addition of an edge
 addition of an edge with positive weight. given a network g and a non-regulator node p in g, we add an edge, which is directed to p with a positive weight. the new network is referred to as g'. in the output of g', only the output of p would be increased, while output of the other nodes should remain unchanged.

 addition of an edge with negative weight. given a network g and a non-regulator node p in g, we add an edge, which is directed to p with a negative weight. the new network is referred to as g'. in the output of g', only the output of p would be decreased, while output of the other nodes should remain unchanged.

 addition of an edge with zero weight. given a network g and a node p in g, we add an edge, which is directed to p with zero weight. the new network is referred to as g'. the output of g' should be identical to the output of g.

 <dig>  deletion of a node
 deletion of a non-regulator node. given a network g and a non-regulator node p in g, we delete p from g to produce a new network g'. the output of g' should be fully subsumed in the output of g. that is,  =  - .

 deletion of a regulator node. given a network g and a regulator node p in g, we delete p from g to produce a new network g'. such a deletion should affect the outputs related to all p's descendant nodes, while the outputs related to p's non-descendant nodes should remain unchanged.

 <dig>  duplication of a network
given a network g, we duplicate g to produce a new network g' .  =  + .

 <dig>  modification of edge weight
 increase of edge weight. given a network g, a node p in g and an edge e directed to p, we increase the weight of e. such a modification should increase all the expression values associated with p.

 decrease of edge weight. given a network g, a node p in g and an edge e directed to p, we decrease the weight of e. such a modification should decrease all the expression values associated with p.

we used three batches of test cases to test gnlab. the first batch contains some randomly generated input networks as source test cases. the second and third batch of test cases were generated using a yeast grn  <cit>  and a e. coli grn  <cit>  as source test case respectively. the yeast grn has  <dig> nodes and  <dig> edges, while the e. coli grn has  <dig> nodes and  <dig> edges  <cit> . we shall refer to the three batches as batch r , batch y  and batch e . for each of three batches, one pair of source and follow-up test cases were used for each mr . all test cases were executed by gnlab and the results were checked against the mrs. the results  indicate that gnlab violates mr <dig>  while satisfying all other mrs.

gnlab and nine of its mutants were tested against three batches of test cases, which are labeled as r , y  and e . each pair of test cases that detects a violation of a mr in a program is labeled by its batch in the respective cell in the table. for example, the label 'ry' in the cell  indicates that mutant  <dig> violates mr <dig> according to the test cases in batch r and batch y.

the initial program developer chose to use k =  <dig> – 1950|w| to map the edge weight of a network into a parameter of the hill's kinetic equation . since the absolute value of the edge weight |w| is restricted between  <dig> and  <dig>  the kinetic parameter k is mapped to a value between  <dig> and  <dig>  we note that this formula satisfies the intuition that higher weight on a directed edge implies stronger influence of the regulator to the regulated gene . however, by using this formula, an edge with zero weight would still allow the regulator  to weakly influence its target gene. to correct this problem, the developer of gnlab either needs to add a conditional clause around this formula, or uses a more appropriate mapping formula. therefore our results demonstrate the effectiveness of mt by identifying a problem with program specification that leads to a program behaviour which violates a basic network simulation intuition.

case study 2: testing of seqmap
seqmap is an efficient tool for mapping massive amount of short sequence reads to a reference genome  <cit> . one important application of seqmap is the detection of cross-hybridizing probes in an oligonucleotide microarray  <cit> . seqmap performs short sequence mapping by solving an approximate string matching problem, which is defined as follows: given a reference string p and a set of target strings t = {t <dig>  t <dig>  ..., tk} where all strings are made up of a finite number of characters taken from the set of alphabets a = {a <dig>  a <dig>  ..., am}, the task is to find all substrings in p such that each substring has an edit distance equal to or less than the maximum number of mismatches e against each ti ∈ t. edit distance refers to the number of operations required to transform one string to another. in short sequence mapping , p is the genome and t is the set of short sequence reads which we intend to map to the genome. in particular, the set of allowable alphabets is a = {a, t, g, c}, and valid edit operations are substitution, insertion and deletion. if a sequence read ti matches any substring in genome p, it is said to be mappable, otherwise, it is said to be unmappable.

although it is easy to verify whether the mapping of each read at one genome location has a mismatch number that is equal to or less than the maximum number of mismatches, it is very hard to check whether this read has been mapped to all possible matching positions in the genome. further it is also very hard to check whether all unmappable reads are indeed truly unmappable to the genome. in other words, soundness of the result is easy to verify, but not the completeness of the result. therefore testing of seqmap suffers from the oracle problem, and may benefit from mt.

based on the knowledge of the problem domain, we have identified two important variables that most likely affect the execution pattern of the program: the content of the input sequences, both p and t, and the edit distance constraint, e. we therefore derived a set of mrs based on the properties of these variables:

 <dig>  changes in read of t
 addition of mismatches. given a set of sequence reads t = {t <dig>  t <dig>  ..., tn}, a genome p and a maximum number of mismatches e, we map t to p and denote the set of mappable reads as tm = {t′ <dig> t′ <dig> ...,t′k}, where k ≤ n. define a subset m of tm, where m = {m <dig>  m <dig>  ..., mq} and q ≤ k. for any mi ∈ m, assume l as one of its mismatch numbers. we arbitrarily choose a l', such that l <l' ≤ e, and introduce  new mismatches on mi . then m′i should still be mappable to p. furthermore, there should exist at least one common location for mi and m′i.

 removal of mismatches. given a set of sequence reads t = {t <dig>  t <dig>  ..., tn}, a genome p and a maximum number of mismatches e, we map t to p and denote the set of mappable reads as tm = {t′ <dig> t′ <dig> ...,t′k}, where k ≤ n. define a subset m of tm, where m = {m <dig>  m <dig>  ..., mq} and q ≤ k. for any mi ∈ m, assume l as one of its mismatch numbers. we arbitrarily choose a l', such that  <dig> ≤ l' <l, and delete  mismatches on mi . then m′i should still be mappable to p. furthermore, there should exist at least one common location for mi and m′i.

 change the type of mismatch. given a set of sequence reads t = {t <dig>  t <dig>  ..., tn}, a genome p and a maximum number of mismatches e, we map t to p and denote the set of mappable reads as tm = {t′ <dig> t′ <dig> ...,t′k}, where k ≤ n. define a subset m of tm, where m = {m <dig>  m <dig>  ..., mq} and q ≤ k. for any mi ∈ m, assume l as one of its mismatch numbers. we arbitrarily replace several mismatches by different types of mismatch on mi , while keeping the same total number of mismatches as l . then m′i should still be mappable to p. furthermore, there should exist at least one common location for mi and m′i.

 <dig>  changes in p
 concatenation of subset of reads. given a set of sequence reads t = {t <dig>  t <dig>  ..., tn}, and a genome p, we select a subset of sequence reads ts ⊂ t and concatenate this subset of reads to the end of p to form a new genome p'. after mapping t to both p and p' independently, the following relations should hold:  all reads in t that are mappable to p should also be mappable to p', and  each read in ts that is mappable to p should have at least one additional mapping location in the part of p', which corresponds to the concatenated string.  each read in ts that is unmappable to p should be mapped at least once in the part of p', which corresponds to the concatenated string.

 deletion of p. given a set of sequence reads t = {t <dig>  t <dig>  ..., tn}, and a genome p, we form a new genome p' by deleting an arbitrary portion of either the beginning or ending of p. after mapping t to both p and p' independently, all reads in t that are unmappable to p should also be unmappable to p'.

 <dig>  changes in both p and t
 reversing the input p and t. given a set of sequence reads t = {t <dig>  t <dig>  ..., tn}, and a genome p, we form a new set of sequence reads t' = {t′ <dig> t′ <dig> ...,t′n} and p' such that each string t′i is a reversed string of ti for  <dig> ≤ i ≤ n, and p' is a reversed string of p. a string s' is a reversed string of s if the first character of s' is the last character of s and the second character of s' is the second last character of s, and so on. we map t to p and independently map t' to p'. the following relations should hold:  ti is mappable to p if and only if t′i is mappable to p' for  <dig> ≤ i ≤ n, and  ti is unmappable to p if and only if t′i is unmappable to p' for  <dig> ≤ i ≤ n.

 permutation of alphabets. given a set of sequence reads t = {t <dig>  t <dig>  ..., tn}, a genome p, and a one-to-one permutation function on the set of alphabets, permute. for any string s, permute is used to denote the string after permutation. we define a new set of sequence reads t' = {t′ <dig> t′ <dig> ...,t′n} and p' such that t′i = permute for all  <dig> ≤ i ≤ n, and p' = permute. we map t to p and independently map t' to p'. the following relations should hold:  ti is mappable to p if and only if t′i is mappable to p' for  <dig> ≤ i ≤ n, and  ti is unmappable to p if and only if t′i is unmappable to p' for  <dig> ≤ i ≤ n .

 <dig>  changes in maximum number of mismatches 
 decrease of e. given a set of sequence reads t = {t <dig>  t <dig>  ..., tn}, a genome p, and the maximum number of mismatches e, we create a new e' such that  <dig> ≤ e' <e. we map t to p with parameter e and denote the set of mappable reads as m. we independently map t to p with parameter e' and denote the set of mappable reads as m'. the following relation should hold: m' ⊆ m.

 increase of e. given a set of sequence reads t = {t <dig>  t <dig>  ..., tn}, a genome p, and the maximum number of mismatches e, we create a new e' such that  <dig> ≤ e <e'. we map t to p with parameter e and denote the set of mappable reads as m. we independently map t to p with parameter e' and denote the set of mappable reads as m'. the following relation should hold: m ⊆ m'.

using mt, we tested seqmap  with five batches of test cases. for each batch, we randomly generated a source test case, from which one follow-up test case is constructed based on each mr. the execution results were checked against these mrs, and we did not observe violation to any of them.

mutation analysis of gnlab and seqmap
to better demonstrate the applicability of mt, we generated a number of fault-seeded variants of gnlab and seqmap, and measure how well our mt procedure can detect them. this process is referred to as mutation analysis  <cit> . a program with a seeded fault is called a mutant. all mutants are generated by applying some very simple mutation operators to alter the source code of the original program. previous study shows that, despite the simplicity of these mutation operators, the capability of detecting failures from the generated mutants is a good indicator of the effectiveness of a testing method  <cit> . it should be noted that if a mutant produces the same output as the original program for all possible inputs with respect to the functionalities under test, such a mutant is said to be equivalent to the original program. using an unbiased random mutant generation strategy , we initially generated  <dig> mutants for gnlab and  <dig> mutants for seqmap. since we only focus on testing certain functionalities of gnlab and seqmap , many of the automatically mutated statements in the source code do not affect the targeted functionalities, and therefore many mutants are equivalent mutants. as a result, there are nine non-equivalent mutants for gnlab and three non-equivalent mutants for seqmap. although the pool of applicable  mutants is not very large, the results we obtain here is sufficient for our purpose of demonstrating the applicability of mt in bioinformatics.

the nine non-equivalent mutants of gnlab  were tested by three batches of test cases used in the testing of the original gnlab program. the results are shown in table  <dig>  we observe that all mutants violate at least one mr. it is also worth noting that different mrs are effective in revealing the fault in different mutants. moreover, different mrs have different failure-detection capabilities. test cases associated with mrs  <dig>   <dig>   <dig> and  <dig> cannot detect any failure. in other words, all the mrs related to the modification of nodes in gnlab network are less effective than other kinds of mrs. the mr violation rate  of the three batches are:  <dig>  ,  <dig>  , and  <dig>  . further, for a given mutant, a single batch of test cases may not violate all possible mrs. for example, only batch e can reveal a violation of mr <dig> and  in gm <dig>  and only batch y can reveal a violation of mr <dig> in gm <dig>  this shows the importance of using various test cases when conducting testing.

the three non-equivalent mutants of seqmap  were tested by the same five batches of test cases used in testing the original seqmap program. the results  shows that our test cases can effectively detect failures in all three mutants. similar to the testing of gnlab, we observe that different sets of mrs are being violated when testing the same mutant with different test cases. also, we note that for each mutant, at least one mr is violated by the test cases.

seqmap and three of its mutants were tested against five batches of test cases, which are labeled as  <dig>   <dig>   <dig>   <dig> and  <dig>  each pair of test cases that detects a violation of a mr in a program is labeled by its batch in the respective cell in the table. for example, the label ' <dig> ' in the cell  indicates that sm <dig> violates mr <dig> according to the test cases in batch  <dig> and batch  <dig> 

discussion
applicability of metamorphic testing in bioinformatics
mt is a general technique to alleviate the oracle problem
the programs we used in our case studies belong to two types of bioinformatics programs that are traditionally very hard to test due to the lack of a tangible oracle. for instance, the current approach to test a network simulator involves visual inspection of the simulated values as well as comparison among multiple implementations of a simulator  <cit> . therefore it tries to tackle the oracle problem by using multiple implementations. such multiple implementations are often hard to acquire in practice, and the results of such testing may be hard to interpret when different implementations give different results. our approach for alleviating the oracle problem is through verifying relationships among multiple test cases. as demonstrated by both of our case studies, as well as many previous studies  <cit> , mt is effective for testing programs that are traditionally difficult to test due to the oracle problem. this allows mt to be applicable for testing various bioinformatics programs in which the oracle problem exists.

mt can test a program against its intended behaviour
for any program, mrs can be derived from the intended program behaviour or the program specification. as demonstrated in our case studies, all mrs are based on the intended program behaviour , and they do not make use of the details of the implementations . based on the ten mrs derived from the intended behaviour of a grn simulator, we found a fault in gnlab. as explained in the results section, this fault is due to the mis-specification of algorithm instead of a bug in the implementation. this means, if test cases were derived from the specification alone, this fault may not have been detected. we believe this ability to test a program against its intended behaviours is very important in bioinformatics, as it allows us to focus our testing effort on assessing whether the underlying biological questions are being tackled correctly. of course, we can easily derive mrs from program specification as well.

mt can be combined with special test cases
it should be emphasized that mt is a general testing technique for the situations where there is no tangible oracle. it can be used to generate a large amount of test cases based on an existing set of test cases. for example, we can easily construct some artificial short sequence reads with predefined mismatch patterns for the testing of seqmap. such special test cases are useful and should be used as far as possible. however, special test cases only cover a small portion of all possible inputs, and we still need more test cases whose testing results are not easy to verify. a straightforward method is to combine mt technique with special test cases. this can be done by using each special test case as a source test case to generate follow-up test cases based on some mrs. such an approach has been shown to be very effective in detecting non-trivial faults  <cit> .

mt is simple and automatable
as demonstrated through the two case studies, the process of mt is straightforward. different subsets of behaviours of the target program can be tested by employing different mrs. once the mrs are identified, test cases can easily be automatically generated and their outputs can be verified using simple scripts. a single program can have a great number of mrs, and various follow-up test cases can be defined based on one single source test case. moreover, the simplicity of mt allows us to perform systematic automated testing using a simple test script. the use of simple test script is important to minimize the chance of introducing bugs into the test script itself, which can subsequently confound the interpretation of the testing result.

mt allows the use of real inputs as test cases
one implication of the ability to automatically generate more test cases is that we can now use real-life program inputs as test inputs. in the mt framework, it is easy to treat a real-life input as a source test case, and generate many follow-up test cases using a set of mrs. for programs that lack a tangible oracle, test cases are usually restricted to those that can easily be constructed and verified. such test cases may not have the same size and characteristics as the real-life program inputs. for instance, testing of real-life input is often not possible for most network simulators since we have no objective means to verify the large amount of simulation results. using mt, such difficulty is alleviated by testing the outputs against a set of mrs instead of the oracle. in our case study of gnlab, we can construct test cases based on two real-life grns which are much larger and complicated than the randomly generated ones. many bioinformatics programs deal with high-throughput data, therefore the ability to test whether they can correctly handle such real-life inputs is important.

mt is suitable for bioinformatics programmers
compared to many other testing techniques, mt is much easier to implement in practice because it relies mainly on user domain knowledge rather than software testing knowledge. many bioinformatics programs are developed by the end-user – the researcher or research group who uses this program. chen et al.  <cit>  have demonstrated that mt is particularly suited to test end-user programmers' own programs because  "end-user programmers have the domain knowledge to identify mrs" and  "end-user programmers can distinguish good mrs based on program structures"  <cit> . in the gnlab example, we only identified and used some mrs related to the structure of the input networks because our domain knowledge points out that changing the network structure should induce the most changes in the execution of the simulator. other properties related to the execution of the simulation, such as length of simulation and output interval, are not covered by the mrs. this feature of mt allows the tester to focus most of the testing effort on the subset of functionalities that are more important, or more frequently used by its intended users.

mt is useful for testing diverse types of programs
although both programs used in our case studies implement deterministic procedures, some initial results show that mt can also be used for testing other types of procedure that are traditionally difficult to test, such as heuristic methods, machine learning methods, stochastic methods and so on  <cit> . since many bioinformatics programs implement such procedures, we expect mt to be applicable to them.

limitations
it should be noted that satisfying all test cases based on a set of mrs does not guarantee the correctness of the program under test. mrs are necessary properties, hence satisfying all of them is not sufficient to guarantee program correctness. this problem is, in fact, a limitation of all software testing methods. nonetheless, the ability to systematically produce a large number of test cases should increase our chance of detecting a fault in the target program, and hence improve its quality.

as this paper focuses on introducing the application of mt in bioinformatics, there are other issues related to mt that are not explicitly discussed here. first, the success of mt greatly depends on defining a "good" set of mrs. from the testing results of gnlab and seqmap, we observe that some mrs are less effective in detecting faults than others. in particular, we note that all mrs based on adding and removing nodes from a network is not effective in detecting faults in our fault-seeded mutants of gnlab. so far in this paper, we have not explicitly addressed the issues of selecting effective mrs. some initial results suggest that those mrs which trigger different execution paths for the source and follow-up cases are more likely to reveal faults  <cit> . this means, although deriving mrs is usually straightforward, selecting the most effective mrs requires good understanding of the problem domains. more specific guidelines in choosing mrs is being actively investigated. second, the mt technique itself does not specify how source test cases should be selected given a set of mrs. we have used randomly generated inputs and real-life inputs for generating source test cases in our study. however, as shown in our case studies, the performance of mt also depends on the number and variety of source test cases. we expect that mt can be combined with other established test case selection techniques to improve the fault-revealing ability.

further examples in bioinformatics
beside programs for network simulation and short sequence mapping, we notice that many other bioinformatics programs can benefit from mt. here we briefly discuss how the testing of programs from several important bioinformatics domains suffer from the oracle problem, and how mt technique can be used in each case. the list of applications presented here is by no means exhaustive. only very simple mrs are pointed out here as we are not discussing any particular detailed problem description. in general, more complex, and potentially more fault revealing, mrs can be formulated based on a more thorough understanding of the problem domain or program specification  <cit> .

phylogenetics
one major endeavor in phylogenetics is to infer the phylogeny  of some species based on their aligned nucleotide or amino acid sequences  <cit> . there are three main approaches to phylogenetic inference:  parsimony methods,  distance based methods,  model based methods. broadly speaking, all methods aim to group these species into a binary tree according to different measures of sequence relatedness. we commonly analyze large number of long bio-sequences. also, many of these methods involve calculating distance matrix, or computing maximum-likelihood estimates, which are difficult to verify except for trivial inputs. therefore the testing of phylogenetic inference programs suffers from the oracle problem.

let us denote a program that performs phylogenetic inference as p. the input of p is a set of n aligned sequences s = {s <dig>  s <dig>  ..., sn}, and the output is a binary tree t. one possible mr is that adding a sequence, sn+ <dig>  would not change the relative structure of the rest of the tree. that is, the trees generated by the source case t and the follow-up case t only differ by one additional leaf node representing sn+ <dig>  for a p that treats each alphabet independently and equally, we can define another mr: replacing, or permuting, the alphabet of the sequence with one another  does not change the final structure of the tree. that is, t = t) where permute is an alphabet permutation function.

microarray analysis
microarray analysis has become an indispensable tool in modern biological and medical research. many types of analyses are available for analyzing microarray data. they include differential expression   <cit> , differential variability   <cit> , hierarchical clustering  <cit> , gene set enrichment analysis  <cit>  and bayesian network analysis  <cit> . due to the difficulty in analyzing the high dimensional input , and often also the high dimensional output , the correctness of the implementation is often difficult to verify. in this case, mt technique can be useful. let us take the identification of de genes between two sample classes as an example. one simple approach is to use the t-statistics to obtain a p value for each gene based on a two-sided hypothesis, and call the genes with p less than a pre-specified threshold significant de genes. since t-statistics is shift independent, we can define a mr that adding a constant value to all values in the input microarray profile does not alter the resulting list of p values. the second mr is that switching the class label of the samples also does not alter the resulting p values as the t-distribution is symmetrical.

biological database retrieval
many biomolecular databases are available, and most of them are built to support fast data retrieval and database mining  <cit> . one major challenge is to ensure that we can accurately and efficiently retrieve the desired data item from the database. this is particularly important as we begin to construct large scale gene regulatory networks and metabolic networks using these databases. invalid retrieval results may lead to a false positive or false negative edges in a reconstructed network. due to large size of the database, it is generally difficult to test if a search engine can correctly retrieve all data that exactly match a query. a potentially suitable mr is that a query a ∩ b ∩ c should not contain more results than query a ∩ b. another mr is that executing the query ¬ should have the same effect as executing the query  ∩ . many more mrs along this line are possible.

CONCLUSIONS
issues related to proper software testing have been largely overlooked in the bioinformatics community. as discussed in this paper, systematic testing of many bioinformatics programs is difficult due to the oracle problem, that is, it is very difficult to verify the testing results of these programs. in this paper, we propose to apply an innovative software testing technique, metamorphic testing , to test these bioinformatics programs. as a case study, we applied the mt technique to test a network simulator and a short sequence mapping program. the results demonstrate that mt is simple to implement, and is effective in revealing faults in a program.

we believe that our work have significant contributions. as far as we are aware, this is the first paper that systematically discusses the oracle problem in testing bioinformatics programs, and how it can be alleviated. as biologists increasingly rely on the results produced by these bioinformatics programs, it is crucial to ensure that they are of high quality. we wish this paper can raise the awareness of proper software testing practice in the bioinformatics community.

