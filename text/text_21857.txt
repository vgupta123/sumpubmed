BACKGROUND
the canonical or standard genetic code is redundant since the  <dig> possible codons encode only  <dig> labels, the  <dig> amino acids present in proteins and the “stop” signal that defines the end of the protein translation process. the canonical code, although prevailing in complex genomes, is not universal. the existence of other different codes, like the one of mitochondrial dna, altered the “frozen accident”, as coined by crick  <cit> , so extensive research has been performed in order to analyze the reasons behind the establishment of the canonical genetic code.

there are three main theories about the genetic code organization and development, which could have influenced the canonical code organization. the stereochemical theory states that the stereochemical interactions between bases and amino acids influenced the primordial code, probably in the rna world or earlier  <cit> . thus, the physicochemical affinity between amino acids and the cognate codons determined the codon assignments  <cit> . the second one is the coevolution theory  <cit> , which maintains that at an early stage of the genetic code development few precursor amino acids were encoded. the other amino acids  developed biosynthetically from such precursor amino acids and these initial amino acids passed part or their whole codon domain to their biosynthetically produced amino acids. finally, the error minimization theory or physicochemical theory considers the minimization of point mutation adverse effects as the main selection factor in the evolution of the code  <cit> .

according to this last theory, the genetic code structure evolved to maximize its robustness, that is, to minimize the consequences of code mutations on the function of the encoded proteins  <cit> . in favor of this theory is the fact that similar codons encode amino acids with similar chemical properties: the codons that share two bases tend to code amino acids with similar hydrophobicity.

in this last alternative, a huge number of alternative “genetic codes” are possible. the number of possible alternative codes is  <dig> · <dig>  <cit> , when each amino acid is coded by  <dig> codons at maximun . if only permutations of the amino acids encoded in the  <dig> codon sets of the canonical code are allowed, there are 20!  possible codes. this alternative, which maintains the canonical codon set structure, is the most used in the studies regarding the error minimization theory. finally, more than  <dig> · <dig> codes can be defined, when no restrictions in the associations between the  <dig> codons and the  <dig> meanings are considered  <cit> .

in this error minimization theory, the efficiency or optimality of a code is defined taking into consideration the possible errors or mutations in the codon letters. typically, all the point mutations in the codons are applied to quantify the change between the encoded amino acids before and after each point mutation. that change is measured taking into account an amino acid property, the polar requirement property being the one most used. once such changes are averaged over all the possible mutations, the lower that error value of a code the more efficient or optimal is the corresponding code, since it means smaller phenotypic changes in the encoded proteins when mutations happen.

moreover, two different analyses were considered to assess the optimality or adaptability of the canonical genetic code. in the first one, named “statistical analysis”, many randomly generated codes are defined and then the probability of more efficient random codes with respect to the canonical one is quantified. the lower this probability the more optimized is the canonical code. according the authors that follow this analysis , the pattern of codon assignments of the canonical code appears nearly optimal.

for example, in this statistical approach, freeland and hurst  <cit>  used alternative codes with the same codon set block structure of the canonical code. in an ample sample of  <dig> , <dig> possible alternative codes only  <dig> codes were more efficient than the canonical code . this low number of random better codes allows the authors to state that the canonical genetic code evolved under the selection of the error minimization. moreover, when the authors weighted transition mutations differently from transversion mutations, only  <dig> in every million randomly alternative codes was better than the canonical genetic code, as the article title states  <cit> .

extensions of these initial works include the analyses by gilis et al.  <cit> , where the authors considered the role of amino-acid frequencies in the efficiency of the canonical genetic code, and the work by torabi et al.  <cit>  who have experimented with the role of aminoacyl-trna synthetases in decreasing the effects of mistranslations in the code evolution. along this line, zhu et al.  <cit>  also took into consideration the codon usage of individual species in the code optimization for error minimization and marquez et al.  <cit>  checked whether organisms optimize the genetic code at the same time that the codon usage.

the second approach to assess code efficiency is the “engineering approach”  <cit> . first, the most efficient code is found, typically by a computational search method. afterwards, the error value of the canonical code is compared with the average error value of randomly generated codes and the error value of the best obtained code. the relative position of the canonical code error value with respect to the others provides a measure of the optimization level of the canonical code. the results with this approach show that the canonical code is not so close to the optimal as the statistical approach claims. the authors in  <cit>  have discussed and debated these two alternatives.

for example, in this engineering approach, according to di giulio  <cit> , the canonical genetic code achieved  <dig> % minimization of polarity distance when comparing the error value of the canonical code with the error values of random codes defined with the same codon set structure of the canonical one and with the value of the best possible code . the best code  was obtained by di giulio  <cit>  using simulated annealing. novozhilov et al.  <cit> , in order to investigate the optimization of codes for the maximum attainable robustness, used also a greedy minimization algorithm for searching better alternative codes. their search method employed swaps of four-codon or two-codon series, in alternative codes defined with the same block structure and the same degeneracy degree of the canonical code. according to the authors’ results, the canonical code is much closer to its local fitness minimum than the majority of the random codes with similar robustness to the canonical one.

following other alternatives, gardini et al.  <cit>  focused their analysis on searching clues for the canonical code robustness. given the dependence of protein function on the tridimensional structure conformation, they took into consideration the function of amino acids in their specific structural environment, analyzing the role of each amino acid in inner or outer regions of the protein structure. in their work  <cit> , the protein data bank ample information was used through a structural bioinformatics approach to search for unambiguous clues of the rationale of the canonical genetic code in assigning from one to six different codons for the different amino acids. for example, leu and arg offer a clear clue, since both appear in the canonical code with six assigned codons, therefore with a high protection from translational errors, and those also appear as the most abundant amino acids in protein-protein and protein-nucleic acid interactions.

our work is focused on the error minimization theory. previously, we have used a genetic algorithm , as a search method for finding better adapted codes than the canonical one  <cit> . the ga provides a global search in the fitness landscape associated with the adaptability of possible hypothetical codes, allowing to obtain clues about the difficulty to obtain better optimized codes. moreover, we also employed a model of alternative codes which reflects the known codon reassignments  <cit> . in line with the engineering approach, our results with simulated evolution revealed that the canonical code is far from the best possible optimized codes. extending our previous work  <cit> , oliveira et al.  <cit>  also proposed a multiobjective approach since two or more objectives were simultaneously optimized. they used as objectives code robustness against mutations, considering the changes in the polar requirement of amino acids , and code robustness with respect to the hydropathy index or molecular volume changes under mutations of possible hypothetical codes . the comparison between the evolution with only one objective and the use of a multiobjective evolutionary algorithm shown that the multiobjective alternative obtains optimized solutions closer to the canonical genetic code. moreover, oliveira and tinós  <cit>  proposed a function which uses entropy with the aim to increase the variability in the number of codons assigned to amino acids. that is, the effects against mutations of a code should be minimized while its entropy should be maximized. with this consideration, their results also indicate that the canonical genetic code is slightly better optimized with respect to not using the entropy term. also, blaŻej et al.  <cit> , inspired by our work with the adapted ga  <cit> , analyzed the effectiveness of using various combinations of mutation and crossover probabilities under three models of the genetic code, assuming different restrictions on its structure.

in evolutionary computing, the so-called “fitness sharing technique”  <cit>  is a “niching” method that allows the evolutionary algorithm search to be simultaneous performed in different areas  corresponding to different local  optima, that is, the technique permits the identification and localization of multiple optima in the search space. it should be noted that the optimization of the code adaptability turns into a minimization problem, where the “code fitness” or adaptability is inversely related to the error cost of a code . in the present work, the fitness sharing technique is introduced into the evolutionary algorithm, which allows the extent to which the canonical genetic code is in an area corresponding to a deep local minimum to be easily determined, even in the high dimensional spaces considered.

it is clearly not difficult to discern whether the canonical code is in a local minimum regarding the fitness landscape associated with the code adaptability. it is only necessary to consider the adaptability level in its neighborhood, that is, inspecting the fitness landscape in its close neighborhood. for example, novozhilov et al. found that “the standard genetic code appears to be a point on an evolutionary trajectory from a random point  about half the way to the summit of the local peak”  <cit> . the fitness landscape is clearly rugged  <cit> , but the question to answer in this paper is the following: is the standard genetic code in an area corresponding to a deep and separated local peak in the vast fitness landscape? moreover, another related aspect is about the possible multimodal nature of the fitness landscape. that is, does the landscape, even with its rugged nature with many non-deep peaks, present localized areas of high fitness  separated by low fitness barriers?

the answers to the questions are relevant since many previous works and authors discussed the possibility of the location of the standard genetic code in a local minimum , regarding error cost, to explain its non-optimum adaptability. that information about the general surface of the fitness landscape could provide clues about the difficulty of the possible evolution of the canonical genetic code. since an exhaustive search of the landscape is not possible, evolutionary computing was used to search in the promising areas of the fitness landscape, incorporating the aforementioned useful technique in evolutionary algorithms  in order to obtain clues about the multimodal nature of the fitness landscape and the relative depth of its peaks.

in the rest of the paper the “methods” section details the definitions of the alternative codes, their encoding in the ga population, the ga operators, the fitness definition in the landscape of such alternative codes, the fitness sharing technique as well as the measures used to quantify the canonical genetic code adaptability level. the “results” section expounds the experiment results when the fitness sharing technique is introduced in the ga. finally, the last sections present a discussion of the results and final conclusions.

methods
generation of variant genetic codes
two possibilities of hypothetical codes were considered. the first possibility reflects the current genetic code translation table and is the most used in previous works  <cit> . when hypothetical codes were generated, two restrictions were considered:


the codon space  was divided into  <dig> nonoverlapping sets of codons observed in the standard genetic code, each set comprising all codons specifying a particular amino acid in the standard code. twenty sets correspond to the amino acids and one set to the  <dig> stop codons.

each alternative code is formed by randomly assigning each of the  <dig> amino acids to one of these sets. the three stop codons remain invariant in position for all the alternative codes. moreover, these three codons are the same stop codons of the standard genetic code .




this conservative restriction, which maintains the pattern of synonymous coding found with the standard genetic code, controls, as indicated by freeland  <cit> , possible biochemical restrictions on code variation and the level of redundancy inherent in the canonical code  <cit> ; or, as stated by novozhilov et al.  <cit> , “the premise behind this choice is that the block structure of the code is a direct, mechanistic consequence of the mode of interaction between the ribosome, mrna, and the cognate trna”.

although these authors  indicate that codes with different block structures are not unviable or impossible “but they are likely to be substantially less fit than those with the canonical block structure”, we used a second possibility with the definition of hypothetical codes with only one restriction: three codons for the stop signal are only imposed. the aim of the introduction of this last possibility, also used by di giulio et al.  <cit> , is a comparison between the restrictive and non-restrictive hypothetical codes in terms of optimal values that can be obtained and in terms of location of the canonical genetic code in the fitness landscape associated with these two genetic code models.

genetic algorithm adapted to the problem
evolutionary computing was used for searching for optimal codes. a classical ga  <cit>  with ad hoc operators for our problem was implemented  <cit> . the genetic population encodes possible hypothetical codes, whereas the fitness function is associated with the robustness against base mutations in each code. these aspects are detailed in the following subsections.

encoding
each individual of the genetic population must encode a hypothetical code. in our solution, in the case of non-restrictive codes, each individual has  <dig> positions, which correspond to the  <dig> codons, and each position encodes the particular amino acid associated with the codon . as in  <cit> , the stop signal is defined by three codons in each possible code.

in the case of restrictive codes, each individual has  <dig> positions, which correspond to the  <dig> codon sets, and each position encodes the particular amino acid associated with the codon set. in the encoding of a possible code, there is not a genotype position for the stop signal, since, as mentioned previously, the same codon set of the standard genetic code was used in all the individuals to define the stop signal.

with the non-restrictive codes, the individuals of the initial population correspond with random assignments of amino acids and the stop signal to the  <dig> codons, ensuring that all individuals encode, at least in one position, the  <dig> amino acids, in addition that three codons encode the stop signal. in the case of restrictive codes, the initial individuals are defined by random assignments between the  <dig> amino acids and the  <dig> codon sets.

genetic operators
in the case of non-restrictive codes, a mutation operator and a swap operator were used. a mutation changes the amino acid encoded in each of the  <dig> positions, with a mutation probability, to a different one. the mutation does not operate if the amino acid to mutate is the only one in the whole code. these mutations simulate the possible errors in the transcription process from dna to rna and in the translation process when incorrect transfer rnas join a given codon of the messenger rna. from our application point of view, it is the operator that varies the number of codons associated with a particular amino acid.

the other genetic operator is a swap operator which interchanges the contents of two genotypic positions, that is, once two positions are randomly selected, the amino acids  codified by the two respective codons are swapped. the bottom part of fig.  <dig> shows the basic functioning of these operators.
fig.  <dig> genetic operators. upper part: encoding of a genetic code and functioning of the swap operator with the restrictive codes. bottom part: swap operator  and mutation operator  used with the unrestrictive codes




the two operators guarantee that the  <dig> amino acids are always represented in the individuals. other operators, such as the classical crossover operator, do not guarantee this important restriction.

in the restrictive codes case, as commented previously, each individual has  <dig> positions encoding the particular amino acid associated with a codon set present in the canonical code. as also mentioned, a fixed number of three codons are used for the stop label, which are the same used in the canonical code.

the ga only uses a swap operator with the restrictive hypothetical codes. as in the previous case, the operator interchanges the contents of two randomly selected positions . the upper part of fig.  <dig> shows the encoding of a given code and how this operator works.

finally, as the selection operator, the tournament selection was used with both hypothetical codes. the operator selects the best individual in a window of randomly selected individuals from the population. hence, the size of the window determines the required selective pressure. moreover, elitism of the best individual was used; that is, this individual is retained in the next generation without changes.

fitness function and optimality measure
the measure applied, for example, by haig and hurst  <cit>  and freeland and hurst  <cit>  to quantify the relative efficiency of any given code was used as fitness function. the measure calculates the mean squared  change in an amino acid property resulting from all possible changes to each base of all the codons within a given code. any one change is calculated as the squared difference between the property value of the amino acid coded by the original codon and the value of the amino acid coded by the new  codon. the final error is an average of the effects of all the substitutions over the whole code. therefore, the error △  is defined as: 
  <dig> △2=∑i,jwi,jxi−xj2∑i,jnij 


where n
ij is the number of times the i−th amino acid changes into the j−th amino acid, and x
i is the value of the amino acid property of the i−th amino acid. w
i,j is a weight associated with each possible mutation in each letter, which is set as  <dig> in the simple ms measure when an equal transition/transversion bias is considered. the changes from and to “stop” codons are ignored, while synonymous changes  are included in the calculation. thus, the ga works with a minimization problem, where the ms measure is the objective to minimize by the ga operators. therefore, as commented in the introduction, the adaptability or code fitness is inversely related to this error cost measure, since the lower the ms value the better the adaptability.

like most authors, we have used the polar requirement as the amino acid property. the property can be considered as a measure of hydrophobicity and it was introduced by carl woese as a measure for the polarity of an amino acid, which is defined as a partitioning coefficient of an amino acid in a water/pyrimidine system  <cit> .

moreover, the previous equation can take into account the relative frequencies of transition/transversions mutations as well as mistranslations in the different bases. as stated by freeland  <cit> , the unequal chemical similarity of the  <dig> nucleotides to one another means that transition errors  occur more frequently than transversions .

to quantify the relative frequencies of mutations, we employed the rules from  <cit>  used to consider the empirical data, which are summarized as:


mistranslation of the second base is much less frequent than the other two positions, and mistranslation of the first base is less frequent than the third base position.

the mistranslations at the second base appear to be almost-exclusively transitional in nature.

at the first base, mistranslations appear to be fairly heavily biased toward transitional errors.

at the third codon position, there is very little transition bias.



i,j in eq.  <dig> correspond with the particular weights in table  <dig>  therefore, the ms calculation takes into account those rules and, following the same terminology of freeland and hurst  <cit> , we term the ms variant as tms. for example, the ms value of the canonical code is  <dig>  whereas its tms value is  <dig> .



as commented previously, the “engineering approach” compares the standard genetic code with the best possible alternative. the approach uses a “percentage distance minimization” , which determines code optimality on a linear scale, as it is calculated as the percentage in which the canonical genetic code is in relation to the randomized mean code and the most optimized code. it is therefore defined as: 
  <dig> p.d.m.=△mean−△code△mean−△low· <dig> 


where △mean is the average error value, obtained by averaging over many random codes, and △low is the best  △ value.

the measure can be interpreted as the optimization level reached during genetic code evolution  <cit> . for example, as previously indicated, di giulio et al.  <cit>  reported a p.d.m. value of  <dig> % in the case of codes with only amino acid permutations in the  <dig> sets of codons , using a simulated annealing technique for obtaining the value of the best possible code, whereas we reported a p.d.m. value of 71%  <cit> , using a ga for searching for the best possible code.

fitness sharing
fitness sharing is a classical technique in evolutionary computing for dividing the population into different subgroups according to the similarity of the individuals. in this present work this technique is incorporated into the ga. this fitness sharing concept was introduced by holland  <cit>  and extended, for example, by goldberg and richarson  <cit> . the shared fitness for the ith individual is defined as: 
  <dig> fshared=foriginal∑j=1nshdij 


where the sharing function is calculated as: 
  <dig> sh=1−dijσshareαifdij<σshare0otherwise 


being d
ij the distance between individuals i and j, σ
share the sharing radius, n the population size and α a constant called the sharing level.

in this application, the distance d
ij is measured by taking into account the difference in polar requirement between the amino acids encoded in the same positions by code i and code j of the population. it is defined as the root squared deviation between both codes: 
  <dig> dij=∑k=1lxik−xjk2max_rsd 


where max_rsd is the maximum root squared deviation between two possible codes, taking into account the largest and lowest polar requirement values of amino acids . the index k refers to a genotype position and l stands for the length of the genotypes in the individuals . this ensures that distances are always in the range  <cit> . this procedure is the same in both hypothetical codes, except that in the case of unrestrictive codes the genotype positions where one of the codes encodes a stop signal are ignored . note that this definition of distance gives more information about the closeness of two codes than a simple calculation of how many different amino acids are encoded in the same position in the two codes. for example, in this last case, a simple swap of two amino acids in a code  can correspond to different distances regarding eq.  <dig>  depending on the polar requirement values of the swapped amino acids.

finally, if the application requires the minimization of the fitness , instead of its maximization, the formula in eq.  <dig> turns to be a multiplication between the two terms =foriginal·∑j=1nshdij). therefore, the fitness sharing technique increases the objective to minimize  in densely populated regions.

this way, fitness sharing modifies the search landscape by reducing the payoff in densely populated regions. the main drawback of the technique is its complexity, o, because of the calculation of inter-distances. on the contrary, the important property is that fitness sharing tends to encourage searches in unexplored regions of the space and favors the formation of stable subpopulations  <cit> .
b and fig. 2
c. now the individuals are distributed in the peaks with a number that depends on the relative fitness of each peak. using a higher σ
share  the population tends to be more expanded, so it is more difficult to leave a local maximum with respect to the use of a lower σ
share .
fig.  <dig> ga final population distribution to maximize a multimodal function. the function has unequally spaced peaks of nonuniform height. final population, at generation  <dig>  in  <dig> cases: a without fitness sharing. b using fitness sharing with σ
share= <dig> , where the population is clustered around most of the peaks of the multimodal function. c using fitness sharing with σ
share= <dig> , where the population is clustered around the different peaks of the multimodal function



c, the population tends to be distributed in the whole range considered for the encoded parameter x .
fig.  <dig> ga final population distribution to minimize the function 1+x
 <dig>  final population, at generation  <dig>  in  <dig> cases: a without fitness sharing. most of the individuals are close to the optimal value. b using fitness sharing with σ
share= <dig> , with the population expanded around the minimum. c using fitness sharing with σ
share= <dig> , with the population more expanded around the minimum




that is, the interest of the fitness sharing technique is to search in all the promising areas with high fitness found in the landscape, performing a better exploration of the search space. however, the introduction of the technique also has other consequence, because it provides clues about the fitness landscape. in the first chosen example , the distribution of the population reveals the multimodal nature of the fitness landscape, indicating the existence of several local maxima. in the second chosen example, the population is not clustered around local minima, and therefore the population is uniformly distributed around the global minimum and according to the sharing radius. note that this information would not be obtained without the introduction of fitness sharing. these considerations are therefore going to be taken into account in the analysis of the  fitness landscape when searching for hypothetical codes with optimized adaptability.

RESULTS
evolutionary algorithm setup
the implemented ga, with the incorporation of fitness sharing, was tested by searching for optimized codes, using the two code models explained in the previous section. the ga parameters for the different experiments are: population size of  <dig> individuals, mutation probability of  <dig>  and a swap probability of  <dig> . as explained, the restrictive model only uses the swap operator to interchange the  <dig> amino acids among the  <dig> codon sets. on the contrary, both operators are used with the non-restrictive model, where the mutation allows changing the number of codons assigned to an amino acid. tournament selection with a tournament size of 3% of the population was used, which provides a low selective pressure. these genetic parameters are the same as those used in our previous work  <cit> , selected to provide an appropriate balance between exploration and exploitation in the ga search.

regarding fitness sharing, the value of parameter α  was set to  <dig> as it is sufficient to generate the possible clustering of the population into different niches. the sharing radius  was varied to observe its effect on the evolution of possible codes, whereas d
ij was calculated using eq.  <dig> , which considers the root squared deviation between code i and code j of the population, taking into account the polar requirement of the amino acids encoded in each genotype position.

evolution of restrictive codes
in a first experiment, the evolutionary algorithm was used to search for optimized codes, using the model of restrictive codes. figure  <dig> shows the fitness  evolution through  <dig> generations of the genetic algorithm. figure  <dig> includes the evolution without fitness sharing and with two values for the parameter sharing radius . the graphs in fig.  <dig> are an average of  <dig> independent runs of the ga, beginning with different random initial populations. it is not easy to determine the appropriate values to use for the parameter σ
share, since it requires a previous knowledge about the landscape surface to easily obtain the possible clustering of the population into niches in a multimodal fitness landscape. since we have no such a priori knowledge, we experimented with different values for the parameter σ
share, starting with a low value  and also using a larger value  of an order of magnitude.
fig.  <dig> ms evolution through generations with the restrictive codes. all graphs are an average of  <dig> independent ga runs, without fitness sharing and fitness sharing with two values for the parameter σ
share . the graph includes the canonical code ms value for comparison 




the evolution without fitness sharing shows that it is easy to discover better adapted codes than the canonical one. in about  <dig> generations, an average best value of ms= <dig>  is obtained . the p.d.m. value is 71%, taking into account the ms value of the canonical code , the average value of the random codes at the initial generation of the ga and the best value in all the ga runs  <cit> . even the average fitness of the population is lower with respect to the ms value of the canonical code. this shows that it is very easy for the ga to discover better adapted codes with respect to the canonical code, which denotes that the canonical code can be adapted but it is clearly far from the best possible adapted code.

when fitness sharing is considered in the ga evolution with a low sharing radius , the fitness progression is similar but more continuous. the reason is that fitness sharing tends to maintain the individuals at least with a distance of  <dig>  between them, so it is more difficult for many individuals to correspond to the same solution, as can occur without the use of fitness sharing, even with the low selective pressure applied. with a larger sharing radius , the evolution of better codes is logically more difficult, although best values than the canonical code are obtained. the average fitness is now greater with respect to the canonical code and it is slightly variable through the evolutionary generations. this is because when several individuals fall in the same vicinity , their fitness is penalized, and therefore in the next generation other individuals can be selected, which generates the variability in the average fitness. table  <dig> summarizes the basic statistic information about the evolutions of fig.  <dig>  which shows the greater variability of the final results with larger values of the parameter σ
share.
fitness sharing, σ
fitness sharing, σ



nevertheless, these previous graphs of evolution of the fitness do not provide information regarding the fitness landscape in the surroundings of the canonical genetic code. we want to discern whether the canonical code is in an area corresponding to a deep local optimum in the huge search space. figure  <dig> helps to visualize this.
fig.  <dig> ms value of the genetic population codes vs. their distances to the canonical code. the same graph is shown in different generations of a ga run, in  <dig> cases with the restrictive codes: a without fitness sharing, b fitness sharing with σ
share= <dig>  and c fitness sharing with σ
share= <dig> . the canonical code was introduced in the initial population in the  <dig> cases . the green dashed line represents the ms value of the canonical genetic code




the columns in fig.  <dig> correspond with a run of the ga with three cases: in column  the ga was run without fitness sharing whereas in columns  and  the ga was run with fitness sharing with σ
share= <dig>  and σ
share= <dig>  respectively. in fig.  <dig> the x-axis represents the distance of each encoded code in the population to the canonical code, whereas the y-axis corresponds to the ms value of each code. therefore, fig.  <dig> shows this correspondence between the ms value of each code and its corresponding distance to the canonical code in different generations of the ga.

it should be noted that if many individuals fell in the same local minimum, their distances to the canonical code would be similar as well as their ms values, that is, a cluster should be appreciated in the graph. the graphs show that the distances of the different codes of the population with respect to the canonical code vary, in most cases and after the initial generation, in the whole range between  <dig>  and  <dig> , which denotes that the hypothetical codes, more optimized than the canonical code in progressive generations, are far from the canonical code. this fact also indicates that the canonical code is not in an area corresponding to a deep local minimum, since all the individuals are far from it, without any individual close to it, as would occur if the canonical code was close to a deep local minimum . the analyses with different values of σ
share, with a sweep of σ
share in an ample range, between  <dig>  and  <dig>  , indicate the same conclusions.

it would be useful that an individual of the ga fell close to the canonical code, since it would also provide knowledge regarding whether the canonical code is in an area corresponding to a deep local peak. since this is very difficult with the limited number of individuals of the population, in these ga runs, the canonical code was introduced in the initial population. this allows to test whether the canonical code can “survive” in the evolutionary progress towards optimized codes. thus, in the initial generation , there is a point that corresponds to the canonical code with distance  <dig> and ms= <dig>  . the other random codes present different ms values, most of them with larger values than the canonical ms value. nevertheless, at generation  <dig>  the canonical code has disappeared from the population , indicating that it is not competitive with other hypothetical codes with better ms values at that generation. this can be obvious without fitness sharing. however, with fitness sharing, if the canonical code was in an area close to a local minimum, it would be difficult for this code to disappear from the population, as explained previously , since some individuals would remain in a niche that would correspond to that area where the canonical genetic code is located. the fact that the canonical code disappears, even with a large sharing radius, is a second piece of evidence that indicates that the canonical code is not in an area corresponding to a deep local minimum.

to illustrate possible evolved codes and their distances, three alternative codes were selected from the final evolved ones in fig. 5
c . two of those codes correspond with the nearest code  and the furthest code  with respect to the canonical code . the third one  is the code that has the best  ms value in that ga run of fig. 5
c. figure  <dig> shows the codes with the assignments of amino acids to the different codons. in addition, each amino acid is represented with a gray level corresponding to its polar requirement: the brighter the gray level the higher the polar requirement. the stop signal is represented in white. moreover, fig.  <dig> includes the canonical code, which helps to visualize the distance between those codes and the canonical one. for example, the differences in polar requirement  between the amino acids in the same codon positions between the canonical code and code  <dig> are lower with respect to the other cases, and code  <dig> and code  <dig> have assignments of amino acids with similar polar requirement in the same positions. therefore, the distance  between code  <dig> and code  <dig> is low. however, code  <dig> has the minimum ms value since it has amino acid assignments with similar polar requirement where possible mutations in the codon letters change the amino acids. for instance, code  <dig> locates amino acids with very similar polar requirement in its third column , since a mutation in the third codon letter can imply a change between such encoded amino acids.
fig.  <dig> selected evolved codes. three codes were selected from the final population in fig.  <dig> c. code 1: nearest code to the canonical code. code 2: furthest code to the canonical code. code 3: best code. the canonical code is included for comparison. d
code <dig> code2= <dig> , d
code <dig> code3= <dig> , d
code <dig> code3= <dig> , mscode1= <dig> , mscode2= <dig> , mscode3= <dig> 




finally, the previous graphs show the distances of the encoded codes with respect to a “reference point” , but do not show how the different codes are far away from each other. it would also be interesting to know whether the final population is clustered around a small neighborhood of the search space or it is spread in the high dimensional landscape. for this, the inter-distances of individuals of the final population were calculated, and a histogram of these distances is plotted in fig.  <dig>  inter-distances close to  <dig> mean the possibility of a cluster  of the population around a local optimum. in fig.  <dig> the x-axis is sampled in intervals of  <dig> , that is, each of the  <dig> intervals in the x-axis specifies the number of inter-distances of the population in that interval. although the distances are normalized in the interval  <cit>  , it is difficult to obtain inter-distances larger than  <dig> , because it would imply large changes in the polar requirement of the encoded amino acids of the codes, and many amino acids have a similar value of polar requirement.
fig.  <dig> histogram of code inter-distances of the ga final population using the restrictive codes. the histogram corresponds to the final population  in a ga run with three cases: a without fitness sharing, b fitness sharing with σ
share= <dig>  and c fitness sharing with σ
share= <dig> 



share= <dig> , the average quality of the population  is close to the value without fitness sharing , and even when the individuals are far away from each other, it means that there are many distant areas of the fitness landscape with better adapted codes than the canonical one. with a larger sharing radius , the expansion of the population in different and distant areas is more pronounced, as indicated now by the greater inter-distances, where most of them are in a continuous range between  <dig>  and  <dig> . it should also be noted that these inter-distances between the evolved codes are lower than the distances of those codes to the canonical one. it means that the canonical code is far from the area where most of the evolved codes are located. therefore, the fitness landscape seems more like a vast space with a broad transition area to the optimum, in the sense that the results resemble the search of the global minimum in the parabola example of fig.  <dig>  the difference is that now the space surface can be rugged with many non-deep  local peaks.

evolution of non-restrictive codes
we repeated the analysis with the model of unrestrictive codes. the number of possible codes is now close to  <dig>  <cit>  with respect to the previous case . the huge increase in the possible codes will allow to check whether the same conclusions are obtained with respect to the previous case. once more, fig.  <dig> shows the evolution across  <dig> generations of the ga with the same setup as in the previous case, except that now both genetic operators  are used. the evolution graphs correspond again to an average of  <dig> independent runs of the ga with different initial populations.
fig.  <dig> ms evolution through generations with the unrestrictive codes. all graphs are an average of  <dig> independent ga runs, without fitness sharing and fitness sharing with two values for the parameter σ
share . the horizontal line shows the canonical code ms value




the same conclusions can be obtained with respect to the restrictive codes case. now all the evolutions are more continuous, given the larger possibilities of codes and landscape areas to explore. the evolution without fitness sharing obtains a possible best code that is more optimized with respect to the use of restrictive codes. this is because the ga has more possibilities to search for adaptive codes against base mutations. taking into account the average ms value of random codes and the best value of the ga runs, the p.d.m. value is 67%  <cit> , meaning that the canonical code is less optimized  with respect to the previous case . this is logical, since the restrictive codes impose constraints to obtain optimized codes. table  <dig> summarizes the statistic information regarding the evolutions of fig.  <dig>  which shows a slight increase in the variability of the final results with larger values of the parameter σ
share.
fitness sharing, σ
fitness sharing, σ



in the analysis of a variety of the best non-restrictive codes, the amino acids that appear in most of the codons have an intermediate value of polar requirement. this helps to minimize the ms error, when most of the mutation changes are among the intermediate values. it is the same idea expressed by di giulio  <cit> , when the author used a simulating annealing algorithm to find optimized non-restrictive codes. as the author stated “by maximizing the number of synonymous changes in the code, it is reasonable to suppose that the objective function value is taken towards the absolute minimum”  <cit> . for example, the author obtained a best code with  <dig> synonymous codons to one amino acid, one codon to the remaining nineteen amino acids, in addition to the three codons for the termination meaning. however, in our case, the global search of the genetic algorithm finds optimized codes with a more balanced number of codes per amino acid, where only the amino acids with extreme values of polar requirement are associated with only one codon.
share, in an ample range between  <dig>  and  <dig> , present the same evidence, so these are not shown in the figures.
fig.  <dig> ms value of the genetic population codes vs. their distances to the canonical code. the same graph is shown in different generations of a ga run, in  <dig> cases with the unrestrictive codes: a without fitness sharing, b fitness sharing with σ
share= <dig>  and c fitness sharing with σ
share= <dig> . the canonical code was introduced in the initial population in the  <dig> cases . the green dashed line represents the ms value of the canonical genetic code




the same previous analysis considering the inter-distances of the final population was performed in order to detect how far such final optimized solutions are, that is, how many areas are being simultaneously searched even when the evolutionary process is ended. note that the inter-distances can have greater values with respect to the previous case with restrictive codes, since the differences between the extreme values of the polar requirement can occur more times with the unrestrictive codes . figure  <dig> shows that the codes are further away from each other as the sharing radius becomes larger. in fig. 10
a, without fitness sharing, some individuals correspond with the best solution . when fitness sharing is used, there are very few solutions corresponding with the best code. figure 10
b, using a low sharing radius , shows that the inter-distances are slightly larger, therefore the individuals are further away from each other with respect to the case without fitness sharing, that is, the final population is more expanded through the fitness landscape. with a larger sharing radius , the expansion of the population through the fitness landscape is clearly more pronounced, as can be seen with the high increase of the inter-distances, most of them being between  <dig>  and  <dig> . even with the expansion of the population in distant areas of the fitness landscape, the average quality is better than that of the canonical code . consequently, the conclusion is again that the fitness landscape does not present a multimodal nature, since there is no niching or clustering effect of the population in promising areas.
fig.  <dig> histogram of code inter-distances of the ga final population using the unrestrictive codes. the histogram corresponds to the final population  in a ga run with three cases: a without fitness sharing, b fitness sharing with σ
share= <dig>  and c fitness sharing with σ
share= <dig> 




introduction of transition/transversion and translational biases
previous works  <cit>  have demonstrated that the canonical code has better adaptability levels when the code fitness takes into account the different probabilities of transition and transversion mutations, together with the mistranslation of mrna, which implies different probabilities of mutations in the three codon bases. for example, using tms , in  <cit> , with the restrictive codes case, the p.d.m is 84%. the comparison of this value with respect to the use of ms as fitness  means that the canonical genetic code is better adapted when the tms calculation is taken into account. consequently, a test was conducted to check whether these considerations in the tms error measure imply a change in the fitness surface nature.
fig.  <dig> histogram of code inter-distances of the final population and using the restrictive codes with tms. the insets show the tms value of the hypothetical codes of the genetic population vs. their distances to the canonical code. the green dashed line represents the tms value of the canonical genetic code. each subfigure corresponds with the histograms of inter-distances of the final populations. the graphs correspond to the final population  of a ga run in  <dig> cases: a without fitness sharing, b fitness sharing with σ
share= <dig>  and c fitness sharing with σ
share= <dig> 




the comparison with the previous cases using ms as objective to minimize  shows that the inter-distances are quite similar when tms is used. for example, the comparison between the histograms in figs.  <dig> and  <dig> shows how the inter-distances are similar using tms in the three cases  without significant variations. however, the distances of each code with respect to the canonical code are now lower. using tms these distances to the canonical code are between  <dig>  and  <dig> , with a larger interval with greater values of σ
share. in the case of using ms, these distances were between  <dig>  and  <dig>  , also with greater intervals with larger values of σ
share. this means that the incorporation of tms implies that the optimized codes are closer to the canonical code, showing again better adaptability of the canonical code considering tms. however, even with the improvement of adaptability when considering tms, the final solutions are far from the canonical code while the population is extended across an ample area of the fitness landscape, and without any presence of clear niches in the landscape.
share. thus, although the final codes are similarly extended in the search space using tms or ms, the codes of the final population are closer to the canonical code using tms, which is a further evidence of the better optimization of the code considering tms.
fig.  <dig> histogram of code inter-distances of the final population and using the unrestrictive codes with tms. the insets show the tms value of the hypothetical codes of the genetic population vs. their distances to the canonical code. the green dashed line represents the tms value of the canonical genetic code. each subfigure corresponds with the histograms of inter-distances of the final populations. the graphs correspond to the final population  of a ga run in  <dig> cases: a without fitness sharing, b fitness sharing with σ
share= <dig>  and c fitness sharing with σ
share= <dig> 




discussion
an adapted genetic algorithm for searching for possible alternative genetic codes better adapted than the canonical code was used in this work. the results of the ga clearly indicate that there are many alternative codes with a better adaptability than the canonical one, being the canonical code relatively far from the best possible adapted one. however, another question to explore is whether the canonical code is in an area corresponding or not to a deep local minimum in relation to the vast fitness landscape, which has been continuously discussed in previous works. this is the issue that has been explored in this work.

as indicated in the introduction, this is not the same as discerning whether the canonical code is in a local peak  regarding its immediate neighborhood. as stated by novozhilov et al. “the fitness landscape of code evolution appears to be extremely rugged, containing numerous peaks with a broad distribution of heights, and the standard code is relatively unremarkable, being located on the slope of a moderate height peak”  <cit>  . instead, our aim was to discern about the nature of the vast fitness landscape, inspecting whether it is a multimodal landscape with clear niches, with separated and deep broad ms peaks, together with the location of the canonical code in such a huge landscape.

as explained, due to the huge dimensionality of the search landscape, the incorporation of the fitness sharing technique in the evolutionary algorithm helps to determine and visualize whether the alternative codes, as well as the canonical code, are in an area corresponding to a deep local minimum.

the limitations of the fitness sharing technique are well-known, and basically entail that: i) setting the dissimilarity threshold  requires a priori knowledge of how far apart the optima are and ii) the complexity per generation is o as a consequence of the distance calculations. even with the complexity drawback, the technique was used because it helps to visualize the fitness landscape . in order to overcome the first limitation, an analysis with different sharing radii was performed.

in the discussion about the location of the canonical code, the general idea is to consider that the canonical code was trapped in a local minimum. for example, according to crick “there is no reason to believe, however, that the present code is the best possible . instead, it may be frozen at a local minimum which it has reached by a rather random path”  <cit> . or, as knight et al. state “although search algorithms can sample billions of different codes, evolution is unlikely to have had similar opportunity given the extreme cost of changing an already functional code, and so we might either expect the code to be trapped at a local, rather than global, optimum”  <cit> .

the engineering approach for obtaining better adapted codes was used in our work, since a computational search method was employed for obtaining possible better adapted codes than the canonical one. on the other hand, in the statistical approach, its main idea is that the standard code minimizes hydrophobicity errors far more than can be explained by chance. we are not in disagreement with this idea since the code is more optimized with respect to random codes, but at the same time our analysis indicates that the code is clearly far from possible optimal codes. some authors within the statistical approach, such as freeland  <cit> , have argued against the engineering approach bases because the criticisms about the fact that the canonical code is far from optimal “overlook the fact that we know very little about the connectivity or accessibility of local and global optima for patterns of codon assignment”. nevertheless, the present study helps to visualize the possible formation of local minima in the fitness landscape, indicating that the canonical genetic code is not in an area of a broad and deep local minimum, since it is not captured in a niche with the fitness sharing technique.

note that our objective was not to explain the possible evolutionary paths to the canonical code. our objective was only to locate the canonical genetic code in the fitness landscape when possible hypothetical codes are considered, from an scenario of hypothetical codes without restrictions in the assignments to the consideration of restrictive hypothetical codes with the same codon set structure as the canonical genetic code. moreover, the fitness landscape depends also on the definition of the fitness function, that is, how the adaptability level of a code is measured. we considered the basic property, the polar requirement of amino acids, the most used one in previous studies, in order to define the fitness landscape, since it is the main property for the folding of a protein and consequently to define its protein function. in this sense, freeland is correct in the criticism “the evolutionary similarity of amino acids  is unlikely to be perfectly represented by a single physiochemical measure  or indeed by any simple combination of two or three such indices”  <cit> . this analysis with other amino acid properties has been performed in several previous works  <cit> . for example, when different amino acid properties  were employed, the results in  <cit>  indicated that polar requirement is the property that provides the most significant evidence of error minimization. thus, we have included only the most meaningful analysis with the polar requirement property.

CONCLUSIONS
the conclusions obtained in this study can be briefly summarized as follows:

 <dig>  the canonical code is better optimized with respect to random codes, when the effects of mutations are taken into account within the error minimization theory. however, the ga search indicates that the canonical code is far from the best possible codes.

 <dig>  when the fitness sharing technique is introduced in the ga search, it indicates that there are no clear niches in the vast fitness landscape, that is, localized areas of high fitness  separated by barriers of low fitness . this is not in contradiction with the rugged nature of the fitness landscape. for example, novozhilov et al. stated that a huge number of taller fitness peaks  exist in the landscape  <cit> . on the contrary, the results in this study denote that there are many connected areas  with higher fitness than the canonical code, as inferred from the results of the distances of the optimized codes with respect to the canonical code and the inter-distances between the optimized codes of the ga final populations. that is, the fitness landscape is rugged but does not have a multimodal nature with clear and deep niches separated by fitness barriers. this explains why any search algorithm easily discovers better adapted codes than the canonical one.

even when the canonical code shows better adaptability levels when the code fitness takes into account different weights for transition and transversion errors in the different codon bases, together with the mistranslational error weights in the three codon bases  <cit> , the same conclusion about the multimodal nature of the fitness landscape is obtained when such biases are considered.

 <dig>  the canonical code is clearly far away from those areas of higher fitness in the landscape. given the non-presence of deep local minima in the landscape, although the code could evolve and different forces could shape its structure, the fitness landscape nature considered in the minimization theory does not explain why the canonical code ended its evolution in a location which is not an area of a localized deep ms minimum of the huge fitness landscape.

abbreviations
gagenetic algorithm

msmean squared

p.d.mpercentage distance minimization

tmsmean squared considering transition/transversion and translational biases

