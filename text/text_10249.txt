BACKGROUND
causal graphs are a convenient representation of causal relationships between variables in a complex system: variables are represented by nodes in the graph and relationships by directed edges. in many applications the edges are also signed, with the sign indicating whether a change in the causal variable positively or negatively affects the second variable. causal graphs can serve as predictive models, and conclusions can be drawn from comparing the models' predictions to experimental measurements of these variables. pollard et al.  <cit>  pioneered the use of large-scale causal graphs to interpret gene expression data and the approach has been used successfully in several contexts  <cit> . we present our own causal reasoning approach in our companion paper  <cit> ; here we give a brief overview.

published research in biology provides a wealth of regulatory relationships within the cell that we mine to produce a causal network. the edges in this network are directed  and signed . directed paths within the network thus predict putative upregulation and downregulation that would be effected downstream by changes in the level of a given entity . our companion paper  <cit>  shows that this reasoning can be applied to the inverse problem: given data from a gene expression assay, our causal network enables us to infer potential upstream causes for the measured gene expression changes. the key output of the method is a list of upstream hypotheses that explain a large fraction of the observed changes in a statistically significant manner. as hypotheses are based on existing literature, they are easily interpretable by biological experts and can provide building blocks for a more comprehensive understanding of causal drivers of the processes under consideration. figure  <dig> provides a schematic of the approach.

in this paper, we study the problem of evaluating statistical significance of the conclusions drawn from a causal graph-based model given a particular gene expression dataset. to form a null distribution, either the correspondence between gene transcripts and experimental expression values or the connectivity of the graph can be randomized. thus, the statistical significance question splits into two subproblems. first, how likely is it for the same level of agreement between predicted and observed regulation to be achieved when the classification of gene transcripts  is randomly drawn from a family of all classifications with similar characteristics? second, how likely is it to occur when the causal graph is randomly drawn from a family of all causal graphs with similar characteristics?

answering the first question amounts to computing the distribution of the dot product of two vectors with components in {- <dig>   <dig>  1}, each drawn randomly from the family containing all such vectors with a fixed number of components of each value. this problem, which we call ternary dot product distribution, generalizes fisher's exact test  <cit>  to ternary variables and we thus believe it is of independent interest. fisher's exact test is ubiquitously used in gene set enrichment analysis and many other areas of computational biology  <cit> . this test is appropriate to assess statistical significance of enrichment in many settings but neglects the sign of differential regulation. in many cases, the sign of the regulation is available and could be harnessed to obtain additional insights. one example where our proposed extension is directly applicable is as an alternative scoring mechanism for the well-known connectivity map approach  <cit> .

answering the second statistical significance question analytically does not appear to be possible, but the desired likelihood may be approximated by sampling uniformly at random from the family of all causal graphs with the same basic structure as the original causal graph: namely, the same positive and negative in- and out-degrees of each vertex. because of the structure of the problem, even drawing one causal graph from this family is challenging. we call this the causal graph randomization problem. previous work on the problem of graph randomization has focused on undirected graphs  <cit> ; the context of directed graphs is less well-studied theoretically  <cit>  despite finding many uses in bioinformatics  <cit> .

the rest of this paper is organized as follows. we begin by describing the regulatory network model based on causal graphs and discuss the way conclusions are drawn from it and the importance and subtleties of computing their statistical significance. we then describe the ternary dot product distribution problem and present two efficient algorithms to solve it: an algorithm with complexity cubic in the number of variables  in the graph but requiring computation in exact arithmetic, and an algorithm with a weaker complexity guarantee but numerically stable and efficient in practice. finally, we discuss the challenges of the causal graph randomization problem and present a practical algorithm for it using local graph operations, and conclude by describing future work.

model description
the two fundamental properties of causal relationships between biological entities are  the direction of causality between them; and  the qualitative response  of the second entity when the first one is upregulated or downregulated. this information can be encapsulated in a signed directed graph g =  whose nodes v are genes, transcripts, compounds, or biological processes, and where a directed edge from node a to node b means that the abundance or activity of b is regulated by the abundance of a. the edge  is labeled with a "+" sign if the regulation is positive , and it is labeled with a "-" sign if the regulation is negative. we call g a causal graph.

for any two nodes a and z not necessarily connected by an edge, the causal graph g models the effects of a change in the abundance of a on the abundance of z by tracing the shortest directed path from a to z in g and then evaluating its sign, given by the product of the signs of the edges along the path. if this overall sign turns out to be a plus sign, it is expected that a upregulates z, and if it is a minus sign, that a downregulates z  <cit> .

hypothesis scoring
given a gene expression dataset, we may classify gene transcripts into three families: significantly upregulated, significantly downregulated, and not significantly regulated. we refer to this classification as the experimental classification. we wish to understand what perturbations may have led to these observations.

given a particular entity v ∈ v in our causal graph, we can examine the predicted effects of upregulating or downregulating it. we call v together with the direction of perturbation a hypothesis. this hypothesis also classifies the gene transcript nodes in the graph into three families: those predicted to be upregulated by the perturbation of v, those predicted to be downregulated by the perturbation of v, and those not predicted to be regulated by v. we refer to this classification as the predicted classification.

in order to evaluate the goodness-of-fit of a particular hypothesis to the observed gene expression dataset, we declare a prediction to be correct if the predicted sign matches the experimental sign and the regulation was significant: i.e., both signs are + or both are -. in case of a mismatch , we declare the prediction to be incorrect. in all other cases, we declare the prediction to be ambiguous. we may now score a hypothesis by awarding  <dig> point for each correct prediction, - <dig> for each incorrect prediction, and  <dig> for each ambiguous prediction.

statistical significance
the scores computed for each putative hypothesis provide us with an overall ranking of all hypotheses. however, a good score does not necessarily imply good explanatory power, because of possible connectivity differences between the transcript nodes of g. in particular, "hubs" with high degree are more likely to have higher scores regardless of which genes are experimentally observed to be significantly regulated. therefore, we also need to look at the statistical significance of each score when the gene expression data is randomized, preserving the number of upregulated and downregulated gene transcript nodes, but not the nodes themselves.

in addition, we need to understand how significant the rank of a hypothesis is with respect to another null model, in which the gene expression data remains fixed but the causal graph is allowed to vary, only keeping basic connectivity properties. more specifically, we examine the rank of a hypothesis of interest in the family of graphs with the same sequence of positive and negative in-degrees and out-degrees as g, but randomly connected otherwise. if these degrees rather than the full structure of g suffice to give a hypothesis of interest a good rank, this hypothesis should not be deemed statistically significant.

illustrative example
to build intuition for the proposed method we outline an example application based on previously published experimental data  and a large-scale causal network containing approximately  <dig>  unique relationships licensed from ingenuity, inc. and selventa, inc. the original study was devised to study the effect of dexamethasone on the differentiation and development of primary mouse chondrocytes using gene expression microarrays. interestingly, the authors report difficulties in drawing clear conclusions about the pathways and biological categories affected by dexamethasone using traditional microarray analysis methods and gene ontology annotations. the authors suggest that the difficulty may be due to modest response to dexamethasone  that limited the ability of traditional approaches to make inference  <cit> .

our approach provides a statistical framework for causal inference that may be particularly valuable in such a situation. as outlined above, we consider each entity in our causal graph together with a direction of perturbation as a hypothesis; based on the network model, perturbing the entity should effect changes downstream, and we assess significance of the concordance between the predicted and experimentally measured changes by computing p-values based on the ternary dot product and causal graph randomized null models. for simplicity, in this example we only consider predicted downstream effects one step downstream of each entity. figure  <dig> illustrates the scoring for one particular hypothesis, klf4+ . note that graph entities are not limited to genes or transcripts but may include more abstract concepts tied to expression changes in the literature; an example we will encounter below is response to hypoxia. in this case, the "direction of perturbation" included in a hypothesis is also to be understood more abstractly: e.g., response to hypoxia+ corresponds to an increase in the effects of hypoxia .

top hypotheses by score in an example experimental dataset of dexamethasone-stimulated chondrocytes . each hypothesis is scored by the difference between the numbers of correct and incorrect predictions. significance is assessed by the ternary dot product and causal graph randomization p-values discussed in the text; the latter numbers are estimates based on  <dig> runs of graph randomization and for this reason are always a multiple of  <dig> . when no randomized graph with a better score for the given hypothesis is detected, we indicate that as "p <  <dig> ." note that hypotheses with the same numbers of correct and incorrect predictions do not necessarily have the same p-values because the significance calculation takes into account the full contingency table for each hypothesis; some hypotheses result in more predicted regulations than others.

importantly, hypotheses are based on overlapping but different sets of regulated transcripts. thus, while we assess significance of each hypothesis in isolation, the evidence shared among hypotheses should be helpful in building a more global understanding. for instance, 50% of the klf4+ transcriptional evidence is also part of the response to hypoxia+ evidence. this supports a major role of hypoxia in chondrogenesis which is partially mediated through klf <dig> 

only  <dig> of the top  <dig> hypotheses by score pass a significance cutoff of  <dig>  for both metrics, indicating the utility of significance assessment--not just score--in discerning hypotheses worthy of further investigation. for example, nrf2+, ranked 17th by score, is not deemed statistically significant according to our metrics; this is consistent with current knowledge as nrf <dig> negatively regulates chondrocyte differentiation contrary to the reported effect of dexamethasone. in contrast to our significance tests, a standard test for enrichment based on fisher's exact test would have given a p-value < 10- <dig>  a result that is probably spurious.

this example is not meant as a comprehensive discussion of the affected biology but should provide some intuition how the proposed measures can be used. for complex biological phenotypes, many hypotheses may be reported as significant that may include overlapping but distinct sets of transcriptional changes as supporting evidence. while our proposed metrics judge significance of single hypotheses independently, the results provide a statistically well-founded substrate on which to form a more comprehensive picture of potential drivers of the observed expression changes.

RESULTS
we divide this section into two parts corresponding to the two statistical significance questions we address: ternary dot product distribution and causal graph randomization.

ternary dot product distribution
we begin by establishing notation and phrasing the problem in a slightly more abstract setting which we find helpful for investigating its mathematical structure.

problem definition
a ternary classification of a ground set t  is a function from t to {- <dig>   <dig>  1}. given an arbitrary but fixed ordering of the elements of t, we can naturally represent a ternary classification c of t as a ternary vector u whose i-th component is the value of c on the i-th element of t. then, for two ternary classifications c and c' of t, the agreement between c and c'  is computed as the dot product u · u.

we are interested in understanding the distribution of the agreement between the fixed experimental classification c and a random classification whose parameters  are taken from the predicted classification c'. in other words, given two classifications c and c' of t, we are interested in the distribution of the agreement between c and a randomized version of c' over all possible randomizations, where a randomization of c' is a classification cr′ of t with the same parameters as c'.

denote the parameters of c and c' by

 qσ:=# {i|ui=σ},nσ:=# {i|ui=σ}, 

where σ ∈ {- <dig>   <dig>  1}. also let

 nσr:=# {i|ui=σ,ui=r} 

for σ, τ ∈ {- <dig>   <dig>  1}, corresponding to the nine ways in which the classifications c and c' can overlap. this gives us the  <dig> ×  <dig> contingency table for the joint classification  shown in table  <dig>  

contingency table of predicted and experimental classifications. the columns sum to n+, n-, and n <dig>  the numbers of predicted classifications of each type, and the rows sum to q+, q-, and q <dig>  the numbers of experimental classifications of each type.

the same  <dig> ×  <dig> contingency table will arise from a large number of randomized classifications cr′, and the number of such classifications, which we denote by d, depends only on the top left  <dig> ×  <dig> corner of the table since the other entries are determined by the constraints on row and column sums. using multinomial coefficients, we can write

 d=q+n++,n+-,n+0q-n-+,n--,n-0q0n0+,n0-,n <dig>  

we will write d as shorthand for this quantity.

the score for a classification cr′ yielding this table is simply

 s:=n+++n---n+--n-+. 

we also know that the total number of possible randomized classifications is

 dtot:= ∑n++,n+-,n-+,n--d=tn+,n-,n <dig>  

thus, the distribution we are seeking is a sum of the d aggregated by the score s and normalized by dtot. explicitly, the probability of a score s is given by

 p= ∑-=sddtot, 

and the p-value of a score can be computed by summing the right tail of the distribution.

in the context of our illustrative example, these are the p-values given for hypotheses of interest in the "ternary dot product p" column of table  <dig>  computing these p-values naïvely is computationally intensive, however; to perform the calculations efficiently, we developed and applied an algorithm we now describe.

algorithm
the ternary dot product distribution problem can be solved by computing each d-value individually in constant time , giving a total running time that scales as the product n+, n-, q+, q-, i.e., o where n := max. while this complexity is acceptable for moderate values of n , it becomes prohibitively slow for larger values of n, typically between  <dig> and  <dig>  that often arise in applications. hence, faster alternatives are necessary; we give two improvements below.

instead of computing all the d-values individually, we can aggregate them by the value of n++ + n--. this still makes it possible to group them by the score s, as s only depends on n++ + n-- and n-+ + n+-. we can write the sum of all the d-values with a fixed n := n+- + n-+ in the form of a constant times

 f:= ∑knkv-nw-kx-ny-k, 

where k = n+-, v = q+ + q- - n++ - n--, w = q+ - n++, x = n+ + n- - n++ - n--, and y = n- - n--. it turns out that f satisfies a three-term linear recursion obtained by using the wz algorithm  <cit> . with this recursion, each f can be computed in average constant time. since there are only o values of f to compute, we get a o algorithm for our problem. 

this cubic algorithm is of theoretical interest but in practice requires exact arithmetic to obtain correct answers due to numerical instability . we therefore developed a second algorithm that is both fast and practical, having the important advantage of working in floating-point arithmetic.

the key observation underlying our algorithm is that the vast majority of contingency tables are highly improbable  and thus may be safely ignored if we:

 need only carry out the computation to fixed precision; and

 do not care about the precise values of tail probabilities: it is enough to know that they are small.

moreover, the quantities d follow an easily described law on certain families of contingency tables, thus allowing us to identify entire families of tables that can be discarded after a constant amount of computation.

consider families of configurations in which the row and column sums of the upper-left  <dig> ×  <dig> submatrix  are fixed. denote these sums by r+, r-, c+, c-, noting that as before, one constraint is redundant as r+ + r- = c+ + c- =: t is the total of the entries in the submatrix. thus, in each family, one degree of freedom remains, which we may parameterize by the value of n++. it turns out that within each such family, d is maximized when n±± are distributed in proportion to the  <dig> ×  <dig> row and column sums, i.e.,

 nστ≈τσcτ/tforσ,τ∈{+,-} 

, and moreover, the probability decreases monotonically as n++ is varied in either direction from the optimum. 

our algorithm thus proceeds as follows . first, compute the global maximum d-value dmax over all  <dig> ×  <dig> contingency tables with row and column sums qσ, nτ. as in the  <dig> ×  <dig> case just discussed, dmax is achieved when nστ≈qσnτ/t for σ, τ ∈ {+, -, 0}. now iterate through the o families of contingency tables with fixed upper-left  <dig> ×  <dig> row and column sums rσ, cτ. for each such family, compute its maximum d-value dfam by setting nστ ≈ rσcτ/t for σ, τ ∈ {+, -} . if dfam is less than dmax times a chosen threshold factor ϵ , discard this family and proceed to the next one. otherwise, the maximum probability for the family is non-negligible; in this case, iterate through the family upward and downward from the maximizing n++, updating the aggregate probabilities of the scores s obtained, until the d-value of the current contingency table drops below ϵdmax.

in practice, very few  <dig> ×  <dig> families are within threshold. in fact, the computation time is often governed by the o initial threshold tests for each family . this observation allows us to obtain further speedup by considering superfamilies in which only the row sums rσ of the upper-left  <dig> ×  <dig> submatrix are fixed, leaving two degrees of freedom. each such superfamily is the union of a set of families we considered above, and as before, the maximal d-value achieved by any contingency table within the superfamily is obtained by assigning counts to the left  <dig> ×  <dig> submatrix proportionally to its row and column sums. we can thus apply the algorithm described above to the o families of  <dig> ×  <dig> left submatrices with fixed row sums. when the maximal d-value of the  <dig> ×  <dig> family is below threshold, we may eliminate an entire one-parameter family of  <dig> ×  <dig> families, achieving further efficiency .

testing
we tested our algorithms on a wide range of problem parameters and found that our thresholded algorithm achieves substantial speed gains across parameter distributions. table  <dig> compares the scaling of run times of the simple quartic algorithm  and algorithm 1b, the version thresholded on  <dig> ×  <dig> families, for a parameter distribution representative of typical use cases. for large cases, the thresholded algorithm reduces run times from days to minutes.

run time comparison of simple quartic ternary dot product distribution algorithm to thresholded version for an increasing family of problems with  in the ratio , a typical usage scenario. runs were performed on a  <dig>  ghz intel xeon processor with  <dig> mb cache.

to further investigate the efficiency attained by thresholding, we computed counts of the numbers of d-values computed by the quartic algorithm and during  <dig> ×  <dig> and  <dig> ×  <dig> thresholding; we compare these counts to the actual numbers of contingency tables and families that pass threshold . we performed these computations for two parameter distributions: one with n <dig> = 5n+ and one with n <dig> = 50n+. the first case is relatively dense, i.e., a sizeable portion  of the gene transcripts are significantly upregulated or downregulated. the second case is sparser; here, there are many more genes but only a few percent of them are found to be regulated. this latter case is typical in practice.

the solid black curve in figure  <dig> indicates the amount of work performed by the simple quartic algorithm while the dotted black curve indicates the number of d-values that exceed ϵdmax, thus placing a lower bound on the amount of work that any thresholding-based algorithm must perform. the disparity between these two curves immediately demonstrates the reason our thresholding algorithms achieve speedup: only a tiny fraction of the d-values are non-negligible. the comparison between the left and right panels of figure  <dig> also makes clear the relative effects of  <dig> ×  <dig> versus  <dig> ×  <dig> thresholding in different parameter settings. in the dense case n <dig> = 5n+, we see that  <dig> ×  <dig> thresholding  is probably already close to optimally efficient: the amount of work required to do the threshold checks  is comparable to the total amount of work required to compute all relevant d-values . on the other hand, in the sparse case n <dig> = 50n+, even performing  <dig> ×  <dig> threshold checks leaves much room for improvement because the number of relevant d-values is far smaller. in this situation it is much more efficient to only compute o  <dig> ×  <dig> threshold checks . for an analytical discussion of these phenomena and a proof that the  <dig> ×  <dig> thresholding algorithm has complexity o, see methods.

we have left our cubic algorithm out of the previous figures and discussion because unfortunately, our tests showed that it is numerically unstable, at least in the form stated; we now briefly discuss this issue. while the cubic algorithm does yield the correct distribution when implemented in arbitrary-precision exact arithmetic, it fails when implemented in floating-point arithmetic because the range of values in the recurrence f is extremely large and subject to cancelation error. for instance, when the parameters are set to the relatively small values v =  <dig>  w =  <dig>  x =  <dig>  y =  <dig>  the values of f already go from  <dig> for n =  <dig> to  <dig> for n =  <dig>  which means that each term is approximately a factor of  <dig> smaller than the previous one. we consider some alternatives in discussion.

implementation
we implemented all of our algorithms in r  <cit> , vectorizing computations when possible. a few remarks are in order about implementation details necessary to make the thresholding algorithm numerically stable. the large factorials in the d-value formula require us to perform all computations in log-transformed space so as to stay within floating point range. this causes no difficulty; multiplication simply becomes addition and addition can be implemented by exponentiating the difference of two log-transformed values, adding  <dig>  taking the log, and adding a shift. numerically, there is no risk of cancelation error because d-values are only summed and never subtracted; thus, all rounding error is additive and well-controlled. the number of summands per score value s is o, and using a stochastic model of rounding error, the total accumulated relative error is thus bounded by o times machine epsilon. in practice n is typically not more than  <dig> while machine precision is 10- <dig> so there is no concern.

the only caveat, as we noted initially, is that our algorithm guarantees precision relative to the maximum probability of all score values--not the probability of each particular score. in other words, very small tail probabilities are known only to the extent that they are understood to be negligible compared to probabilities from the bulk distribution; their precise values are not computed.

causal graph randomization
we now turn to our second computational problem arising from statistical significance evaluation in causal graph models, that of graph randomization. we begin by defining the causal graph randomization problem and placing it in context with previous work on graph randomization. we then explain the special challenges of randomizing a signed causal graph and present an algorithm that successfully overcomes these challenges in practice.

problem definition
the basic statistical significance question motivating our study of graph randomization is the same as before: how likely is a given observation to have occurred by chance? in the preceding development we analyzed this question from the standpoint of randomizing the identities of gene transcripts classified as upregulated or downregulated in a gene expression assay; now we take the perspective of randomizing the causal graph itself. note that the ability to efficiently sample randomized versions of the graph allows one to create an empirical distribution of any quantitative graph property of interest, in particular enabling p-value computation.

in our setup, we estimate the p-value of a hypothesis as the proportion of the randomized graphs with a better score for the hypothesis than the actual causal graph. this is the general context in which we computed the p-values listed in the "causal graph p" column of table  <dig> for our illustrative example. the precise randomization procedure involves some subtleties both in definition and algorithmic implementation, however, which we now describe.

in order to obtain an appropriate null distribution on causal graphs, it is important to require that the randomized graphs share basic structural properties with the original causal graph, yet have enough flexibility to reflect the space of reasonable graphical models. we propose to fix the vertex set v of our original graph g =  and randomize the edges, requiring that the randomized versions g' =  maintain three properties:

 <dig>  vertex degrees. we require that each vertex a ∈ v have the same positive and negative in- and out-degrees in g' as in g. this requirement is important as biological networks typically have long-tailed degree distributions that include highly connected "hubs" as well as vertices with few incident edges.

 <dig>  simplicity. we disallow self-edges and parallel edges in g' as these are not present in g. in other words, for any two vertices a, b ∈ v, there cannot be an edge from a to itself and there can be at most one directed edge from a to b, either positive or negative.

 <dig>  connectedness. we require that g' be connected, as is the case for our original biological network g. for our signed directed graphs, we take connectedness to mean that the graph induced by ignoring edge signs and directions is connected.

note that the first two properties are local and the third is global. these properties capture the most significant features of a causal graph and have also been the subject of previous study in the graph randomization literature  <cit> , though not until recently in the signed directed case  <cit>  that we investigate here.

challenges in causal graphs
in the case of undirected graphs, the randomization problem is typically solved by defining a markov chain whose state space is f, the family of possible randomizations g' of g. transitions in this chain consist of edge switches, which consist of picking two random edges  and  and replacing them with the edges  and , provided this does not violate required graph properties. this elementary operation yields an ergodic markov chain whose unique stationary distribution is the uniform distribution on f  <cit> . in the directed setting, edge switches are no longer sufficient to make the markov chain ergodic, but adding a further operation, which we call triangle flipping, overcomes this problem at least for the case in which property  <dig>  is not required  <cit> . a triangle flip replaces the edges , ,   with the edges , ,  .

in our situation, signed directed graphs, a natural generalization of the above randomization algorithm is to allow edge switches and triangle flips of same-sign edges. such operations clearly preserve in- and out-degrees while modifying the edge structure of the graph, but unfortunately the sign requirement substantially constrains the set of possible transitions. we have identified several obstacles that can make parts of the state space f unreachable by this method; we illustrate two in figure  <dig> 

the first one is the strong quadrilateral: a pair of edges ,  of the same sign  such that the graph also contains edges ,  of the opposite sign . the graph obtained by flipping the signs on the edges of a strong quadrilateral belongs to f--indeed, it could be obtained by simultaneously performing edge switches on both pairs of edges--but neither edge switch is legal on its own because performing one edge switch would cause the pairs of edges to overlap, destroying simplicity.

the second obstacle is the strong triangle: a triplet of edges , ,  of the same sign  such that the edges , ,  of the opposite sign  also exist in the graph. again, the graph obtained by flipping the signs on all the edges of a strong triangle has the same degree sequence as the original one, and it can be reached by a pair of simultaneous triangle flips, but either flip is illegal on its own. we have also found other obstacles that can be created by combinations of edge pairs, triangles and 3-paths  with different signs.

now, while these examples show that in general it is impossible to produce all the graphs in f via same-sign edge switches and triangle flips, we believe that the situation is not so bleak for the large, sparse causal graphs we deal with in practice. by leveraging auxiliary edges, it is usually possible to bypass the above obstacles. we give one possible construction showing that strong triangles do not actually present obstacles in a large, sparse causal graph; a similar construction works for strong quadrilaterals, as well as other obstacles.

let a, b, c be the vertices of a strong triangle in which , ,  are positive edges. suppose that there exist positive edges , ,  disjoint from each other and {a, b, c}. the following procedure, illustrated in figure  <dig>  "flips" both parts of the strong triangle:

 <dig>  opening: switch  with ,  with ,  with .

 <dig>  flipping: flip the triangle , ,  .

 <dig>  closing: switch  with ,  with ,  with .

 <dig>  restoring: switch  with  and then switch  with .

algorithm
given that causal graphs arising from biological networks are typically large and sparse, we expect that in practice the combination of same-sign edge flips and triangle switches suffices to overcome local obstacles to randomization, as observed above.

we thus propose the following algorithm for causal graph randomization. repeatedly perform the following procedure:

 <dig>  pick two edges uniformly at random from the edge set e. if the edges are of different sign, restart.

 <dig>  if the edges share no endpoints, perform an edge switch if it is legal; otherwise, restart.

 <dig>  if the edges share one endpoint and belong to a directed triangle, perform a triangle flip if it is legal; otherwise, restart.

note that in order for a transition to be legal, connectedness must be preserved , which is a global property and thus slow to verify. to improve the efficiency of our algorithm, we therefore perform multiple iterations in between connectivity checks. we allow the number of iterations k between checks to vary dynamically, adopting a heuristic from viger and latapy  <cit> . more precisely, when we perform a connectivity check after k iterations, we proceed as follows. if the check succeeds, we multiply k by a factor of  <dig> + q+. if it fails, we multiply it by  <dig> - q_ and revert to the previous state of the graph . the constants q+ and q_ are chosen to match the heuristic argument presented by viger and latapy  <cit> .

an important final detail of the algorithm is the number of iterations to perform; this relates to the mixing time of the markov chain. while the mixing times of chains arising from graph randomization are not theoretically known, a constant multiple γ of the number of edges in the graph is enough in practice. we set γ =  <dig> by default as suggested in previous literature  <cit> ; our tests below indicate that this value is sufficient and in fact smaller values may already suffice.

testing
we tested our algorithm on the causal graph studied in our companion paper  <cit> , which has  <dig>  vertices and  <dig>  edges  for an average vertex degree less than  <dig>  to check that our randomization algorithm indeed explores the state space of possible graphs--i.e., the markov chain mixes sufficiently--we performed  <dig> independent runs of the algorithm using varying numbers of iterations  and compared the numbers of edges shared between pairs of graphs produced at consecutive values of γ. the number of shared edges converged rapidly to a limiting value of ~ <dig>  edges in common, and in fact convergence already appeared to have happened by γ =  <dig> 

we also tabulated some statistics from an independent set of  <dig> runs with γ =  <dig> that illuminate the workings of our algorithm. in table  <dig>  we give occurrence rates of local structures--in particular, potential obstacles--that our algorithm identified. we see that in our application, all of these structures were extremely rare, with strong quadrilaterals appearing only a few times per ten thousand iterations and strong triangles a few times per billion. these statistics demonstrate that local obstacles are unlikely to cause difficulty in practice.

rates of occurrence of local graph structures in  <dig> runs of the randomization algorithm on our test graph. a total of  <dig>  billion iterations were performed during these runs.

finally, we recorded the variation of the connectivity check interval k in our runs and found that on average  <dig> moves were performed between checks, representing a great speedup over testing connectivity after every iteration. even with this speedup, creating one randomized version of the graph took roughly one hour on a standard pc, a nontrivial computational cost. note, however, that for inference on a fixed causal graph, randomized versions of the graph can be precomputed once and then used for assessing statistical significance on any number of experimental datasets.

implementation
we implemented our algorithm in r using the igraph package  <cit> . the parameters we chose were k =  <dig> for the initial number of iterations between connectivity checks and q+ ≈  <dig> , q_ ≈  <dig>  for the dynamic update of k. for our tests, we used a computational grid to perform independent runs of our algorithm.

discussion
our work provides practical algorithms for assessing statistical significance in causal graphs but also raises a number of unresolved theoretical questions; we describe a few of them now.

in the ternary dot product distribution problem, we saw that the recursion used to obtain a cubic algorithm leads to cancelation of large approximately equal numbers. this naturally brings up the following question: is numerical instability an artifact of a poor setup of the recursion computing f or is it an inherent feature of the problem? we believe that the numerical instability is indeed an inherent feature of the problem, but it is conceivable that a clever transformation could improve the conditioning.

another open question is the precise computational complexity of our thresholding algorithm. in methods we prove an o bound on the complexity, but our empirical results  indicate that the actual performance is much faster. can our analysis be tightened to bring down the exponent? in particular, what is the number of terms d that are within a multiplicative factor of ϵ from the largest term dmax, as a function of n and ϵ?

furthermore, it would be interesting to investigate the consequences of level stratification in regulatory networks in order to propose a more refined null model. while such a multilevel model may indeed provide more precise estimates of statistical significance, it would be much more challenging to estimate that significance and would likely require simulation rather than an analytic approach like the one in this paper.

in the causal graph randomization problem, we saw that same-sign edge switches and triangle flips are insufficient to reach all possible random graphs in the state space f. does there exist an augmented set of moves that suffices? it is worth noting that  this question is open even in the unsigned directed case when connectedness  is required. while edge switches and triangle flips solve the directed case without connectedness  <cit> , these two operations do not suffice when connectedness is imposed. indeed, consider a directed graph g with vertices a, b, c, d and directed edges , , . there are no triangles to flip, and the unique allowed edge switch, involving  and , disconnects the graph. thus, in order to get to the other graph in f, namely, the graph with edges , , , a further operation, called a 3-swap  <cit> , is required. it is interesting to note that the triangle flip is a special case of the 3-swap where a = d.

on the other hand, in practical cases with large, sparse graphs, we showed that it is often possible to overcome local obstacles to randomization. this gives rise to the following question: is there a lower bound on the size or upper bound on the edge density of the graph that would make same-sign edge switches and triangle flips sufficient?

an alternative approach to overcoming obstacles is to limit ourselves to edge switches and triangle flips, but allow several moves to be performed in sequence before the simplicity of the resulting graph is verified. let ks denote the longest such sequence that is required to make the resulting markov chain on f connected, where n is the number of vertices of g. it is clear that ks is always finite and in fact bounded by n <dig> -- n, the largest number of edges in a simple graph on n vertices. does ks grow linearly with n, is it bounded above by a constant, or something in between?

finally, even in cases that markov chains can be shown to generate all possible graph randomizations, their mixing time remains an open question. it is known that the markov chain rapidly mixes in the case of regular directed graphs, i.e., graphs in which all vertices have the same in- and out-degrees  <cit> , but it appears to be slowly mixing for some exponential degree distributions  <cit> . it would be interesting to better understand the mixing time behavior of the chain we proposed for signed directed graphs.

in some cases it may be possible to reduce the size of a causal graph, and thereby the resources required to solve the causal graph randomization problem, by performing a transitive reduction of the graph. a transitive reduction of a graph is a minimal graph with the same transitive closure as the original graph . transitive reduction has been successfully used in computational biology  <cit> ; we opted not to use it here to avoid the possibility of filtering out potentially useful relationships, particularly because our graph likely contains some noise. this reduction approach might prove most helpful when some causal relationships in the graph are known a priori to be indirect.

CONCLUSIONS
this paper presents the first systematic attempt at addressing the computational challenges that arise in the evaluation of the significance of results produced by a causal graph-based model. we develop two algorithms for the ternary dot product distribution problem and one algorithm for the causal graph randomization problem. all the algorithms are implemented in the statistical computing language r and available on request for academic purposes. we believe that our work opens the door to further study of causal graphs from both a theoretical and practical perspective, and we hope that these algorithms will enable the integration of statistical significance computations into causal graph-related methods in biology and other areas of science.

