BACKGROUND
information extraction from biomedical research publications has been a topic of intense research during recent years  <cit> . literature databases such as pubmed offer access through online interfaces to records of millions of research articles from the biomedical domain, with abstracts made available for many, and full texts for some of the papers. potentially, this offers a researcher direct access to vast amounts of research knowledge. however, locating the useful information can be challenging, a simple keyword search may still return many more articles than a human being can process. this motivates the development of tools for automating the extraction of information from biomedical text.

a task of significant interest in biomedical natural language processing is the automated protein-protein interaction  extraction. the most commonly addressed problem has been the extraction of binary interactions, where the system identifies which protein pairs in a sentence have a biologically relevant relationship between them. proposed solutions include both hand-crafted rule-based systems and machine learning approaches . a wide range of results have been reported for the systems, but as we will show, differences in evaluation resources, metrics and strategies make direct comparison of the numbers presented problematic. further, the results gained from the biocreative ii evaluation, where the best performing system achieved a 29% f-score  <cit> , suggest that the problem of extracting binary protein-protein interactions is far from solved.

the public availability of large annotated ppi-corpora such as aimed  <cit> , bioinfer  <cit>  and genia  <cit> , provides an opportunity for building ppi extraction systems automatically using machine learning. a major challenge is how to supply the learner with the contextual and syntactic information needed to distinguish between interactions and non-interactions. to address the ambiguity and variability of the natural language expressions used to state ppi, several recent studies have focused on the development, adaptation and application of nlp tools for the biomedical domain. many high-quality domain-specific tools are now freely available, including full parsers such as that introduced by lease and charniak  <cit> . additionally, a number of conversions from phrase structure parses to dependency structures that make the relationships between words more directly accessible have been introduced. these include conversions into representations such as the stanford dependency scheme  <cit>  that are explicitly designed for information extraction purposes. however, specialized feature representations and kernels are required to make learning from such structures possible.

approaches such as subsequence kernels  <cit> , tree kernels  <cit>  and shortest path kernels  <cit>  have been proposed and successfully used for relation extraction. however, these methods lack the expressive power to consider representations derived from general, possibly cyclic, dependency graph structures, such as those generated by the stanford tools. the subsequence kernel approach does not consider parses at all, and the shortest path approach is limited to representing only a single path in the full dependency graph, which excludes relevant words even in many simple cases . tree kernels can represent more complex structures, but are still restricted to tree representations.

lately, in the framework of kernel-based machine learning methods there has been an increased interest in designing kernel functions for graph data. building on the work of gärtner et al.  <cit> , graph representations tailored for the task of dependency parse ranking were proposed by pahikkala et al.  <cit> . though the proposed representations are not directly applicable to the task of ppi extraction, they offer insight in how to learn from dependency graphs. we develop a graph kernel approach for ppi extraction based on these ideas.

we next define a graph representation suitable for describing potential interactions and introduce a kernel which makes efficient learning from a general, unrestricted graph representation possible. then we provide a short description of the sparse regularized least squares  kernel-based machine learning method we use for ppi-extraction.

further, we rigorously assess our method on five publicly available ppi corpora. in addition to purely intrinsic evaluation using cross-validation on single corpora, we provide a broad cross-corpus evaluation to test how well an extraction system trained on a given corpus will generalize to the other corpora. we thus provide, to our knowledge, the most comprehensive evaluation done with a machine learning approach to ppi-extraction. finally, we discuss the effects that different evaluation strategies, choice of corpus and applied metrics have on measured performance, and provide conclusions.

methods
we next present our graph representation, formalize the notion of graph kernels, and present our learning method of choice, the sparse rls.

graph encoding of sentence structure
as in most recent work on machine learning for ppi extraction, we cast the task as learning a decision function that determines for each unordered candidate pair of protein names occurring together in a sentence whether the two proteins interact. in the following, we first define the graph representation used to represent an interaction candidate pair. we then proceed to derive the kernel used to measure the similarities of these graphs.

we assume that the input of our learning method is a dependency parse of a sentence where a pair of protein names is marked as the candidate interaction for which an extraction decision must be made. based on this, we form a weighted, directed graph that consists of two unconnected subgraphs. one represents the dependency structure of the sentence, and the other the linear order of the words .

the first subgraph is built from the dependency analysis. one vertex and an associated set of labels is created in the graph for each token and for each dependency. the vertices that represent tokens have as labels the text and part-of-speech  of the token. to ensure generalization of the learned extraction model, the labels of vertices that correspond to protein names are replaced with prot <dig>  prot <dig> or prot, where prot <dig> and prot <dig> are the pair of interest. the vertices that represent dependencies are labeled with the type of the dependency. the edges in the subgraph are defined so that each dependency vertex is connected by an incoming edge from the vertex representing its governor token, and by an outgoing edge to the vertex representing its dependent token. the graph thus represents the entire sentence structure.

it is widely acknowledged that the words between the candidate entities or connecting them in a syntactic representation are particularly likely to carry information regarding their relationship; bunescu and mooney  <cit>  formalize this intuition for dependency graphs as the shortest path hypothesis. we apply this insight in two ways in the graph representation: the labels of the nodes on the shortest undirected paths connecting prot <dig> and prot <dig> are differentiated from the labels outside the paths using a special tag. further, the edges are assigned weights; after limited preliminary experiments, we chose a simple weighting scheme where all edges on the shortest paths receive a weight of  <dig>  and other edges receive a weight of  <dig> . the representation thus allows us to emphasize the shortest path without completely disregarding potentially relevant words outside the path.

the second subgraph is built from the linear structure of the sentence. for each token, a second vertex is created and the labels for the vertices are derived from the texts, pos-tags and named entity tagging as above. the labels of each word are specialized to denote whether the word appears before, in-between, or after the protein pair of interest. each word node is connected by an edge to its succeeding word, as determined by sentence order of the words. each edge is given the weight  <dig> .

the all-paths graph kernel
we next formalize the graph representation and present the all-paths graph kernel. this kernel can be considered as a practical instantiation of the theoretical graph kernel framework introduced by gärtner et al.  <cit> . let v be the set of vertices in the graph and ℒ be the set of possible labels vertices can have. we represent the graph with an adjacency matrix a ∈ ℝ|v| × |v|, whose rows and columns are indexed by the vertices, and i, j contains the weight of the edge connecting vi ∈ v and vj ∈ v if such an edge exists, and zero otherwise. further, we represent the labels as a label allocation matrix l∈ℝ|ℒ|×|v| so that li, j =  <dig> if the j-th vertex has the i-th label and li, j =  <dig> otherwise. because only a very small fraction of all the possible labels are ever assigned to any single node, this matrix is extremely sparse.

it is well known that when an adjacency matrix is multiplied with itself, each element i, j contains the summed weight of paths from vertex vi to vertex vj through one intervening vertex, that is, paths of length two. similarly, for any length n, the summed weights from vi to vj can be determined by calculating i, j. since we are interested not only in paths of one specific length, it is natural to combine the effect of paths of different lengths by summing the powers of the adjacency matrices. we calculate the infinite sum of the weights of all possible paths connecting the vertices using the neumann series, defined as

 −1=i+a+a2+…=∑k=0∞ak 

if |a| <  <dig> where |a| is the spectral radius of a  <cit> . from this sum we can form a new adjacency matrix

 w = - <dig> - i. 

the final adjacency matrix contains the summed weights of all possible paths connecting the vertices. the identity matrix is subtracted to remove the paths of length zero, which would correspond to self-loops. next, we present the graph kernel that utilizes the graph representation defined previously. we define an instance g representing a candidate interaction as g = lwlt, where l and w are the label allocation matrix and the final adjacency matrix corresponding to the graph representation of the candidate interaction.

following gärtner et al.  <cit>  the graph kernel is defined as

 k=∑i=1|ℒ|∑j=1|ℒ|g′i,jg″i,j, 

where g' and g" are two instances formed as defined previously. the features can be thought as combinations of labels from connected pairs of vertices, with a value that represents the strength of their connection. in practical implementations, the full g matrices, which consist mostly of zeroes, are never explicitly formed. rather, only the non-zero elements are stored in memory and used when calculating the kernels.

scalable learning with sparse rls
rls, also known as the least squares support vector machine, is a state-of-the-art kernel-based machine learning method which has been shown to have comparable performance to standard support vector machines  <cit> . we choose the sparse version of the algorithm, also known as subset of regressors, as it allows us to scale up the method to very large training set sizes. sparse rls also has the property that it is possible to perform cross-validation and regularization parameter selection so that their time complexities are negligible compared to the training complexity. these efficient methods are analogous to the ones proposed by pahikkala et al.  <cit>  for the basic rls regression.

we now briefly present the basic sparse rls algorithm. let m denote the training set size and m = { <dig> ..., m} an index set in which the indices refer to the examples in the training set. instead of allowing functions that can be expressed as a linear combination over the whole training set, as in the case of basic rls regression, we only allow functions of the following restricted type:

  f=∑i∈baik, 

where k is the kernel function, xi are training data points, ai ∈ ℝ are weights, and the set indexing the basis vectors b ⊂ m is selected in advance. the coefficients ai that determine  are obtained by minimizing

  ∑j=1m)2+λ∑j,i∈bajaik, 

where the first term is the squared loss function, the second term is the regularizer, and λ ∈ ℝ+ is a regularization parameter. all the training instances are used for determining the coefficient vector, but only a subset of them to represent the learned hypothesis. the minimizer of  is obtained by solving the corresponding system of linear equations, which can be performed in o time.

we set the maximum number of basis vectors to  <dig> in all experiments in this study. the subset is selected randomly when the training set size exceeds this number. other methods for the selection of the basis vectors were considered by rifkin et al.  <cit> , who however reported that the random selection worked as well as the more sophisticated approaches.

RESULTS
we next describe the evaluation resources and metrics used, provide a comprehensive evaluation of our method across five ppi corpora, and compare our results to earlier work. further, we discuss the challenges inherent in providing a valid method evaluation and propose solutions.

corpora and evaluation criteria
we evaluate our method using five publicly available corpora that contain ppi interaction annotation: aimed  <cit> , bioinfer  <cit> , hprd <dig>  <cit> , iepa  <cit>  and lll  <cit> . all the corpora were processed to a common format using transformations  <cit>  that we have introduced earlier  <cit> . we note that the version of the bioinfer used in this study differs from the one we considered in  <cit>  and in  <cit> . this is due to the fact that these studies used an early version of the binarization rules  <cit>  that transform the complex relations of bioinfer to binary ones.

we parse these corpora with the charniak-lease parser  <cit> , which has been found to perform best among a number of parsers tested in recent domain evaluations  <cit> . the charniak-lease phrase structure parses are transformed into the collapsed stanford dependency scheme using the stanford tools  <cit> . we cast the ppi extraction task as binary classification, where protein pairs that are stated to interact are positive examples and other co-occurring pairs negative. thus, from each sentence,  examples are generated, where n is the number of occurrences of protein names in the sentence. finally, we form the graph representation described earlier for each candidate interaction.

in the single corpus tests we evaluate the method with 10-fold document-level cross-validation on all of the corpora. this guarantees the maximal use of the available data, and also allows comparison to relevant earlier work. in particular, on the aimed corpus we apply the exact same 10-fold split that was used by bunescu et al.  <cit> , giuliano et al.  <cit> , van landeghem et al.  <cit> , and possibly some of the other studies which do not explicitly state which split was used. in cross-corpus tests we use each of the corpora in turn to train an extraction system, and test the system on the four remaining corpora.

performance is measured according to the following criteria: interactions are considered untyped, undirected pairwise relations between specific protein mentions, that is, if the same protein name occurs multiple times in a sentence, the correct interactions must be extracted for each occurrence. further, we do not consider self-interactions as candidates and remove them from the corpora prior to evaluation. the majority of ppi extraction system evaluations use the balanced f-score measure for quantifying the performance of the systems. this metric is defined as f=2prp+r, where p is precision and r recall. likewise, we provide f-score, precision, and recall values in our evaluation. it should be noted that f-score is very sensitive to the underlying positive/negative pair distribution of the corpus – a property whose impact on evaluation is discussed in detail below. as an alternative to f-score, we also evaluate the performance of our system using the area under the receiver operating characteristics curve  measure  <cit> . auc has the important property that it is invariant to the class distribution of the used dataset. due to this and other beneficial properties for comparative evaluation, the usage of auc for performance evaluation has been recently advocated in the machine learning community . formally, auc can be defined as

 auc=∑i=1m+∑j=1m−hm+m−, 

where m+ and m- are the numbers of positive and negative examples, respectively, and x <dig> ...,xm+ are outputs of the system for the positive, and y <dig> ...,ym− for the negative examples, and

 h={ <dig> if r> <dig> ,if r= <dig> otherwise. 

the outputs are real valued and can be thought of as inducing a ranking, where the examples considered to be most likely to belong to the positive class should receive the highest output values. the measure corresponds to the probability that given a randomly chosen positive and negative example, the system will be able to correctly distinguish which one is which.

performance on the individual corpora
the performance of our method on the five corpora for the various metrics is presented in table  <dig>  for reference, we show also the performance of the co-occurrence  baseline, which simply assigns each candidate into the interaction class. the recall of the co-occurrence method is trivially 100%, and in terms of auc it has a performance of 50%, the random baseline. all the numbers in table  <dig>  including the co-occurrence results, are averages taken over the ten folds. one should note that because of the non-linearity of the f-score measure, the average precision and recall will not produce exactly the average f. further, calculating the co-occurrence numbers as averages over the folds leads to results that differ slightly compared to the approach where the co-occurrence statistic is calculated over all the data pooled together.

                              f
                              auc
the results hold several interesting findings. first, we briefly observe that on the aimed corpus, which has recently been applied in numerous evaluations  <cit>  and can be seen as an emerging de facto standard for ppi extraction method evaluation, the method achieves an f-score performance of  <dig> %. as we argue in more detail below, this level of performance is comparable to the state-of-the-art in machine learning based ppi extraction. for the other large corpus, bioinfer, f-score performance is somewhat higher, at 61%. second, we observe that the f-score performance of the method varies strikingly between the different corpora, with results on iepa and lll approximately  <dig> percentage units higher than on aimed and  <dig> percentage units higher than on bioinfer, despite the larger size of the latter two. in our previous work we have observed similar results with a rule-based extraction method  <cit> . as a broad multiple corpus evaluation using a state-of-the-art machine learning method for ppi extraction, our results support and extend the key finding that f-score performance results measured on different corpora cannot, in general, be meaningfully compared.

the co-occurrence baseline numbers indicate one reason for the high f-score variance between the corpora. the f-score metric is not invariant to the distribution of positive and negative examples: for example, halving the number of negative test examples is expected to approximately halve the number of false positives at a given recall point. thus, the greater the fraction of true interactions in a corpus is, the easier it is to reach high performance in terms of f-score. this is reflected in co-occurrence results, which range from 30% to 70% depending on the class distribution of the corpus.

this is a critical weakness of the f-score metric in comparisons involving different corpora as, for example, the fraction of true interactions out of all candidates is 50% in the lll corpus but only 17% in aimed. by contrast to the large differences in performance measured using f-score, we find that for the distribution-invariant auc measure the performance for all of the corpora falls in the range of 80–85%. the results provide an argument in favor of applying the auc metric instead of, or in addition to, f-score. auc is also more stable in terms of variance.

the similar performance in terms of auc for corpora with as widely differing sizes as lll and bioinfer allows for two alternative interpretations. first, it might be that past a relatively modest number of examples, increasing corpus size has little effect on the performance of the method. alternatively, it might be the case that the larger corpora, while having more training data available, are also more difficult to learn than the smaller corpora. we explore the issue further by calculating learning curves on the corpora, using auc as the performance measure . for each corpus five folds are set aside as the test set, and the rest of the data is incrementally added to the training set to test how increase in training data affects the performance.

the learning curves support the latter interpretation. if the datasets all represented equally difficult tasks with respect to distinguishing randomly drawn positive instances from negatives, we would expect the curves to roughly overlap. the fact that they are to a large extent separate indicates that there are large differences in the difficulty of the learning tasks represented by the different corpora. on aimed and bioinfer it takes significantly more data to reach the same performance than on the three smaller corpora hprd <dig>  lll and iepa: for example, performance on the latter three with  <dig> training examples exceeds the performance on bioinfer with ten times as much training data.

cross-corpus performance
the cross-corpus evaluation aims to shed light on a question of fundamental importance in training machine learning based ppi-extraction systems: will the learned models generalize beyond the specific characteristics of the data they were trained on? the types of named entities annotated, the definition of what exactly constitutes an interaction and the relative positive/negative distributions of pairs can vary significantly over different corpora. thus it is not obvious that a system trained on a given corpus will perform well on data which is not from the same corpus. as discussed in  <cit> , applying text mining tools beyond the development data can lead to disappointing results.

we explore this issue through a cross-corpus evaluation of our method. five extraction systems are trained, one on each corpus, and they are each tested on the four remaining corpora. leave-one-document-out cross-validation on the training corpus is used for parameter value selection. our evaluation extends the recent results of van landeghem et al.  <cit> , who conducted cross-corpus experiments on four of the corpora considered in this study. their finding was that models trained on a combination of three of the corpora often did not perform well on terms of f-score, when tested on the remaining corpus.

we start by considering the auc results of the cross-corpus evaluation , as the metric normalizes away much of the differences resulting from differing positive/negative distributions and threshold selection strategies, thus providing a more stable view of performance. we notice that the performance varies significantly depending on the training and test corpus. unlike in the single corpus evaluations the results are scattered, ranging from 61% to 83% auc. on the large corpora the trained extraction systems in all cases perform clearly worse than the cross-validation performance. however, on the two smallest corpora this is not so. on hprd <dig> systems trained on aimed and iepa actually give better performance than the results from cross-validating on the corpus. on lll the models trained on bioinfer and iepa do almost as well as the cross-validation results on the corpus. these results suggest that a larger amount of training data can compensate for the differences in corpus annotation strategies to a large extent. random chance may also be a factor here, as observed previously in the large variances in cross-validation results on the smallest corpora.

one relevant question that can be answered from the cross-corpus experiments is which of the corpora provides the best resource for training from a generalization perspective. however, it is not entirely straightforward to meaningfully summarize these results: simple averages over results on the very different resources carry little meaning. instead, we provide a simple, rough indicator of generalization potential by ranking the corpora separately according to the results on each of the other corpora. the rankings are presented in table  <dig>  though the rankings do differ over different test corpora, overall they roughly follow the size of the corpora. on average models trained on the largest corpus, bioinfer, perform best. next in this ranking the second and third largest corpora, aimed and iepa share a rank. the second worst performing models are trained on the second smallest corpus hprd <dig>  and the lowest performing ones on the smallest dataset, lll. unsurprisingly, the more training data available the better the performance is. a surprising result is the high performance of systems trained on iepa, the corpus being an order of magnitude smaller than aimed or bioinfer.

next, we consider the results using the f-score measure. in table  <dig> results for which the threshold separarating positive and negative classes has been selected on the training corpus are shown. in some cases the results are on a similar level to those gained in the single corpus cross-validation experiments. this holds true for example with models trained on aimed or iepa, and tested on the hprd <dig> corpus. however, there are several cases where the performance is disastrously low. most strikingly, three out of four results gained when using aimed for training fall below the results one would achieve with the naive co-occurrence baseline. we observe that even in these cases the auc results are still competitive. this gives rise to the assumption that the problem is in the threshold selection. the learned models do have the property that they tend to assign higher values for the positive than for the negative examples, but the approach of selecting the suitable threshold on training data for separating the two classes fails utterly in some cases. we further observed that avoiding the task of threshold selection altogether by setting it simply to zero yielded no better results.

in table  <dig> we provide the optimal f-score results, choosing the positions from the precision/recall curves that would lead to highest f-scores. many of the results are now greatly increased, with no result falling below the naive co-occurrence baseline. further, the relative ranking order of the results is the same as that induced by the auc scores. it is now clear that one can not necessarily rely on the approach of choosing the threshold according to what works on the training set when doing cross-corpus learning. this is perhaps due to the large differences in the underlying positive/negative distributions of the corpora. the differences mean breaking the basic assumption made by the majority of machine learning methods, that the training and test examples are identically distributed. as can be seen from the statistics presented in table  <dig>  the examples are clearly not identically distributed over the corpora, at least with respect to outputs.

one approach for selecting which examples to assign to positive and which to negative classes could be selecting the threshold according to the the relative positive/negative distribution of the test set. to estimate this in a practical setting, one may have to sample and manually check examples from the test set. in table  <dig> are presented the f-score results gained when assigning to positive class such a fraction of the test examples that corresponds to the relative frequency of positive examples in the test corpus. in all the cases the results are within a few percentage units of the optimal values, indicating that this simple heuristic allows the worst disasters observed in the cross-corpus tests to be avoided. however, there are several cases where the result achieved with this approach is lower than when choosing the threshold on the training data.

to conclude, the cross-corpus learning results support the assumption that the learned models generalize beyond the corpora they were trained on. still, results are generally lower when testing a method against a corpus different from that on which it was trained. we observe that the systems trained on larger corpora tend to perform better than the ones trained on smaller ones, as is to be expected. the results achieved with the iepa as a training corpus are surprisingly competitive, considering how much smaller it is than the two larger corpora. choosing a threshold for separating the positive and negative classes proves to be a challenging issue, as a threshold chosen on the training corpus may not work at all on another.

performance compared to other methods
we next discuss the performance of our method compared to other methods introduced in the literature and the challenges of meaningful comparison, where we identify three major issues.

first, as indicated by the results above, differences in the makeup of different corpora render cross-corpus comparisons in terms of f-score essentially meaningless. as f-score is typically the only metric for which results are reported in the ppi extraction literature, we are limited to comparing against results on single corpora. we consider the aimed and bioinfer evaluations to be the most relevant ones, as these corpora are sufficiently large for training and reliably testing machine learning methods. as the present study is, to the best of our knowledge, the first to report machine learning method performance on bioinfer, we will focus on aimed in the following comparison.

second, the cross-validation strategy used in evaluation has a large impact on measured performance. the pair-based examples can break the assumption of the training and test sets being independent of each other, as pairs generated from the same sentence, and to a lesser extent from the same document, are clearly not independent. this must be taken into account when designing the experimental setup . in earlier system evaluations, two major strategies for defining the splits used in cross-validation can be observed. the approach used by bunescu and mooney  <cit> , which we consider the correct one, is to split the data into folds on the level of documents. this guarantees that all pairs generated from the same document are always either in the training set or in the test set. another approach is to pool all the generated pairs together, and then randomly split them to folds. to illustrate the significance of this choice, consider two interaction candidates extracted from the same sentence, e.g. from a statement of the form "p <dig> and p <dig>  p3", where "" is any statement of interaction or non-interaction. due to the near-identity of contexts, a machine learning method will easily learn to predict that the label of the pair  should match that of . however, such "learning" will clearly not generalize. this approach must thus be considered invalid, because allowing pairs generated from the same sentences to appear in different folds leads to an information leak between the training and test sets. sætre et al.  <cit>  observed that adopting the latter cross-validation strategy on aimed could lead up to  <dig> f-score percentage unit overestimation of performance. for this reason, we will not consider results listed in the "false 10-fold cross-validation" table  of sætre et al.  <cit> .

with these restrictions in place, we now turn to comparison with relevant results reported in related research, summarized in table  <dig>  among the work left out of the comparison we note the results of bunescu and mooney  <cit> , who reported a performance of  <dig> % f on aimed. though they used the same cross-validation strategy as the one used in our experiments, their results are not comparable to the ones included in the table  <dig>  they applied evaluation criteria where it is enough to extract only one occurrence of each mention of an interaction from each abstract, while the results shown were evaluated using the same criteria as applied here. the former approach can produce higher performance: the evaluation of giuliano et al.  <cit>  includes both alternatives, and their method achieves an f-score of  <dig> % under the former criterion, which they term one answer per relation in a given document .

the best performing system, that of miwa et al.  <cit> , combines the all-paths graph kernel, implemented based on the description we provided in  <cit> , together with other kernels. their results can be considered as a further validation about the suitability of the graph kernel for ppi-extraction. our implementation of the all-paths method outperforms most of the other studies using similar evaluation methodology, with the exceptions being the approaches miyao et al.  <cit>  and giuliano et al.  <cit> .

miyao reports choosing in the experiments always the optimal point from the precision/recall curve, an approach we observe would raise our results around the same level. the results of giuliano et al. are somewhat surprising, as their method does not apply any form of parsing but relies instead only on the sequential order of the words. this brings us to our third point regarding comparability of methods. as pointed out by sætre et al.  <cit> , the aimed corpus allows remarkably different "interpretations" regarding the number of interacting and non-interacting pairs. for example, where we have identified  <dig> interacting and  <dig> non-interacting protein pairs in aimed, in the data used by giuliano there are eight more interacting and  <dig> fewer non-interacting pairs. the corpus can also be preprocessed in a number of ways. in particular we noticed that whereas protein names are always blinded in our data, in the data used by giuliano protein names are sometimes partly left visible. as giuliano has generously made his method implementation available  <cit> , we were able to test the performance of his system on the data we used in our experiments. this resulted in an f-score of  <dig> %.

finally, there remains an issue of parameter selection. for sparse rls the values of the regularization parameter λ and the decision threshold separating the positive and negative classes must be chosen, which can be problematic when no separate data for choosing them is available. choosing from several parameter values the ones that give best results in testing, or picking the best point from a precision/recall curve when evaluating in terms of f-score, will lead to an over-optimistic evaluation of performance. this issue has often not been addressed in earlier evaluations that do cross-validation on a whole corpus. we choose the parameters by doing further leave-one-document-out cross-validation within each round of 10-fold-cross-validation, on the nine folds that constitute the training set.

as a conclusion, we observe the results achieved with the all-paths graph kernel to be state-of-the-art level. however, differences in evaluation strategies and the large variance exhibited in the results make it impossible to state which of the systems considered can be expected in general to perform best. we encourage future ppi-system evaluations to report auc and f-score results over multiple corpora, following clearly defined evaluation strategies, to bring further clarity to this issue. for further discussion on resolving the challenges of comparing biomedical relation extraction results we refer to  <cit> .

CONCLUSIONS
in this paper we have proposed a graph kernel approach to extracting protein-protein interactions, which captures the information in unrestricted dependency graphs to a format that kernel based learning algorithms can process. the method combines syntactic analysis with a representation of the linear order of the sentence, and considers all possible paths connecting any two vertices in the resulting graph. we demonstrate state-of-the-art performance for the approach. all software developed in the course of this study is made publicly available at  <cit> .

a cross-corpus evaluation is performed to test whether an extraction system will work beyond the corpus it was trained on. we observe this to be the case, though results are generally worse than when training and testing on data from the same corpus. having a larger amount of data available leads to better performance. extraction systems trained on the largest corpora work on the smallest ones in some cases as well as systems trained on data directly from the smaller corpora themselves.

we identify a number of issues which make results achieved with different evaluation strategies and resources incomparable, or even incorrect. in our experimental design we consider the problems related to differences across corpora, the effects different cross-validation strategies have, and how parameter selection can be done. our recommendation is to provide evaluations over different corpora, to use document-level cross-validation and to always select parameters on the training set.

we draw attention to the behavior of the f-score metric over corpora with differing pair distributions. the higher the relative frequency of interacting pairs is, the higher the performance can be expected to be. this is noticed both for the graph kernel method and for the naive co-occurrence baseline. indeed, the strategy of just stating that all pairs interact leads to as high a result as 70% f-score on one of the corpora. we consider auc as an alternative measure that does not exhibit such behavior, as it is invariant to the distribution of pairs. the auc metric is much more stable across all the corpora, and never gives better results than random for approaches such as the naive co-occurrence.

though we only consider binary interactions in this work, the graph representations have the property that they could be used to represent more complex structures than pairs. the availability of corpora that annotate complex interactions, such as the full bioinfer and genia, makes training a ppi extraction system for extracting complex interactions an important avenue of future research . however, how to avoid the combinatorial explosion following from considering triplets, quartets etc. remains an open question. also, the performance of the current approaches may need to be yet improved before extending them to recognize complex interactions.

competing interests
the authors declare that they have no competing interests.

authors' contributions
aa designed the graph kernel, implemented it with the help of jb, and had the main responsibility for experiments. aa, fg, jb and sp explored suitable features and their representations. tp provided the sparse rls algorithms and advice on kernel design. aa was the main author of the manuscript with contributions from all other authors, all of whom read and approved the final version.

