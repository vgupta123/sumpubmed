BACKGROUND
selection of a subset of important features  is crucial for modeling high dimensional data in bioinformatics. for example, microarray gene expression data may include p ≥  <dig>   <dig> genes. but the sample size, n, is much smaller, often less than  <dig>  a model cannot be built directly since the model complexity is larger than the sample size. technically, linear discriminant analysis can only fit a linear model up to n parameters. such a model would provide a perfect fit, but it has no predictive power. this "small n, large p problem" has attracted a lot of research attention, aimed at removing nonessential or noisy features from the data, and thus determining a relatively small number of features which can mostly explain the observed data and the related biological processes.

though much work has been done, feature selection still remains an active research area. the significant interest is attributed to its many benefits. as enumerated in  <cit> , these include  reducing the complexity of computation for prediction;  removing information redundancy ;  avoiding the issue of overfitting; and  easing interpretation. in general, the generalization error becomes lower as fewer features are included, and the higher the number of samples per feature, the better. this is sometimes referred to as the occam's razor principle  <cit> . here we give a brief summary on feature selection. for a recent review, see  <cit> . basically, feature selection techniques can be grouped into three classes: class i: internal variable selection. this class mainly consists of decision trees   <cit> , in which a variable is selected and split at each node by maximizing the purity of its descendant nodes. the variable selection process is done in the tree building process. the decision tree has the advantage of being easy to interpret, but it suffers from the instability of its hierarchical structures. errors from ancestors pass to multiple descendant nodes and thus have an inflated effect. even worse, a minor change in the root may change the tree structure significantly. an improved method based on decision trees is random forests  <cit> , which grows a collection of trees by bootstrapping the samples and using a random selection of the variables. this approach decreases the prediction variance of a single tree. however, random forests may not remove certain variables, as they may appear in multiple trees. but random forests also provides a variable ranking mechanism that can be used to select important variables.

class ii: variable filtering. this class encompasses a variety of filters that are principally used for the classification problem. a specific type of model may not be invoked in the filtering process. a filter is a statistic defined on a random variable over multiple populations. with the choice of a threshold, some variables can be removed. such filters include t-statistics, f-statistics, kullback-leibler divergence, fisher's discriminant ratio, mutual information  <cit> , information-theoretic networks  <cit> , maximum entropy  <cit> , maximum information compression index  <cit> , relief  <cit> , correlation-based filters  <cit> , relevance and redundancy analysis  <cit> , etc.

class iii: wrapped methods. these techniques wrap a model into a search algorithm  <cit> . this class includes foreward/backword, stepwise selection using a defined criterion, for instance, partial f-statistics, aikaike's information criterion   <cit> , bayesian information criterion   <cit> , etc. in  <cit> , sequential projection pursuit  was combined with partial least square  analysis for variable selection. wrapped feature selection based on random forests has also been studied  <cit> . there are two measures of importance for the variables with random forests, namely, mean decrease accuracy  and mean decrease gini . both measures are, however, biased  <cit> . one study shows that mdg is more robust than mda  <cit> ; however another study shows the contrary  <cit> . our experiments show that both methods give very similar results. in this paper we present results only for mda. the software package varselrf in r developed in  <cit>  will be used in this paper for comparisons. we call this method rf-fs or rf when there is no confusion. given the hierarchical structure of the trees in the forest, stability is still a problem.

the advantage of the filter approaches is that they are simple to compute and very fast. they are good for pre-screening, rather than building the final model. conversely, wrapped methods are suitable for building the final model, but are generally slower.

recently, random knn  which is specially designed for classification in high dimensional datasets was introduced in  <cit> . rknn is a generalization of the k-nearest neighbor  algorithm  <cit> . therefore, rknn enjoys the many advantages of knn. in particular, knn is a nonparametric classification method. it does not assume any parametric form for the distribution of measured random variables. due to the flexibility of the nonparametric model, it is usually a good classifier for many situations in which the joint distribution is unknown, or hard to model parametrically. this is especially the case for high dimensional datasets. another important advantage of knn is that missing values can be easily imputed  <cit> . troyanskaya et al.  <cit>  also showed that knn is generally more robust and more sensitive compared with other popular classifiers. in  <cit>  it was shown that rknn leads to a significant performance improvement in terms of both computational complexity and classification accuracy. in this paper, we present a novel feature selection method, rknn-fs, using the new classification and regression method, rknn. our empirical comparison with the random forests approach shows that rknn-fs is a promising approach to feature selection for high dimensional data.

methods
random knn
the idea of random knn is motivated by the technique of random forests, and is similar in spirit to the method of random subspace selection used for decision forests  <cit> . both random forests and decision forests  <cit>  use decision trees as the base classifiers. compared with the two, random knn uses knn as base classifiers, with no hierarchical structure involved. compared with decision trees, knn is simple to implement and is stable  <cit> . thus, random knn can be stabilized with a small number of base knn's and hence only a small number of important variables will be needed. this implies that the final model with random knn will be simpler than that with random forests or decision forests. specifically, a collection of r different knn classifiers will be generated. each one takes a random subset of the input variables. since knn is stable, bootstrapping is not necessary for knn. each knn classifier classifies a test point by its majority, or weighted majority class, of its k nearest neighbors. the final classification in each case is determined by majority voting of r knn classifications. this can be viewed as a sort of voting by a majority of a majority.

more formally, let f = {f <dig>  f <dig> ..., fp} be the p input features, and x be the n original input data vectors of length p, i.e., an n × p matrix. for a given integer m <p, denote f = {fj <dig>  fj <dig> ..., fjm |fjl ∈ f,  <dig> ≤ l ≤ m} a random subset drawn from f with equiprobability.

similarly, let x be the data vectors in the subspace defined by f, i.e., an n × m matrix. then a knn classifier is constructed by applying the basic knn algorithm to the random collection of features in x. a collection of r such base classifiers is then combined to build the final random knn classifier.

feature support - a ranking criterion
in order to select a subset of variables that have classification capability, the key is to define some criteria to rank the variables. we define a measure, called support. each feature f will appear in some knn classifiers, say, set c of size m, where m is the multiplicity of f. in turn, each classifier c ∈ c is an evaluator of its m features, say, set f. we can take its accuracy as a performance measure for those features. the mean accuracy of these knn classifiers  is a measure of the feature relevance with the outcome. thus we have a ranking of the features. we call this scheme bidirectional voting. each feature randomly participates in a series of knns to cast a vote for classification. in turn, each classification result casts a vote for each participating feature. the algorithm is listed in table  <dig>  a schematic diagram of the bidirectional voting procedure is shown in figure  <dig> 

to compute feature supports, data are partitioned into base and query subsets. two partition methods may be used:  dynamic partition: for each knn, the cases are randomly partitioned. one half is the base subset and the other half is the query subset;  the data set is partitioned once, and for all knn's, the same base subset and query subset are used. that is, all base subsets are the same and all query subsets are also the same. for diversity of knn's, the dynamic partition is preferred.

support is an importance measure. the higher the support, the more relevant the feature. figure  <dig> shows the  <dig> most relevant genes determined using the support criterion for golub's  <dig> leukemia training samples, for both fixed and dynamic partitions. the dataset is available in an r package golubesets.

rknn feature selection algorithm
with feature supports, we can directly select high rank features after running the support algorithm on the entire data set. we call this direct selection. but this simple approach may be too aggressive and risky for high dimensional data. we take a more conservative and safer approach, namely, multiple rounds of screening. that is, we recursively apply the direct selection procedure. to balance between speed and classification performance, we split recursion into two stages. the first stage is fast, and the number of variables is reduced by a given ratio . this stage is a geometric elimination process since the dimension to be kept is a geometric progression. in the second stage, a fixed number of features  are dropped each time. this is a linear reduction process. finally, a relatively small set of variables will be selected for the final models. to aid in this recursive procedure, another assessment criterion for a set of features is required. we use the average accuracy of the r random knns. after the first stage, we can plot the average accuracies against the number of features. the iteration just before the maximum accuracy is reached is called pre-max iteration. the feature set from the pre-max iteration will be the input for the second stage selection. the algorithm is shown in table  <dig> 

this procedure was applied to golub's leukemia datasets. figure  <dig> shows the variation of mean accuracy with decreasing number of features in the first stage of feature selection. figure  <dig> shows the variation of mean accuracy with decreasing number of features in the second stage. from figure  <dig>  a maximum mean accuracy is reached when  <dig> genes are left in the model. these final four genes selected for leukemia classification are: x95735_at, u27460_at, m27891_at and l09209_s_at. using these four genes and the ordinary knn classifier  to classify the  <dig> independent test samples,  <dig> of  <dig> all cases are correctly classified and  <dig> of  <dig> aml cases are correctly classified. total accuracy is 91%. this model is very simple compared with others that use far more genes.

time complexity
time complexity for computing feature support
for each knn, we have the typical time complexity as follows:

• data partition: o;

• nearest neighbor searching: o;

• classification: o;

• computing accuracy: o.

adding the above  <dig> items together, we get a time needed for one knn: o. for random knn, we have r knn's; thus the total time for the above steps is o. since rm features are used in the random knn, the time for computing supports from these accuracies is o. thus the overall time is o + o = o) = o. sorting these supports will take o. since for most applications, log p <n log n, and p <rk2m, the time complexity for computing and ranking feature supports still remains as o.

time complexity for feature selection
in stage-one, the number of features decreases geometrically with proportion q. for simplicity, let us take m to be the square-root of p and keep r fixed. thus the sum of the component 2m is 2p+2pq+2pq2+2pq3+2pq4+.... the first term is dominant, since q is a fraction. thus the time complexity will be in o.

in stage-two, each time a fixed number of features is removed. in the extreme case, only one feature is removed per iteration, the total time will be o, where p <dig> is the number of features at the start of stage-two, and usually p <dig> < p1/ <dig>  so on average, we have time in o=o.

therefore, the total time for the entire algorithm will be in o, the same as that for using random knn for classification, at m=p basically, in theory, feature selection does not degrade the complexity of random knn. with m = log p, we obtain time complexity in o. this is significant, as it means that with appropriate choice of m, we can essentially turn the exponential time complexity of feature selection to linear time, with respect to p, the number of variables.

parameter setting
the random knn has three parameters, the number of nearest neighbors, k; the number of random knns, r; and the number of features for each base knn, m. for "small n, large p" datasets, k should be small, such as  <dig> or  <dig>  etc. , since the similarities among data points are related to the nearness among them. for m, we recommend m=p in order to maximize the difference between feature subsets  <cit> . performance generally improves with increasing r, however, beyond a point, larger values of r may not lead to much further improvements. . beyond r >  <dig>  there is not much added advantage with respect to classification accuracy.

RESULTS
microarray datasets
to evaluate the performance of the proposed rknn-fs, we performed experiments on  <dig> microarray gene expression datasets . ten of them were previously used to test the performance of random forests in gene selection  <cit> . these are available at http://ligarto.org/rdiaz/papers/rfvs/randomforestvarsel.html. the other eleven were downloaded from http://www.gems-system.org. some datasets are from the same studies but used different preprocessing routines, and thus the dimensionalities are different. these datasets are for gene profiling of various human cancers. the number of genes range from  <dig>  to  <dig> . the number of classes range from  <dig> to  <dig> 

classwise sample sizes are from  <dig> to  <dig> . the ratio of the number of genes, p, to the sample size, n, reflects the difficulty of a dataset and is listed in the table. the number of classes c, has a similar effect on the classification problem. thus collectively, the quantity  * c is included in the tables as another measure of complexity of the classification problem for each dataset. based on this, we divided the datasets into two groups - group i - those with relatively high values for  * c , and group ii - those with relatively low values . we have organized our results around this grouping scheme.

evaluation methods
in this study, we compare random knn with random forests since they both are ensemble methods. the difference is the base classifier. we perform leave-one-out cross-validation  to obtain classification accuracies. loocv provides unbiased estimators of generalization error for stable classifiers such as knn  <cit> . with loocv, we can also evaluate the effect of a single sample, i.e., the stability of a classifier. when feature selection is involved, the loocv is "external." in external loocv, feature selection is done n times separately for each set of n -  <dig> cases. the number of base classifiers for random knn and random forests is set to  <dig> . the number of variables for each base classifier is set to the square-root of the total number of variables of the input dataset. both k =  <dig>  and k =  <dig>  for random knn are evaluated.

performance comparison without feature selection
random forests and random knn are applied to the two groups of datasets using all genes available. the results  indicate that random forests was nominally better than random knn on  <dig> datasets while random knn was nominally better than random forests on  <dig> datasets. they have a tie on one dataset. using the p-values from the mcnemar test  <cit> , random forests was no better than random knn on any of the datasets, while r1nn was significantly better than random forests on the nci data and random forests was better than r3nn on two datasets. using the average accuracies, no significant difference was observed in group i , or in group ii . therefore from the test on the  <dig> datasets, we may conclude that without feature selection, random knn is generally equivalent to random forests in classification performance.

performance comparison with feature selection
the proposed feature selection approach using random knn is applied to the  <dig> datasets and compared with random forests. the proportion of features removed at each iteration was set to  <dig>  for both rknn-fs and rf-fs  and other parameter settings are the same as in the previous section. the results are shown in tables  <dig> and  <dig>  the indicated results are the mean, standard deviation, and coefficient of variation recorded based on the individual execution of the leave-one-out cross validation  procedure. in one case in the more complex datasets of group i , rf was better than r3nn in both classification accuracy and stability, but r1nn provided a similar performance with rf in both stability and classification accuracy. in another case in group i , rf was slightly better than rknn-fs in classification accuracy, but much worse in stability of classification accuracy. in just one case in the simpler dataset of group ii , rf-fs was better than both r1nn and r3nn in both classification accuracy and stability. they had a virtual tie one one dataset . in all the other datasets , rknn-fs was better in both classification rate, and in stability of the classification rates. rknn-fs showed much more significant performance improvements over rf on the more complex datasets of group i. from the tables, one can observe the general trend: rknn-fs performance improvement over rf increases with increasing dataset complexity .

stability
the tables above also show the standard deviation and coefficient of variation  for the classification accuracy of rknn-fs and rf-fs on each dataset. the tables clearly show that rknn-fs is much more stable with respect to classification accuracy than rf-fs. as with classification accuracy itself, the improvement in stability of the accuracy rates over rf-fs also improves with increasing complexity of the dataset. another way to measure the stability is by considering the variability in the size of the selected gene set. at each run of the loocv, the size of the best gene set selected by random knn and random forests for each cross-validation is recorded. the average size and standard deviation are reported in tables  <dig> and  <dig>  from these tables, one can see that for some datasets , the standard deviation of the best gene set size could be surprisingly large with random forests. the standard deviation can be larger than  <dig> ! the above datasets either have more classes  and/or a large number of genes , and thus have high p * c/n values. it is also believed that datasets with a lager number genes have more noisy genes than those with a smaller number of genes from which the original investigators removed some genes somehow. this shows a striking problem with random forests for noisy "small n, large p" datasets: the size of the selected best gene set can change dramatically even when just one data point is changed . in principle, random forests tries to tackle the problem of instability of the tree structure by bootstrapping the data and constructing many trees. however, the above results support the fact that random forests is still unstable in the presence of noisy or unbalanced input. see  <cit>  for further discussion on the problem of instability in random forests. as table  <dig> shows, in general the stability of random knn is much better than that of random forests. clearly, such a trend will be expected to have some impact on computational requirements - with the stability of rknn-fs in the size of the selected feature sets, there will also be less variability in its computational requirements. thus, we recommended random knn over random forests for gene selection on microarray data.

time comparison
the computing times for rf-fs and rknn-fs are recorded and reported in tables  <dig> and  <dig>  for the smaller  datasets , rf-fs is faster than rknn-fs. however, as shown by time ratio in figure  <dig>  rknn-fs is much faster than rf-fs on the large computationally intensive tasks. for instance, rknn-fs is 4- <dig> times faster on datasets with very large p, and many classes . we conclude that random knn is more scalable than random forests in feature selection. this is important, especially in dealing with the computational burden involved in very high dimensional datasets. between r1nn and r3nn, there was little or no difference in execution time, although r1nn was slightly faster.

CONCLUSIONS
in this paper, we introduce rknn-fs, a new feature selection method for the analysis of high-dimensional data, based on the novel random knn classifier. we performed an empirical study using the proposed rknn-fs on  <dig> microarray datasets, and compared its performance with the popular random forests approach. from our comparative experimental results, we make the following observations:  the rknn-fs method is competitive with the random forests feature selection method  in classification performance;  random forests can be very unstable under some scenarios , while the random knn approach shows much better stability, whether measured by stability in classification rate, or stability in size of selected gene set;  in terms of processing speed, random knn is much faster than random forests, especially on the most time-consuming tasks with large p and multiple classes. the concept of knn is easier to understand than the decision tree classifier in random forests and is easier to implement. we have focused our analysis and comparison on random forests, given its popularity, and documented superiority in classification accuracy over other state-of-the-art methods  <cit> . other results on the performance of rf and its variants are reported in  <cit> . in future work, we will perform a comprehensive comparison of the proposed rknn-fs with these other classification and feature selection schemes, perhaps using larger and more diverse datasets, or on applications different from microarray analysis.

in summary, the rknn-fs approach provides an effective solution to pattern analysis and modeling with high-dimensional data. in this work, supported by empirical results, we suggest the use of random knn as a faster and more stable alternative to random forests. the proposed methods have applications whenever one is faced with the "small n, large p problem", a significant challenge in the analysis of high dimensional datasets, such as in microarrays.

authors' contributions
sl and daa initiated this project. sl developed the methods with the help of daa and ejh. sl and daa analyzed the results from the proposed methods. daa and ejh oversaw the whole project. all authors read and approved the final manuscript.

