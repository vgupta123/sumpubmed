BACKGROUND
reconstruction of phylogenetic trees from molecular sequence data has numerous applications. diverse methods of reconstruction, which are adapted to different circumstances or make different trade-offs between speed and accuracy, are in use. most of the commonly-used methods fall into three categories: distance methods, maximum likelihood, and maximum parsimony.

less well known are methods based on maximum compatibility. although this criterion was first described long ago  <cit> , compatibility methods have not seen much use, perhaps because their conditions of applicability have rarely been met. however, a compatibility criterion is attractive for certain applications made possible by high-throughput sequencing, in which extensive sequencing is performed on possibly large numbers of closely-related organisms. an example is whole-genome sequencing of very closely-related bacteria. phylogenetic reconstruction from such data is important for, among other things, surveillance of bacterial pathogens.

compatibility can most easily be compared to parsimony. maximum parsimony methods seek a tree that minimizes the total number of changes of character state that are necessary to explain the data. conventional maximum compatibility seeks a tree that minimizes the number of characters  required to have more than the minimum possible number of changes of state. these criteria, though related, are not equivalent, and can give different results. suppose, for example, that the polymorphic subset of our data consists of  <dig> two-state characters. one tree topology requires two changes of state for each of  <dig> characters and just one change for each of the remaining  <dig>  a second topology requires  <dig> changes of state for one character and just one change for each of the remaining  <dig> characters. maximum parsimony prefers the first topology , whereas maximum compatibility prefers the second . which preference is scientifically justifiable?

the answer depends on the context. in the case of bacterial pathogen surveillance, incompatible characters are expected, and generally observed, to constitute only a small fraction of the variable sites . the  <dig> variable sites in the example would typically be accompanied by several million sites in the genome that were not observed to vary at all, suggesting that few if any sites will have changed more than once by ordinary sequence divergence. on the other hand, there are many ways in which misleading or incorrect character states can come to pollute the data, and the affected characters often require multiple changes of state on any reasonable tree. sources of problematic characters include genetic recombination, misassembly or misalignment due to unrecognized repeat sequences, and contamination of samples by material from related bacteria. thus, the topology preferred by maximum compatibility corresponds to what may be the simplest explanation of the data: a single corrupted alignment column, which conveys no useful information, along with  <dig> variable sites with a single change of state.

felsenstein  <cit>  gave conditions for applicability of maximum compatibility. scotland and steel  <cit>  exhibited conditions under which compatibility would be superior to parsimony, and suggested application of compatibility to morphological traits. an application to sequence data is described by gupta and sneath  <cit> .

in the simplest case for maximum compatibility, all characters are binary  and there are no ambiguous character states. under these conditions, pairwise compatibility among a set of characters guarantees compatibility of the set as a whole with some tree  <cit> . the maximum compatibility problem then becomes a maximum clique problem. although the maximum clique problem is np-hard  <cit> , existing algorithms can solve instances of moderate size in reasonable time , and various speed enhancements apply to the type of instance involved in this phylogenetic application .

in practice, neither of these conditions holds. characters are not always binary; a sequence column may contain three or all four bases. ambiguous states may occur. indeed these are abundant in the bacterial genome use case .

failure of the first condition is of little consequence. under the conditions that make compatibility appealing, only a small fraction of the variable sites are expected to contain more than two bases, and those that do are highly suspect. non-binary sites are indeed very rare in the motivating case of closely-related bacteria . these sites are simply discarded by the algorithm presented here. the algorithm thus applies a modified compatibility principle: maximize the number of characters that do not require more than one change of state. characters with more than two observed states can never satisfy this criterion. this is the form of maximum compatibility assumed by felsenstein  <cit>  when assessing it from the perspective of maximum likelihood.

ambiguous character states, on the other hand, cannot be ignored or discarded. the algorithm presented here nonetheless provides an exact solution to the modified compatibility problem in the presence of ambiguities. it solves a maximum clique problem and, if the result is not a solution to the phylogenetic problem at hand, iteratively modifies the problem until such a solution is reached. it then resolves ambiguities in the compatible character set to the extent possible, and produces a corresponding phylogenetic tree with branch lengths.

methods
maximum compatibility algorithm
the algorithm described here solves a version of the maximum compatibility problem. a character is said to be compatible with a tree if, for some resolution of any ambiguous states for that character, the character states can be explained with at most one change of state on that tree. a set of characters is said to be compatible if there exists a tree with which all of them are compatible. a maximum compatible set of characters is a compatible set that is at least as large as any other compatible set. the algorithm takes a nucleotide character matrix as input and finds all maximum compatible character sets. it then produces a strict consensus tree that reflects all maximum compatible character sets.

the algorithm  is based on a variant of established algorithms for the maximum weight clique  problem. vertices of the usual maximum clique problem are combined into a single weighted vertex whenever they have identical patterns of compatibility among the other vertices. several modifications greatly increase the speed of this core computation. the larger algorithm handles various complications of ambiguous character states. it produces a phylogenetic tree and reports statistics on the dispositions of characters. optional output includes a list of the characters that failed to meet the compatibility condition.fig.  <dig> outline of the overall algorithm


fig.  <dig> the recursive maximum weight clique algorithm. a\b indicates the set difference between a and b, i.e., the set of all elements of a that are not elements of b. n indicates the set of all vertices that are neighbors of  vertex v. wt indicates the weight of a vertex or the sum of the weights of a set of vertices. r indicates the index of the end of the range of vertices following v
i that share its pattern of conflicts with all vertices v
j with j > i 




data representation
initial input consists of a nucleotide character matrix. this may be a complete multiple sequence alignment, but often only a discontiguous set of sequence positions is given, and their order is of no importance. each column of the matrix corresponds to a character , and each row corresponds to a terminal node on the tree . allowed character states are the four dna bases  and the ambiguity symbol n.

the columns of interest are those in which exactly two of {a, g, c, t} occur, possibly along with occurrences of n. columns with three or four unambiguous bases would require more than one change of state regardless of tree topology, and therefore are excluded. columns that contain only one unambiguous base do not require any changes of state, and are also discarded.

each column of interest specifies a split  of the terminal nodes that may be ambiguous. a column containing {a, g}  splits the terminal nodes unambiguously into two sets in the obvious way. for a column with {a, g, n}, set membership is ambiguous for the rows containing n.

a  split is represented by lower and upper bounds on one of its two component sets, as illustrated in fig.  <dig>  each bounding set is represented by a sorted array of unsigned integers, each integer being the index of a terminal node . the choice of which set to take as the representative–e.g., the set of leaves with a at a particular position or the complementary set with g–may be made arbitrarily, and the algorithm may take the complement of a set when it is convenient to do so. the operation of complementation of an ambiguous set consists of interchanging the upper and lower bounds and complementing each of them.fig.  <dig> illustration of treatment of ambiguous character states. two nucleotide characters having ambiguities  are represented by pairs of sets . the column designated “x” is represented by upper and lower bounds on the set of rows with “t”, although it could instead be represented by the set with “a”. similarly, “y” is represented in terms of the rows with “c”. the result of disambiguation using only information from this pair is shown at the bottom, including the implied effect on the nucleotide character states




columns corresponding to the same ambiguous split are combined and represented as a split with an associated column count. the resulting collection of ambiguous splits with counts contains all of the information used in subsequent steps.

pairwise compatibilities
pairwise compatibilities are determined for all pairs of splits present in the data. two splits represented by x and y are compatible if, and only if, at least one of four conditions holds:the upper bound on x is a superset of the lower bound on y.

the lower bound on x is a subset of the upper bound on y.

the lower bound on x and the lower bound on y are mutually exclusive .

the upper bound on x and the upper bound on y are jointly exhaustive .




in fig.  <dig>  for example, condition  <dig> is met, but none of the others holds.

note that if any of these conditions is met, any other is met under complementation of x, complementation of y, or complementation of both. they represent a single underlying condition that can manifest in four ways, depending on two arbitrary choices between complementary sets as representatives of the two splits. condition  <dig> is obviously a sufficient condition for some set within the bounds of x to be a superset of some set within the bounds of y. it is also a necessary condition: if the superset relation holds between any such sets, it must hold between the largest possible value for x and the smallest for y. the disjunction of the four conditions therefore corresponds to the possibility of resolving ambiguities such that the resulting unambiguous splits are compatible, i.e., at least one member of each split is a subset of one member of the other split.

the compatibility condition given above means that some resolution of the ambiguities in x is compatible with some resolution of the ambiguities in y. it does not imply that all resolutions of x are compatible with all, or even some, resolutions of y. thus, a set of splits that are pairwise compatible in this sense are not necessarily mutually compatible: there may be no resolution of all ambiguities that preserves all pairwise compatibilities, and  no tree topology that is compatible with the entire set. on the other hand, the compatibility constraints put on one split by another allow resolution of much ambiguity once a mutually compatible set has been found.

preprocessing
although the matrix of pairwise compatibilities described above could be used directly as the connectivity matrix for a maximum weight clique problem, several intervening steps allow for greatly improved speed.

distinct splits may exhibit identical patterns of compatibility with the other splits present in the data . these are combined for the purpose of finding a maximum weight clique, which necessarily contains either all or none of them. this procedure can greatly reduce the size of the problem to be solved.

next, a greedy algorithm is run to obtain an approximate solution to the problem. in each iteration, a vertex with the largest total weight of conflicts with the remaining vertices is removed from the set until no conflicts remain. this procedure serves several purposes. first, the resulting clique provides a lower bound on the weight of the optimal solution. this bound allows the exact algorithm to run more quickly by rapidly rejecting families of solutions that could not possibly be as good as the approximate solution. the bound also allows up-front removal of vertices that conflict with too many columns to be part of an optimal solution, which may in turn allow for further consolidation of vertices with identical conflict patterns. it also allows identification of vertices that must be included in any optimal solution; these are marked for inclusion and removed from the problem. second, the greedy algorithm provides an ordering of the vertices that can greatly increase the speed of the exact algorithm: vertices are presented in order of removal, followed by the vertices that form the remaining clique. this ordering is broadly similar to that employed by  <cit>  in that vertices with lower connectivity  tend to come earlier.

problem size reduction
the size of the problem to be solved is further reduced before an exact solution is sought. vertex coloring provides, for every vertex, an upper bound on the weight of a clique that contains it  <cit> . together with the lower bound on the mwc, this information allows elimination of many vertices from consideration before the main computation is performed. a more drastic reduction is achieved by consideration of weights. if the weight of a vertex exceeds the combined weight of the vertices that conflict with it, the first vertex must be included in any maximum weight clique and the conflicting vertices must be absent from it. this is so because any clique not containing the first vertex would be made larger in weight by addition of the first vertex and removal of any vertices that conflict with it. thus, several vertices can be removed from the problem; one is recorded as necessarily included, and the others are discarded. this procedure is repeated until no additional vertices can be removed.

if the problem remains sufficiently large, a further reduction is applied, based on an extension of the reasoning given above. any subset of a clique, including the set of members that conflict with a particular vertex, must itself be a clique. thus, a vertex is recognized as necessarily included in any mwc, and the vertices that conflict with it are removed from consideration, if the first vertex outweighs all cliques that can be formed from the conflicting vertices. this determination is made using a modified version of the exact mwc algorithm that returns as soon as it finds a clique of sufficient weight. this can be much faster than finding the mwc, whose weight may far exceed the required minimum.

size reduction may enable further grouping of columns on the basis of shared patterns of conflict. this additional grouping may in turn allow additional size reduction. thus, the combination of preprocessing  and size reduction is performed iteratively until no further reduction occurs .

exact maximum weight clique algorithm
maximum weight cliques are found by a version of the algorithm of carraghan and pardalos  <cit>  , adapted to the weighted variant of the maximum clique problem . when there is more than one maximum weight clique, this version returns all of them. branch cuts may be performed based on upper bounds on clique weight calculated in either of two ways described below. several modifications increase the speed of the algorithm:as noted above, a greedy algorithm provides a vertex ordering that speeds computation.

the lower bound on maximum clique weight, provided by the greedy solution, greatly speeds the computation.

an additional cut condition is applied to the iterative removal of vertices : when the weight of the first vertex in a candidate list exceeds the total weight of its conflicting vertices within that list, there is no need to continue beyond the current iteration. this is so because subsequent iterations consider only cliques that do not contain the first vertex, but any mwc contained in the candidate list must include the first vertex under these conditions .

a vertex may be immediately followed in the ordering by one or more vertices that share its pattern of connectivity to all other vertices that come after it. at the point in the algorithm where the first remaining vertex is removed from the candidate set and provisionally included in a clique, any such following vertices that remain in the candidate set are removed and considered for inclusion along with it . this is justified because any mwc of the candidate set that contains the first vertex must contain these additional vertices as well, since it would otherwise be possible to add them without introducing conflicts, yielding a clique with larger weight.




branch cuts may also be based on vertex coloring, essentially as described by tomita and yamada  <cit> . if the upper bound on clique weight calculated for a candidate set is too low to allow the current best solution to be equaled, the branch is terminated . otherwise, the margin by which the upper bound exceeds the requirement is recorded. because it is costly, an upper bound calculation is not performed again until the decrease in candidate weight, combined with any increase in the maximum observed clique weight, exceeds this margin.

when this option is in force, a coloring is calculated for each terminal sequence of vertices before the main algorithm is run. the algorithm then uses the appropriate coloring according to the first vertex in the subsequence that it is evaluating. compared to the use of a single coloring throughout, this approach yields generally tighter bounds and hence greater speed.

an alternative approach can provide tighter upper bounds and hence increased speed. the usual approach using vertex coloring considers only conflicts among nodes in the same color class. the alternative described here incorporates some of the remaining conflicts, which involve vertices in different color classes. the color classes are arranged into a tree, constructed so that pairs of classes containing vertices with “important” conflicts—those involving the vertices with highest weight in their color classes and overall—tend to be adjacent in the tree . for a given set of vertices, the algorithm calculates the maximum weight of any subset that respects all conflicts between vertices in tree-adjacent classes in addition to within-class conflicts. this is accomplished through dynamic programming. for any color class, n +  <dig> scores are calculated, where n is the number of vertices in that class. these scores correspond to the n +  <dig> choices of which vertex, if any, to include from that class. each score represents the maximum weight, given that choice, of a subset that satisfies the constraints but includes only nodes from the subtree defined by that color class. the score is set to zero for any vertex not present in the set under evaluation. scores for all classes are calculated recursively, and the maximum score for the root of the tree is the desired overall maximum. each such evaluation is costlier than the usual coloring-based calculation, but it can yield much tighter upper bounds, and hence earlier branch cuts and dramatic improvements in overall speed.

a color class tree is constructed as follows for each set of color classes  before the main algorithm is run. the color classes are first ordered by decreasing maximum member weight. they are then added to the tree by alternation of these steps:the first remaining  color class is added to the tree. if it is the first class to be added, it becomes the root. otherwise, it is attached as a child of the root.

any remaining classes whose highest-weight member conflicts with the highest-weight member of the class added in  are added as children of that class. the added children are then treated, in order, in the same way, so that they may acquire children of their own and more distant descendants.




a preference for enforcement of “important” conflicts, as defined above, is accomplished by step  <dig> in conjunction with the class ordering.

by default, the algorithm chooses whether to calculate upper bounds, and, if so, by which method, on the basis of the size of the problem. the method used can also be specified by the user.

disambiguation
the above procedure yields a collection of splits that generally contain ambiguities. ambiguities in a split may often be resolved by constraints imposed by other splits in the collection. ambiguities are resolved to the extent possible by an iterative pairwise process, and only those splits that are fully resolved by this process impose splits on the computed phylogenetic tree or contribute to the lengths of its branches.

consider a pair of possibly ambiguous splits, represented by set ranges x and y. x may resolve some ambiguities in y, and vice versa, when exactly one of the four compatibility conditions  holds. suppose, for example, that only condition  holds. this implies that, on any consistent resolution of ambiguities, x is a superset of y. it follows that y can be no larger than the upper bound on x. we may, therefore, obtain a stricter upper bound on y, namely the intersection of the original upper bound on y and the upper bound on x. similarly, the lower bound on x is replaced by its union with the lower bound on y. figure  <dig> illustrates the application of this rule and the corresponding implicit effects on ambiguous nucleotide states. analogous disambiguation rules are applied for the other three compatibility conditions. like the compatibility conditions themselves, these four rules are in reality a single underlying rule applied to different representations of the data. these operations correspond to meacham’s  <cit>  second rule for partial splits.

the pairwise disambiguation procedure is performed iteratively on pairs of splits until no further disambiguation is possible. if this condition is reached without the introduction of any pairwise incompatibilities, the disambiguated splits are converted to a phylogenetic tree with branch lengths . if a pairwise inconsistency does arise, a modified mwc problem is solved, as described next.

when ambiguities are not completely resolved, there may be total splits implied by the data that are not recovered by pairwise disambiguation. for the data on which the algorithm has been tested, the vast majority of ambiguous splits are fully resolved , so there are few, if any, of these. nonetheless, alternative procedures may be worth pursuing.

handling false solutions
as noted above, in the presence of ambiguities a maximum weight clique need not be a solution to the maximum compatibility problem: there may be no way to resolve all ambiguities such that pairwise compatibility remains intact. the disambiguation procedure may therefore give rise to incompatibilities. when this occurs for all of the cliques found, it is necessary to find a different candidate solution to the compatibility problem. this is done by solving a modified instance of the mwc problem.

to understand how this situation is handled by the algorithm, it is helpful to consider a correct but inefficient means by which ambiguities could have been handled. in this impractical approach, each ambiguous split containing n ambiguities is expanded into all 2n unambiguous possibilities that it represents. these are marked as incompatible with one another, so that at most one resolution of any ambiguous split is included in any clique. other compatibilities are determined as above. solution of the resulting maximum weight clique problem yields a solution to the maximum compatibility problem.

such a procedure would be practical only if ambiguities were rare and reasonably evenly distributed across matrix columns. when some columns contain many ambiguities, the number of vertices needed to represent all possibilities becomes prohibitively large. however, limited expansion of ambiguities, guided by the incompatibilities that arose in the course of disambiguation, allows reasonably rapid calculation of another candidate solution, as described below.

suppose that disambiguation produces pairwise incompatibilities. this occurrence identifies at least one pair of splits that were originally compatible  but became incompatible in the course of disambiguation. expansion of just these two splits into their component possibilities would guarantee a different outcome: if solution of the modified maximum weight clique problem results in any incompatibilities, these will involve different splits, which can then also be expanded. furthermore, the acquired incompatibility can be attributed to subsets of ambiguities in the original pair whose resolution destroyed one or more compatibility conditions. suppose, for example, that the two original ambiguous sets x and y satisfied only compatibility condition  <dig>  and that the disambiguation process yields incompatible restrictions x’ and y’. then the implicated ambiguous elements for x are those absent from the upper bound of x’ but present in the lower bound of y’. these are precisely those elements whose exclusion from x’ make it too small to be a superset of any resolution of y’, so that condition  <dig> is not satisfied.

thus, complete expansion of an implicated split into 2n unambiguous possibilities is not necessary. in fact, expansion into just two possibilities that resolve only one ambiguous element may prevent the conflict and avert a costly combinatorial explosion. therefore, for each split in a conflicting pair the algorithm chooses one element for expansion . if there are multiple mwcs, however, they may implicate different elements of the same split. in general, then, a split is expanded into 2m possibilities, with m < = n. if m < n, these possibilities are themselves ambiguous . incompatibilities in solutions of the modified mwc instance will necessary involve other splits or different ambiguities in these splits.

the above procedure designates one or two splits for expansion at certain ambiguities. disambiguation is then attempted on what remains of the clique after these splits are removed, and the procedure is repeated until no incompatibilities remain . this is not necessary for correctness, but may identify additional splits for expansion without an additional mwc search and hence improve performance. the result is a set of one or more ambiguous splits that are to be partially expanded with respect to certain designated ambiguities.

if solution of the modified problem also yields incompatibilities upon disambiguation, splits/ambiguities are again designated for expansion and the process is repeated. among the splits to be expanded may be the products of previous expansions. iteration  must eventually yield a legitimate solution to the maximum compatibility problem. in practice this requires at most a few iterations and only modest enlargement of the problem, and computations complete in reasonable times.

when pairwise disambiguation succeeds without conflict, the splits may nonetheless lack mutual compatibility. this situation has not been encountered with real data during the development of the algorithm. nonetheless, the algorithm checks every candidate solution by seeking a complete and consistent resolution of all ambiguities, the existence of which ensures mutual compatibility. first, any of the remaining ambiguous splits that can be resolved to singletons  are so resolved, eliminating the possibility of conflicts involving them. second, any ambiguous splits that can be resolved to unambiguous splits already in the set are resolved in that way. this procedure cannot introduce new conflicts, so it preserves mutual compatibility. finally, remaining incompatibilities are resolved by iteratively resolving one ambiguous element arbitrarily and performing pairwise disambiguation on the modified set. iteration proceeds until there are no ambiguities remaining or a conflict arises.

a conflict at this stage is treated much like a conflict arising in the earlier disambiguation of the original set: one or both of the splits involved are marked for partial expansion in a subsequent mwc search . however, when there are multiple maximum cliques, a conflict at this stage for any of those cliques mandates a subsequent search, even if some other solutions proceed without conflict . this is because the search for a compatible resolution of all ambiguities is not guaranteed to succeed even if one exists. it has not been observed to fail, except on artificial data constructed to make it do so, but the possibility is handled appropriately.

if no conflict arises, the result is a complete resolution of all ambiguities that is pairwise compatible and hence mutually compatible. this resolved set serves as a proof of the mutual compatibility of the original set. a tree corresponding to the fully resolved set may optionally be produced as auxiliary output. however, it is not used for the main tree, which is based on pairwise disambiguation results.

multiple maximum cliques
an instance of the maximum clique problem may admit multiple solutions. the exact search described here is exhaustive and may yield more than one clique of the same size. all of the solutions are evaluated for mutual compatibility as described above. any incompatibilities that arise from different solutions are combined appropriately for determining any subsequent ambiguity expansions. if one or more solutions are found to possess mutual compatibility, these represent the largest sets of mutually compatible columns, provided that all of the other solutions produced incompatibilities during pairwise disambiguation. the pairwise-disambiguated maximum compatible sets are then used for tree construction.

although a tree can be derived from each such result, by default they are combined to produce a consensus tree. the consensus tree contains exactly those splits that are found in all of the solutions. the length of the branch corresponding to a split is the minimum of the split’s total count among the solutions.

implementation
the algorithm was implemented in c++ and python, with an interface between the two generated by swig  <cit> . it was developed under linux. source code and build instructions are available at  <cit> .

bacterial sequence data
the algorithm was assessed using bacterial nucleotide character matrices derived from whole-genome sequence data. these character matrices were produced by the ncbi pathogen detection pipeline. information about this pipeline can be found at  <cit>  and  <cit> . the character matrices analyzed are available at  <cit> .

maximum parsimony trees
maximum parsimony trees were built with tnt   <cit> . one hundred replications were performed with the xmult command, with five runs each of the parsimony ratchet. a consensus tree was then built after trees were collapsed with tbr.

RESULTS
application of maximum compatibility to bacterial genomes
the algorithm described here was applied to salmonella enterica data generated by the ncbi pathogen detection pipeline. data consisted of nucleotide character states for sets of salmonella genomes . each set consists of closely-related genomes , and is therefore referred to as a cluster. character states were derived from raw sequence reads where available, but some genome assemblies were also included. character states had been filtered to remove several kinds of potentially problematic sites: those with large numbers of conflicting sequence reads, those with low coverage, certain repeat sequences, and sites in regions with high densities of sequence differences . table  <dig> gives the run times for the twenty largest clusters, along with information about the input data and the disposition of columns in the tree reconstruction process.table  <dig> summary of results and performance on salmonella data

some counts are averages over multiple maximum compatible sets, and may therefore be non-integral




tree computation was rapid. for the largest cluster, which contained  <dig> isolates and had  <dig> informative characters, the algorithm took just under 10 s to run using a single core on commodity hardware . calculating all  <dig> trees took a total of less than 30 s.

in all cases the maximum compatible set included well over 90% of the variable characters. after the pairwise disambiguation process, the vast majority of these were completely unambiguous. these facts lend support to the applicability of maximum compatibility, and suggest that any loss of information due to genuine homoplasy or inadequate disambiguation is small.

in the majority of the columns that could not be completely disambiguated, one of the unambiguous bases was present in only one row, making those columns uninformative for tree topology. this is true of columns in general , but is disproportionately common among those whose ambiguities are not all resolvable. of the remaining such columns, the majority admit resolution to the same split as some fully disambiguated column, so they cannot imply any split that is not known from another column. thus, only a very small number of columns not fully disambiguated are both informative and non-redundant.

the algorithm was also applied to data for other bacteria produced by the ncbi pathogen detection pipeline. additional file 1: table s <dig> shows results for all clusters with  <dig> or more members, after removal of isolates with more than 10% ambiguities for some taxa. these clusters represent eight genera belonging to a variety of bacterial groups. the results are similar to those for salmonella enterica. execution times were at most  <dig>  s, and the vast majority of variable sites are compatible with the inferred trees and contribute to branch lengths.

maximum parsimony trees
trees for each salmonella cluster were also calculated by maximum parsimony for the purpose of comparison. these were similar in topology to the maximum compatibility trees, but for some clusters differed significantly.

an example with significant differences is cluster  <dig>  the compatibility tree for this cluster displays  <dig> splits, and the parsimony tree displays  <dig>  because  <dig> of these correspond to terminal branches, the numbers of informative splits are  <dig> and  <dig>  of these,  <dig> found on the compatibility tree are absent from the parsimony tree, and  <dig> found on the parsimony tree are absent from the compatibility tree. if we restrict attention to splits on one tree that conflict with those on the other , these numbers are  <dig> for compatibility and  <dig> for parsimony. these differences represent a significant fraction of the informative splits.

analysis revealed that several nucleotide sites are highly homoplastic with respect to both trees. these generally required fewer changes on the parsimony tree than the compatibility tree. for example, the most homoplastic site according to the compatibility tree requires  <dig> changes, but the same site requires only  <dig> changes on the parsimony tree.

it is not surprising that parsimony arrived a tree topology that decreases the number of changes required. however, the requirement for  <dig> changes even according to parsimony, where most variable sites require just one change, suggests that this site is unreliable and should be ignored. compatibility effectively ignores it, as it counts the  <dig> changes as no worse than two, whereas parsimony accommodates it, counting the reduction from  <dig> to  <dig> as a major improvement that would justify the loss of compatibility with multiple sites.

additional sites show a similar pattern. the next most homoplastic sites according to compatibility require  <dig>   <dig>   <dig>   <dig>  and  <dig> changes. on the parsimony tree, these counts are also reduced drastically, to  <dig>   <dig>   <dig>   <dig>  and  <dig>  respectively.

further investigation traced most of the highly homoplastic sites to the minority of bacterial isolates for which raw sequence reads were unavailable. for these isolates there was no opportunity to remove uncertain base calls on the basis of read alignments, and the analysis relied on whatever assembly method had been used by the sequence submitters. removal of these isolates eliminated most of the highly homoplastic sites and brought the compatibility and parsimony topologies into near agreement. this is additional evidence that the highly homoplastic sites are unreliable and should be ignored, as effectively done under maximum compatibility, and therefore that the compatibility tree is preferable to the parsimony tree.

effects of addition of suspect character data
a second type of comparison between compatibility and parsimony considers the effect of allowing normally excluded nucleotide sites into the input data. in a series of computational experiments, randomly chosen positions that had been removed by one form of filtering were re-introduced into the analysis, and the effects on compatibility and parsimony trees were compared. removal of these sites had been based on identification of sequence differences that cluster on the genome. such clusters can result from various biological events and technical problems and are likely to be misleading.

the starting point for addition of these characters consisted of those sites that were compatible with both the original compatibility tree and the original parsimony tree. for this set of sites, the two methods yield the same tree topology, which is a consensus between the two original trees. this tree serves as a common basis of comparison for the effects of added sites on compatibility and parsimony. any split that conflicts with this tree also conflicts with the original trees produced by both methods.

results are shown in fig.  <dig> for clusters  <dig> and  <dig>  the two clusters most subject to the effects of the suspect sites . as more randomly chosen suspect sites are added, the inferred tree topologies increasingly change. parsimony is clearly more susceptible to the effects—presumably detrimental—of the added sites, whereas compatibility is much more robust to them.fig.  <dig> susceptibility of maximum compatibility and maximum parsimony to the influence of suspect sequence data. the effect of adding  <dig>   <dig>  or  <dig> columns of suspect data is shown for each method. three replicates  are shown for each number of columns. the topological difference between trees reconstructed with and without the suspect columns is quantified by the number of columns on either tree that are absent from the other and the number on either tree that conflict with the other




algorithm comparisons
the phylip phylogentic software package  <cit>  includes a program, dnacomp, for maximum compatibility tree reconstruction from nucleotide data. applied to the twenty salmonella clusters  with the default parameters, dnacomp took much longer to run than the algorithm described here. run times ranged from several seconds for the smallest clusters  to nearly ten hours for the largest . in several cases, dnacomp results fell slightly short of the true compatibility maximum.

the techniques described here for reducing problem size  often reduce the phylogenetic problem to a trivially small  instance of the maximum weight clique problem. in cases where a non-trivial instance remained, the recursive mwc algorithm described here, with either use of vertex coloring, was found to be much faster than the algorithm of Östergård  <cit>  for solving the reduced problem. this performance advantage is presumably dependent on characteristics of the problem instances that occur in this application. it is noteworthy, however, that the reduced instances are not necessarily very densely connected.

discussion
the algorithm described here computes an exact maximum compatibility consensus tree for binary characters in the presence of ambiguity. the computation is rapid for character data with the intended properties. for input derived from whole-genome sequencing of closely-related bacteria, consisting of up to several thousand informative sites for nearly  <dig> genomes, trees were computed in a few seconds or less. compatibility is thus a computationally feasible phylogenetic method for such data.

the speed of the algorithm will vary with attributes of the input data besides its size. as expected for an np-hard problem, worst-case run time can be long for large problem sizes. the high speed of the bacterial tree computations is made possible by the nature of the biological input data. most important would seem to be the high density of the compatibility graph, i.e., the fact that vast majority of character pairs are compatible.

the main motivation for applying compatibility in this context is to make phylogenetic inference more robust to problematic sequence positions. computational experiments confirmed that compatibility is more resistant than parsimony to the effects of misleading sequence positions on tree topology. these experiments were based on the effects of actual sequence data that is normally identified as suspicious and discarded.

maximum compatibility may be compared to another approach to misleading sequence positions. some analyses of bacterial genomes have discarded any positions that are incompatible with an initial tree calculated by a more commonly used phylogenetic method  <cit> . this procedure may be helpful, but it is not a substitute for the benefits of maximum compatibility. if the initial tree topology is incorrect due to problematic sites, the set of positions chosen for retention by this procedure will also be incorrect. re-computation of the tree based on this misidentified subset does not remedy the situation. it will, in fact, tend to reproduce the original flawed tree topology or a less-resolved version of it . with maximum compatibility, in contrast, identification of potentially misleading sites is an integral part of determination of the tree topology, not a subsequent step that is determined by a topology that may be corrupted by those very sites.

compatibility methods and whole-genome sequencing appear to be particularly well matched. compatibility is not frequently used for analysis of nucleotide sequences, perhaps because it is not often appropriate. it is most applicable when most of the variable sites have changed just once over the length of the true tree. in practice this means that the vast majority of sequence positions do not vary in the group under study, so that the number of useful characters will be small unless many nucleotide positions are sequenced. whole-genome sequencing provides data for millions of positions, allowing for differentiation of closely related isolates that are identical at all but a tiny fraction—but a reasonably large number—of nucleotide sites. it is, however, subject to many sources of misleading character states, including recombination events, unrecognized repeat sequences, systematic sequencing errors, and contamination of sequence reads, that can overwhelm the truly informative sites. maximum compatibility provides robustness against these phenomena.

CONCLUSIONS
the maximum compatibility algorithm presented here rapidly computes phylogenies of closely-related bacteria from genome sequence data. this application domain appears to conform to the assumptions of maximum compatibility: the vast majority of variable characters require only one change of state on the phylogenetic tree. in the presence of moderate levels of sequence ambiguity, the method is able to resolve most ambiguous states. compared to maximum parsimony, the method is robust to phylogenetically misleading nucleotide positions that can be found in actual data. it may therefore be a preferred method for an important class of phylogenetic problems.

additional file

additional file 1: table s <dig>  summary of results and performance on bacteria other than salmonella. 




abbreviations
mwcmaximum weight clique

