BACKGROUND
the high throughput sequencing  technologies  <cit>  have been a major transformation in the way scientists extract genetic information from biological systems, revealing limitless insight about the genome, transcriptome, and epigenome of many species. one major step of analysis is combining the overlapped reads  to reconstruct the original genome sequence of the target species, called assembly. however, the lengths of reads  generated by hts technologies are much shorter than those of the traditional sanger sequencing  and the sequencing error rate is usually higher . in addition, there are many repetitive sequences along the genomes. all the above features will make the assembling process difficult and will introduce mis-assembled genome sequence.

many assembly methods  have been developed to deal with these challenges and they have steadily improved in recent years. however, the problem of mis-assembly is still unsolved  <cit>  and the assembly errors will have adverse impact to downstream analysis  <cit> . there are two main approaches for determining mis-assembled sequences depending on whether we have a similar reference genome for the target genome .

reference-based approach
if the genome reference for the target organism is available, mis-assembled sequences, e.g., misjoins and erroneous insertions/deletions, can be detected by comparative analysis of the reference sequence and the assembled genome sequence. however, a good genome reference is usually not available. when the target genome and the reference genome are not the same, there are some differences caused by structural variations between them. mauve  <cit>  regards these differences as assembly errors directly without further analysis, which may affect the final result . gage  <cit>  and quast  <cit>  regard these differences as erroneous indels  or misjoins. all these tools do not distinguish whether the differences caused by assembly errors or by structural variations, therefore further analysis is required to determine which differences are due to mis-assembly to prevent introducing false error calls.

de novo approach
if a reference is unavailable, the alignment of the raw reads to their assembly provides indirect measures of assembly quality, e.g., high variation in coverage depth alone mis-assembled sequence, inconsistent insert distance when aligning paired-end reads to mis-assembled sequence, etc. this information can then be used to detect single-base changes, repeat condensation or expansion, false segmental duplications and other mis-assemblies. cgal  <cit>  and ale  <cit>  both produce a summary likelihood score of an assembly. ale also reports four likelihood scores for each base representing the probability that an assembly is correct. however, they lack the ability to transform metrics to accurate error calls  <cit> . reapr  <cit>  reports a single score for each base for accuracy derived from just a few metrics, such as the coverage depth distribution, it may tend to introduce some false error calls since the real reads data usually are uneven, and it also tends to break the scaffolds in their gap regions by mistake .

both reference-based and de novo approach may partially solve the mis-assembly problem. however, reference-based approach cannot distinguish real structure variations and mis-assembled sequences while de novo approach can have many false positive detections because of the uneven sampling in real data. a better performance can be achieved by combining both approaches in determining mis-assembled sequences.

in this article, we present misfinder, a tool that aims to identify the assembly errors with high accuracy in an unbiased way  and correct these errors at their mis-assembled positions to improve the assembly accuracy for downstream analysis. it uses the reference  to find the differences between the scaffolds and the reference, and uses paired-end reads to validate these differences to determine whether they are assembly errors or correct assemblies corresponding to structural variations rather than regarding them as errors directly with some biases. in order to distinguish the assembly errors and correct assemblies corresponding to structural variations, misfinder analyzes the patterns of each type of assembly errors, and then applies multiple features derived from coverage and consistence of paired-end reads for these errors to obtain high confident error calls and pinpoint the correct assemblies corresponding to structural variations, thus resulting assembly error calls with high accuracy in an unbiased way.

methods
the workflow of misfinder to identify assembly errors is shown in fig.  <dig>  misfinder is based on blastn  <cit> , assembly , genome reference and paired-end reads from solexa sequencing technology are its input, with aims to identify the mis-assemblies i.e., the assembly errors, and correct these errors to increase the accuracy of the assembly. it consists of three major steps:  identify the differences between scaffolds and reference using blastn alignment;  compute the breakpoints according to paired-end reads alignment information;  validate the differences according to paired-end reads alignment information to distinguish the assembly errors and correct assemblies corresponding to structural variations. the algorithm of misfinder will be described in details in the following sections.fig.  <dig> workflow of misfinder. misfinder consists of three major steps.  identify putative mis-assembles. scaffolds  and genome reference are first used to generate the blastn alignments followed by the alignment processing that the redundant alignments will be removed, and then the putative mis-assembles are identified according to their non-redundant alignments.  breakpoint computation. paired-end reads are aligned to the scaffolds to make the breakpoints more accurate.  mis-assembly validation. putative mis-assemblies are validated according to the alignment information of paired-end reads on scaffolds



identify differences between scaffolds and reference
align scaffolds to reference
misfinder is based on the alignments of blastn   <cit> , a well-established long-range nucleotide sequence alignment program for producing accurate long-range sequence alignments, which is particularly suitable for capturing the scaffolds alignment information. as blat  <cit>  does not produce single hit for distances > <dig> kbp  <cit> , and according to our experiments, it tends to break single well-aligned segments into multiple small pieces as it produces gapped alignments, and the most important, it may miss well-aligned segments sometimes, while these situations does not occur for blastn which is well-known and always tries to produce continuous alignments as large as possible. therefore, we choose blastn as our long-sequence alignment tool.

misfinder uses blastn in multiple threads approach to compute the alignments, first, the scaffolds are divided into equal-sized parts to run blastn independently with multiple threads; and then, the sub-alignments for each thread are merged to generate the whole alignment results for further analysis.

obtain non-redundant alignments
if a scaffold is aligned to genome reference uniquely, we keep its alignment information without additional requirements. otherwise, we select the several best aligned segments that cover the whole scaffold, and other alignments are removed as they are short and redundant to the alignment of the whole scaffold. as the alignments from blastn are already sorted in descending order according to their scores, so we first choose the best aligned segment as the start segment, and select its adjacent segments one by one to the 3′ end of the scaffold until no adjacent ones, and then the adjacent ones are selected to the 5′ end of the scaffold in the same way. for selecting the adjacent segment, the candidates should have an overlap or a gap no more than  <dig> kbp by default according to the blastn alignments, and select the one of the minimal overlap or gap size. if there are no adjacent segments, the segment that has the minimal overlap or gap size according to the scaffold position is selected. these selected segments cover the whole scaffold and are placed according to their positions in scaffold. other unselected segments are redundant and are removed.

identify differences using blastn
after analyzing the non-redundant alignment information of scaffolds generated by blastn, four kinds of patters are observed . some scaffolds can perfectly match with reference , and there will be no assembly errors within these scaffolds. other three most common kinds of differences, i.e., misjoin, insertion and deletion, may be due to assembly errors . the misjoin may be caused by joining segments with large distance or different strands in genome, or by joining segments between different chromosomes  or between chromosome and plasmid . the insertion/deletion may be caused by incorrectly expanded/collapsed repetitive sequences during assembly, or may be caused by structural variation between the target genome and reference genome. note that the scaffold segments with no alignment information are treated as insertion, and they may be caused by sequencing errors or by novel sequences compared to the genome reference. blastn tends to break the alignment at these regions of differences, and these differences have high possibility to be assembly errors. misfinder identifies these differences as putative mis-assemblies which needs further validations to determine whether they are true assembly errors.fig.  <dig> overview of differences between scaffolds and reference according to blastn alignments. solid lines indicate reference  and scaffolds  respectively, red lines indicate unaligned segments, dashed lines between reference and scaffolds indicate alignment borders. a scaffold is perfectly aligned to the genome reference. b insertion or deletion error in scaffolds. an insertion/deletion error in scaffold causes alignment breaks, and the scaffold will be split into several aligned segments separated by the insertion/deletion error. c misjoin in scaffold. assembly errors caused by joining distinct genome regions with large distance , by joining segments which can be aligned to different reference strands , or by joining segments between different chromosomes  or between chromosome and plasmid  . the yellow solid line indicates the region of reverse strand of the reference region. d scaffolds that have entirely no alignment information  or have partial unaligned segments relative to the scaffold . we treat these situations as insertions that may be caused by assembly errors or by novel sequences in target genome



compute breakpoints
after analyzing the alignments of the scaffolds to the genome reference, three common types of mis-assemblies, including misjoin, erroneous insertion and erroneous deletion, are observed at the positions of differences according to their alignment information. before calling assembly errors, it is necessary to get the scaffold regions which have differences that may contain assembly errors for misjoin, erroneous insertion/deletion. we call such scaffold region as breakpoint region with left margin ml and right margin mr. according to our observations, the normal regions have well aligned read pairs and relative even read coverage depth , and whereas for the three types of mis-assemblies, they have different error patterns in their breakpoint regions, which can be used for error calling .

since the target genome and the reference genome are not exactly the same, there are usually some differences between them, i.e., structural variations . therefore, in order to distinguish assembly errors and correct assemblies corresponding to structural variations, paired-end reads are aligned to scaffolds to call the mis-assemblies using multiple kinds of information extracted from the paired reads data . note that, for the reads fall into repeat regions, their best alignments are randomly selected to prevent the correct regions from having zero read coverage, and we call these reads with multiple aligned positions as multiple aligned reads, misfinder marks these multiple aligned reads for further analysis.

breakpoint region for misjoins
misjoin in scaffold can be depicted in fig.  <dig>  for the scaffold with misjoin, the whole scaffold will be divided into several large segments after blastn alignment, and these segments can be aligned to different reference regions respectively, with different strands or long distance of distinct regions, e.g., more than several kilo bases, or can be aligned to different chromosomes  or between chromosome and plasmid . the misjoins are caused by repeats which are not correctly resolved by assembly algorithm.fig.  <dig> misjoin in scaffold. after aligning the misjoined scaffold to reference, it will be split into two sub-segments according to the alignment information, and the two sub-segments are aligned with different reference strands or aligned to distinct regions with long distance. and these two sub-segments overlap each other due to the repeat  whose erroneous tails around margins m
l and m
r will be trimmed



as blastn usually produces some mismatched bases around repeat margins ml and mr, misfinder trims the segment tails containing mismatched bases to get the margins ml and mr . this repeat region between ml and mr is a breakpoint region that may contain assembly errors. for blastn alignments, the adjacent two misjoined segments usually have some overlaps, and it is observed that there are many multiple aligned reads  in the region, and the scaffold should be split into two small pieces if the breakpoint region contains a misjoin assembly error.

breakpoint region for erroneous insertions
scaffolds usually have some erroneous insertions in the middle, and they also usually have some unaligned segments at the ends, we treat all of the above two cases as insertion errors, which can be illustrated in fig. 4a-c. for the insertion error at the end of scaffolds, the end usually contains some erroneous bases, and there are usually only single-end reads covering the breakpoint region without paired-end reads. for the insertion error in the middle of scaffold, it has two flanking well-aligned segments at both sides of it, and the paired-end reads aligned on the two segments have a larger insert size than normal regions. the insertion error has a breakpoint region with margins ml and mr which can be easily determined from alignments directly.fig.  <dig> insertion/deletion error in scaffold. a-b an insertion error at scaffold end. there are usually only single-end reads can be aligned to the erroneous ends. c an insertion error in the middle of two well-aligned segments whose paired-end reads have a larger insert size than normal regions. d a deletion error in the middle of two well-aligned segments whose paired-end reads have a smaller fragment size than normal regions. m
l and m
r are the left margin and the right margin for the insertion  error, respectively



breakpoint region for deletions
scaffolds also usually contain some erroneous deletions which can be illustrated in fig. 4d. unlike erroneous insertion, the erroneous deletion is a missing sequence with two well-aligned segments around it, and the aligned paired-end reads on the two segments have a shorter insert size than that of normal regions. the deletion error also has a breakpoint region with margins ml and mr which can be easily determined from alignments directly.

validate assembly errors
after aligning paired-end reads to scaffolds, there are several features that are different with the normal regions for these putative mis-assemblies, including abnormal  coverage, some disagreements , multiple aligned reads , fragment size difference , and discordant read pairs . the mis-assembled regions typically have high or low coverage , much more discordant read pairs than other normal regions. so that, the putative mis-assemblies could be validated by using the paired-end reads aligned to the scaffolds. the high coverage means that the breakpoint region has more than one 50-bp sub-region whose coverage is higher than  <dig>  fold of the average coverage of that scaffold, while the low coverage means that it has more than one 50-bp sub-region whose coverage is lower than  <dig>  fold of the average coverage of that scaffold. and for the discordant read pairs, we calculate the ratio of the discordant read pairs and all the read pairs in the breakpoint region, named discordant ratio, and the breakpoint region with much more discordant read pairs usually has a high discordant ratio, say > <dig> . and for the breakpoint region larger than  <dig> base pairs, we calculate the discordant ratio for each 500-bp sub-region.

as the single-cell data typically have highly uneven sequencing depth, we re-define the sub-regions of high coverage and low coverage in the case of single-cell sequencing data. for a scaffold, we compute the average coverage of each 50-bp sub-region, and then calculate the mean coverage and standard deviation of the coverage of these sub-regions of the scaffold. the high coverage means that the breakpoint region has more than one 50-bp sub-region whose coverage is at least  <dig>  fold of the standard deviation higher than the mean coverage of that scaffold, while the low coverage means that it has more than one 50-bp sub-regions whose coverage is at least  <dig>  fold of the standard deviation lower than the mean coverage of that scaffold.

since different errors appear different patterns, we applied different methods to validate their correctness. the misjoins could be validated using the abnormal coverage, disagreements, multiple aligned reads, and the insertion/deletion errors could be validated using the abnormal coverage, discordant read pairs and the fragment size difference.

validate misjoins
after aligning paired-end reads to scaffolds, it is observed that there are some differences between the breakpoint region  and other normal regions around the margins ml and mr . the patterns of misjoins are described as below.

in misjoin regions, there are usually some disagreements and abnormal coverage around margins ml and mr. this is caused by the repeats that come from different genome regions which are incorrectly joined by assembly algorithm. even though one end of the paired-end reads can be aligned to the scaffold, the other end may be aligned with some mismatched bases which usually have the same position in scaffold . for a base in scaffold, there will be many aligned reads covering it, the read count is called coverage which consists of the counts of a, c, g and t, respectively. if the majority nucleotide differs no much with others, e.g., the percent of the majority < <dig> , we call the nucleotide in scaffold a disagreement. for misjoins, there are usually some disagreements around breakpoint margins ml and mr, whereas the normal regions usually have no disagreements . also, for the breakpoint region with margins ml and mr, some nucleotides may also have abnormal high or low coverage , and these abnormal coverage usually indicates assembly error.

after aligning paired-end reads to scaffolds, most of the reads are uniquely aligned in normal regions, and there are usually some multiple aligned reads in misjoin regions with margins ml and mr . this is also caused by repeats, the repeat regions usually have more multiple aligned reads than that of other normal regions. therefore, for a breakpoint region of misjoin, we compute the percentage of the multiple aligned reads, named multi-align ratio, to determine whether this difference is caused by repeats. high values of the multi-align ratio  may indicate the assembly error.

therefore, in summary, the putative misjoin is a validated assembly error if it satisfies at least one of the following two conditions:  it has abnormal coverage or more than  <dig> disagreement;  the multi-align ratio is high, say > <dig> . otherwise, it may be due to structural variation that needs further analysis .

validate insertion errors
after placing paired-end reads to their most likely locations in scaffolds and computing the breakpoint regions of insertion errors , misfinder analyzes the aligned reads around the breakpoint regions. for the insertion error in the middle, misfinder identifies the paired-end reads whose two ends are aligned to the two flanking sub-segments, and then calculates the fragment size of the paired-end reads. if the difference of the fragment size and the library insert size is close to the size of the inserted sequence, e.g., < <dig> * standard deviation, then it may indicate an assembly error. moreover, it may contain some disagreements, low coverage, and many discordant read pairs with large fragment size . therefore, in order to call the assembly error with high confidence, the putative insertion error in the middle of a scaffold is a validated assembly error if:  the difference of the fragment size and the library insert size is close to the size of the inserted sequence, and  it satisfies at least two of the following conditions:  it has disagreements;  low coverage; and  many discordant read pairs with large fragment size, e.g., discordant ratio >  <dig> .

for the insertion errors whose differences of the fragment size and the library insert size are not close to the size of the inserted sequences, the length of inserted sequences are usually larger than the read length. they usually have some disagreements in the breakpoint regions, and we calculate the number of disagreements per kilo base pairs in the breakpoint regions. therefore, these putative insertion errors in the middle of scaffolds are validated assembly errors if they have more than one disagreement per kilo base pairs in their breakpoint regions.

moreover, for the insertion error at the 5′/3′ end of a scaffold, as it has no paired-end reads for most cases, misfinder calculates the read coverage at the scaffold end, and if there are some disagreements or zero-coverage nucleotides, then it should be a true erroneous insertion sequence.

validate deletion errors
in contrast with insertion error, the deletion error has a missing sequence in scaffolds . misfinder identifies the paired-end reads whose two ends are aligned to the two flanking sub-segments, and then calculates the fragment size of these paired-end reads. if the difference of the library insert size and the fragment size is close to the size of the deleted sequence, e.g., < <dig> * standard deviation, then it may indicate an assembly error. it may contain some disagreements, high or low coverage , and some discordant read pairs with erroneous orientation or small fragment size in the breakpoint region . therefore, in order to call the assembly error with high confidence, the putative deletion error is a validated assembly error if:  the difference of the library insert size and the fragment size is close to the size of the deleted sequence, and  it satisfies at least two of the following conditions:  it has disagreements;  high or low coverage ; and  many discordant read pairs with erroneous orientation or small fragment size, e.g., discordant ratio >  <dig> .

similar with the insertion errors, for the deletion errors whose differences of the fragment size and the library insert size are not close to the size of the deleted sequences, the length of deleted sequences are usually larger than the read length. they usually have some disagreements in the breakpoint regions, and we calculate the number of disagreements per kilo base pairs in the breakpoint regions. therefore, these putative deletion errors in the scaffolds are validated assembly errors if they have more than one disagreement per kilo base pairs in their breakpoint regions.

distinguish correct assemblies corresponding to structural variations
after validating the potential mis-assemblies, assembly errors are identified, and there are still some differences due to structural variations that are not validated as assembly errors, and they may need further analysis. in order to distinguish these correct assemblies corresponding to structural variations with high confidence, we perform the correct assembly analysis to determine them.

for the correctly assembled scaffold regions, they usually have the same patterns as the normal regions, while for assembly errors their patterns differ significantly with the normal regions, which can be used to determine the correct assemblies from the differences that are not been identified as assembly errors in previous section. for the difference between the scaffold and reference that is not identified as assembly error, if its breakpoint region has even coverage, no disagreements, and very few discordant read pairs , it should be a correct assembly whose difference is caused by structural variations; otherwise, misfinder output it as a warning that may need further analysis.

after the analysis, some novel sequences could be identified, e.g., novel sequences of  <dig> kbp and  <dig>  kbp in s.pombe strain jb <dig> were identified, and they should be correct assemblies rather than assembly errors .

RESULTS
detection of assembly errors on simulated data
genome assembly usually contains some common errors such as misjoins of distinct genomic regions, erroneous insertions and deletions. to test misfinder’s ability to detect such errors, we used gemsim  <cit>  to generate 50× simulated illumina short reads data on escherichia coli k <dig> mg <dig> , with mean insert size 368 bp and standard deviation 61 bp. next, these paired-end reads data were assembled using masurca   <cit> , and  <dig> scaffolds were generated. finally, the misfinder was performed to identify assembly errors in the scaffolds using the genome reference and paired-end short reads data. note that the differences between the assembly and reference could be directly treated as errors without considering structural variations for simulated reads data.

according to our experiments, masurca produced more assembly errors  than other assemblers on e.coli and s.pombe genomes. masurca generated more mis-assembled contigs than other assemblers, and the detailed information can be seen in our previous work  <cit> , therefore, masurca was chosen to be the assembler for the experiments of e.coli and s.pombe genomes to give better presentations for the performance of misfinder on identifying the assembly errors and structural variations.

we tested misfinder by first aligning the assembly to the reference using blastn   <cit>  with option ‘-best_hit_overhang  <dig> ’ to reduce the redundant short align segments. the remaining redundant short segments were further removed to obtain non-redundant align segments, therefore most of the scaffolds each had only one large align segment with only a few mismatched bases, e.g., insertions/deletions and mismatches. then, the paired-end reads were aligned to the assembly to assist in extracting the suspicious mis-assembly breakpoint regions before analyzing their alignment information. finally,  <dig> assembly errors including  <dig> misjoins,  <dig> insertion errors and  <dig> deletion errors were identified according to multiple features of their paired-end reads information .fig.  <dig> visualization of misfinder output for identifying assembly errors on e.coli simulated data. the running results of misfinder are shown using circos  <cit> . the ideogram  shows the circularized selected scaffolds containing errors and structural variations. the scatter plot shows the identified assembly errors  and correct assemblies  corresponding to structural variations by misfinder. there are  <dig> assembly errors and  <dig> correct assemblies corresponding to artificial svs. the disagreement plot marks the disagreement for each base in scaffolds. the zero coverage plot marks each nucleotide with zero coverage. the multi-align ratio plot shows the ratio of multiple aligned reads for each region of 500 bp, ranging from  <dig> to  <dig>  the discordant ratio plot shows the discordant ratio of discordant read pairs for each 500-bp region in scaffolds, ranging from  <dig> to  <dig>  the last plot shows the read coverage in scaffolds



we checked all these identified assembly errors manually, and found all of them were true assembly errors and correctly identified by misfinder without introducing mis-identification errors, which may indicate misfinder’s high accuracy of identification of assembly errors.

distinguish assembly errors and correct assemblies corresponding to structural variations on simulated data
since the target genome and the reference genome usually are not the same, they may contain some structural variations , and for the difference between the assembly and reference, it may be caused by assembly errors or it is a correct assembly corresponding to svs, therefore it needs to determine whether the difference is caused by assembly error or it is a correct assembly corresponding to svs when performing the assembly error call.

to test the ability of misfinder to call assembly errors and correct assemblies corresponding to svs, we introduced six different modifications into the e.coli genome reference to analog the svs, these modifications included one duplicated sequence , one large relocation , two insertions  and two deletions  . the similarity between the artificially modified reference and the original reference is  <dig>  %. we treated this mutated reference as new high quality reference, and treated the assembly as the target genome in which some differences may be due to svs rather than assembly errors. then, the scaffolds and paired-end reads data in previous section were directly used again to test the performance of misfinder on identification of the assembly errors and the correct assemblies with svs that were correctly assembled. as the duplicated sequence introduced one difference and the large relocation produced three differences at their joined positions, there were eight differences between the target genome and the reference. as a result, misfinder successfully identified all the  <dig> assembly errors that were already detected in previous section without introducing miscalled errors, and moreover, it determined all the eight differences caused by svs as correct assemblies .

from the above two experiments on simulated short reads data, it shows that misfinder has good ability for identifying the assembly errors and correct assemblies corresponding to svs with high accuracy by using the reference and paired-end reads data.

performance on e.coli single-cell data
we tested the performance of misfinder on e.coli k <dig> strain mg <dig> single cell data. the single-cell sequencing data   <cit>  were downloaded from http://bix.ucsd.edu/projects/singlecell/nbt_data.html, with mean insert size 282 bp and standard deviation 65 bp, sequencing depth ~600×. the masurca assembly and the artificially modified reference in previous section were used again to test the performance of misfinder on identifying assembly errors and structural variations on highly uneven sequencing data.

the experiments for single-cell reads data were carried out on an intel xeon core- <dig> cpu  <dig> -ghz server supplied with 24 gb memory. the single-cell sequencing data option “-sc 1” was specified then performing the experiments using  <dig> threads, the running time was 8 min and the memory consumption was  <dig>  gb, and all the  <dig> assembly errors and  <dig> structural variations were successfully identified without introducing other miscalls , which may indicate that misfinder has good performance not only on uniform distribution coverage data but also on highly uneven sequencing data .

detection of assembly errors on real data
to test the performance of misfinder on real sequence data, we applied it to schizosaccharomyces pobme strain jb <dig> real short paired-end reads data by using the same assembler masurca  <cit> . the paired-end reads data  of s.pombe were downloaded from ncbi, with mean insert size 380 bp and standard deviation 82 bp. since the reference of strain jb <dig> is not available, we used the high quality reference of its close strain 972 h-  which consists of three chromosomes and one mitochondrion . for the assembly of the s.pombe strain jb <dig>  there were some assembly errors introduced during the assembly step, and moreover, the target genome and the reference genome were not exactly the same, there were some structural variations between them. therefore, misfinder was used to find the assembly errors and correct assemblies corresponding to structural variations.

first, de novo assembly was carried out using masurca, and produced  <dig> scaffolds. then, misfinder was applied to identify the assembly errors and distinguish the correct assemblies corresponding to svs in the scaffolds by using the s.pombe strain 972h- reference and paired-end reads data. misfinder identified  <dig> assembly errors and  <dig> correct assemblies corresponding to structural variations with only three false positives and one false negative. for the  <dig> assembly errors, there were  <dig> misjoins,  <dig> erroneous insertions and  <dig> erroneous deletions; and for the  <dig> correct assemblies, there were  <dig> insertions,  <dig> deletions and  <dig> false misjoins, ranging from several base pairs to several kilos of nucleotides.

these assembly errors and correct assemblies corresponding to svs were all manually checked by aligning their paired-end reads to see the coverage, disagreements and discordant read pairs and etc., using blastn  <cit>  alignments and igv  <cit> . for the  <dig> identified errors, there were only  <dig> false positives; and for the  <dig> correct assemblies, there was only one miscalls.

figure  <dig> showed  <dig> scaffolds with the most typical errors and correct assemblies corresponding to variations were selected and analyzed by manually comparing the scaffolds with the reference sequence using act  <cit> , and by visualizing their aligned paired-end reads using igv  <cit> . in the figure, the erroneous regions had some disagreements, low coverage, many discordant read pairs, and other abnormal features, whereas the correct assembly regions had well supported paired-end reads, even coverage and no disagreements.fig.  <dig> visualization of misfinder output for identifying assembly errors on selected  <dig> scaffolds of most errors for s.pombe real data. the running results of misfinder are shown using circos  <cit> . the ideogram  shows the circularized selected scaffolds. the scatter plot shows the marked assembly errors  and correct assemblies  corresponding to structural variations identified by misfinder. the disagreement plot marks the disagreement for each base in scaffolds. the zero coverage plot marks each nucleotide with zero coverage. the multi-align ratio plot shows the ratio of multiple aligned reads for each region of 500 bp, ranging from  <dig> to  <dig>  the discordant ratio plot shows the discordant ratio of discordant read pairs for each 500-bp region in scaffolds, ranging from  <dig> to  <dig>  the last plot shows the read coverage in scaffolds. a, b show zoomed regions in the figure. a an identified assembly error of 55 bp deletion error in scaffolds was visualized using act  and igv . b a detected correct assembly corresponding to structural variation of  <dig> kbp copy number variation in scaffolds was visualized using act  and igv 



from the above three experiments, it shows that misfinder has good performance on identification of assembly errors with only few false positives, and it also pinpoints the correct assemblies corresponding to structural variations with high accuracy, which indicates the great power of misfinder to detect the assembly errors using genome reference and multiple features extracted from paired-end reads data, thus could help to increase the accuracy of assembly results for downstream analysis.

corrected assembly statistics
to highlight the performance of misfinder on mis-assembly identification, we evaluated it on both the accuracy of mis-assembly identification and the continuity of the corrected assembly using the assemblies of e.coli and s.pombe on simulated and real illumina paired-end reads data. the e.coli and s.pombe assembly data were used again to perform the experiments, and the artificially modified reference was used as the high quality e.coli genome reference, and there were some differences between these two target genomes and their genome references.

in order to test the performance of misfinder on large genome, human chromosome  <dig>  simulated data were used to perform the experiments. the simulated data were generated using gemsim  <cit> , with length 100 bp, mean insert size 369 bp and standard deviation 45 bp. we chose cabog  <cit>  to perform the assembly because cabog produced more errors than other tools according to our previous work  <cit> .

we compare the n <dig> size of the assemblies before and after the correction . since quast  <cit>  just computed mis-assembly statistics rather than correcting errors, we chose the metrics na <dig> as the corrected n <dig>  and we computed the following mis-assembly statistics, including true positives , false positives , false negatives , precision ) and true positive rate ). precision is the fraction of identified assembly errors that are true, while true positive rate tpr  is the fraction of true assembly errors that are identified.

we also further compared misfinder with the reference-based approach quast   <cit>  and the de novo approach reapr   <cit>  on the same datasets, and recorded their running time and memory consuming. the experiments for the e.coli simulated reads data and s.pombe real reads data were carried out on a 64-bit linux machine with an intel core- <dig> cpu  <dig> -ghz supplied with 3 gb memory, and the results were shown in tables  <dig> and  <dig>  respectively. the experiments for the human chromosome  <dig> simulated reads data were carried out on a 64-bit linux server with  <dig> intel xeon cpus of  <dig> -ghz supplied with 1 tb memory, and the results were shown in table  <dig> table  <dig> performance on assembly of e.coli simulated reads data

74
 <dig> 
 <dig> /  <dig> / 1
 <dig> 
 <dig> 
8
 <dig> 
1
 <dig> 
74
 <dig> 
 <dig> 
 <dig> 

anumber of assembly errors were called by misfinder, quast and reapr, including tp  and fp , while fn  is the number of assembly errors that were not called


bnumber of correct assemblies corresponding to structural variations called by misfinder


cquast did not output the number of broken scaffolds

the bold data reflected the best values for each column

481
 <dig> 
 <dig> /  <dig> / 9
 <dig> 
 <dig> 
22
 <dig> 
2
 <dig> 
 <dig> 

anumber of assembly errors were called by misfinder, quast and reapr, including tp  and fp , while fn  is the number of assembly errors that were not called


bnumber of correct assemblies corresponding to structural variations called by misfinder


cquast did not output the number of broken scaffolds

the bold data reflected the best values for each column

 <dig> /  <dig> / 95
 <dig> 
 <dig> 
12
21
4
2322
 <dig> 

anumber of assembly errors were called by misfinder, quast and reapr, including tp  and fp , while fn  is the number of assembly errors that were not called


bnumber of correct assemblies corresponding to structural variations called by misfinder


cmemory usage of misfinder: blastn 30 gb, error identification  <dig>  gb


dquast did not output the number of broken scaffolds

the bold data reflected the best values for each column



performance on assembly of e.coli simulated reads data
for the results in table  <dig> on e.coli, misfinder identified  <dig> true positives in scaffolds, with  <dig> false negative and no false positives, the highest precision  and true positive rate . in the scaffolds, there were three large misjoins of distinct genome regions, misfinder correctly identified all of them and broke the scaffolds at their breakpoints. quast identified  <dig> mis-assemblies, however, there were  <dig> false positives and  <dig> false negative, and most of the false positives were corresponding to structural variations, so its precision was only 75 %. misfinder found  <dig> correct assemblies corresponding to structural variations using the artificially mutated genome reference, whereas quast also found these  <dig> correct assemblies, but it treated them as assembly errors. reapr identified  <dig> errors without false positives, however,  <dig> assemblies errors were missing called, so the true positive rate tpr was only  <dig>  %.

the corrected n <dig> size of misfinder and reapr did not dropped , whereas the corrected n <dig> size of quast dropped from  <dig>  kbp to  <dig>  kbp, because it incorrectly broke the scaffolds at their breakpoint regions of differences due to structural variations. quast had the least time consumption , reapr is the most time consuming , misfinder is moderate on time consumption , which is because that misfinder and reapr performed the time consuming paired-end reads alignment while quast did not. quast and reapr had the least memory usage , and misfinder cost more memory .

performance on assembly of s.pombe real reads data
for the s.pombe assembly in table  <dig>  misfinder identified  <dig> errors including  <dig> true positives and  <dig> false positives , with only  <dig> false negatives, and it also identified  <dig> correct assemblies corresponding to structural variations. in scaffolds, misfinder detected  <dig> misjoins and broke the scaffolds at their breakpoints. for quast, it identified  <dig> errors including  <dig> true positive errors and  <dig> false positives , and with  <dig> false negatives. reapr identified  <dig> errors including  <dig> true positives and  <dig> false positives , and with  <dig> false negatives. misfinder detected more true positives than quast and reapr, while quast and reapr generated more false positives than misfinder.

misfinder had the highest precision , while these values of quast and reapr were only 41 % and  <dig>  %, respectively. quast and reapr treated gaps between contigs in scaffolds as errors directly, while these gaps were caused by lack of read coverage and they were normal and common in scaffolds, so misfinder just report these gaps rather than treat them as errors. moreover, quast treated all the differences as assembly errors directly without considering structural variations, thus introduced some false positives, e.g., there were  <dig> false positives caused by structural variations in the  <dig> false positives identified by quast, but misfinder could distinguish these correct assemblies corresponding to structural variations.

misfinder had the highest true positive rate , while these values of quast and reapr were  <dig>  % and  <dig>  %, respectively. misfinder and quast employed the reference to anchor differences which may be assembly errors and generated accurate results, while quast had some missing calls in the scaffolds and introduced some false negatives. reapr used the inconsistence information of read coverage which was not reliable on some error regions, thus resulted in some false negatives.

from the results, it can be seen that misfinder could give accurate assembly error calls, it is because that misfinder adopted a mixed approach to combine the high quality reference and paired-end reads information, and applied the genome reference information to locate the differences between the assembly and the reference, and then aligned the paired-end reads information to validate these differences according to multiple characteristics, such as disagreements, coverage, discordant reads and multiple aligned reads information.

misfinder and quast had slight decrease on n <dig> size which dropped from  <dig>  kbp to  <dig>  kbp, while for reapr, the n <dig> size dropped dramatically from  <dig>  kbp to  <dig>  kbp, that was because reapr broke scaffolds at assembly errors over gaps, and many gaps were caused by lack of read coverage which were normal and common in scaffolds, thus introduced false broken, whereas misfinder just broke scaffolds at regions of misjoins instead. quast was the fastest  and reapr was the most time consuming , while misfinder was moderate on running time  and memory consumption .

from the above experiments, misfinder had better performance than quast and reapr on both simulated and real paired-end reads data. it generated more accurate assembly error calls because it combined the reference-based approach and de novo approach to fully utilize the information of high quality reference and paired-end reads in an unbiased way. it identified true positive mis-assemblies with few false positives and false negatives; it also distinguished the correct assemblies corresponding to structural variations from mis-assembled sequences.

performance on assembly of human chromosome  <dig> simulated reads data
human chromosome  <dig> simulated short reads data were used to test the performance of misfinder on large genomes. six modifications were introduced to the human chromosome  <dig> , including one large relocation , one duplicated sequence , two insertions  and two deletions  . we treated this mutated reference as new high quality reference, and treated the cabog assembly as the target genome in which some differences may be due to svs rather than assembly errors. as the duplicated sequence introduced one difference and the large relocation produced three differences at their joined positions, there were eight differences between the target genome and the reference. moreover, we compared misfinder with quast and reapr, and the results were shown in table  <dig> 

from the table, misfinder identified  <dig> true positives in scaffolds, with only  <dig> false negatives and no false positives, the highest precision  and true positive rate . quast identified  <dig> true positive mis-assemblies, however, there were  <dig> false positives and  <dig> false negatives, in which  <dig> false positives were corresponding to structural variations, so its precision and true positive rate were only  <dig>  % and  <dig>  %, respectively. misfinder found  <dig> correct assemblies in which  <dig> were corresponding to structural variations, whereas quast found only  <dig> of these  <dig> correct assemblies, but it treated them as assembly errors. reapr identified  <dig> true positives with  <dig> false positives and  <dig> false negatives, so its precision and true positive rate were only 77 % and  <dig>  %, respectively.

we checked the  <dig> false structural variations, and all these miscalls were caused by highly repetitive short tandem repeats with lengths larger than the read length , and one typical example was the deletion error of length  <dig> base pairs, which was caused by the highly repetitive short tandem repeat in the form of “ctttcttt…ctttcctttccttt…ccttt” with cttt and ccttt repeated many times, and reads in the genome region were well-aligned and without abnormal patterns because of the short size of the deleted sequence, so this case was difficult to be distinguished between the assembly error and structural variation. therefore, misfinder identified these  <dig> structural variations correctly and miscalled other  <dig> assembly errors as structural variations.

misfinder and quast had decrease on n <dig> size which dropped from  <dig>  kbp to  <dig> kbp, while for reapr, the n <dig> size dropped slightly from  <dig>  kbp to  <dig>  kbp, that was because reapr had much more false negatives than misfinder and quast, resulting in many assembly errors undetected.

misfinder had the least time consuming  and the highest memory consumption , because it used  <dig> threads to perform the blastn alignment, and each thread required about  <dig>  gb memory, thus it had the fastest speed and highest memory usage. if the thread number is half reduced to  <dig>  the memory consumption will half reduced accordingly, and the running time may be doubled to about 40 min. besides the blastn memory consumption, other parts of misfinder were low . quast and reapr took much more time  and less memory usage .

performance on close reference genomes with different similarities
in order to illustrate the impact of similarities on the performance between close genomes, four e.coli reference genomes with similarities ranging from  <dig>  % to  <dig>  % compared to e.coli k <dig> mg <dig> , including e.coli o157:h <dig> str. sakai , e.coli hs , and two close genome e.coli k <dig> dh10b  and e.coli k <dig> w <dig> . the 50× e.coli k <dig> mg <dig> simulated data and masurca assembly were used again to test their performances using above different reference genomes. as the main purpose of our work is to identify assembly errors to improve the assembly quality, we analyzed the identified errors and calculated the precision ) for the number of true errors among the identified errors for different reference genomes, and the results were shown in table  <dig> table  <dig> performance on close reference genomes with different similarities for the assembly of e.coli simulated reads data







from the table, it can be seen that the precision increased with the increase of the genome similarity. the e.coli strain sakai had the lowest similarity  compared to the strain k <dig> mg <dig> while the strain k <dig> w <dig> had the highest similarity , and misfinder had the highest precision  on the strain k <dig> w <dig> and the lowest precision  on the strain sakai. misfinder identified more assembly errors on the strain sakai than on other strains, however, some of the identified errors were false errors, they were miscalled because these scaffold regions were not well aligned to the reference, and some paired-end reads were also incorrectly aligned to these regions and caused some abnormal patterns , even though these regions were correctly assembled and could be perfectly aligned to the e.coli k <dig> mg <dig> reference.

for the reference genome of lower similarity, there will be more scaffold regions that could not be well aligned to the reference, and some regions may contain incorrectly aligned paired-end reads with some abnormal patterns even though these scaffold regions are correctly assembled, thus these regions may be error prone to be miscalled, whereas they may be ignored when using a higher similarity reference genome as they might be well aligned to the higher similarity reference. therefore, higher similarity reference genome may lead to better results, and we recommend the similarity of the close reference as much higher as possible.

performance on identifying structural variations
one of the main features of misfinder is finding svs between a close reference and an assembly, we tested misfinder on e.coli k <dig> mg <dig> and s.pombe jb <dig> genomes and compared its performance with lumpy   <cit> , a well-known sv finding tool, and the results were shown in table  <dig>  the e.coli mg <dig> simulated reads data and the artificially modified reference, and the s.pombe jb <dig> real reads data  and the close reference of s.pombe 972 h- were used again to perform the experiments.table  <dig> performance on identifying structural variations for e.coli and s.pombe genomes





we computed the following statistics, including true positives , false positives , false negatives , precision ) and true positive rate ). precision is the fraction of identified svs that are true, while true positive rate tpr  is the fraction of true svs that are identified. as the assembly of the mitochondrion of s.pombe  were fragmented too much , it was difficult to determine whether the identified svs were true or false, so the mitochondrion of s.pombe was excluded from the analysis.

according to the results, misfinder identified more structural variations with fewer false positives and fewer false negatives, and obtained better precision and higher true positive rate tpr on both of the two genomes than lumpy on identifying structural variations. for the e.coli genome, there were  <dig> structural variations according to the artificially modifications , misfinder identified all of them without introducing false positives and false negatives, whereas lumpy discovered only  <dig> svs with one false positive and  <dig> false negatives. for the s.pombe genome, misfinder identified  <dig> svs with one false positive and one false negative, whereas lumpy discovered only  <dig> svs with  <dig> false positives and  <dig> false negatives, resulting the presision and tpr were only  <dig>  and  <dig> , respectively.

moreover, there were some novel sequences in s.pombe jb <dig> compared to s.pombe 972 h-, misfinder identified these novel sequences as structural variations while lumpy could not find these novel sequences because lumpy does not contain the assembly process. for example, there were  <dig> novel sequences in s.pombe jb <dig> with lengths ranging from  <dig> kbp to  <dig> kbp compared to s.pombe 972 h-, but lumpy could not find these novel sequences.

discussion
we have developed an open-source mis-assembly identification method, misfinder, which identifies the assembly errors by combining the reference and paired-end reads information. the main purpose of our work is to improve the assembly quality by identifying the mis-assemblies excluding the differences caused by structural variations between the target genome and the reference genome.

there are many repeats  in genome, and they are difficult to be resolved in assembly. therefore, assembly is usually broken in these repeat regions, and as a result, the repetitive sequences appear at the scaffold ends in most cases, only a few repeats occur in the inner parts of scaffolds. this is consistent with our experiments.

for the repeats, they should be considered together with the scaffolds they belonged to, even though they have multiple aligned locations in the reference. so, if the repeats are well aligned to the reference together with their scaffolds, the other locations of the repeats will not be considered in our method. therefore, most of the duplicated sequences have no much impact to the mis-assembly identifications.

for the structural variation identification, paired-end reads are aligned to the reference , and some abnormal patterns of paired-end reads are applied to call structural variations. however, in our method, scaffolds are first aligned to the reference to determine their differences, and these differences may be caused either by mis-assemblies or by structural variations. and then, paired-end reads are aligned to the scaffolds  to distinguish mis-assemblies using those abnormal patterns of paired-end reads. and according to our experiments, the differences that are due to structural variations usually have no abnormal patterns, thus can be excluded. note that we only consider the scaffold regions that have differences with the reference rather than other well aligned scaffold regions.

however, some assembly errors caused by highly repetitive short tandem repeats are difficult to be correctly resolved, some of them may be miscalled as structural variations because the lengths of inserted/deleted sequences are typically short  and their breakpoint regions usually have well-aligned paired-end reads and no abnormal patterns. some of these short tandem repeats are difficult to be resolved by misfinder and may cause some mis-identifications, and the lengths of these highly repetitive short tandem repeats are usually longer than the read length, and we think that increase the read length may help to identify these assembly errors more accurately.

moreover, some scaffold regions have some mismatches and abnormal coverage depth even though these regions are perfectly aligned to the reference. the reason is that these regions are similar with some other genomic regions which are not successfully reconstructed during assembly , and paired-end reads derived from these missing regions are incorrectly aligned to the similar regions with some mismatches, and as a result, abnormal patterns are shown in some well aligned scaffold regions . but, these regions are well aligned to the reference , so they are correctly constructed, and we do not consider these well aligned regions to prevent miscalls in our method.

CONCLUSIONS
even though there is a high-quality genome reference, for genome sequencing , there are usually some differences between the target genome and the reference genome as the two genomes are not exactly the same. for the assembly of a target genome, it may contain many differences may be caused by assembly errors or structural variations. when calling the assembly errors, if we do not consider the differences between the target genome and the reference genome, the results may contain some biases.

in this article, we present misfinder, a tool that aims to identify the assembly errors with high accuracy in an unbiased way and correct these errors at their misjoined positions to improve the assembly accuracy before downstream analysis. it uses the reference  to find the differences between the scaffolds and the reference, and uses multiple features extracted from the paired-end reads to validate these differences to determine whether they are assembly errors or correct assemblies corresponding to structural variations. experiments showed that misfinder could identify the assembly errors with fewer miscalls, and the correction almost has no much impacts on the continuity of the assembly both for simulated e.coli reads data and real s.pombe dataset. human chromosome  <dig> experiments showed that misfinder could identify the assembly errors and correct them to improve the assembly quality for large genomes.

availability of supporting data
misfinder was implemented in c language on linux x86_ <dig> machine. the source code can be freely downloaded from https://github.com/hitbio/misfinder.

additional file
additional file 1: 
pattern screenshots for assembly errors. the file gives screenshots of different patterns for assembly errors, including misjoins, insertions and deletions for the assembly on e.coli simulated paired-end short reads data. the file also gives the screenshots of identified novel sequences for the s.pombe strain jb <dig> genome comparing to the reference of s.pombe strain 972 h-. the file still gives some detailed information for the artificially modified references for e.coli and human chromosome  <dig>  



competing interests

the authors declare that they have no competing interests.

authors’ contributions

xz developed the computational methodologies and implementation, run the studies and drafted the manuscript. hcml and rw performed the experiments, analyzed the data and drafted the manuscript. smy, fylc contributed to guide the developments and analysis and reviewed of the manuscript. gq guided the development and gave useful ideas in early studies. yl, rz, qj, bl, yd and gz analyzed the results and gave some suggestions. yw conceived and managed the study, guided the development and analysis. all authors reviewed and approved the final manuscript.

