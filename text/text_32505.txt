BACKGROUND
the multiple sequence alignment problem is still the holy grail of bioinformatics  <cit> . there are  <dig> sequences in the uniprotkb/swiss-prot release of the 18th of may  <dig> http://expasy.org/sprot/, while on the other hand, there are only  <dig> known structures in the last pdb database relase of the 8th of june  <dig> http://www.pdb.org/pdb/home/home.do. therefore, the in silico prediction of protein structures is still demanding, and the majority of the protein structure prediction methods need accurate alignments. there are two major technical hurdles in the multiple sequence alignment problem. the first is the scoring problem: how to score the alignments such that the best scored alignment is the most accurate one. the second is the algorithmic problem: how to find the best scored alignment.

significantly more effort has been put into the research for solving the second challenge. although the number of possible alignments of two sequences grows exponentially with the length of the sequences, finding the best scoring alignment of two sequences is computationally feasible, since such an alignment can be found by iteratively comparing the prefixes of the two sequences  <cit> . the optimal alignment of longer prefixes can be calculated quickly from shorter prefixes, and hence, the algorithm needs only memory and running time that both are proportional to the product of the lengths of the sequences. this dynamic programming algorithm can be extended to many sequences  <cit> , however, it becomes computationally infeasible, since analysing all possible combinations of prefixes requires o memory and running time. it has been proven that finding the best scoring multiple alignment under the sum-of-pairs scoring scheme is np-hard  <cit> , therefore it is very unlikely that any fast algorithm exists for the exact multiple sequence alignment problem.

the memory requirement and running time can be reduced by corner-cutting methods. corner-cutting algorithms define a narrow strip in the dynamic programming table which contains the optimal alignment. some methods use an a priori estimated upper limit for the score of the optimal alignment to define such a strip  <cit> . hein et al. obtained a strip around the parsimony-based optimal alignment for hmm-based calculations  <cit> . the strip can also be defined on the y using the so-called diagonal extension method  <cit> . the corner-cutting method has been extended to multiple sequence alignment, too  <cit> , with which the optimal alignment of 4- <dig>  each 200- <dig> long sequences can be found in reasonable time  <cit> . however, even the size of the narrowest possible strip - which has a unit hypercube transverse section - grows exponentially with the number of sequences to be aligned, hence, this approach eventually becomes unfeasible for large number of sequences.

above exact methods, approximation methods for the multiple sequence alignment problem are also widespread. the most commonly used approximation to multiple sequence alignment is the progressive alignment approach  <cit> , which builds multiple sequence alignments bottom-up along a guide tree, through a series of pairwise alignments of two sequences , two alignments , or a sequence and an alignment. the guide tree is typically constructed from the pairwise distance matrix of the sequences that is computed using pairwise sequence alignments. these methods apply the "once a gap, always a gap" rule  <cit> : gaps inserted into an alignment at an inner node of the guide tree cannot be removed or modified further up in the guide tree. although one can trust more in gaps introduced at the lower nodes of the guide tree, there is no guarantee that these gaps are correct, and a gap that has incorrectly been inserted into a subalignment based on local information cannot be corrected later on.

there have been successful attempts in other directions to reduce the computational time required to align sequences. mafft employs the fast fourier transformation  technique to rapidly identify homologous regions by converting the amino acid sequence into a sequence of volume and polarity values  <cit> . the two basic optimisation heuristics  have been substituted by more advanced iterative methods in the most recent version of the software where pairwise alignment information is incorporated into the objective function, thus making mafft one of the most accurate alignment tools available.

one artifact shared by all of the previously mentioned methods is that evolutionary events are scored using user-specified values . the accuracy of the alignments largely depends on the selection of these parameter values. to overcome these difficulties the statistical alignment approach has been introduced where evolutionary models describe the type of events that transform the sequences and provide a means of calculating the probability of a sequence of events. the alignment is then produced in an optimisation framework such as maximum likelihood or markov chain monte carlo by finding the set of events explaining the evolution of the sequences with a high probability and the parameters of the evolutionary model are estimated from the data. this approach is taken by computationally expensive methods such as bali-phy  <cit>  and statalign  <cit>  that integrate over all possible tree topologies. to make this more practical, fsa uses only pairwise comparisons in a statistical alignment framework and so reduces the running time drastically while sacrificing some of the accuracy  <cit> .

in this paper, we introduce a novel corner-cutting method combined with progressive sequence alignment. unlike former corner-cutting methods, our method does not define a compact part of the dynamic programming table to be filled in. the rationale behind the idea is the following. it is easy to see that any high-scored alignment is surrounded by a large set of low-scored alignments, and the number of low-scored alignments increases exponentially with the number of sequences. indeed, a high-scored alignment contains several alignment columns containing homologous amino-acids. there are 2k - <dig> ways to split an alignment column containing k characters into two columns with gaps. any alignment containing such pair of alignment columns will be a neighbour of the high-scored alignment in the dynamic programming table. furthermore, the score of these alignments will be significantly lower than the score of the high-scored alignment, since the scores differ in two gap scores and the scores missing due to not aligning homologous amino-acids.

instead of defining a compact part of the dynamic programming table, our approach stores a set of optimal and suboptimal alignments at each step of the progressive alignment procedure. at an internal node of the guide tree, the two sets of alignments of the two children nodes are aligned against each other. we use a special data structure for both representing the alignments and aligning the set of alignments against another set of alignments. the common parts of the alignments are represented only once, and aligned only once, thus saving a large amount of memory and running time. the alignments in our representation form a reticulated network , hence the name of the method. previous works showed that the convex hull of the optimal and suboptimal alignments might be relatively large . the volume of this convex hull grows exponentially with the number of alignments. on the other hand, our method maintains only the reticulated network instead of the entire convex hull thus saving a large amount of memory.

the method has been implemented in the java programming language, tested on the balibase database  <cit> , and compared with clustalw  <cit> , mafft  <cit>  and fast statistical alignment   <cit> . several scoring schemes have been implemented and assessed in the reticular alignment algorithm. we show that reticular alignment outperforms clustalw even if a simple scoring scheme is applied. when sophisticated scoring models are applied  reticular alignment outperformes fsa and even mafft in some accuracy measurement.

methods
in this section, we describe the algorithms and theorems which are the theoretical background of the reticular alignment algorithm.

the waterman-byers algorithm and x-networks
let a and b be two sequences over an alphabet Σ, of lengths n and m, respectively. let ai denote the i long prefix of sequence a, and let ai denote the suffix of a starting in the i + 1st position. in this way, ai ◦ ai = a, where ◦ denotes concatenation. let ai denote the character of a in position i.

let s : Σ × Σ → r be a similarity function. go will denote the gap opening and ge will denote the gap extension penalty. the score of any alignment, and thus all introduced concepts based on the alignment scores depend on the choices on similarity function, gap opening and gap extension penalty. however, for sake of simplicity, we omit to denote this dependence.

the waterman-byers algorithm  <cit>  produces all alignments that have a score no less than the score of the optimal alignment minus some constant value. here we show a variant of the algorithm that our method is based on. the algorithm is built up of  <dig> parts: a forward-align algorithm, a backward-align algorithm, and the alignment search algorithm that finds all alignments above a given score using the scores calculated by the forward and backward algorithms.

the forward-align algorithm calculates the score of the best alignment of prefixes ai and bj within the following  <dig> subsets of alignments:

• alignments ending in two aligned  characters. the score of the best alignment of prefixes ai and bj in this set is denoted by mf .

• alignments ending in an insertion of character bj. the score of the best alignment of prefixes ai and bj in this set is denoted by if .

• alignments ending in a deletion of character ai. the score of the best alignment of prefixes ai and bj in this set is denoted by df .

the score of the optimal alignment of prefixes ai and bj is then max{mf , if , df }. mf , if and df can be efficiently calculated using dynamic programming. the dp tables are initialised as:

  mf= <dig> 

  if=df=−∞ 

  mf=if=−∞   i> <dig> 

  df=g0+∗ge   i> <dig> 

  mf=df=−∞   j> <dig> 

  if=go+*ge   j> <dig> 

the dynamic programming recursion then goes from shorter prefixes towards larger prefixes in the following way:

  mf=max{mf,if,df}+s 

  if=max{mf+go,if+ge,df+go} 

  df=max{mf+go,if+go, df+ge} 

the backward-align algorithm is more sophisticated. let ai/-j denote the alignment column showing deletion of ai in an alignment in which the first character in sequence b to the left of this alignment column is bj. similarly, let -i/bj denote the alignment column showing the insertion of character bj in an alignment in which the first character in sequence a to the left of this alignment column is ai. the backward algorithm calculates the following three types of entries:

 <dig>  mb denotes the score of the best alignment of suffixes ai and bj whose score is calculated as if the ai/bj alignment column was before it. namely, if the alignment starts with a gap, it will be scored with the gap opening penalty.

 <dig>  ib denotes the score of the best alignment of suffixes ai and bj whose score is calculated as if the -i/bj alignment column was before it. namely, if the alignment starts with an insertion, it will be scored with the gap extension penalty.

 <dig>  db denotes the score of the best alignment of suffixes ai and bj whose score is calculated as if the ai/-j alignment column was before it. namely, if the alignment starts with a deletion, it will be scored with the gap extension penalty.

these backward alignment scores can also be computed using a dynamic programming approach similar to the forward case. the initialisation of the backward dp tables is:

  mb=ib=db= <dig> 

  mb=ib=go 

  mb=ib=go+*ge   i<n− <dig> 

  db=*ge   i> <dig> 

  mb=db=g0+*ge   j<m− <dig> 

  mb=db=go 

  ib=*ge   j> <dig> 

the dp tables are then filled from the shorter suffixes towards the longer suffixes, that is, backward on the indices. the recursions:

  mb=max{mb+s,ib+go, db+go} 

  ib=max{mb+s,ib+ge, db+go} 

  db=max{mb+s,ib+go,db+ge} 

using the forward and the backward scores it is possible to find all alignment columns that appear in an alignment with a score above a given threshold. this is based on the following theorem:

theorem 1
the score of the best alignment containing alignment column ai/bj  is mf  + mb  + ib, df  + db) .

proof
we give a proof for the first case, the proof for the other two cases goes in the same way. if an alignment contains ai/bj, then cutting the alignment after this alignment column will create two alignments. the left one is an alignment of prefixes ai and bj in which the last alignment column is ai/bj. the right one is an alignment of suffixes ai and bj whose score is calculated by adding the alignment column ai/bj before it. the best scored alignment containing ai/bj are cut into the best scored left and right alignment, by definition, with scores mf  and mb. the score of the alignment is the sum of these two values.

theorem  <dig> provides the means to collect the alignment columns that participate in an alignment having score above a given threshold. the best score of the alignment column will be denoted by b. we define the x-network of the alignments in the following way.

definition
for any sequences a and b, x ≥  <dig>  the x-network of the alignments of a and b is a directed graph g. the vertex set consists of alignment columns α for which b ≥ opt - x, where opt is the score of the optimal alignment of a and b; plus two auxiliary vertices, representing the beginning and the end of the alignment. these two auxiliary vertices are denoted by start and end. an edge is going from vertex α <dig> to vertex α <dig> if there is an alignment in which α <dig> is followed by α <dig>  the outgoing edges from the start vertex go to the alignment columns with which the alignment might start, and the incoming edges of the end vertex come from the alignment columns that might be at the end of an alignment.

the following theorem states that an x-network never contains dead ends.

theorem 2
for any sequences a, b, x ≥  <dig>  and α vertex of the x-network, there is a directed path from start to α and also from α to end.

proof
since α is in the x-network, b ≥ opt - x. consider an alignment containing α with score b. any α' of this alignment has a best score greater or equal than b, hence they are all in the vertex set of the x-network. this alignment defines one possible directed path from start to α and also from α to end.

an x-network can be constructed using an algorithm that first runs the forward and backward algorithm to calculate b for each possible alignment column α, selects those columns for which b ≥ opt - x, and builds the network from them.

aligning a network of alignments to a network of alignments
we are going to extend the waterman-byers algorithm to align a network of alignments to another network of alignments. first we define the network of alignments.

definition
a network of alignments of sequences a <dig>  a <dig>  . . . ak, k ≥  <dig> is a directed acyclic graph whose vertices are alignment columns of the set of sequences together with a unique source  and a unique sink . the vertices along any path from the source to the sink form a multiple sequence alignment of the set of sequences.

obviously, an x-network is a network of alignments. moreover, any single sequence  can be considered a simple, formal network. in that case, the formal alignment columns contain only one character, and the network is a single line containing only one alignment. we can generalise the definition of the x-network of two sequences to the x-network of two networks of alignments. for this, we first have to define the alignment of alignments.

definition
an alignment of two alignments a and ℬ of sequences a <dig>  a <dig>  . . . ak and b <dig>  b <dig>  . . . bl is a multiple sequence alignment of these k + l sequences such that the non all-gap columns of the first k rows gives back a, and the non all-gap columns of the last l rows gives back ℬ.

when we take an alignment column containing all-gap characters in the first k rows or in the last l rows, we indicate what was the previous non all-gap alignment column from a or ℬ. for example, ai/-j indicates an alignment column in which the first k row is the ith alignment column from a, the last l rows contain only gaps, and the first alignment column to the left of this alignment column in which the last l rows contain not only gaps is the jth alignment column from ℬ. in the next definition when we talk about alignment columns from the multiple alignment of all as and bs sequences, we always mean alignment columns containing this additional information. similarly, from now on, we always assume that the alignment is an alignment of two alignments, the first containing k lines, the second containing l lines.

definition
for any two networks of alignments a and b and x ≥  <dig>  the x-network of a and b is a directed graph g. the vertex set consists of two auxiliary vertices, representing the beginning and the end of the alignment and all alignment columns α for which b ≥ opt - x, where b is the maximal score of the alignment that can be achieved by aligning an alignment a ∈ a to an alignment ℬ ∈ b so that it contains the column α. opt is the maximal score that can be achieved by aligning any alignment a ∈ a to any alignment ℬ ∈ b. an edge is going from α <dig> to α <dig> if there is an alignment in which α <dig> and α <dig> are neighbour columns. the outgoing edges from start go to the vertices that might be the first alignment column in an alignment, and the incoming edges of the end vertex come from the vertices that might be the last alignment column in an alignment.

when we align a network to a network using a dynamic programming algorithm, it is important to visit the alignment columns of the network in an order such that the entries are already calculated by the time we want to use them in the dynamic programming recursion. therefore we introduce the linear extension of networks that can be used for traversing the network.

definition
a linear extension of a directed acyclic graph is a total ordering, <, on the vertices such that for any two vertices v and u, if there is a directed path from v to u then v < u.

furthermore, the forward-align and the backward-align algorithms work with prefix-alignments and suffix-alignments defined in the following way.

definition
a prefix-alignment is a prefix of an alignment achievable by aligning an alignment a ∈ a to an alignment ℬ ∈ b. similarly, a suffix-alignment is a suffix of an alignment achievable by aligning an alignment a ∈ a to an alignment ℬ ∈ b.

the generalisation of the waterman-byers algorithm is the following. the input consists of a threshold value x ≥  <dig> and a couple of networks of alignments, a and b, together with a linear extension for each network. the output is the x-network of a and b together with a linear extension of it.

the algorithm uses a forward and a backward dynamic programming algorithm. the forward align algorithm calculates the score of the best prefix-alignment in which the last non all-gap columns in the first k lines is ai and in the last l lines is bj for each subset of alignments:

• alignments ending with ai/bj. the score will be denoted by mf .

• alignments ending with -i/bj. the score will be denoted by if .

• alignments ending with ai/-j. the score will be denoted by df .

the initialisation is:

  mf= <dig> 

  if=df=−∞ 

the dynamic programming algorithm visits the vertices of the two networks in their linear order. the recursions are:

  mf=maxi'∈n+maxj'∈n+{mf,if, df}+s 

  if= maxj'∈n+ {mf+g,if+g,df+g} 

  df= maxi'∈n+ {mf+g,if+g,df+g} 

where n+ is the set of indices of vertices sending an edge to the vertex indexed by i, and g is the gap penalty function for alignment column b/d preceded by alignment column a/c. we assume that the gap penalty for a given alignment column can be calculated from the alignment column in question and its preceding alignment column. see details in the subsection gap penalties below. the maximum of an empty set is defined to be - ∞.

the backward algorithm calculates the following scores:

• mb denotes the score of the best suffix-alignment that can follow the alignment column ai/bj. furthermore, the gap score of the first alignment column is calculated as if ai/bj was inserted before the first alignment column.

• ib denotes the score of the best suffix-alignment that can follow the alignment column -i/bj. furthermore, the gap score of the first alignment column is calculated as if -i/bj was inserted before the first alignment column.

• db denotes the score of the best suffix-alignment that can follow the alignment column ai/-j. furthermore, the gap score of the first alignment column is calculated as if ai/-j was inserted before the first alignment column.

the initialisation of the dynamic programming algorithm is

  mb=ib=db=0∀n∈n+, m∈n+ 

where n+ and n+ are the sink vertex of networks a and b, respectively.

the dynamic programming algorithm visits the vertices of the two networks backward in their linear extension. the recursions are

  mb=maxi'∈n−maxj'∈n−{mb+s,ib+g,db+g} 

  ib=maxi'∈n−maxj'∈n−{mb+s,ib+g,db+g} 

  db=maxi'∈n−maxj'∈n−{mb+s,ib+g,db+g} 

where n− is the set of indices of vertices to which an edge is going from the vertex with index i. similarly to theorem  <dig> , it is true that the best score of alignments containing ai/bj, -i/bj and ai/-j is mf  + mb, if  + ib and df  + db, respectively. therefore, the pair of indices  is visited in lexicographical order, and those alignment columns α = ai/bj or -i/bj or ai/-j are selected for which b ≥ opt -x. the maximal score, opt, can be calculated from the following equation

  opt=maxn∈n+maxm∈n+{mf,if,df} 

similarly to theorem  <dig> , it is easy to show that there are no dead ends in the so constrained network. the following theorem states that visiting the alignment columns in lexicographical order will provide a linear extension for the constructed x-network.

theorem 3
the lexicographical ordering of alignment columns together with arbitrary ordering of ai/bj, -i/bj and ai/-j is a linear extension for the x-network of networks a and b if the indices i's and j's are linear extensions for the networks a and b, respectively.

proof
the preceding alignment columns for ai/bj might be ai'/bj', -i'/bj' or ai'/-j' for some i' ∈ n+ and j' ∈ n+. since indices in a are linear extensions, i' < i for any i' ∈ n+, and thus, in the lexicographical order, all possible preceding alignment columns are smaller than ai/bj.

the preceding alignment columns for -i/bj might be ai/bj', -i/bj' or ai/j' for some j' ∈ n+. since indices in b are linear extensions, j' < j for any j' ∈ n+, and thus, in the lexicographical order, all possible preceding alignment columns are smaller than -i/bj

the preceding alignment columns for ai/-j might be ai'/bj, -i'/bj or ai'/-j for some i' ∈ n+. since indices in a are linear extensions, i' < i for any i' ∈ n+, and thus, in the lexicographical order, all possible preceding alignment columns are smaller than ai/-j.

the reticular alignment algorithm
the reticular alignment algorithm is the following:

 <dig>  build or load a guide tree for the sequences

 <dig>  transform the sequences at the leaves of the guide tree into simple 'linear' networks

 <dig>  visit the internal nodes of the guide tree in reverse traversal order. for each internal node v with children u <dig> and u <dig>  labelled with the networks of alignments a <dig> and a <dig>  respectively, calculate the xv-network of a <dig> and a <dig> using the generalised waterman-byers algorithm

 <dig>  return the best scored alignment from the x-network calculated at the root of the guide tree.

when x is set to  <dig>  only the  optimal multiple alignments are stored in the x-network. in this case, the reticular alignment algorithm mimics a standard progressive alignment method. when x is set to ∞, the reticular alignment method performs an exhaustive search in the space of multiple alignments, namely, it finds the best scored alignment. as x increases, the size of the network also increases, having a similar effect on the running time and memory usage. along with the x value the reticular alignment algorithm can be parameterised in a list of ways:

• guide tree construction method

• similarity scoring of alignment columns

• gap scoring model and gap penalties

• strategy to select threshold values at the internal nodes

here we briefly describe the choices we had and the decisions we made considering these aspects of the algorithm.

building the guide tree
standard methods for constructing a guide tree using pairwise comparisons of the input sequences include upgma and neighbour joining   <cit> . we implemented both and allow the user to choose between the two algorithms or to provide their own guide tree.

the nj algorithm generates an unrooted tree. because retalign requires a rooted tree that can be traversed from the leaves upwards, we root the tree using the 'mid-point' method as described in  <cit> . the computationally most expensive step of the guide tree construction process is the calculation of the pairwise distances between the sequences. for increased accuracy, we opted to perform a full dynamic programming alignment between each pair of sequences and transform the similarity scores into distances using the formula:

  dij=sii+sjj−2sij 

in a future version of retalign we plan to implement a basic optimisation such as the hirschberg algorithm  <cit>  to reduce the memory usage of this initial alignment phase from Θ to Θ where l is length of the longest sequence.

gap penalties
it is well known that affine gap penalties  generate significantly more accurate pairwise alignments than linear gap penalties. therefore it seems reasonable to define similar gap penalties for multiple sequence alignments. one natural way is the sum-of-pairs scoring with affine gap penalty, when one generates all pairwise alignments from the multiple alignment, removes all-gap columns, scores the so-obtained alignment using affine gap penalty, and sums these scores over all pairwise alignments. surprisingly, finding the best sum-of-pairs scored multiple alignment between two multiple alignments is np-complete  <cit> . the heuristic explanation is that the question whether a gap-opening or a gap-extension penalty should be calculated for an alignment column can be answered only after removing the all-gap alignment columns from the pairwise alignment taken from the multiple alignment. rarely can the question be answered by looking back at the previous alignment column only. the exact sum-of-pairs scoring problem is generally hard to solve, but in some cases it can be solved unambiguously by looking back at the previous alignment column. furthermore, it can always be solved this way when aligning only two sequences. we developed a gap scoring scheme that approximates the sum-of-pairs gap score and can be calculated efficiently by looking at adjoining alignment columns only. we assign a score to each combination of patterns that any two rows from two adjoining columns can form. these scores then need to be summed for all sequence  pairs to obtain the indel score for the two columns. the full indel score for a multiple alignment is then the sum of the indel scores of the consecutive alignment columns. the indel matrix on table  <dig>  shows the score value used for each pattern combination. the goals in mind when filling up this matrix were to make the resulting scoring

row: indel pattern formed by two consecutive columns of the 1st sequence, column: that of the 2nd sequence. op and ex are the gap opening and extension penalty.

• consistent in that it does not depend on the order of the sequences within the selected pairs 

• symmetric - the reverse of a multiple alignment has the same score 

• best approximate the sum-of-pairs scores

the simplest case to consider is when there is an insertion in one of the sequences: *−−−******

the sum-of-pairs indel score of this alignment is op + 2ex where op and ex are the gap opening and extension penalty. this - and any similar cases where the length of the insertion is different - can be mimicked precisely if  the score of the pattern −−** is ex while the score of *−** and −*** is both op/ <dig> due to the symmetric property. the score of *−−* is op for similar reasons as it starts a new sequence of gaps in both directions. with this choice cases such as *−−******−−* are handled properly. to avoid significant overestimation of the score of *−−−**−−−* which is  <dig> in the sum-of-pairs scheme, a score of  <dig> must be assigned to both −−−− and −*−* then the only pattern left to assign a score to is *−−− . the problem with this one is that the score should depend on whether the gap in *− is extended in the next non-gap-only column to the right. the three possibilites are  *−−*−−−−,  *−−−−−−* and  *−−*−−−* so it is easy to see that a score of ex/ <dig> suffices for  and op/ <dig> does for   so the total scores of ex, op and op/ <dig> are obtained that match the scores of the corresponding patterns formed by removing the gap-only columns). we resolved the ambiguity by choosing op/ <dig> as the score because we expected this to provide the best approximation of the sum-of-pairs scores with a systematic overscoring in cases such as . other alternatives include ex or ex/ <dig>  both of which have been later shown to yield slightly lower overall accuracy as measured on the balibase reference database.

in addition to retalign's default pairwise indel score model presented above we also implemented the simplified, non-pairwise indel scoring method used in clustalw. in this scheme, when two sets of sequences are aligned, each insertion or deletion of a full alignment column receives a single gap penalty - even if the alignment column contains several gaps. this score can be computed considerably faster  but creates anomalies when suboptimal alignments are inserted or deleted: the gaps 'hidden' in the columns of the suboptimal alignments are not penalised and these columns become overly represented in the final alignment . unlike the pairwise indel scoring this score cannot be used as an accuracy measure of multiple alignments because it depends on which sets of sequences are being aligned in the last step.

scoring similarities
we score substitutions in accordance with the sum-of-pairs scoring scheme. a similarity score is computed for each alignment column as the sum of similarity values for each pair of non-gap characters in the column . the similarity score is also computed for columns where an insertion or deletion occurs and creates a stack of gaps in the ongoing alignment step. the total similarity score of an alignment is simply the sum of similarity scores for all columns.

this pairwise scoring method is slightly different from clustalw's approach where the substitution score is dependent on what the two sets of sequences are that are being aligned: only 'cross-scores' are taken into account . the similarity score of columns with insertion or deletion in the ongoing alignment is thus zero. we also implemented this modified similarity scoring method and combined it with the non-pairwise indel scoring shown in the previous section to imitate clustalw's scoring model.

internal score and sequence weighting
we introduced the indel and similarity scoring models of retalign in the last two sections. the total  score of a multiple alignment as produced by retalign is the sum of the indel and similarity scores, both of which are calculated pairwise. though very similar, this score slightly deviates from the sum-of-pairs score as a result of the approximation of the indel score using adjoining alignment columns only - this is explained in detail above. in practice we did not encounter any situation where the difference was significant and the optimisation targeted to maximise the internal score efficiently boosted the sum-of-pairs score, too. both scores are completely independent from the phylogenetic tree connecting the sequences and can be used as an accuracy measure.

one inherent weakness of the sum-of-pairs scoring, though, is that evolutionary events separating a distant sequence from a number of closely related  sequences are overscored - one evolutionary event in time might be penalised several times in the alignment score. to overcome this, we introduced sequence weighting, based on principles set out in clustalw. first, a list of weights is calculated and assigned to sequences using the topology and edge lengths of the guide tree, precisely as described in  <cit> . the weight of a sequence is calculated from the edge lengths of the branches leading to the sequence from the root node, and edge lengths of branches that are shared by two or more sequences are divided up equally between them. the weights are the sums of these partial lengths. once the weights are available, the pairwise scoring method can be applied with the modification that whenever a score is calculated for a pair of sequences it is multiplied by both sequence weights. the sum of these weighted scores gives rise to an overall score that is much less biased by the overrepresented sequences.

threshold values
the size of the alignment space that is being explored by the reticular alignment algorithm and consequently, the accuracy of the alignments created depends on the strategy for choosing an x value for each alignment step at the internal nodes. we chose to set the x value dynamically such that the final size of the alignment network is at most % of the length  of one of the best scored multiple alignments, where t is a threshold parameter set by the user. note that this is the "threshold to be passed for computation" value on the gui of our application. the slider underneath is just for convenience, with a log transformation. for any such t value, the corresponding x value can be found by building the network gradually: at first, alignment columns are placed in a priority queue where the key is the score of the best alignment they appear in; then groups of columns having equal score are removed from the queue iteratively, starting with the ones having the highest score, and added to the growing network en masse while the size limit permits.

this approach is more advantageous than if the x was constant or set to a fixed proportion of the optimum score because the later would have an unpredictable effect on the running time and memory usage and could also cause the alignment networks to vary considerably in relative size at the internal nodes. in contrast, with our method, the memory requirement can be estimated from t and the proportion of the number of suboptimal alignment columns to optimal columns is uniform over the whole tree.

efficient score calculation
the scoring scheme of retalign involves summing similarity values and gap penalties for all sequence pairs. these pairwise summations are carried out repeatedly on alignment columns  and pairs of columns  to fill each element of the dynamic programming tables. the straightforward implementation can thus have a huge impact on the running time when many sequences are aligned. for this reason we developed techniques to speed up these calculations.

the two problems are essentially the same: given a list of pattern values v <dig>  . . . vn, pairwise pattern scores must be summed for all pairs: s=∑i=1n∑j=1nm,   vi∈   {p <dig> …pk}. in the similarity score case, the patterns are the residues  and the matrix is the similarity matrix, while in the indel score case there are  <dig> different patterns formed by two successive characters, both either gap or non-gap. the trick is simple: first count how many of each pattern type is present in the column, then sum the score value for the pair of types multiplied by the counts:

cj=∑i=1nδvi,pj so that now s=∑i=1k∑j=1kcicjm. one distinct bonus of the idea is that it can be naturally adapted to sequence weighting: if w <dig>  . . . wn are given in addition to the patterns then sw=∑i=1n∑j=1nwiwjm can be calculated as sw=∑i=1k∑j=1ksisjm where sj=∑i=1nwiδvi,pj i.e. the count for each pattern type must simply be substituted by the sum of sequence weights for patterns of each type to obtain the scoring scheme with sequence weighting. it is an important implementation consideration how the list of counts or weight sums is represented. for the indel case, we opted to use an array of fixed length of  <dig> that means the calculation of a column score requires n +  <dig> steps. in the similarity score case, however, we chose to store a list of  pairs so that the calculation takes only n + l <dig> steps where l is number of different character types present in the column. though this requires one or two additional table lookups per iteration, the savings are huge when there are conserved columns made up of just a few different characters.

RESULTS
we implemented the reticular alignment method in the java programming language with all features for the choices of parameters as described in the previous section. the method was tested on the balibase database  <cit> , and compared with clustalw  <cit> , mafft  <cit>  and fast statistical alignment   <cit> . balibase is a database of manually-refined multiple sequence alignments specifically designed for the evaluation and comparison of multiple sequence alignment programs. the alignments are categorised by sequence length, similarity, and presence of insertions and n/c- terminal extensions. core blocks are identified excluding non-superposable regions.

balibase provides a scoring tool  to measure the accuracy of sequence alignments based on the reference alignments in the database. this tool offers two accuracy measures  and allows assessment based on either all or a subset of alignment columns thus essentially giving four different accuracy scores. sp is the number of correctly aligned residue pairs divided by the number of aligned residue pairs in the reference alignment, tc is the number of correctly aligned columns divided by the number of columns in the reference alignment. sp and tc can also be calculated on columns of the core blocks only - these feature columns are described in the balibase database by separate files. we denote the so-obtained scores 'feature sp' and 'feature tc'. all four of these scores can be regarded as a sensitivity measure  because characters/columns incorrectly shown homologous do not decrease the score.

we measured the accuracy of the reticular alignment method on balibase v <dig>  and v <dig>  ref1- <dig> datasets and compared it to the performance of the well-known alignment software clustalw, mafft and fsa. see results in figure  <dig> and  <dig>  to separate the effect of the guide tree and allow a fair comparison of the alignment strategies we re-run clustalw and retalign with the guide tree fixed to the one created by mafft. results are shown in figure  <dig> 

we were interested in how the accuracy of our method depends on different parameters. since the parameter space is four dimensional  with several choices along each dimension, we do not show the results for each possible combinations of parameters. two parameters  influence only the score of the multiple alignments, one parameter  influences how to search in the search space, and one parameter  influences the search strategy , and might also influence the way of scoring alignments . for each fixed score function, we tested how the alignment accuracy changes with the t parameter, namely, how much the accuracy can be improved by a deeper search in the alignment space. some of our findings are quite surprising, discussed in the following subsections.

alignment accuracy generally increases with the deepened search in the alignment space
as the main novelty of our method is the sophisticated search for the best scored alignment, we first show the effect of the t parameter on the alignment accuracy. the average alignment accuracy improves as the t parameter increases, see figure  <dig>  however, this increase is not monotonous. there might be two reasons why a widened search may yield worse alignments. the first reason is simple: the better scored alignments are less accurate, hence, although the wider search found better scored alignments, these alignments agree less with the balibase benchmark. the second reason is more sophisticated, and to understand this, the reader must have in mind that the globally optimal alignment might be achived via suboptimal solutions during the progressive alignment method. having said this, imagine the following situation : at a given reticular threshold value t <dig>  the best alignment at internal node va has a score sa, and an xa,1-network is generated at va. from this network, the best alignment at some ancestral node of va, denoted by vb has a score sb, <dig>  and an xb,1-network is generated at vb. from this network, the best alignment at the root of the guide tree has score sr, <dig>  now we change the threshold to t <dig>  the best alignment at node va is still the same, but we create a larger, xa,2-network at this node, xa, <dig> >xa, <dig>  from this network, we are able to find a better scored alignment at node vb, which has score sb, <dig> >sb, <dig>  we build up an xb,2-network around this node, but it might happen that sb, <dig> - xb, <dig> >sb, <dig>  this means that the new xb,2-network does not contain any alignment from the old, xb,1-network! therefore, the progressive alignment method with reticular threshold t <dig> will operate on a set of alignments above the node vb which are completly different from the set of alignments appeared during the progessive alignment method with reticular threshold t <dig>  the consequence is that the best alignment at the root obtained from the xb,2-network might have a score sr, <dig> <sr, <dig>  namely, the score of the final alignment might decrease with increasing the reticular threshold parameter.

to test the second hypothesis, the internal score of the alignments were measured, i.e. the score that the reticular alignment algorithm was to maximise. the dependency of this internal score on the t threshold value is shown on figure  <dig>  on average, this internal score is monotonously increasing, although we did find example sets of sequences for which the internal score decreased by increasing t. however, these examples were relatively rare. hence, the slight occasional decrease in the accuracy caused by the increase of t is mainly due to the non-perfect correlation between the retalign's internal score of an alignment and the alignment accuracy measured on balibase. the most interesting case is discussed in the next subsection.

comparing single and pairwise gap penalties
clustal uses a simple non-pairwise gap-penalty for multiple alignments as described in the methods section. this seems a rational choice for clustal, as this gap scoring scheme indeed generates better alignments for clustal than the pairwise scoring scheme.

however, when we extend the scope of the search in the alignment space, and keep not only the locally optimal alignment during the progressive alignment procedure, we see a different picture. increasing the t parameter when the alignments are scored using a pairwise gap penalty scheme yielded an increase in the accuracy of the generated alignments, and eventually the reticular alignment method with this gap-penalising scheme overtakes clustalw, see figure  <dig>  we would like to highlight that in this experiment no further tricks were used by reticular alignment, like differentiating the gap penalties for hydrophobic and hydrophilic amino acids.

on the other hand, when simple non-pairwise gap penalties were applied, the accuracy decreased with increasing the t parameter, see figure  <dig>  a detailed analysis revealed that the internal score of the reticular alignment increased in this experiment. namely, the method found better-scored alignments with increasing the explored search space, however, these better scored alignments are less accurate according to the balibase database. however, these overall better scored solutions can only be constructed via locally suboptimal solutions, see figure  <dig>  clustal does not consider suboptimal solutions, that is why it does not find these alignments, and thus generates worse-scored, on the other hand, more accurate alignments. this example clearly shows that the parameterisation problem is at least as important in the multiple sequence alignment than the optimisation problem.

the importance of a good guide tree, sequence weighting and gap scoring
although reticular alignment outperformed clustalx with a simple sum-of-pairs scoring scheme, and without any sophisticated gap scoring scheme, its performance with the less sophisticated scoring schemes was worse than the performance of the cutting-edge multiple sequence alignment methods. therefore, we improved the scoring scheme both for similarity scoring and for gap scoring.

it is well-known that the relative difference between the score of the fully conserved alignment column and the score of the alignment column with a single mismatch decreases with the number of sequences  <cit> . this artefact can be reduced by weighting the sequences according to the evolutionary tree showing their relationship. such a weighting also improves alignment accuracy  <cit> . we implemented the same sequence weighting method that clustalx uses.

since our sequence weighting method uses the guide tree, it is also important to construct a good guide tree. we found that nj outperforms upgma measured in alignment accuracy . since the nj algorithm generates an unrooted tree, and the reticular alignment method needs a rooted tree, the nj tree must be rooted. changing the root of the guide tree also changes the progression of the multiple alignment. the more balanced the tree, the closer the numbers of sequences in the two alignment networks. we found that balanced trees generated by the 'mid-point' method as described in  <cit>  generates more accurate alignments than unbalanced trees where one of the subtrees of the root contains only a single sequence.

finally, it is also important to distinguish gap scores based on whether hydrophilic or hydrophobic amino-acids are inserted and/or deleted. applying the same scoring scheme that clustalx uses improved the alignment accuracy.

fortifying the reticular alignment method with these sophisticated scoring schemes yielded a method that generated highly accurate alignments. reticular alignment outperformed all of clustalx, mafft and fsa in sp values on the balibase v <dig>  database, and only mafft outperformed reticular alignment in the tc values, see figure  <dig>  on balibase v <dig> ., reticular alignment outperformed clustalx and fsa in all accuracy measurements, and it had a higher feature sp value than mafft, see figure  <dig> 

memory and computational demand
as the threshold value increases, the size of the alignment network will increase, too. figure  <dig> and  <dig>  show the dependence of running time on the reticular threshold value. the log-log scale plot in figure  <dig>  clearly indicates that the empirical running time grows quadratically with the reticular threshold. this agrees well with the theoretical considerations that the time required to align two alignment networks is proportional to the product of the two network sizes. the memory usage is also quadratic with the threshold value in the current implementation , which restricts the applicability of the software to 30- <dig> sequences of intermediate size  due to memory requirements, but this can be circumvented using checkpoint algorithms, see  <cit> .

CONCLUSIONS
previous corner-cutting methods define a compact part of the dynamic programming table for searching the best scored alignment. these methods become very inefficient when the number of sequences increases. we introduced a new progressive alignment method called reticular alignment, which obtains a set of optimal and suboptimal alignments at each step of the progressive alignment procedure. this set of alignments is represented by a network and are not directly embedded into the high-dimensional dynamic programming table. the set typically contains high-scored alignments that are usually not neighbours in the dynamic programming table . therefore, the convex hull of the set of these alignments in the high dimensional dynamic programming table contains a significantly larger set of alignments. any previous corner-cutting method setting a convex part containing the set of alignments found by the reticular alignment method would need significantly more memory and running time.

this novel corner-cutting approach allows the efficient search of the space of multiple sequence alignments for high-scored alignments. the method has a parameter which affects how much of the alignment space is explored. furthermore, the reticular alignment method can be combined with any scoring scheme, and in this way, we were able to infer what is the importance of sophisticated scoring schemes and more exhaustive searches in finding accurate multiple sequence alignments.

the conclusion is that it is important to increase the search space for finding high-scored alignments. the reticular alignment method could find more accurate alignments than clustalw even when the gap-scoring scheme was significantly less sophisticated than the scoring scheme of clustalw. for example, clustalw gives different gap scores for hydrophilic and hydrophobic amino acids. this is considered to improve the alignment quality as hydrophobic amino acids are on the surface of globular proteins forming loops, and these loops undergo significantly more insertion and deletion events than other parts of the proteins. still, reticular alignment could generate more accurate alignments than clustalw by merely extending the search space and without applying the above mentioned sophisticated scoring scheme of clustalw. on the other hand, sophisticated scoring schemes are also necessary to get highly accurate multiple alignments. combining sophisticated scoring schemes with the reticular alignment progressive alignment approach yielded a method whose accuracy is comparable to that of cutting-edge alignment methods. without such sophisticated methods, the reticular alignment method only outperformed the clustalx method, and were beaten by mafft and fsa in all accuracy measurements. therefore it is also an important question how to find the scoring function that provides the most accurate multiple alignments. kececioglu and kim gave a fast linear programming-based method that finds parameter values that make given example alignments be optimal-scoring alignments of their strings  <cit> . such extension of that approach for multiple sequence alignments would be desirable.

authors' contributions
im proposed the extension of waterman-byers algorithm for aligning a network of alignments to a network of alignments, and implemented a prototype. as developed the majority of the current retalign implementation. Án proposed the data structures and algorithms for efficient score calculation, and created the benchmarking framework to compare alignment programs. jh encouraged the discussions. all authors read and approved the final manuscript..

