BACKGROUND
motivation
molecular biology  benefits greatly from the use of software technology in preparing experiments, analyzing data, and performing "in-silico" analyses. however interaction between mb software programs is often complicated.

this will be illustrated by an example from our work: recently we localized short reads of nucleosomes, gained by illumina solexa technology, in a reference genome. the sequences acquired were analyzed by computing some of their properties and assigning annotations from the reference genome to them.

we used the programs rmapq  <cit> , soap  <cit>  and maq  <cit>  for the localization. each of them uses a separate input format, different from the short read data format. we had to perform three data transformations. furthermore, the domain understanding of these programs is slightly different: soap and maq support pair-end sequencing, while rmapq does not; soap can report multiple hits, while rmapq and maq can not. due to this different domain understanding, each program uses its own output format with slightly different semantic. we had to write three different scripts to obtain the nucleosome sequences from the reference genome. to relate the acquired locations with other annotations and visualize this data, we used genetrack  <cit> , which is based on a more aggregated view of the acquired locations. genetrack does not evaluate single hits of the localization programs, it analyzes the number of hits on found locations . genetrack uses proprietary data formats for both the acquired locations and the reference genome annotations. again, we had to transform the output of rmapq, soap, and maq three times. and we converted the reference genome annotations from the gene bank format into the genetrack format.

this is only one example of limited interoperability. however, due to heterogeneous data standards and uncoordinated software development  <cit> , there are many other scenarios of complicated data exchange. a shared domain understanding was identified as a potent means to achieve interoperability for mb software  <cit> . on the other hand, mb, especially the areas of functional genomics and proteomics, is a very dynamic research domain. the increasing number of biological databases  <cit>  and the continuous development of the embl data format  <cit>  attest to this fact. for example, the feature "snorna" was introduced with release  <dig>  in release  <dig> the features "snorna," "scrna," "snrna," and "misc_rna" were replaced by the new feature "ncrna" and its mandatory qualifier "ncrna_class." the qualifier defines the kind of "ncrna," and its value set is defined in an extensible form  <cit> . this suggests that further development in the area of non-coding rna may be expected in the future.

as new insights into mb are gained, the domain and its concepts quite often have to be viewed from a new perspective; sometimes new experimental or theoretical results shift even fundamental concepts. the term "concepts" means the notable entities in the domain, such as different kinds of molecules  or special regions of molecules . software systems for mb must be sufficiently flexible to accommodate these changes in a reasonable amount of time; otherwise, the software soon becomes obsolete or its value diminishes  <cit> .

previous studies investigated extensibility as an important requirement to achieve flexibility for mb software; e.g. jones and paton  <cit> . besides extensibility, changeability is equally required to achieve flexibility  <cit> .

an approach often used to deal with the problem of flexibility is to consider only a small, well-defined area of the domain. by this means, knowledge changes are scarcer and, due to the lower program complexity, easier to implement. the drawback is an isolated domain understanding of these programs, which is very much dependent on the particular program's domain view. furthermore, these programs very often use proprietary data formats. the explorative manner of biologists work is not well supported, and interoperability and data exchange are difficult to achieve. performing large-scale "in-silico" analyses using several programs often requires an enormous amount of time and resources for interoperability. the challenge in developing software for mb is to satisfy both requirements appropriately: interoperability to support explorative work in mb, and flexibility to accommodate new knowledge in the domain.

to meet this challenge, we approach the problem from the fundamental level of computer program development; namely, the domain model, also known as "conceptual model." in object-oriented  software development  <cit> , the domain model is a systematic description of entities in the subject domain and their relationships  <cit> . it reduces the gap between mental and software models, and it supports communication between domain experts and software developers  <cit> .

the domain model is created in an early development phase, the analysis phase. it is the basis for data models created in later phases, such as data formats for data exchange and file storage, or the database model, or the class model for the domain layer. changes of the domain model affect many parts of a software system; they are therefore costly and complicated and should be avoided. so, besides flexibility, stability is also very important for domain models in mb. a comprehensive domain model for mb could provide a shared domain understanding for a wide range of programs and therefore support interoperability.

it is difficult to fulfill both requirements using commonly applied oo modeling approaches. in these approaches, domain concepts are modeled statically in class hierarchies with associations between classes. new or changed knowledge leads to changes in the domain model, which should be avoided, as mentioned above.

therefore, we present a different modeling approach, which has adapted the "dynamic object model" pattern  <cit> . this approach promises to fulfill both requirements of a comprehensive domain model for mb – flexibility and stability – in a balanced manner and therefore supports interoperability.

RESULTS
approach
overview
the essential idea behind our approach is the separation of fundamental domain concepts from domain knowledge, as proposed by beale  <cit> . fundamental concepts define the scope of the subject domain, and hence the scope of the software. if fundamental concepts were to change, the subject of the domain and the software would have to change, too. therefore, fundamental concepts constitute a stable core; changes would only affect domain knowledge.

following this idea, fundamental concepts were modeled in an abstract class model and domain knowledge was reflected in an object model. this approach utilizes the "dynamic object model" pattern  <cit> , also known as "adaptive object model"  <cit> . this is a composed pattern and its core is the "type object" pattern  <cit> . we named abstract classes corresponding to fundamental concepts typed classes. instances of typed classes get a more concrete meaning from a special attribute, called type attribute, which describes a concrete concept. in other words, instances of typed classes are parameterized by their type attributes. these type attributes constitute the model for the domain knowledge. they are instances of special classes, called type definition classes.

the following example explains this approach: in classical oo models, different molecules such as dna, rna and proteins are represented as classes in a class hierarchy . in contrast, the presented modeling approach uses classes as well as instances : molecule is a typed class and moleculetype is a type definition class. different molecule types are represented by instances of moleculetype, not by subclasses of molecule . these instances are type attributes of molecule instances. by using this approach, new concepts can be introduced into the model without changing the class model.

following this approach, we realized that four models can be distinguished on different abstraction levels :

• the operational model defines the scope of the domain model. it contains the fundamental abstract domain concepts. it is a classical oo-class model that consists of the typed classes.

• the knowledge model defines concrete concepts in the area of interest; these concepts and their relations are subject to changing knowledge. the elements of the knowledge model are instances of type definition classes that can be created and changed dynamically. they are used as type attributes in the operational model.

• the meta model of the knowledge model defines the structure of the knowledge model. it joins concrete concepts defined in the knowledge model with abstract concepts of the operational model. classes in the meta model of the knowledge model are type definition classes. this model is therefore an oo-class model.

• the information model contains application data from the developed system. it is not developed in any phase of the software development process, but rather it originates during the execution of an implemented system. it consists of instances of classes from the operational model, which use type attributes.

the names "operational model" and "knowledge model" are inspired by the terms "operational level" and "knowledge level," used by fowler in  <cit> . beale used the terms "knowledge level" and "information level" in  <cit> ; the latter term was the inspiration behind the naming of the "information model."

properties of knowledge model concepts
concrete concepts usually define properties. for example, double-stranded dna has a melting temperature and a gc ratio, and proteins can have annotations describing their function. in our approach, properties cannot be modeled as instance attributes of the typed class. this is because properties are not shared by all kinds of concepts; every concept has its own set of properties. to meet this challenge, we integrated properties using a generic property model . the basis of this model is the "typed dynamic property" pattern  <cit> .

the property model defines kinds of properties by instances of the type definition class propertytype. these instances are elements of the knowledge model  and represent concrete kinds of properties . instances of the typed class property  represent property values according to its propertytype.

domain concepts usually have several properties; they have a property set. these sets are defined by instances of the type definition class propertyregistry . these instances define property sets for concrete concepts, they are also elements of the knowledge model. the corresponding typed class for propertyregistry is propertyholder, which is a container class to manage instances of property according to the propertyregistry.

the property model is integrated into our domain model using inheritance . if inheritance might cause problems, delegation can be used instead: for example, when the class that should have properties is the subclass of another class, delegation would avoid problems that multiple inheritance could imply  <cit> .

associations between concrete concepts
domain objects are often related to other domain objects. for example, a promoter can be involved in gene regulation. to support relationships, riehle suggests the "relationship type objects"  <cit>  pattern. it is a combination of "association classes"  <cit>   and the "type object" pattern. "relationship type objects" are "association classes" that have a type attribute; in our terms, they are typed association classes. on the basis of "relationship type objects," we have developed a model for associations between typed classes .

the main element of this model, the typed association class relation, represents relationships between domain objects . its type definition class relationtype must be more complex than previously described typed classes. it defines roles that can be played by members, and rules that apply to the relation and its members. the role class is the type definition class of the member class.

this is explained by an example : in a relation, describing the gene regulation by promoters, the roles "promoter" and "gene" may exist.

furthermore, the promoters and regulated genes must be on the same dna-strand. agenregrel, an instance of relation, realizes this relation. it is parameterized by the relationtype genregtype, which declares two roles, generole and promoterrole. members of the relation  are managed by genemembers and prommembers . both are parameterized by its type attributes, generole and promoterrole . the rule instance samemolecule is associated with generegtype to ensure that all members of a generegtype relation are located on the same dna-strand. the logic used to perform the necessary checks cannot be shown in the object diagram, so a uml note is used to declare the logic.

structure of the model
modeling linear biological macromolecules
dna, rna, and proteins are the main domain concepts. they are polymers, consisting of nucleotides or amino acids. it is common to present these molecules as a sequence of their elements. figure  <dig> shows the model of linear biological macromolecules.

many different kinds of molecules exist, for example ordinary dna or rna and more specific cdna, trna, and various ncrnas. the relevance of molecule kinds depends on the application; sometimes a less relevant kind may become important over the course of research. in order to support changeability, molecules are modeled as the typed class molecule and its type definition class moleculetype.

the linear structure is modeled by sequence and moleculeelement; sequence reflects the order of elements. the association between moleculetype and moleculeelement is used by instances of moleculetype  to define the set of moleculeelements, which can be contained in a specific molecule type.

this model makes the dynamic definition of molecule types possible; new types of molecules can be defined without creating a new class.

modeling special regions in linear macromolecules
molecules can have special regions in their sequence, such as genes and promoters in dna or dna-binding regions in proteins. figure  <dig> shows the model of special regions and its relation to the model of molecules.

an important attribute of a special region is its location in the sequence. simple locations only have a start and an end position. however, there could also be more complex locations:

i. they can have gaps; e.g., the areas of introns are not part of coding sequences.

ii. they can be located between two molecule elements; e.g., the cleavage site of a restriction enzyme.

iii. the start or end position could only approximately be known.

for these reasons, the operational model contains the class location. its attributes startlocproperty and endlocproperty specify the meaning of the start and end values. they allow the definition of special positions corresponding to  and . the self-referencing association sublocation can compose locations to deal with gaps . if a composed location contains sublocations which are not adjoining, it contains a gap.

the class moleculesegment represents special regions within molecules. however, there is a wide variety of special regions, and it is expected to discover new region types in the future . therefore, moleculesegment is a typed class with the type definition class segmenttype. this allows the integration of new kinds of special regions into the model, e.g., when new kinds of ncrna become interesting. which special regions can occur in a molecule depends on the molecule type. therefore, an association between moleculetype and segmenttype describes allowed segment types.

modeling properties of concrete concepts
simple properties as described in "properties of knowledge model concepts" are not sufficient in mb. for many properties their values and equally further information about the values is important. we named this information "annotations." an example of such a property is the melting temperature  of a doublestranded dna, calculated from the nucleotide sequence. different tm-algorithms exist and many factors affect their suitability to calculate tm. in order to assess a tm value, it is important to know how the value was calculated.

these special characteristics of properties are considered in an extended property model . gray parts are taken from the simpler model above; black parts are new to the model. the new association between property and propertyholder enables property to hold annotations of its values. the one-to-many cardinality allows each property value to have annotations and its individual propertyholder. a constraint on the association prohibits annotations from having further annotations. annotations of an annotation would not be of value. their responsibility is to clarify the property value meaning. annotations must be so precise that an explanation of them is not needed. propertytype uses an association with propertyregistry to define which annotations are allowed for its values. to avoid the specification of an annotation set for annotations, a constraint prohibits the definition of a propertyregistry for annotations.

typed classes of the operational model  inherit from propertyholder to enable them to hold properties. therefore, the corresponding type definition classes have to be subclasses of propertyregistry. this is illustrated by an example for the classes molecule and moleculetype in figure  <dig> 

overview of the operational model
the preceding sections explained parts of the operational and the meta model in combination. the next two sections will explain both models separately to clarify their content and responsibility. this section describes the operational model .

molecules and special regions within these molecules are the relevant concepts in the domain. they define the scope and have to be contained in the operational model. both are represented by typed classes, molecule and moleculesegment. relations between molecules and special regions are also in the focus. they are realized by the relation model described in "associations between concrete concepts." the operational model contains the typed class relation for this reason.

instances of these typed classes have to hold type specific properties. therefore, molecule, moleculesegment, and relation are subclasses of propertyholder.

the linear molecule structure is represented by the class sequence, while the class moleculeelement represents the monomers. the class location specifies the position of a special region within a molecule. member holds references to objects involved in associations; these objects are usually molecules or moleculesegments.

the operational model defines linear biological macromolecules, special regions within these molecules, and relations between them as concepts in the scope of the domain model.

overview of the meta model
the type definition class relationtype supports the definition of member roles and the assignment of relation type specific rules by the associations to the role and rule classes.

the meta model of the knowledge model provides means to introduce new domain concepts, including their relations and properties, without needing to define new classes.

discussion
improvements due to the modeling approach
this work presents a domain model for mb, based on a novel modeling approach. in contrast to traditional modeling, this approach provides means to develop a single comprehensive view of the mb domain. therefore, it supports a higher degree of interoperability .

the strength of the modeling approach is the separation of the model into operational and knowledge models. the operational model defines the scope of the model at a high abstraction level, . this ensures that all relevant concepts can be represented in the model, albeit on a very abstract level.

the knowledge model decreases the abstraction level. it describes concrete domain concepts using objects that are applied as type attributes of classes in the operational model. new or changed domain concepts can be flexibly defined in the knowledge model 

the separation of the knowledge model and usage of instances facilitate the utilization of semantic technologies, e.g., ontologies . these technologies are more suitable for knowledge representation than commonly used class diagrams; they enhance the clarity and strength of the model.

an increased changeability, necessary due to the knowledge development in mb , is also supported by this approach. the applied design pattern "dynamic object model" is intended to support changeability better than traditional approaches. furthermore, the "effects of changing knowledge" section demonstrates the limited effects of changing knowledge on implementations that utilize the presented modeling approach. these limited effects make changes easier and less time consuming. new findings can be reflected faster and with less effort in the software. furthermore, changes arising from new knowledge only affect certain parts; hence there is less chance of introducing errors into the software. positive effects in terms of maintainability and software quality are discussed in "consequences for software development."

consequences for design and software development
due to the fundamental role of domain models, the manner in which they are developed strongly affects the design of software and the development process. consequences of the modeling approach for software design concern the internal software structure  as well as the interaction of software components. in this article, the term "component" denotes a small modular and replaceable part of the system that provides a determined functionality  <cit> .

consequences for software development
the modeling approach distinguishes the abstraction level by using different models: the operational model, the knowledge model, and the meta model of the knowledge model. these models use the same modeling technology. at first glance, systems based on this approach seem to be harder to maintain than traditionally developed systems. developers have to put significant effort into understanding this kind of modeling. however, we and others have observed that developers who manage to achieve this understanding find such systems easier to maintain than traditionally developed systems  <cit> .

furthermore, the separation of operational and knowledge model reduces coupling between concepts on different abstraction levels. the operational model is notably smaller and less complex than the class model of traditionally developed systems. both of these factors – a good separation of concerns and lower complexity – are known to support maintainability and enhance software quality  <cit> .

consequences for the structure of software components
systems based on this approach need typical components in order to handle the knowledge model, usually a repository that provides a list of known types. for example, for the instantiation of typed classes, a value for their type attribute is needed. this value can be obtained from the repository.

another typical component is a persistence component that loads the knowledge model from permanent memory. standard methods for mapping object models like the knowledge model into relational databases and xml files can be used in this persistence component  <cit> . the viability of this approach is shown by the implementation of the mb framework "molecule computation kit" , which is based on the domain model presented here . the current mck version uses xml files to define the knowledge model. in the further development of mck, however, ontologies seem to be a promising alternative for defining the knowledge model, as discussed in "use of ontologies as the knowledge model."

in the presented modeling approach, the formal description by type attributes is advantageous for the implementation of software components. thanks to this description, components can handle data generically and hence they are unaffected by changing knowledge. for example, mck uses generic writers and readers that store and load molecules, molecule segments, and relations between molecules by utilizing type attributes. the mck also contains a design study for user interface components that uses the formal description to display properties of molecules.

however, generic handling is not always possible. for instance, new domain concepts are usually followed up by new data processing components that process these concepts. these components must be integrated into the system. for this reason, a software system has to provide extension points for the integration of new data processing components.

as another example of the advantages of the modeling approach presented here, data processing components can use type attributes to validate input data with regard to the concrete type of a typed class or necessary properties. this generic validation even allows the processing of concepts that were unknown at the development time of the data processing component; an inherent interoperability is achieved.

even data processing components themselves, including their i/o ports and configuration parameters, could be described by type attributes. this would allow the dynamic and semantically correct composition of data processing components  <cit>  and support interoperability and the explorative manner of biological research. this interesting approach is the subject of further investigations .

consequences for the interaction of software components
the use of typed classes also concerns the interaction of system components. during interaction, the involved components must act in accordance with the meaning of the exchanged data. this requires the ability of components to utilize the type attribute; since the meaning of instances of typed classes depends on the value of their type attribute and their class. as described in "consequences for the structure of software components" generic components must utilize the type attribute. they depend on software structures that allow them to read the meta data provided by the type attributes. a modular design of these software structures allows their reuse by non-generically implemented components. the type attributes can then be read and utilized by all components in internal communication.

since changes in the knowledge model may often occur, data using different knowledge model versions will exist. this becomes relevant for reading older data from files or importing data from system installations with other knowledge model versions. transformation rules support persistence components in this task. they describe steps necessary to convert data from one version to another, and would support automatic data transformation.

the modeling approach presented here supports the development of transformation rules. hence the separation of the knowledge model makes changes to the domain understanding explicit. a change in the knowledge model indicates the necessity for developing a transformation rule. furthermore, the reasons for the knowledge model change are known. this knowledge is helpful in developing the transformation rules; due to the explicit presence of the change, this knowledge can be used immediately.

effects of changing knowledge
one of our aims was the development of a domain model for mb that allows the fast and convenient integration of new knowledge while providing a stable basis for software development. to assess the achievement of this goal, we have analyzed the effects of changing knowledge on implementations based on the presented approach.

when new domain concepts arise, or when they are changed, the class model of the domain layer is not affected. in the case of changing domain concepts, it is sufficient to create new instances of type definition classes, or to change existing instances. in traditionally developed systems, a new class must be created as mentioned in "motivation," significantly more time and effort is needed than in the presented approach. hence, in contrast to traditionally developed systems, our approach separates the software implementation from the knowledge representation, so changes in knowledge have limited effects on the software implementation.

changing knowledge only affects components directly dependent on them, so they must be adapted. generically implemented components and components not involved remain unchanged. for example, the changed cardinality of a concrete concept property affects the implementation of processing components that must consider this property in its processing. components that work with the same concept but do not use the changed property will not be affected. our practical experience with mck supports this statement

a close examination of possible changes reveals three different kinds of changes to the knowledge model:  the introduction of new domain concepts leads to new model elements.  domain concepts must be removed.  modified domain concepts lead to modified model elements. these different kinds of change must be handled in an appropriate manner.

we developed the following strategy to deal with the different kinds of changes and applied it to the mck. new and modified knowledge model elements can mostly be handled generically. when this is not applicable, the strategy suggests ignoring unknown elements of the knowledge model. this is possible because a software system that is not aware of a model element will not depend on it.

simply removing obsolete elements from the knowledge model would also lead to "unknown" elements. however, these removed elements must not be handled generically; they were discovered to be obsolete and should not occur in the system. to prevent generic handling of these elements, it is not sufficient to simply remove them. they have to remain in the model and must be flagged as obsolete.

effects on interoperability
the limited interoperability of current mb software motivated the development of our domain model. the consequences of our approach for interoperability are outlined in this section.

in "motivation" we demonstrated that a shared domain model is a potent means of achieving interoperability. this does not mean that the interacting systems must use the same software implementation. it is sufficient that they use the same domain model. the presented modeling approach provides the flexibility and strength required to develop a widely used domain model for linear biological macromolecules. systems using this domain model are able to exchange data simply and accurately, thus supporting interoperability on a new level.

the use of meta data in information systems is known to support interoperability  <cit> . a shared domain understanding is usually not given in communication between systems with different domain models. a mapping that transforms the data of one system into a form understandable by the other system is necessary. the development of this mapping is usually a complicated process and often associated with loss of information . and it is important that this mapping does not modify the semantics of exchanged data.

the section "consequences for the structure of software components" describes how data processing components can use type attributes to validate their input data. this kind of validation signifies a shift from type-based communication to content-based communication. type-based communication only considers data types specified by method signatures to ensure correct communication. content-based communication considers not only the data type, but also the semantics of data by utilizing meta data like the type attribute. for example, content-based communication can distinguish between a float value describing a percent value and one describing a temperature value. the presented approach allows systems to communicate in type-based and content-based manner. this achieves greater flexibility in the mapping development and leads to better interoperability.

validation of the domain model
our domain model must be able to include the relevant concepts of the domain. to validate this, we successfully proved that the data structures of the embl standard  <cit>  can be mapped into our model, and developed an according mapping. embl database entries were handled as molecules and embl features were treated as molecule segments. other embl line codes were mapped to properties and annotations. qualifiers of embl features were handled mostly as annotations for segments . we verified this mapping by implementing a parser for embl files in our mck, which will be described next.

we demonstrated the feasibility of systems based on our domain model with a framework for linear biological macromolecules. it is called molecule computation kit  and is available at .

generic models like our domain model do not provide type safety by themselves. however, type safety provides strong type checks at compilation time and many errors can be detected early.

in order to compensate for missing type safety, we use runtime type checks against the type attributes in the mck. to make these runtime type checks transparent and decrease complexity, we implemented the property model in a set of service classes. they manage properties and perform type checks.

in order to guarantee that annotations do not have further annotations , we distinguished two different kinds of properties and introduced corresponding classes. we named them feature, which can be annotated, and annotation, which can not have further annotations. all typed classes of the mck use the service classes by inheritance.

furthermore, we implemented an xml-based storage component. it is based on the structure of the operational model and handles all kinds of molecules, segments, and relations between molecules. it utilizes the formal description of concepts provided by the type attributes. generic readers and writers are assigned to data types. annotations and features of stored objects are handled by these readers and writers according to the data type specified by the propertytype. therefore, the storage component does not have to be changed when new knowledge model elements are defined. due to its generic implementation, the storage component can work with different knowledge model versions.

similar work
our domain model uses solutions from the composite design pattern "dynamic object model"  <cit> , which has been successfully applied in different domains. the developed model meets the special requirements of mb by adapting the pattern. the typed classes and their type attributes are similar to the "type object" pattern  <cit> . the property model applies the "typed dynamic property" pattern  <cit> , and the model for associations uses ideas described as "relationship type objects" in  <cit> .

the main difference of our approach compared to "dynamic object model" is the explicit distinction between operational and knowledge model and the explicit description of the knowledge model structures by the meta model of the knowledge model. the information processing model is strictly separated from the knowledge representation. this separation is also intended by the "archetype" modeling approach of beale  <cit>  and the "knowledge level" described by fowler  <cit> . beale proposes the proprietary archetype definition language  to specify the knowledge model. the adl has a higher expressiveness than the currently used knowledge model description. however, the adl has not yet been broadly applied. in contrast, we use well-known oo technology, which we are going to combine with ontologies to derive the knowledge model from them . by this means, the knowledge model would get significantly greater expressiveness, and well-known technologies would be used.

jones and paton analyzed and described modeling constructs to achieve extensibility in data formats for functional genomics  <cit> . they described how different modeling constructs support frequently performed tasks, mainly in data analysis. although they did not focus on domain models, some of the described constructs are suitable for domain modeling and were adapted in our approach.

our property model extends the name-value-type triples  described in  <cit>  by a description of data types and cardinality. this extension supports the "reasonable" usage of nvts as demanded in  <cit>  and increases semantic expressiveness.

in  <cit> , inheritance was also described as a means to achieve extensibility. however, we do not use inheritance for extension on the knowledge level. inheritance is only used on a more technical level, e.g., to define extension points for generically implemented or data processing components. inheritance is not used to represent "is-a" relations between domain concepts. this kind of knowledge representation is too inflexible for mb domain models . furthermore, inheritance often causes misunderstandings between domain experts and software engineers. domain experts often think of "is-a" relations as restrictions, e.g., a cdna is a dna without introns. in contrast, commonly used oo programming languages and the uml interpret "is-a" relations described by inheritance as an extension by attributes, methods, or associations.

ontologies provide a stronger way to describe relations between domain concepts. not only "is-a" relations, but also "has-a" relations and even other relation types can be described by ontologies. jones and paton also described ontologies as a suitable means to achieve extensibility in  <cit> . we share this opinion, and will derive the knowledge model from ontologies in the future .

use of ontologies as the knowledge model
motivation for the use of ontologies
in mck we currently identify concepts in the knowledge model by simple name attributes of the type definition classes. this does not allow the expression of semantic relations such as "is-a" relations between general and specialized concepts.

the usage of ontologies is promising to cope with this problem. ontologies provide a formal description of domain concepts and of relations between them, as "is-a" and "has-a" relations. "reasoners"  can use this description to determine semantic associations like "a snorna is-a ncrna." there is an active community for bio-ontologies  <cit> , and ontologies have taken an important place in bioinformatics  <cit> . their semantic capabilities were applied in several fields, such as data exchange, information integration, search and query of heterogeneous data sources, and computer reasoning  <cit> .

an adoption of ontologies will help to acquire a representation of "is-a" relations between domain concepts  <cit> . we have developed a strategy to derive the knowledge model from ontologies. however, a full description of this strategy would be beyond the scope of this paper and will be the topic of an upcoming publication. therefore, we provide a sketch of our strategy in the next section.

strategy to derive the knowledge model from ontologies
the essential idea to derive the knowledge model from ontologies is to use the concept identifier of ontological concepts as the name attribute value of type definition classes. a mapping between ontological key concepts and type definition classes provides entry points into the ontology. "is-a" relations in the ontology are used for navigation from entry points to ontological child concepts. so, one can recursively derive the descriptions of concrete concepts for the knowledge model. properties of ontological concepts and "has-a" relations can be used to derive property sets of the concepts.

an example illustrates the strategy. it uses the sequence ontology, version  <dig>   <cit>  and applies the notation "term-id = term name" to reference ontology terms: the term "so: <dig> = sequence_feature" is identified as a key concept in the ontology and is mapped to the class segmenttype. this term serves as an entry point, and according to this term, an instance of segmenttype is created and inserted into the knowledge model. the concept id "so:0000110" is used as the name attribute for the new instance.

all ontology terms with a direct or indirect "is-a" relation to the term "so: <dig> = sequence_feature" are searched by reasoning. every term contained in the result forces to insert a corresponding instance of segmenttype into the knowledge model. for example, the term "so: <dig> = region" has a direct "is-a" relation to "so: <dig> = sequence_feature" and is inserted into the knowledge model. the term "so: <dig> = transcript_region" has an indirect "is-a" relation to "so: <dig> = sequence_feature". this means, there is a path from "so: <dig> = sequence_feature" over "so: <dig> = region" to "so: <dig> = transcript_region". therefore, "so: <dig> = transcript_region" is inserted as a segmenttype into the knowledge model.

this strategy permits the derivation of the knowledge model from ontologies, and "is-a" relations  can now be expressed in the knowledge model by using reasoning.

current usage of ontologies and their relevance for deriving the knowledge model
ontologies are used extensively in current mb software and our approach can benefit from experiences made there. this section provides a short overview of current ontology usage, relevant to our approach.

the tambis project  <cit>  is an example for ontology usage to mediate between different domain models. a mediator component and several database wrappers use the tambis ontology to provide transparent access to heterogeneous databases. the tambis strategy is to perform a mapping between the terms of the heterogeneous databases and the tambis ontology terms. tambis usage may be convenient for the user. however, due to continuous database development, the wrapper maintenance will be very labor intensive. on the other hand, the tambis ontology proves the possibility of a comprehensive domain ontology.

another approach is to integrate ontologies into data models, e.g., fuge  <cit>  and mage-om  <cit> . in both models, classes, representing domain objects, use associations to the class ontologyterm, that represents ontology terms. for example, to specify the experimental equipment  more precisely, the fuge model uses the association "equipmentmodel" between the equipment and ontologyterm classes to specify the equipment product name. the approach allows the flexible integration of ontological terms into the models. both models use this mechanism to specify domain entity types or generic properties. at first glance, this is similar to the type attributes and generic properties presented here. however, the models do not constrain the set of allowed properties. our approach for deriving the knowledge model from ontologies is a further development of the fuge and mage-om approach.

another approach to utilize ontologies in domain modeling is to derive a class model from an ontology  <cit> . the approach defines transformation rules, which, for example, map concepts to classes and relations to associations. these rules allow the automatic conversion of ontologies into object-oriented models. however, a static class model is generated. such a model is too inflexible to serve as a mb domain model. changes in the ontology would require new transformations and result in new domain models. in contrast, our approach creates a dynamic representation of ontology concepts; it is a similar approach but enhances the flexibility significantly.

outlook and current work
integration of data processing components
another aspect of our current investigation are extension points that allow the integration of extended data processing components. these components should be seen as algorithms, formal described by type attributes. the description includes the i/o ports and configuration parameters of the algorithms, see section "consequences for the structure of software components." this description provides enhanced capabilities in using data processing components. for example, the description of i/o ports allows an easy and semantically correct combination of processing components. together with the formal description of exchanged data, one can ensure semantic compatibility. in this way, users will be able to join data processing components safely and create their own computing pipelines.

CONCLUSIONS
our aim was the development of a domain model for linear biological macromolecules that can easily integrate new or modified domain concepts and nevertheless provide a stable basis for implementation models. we achieved this through the strict separation of two model parts, the operational model and the knowledge model. these parts are connected by the meta model of the knowledge model to the whole system model.

we validated our model against the embl standard and by implementing an mb framework  whose data structures are based on the model. we demonstrated that our model is able to integrate new domain concepts without changes to the operational model and therefore provides a stable interface for software programs. general use of the design pattern "dynamic object model" and its related patterns is the key to creating changeable, high-quality software solutions for mb.

in the future, an integration of domain-specific ontologies will enrich the model and the modeling approach presented here even further; for example, in the form of enhanced expressiveness and automatic generation of knowledge models.

the modeling approach allows the development of information systems for mb that can accommodate changes in the domain in a fast and flexible manner. this approach also provides the expressiveness and flexibility that is needed to develop a widely used domain model of mb, one which allows a shift to a global view of the domain and supports interoperability on a new level.

availability and requirements
our models and the mck are available at . mck requires java software development kit, version  <dig>  or higher, and eclipse  <dig>  .

authors' contributions
nb developed the modeling approach and drafted the manuscript. gw participated in developing the modeling approach and revised the manuscript. all authors read and approved the final manuscript.

