BACKGROUND
quantitative traits are usually controlled by multiple quantitative trait loci  and environmental factors. interactions among qtls or between genes and environmental factors make a substantial contribution to variation in complex traits  <cit> . the goal of qtl mapping is to infer genomic loci that are associated with the trait and to estimate the genetic effects of these loci including their main effects and gene-gene  and gene-environment  interactions. due to the physical linkage of and/or epistatic interactions among multiple qtls, it is highly desirable to analyze a large number of loci simultaneously. since hundreds or thousands of genomic loci or markers are usually genotyped and involved in qtl mapping studies, including all these markers and their possible interactions in a model leads to a huge number of model variables, typically much larger than the sample size. two general techniques often employed to handle such oversaturated models are variable selection and shrinkage.

variable selection attempts to identify a subset of all possible genetic effects that best explain the phenotypic variation, typically using a stepwise search procedure in conjunction with a selection criterion such as the bayesian information criterion   <cit> . on the other hand, a shrinkage method includes all variables in the model but uses a penalty function of the variables or appropriate prior distributions on the variables to shrink most non-effect variables toward zero. early shrinkage methods include ridge regression  <cit>  and the least absolute shrinkage and selection operator   <cit> . more recently, bayesian shrinkage method  <cit>  has received considerable attention and been applied to multiple qtl mapping  <cit> . all these works employ markov chain monte carlo  simulation to fit the bayesian model and provide comprehensive information about the model drawing from the posterior distribution of the model variables. despite the advances in the development of the mcmc simulation algorithms  <cit> , mcmc simulations are computationally intensive and time consuming.

in order to reduce the computational burden of the fully bayesian approach relying on mcmc simulation, one of the authors of this paper developed an empirical bayes  method  <cit>  that uses a properly chosen prior distribution for the model variables to shrink variables toward zero. it was demonstrated that the eb method can handle a large number of model variables simultaneously. more recently, the eb method has been extended to handle classification predictor variables  <cit> . although the eb method  <cit>  requires much less computation comparing to the fully bayesian approach, its efficiency is limited by the fact that a numerical optimization algorithm such as the simplex algorithm  <cit>  is needed to estimate the variance components. on the other hand, a very efficient eb method, named relevance vector machine , for learning a linear model was developed in the machine learning community  <cit> . the rvm can estimate the variance components in a closed form, which along with other algorithmic techniques make it a very fast algorithm. the rvm assumes a uniform prior distribution for the variance components. although this choice of the prior distribution gets rid of any hyperparameters to be pre-specified, it lacks the flexibility of adjusting the degree of shrinkage needed for analyzing a specific data set. particularly, its uniform prior distribution may not provide enough shrinkage in multiple qtl mapping that includes a very large number of possible effects, often resulting in a large number of false effects  <cit> .

in this paper, capitalizing on the idea of rvm, we developed a fast empirical bayesian lasso  algorithm based on the bayesian lasso model  <cit>  with an exponential prior distribution for the variance components in contrast to the inverse chi-square distribution for the variance components used by the eb method  <cit> . simulation studies demonstrate that our eblasso method can provide a speed up to orders of magnitude faster than the eb method and can detect more true qtl effects without increasing the false positive rate. real data analysis also show that the eblasso method is able to detect some effects when the eb method fails.

methods
linear model of multiple qtls
let yi be the phenotypic value of a quantitative trait of the ith individual in a mapping population. suppose we observe yi, i =  <dig>  ⋯, n of n individuals and collect them into a vector y = t. considering environmental effects, main and epistatic effects of all markers and gene-environment  interactions, we have the following linear regression model for y:   

where μ is the population mean, vectors βe and βg represent the environmental effects and the main effects of all markers, respectively, vectors βgg and βge capture the epistatic effects and the g × e interactions, respectively, xe, xg, xgg and xge are the corresponding design matrices of different effects, and e is the residual error that follows a normal distribution with zero-mean and covariance . throughout the paper we use i to denote an identity matrix whose size can be clearly identified from the context.

the design matrix xg depends on a specific genetic model. we adopt the widely used cockerham genetic model as also used by  <cit>  in their generalized linear model for multiple qtl mapping. for a back-cross design, the cockerham model defines the values of the main effect of a marker as - <dig>  and  <dig>  for two genotypes at the marker. for an intercross  design, there are two possible main effects named additive and dominance effects. the cockerham model defines the values of the additive effect as - <dig>   <dig> and  <dig> for the three genotypes and the values of the dominance effect as - <dig>  and  <dig>  for homozygotes and heterozygotes, respectively. the columns of the design matrix xgg are obtained as the element-wise product of any two different columns of xg, and similarly the columns of xge are constructed as the element-wise product of any pair of columns from xe and xg.

defining , x = , we can write  in a more compact form:   

suppose that there are p environmental covariates and q markers whose main effects are additive, then the size of matrix x is n × k where k = p + q/ <dig> + pq. typically, we have k ≫ n. if dominance effects of the markers are considered, k is even larger. our goal is to estimate all possible environmental and genetical effects on y manifested in the regression coefficients β, which is a challenging problem because k ≫ n. however, we would expect that most elements of β are zeros and thus we have a sparse linear model. taking into account this sparsity, we will adopt the bayesian lasso model  <cit>  where appropriate prior distributions are assigned to the elements of β as described in the next section.

prior and posterior distributions
the unknown parameters in model  are, μ  and β. while our main concern is β, parameters μ and  need to be estimated so that we can infer β. to this end, we assign a noninformative uniform prior μ to and , i.e., p ∝  <dig> and p() ∝  <dig>  following the bayesian lasso model  <cit> , we assume a three-level hierarchical model for β. let us denote the elements of β as βi, i =  <dig>   <dig>  ⋯, k. at the first level, βi, i =  <dig>   <dig>  ⋯, k follow independent normal distributions with mean zero and unknown variance . at the second level, , follow independent exponential distribution with a common parameter . for a given λ, the distribution of βi is found to be the laplace distribution: , which is known to encourage the shrinkage of βi toward zero  <cit> . however, the degree of shrinkage strongly depends on the value of λ. to alleviate the problem of choosing an inappropriate value for λ, we add another level to the hierarchical model at which we assign a conjugate gamma prior gamma with a shape parameter a >  <dig> and an inverse scale parameter b >  <dig> to the parameter λ. as discussed in  <cit> , we can pre-specify appropriate values for a and b so that the gamma prior for λ is essentially noninformative.

let us define vector . the joint posterior distribution of all the parameters  can be easily found  <cit> . in principle, mcmc simulation can be employed to draw samples from the posterior distribution for each parameter. however, since the number of parameters 2k +  <dig> in our model can be very large, the fully bayesian approach based on mcmc sampling requires a prohibitive computational cost. to avoid this problem, xu developed an empirical bayes method for inferring β  <cit> . our goal here is to develop a much faster and more accurate empirical bayes method that can easily handle tens of thousands of variables.

maximum a posteriori estimation of variance components
similar to the eb method of  <cit> , our eblasso first estimates σ <dig>   and μ, and then finds the posterior distribution of β based on the estimated parameters. since λ is a parameter that we do not want to estimate, we can find the prior distribution of  independent of λ as follows   

the posterior distribution of μ, β, σ <dig> and  is given by   

the marginal posterior distribution of μ, σ <dig> and  can then be written as   

let us define the precision of βi as , i =  <dig>   <dig>  ..., k and let α = . it turns out to be more convenient to estimate α rather than σ <dig> as will be shown shortly. let us collect all parameters that need to be estimated as θ = . the log marginal posterior distribution of θ can be found from  as follows   

where  is the covariance matrix of y with a given α.

similar to the eb method  <cit>  and the rvm  <cit> , we will iteratively estimate each parameter by maximizing the log marginal posterior distribution l with the other parameters being fixed. since it is not difficult to find the optimal μ and  in each iteration as shown in  <cit> , we will give the expressions for μ and  later but focus on the estimation of α now. let us define  and . then following the derivations in  <cit> , we can write l in  as l = l + l, where l does not depend on αi and l is given by   

with  and . if we assume a > - <dig>  and b >  <dig>  we prove in the additional file that l has a unique global maximum and that the optimal αi maximizing l is given by   

where we have defined , , ,  and . note that the gamma distribution requires that a >  <dig> and b >  <dig> as we mentioned earlier. when - <dig>  <a ≤  <dig> as assumed here, we essentially use an improper distribution. in the additional file, we show that this improper distribution appears appropriate for getting a point estimation of αi given in . it turns out that negative values of a give one more degree of freedom to adjust the shrinkage as will be demonstrated later in the results section. moreover, if a = - <dig>  the last term in the right hand side of  disappears. in this case, we essentially use a noninformative uniform prior. then it is not difficult to verify that  gives the optimal αi derived in  <cit> :   

note that α* in  and  depends on other unknown parameters through si and qi, and thus, αi will be estimated iteratively as detailed in the eblasso algorithm described in the next section. comparing with the eb method  <cit> , our method finds each αi  in a closed form, whereas the eb method generally needs to employ a numerical optimization algorithm to find each . therefore, our method not only saves much computation but also gives more accurate estimate of each αi. moreover, exploiting the similar techniques used in the rvm  <cit> , we can further increase computational efficiency as described in the ensuing section.

fast empirical bayesian lasso algorithm
note that when αi = ∞, we have βi =  <dig>  therefore, in each iteration, we can construct a reduced model of  that includes only nonzero βis and the corresponding columns of x. let xi be the ith column of x. if αi = ∞ in the previous iteration but  is finite in the current iteration, then we add xi to the model and set ; if αi is finite in the previous iteration but  in the current iteration, we delete xi from the model and set αi = ∞; if both αi and  are finite, we retain xi in the model and update αi as . this can be done for all is in a pre-specified order in each iteration. alternatively, we can employ a greedy and potentially more efficient method to construct the model as described in the following. we define two iteration loops: an outer iteration loop and an inner iteration loop. in each outer iteration, we estimate μ and . in the inner iterations, assuming μ and  are known and fixed, we estimate each αi and construct the model. specifically, in each inner iteration, we first calculate each  from  and hen find , where αi stands for the value of αi obtained in the previous inner iteration. this step basically identifies the xj that gives the largest increase in the log posterior distribution. then we add, delete or retain xj as described early. the inner iterations can run until a local convergence criterion is satisfied. let vector  contain all finite αis, vector  consist of the corresponding βis and matrix  contain the corresponding columns of x. then we essentially construct the following reduced model:   

where the number of columns of , kr, is typically much less than the number of rows, n. this property will be used to reduce computation.

to calculate  in , we need to first calculate si and qi which requires . since c-i is different for different i, it may need large computation to calculate all . however, it was shown in  <cit>  that we can calculate si and qi as follows   

where  and . this requires only one matrix inversion in each iteration for calculating all si and qi, i =  <dig>  ⋯, k. however, since c is a relatively large matrix of size n × n, direct calculation of c- <dig> may still require large computation. to avoid this problem, we can use the woodbury matrix identity to derive an expression for c-1:   

where   

with . the size of matrix ∑ is kr × kr which is typically much smaller than the size of c. since inverting a matrix of n × n using an efficient method such as qr decomposition needs computation of o, calculating ∑ requires much less computation than directly inverting c. using , we can calculate si and qi as follows:   

so far we have derived the method for efficiently estimating α. other two unknown parameters μ and  can be obtained by setting  and . this gives   

where  <dig> is a vector whose elements are all  <dig>  and  <cit>    

where ∑ii is the ith diagonal element of ∑ and   

after we get estimates of μ,  and α, we finalize the model , where the prior distribution of  is now . for those xis not in the model, we can declare that they do not affect the quantitative trait because their regression coefficient is zero. for those xis in the matrix , the posterior distribution of their regression coefficients  is gaussian with covariance ∑ in  and mean u in   <cit> . we can then use the z-score or more conservative t-statistics to test if  at certain significance level. in this paper, the posterior mean uj of the jth effect is reported as the empirical bayes estimate of βj, denoted by , and the posterior standard deviation, , is used as the standard error of .

we now summarize our fast eblasso algorithm as follows.

algorithm  <dig> 
 <dig>  initialize parameters: choose a > - <dig>  and b >  <dig>  calculate μ = 1t y/n, and set to be a small number, e.g., .

 <dig>  initialize the model: find , and calculate αj from , set all other αis to be ∞ and .

 <dig>  calculate ∑ from , si and qi, ∀i, from .

 <dig>  update the model

   while the local convergence criterion is not satisfied

      calculate qi and si from , ∀i.

      calculate from , ∀i.

   find .

   if 

      if xj is in the model, delete it and update ∑, si and qi, ∀i.

   else

      if xj is in the model, set and update ∑, si and qi, ∀i.

      if xj is not in the model, add it, set and update ∑, si

      and qi, ∀i.

   end if

   end while

 <dig>  update the residual variance using .

 <dig>  calculate ∑ from  and c- <dig> from .

 <dig>  update the fixed effects μ using  and update .

 <dig>  calculate si and qi from .

 <dig>  if the global convergence criterion is not satisfied, go to step  <dig> 

 <dig>  find the posterior mean of from  and the posterior variance ∑ii from .

 <dig>  use t-statistics to test if .

the parameters a and b can be set to be a small number  so that the gamma prior distribution is essentially noninformative  <cit> . alternatively, we can use the predicted error  obtained from cross-validation  <cit>  to choose the values of a and b. as done in  <cit> , the initial value of  is chosen in step  <dig> to be a small number and the initial model is selected in step  <dig> to have a single effect that corresponds to the maximum l with a = - <dig>  the outer iteration loop consists of steps 4- <dig>  while the inner iteration loop is step  <dig>  where we use the greedy method described earlier to update the model. in step  <dig>  we use the method given in the appendix of  <cit>  to efficiently update ∑, si and qi after a xj is added to or deleted from the model or after αj is updated. the local convergence criterion can be defined as the simultaneous satisfaction of the following three conditions: 1) no effect can be added to or deleted from the model, 2) the change of l between two consecutive inner iterations is smaller than a pre-specified small value, and 3) the change of  between two consecutive inner iterations is less than a pre-specified value. the global convergence criterion can be defined as the simultaneous satisfaction of the following two conditions: the change of l between two consecutive outer iterations is smaller than a pre-specified small value, and 2) the total change in μ,  and  between two consecutive outer iterations is less than a pre-specified value. a matlab program has been developed to implement the algorithm; and a more efficient c++ program is under development.

RESULTS
simulation study
we simulated a single large chromosome of  <dig> centimorgan  long covered by evenly spaced q =  <dig> markers with a marker interval of  <dig> cm. the simulated population was an f <dig> family derived from the cross of two inbred lines with a sample size n =  <dig>  the genotype indicator variable for individual i at marker k is defines as xik =  <dig>   <dig>  - <dig> for the three genotypes, a1a <dig>  a1a <dig> and a2a <dig>  respectively. twenty markers are qtls with main effects and  <dig> out of the  marker pairs have interaction effects. the locations and effects of the markers and maker pairs are shown in table  <dig>  environmental effects and g × e effects were not simulated. the true population mean is μ =  <dig> and the residual variance is .

awhen i = j, the qtl is a main effect; otherwise, it is an epistatic effect.

bthe true value of a qtl effect is denoted by β and the proportion of variance contributed by the qtl is denoted by h <dig> 

cthe estimated qtl effect is denoted by  and the standard error is denoted by . the eblasso algorithm used hyperparameters a = b =  <dig>  and the eb algorithm used hyperparameters τ = - <dig> and ω =  <dig> .

dthe estimated qtl effect was obtained from a neighboring marker  rather than from the maker with the true effect.

the total phenotypic variance for the trait can be written as   

where cov is the covariance between xj and xj' if j ≠ j' or the variance of xj if j = j', which can be estimated from the data. the total phenotypic variance was calculated from  to be  and the total genetic variance contributed by the main and epistatic effects of the markers was calculated from the second term of the right hand side of  to be  <dig> . if we ignore the contributions from the covariance terms which are relatively small, the proportions of the phenotypic variance explained by a particular qtl effect j can be approximated by   

where var is the variance of xj. in the simulated data, the proportion of contribution from an individual qtl varied from  <dig> % to  <dig> %, whereas the proportion of contribution from a pair of qtls ranged from  <dig> % to  <dig> %, as shown in table  <dig>  some of the markers had only main or epistatic effect, while the others had both main and epistatic effects. the qtl model contained a total of  possible effects, a number about  <dig> times of the sample size.

the data were analyzed in matlab on a personal computer  using the eblasso algorithm, the eb method, the rvm and the lasso. the matlab program sparsebayes for the rvm was downloaded from http://www.miketipping.com. we translated the original sas program for the eb method  <cit>  into matlab, and slightly modified the program to avoid possible memory overflow due to the large number of possible effects. we also got the program glmnet  <cit>  that is a very efficient program implementing the lasso and other related algorithms. the pc version of glmnet uses matlab to initialize and call the core lasso algorithm that is implemented efficiently with fortran code.

we used the pe  <cit>  obtained from ten-fold cross validation to select the values of hyperparameters a and b in our eblasso algorithm. ideally, we should test a large set of values for a ≥ - <dig> and b >  <dig>  but this may be time consuming. therefore, we first ran cross-validation for the following values: a = b =  <dig> ,  <dig> ,  <dig> ,  <dig> ,  <dig> , 1; the degree of shrinkage generally decreases along this path. table  <dig> lists the pes and the standard errors of the pes for different values of a and b. it is seen that the pe for a = b =  <dig>  is the smallest, although it is close to the pes for a = b =  <dig>  and  <dig>  but relatively smaller than pes for the other values of a and b. to see if a = b =  <dig>  is the best set of values, we further ran cross-validation with b =  <dig>  and a =  <dig>  or - <dig> . for a fixed b, the degree of shrinkage decreases when a decreases. it is seen from table  <dig> that the pe for b =  <dig>  and a =  <dig>  or - <dig>  is greater than that for a = b =  <dig> . therefore, cross-validation gave a = b =  <dig>  as the best set of values. table  <dig> also lists the number of effects detected with different values of a and b. all  <dig> effects detected with a = b =  <dig>  are presented in table  <dig> and shown in figures  <dig> and  <dig> 

◇ parameters are  for the eblasso, and  for the eb.

*the average pe and the standard error were obtained from ten-fold cross validation.

†the number of effects and residual variance were obtained using all  <dig> samples not from cross validation.

‡the first number is the number of true positive effects; the second number is number of false positive effects. all the effects counted have a p-value ≤  <dig> .

to test the performance of the eb method, we ran the program with the following parameter values: τ = - <dig>  ω =  <dig> ,  <dig> ,  <dig>  and  <dig> , which yielded  <dig>   <dig>   <dig>  and  <dig> true simulated effects, respectively, and  <dig>   <dig>   <dig>  and  <dig> false effects, respectively, as shown in table  <dig>  cross-validation was not done because it was too time-consuming, and thus, the optimal values for the parameters could not be determined. nevertheless, we listed  <dig> true positive effects estimated with τ = - <dig> and ω =  <dig>  in table  <dig>  which reflects the best performance of the eb method with the set of parameters values tested. we also plotted these  <dig> effects in figures  <dig> and  <dig>  comparing the effects detected by eblasso and eb methods shown in table  <dig> and in figures  <dig>   <dig>   <dig> and  <dig>  the eblasso method detected  <dig>  true main  effects, whereas the eb method detected  <dig>  true main  effects. overall, the eblasso detected  <dig> more true effects than the eb method without any false positive effects, whereas the eb method gave one false positive effect. we would like to emphasize here that the eb method may detect less number of true effects in practice because as we mentioned earlier it is too time-consuming to choose the optimal values for the parameters τ and ω. to see if eblasso could estimate qtl effects robustly, we simulated three replicates of the data: each replicate consists of  <dig> individuals whose genotypes at  <dig> markers were independently generated and whose phenotypes were calculated from  with e independently generated from gaussian random variables with zero mean and covariance 10i. we performed cross-validation and determined the best values of a and b for each replicate. using these values, we ran the eblasso and identified  <dig>   <dig>   <dig> true positive effects and  <dig>   <dig>   <dig> false positive effects, respectively, for three replicates. these results showed that the eblasso could detect qtl effects robustly.

the eblasso took about  <dig>  minutes of cpu time for each set of values of a and b listed in table  <dig>  whereas the eb took  <dig> hours of cpu time for τ = - <dig> and ω =  <dig>  and about  <dig>   <dig>   <dig> hours for τ = - <dig> and ω =  <dig> ,  <dig> ,  <dig> , respectively. this simulation study showed that the eblasso method not only can detect more effects, but also offers a huge advantage in terms of computational time. note that all simulations were done in matlab. it is expected that the eblasso algorithm will be even faster, after its implementation in c++ is completed.

we wished to test the performance of the rvm and the lasso on the simulated data. to this end, we replaced the inner iteration in our eblasso algorithm with the program sparsebayes that implemented the rvm. although we carefully modified sparsebayes to avoid possible memory overflow due to the large number of possible effects, the program ran out of memory after one or two outer iterations. hence, we did not get any results from the rvm method. considering the qtl model in , the lasso tries to estimate μ and the qtl effects β as follows   

where λ is a positive constant that can be determined with cross-validation  <cit> . we tried to run the program glmnet  <cit>  with the simulated data. however, glmnet could not handle the big design matrix x of  <dig>   <dig> ×  <dig>   <dig> in our qtl model, and we did not get any results from glmnet.

in order to compare the performance of our eblasso algorithm with that of the rvm and the lasso, we simulated a new set of data by deleting the  <dig> epistatic effects in the previous set of simulated data, and then used a qtl model that only contained  <dig> possible main effects to estimate qtl effects, i.e., the design matrix x in  was  <dig> ×  <dig>  the small number of possible effects was chosen to avoid the memory overflow problem of the rvm and glmnet. the results of the eblasso, eb, rvm and lasso for this data set are summarized in table  <dig>  to choose the values of a and b for the eblasso, we ran ten-fold cross validation with the following parameters: a = b =  <dig> ,  <dig> ,  <dig> ,  <dig> ,  <dig> ,  <dig>  since a = b =  <dig>  yielded the smallest pe, we further performed cross-validation with b =  <dig>  and a = - <dig> , - <dig> , - <dig> ,  <dig> . this gave the smallest pe at a = - <dig>  and b =  <dig> . finally, we used a = - <dig>  and b =  <dig>  to run the eblasso algorithm on the whole data set, which identified all  <dig> true effects but also  <dig> false positive effects. in fact, since the eblasso program ran very fast on this data set, we did ten-fold cross validation for  <dig> sets of values for a and b obtained by combining the following values: a = - <dig>  - <dig> , - <dig> , - <dig> , - <dig> , - <dig> , - <dig> , - <dig> , - <dig> ,  <dig> ,  <dig> ,  <dig> ,  <dig> ,  <dig> ,  <dig> and b =  <dig>   <dig>   <dig>   <dig> ,  <dig> ,  <dig>   <dig> ,  <dig>   <dig>   <dig>   <dig>  the smallest average pe and standard error were  <dig>  ±  <dig>  achieved at a =  <dig>  and b =  <dig>  with this set of values, the eblasso identified all  <dig> true effects and also  <dig> false positive effects, which is similar to that identified at a = - <dig>  and b =  <dig> . this study showed that the two-step cross-validation approach, where cross-validation was run with a = b =  <dig> ,  <dig> ,  <dig> ,  <dig> ,  <dig> ,  <dig> and then with a fixed b but a varying a, performed well and could save much time. we further simulated three replicates of the data in the same way described earlier for the model with epistatic effects. we then repeated the two-step cross-validation for each replicate. using the values of a and b determined in cross-validation, the eblasso detected  <dig>   <dig>   <dig> true effects, and  <dig>   <dig> and  <dig> false positive effects, respectively, for three replicates. this again showed that our eblasso could estimate the effects robustly.

◇ parameters are  for the eblasso,  for the eb and λ for the lasso.

*the average pe and the standard error were obtained from ten-fold cross validation.

†the number of detected effects and residual variance were obtained using all  <dig> samples not from cross validation.

‡the first number is the number of true positive effects; the second number is number of false positive effects. all the effects counted have a p-value ≤  <dig> .

the optimal values for the parameters of the eb method were τ = - <dig> and ω =  <dig> , since they gave the smallest pe in cross-validation as listed in table  <dig>  with τ = - <dig> and ω =  <dig> , the eb method detected  <dig> true effects and  <dig> false positive effects. the rvm detected all  <dig> true effects as the eblasso did, but it also output a large number of  <dig> false positive effects. this result is consistent the observation  <cit>  that the uniform prior distribution used in the rvm usually yields many false positive effects. to choose the optimal value of λ for the lasso, we ran ten-fold cross validation starting from λ =  <dig>   and then decreasing λ to  <dig>  with a step size of  <dig>  on the logarithmic scale  =  <dig> ). the smallest pe was achieved at λ =  <dig> . we then used this value to run glmnet on the whole data set, which yielded  <dig> nonzero effects. for each of these nonzero effects, we calculated their standard error using equation  in  <cit> , and then calculated the p-value of each nonzero effect. this gave  <dig> true effects and  <dig> false positive effects with a p-value less than  <dig> . comparing the number of effects detected by the eblasso, eb, rvm and lasso, the eblasso offered the best performance because it detected all true effects and a very small number of false positive effects.

it is seen from table  <dig> that the eblasso and the lasso took much less time than the eb method and the rvm on analyzing this data set. it is expected that the eblasso is much faster than the eb method because as we discussed earlier the eb needs a numerical optimization procedure. the rvm and eblasso generally should have similar speed because two algorithms use the similar technique to estimate effects. however, when applying to the same data set, the rvm often yields a model with much more nonzero effects than the eblasso as is the case here, because the rvm does not provide sufficient degree of shrinkage. due to this reason, the rvm algorithm requires more time than the eblasso. the lasso took slightly less cpu time than the eblasso in this example. however, we would emphasize that the lasso was implemented with fortran but our eblasso was implemented with matlab. the speed of eblasso is expected to increase significantly once it is implemented in c/c++.

real data analysis
this dataset was obtained from  <cit> . this dataset consists of n =  <dig> double haploids  derived from the cross of two spring barley varieties morex and steptoe. the total number of markers was q =  <dig> distributed along seven pairs of chromosomes of the barley genome, covering  <dig> cm of the barley genome. the phenotype was the spot blotch resistance measured as the lesion size on the leaves of barley seedlings. note that spot blotch is a fungus named cochliobolus sativus. this dataset was used as an example for the application of the eblasso method. genotype of the markers were encoded as + <dig> for genotype a , - <dig> for genotype b , and  <dig> for missing genotype. ideally, the missing genotypes should be imputed from known genotypes of neighboring markers. for simplicity, we replaced the missing genotypes with  <dig> in order to use the phenotypes of the individuals with missing genotypes. the total missing genotypes only account for about  <dig> % of all the genotypes. including the population mean, the main and the pair-wise epistatic effects, the total number of model effects was , about  <dig> times as large as the sample size.

*the average pe and the standard error were obtained from five-fold cross validation.

†the number of effects and residual variance were obtained using all  <dig> samples not from cross validation.

‡the first number is the number of effects with a p-value ≤  <dig>  and proportion of variance ≥  <dig> %; the second number is the number of effects with a p-value ≤  <dig> ; the third number is the total number of non-zero effects reported by the program.

eights effects were detected with all of the following parameters: a = b =  <dig> ,  <dig> ,  <dig> ,  <dig> , 1; ,  and  listed here were obtained with a = b =  <dig> .

discussion
xu  <cit>  compared several methods for multiple qtl mapping including the eb  <cit> , lasso  <cit> , penalized likelihood   <cit>  and stochastic search variable selection   <cit>  methods. the ssvs method is much slower than the eb method; whereas lasso and penal methods are faster than the eb method. although we did not directly compare the speed of our eblasso with that of the penal method, based on all comparisons with the eb method in  <cit> , we observed that the eblasso method is faster than penal methods. direct comparison between the eblasso and lasso showed that the lasso is slightly faster than the current version of eblasso, however, this may not be the case when the eblasso is implemented in c/c++ instead of matlab. although eb, lasso, penal and ssvs methods all produced satisfactory results in a simulation study  <cit> , the eb method outperformed the other three methods in terms of the mean-squared error. moreover, when being applied to a real data set, the eb and lasso detected some effects, whereas the penal and ssvs failed to generate any meaningful results  <cit> . in our simulation studies, we observed that the eblasso method detected more true effects than the eb method with almost the same false positive rate, and the same number of true effects as the lasso but with a much smaller number of false positive effects. when analyzing a real data set, we found that the eblasso method detected a reasonable number of effects, but the eb method detected one or zero effect depending on values of the hyperparameters used. these observations in both simulation study and real data analysis demonstrated that the eblasso method outperforms the eb method and the lasso.

the eblasso method was built upon the idea of the rvm in machine learning. the eblasso and eb methods, as well as the rvm, all are based on a bayesian hierarchical linear regression model and all estimate the variances of the regression coefficients. the difference of the three methods in the regression model is the different prior distributions for the hyperparameters. the eb method and the rvm employ inverse chi-square and uniform distributions, respectively, for the variances of the regression coefficients, while the eblasso assigns exponential distributions to the variance components and uses a gamma distribution for the parameter of the exponential distribution, which leads to the prior distribution in  for the variance components. the uniform prior distribution used by the rvm may not provide enough degree of shrinkage for certain data and thus generate a large number of false positive effects as shown in  <cit>  and as demonstrated in our simulation study.

the prior distributions used by the eblasso and rvm methods enable one to estimate the variance components in a closed form, while the eb method generally needs a numerical optimization algorithm to estimate the variance components. this difference has at least two implications: 1) both the eblasso and the rvm methods requires much less computation than the eb method to estimate the variance components, and 2) the eblasso method and the rvm method can always find the unique optimal estimate of a variance component but the numerical optimization algorithm used by the eb method may not find the optimal value of the variance due to the nonlinearity and non-convexity of the objective function. another main factor that makes the eblasso method and rvm more efficient is an automatic variable selection procedure resulting from the process of estimating variance components, because the variables whose precision is infinity or equivalently whose variance is zero are excluded from the model. this results in an efficient formula in  for calculating the inverse of the covariance matrix of the data. this is especially beneficial when the number of samples is relatively large. on the other hand, the eb method in principle can be applied to a linear regression model with any prior distribution for the variances of regression coefficients. since the prior distribution may play an important role in estimation of the qtl effects, the eb method has its value when one tries to explore different prior distributions.

to get the best performance, the eblasso method needs to properly choose values of hyperparameters a and b. in this paper, we selected the values of a and b that gave the smallest average pe resulting from ten-fold cross validation. ideally, we need to find pes for a large set of values for a ≥ - <dig> and b >  <dig> and then identify the best values for a and b. in our simulation study, we found a two-step cross validation procedure could significantly reduce the number of values to be tested without missing the best values, thereby reducing computational time. in this two-step procedure, we first run cross-validation for the following set of values: a = b =  <dig> ,  <dig> ,  <dig> ,  <dig> ,  <dig> ,  <dig>  we identify the values  from this set of values that yields the smallest pe. we then fixed b to be b* and run cross-validation for several other values of a greater or less than a*. the final best values of a and b are the ones that yield the smallest pe.

the eblasso algorithm may still be improved. in the analysis of simulated data with both main and epistatic effects, although the eblasso method detected  <dig> more true effects than the eb method without any false positive effects, it missed three effects that the eb method detected. it is unclear how this discrepancy occurred. one possible reason is the different prior distributions used in the two methods. although it is difficult for the eblasso method to use the scaled inverse chi-square distribution that is used by the eb method, other prior distributions may worth investigation. another possible reason may be the greedy method used to select the variable to include in or to exclude from the model. in the current algorithm, we choose the variable that gives the largest increase in the likelihood to add to or delete from the model. it may be better to simultaneously add or delete more than one variables. the eblasso method presented in this paper assumes continuous quantitative traits. it can also be extended to handle binary or polychotomous traits and the algorithm is under development. the algorithm is currently implemented in matlab. we are developing programs in c++ to implement the algorithm, which is expected to be much faster and to be capable of running in r and sas environments.

CONCLUSIONS
we have developed a fast empirical bayesian lasso method for multiple qtl mapping that can deal with a large number of effects possibly including main and epistatic qtl effects, environmental effects and the effects of environment and gene interactions. our simulation studies demonstrated that the eblasso algorithm needed about  <dig>  minutes of cpu time, running in matlab on a pc with  <dig>  ghz intel core <dig> cpu and  <dig> gb memory running windows xp, to analyze a qtl model with more than  <dig> possible effects, whereas the eb method took more than  <dig>  minutes to analyze the same model on the same computer. our simulation studies also showed that the eblasso method could detect more true effects with almost the same false positive rate comparing to the eb method. our real data analysis demonstrated that the eblasso method could output more reasonable effects than the eb method. comparing with the lasso, our simulation showed that the current version of the eblasso implemented in matlab was slightly slower than the lasso implemented with glmnet in fortran, and that the eblasso detected the same number of true effects as the lasso but a much smaller number of false positive effects. in conclusion, the eblasso method will be a useful tool in multiple qtl mapping.

authors' contributions
xc conceived the idea of the eblasso method, developed the eblasso algorithm, participated in the data analysis and drafted the manuscript. ah developed the computer programs and performed the data analysis. sx participated in the development of the eblasso algorithm, designed simulation study, participated in the data analysis and helped to draft the manuscript. all authors read and approved the final manuscript.

