BACKGROUND
thanks to recent technological advances, sequencing is no longer restricted to genomes and can now be applied to many new areas, including the study of gene expression and splicing. the so-called rna-seq protocol consists in applying fragmentation and reverse transcription to a rna sample followed by sequencing the ends of the resulting cdna fragments. the short sequencing reads then need to be reassembled in order to get back to the initial rna molecules. a lot of effort has been put on this assembly task  <cit> , whether in the presence or in the absence of a reference genome but the general goal of identifying and quantifying all rna molecules initially present in the sample remains hard to reach. the main challenge is certainly that reads are short, and can therefore be ambiguously assigned to multiple transcripts. in particular, in the case of alternative splicing , reads stemming from constitutive exons can be assigned to any alternative transcript containing this exon. finding the correct transcript is often not possible given the data we have, and any choice will be arguable. as pointed out in martin and wang's review  <cit> , reference-based and de novo assemblers each have their own limitations. reference-based assemblers depend on the quality of the reference while only a small number of species currently have a high-quality reference genome available. de novo assemblers implement reconstruction heuristics which may lead them to miss infrequent alternative transcripts while highly similar transcripts are likely to be assembled into a single transcript. we argue here that it is not always necessary to aim at the difficult goal of assembling full-length molecules. instead, identifying the variable parts between molecules  is already very valuable and does not require to solve the problem of assigning a constitutive read to the correct transcript. we therefore focus in this paper on the simpler task of identifying polymorphisms in rna-seq data. three kinds of polymorphisms have to be considered: i) as  that produces several alternative transcripts for a same gene, ii) snps  that may also produce several transcripts for a same gene whenever they affect transcribed regions, and iii) approximate tandem repeats which affect the number of copies of tandem repeats. our contribution in this paper is double: we first give a general model which captures these three types of polymorphism by linking them to characteristic structural patterns called "bubbles" in the de bruijn graph  built from a set of rna-seq reads, and second, we propose a method dedicated to the problem of identifying as events in a dbg, including read-coverage quantification. we notice here that only splicing events but not transcriptional events, such as alternative start and polyadenylation sites, are covered by our method.

the identification of bubbles or bulges in dbg has been studied before in the context of genome assembly  <cit> . however, the purpose in these works was not to enumerate these patterns, but "only" to remove them from the graph. additionally, since in these applications, the patterns correspond to snps and sequencing errors, the authors only considered paths of length smaller than a constant.

more recently, ad-hoc enumeration methods have been proposed but are restricted to non-branching bubbles  <cit> , i.e., each vertex from the bubble has in-degree and out-degree  <dig>  except for the extremities of the bubble.

extracting as events from a splicing graph has been studied before  <cit>  but a significant difference between splicing graphs and de bruijn graphs is that in the former, nodes are genomically ordered  therefore leading to a dag, whereas dbgs are general graphs, that furthermore do not require any additional information to be built.

when no reference genome is available, efforts have focused on assembling the full-length rna molecules, not the variable parts which are our interest here. most rna-seq assemblers  <cit>  do rely on the use of a dbg, but, since the primary goal of an assembler is to produce the longest contigs, heuristics are applied, such as tip or bubble removal, in order to linearise the graph. the application of such heuristics results in a loss of information which may in fact be crucial if the goal is to study polymorphism.

to our knowledge, this work is the first attempt to characterise polymorphism in rna-seq data without assembling full-length transcripts. we stress that it is not a general purpose transcriptome assembler and when we benchmark it against such methods, we only focus on the specific task of as event calling. finally, our method can be used with a single or multiple rna-seq experiments and our quantification module outputs a coverage  for both the shorter and the longer isoform of each as event, in each experiment.

the paper is organised as follows. we first present the model  linking structures of the dbg for a set of rna-seq reads to polymorphism, and then introduce a method, that we call kissplice, for identifying dbg structures associated with as events . we show in section "results" the results of using kissplice compared with other methods on simulated and real data.

methods
de-bruijn graph models
de-bruijn graph
dbgs were first used in the context of genome assembly in  <dig> by pevzner et al.  <cit> . in  <dig>  medvedev et al.  <cit>  modified the definition to better model dna as a double stranded molecule. in such a context, a dbg is a bidirected multigraph, each node n storing a sequence w and its reverse complement w ¯. the sequence w, denoted by f, is the forward sequence of n, while w ¯, denoted by r, is the reverse complement sequence of n. an arc exists from node n <dig> to node n <dig> if the suffix of length k -  <dig> of f or r overlaps perfectly with the prefix of f or r. each arc is labelled with a string in {ff, rr, fr, rf}. the first letter of the arc label indicates which of f or r overlaps f or r, this latter choice being indicated by the second letter. because of reverse complements, there is an even number of arcs in the dbg: if there is an arc from n <dig> to n <dig> then, necessarily, there is an arc from n <dig> to n <dig> . examples of dbgs are presented in figure  <dig> 

definition  <dig> 
the traversal of a node is said to be valid if the rightmost label  of the arc entering the node is equal to the leftmost label of the arc leaving the node.

a path in the graph is valid if for each node involved in the path, its traversal is valid, that is, each pair of adjacent arcs in the path are labelled, respectively, xy and y z with x, y, z ∈ {r, f}.

for instance, for any graph shown in figure  <dig>  the path starting from the leftmost encircled node, going by the upper path to the rightmost encircled node is valid. a dbg can be compressed without loss of information by merging simple nodes. a simple node denotes a node linked to at most two other nodes. two adjacent simple nodes are merged into one by removing the redundant information. a valid path composed by i >  <dig> simple nodes is compressed into one node storing a sequence of length k +  as each node adds one new character to the first node. figure  <dig> a represents the compressed dbg shown in figure  <dig> a <dig>  in the remaining of the paper, we denote by cdbg a compressed dbg.

bubble patterns in the cdbg
polymorphisms  in a transcriptome or a genome, correspond to recognisable patterns in the cdbg, which we call a bubble. intuitively, the variable parts will correspond to alternative paths and the common parts will correspond to the beginning and end points of these paths. we now formally define the notion of bubble, taking carefully into account the bi-directed and arc labeled nature of the cdbg.

definition  <dig> 
a node is switching with respect to a path if this path is invalid during the traversal of this node.

definition  <dig> 
in the cdbg, a bubble is a simple cycle involving at least three distinct nodes such that exactly two nodes snleft and snright are switching w.r.t. the path of the cycle. by definition, two valid paths exist between these two switching nodes. in the remaining of the paper, we refer to these two paths as the paths of the bubble. if they differ in length, we refer to, respectively, the longer and the shorter path of the bubble.

in general, any process generating patterns asb and as'b in the sequences, with a, b, s, s' ∈ Σ*, |a| ≥ k, |b| ≥ k and s and s' not sharing any k-mer, creates a bubble in the cdbg. indeed, all k-mers entirely contained in a  compose the node snleft . since |a| ≥ k and s ≠ s', there is at least one pair of k-mers, one in as and the other in as', sharing the k -  <dig> prefix and differing by the last letter, thus creating a branch in snleft from which the two paths in the bubble diverge. the same applies for sb, s'b and snright, where the paths merge again. all k-mers contained in s  and in the junctions as and sb  compose the paths of the bubble. in the case of as events and approximate tandem repeats, s is empty and the shorter path is composed of k-mers covering the junction ab.

this model is general as it captures snps, approximate tandem repeats and as events, as shown in figure  <dig>  the main focus of the algorithm we present in this paper is the detection of bubbles generated by as events.

bubbles generated by as events
a single gene may give rise to multiple alternative spliceforms through the process of as. alternative spliceforms differ locally from each other by the inclusion or exclusion of subsequences. these subsequences may correspond to exons , exon fragments  or introns  as shown in figure  <dig>  observe that alternative start and polyadenylation sites, which are not considered as as events but as transcriptional events, are not taken into account in this work. a splicing event corresponds to a local variation between two alternative transcripts. it is characterised by two common sites  and a variable part . in the cdbg, the common sites correspond to the switching nodes and the variable part to the longer path. as there are k -  <dig> k-mers at the junction between the two common sites a.b, the shorter path is composed of at most k -  <dig> k-mers, i.e. represents a path of length at most 2k -  <dig> in the cdbg. an example is given in figure  <dig> b.

the shorter path of a bubble generated by an as event has length exactly 2k -  <dig> iff  the last nucleotide  of the variable part is distinct from the last nt of the left switching node, and  the first nt of the variable part is distinct from the first nt of the right switching node. otherwise, the two alternative paths join ) or diverge ) earlier and the shorter path may be smaller. in human, 99% of the annotated exon skipping events yield a bubble with a shorter path length between 2k -  <dig> and 2k -  <dig> 

bubbles generated by snps and approximate tandem repeats
polymorphism at the genomic level will necessarily also be present at the transcriptomic level whenever it affects transcribed regions. two major kinds of polymorphism can be observed at the genomic level: snps and approximate tandem repeats. as shown in figure  <dig>  these two types of polymorphism also generate bubbles in the cdbg.

however, these bubbles have characteristics which enable to differentiate them from bubbles generated by as events. indeed, bubbles generated by snps exhibit two paths of length exactly 2k -  <dig>  which is larger than 2k -  <dig>  the maximum size of the shorter path in a bubble generated by an as event.

approximate tandem repeats may generate bubbles with a similar path length as bubbles generated by splicing events, but the sequences of the paths exhibit a clear pattern which can be easily identified: the longer path contains an inexact repeat. more precisely, as outlined in figure  <dig> c, it is sufficient to compare the shorter path with one of the ends of the longer path.

finally, genomic insertions or deletions  may also generate bubbles with similar path lengths as bubbles generated by splicing events. in this case, the difference of length between the two paths is usually smaller . in our method, when the difference of path lengths is strictly below  <dig>  we classify the bubble as an indel. otherwise, we do not decide, which means that a fraction of the bubbles we report as as events will correspond to indels. note that this classification is a simple suggestion. we encourage users to affine results by considering species specificity and by applying coverage criterion.

in the following, we focus on bubbles generated by as events. we do provide as a collateral result three additional collections of bubbles: one corresponding to putative snps, one to short indels, and one to putative approximate tandem repeats. the post-treatment of these collections to discard false positives caused by sequencing errors is beyond the scope of this paper.

the kissplice algorithm
the kissplice algorithm detects in the cdbg all the bubble patterns generated by as events, i.e. the bubbles having a shorter path of length at most 2k -  <dig>  essentially, the algorithm enumerates all the cycles verifying the two following criteria: i) the path obtained by following all the nodes of the cycle contains exactly two nodes that are switching for this path, and ii) the length of the shorter path linking the two switching nodes must be no longer than 2k -  <dig>  further criteria are applied to make the algorithm more efficient without loss of information, and to eliminate polymorphism events that do not correspond to as. since the number of cycles in a graph may be exponential with the size of the graph, the naive approach of enumerating all cycles of the cdbg and verifying which of them satisfy our conditions is only viable for very small cases.

nonetheless, kissplice is able to enumerate a potentially exponential number of bubbles for real-sized data in very reasonable time and memory. this is in part due to the fact that, previous to cycle enumeration, the graph is pre-processed in a way that, along with the pruning criteria of step  <dig> , is responsible for a good performance in practice.

kissplice is indeed composed of six main steps which are described next. the pre-processing just mentioned corresponds to step  <dig>  as far as we know, it is the first time it is used in conjunction with cycle enumeration.

step  <dig>  construction of the cdbg of the reads of one or several rna-seq experiments. each node contains the coverage of the corresponding k-mer in each experiment. in order to get rid of most of the sequencing errors, nodes with a minimal coverage of  <dig> may be removed.

step  <dig>  biconnected component  decomposition. a connected undirected graph is biconnected if it remains connected after the removal of any vertex. a bcc of an undirected graph is a maximal biconnected subgraph. moreover, it is possible to show that the bccs of an undirected graph form a partition of the edges with two important properties: every cycle is contained in exactly one bcc, and every edge not contained in a cycle forms a singleton bcc. applying on the underlying undirected graph of the cdbg tarjan's lowpoint method  <cit>  which performs a modified depth-first search traversal of the graph, step  <dig> detects all bccs, and discards all singleton ones that could not contain any bubble. without modifying the results, this considerably reduces the memory footprint and the computation time of the whole process. to give an idea of the effectiveness of this step, the cdbg of a  <dig> m dataset had  <dig>  m nodes, but the largest bcc only  <dig> nodes.

step  <dig>  four-nodes compression. single substitution events  generate a large number of cycles themselves included into bigger ones, creating a combinatorial explosion of the number of possible bubbles. this step of kissplice detects and compresses all bubbles composed by just four nodes: two switching nodes and two non-branching internal nodes each storing equal length sequences differing by just one position. figure  <dig> a shows an example of a four-nodes bubble. four-nodes bubbles are output as potential snps and then reduced to a three-nodes path. the two non-branching internal nodes are merged into one, storing a consensus sequence where the unique substitution is replaced by n.

step  <dig>  bubbles enumeration. the cycles are detected in the cdbg using a backtracking procedure  <cit>  augmented with two pruning criteria. the exploration of one cycle is stopped if the path contains more than two nodes that are switching relative to the path that is being followed, or the length of the shorter path is bigger than 2k -  <dig>  this approach has the same theoretical time complexity of tiernan's algorithm for cycle enumeration  <cit> , which is worse than tarjan's  <cit>  polynomial delay algorithm but it appears to be not immediate how to use the pruning criteria with the latter while preserving its theoretical complexity. we however were able to show that in practice, the pruning criteria are very effective for the type of instances we are dealing with. indeed, we compared the three following implementations on a  <dig> m reads dataset: i) tiernan ii) tarjan iii) tiernan with prunings . the results clearly showed that, while tarjan  outperforms tiernan , both are clearly outperformed when the prunings are used .

step  <dig>  results filtration and classification. the two paths of each bubble are aligned. if the whole of the shorter path aligns with high similarity to the longer path, we decide that the bubble is due to an approximate tandem repeat . after this alignment, a bubble is classified either as an as event, an approximate tandem repeat, or a small indel .

step  <dig>  read coherence and coverage computation. reads from each input dataset are mapped to each path of the bubble. if at least one nucleotide of a path is covered by no read, the bubble is said to be not read-coherent and is discarded. the coverage of each position of the bubble corresponds to the number of reads overlapping this position. border effects are handled in the following way: reads mapping to the extremity of a path with less than k bases are discarded. this results in a systematic under-estimation of the coverage of the extremities of the path. under a simple assumption of locally uniform coverage, this can be counter-balanced by multiplying the coverage of each of the k -  <dig> external positions by a correction factor of ll-i, with l the read size and i the distance to the first non biased position. this correction is possible because the paths considered correspond to internal transcript sequences, not to a transcription start or end.

RESULTS
simulated data
in order to assess the sensitivity and specificity of our approach, we simulated the sequencing of genes for which we are able to control the number of alternative transcripts. we show that the method is indeed able to recover as events whenever the alternative transcripts are sufficiently expressed. for our sensitivity tests, we used simulated rna-seq single end reads  with sequencing errors. we first tested a pair of transcripts with a  <dig> nt skipped exon. simulated reads were obtained with metasim  <cit>  which is a reference software for simulating sequencing experiments. as in real experiments, it produces heterogeneous coverage and authorises to use realistic error models.

in order to find the minimum coverage for which we are able to work, we created datasets for several coverages , with  <dig> repetitions for each coverage, and tested them with different values of k . the purpose of using  <dig> repetitions for each coverage was to obtain results which did not depend on irreproducible coverage biases. for coverages below 8× , kissplice found the correct event in some but not all of the  <dig> tested samples. the failure to detect the event was due to the heterogenous and thus locally very low coverage around the skipped exon, e.g. some nt were not covered by any read or the overlap between the reads was smaller than k- <dig>  above 8× , kissplice detected the correct exon skipping event in all samples.

for each successful test, there was a maximal value kmax for k above which the event was not found, and a minimal value kmin below which kissplice also reported false positive events. indeed, if k is too small, then the pattern ab, as 'b, with |a| ≥ k, |b| ≥ k is more likely to occur by chance in the transcripts, therefore generating a bubble in the dbg. between these two thresholds, kissplice found only one event: the correct one. the values of kmin and kmax are clearly dependent on the coverage of the gene. at 8× , the  <dig> nucleotides exon was found between kmin =  <dig> and kmax =  <dig>  at 20× , it was found for kmin =  <dig> and kmax =  <dig>  we performed similar tests on other datasets, varying the length of the skipped exon. as expected, if the skipped exon is shorter , kissplice needed a lower  coverage to recover it.

since kissplice is, to our knowledge, the first method able to call as events without a reference genome, it cannot be easily benchmarked against other programs. here, we compare it to a general purpose transcriptome assembler, trinity  <cit> . both methods are compared only on the specific task of as event calling. the current version of trinity being restricted to a fixed value of k =  <dig>  we systematically verified that this value was included in .

we found out that trinity was able to recover the as event in all  <dig> samples only when the coverage was above 18× , which clearly shows that kissplice is more sensitive for this task. this can be explained by the fact that trinity uses heuristics which consist in discarding a k-mer in the dbg whenever it is  <dig> times less frequent than an alternative k-mer branching at the same location in the dbg.

all these results were obtained using a minimal k-mer coverage  of  <dig>  we also tested with mkc =  <dig> , leading to the same main behaviour. we noticed however a loss in sensitivity for both methods, but a significant gain in the running time. kissplice found the event in all  <dig> samples for a coverage of 12×  which remains better than the sensitivity of trinity for mkc =  <dig> 

real data
we further tested our method on rna-seq data from human. even though we do not use any reference genome in our method, we applied it to cases where an annotated reference genome is indeed available in order to be able to assess if our predictions are correct.

we ran kissplice with k =  <dig> and mkc =  <dig> on a dataset which consists of  <dig> m reads from human brain and  <dig> m reads from liver from the illumina body map  <dig>  project . as in all dbg-based assemblers, the most memory consuming step was the dbg construction which we performed on a cluster. the memory requirement is directly dependent on the number of unique k-mers in the dataset. despite the fact that we do not use any heuristic to discard k-mers from our index, our memory performances are very similar to the ones of inchworm, the first step of trinity, as indicated in figure  <dig>  in addition, for the specific task of calling as events, kissplice is faster than trinity as shown in figure  <dig> 

kissplice identified  <dig> biconnected components which contained at least one bubble,  <dig> of which consisted of bubbles generated by approximate tandem repeats and  <dig> which consisted of bubbles generated by short indels . noticeably, the bccs which generated most cycles and were most time consuming were associated to approximate tandem repeats. as these bubbles are not of interest for kissplice, this observation prompted us to introduce an additional parameter in kissplice to stop the computation in a bcc if the number of cycles being enumerated reaches a threshold. this enabled us to have a significant gain of time. we however advise not to use this threshold if the purpose is to identify as events associated to approximate tandem repeats, which we did not address here.

out of the  <dig> remaining bccs, we found that  <dig> were read-coherent  and we next focused on this set. for each of the  <dig> cases, we tried to align the two paths of each bubble to the reference genome using blat  <cit> . if the two paths align with the same initial and final coordinates, then we consider that the bubble is a real as event. if they align with different initial and final coordinates, then we consider that it is a false positive. out of the  <dig> bccs,  <dig>  corresponded to real as events, while the remaining corresponded to false positives. a first inspection of these false positives led to the conclusion that the majority of them correspond to chimeric transcripts. indeed, the shorter path and the longer path both map in two blocks within the same gene, but the second block is either upstream of the first block, or on the reverse strand, in both cases contradicting the annotations and therefore suggesting that the transcripts are chimeric and could have been generated by a genomic rearrangement or a trans-splicing mechanism.

for each of the  <dig> real cases, we further tried to establish if they corresponded to annotated splicing events. we therefore first computed all annotated as events using astalavista  <cit>  and the ucsc known genes annotation  <cit> . then, for each aligned bubble, we checked if the coordinates of the aligned blocks matched the splice sites of the annotated as events. if the answer was positive, then we considered that the as event we found was known, otherwise we considered it was novel. out of a total of  <dig> cases, we find that only  <dig> are known while  <dig> are novel. this clearly shows that current annotations largely underestimate the number of alternative transcripts per multi-exon genes as was also reported recently  <cit> .

additionally, we noticed that  <dig> bccs contained more than one as event, which all mapped to the same gene. this corresponds to complex splicing events which involve more than  <dig> transcripts. such events have been described in sammeth et al.  <cit> . their existence suggests that more complex models could be established to characterise them as one single event, and not as a collection of simple pairwise events. an example of novel complex as event is given in figure  <dig> 

we also found the case where the same as event maps to multiple locations on the reference genome . we think these correspond to families of paralogous genes, which are "collectively" alternatively spliced. we were able to verify this hypothesis on all tested instances. in this case, we are unable to decide which of the genes of the family are producing the alternative transcripts, but we do detect an as event.

characterisation of novel as events
in order to further characterise the  <dig> novel as events we found, we compared them with annotated events considering their abundance, length of the variable region and use of splice sites. for each as event, we have  <dig> abundances, one for each spliceform , and one for each condition. we computed the abundance of an event as the abundance of the minor spliceform. as outlined in figure  <dig>  we show that novel events are less abundant than annotated events. this in itself could be one of the reasons why they had not been annotated so far. interestingly, we also found that while annotated events are clearly more expressed in brain than liver , this trend was weaker for novel events . this may reflect the fact that, since tissue-specific splicing in brain has been intensely studied, annotations may be biased in their favour.

we then computed the length of each event as the difference of the length between the two paths of the bubble. we found that for annotated events, there is a clear preference  for lengths that are a multiple of  <dig>  which is expected if the event affects a coding region. however, although still very different from random, this preference is less strong for novel events , which, in addition are particularly enriched in short lengths as shown in figure  <dig> 

finally, we computed the splice sites of annotated and novel events, and we found that a vast majority  of known events exhibit canonical splice sites, while this is again less strong for novel events . out of the non canonical cases,  <dig> correspond to u <dig> introns, but most correspond to short events.

altogether, while we cannot discard that short non canonical events do occur and have been under-annotated so far, we think that the observations we make on the length and splice site features can be explained by the presence of genomic indels in our results. we had indeed already stated in section "de-bruijn graph models" that while most annotated genomic indels are below  <dig> nt, some may still be above. in practice, if the purpose is to strictly study as events and not indels, then we recommend to focus on events longer than  <dig> nt, which have canonical splice sites in  <dig> % of the cases. more generally, we wish to stress that this confusion between genomic indels and as events is currently being made by all transcriptome assemblers.

comparison with trinity
finally, in order to further discuss the sensitivity of our method on real data, we compared our results with trinity. although trinity is not tailored to find as events, we managed to retrieve this information from the output. whenever trinity found several alternative transcripts for one gene, we selected this gene. we further focused on cases which contained a cycle in the splicing graph reconstructed from this gene and we compared them with the events found by kissplice. whenever we found that both the longer and the shorter path of a bubble were mapping to the transcripts of a trinity gene, we decided that both methods had found the same event. in total, kissplice found  <dig> cases, trinity found  <dig> out of which  <dig> were common. while the sensitivity is overall larger for kissplice, we see that  <dig> cases are found by trinity and not by kissplice. we then mapped these transcripts to the human genome using blat. in many instances , the transcripts did not align on their entire length, or to different chromosomes, indicating that they corresponded to chimeras. a first inspection of the remaining  <dig> cases revealed that they correspond to the complex bccs we chose to neglect at an early stage of the computation, because they contain a very large number of approximate tandem repeats. a first simple way to deal with this issue is to increase the value of k. the effect of this is to break the large bccs into computable cases, enabling to recover a good proportion of the missed events. for instance, for k =  <dig>  we found back  <dig> cases. more generally, this shows that more work on the model and on the algorithms is still required to characterise better as events which are intricated with approximate tandem repeats. we think that trinity manages to identify some of them because it uses heuristics, which enables it to simplify these complex graph structures.

CONCLUSIONS
this paper presents two main contributions. first, we introduced a general model for detecting polymorphisms in de bruijn graphs, and second, we developed an algorithm, kissplice, to detect as events in such graphs. this approach enables to tackle the problem of finding as events without assembling the full-length transcripts, which may be time consuming and uses heuristics that may lead to a loss of information. to our knowledge, this approach is new and should constitute a useful complement to general purpose transcriptome assemblers.

results on human data show that this approach enables de-novo calling of as events with a higher sensitivity than obtained by the approaches based on a full assembly of the reads, while using similar memory requirements and less time. 5% of the extracted events correspond to false positives, while the 95% remaining can be separated into known  and novel events . novel events exhibit similar sequence features as known events as long as we focus on events longer than  <dig> nt. below this, novel events seem to be enriched in genomic indels.

kissplice is available for download at http://alcovna.genouest.org/kissplice/ and can already be used to establish a more complete catalog of as events in many species, whether they have a reference genome or not. despite the fact that more and more genomes are now being sequenced, the new genome assemblies obtained usually do not reach the level of quality of the ones we have for model organisms. hence, we think that methods which do not rely on a reference genome are not going to be easily replaced in the near future. there is of course room for future work. the kissplice algorithm could be improved in several ways. the coverage could be used for distinguishing snps from sequencing errors. moreover, the sequences surrounding the bubbles could be locally assembled using a third party tool  <cit> . this would allow to output their context or the full contig they belong to.

last, the complex structure of bccs associated to approximate tandem repeats seems to indicate that more work on the model and on the algorithms is required to efficiently deal with the identification of real approximate tandem repeat events, which may be highly intertwined with other events.

competing interests
the authors declare that they have no competing interests.

authors' contributions
vl proposed the models, pp gs and mfs developed the algorithms, rc implemented the dbg construction, pa and gs implemented the main algorithms, pp supervised the implementations, jk ran the tests on simulated data, ru ran the tests on real data, vl supervised the tests. all authors contributed to the writing of the paper.

