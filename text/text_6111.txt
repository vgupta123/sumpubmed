BACKGROUND
introduction
the secondary structure of an rna molecule is a representation of the pattern, given an initial rna sequence, of complementary base-pairings that are formed between the nucleic-acids. the sequence, represented as a string of four letters, is a single strand consisting of the nucleotides a, c, g, and u, which are generally assumed to pair to form a secondary structure with minimum free energy. as such, the secondary structure of rna is experimentally accessible based on minimum free energy calculations, thus making its computational prediction a challenging but practical problem: it can be directly tested in the laboratory with minimal experimental effort relative to, for example, rna tertiary structure. moreover, there is a well known correspondence between the secondary structure of rna and the molecule's ultimate function.

rna viruses are known to possess unique secondary structures. the secondary structure of an rna virus such as the hepatitis c virus  is mostly elongated due to the large number of base pairings that are formed, thereby lowering its free energy considerably and making the virus much more thermodynamically stable than a random rna sequence. the typical stem-loop structure motif of an rna virus, which consists of a long stem  that ends in an unpaired loop, has been experimentally observed to play a significant role in both virus replication and translation initiation. for example, in hcv, disruptive mutations were found to cause a structural change that directly led to either an alteration in virus replication  <cit>  or to a dramatic reduction in translation initiation  <cit> .

rna folding prediction
the folding prediction problem of the secondary structure of rnas has been an area of active research since the late 70's. dynamic programming methods were developed in  <cit>  and in  <cit>  for computing the maximum number of base pairings in an rna sequence. energy-minimization methods by dynamic programming  <cit>  have led to zuker's mfold prediction server  <cit>  and the vienna rna package  <cit> . the predictive accuracy of these packages was improved by incorporating expanded energy rules  <cit> , derived from an independent set of experiments, into the folding prediction algorithm.

rna mutation prediction
the folding prediction problem described above is the most fundamental problem in rna bioinformatics. the related rna mutation prediction problem, in turn, is a sub-problem that uses the methods developed for rna folding prediction multiple times to predict various mutation combinations. from a computer program's perspective, mutation prediction can be viewed as an outer loop that uses rna folding prediction in its inner loop. the mutation prediction problem, however, presents several computationally challenging issues, mainly in the generalization to multiple-point mutations, which can become computationally heavy if a 'brute-force' strategy of calculating all possible mutations is used without devising a unique approach. we propose to solve this problem by using suboptimal folding prediction solutions, described in the next section, which offer a practical method for achieving high computational efficiency.

the mutation prediction problem was initially investigated in  <cit>  and has been revived in  <cit> . the first publicly available computerized tools for rna mutation prediction, which only account for single-point mutation predictions, are the java tool called rnamute  <cit>  and a web server called rdmas  <cit> . neither of the tools can handle multiple-point mutations, though the authors in this work have already extended rnamute to calculate all multiple-point mutations in a 'brute-force' manner , revealing that this is a computationally heavy task.

rnamute: rna secondary structure single-point mutation analysis tool
rnamute is an interactive java tool that, given an rna sequence, calculates the secondary structure of all single point mutations and organizes them into categories according to their distances from the predicted wild-type structure. more details are available in  <cit> . for grouping and analyzing the point mutations, rnamute utilizes mathematical theorems that relate to eigen-decomposition of the laplacian matrix  <cit>  corresponding to shapiro's coarse-grain tree graphs  <cit> . the vienna rna package  <cit>  is currently used as the core for rnamute and for the rdmas server  <cit>  that also analyzes point mutations. future extensions may include rnashapes  <cit>  for the coarse-grain representation and the rnaforester  <cit>  for tree comparisons.

motivation for an efficient extension to analyze multiple-point mutations
the examination of the phenotypic data based on hepatitis c virus  experiments  <cit>  presents a typical example of the powerful potential of rnamute. in the structural analysis of 5bsl <dig>  via mutagenesis experiments, rnamute could have assisted as a pre-processing step, performed before the site-directed mutagenesis experiments, to provide a selection of mutations superior to that achieved by trial and error. rnamute could have identified locations likely to disrupt certain motifs in the rna secondary structure that are known to be functionally important for virus replication. another example that highlights the application potential of rnamute is the structure of the stem-loop iiic of the hepatitis c virus 1b 5' untranslated region   <cit> . in this case, rnamute can predict a single point mutation that causes a dramatic reduction in the translation initiation of the virus.

thus, extensions of rnamute should enable preliminary analyses before deciding which mutations to employ experimentally for the disruption of certain important motifs in the rna secondary structure. our innovative approach presents an automated technique for considering some of the sophisticated secondary structure scenarios beyond a local disruption or formation of a single watson-crick base pairing, which proved misleading in the past, as was the case in  <cit>  that was discussed in  <cit> . although this specific case could have been resolved using the 'primitive' rnamute described in  <cit>  for predicting a single point mutation that hinders the translation initiation, more advanced cases will need an efficiently running, multiple-point mutation, 'extended' rnamute, as proposed here.

using rnasubopt  <cit> , our method extends the applicability of rnamute to multiple-point mutations. in general, the same type of analysis could be done using the suboptimal solutions obtained by mfold  <cit> . however, for practical reasons concerning our specific application of multiple-point mutations we utilized the vienna rna package since mfold uses pre-defined filters for filtering suboptimal structures. in developing our method, the motivation was to start with all suboptimal solutions as provided in vienna's rnasubopt  <cit>  and to experiment with various filters of our own, comparing our application's performance to that of the original rnamute  <cit>  with vienna's rnafold. in the future, we plan to incorporate mfold into rnamute alongside vienna's rnafold and rnasubopt. note that both rnasubopt and rnafold are used with the "no lonely pair" option to conform with the vienna web server.

the original rnamute  <cit>  analyzes only one-point mutations for a given rna sequence. although a single point mutation may sometimes cause a secondary structure rearrangement of an rna molecule, often it is essential to introduce more than a single point mutation to alter the rna secondary structure. the second version of rnamute  that followed the original  <cit>  and was implemented before the work described here is already capable of dealing with multiple point mutations by trying all possible m-point mutations. however, if the length of the sequence is n and the number of point mutations is m, the running time for the number of point mutations tried will be o, which, computationally, is highly expensive. to estimate the run time, analysis of a sequence length of about  <dig> nts with 3-point mutations would require at least several hours on a typical pc. to overcome this problem, we present a faster method in which we do not need to simulate all possible m-point mutations in the sequence; instead, after executing rnasubopt  <cit>  once on the wild-type sequence, we find them directly from the suboptimal solutions provided by the vienna rna package.

RESULTS
algorithm
the algorithm consists of several steps performed consecutively. first, given a wild-type sequence with several input parameters, the suboptimal solutions of the minimum free energy folding prediction are calculated. this step is followed by a suboptimal solutions filtering step. next, the beginning and end points of each stem in the suboptimal solution results are calculated. finally, m-point mutations that disrupt the optimal solution are calculated. a summary of all the steps in the procedure is given in the flowchart available in figure  <dig>  each step is described in detail below.

calculating suboptimal solutions
after running the program, it calculates the dot-bracket representation of the optimal secondary structure of the given sequence, using the rnafold routine of the vienna rna package, and the dot-bracket representations of all suboptimal secondary structures that are obtained using the rnasubopt routine of the vienna rna package with some parameter -e  are also calculated. this parameter is chosen by the user. the lower limit of e is  <dig>  regarding the upper limit, as will be elaborated in the discussion section, it is recommended to start for example from e =  <dig> for short sequences of about  <dig> nts with 3-point mutations and then to perform consecutive trials with increasing e until the optimal value is found for a particular case. in the case of sequences of about  <dig> nts and 3-point mutations, increasing e to high values such as  <dig> instead of  <dig> will yield a running time of days instead of seconds/minutes and is not desired. the program saves the optimal structure as "opt" and all the suboptimal structures as a list called "subopts".

filtering suboptimal solutions
we use three filters on the "subopts" list:

1) the first filter removes all suboptimal solutions for which the distance of their dot bracket representations from "opt" is less than a parameter value  as specified by the user . the distances are computed as described below.

2) the second filter is designed to simply discard the suboptimal solutions that most likely will not become the optimal solution after the introduction of an m-point mutation. for example, if the dot bracket representation of the optimal solution of the sequence ugccugccucuugggaggggc is .)))))) and the dot bracket representation of one of the suboptimals is ..)......., then it is clear that no one-point mutation can cause the optimal to become suboptimal. compared to the other filters, the effect of such a filter is minor, and indeed it can be easily shut off as explained in connection with a threshold parameter called diff that will be described below. to generate such a filter, one could consider scenarios of hypothetical mutations in which a previously suboptimal solution becomes the optimal, but in such scenarios the location of the mutation is unknown, and therefore, we cannot measure the stability of such a structure using the zuker-turner energy rules  <cit> . however, we can apply a simplistic, highly approximate model that suits our requirements, one that will calculate the relative stabilities of the secondary structures of the optimal and all suboptimal solutions using a weighted nussinov model  <cit>  for assessing the strength of the base pairings. the base pairs cg and gc that are composed of three hydrogen bonds are given a score of  <dig>  base pairs au and ua that are composed of two hydrogen bonds are given a score of  <dig>  and base pairs gu and ug that are traditionally considered a weaker bond compared to the former  are given a score of  <dig>  after this calculation the filter removes those suboptimal solutions with relative stabilities that are lower than that of the optimal as a consequence of the introduction of "nummuts" mutations  into the wild-type sequence. for more information on how this filter operates and how to shut it off, see 'additional file 1:filter2' for supplementary information on the second filter.

3) the third filter removes the suboptimal solutions that are closest to each other, i.e., if the distance between two suboptimal solutions is less than a parameter "dist2" that is specified by the user , then one of the suboptimal solutions will be removed. as a pre-processing step, we prefer to remove solutions whose distances from the optimal are smallest and those deemed as less stable solutions. for this reason we sort all the remaining  suboptimal solutions according to their distance from optimal in descending order and subsequently sort them according to their energy calculated by rnasubopt. only after the program is done with both sorting tasks is the third filter applied. we start from the first suboptimal solution , and check the distance of this solution against all other solutions. each of the following solutions for which the distance from the first solution is less than "dist2" will be removed from the list, but the first solution remains in the list. after reaching the end of the list, the second suboptimal solution becomes the first, and so on.

if the chosen parameters dist <dig> and dist <dig>  are large numbers relative to the length of the sequence, then filtering is a fast process because most suboptimal solutions were filtered already with the first filter. thus, the third filter, which has a quadratic running time of o because we compare all pairs of suboptimal solutions, also appears to be fast. the running time of the first filter is o, where "subs" is the number of suboptimal solutions obtained by running rnasubopt on the wild-type rna sequence.

calculating the distance between two dot-bracket representations
in the future, we will offer a choice between three methods for calculating the distance between two dot-bracket representations of rna secondary structures, but here we only used the two computationally faster techniques to present the methodology. the first method is vienna's rnadistance, which calculates a tree-edit distance by default. the second, more approximate method was developed to save time because we had too many suboptimal solutions to compare. using this method we simply run the two dot-bracket representations in parallel and calculate the number of mismatches, or, equivalently, the hamming distance. the running time is o, where n is the length of the dot-bracket representation. finally, distances can also be calculated using the base pair distance that has been used in many previous studies . similar to the hamming distance, the base pair distance can be calculated efficiently with a running time of o. the current version of our application includes both the hamming distance and the base pair distance as options for the user; the more expensive tree-edit distance could be added in the future. for example, suppose we have the following two dot brackets:

)))

.)))

the hamming distance between the two dot-bracket representations is  <dig> , whereas the base pair distance is  <dig> 

calculating the stems
after we filter the suboptimal solutions, we calculate the stems for each suboptimal solution by calculating the starting and ending points of each stem in the suboptimal solution.

for example, one of the suboptimal solutions for the given sequence ugccugccucuugggaggggc is:

..).)))...

the dot plot  for this suboptimal solution has two stems . in all the dot plots presented in this work, it should be noted that we start the numbering from zero, and when referring to sequence positions in the dot plots this should be taken into account. the stems are represented by the starting and ending points, so the start of the first stem on this plot is location  and the end of the first stem is location . similarly, the starting and the ending points of the second stem are  and  respectively.

calculating m-point mutations that disrupt the optimal solution
we begin by searching for locations at which mutations in the dot plot may:  stabilize the suboptimal solution;  destabilize the optimal solution; and  simultaneously stabilize the suboptimal solution and destabilize the optimal solution. the stabilizing mutations in our case are mutations that extend the existing stems, or those that introduce an additional stem  near an existing stem, without disrupting any base pairs in the existing stems. the destabilizing mutations in our case are mutations that disrupt some existing base pairs in the optimal solution without disrupting any base pairs in the suboptimal solution.

for example, location p for a mutation in the dot plot of figure  <dig> signifies that a mutation in either nucleotide  <dig> or  <dig> on the rna sequence forms a base pair between nucleotides  <dig> and  <dig>  note that p extends both stem <dig> and stem <dig>  even connecting them, and as such it stabilizes the suboptimal solution shown in figure  <dig>  additionally, p and the double location p, p are also stabilizing locations because they extend stem <dig>  all the "stabilizing" mutations that we found on the dot plot  are highlighted by circles in figure  <dig> 

therefore, if we are only searching for stabilizing single point mutations, then p or p are candidates but not p as it forms a lonely base pair, which is not stable, and as such it should be discarded. in the case of stabilizing two-point mutations there are also two possibilities, p, p and p, p, while a three-point mutation would incorporate p, p, p. there are no four or greater-than-four point mutations for this suboptimal solution if we are considering only stabilizing mutations. the locations p and p are not stabilizing locations because they will lower the hairpin loop to fewer than three nucleotides, which is unstable. on the other hand, it is possible that mutations in the hairpin are good if these mutations destabilize the optimal solution.

using the same sequence , the optimal solution is .)))))), and the corresponding dot plot is shown in figure  <dig>  in this figure the suboptimal solution that appears in figures  <dig> & <dig> and an optimal solution for the rna sequence are observable. figure  <dig> shows the probability dot plot obtained by running the vienna rna package on the same sequence. based on figures  <dig> & <dig>  we can conclude that mutation g14c in location p stabilizes the suboptimal solution by forming a cg base pair between nucleotides  <dig> and  <dig>  this same mutation, however, also destabilizes the optimal solution by breaking a gc base pair between nucleotides  <dig> and  <dig>  therefore, the mutation g14c is both stabilizing and destabilizing. on the other hand, mutation g5c at the same location p is only a stabilizing mutation, because it also forms a base pair between nucleotides  <dig> and  <dig> in the suboptimal solution and connects "stem 1" and "stem 2", but it has no disruptive effect on the optimal solution. each of these mutations is worth checking, but we may assume that mutation g14c will have a stronger effect on the conformational rearrangement of the optimal solution. and indeed, if we introduce mutation g14c and use the vienna rna package, we can confirm that this is a conformational rearranging mutation . a rearranging mutation means a drastic change in one of the secondary structure motifs as inspected by eye, such as two new hairpins forming instead of one, etc.

mutations g18c and g19a at locations p and p  are also both stabilizing and destabilizing mutations, while mutations on the hairpin of the suboptimal solution, at locations p and p, are only destabilizing mutations. for example, mutation u8g at p disrupts a ua base pair between bases  <dig> and  <dig> in the optimal solution, but this mutation has no effect on base pairs in the suboptimal solution.

implementation
first, we describe the optional modes of operation available to the user according to the problem at hand  when implementing the proposed methodology. second, in testing we analyze the results of two artificial examples in detail, reporting running times, parameter usage, and possible limitations. third, we show two practical implementation examples taken from the full p5abc subdomain of the tetrahymena thermophila group i intron ribozyme and the 5bsl <dig>  sequence of a subgenomic hepatitis c virus  replicon.

after identifying the stabilizing and destabilizing locations, the program calculates m-point mutations using these detected locations. there are four options, depending on the desired running time vs. the number of mutations to be tried, for calculating mutations:

1) in the first option, we only take into account the stabilizing locations and we can only extend the existing stems without making any new stems. the number of mutations in this option is bounded by m * 2m, where s is the number of stems in the suboptimal solution and m is the number of point mutations. the expression  is needed because mutations may be introduced at both ends of the stem, and 2m is included because in each detected location we may introduce two different mutations. the number of mutations will be much lower because in practice the stems are relatively close to each other and it is impossible to perform m mutations near each stem; and in some cases, it will be impossible to perform even a single mutation near the ends of most stems. even for the worst cases, however, the running time is better than in the existing version of rnamute when mmutations are tried, n being the length of the sequence and s <<n. of course, the running time also depends on the number of suboptimal solutions found, but if we take only different suboptimal solutions and use large values for dist <dig> and dist <dig>  we will obtain only about 5– <dig> different suboptimal solutions.

2) in the second option, we take into account not only mutations that extend existing stems, but also those that create a new stem of length > <dig> between existing stems. the running time of this option is greater than that for the first option but still better than that of rnamute. as in the first option, in most cases this option is also fast. but because extending the existing stems is more stable than forming a new short stem near the existing one, in most cases it is enough to use the first option instead of the second option.

3) similar to the first option, this option also considers destabilizing mutations. in practice, the number of destabilizing mutations is usually relatively low, and therefore, the running time of this option is affordable for more than 4– <dig> point mutations. but in some cases where the number of possible destabilizing mutations is large, the running time is close to that of rnamute.

4) a combination of options  <dig> and  <dig> that is similar to the second option, it also accounts for destabilizing mutations. for the same reason stated above in the second option, it is often enough to ignore option  <dig>  thereby choosing option  <dig> over option  <dig> 

for each m-point mutation found, we check the dot-bracket distance of the secondary structure of the mutated sequence, after applying rnafold on it, against the optimal secondary structure of the wild-type sequence. if the distance is greater than or equal to dist <dig>  we print this mutation.

input
input to our program includes:

 <dig>  query rna sequence – "seq".

 <dig>  energy parameter for rnasubopt routine "e" .

 <dig>  distance "dist1" for filtering the suboptimal solutions that are close to the optimal. note: it is recommended that the value for dist <dig> be about 25% of the sequence length, and this value should be lowered if more solutions are desired.

 <dig>  distance "dist2" for filtering the suboptimal solutions that are close to each other. same advice above on how to pick a value for dist <dig> holds for dist <dig> 

 <dig>  "nummuts" – number of point mutations that should be introduced into the rna sequence.

 <dig>  "method" – type of algorithm that will be used to calculate the final m-point mutations.

the recommended parameter values are found in the discussion section.

testing
we test our method by demonstrating it on two examples using artificially generated sequences. the results are described in detail. for our first example, we executed our procedure on the following sequence of length  <dig> nts:

ccuuaaccagcaaaaacugcugg

the following parameters were used: dist <dig> =  <dig>  dist <dig> =  <dig>  e =  <dig>  nummuts =  <dig>  method =  <dig>  distance = hamming. the input screen appears in figure  <dig>  the running time reported was  <dig> sec on a typical pc. about  <dig> rearranging mutations were found . fewer mutations can be obtained by decreasing the value for e or increasing the values of dist <dig> and dist <dig>  for example, when dist <dig> is larger, out of the  <dig> rearranging mutations originally detected, only those exhibiting a greater likelihood to be rearranging mutations are left; if dist <dig> is increased, fewer mutations that degenerate to similar secondary structures are left. one of the rearranging 2-point mutations  is reported in figure  <dig> and its corresponding dot plot in figure  <dig>  examining the dot plot reveals the optimal  and suboptimal  solutions from which we obtained the structure in figure  <dig> after mutations in places p and p. the mutation a15g stabilizes the suboptimal solution by elongating the stem , and the mutation u20g is both stabilizing  and destabilizing .

after undergoing mutation, the suboptimal structure becomes the optimal and vice versa . some of the other mutations at positions p and p that produce the same secondary structure are c10u-u20a, a15g-u20a. note that c10u is both a stabilizing and destabilizing mutation , as well as u20a.

for comparison, we ran rnamute with multiple-point mutations on the same sequence and found that about 20% of all possible 2-point mutations are relatively rearranging mutations . our program succeeded in finding almost all of these 2-point mutations  because we used small distance values while the value of e was even larger than the energy of the optimal structure. using rnamute with multiple-point mutations is computationally very slow, and with it we are almost unable to analyze sequences longer than in the example above and/or those with more than 2-point mutations. this shows the necessity for our efficient procedure.

for longer sequences and for those with more mutations, the number of rearranging mutations is very large. a trial run of rnamute on sequences of about  <dig> nt with 2-point mutation showed that more that 10% of all the m-point mutations were rearranging. if we use a smaller value for e and a larger value for dist <dig>  however, we obtain fewer rearranging mutations. therefore, if we want the program to terminate fast, we will lose a significant number of desired mutations. consequently, to detect more rearranging mutations requires a larger value for e and a smaller value for dist <dig> 

in terms of this example, the following scenarios may occur. there may exist a highly unstable suboptimal solution which, after receiving an m-point mutation, becomes highly stable, thus becoming the new optimal solution. finding such mutations requires that the value of e be increased. in addition, there may be two similar secondary structures, but only one of these structures will become the optimal solution after the insertion of mutations into both structures. if we filter the first structure, for example, with the third filter, we remain with the second one, and as such we may also miss some desired mutations. to overcome this problem, a smaller value of dist <dig> should be tried, but in so doing the running time will increase.

admittedly, what cannot be overcome are the cases in which mutations destabilize both the optimal and the suboptimal solutions. such mutations may destabilize the optimal solution more than the suboptimal one, and the suboptimal may, as a consequence, become the optimal solution. checking such mutations will require running times no shorter than those of rnamute with multiple-point mutations. it is also possible that mutations  form some stems that do not appear in both the optimal and the suboptimal solutions; our method cannot find such mutations, the number of which is relatively small. for example, in the sequences we checked when comparing the performance of rnamute with multiple-point mutations, undetectable mutations comprised no more than 5% of all the rearranging mutations. this number will increase, however, if we use more than 4– <dig> point mutations.

for the second example, we ran the program on the following sequence comprising  <dig> nts:

ccggaagagggggacaacccggggaaacucgggcuaaucccccauguggacccgccccuugggguguguccaaagggcuuugcccgcuuccgg

using the parameters dist <dig> =  <dig>  dist <dig> =  <dig>  e =  <dig>  nummuts =  <dig>  method =  <dig>  and distance = hamming.

the running time reported in this example for our procedure was  <dig> minutes, and the number of rearranging mutations found was about  <dig>  an example of a rearranging 3-point mutation can be observed in figure  <dig>  while figure  <dig> contains more information about the same mutation.

benchmark times for some generated test cases and for the examples reported in the results section, performed on a stand-alone pc with a  <dig>  ghz intel dual-core processor. highlighted are the parameter values that were varied each time.

ugccugccucuugggagggg

and this sequence was repeated  to form the longer sequences of length n =  <dig>  n =  <dig>  n =  <dig>  and n =  <dig> nts reported in the table. the calculations were performed on a stand-alone pc with a  <dig>  ghz intel dual-core processor.

examples for a success of our procedure
for the first example we used the full rna sequence of the p5abc subdomain of the tetrahymena thermophila group i intron ribozyme that appears in the nucleic acid database   <cit> . the purpose of this illustrative example on a well-known biological structure is to show that predictions of our suggested efficient procedure that take a few minutes coincide with predictions performed in a 'brute-force' manner by traversing all possible point mutations that take several hours. in the experiments of wu and tinoco  <cit> , the authors initially took off  <dig> base pairs for convenience with their experiment, starting from the base pair  <dig> u – 30a and ending with the base pair 18g –  <dig> u of the structure drawn in figure  <dig>  in addition, the 19g –  <dig> u wobble base pair was replaced by a 19g – 26c watson-crick base pair and the 20g – 25c base pair was flipped to 20c – 25g. this truncated p5abc subdomain of  <cit>  served as an illustrative example in  <cit>  where it was analyzed with rnamute using only single-point mutations, predicting that only an exceptional single-point mutation may lead to a conformational rearrangement. however, when inserting the full p5abc subdomain into rnamute, it is computationally predicted that no single-point mutation will cause a conformational rearrangement. this illustrative example is small enough to try the 'brute-force' version of rnamute for the case of two point mutations, traversing all two-point mutations in a calculation that takes several hours, finding that only a few two-point mutations located in the p5b stem-loop are predicted to cause a significant conformational rearrangement to a linear structure. we would like to find in a much more efficient manner, using our suggested procedure, those two-point mutations in the rna sequence that will cause a conformational rearrangement to a linear structure of the full p5abc subdomain. therefore, we execute our program on the sequence with the parameters dist <dig> =  <dig>  dist <dig> =  <dig>  e =  <dig>  nummuts =  <dig>  method =  <dig>  and distance = hamming.

the wild-type sequence of the full p5abc subdomain is:

ggcaguaccaagucucaggggaaacuuugagauggccuugcaaaggguaugguaauaagcugcc

the dot bracket representation of the optimal secondary structure is:

)))))))).)))).)))).....))))))

the minimum free energy is - <dig>  kcals/mole, and the predicted structure is shown in figure  <dig> 

after running our program on the wild-type sequence of the full p5abc subdomain, with a reported running time of  <dig> minutes, we obtained several suboptimal structures, in which one of them is a linear structure and its dot bracket representation is:

)....)))))....)))..)))).....))))))

and its minimum free energy is: - <dig>  kcals/mole.

this suboptimal secondary structure is clearly very unstable when compared to the optimal secondary structure. figure  <dig> shows the dot plot with optimal and suboptimal secondary structures. the program finds several two-point mutations that cause the optimal solution to rearrange as the suboptimal solution becomes the optimal. these two-point mutations found in  <dig> minutes coincide with the ones found in a 'brute-force' manner that takes several hours.

for example:

1) the dot bracket representation of the secondary structure of the sequence with mutation g20c-a21c, using vienna's rnafold with the "no lonely pair" option is:

).))))))))....)))..)))).....))))))

a drawing of which appears in figure  <dig>  inspecting the dot plot of figure  <dig>  note that both mutations g20c and a21c in locations p and p stabilize the suboptimal solution by extending "stem 4" , but these mutations have no effect on the base pairs of the optimal solution. in this case we obtain the suboptimal solution with three additional base pairs: two because of the mutations and a third one that was previously a lonely base pair.

2) another case of three mutations g20c-g28c, g20c-g28u, g20c-g28a, in which their secondary structure has the following dot bracket representation using vienna's rnafold with the "no lonely pair" option:

)...))))))....)))..)))).....))))))

as in the previous case, mutation g20c is a stabilizing mutation, but the second mutation in position  <dig> of the sequence is a destabilizing mutation, which destabilizes the base pair 28g – 15c in the optimal secondary structure. in this case we obtain the suboptimal solution with one additional base pair.

for the second example, we take the 5bsl <dig>  sequence of a subgenomic hepatitis c virus  replicon that was evaluated in  <cit>  by site-directed mutagenesis experiments . this example shows the reproducibility of an example of published data for which introduced mutations in a mutagenesis experiment changed the structure and that our suggested computational procedure, given the original sequence, can successfully predict these mutations. the wild-type sequence of the 5bsl <dig>  is:

agcgggggagacauauaucacagccugucucgugcccgaccccgcu

the wild-type is well-predicted by rnafold, as can be observed in figure  <dig>  in  <cit> , denaturating gels were extracted for the 5bsl <dig>  wildtype, and for the two-point mutations c30a-u32g  and c30a-u32a. the gels indicated that in mutant c30a-u32g, which was find not viable, elimination of the c-g base pair by a change from c to a in position  <dig> and the change of the loop nucleotide  <dig> from u to g caused misfolding and disrupted the upper helix. interestingly, mutant c30a-u32a was viable and maintained a similar pattern of cleavage products as the 5bsl <dig>  wildtype, providing a clear indication that preservation of the 5bsl <dig>  structure correlates with viability. it was concluded in  <cit>  that the contrast between c30a-u32g and c30a-u32a suggests that a g in position  <dig> is capable of altering the upper helix, while an a in position  <dig> finds no suitable partners within the nucleotides to make up the stem. the functional meaning of the above is that the two-point mutation c30a-u32g alters virus replication  by causing a conformational rearrangement. the g in position  <dig> is important for this effect to be achieved.

we now experiment with our suggested method for this case. to begin with, the wild-type sequence and its predicted rnafold optimal structure using a dot-bracket representation is:

agcgggggagacauauaucacagccugucucgugcccgaccccgc

.)))))........))))))

next, after running rnasubopt, it is found that one of the suboptimal solutions, in dot-bracket representation, is:

.)...)....))))))

where # is in position  <dig> in the 5bsl <dig> , corresponding to position  <dig> in the entire 5bsl <dig>  and * is in position  <dig> in the 5bsl <dig> , corresponding to position  <dig> in the entire 5bsl <dig>  examining the mutations reported in  <cit> , it is first verified that mutation c30a destabilizes the base pair in the optimal structure and mutation u32g stabilizes the stem in the suboptimal structure, after which we obtain the structure of the two-point mutation c30a-u32g in dot-bracket representation as follows:

.)...)))....))))))

in the next step, when running our method with the parameters: dist <dig> =  <dig>  dist <dig> =  <dig>  e =  <dig>  nummuts =  <dig>  method =  <dig> and distance = hamming we obtain after about  <dig> minutes on a typical pc the results that appear in figure  <dig>  by double-clicking on mutation c30a-u32g in the gui depicted in figure  <dig>  we obtain the secondary structure drawing that appears in figure  <dig>  and highlighted is one of the most distant mutations from the wild-type. this mutation corresponds to the mutation from  <cit> , the virus mutant c30a-u32g that fails to replicate, as discussed above. notably, we find that in full-correspondence with the results and discussion of the experimental results in  <cit> , the two-point mutations in our figure  <dig> are from c to a, g, u in position  <dig> but particularly to g in position  <dig>  this implies that our suggested computational method is in good agreement with the experimental results available in  <cit> .

discussion
considering the possible limitations and the rna energy minimization prediction methods that we are utilizing and our motivation to use them as accurately as possible, our program is intended to work with sequences no longer than 100– <dig> nts. obviously, sequences much longer than 100– <dig> nts will run into memory problems, but, even more deleterious, in many cases the accuracy of its folding prediction will suffer. for sequences with  <dig> nts, the value e =  <dig> or  <dig> is recommended; for sequences with  <dig> nts, the value e =  <dig> is recommended; for sequences with  <dig> nts, the value e =  <dig> is recommended, and for shorter sequences of about  <dig> nts, similar to the examples above, the value e =  <dig> may be used and a typical pc will return an answer after only a few minutes runtime for sequences with 3-point mutations . in general, a larger e value will provide better results but also a longer running time. for all the cases above, although we obtained a large number of suboptimal secondary structures using rnasubopt, after running our filters we only remained with about 10– <dig> different suboptimal solutions. for sequences with  <dig> –  <dig> nts or less, rnasubopt runtime is not a limiting factor if the recommended value of e is used. if the runtime is fast, e can be further increased and another run can be tried. in terms of sequence size and number of point mutations, the actual limitations of our approach are about  <dig> nts for sequence length and 5-point mutations for the number of point mutations. for longer sequences, prediction reliability starts to decline and the running time will be hours or days instead of minutes, which is also the case for more than 5-point mutations even with a sequence size of about 100– <dig> nts.

it is possible that some of the mutations found by our approach will not cause much of a conformational rearrangement effect, and their distance from the wild-type solution will be less than dist <dig>  we simply discard such mutations. in addition, some mutations may exhibit not only large distances from their respective wild-type structures, but there may also be large distances between them and the suboptimal solutions from which they were found. such mutations are printed in the final report, because they are still conformational rearranging mutations.

what is promised by our procedure is that mutations that we find  are indeed conformational rearranging mutations that will lead to structures located relatively far from their wild-type secondary structures. our procedure may miss some mutations that alter the secondary structure of the rna because we rely strictly on suboptimal solutions as a consequence of energy minimization, and it is possible that there are some mutations that alter the secondary structure but that do not appear in the suboptimal solutions derived by energy minimization. this is possible because the free energy of such a suboptimal solution is very large, and the introduction of a mutation may sufficiently lower the free energy, such that it becomes optimal. nevertheless, such situations are of the exception, and in practice the method proposed performs accurately and efficiently.

CONCLUSIONS
we present a method that extends rnamute  <cit>  to treat multiple-point mutations in a tractable manner using suboptimal structures as obtained by vienna's rnasubopt  <cit> . the proposed method is practical, as was demonstrated in two implementation examples. the first with the full p5abc subdomain of the tetrahymena thermophila group i intron ribozyme, showing the success of the efficient approach relative to a 'brute-force' strategy in which all possible multiple-mutations are tried, and explaining the procedure in detail. the second with the 5bsl <dig>  sequence of a subgenomic hepatitis c virus  replicon, showing the success of the suggested computational procedure to predict conformational rearranging mutations that were already found to alter virus replication in a published mutagenesis experiment. the user has the flexibility to choose how much time efficiency is desired vs. how many candidate mutations are to be analyzed. this makes the proposed method particularly suitable for application to specific problems in practice.

