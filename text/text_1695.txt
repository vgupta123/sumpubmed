BACKGROUND
for the past  <dig> years, research in molecular biology has been based predominantly on reductionist thinking, trying to unravel the complex workings of living organisms by investigating genes or proteins one at a time. in recent years, molecular biologists have come to view the cell from a different, more global perspective. with the advent of fully sequenced genomes and high-throughput functional genomics technologies, it has become possible to monitor molecular properties such as gene expression levels or protein-dna interactions across thousands of genes simultaneously. as a consequence, it has become feasible to study genes, proteins and their interactions in the context of biological systems rather than in isolation. this novel paradigm has been named 'systems biology'  <cit> .

one of the goals of the systems approach to molecular biology is to reverse engineer the regulatory networks underlying cell function. particularly transcriptional regulatory networks have received a lot of attention, mainly because of the availability of large amounts of relevant experimental data. several studies use expression data, promoter motif data, chromatin immunoprecipitation  data and/or prior functional information  in conjunction to elucidate transcriptional regulatory networks  <cit> . most of these methods try to unravel the control logic underlying specific expression patterns. this type of analysis typically requires elaborate computational frameworks. in particular probabilistic graphical models are considered a natural mathematical framework for inferring regulatory networks  <cit> . probabilistic graphical models, the best-known representatives being bayesian networks, represent the system under study in terms of conditional probability distributions describing the observations for each of the variables  as a function of a limited number of parent variables , thereby reconstructing the regulatory network underlying the observations. friedman et al. pioneered the use of bayesian networks to learn regulatory networks from expression data  <cit> . in these early studies, each gene in the resulting bayesian network is associated with its individual regulation program, i.e., its own set of parents and conditional probability distribution. a key limitation of this approach is that a vast number of structural features and distribution parameters need to be learned given only a limited number of expression profiles. in other words, the problem of finding back the real network structure is typically heavily underdetermined. an attractive way to remedy this issue is to take advantage of the inherent modularity of biological networks  <cit> , specifically the fact that groups of genes acting in concert are often regulated by the same regulators. segal et al.  <cit>  first exploited this idea by proposing module networks as a mathematical model for regulatory networks. module networks are probabilistic graphical models in which groups of genes, called modules, share the same parents and conditional distributions. as the number of parameters to be estimated in a module network is much smaller than in a full bayesian network, the currently available gene expression data sets can be large enough for the purpose of learning module networks  <cit> .

despite the demonstrated success of module network learning algorithms in finding biologically relevant regulatory relations  <cit> , there is only limited information about the actual recall and precision of such algorithms  <cit>  and how these performance measures are influenced by the use of alternative module network learning strategies. having the means to answer the latter question is key to the further development and improvement of the module networks formalism.

the purpose of the present study is twofold. first, we introduce a novel software package for learning module networks, called lemone, which is based on the general methodology outlined in segal et al.  <cit>  but incorporates an alternative strategy for inferring regulation programs.

second, we demonstrate the use of syntren  <cit> , a data simulator that creates synthetic regulatory networks and produces simulated gene expression data, for the purpose of testing and comparing module network learning algorithms. we use syntren data to assess the performance of lemone and to compare the behavior of alternative module network learning strategies. additionally, we assess the effect of various parameters, such as the size of the data set and the amount of noise, on the inference performance. for comparison, we also use lemone to analyze real expression data for s. cerevisiae  <cit>  and investigate to what extent the quality of the module networks learned on real data can be automatically assessed using structured biological information such as go information and chip-chip data  <cit> .

methods
data sets
we used syntren  <cit>  to generate simulated data sets for a gene network with  <dig> genes of which  <dig> act as regulators. the topology of the network is subsampled from an e. coli transcriptional network  <cit>  by cluster addition, resulting in a network with  <dig> edges. all parameters of syntren were set to default values, except number of correlated inputs, which was set to 50%. syntren generated expression values ranging from  <dig>  to  <dig>  which we normalized to log <dig> ratio values by picking one of the experiments as the control. except where indicated otherwise, the list of true regulators was given as the list of potential regulators for lemone and genomica.

for the tests performed on real data, we used an expression compendium for s. cerevisiae containing expression data for  <dig> different experimental stress conditions  <cit> . the data were obtained in prenormalized and preprocessed form. we used the mean log <dig> values of the expression ratios .

to assess the quality of the regulatory programs learned from real data, we used data on genome-wide binding and phylogenetically conserved motifs for  <dig> transcription factors from harbison et al.  <cit> . for a given transcription factor, only genes that were bound with high confidence  and showed motif conservation in at least one other saccharomyces species  were considered true targets.

module networks
module networks are a special kind of bayesian networks and were introduced by segal et al.  <cit> . to each gene i we associate a random variable xi which can take continuous values and corresponds to the gene's expression level. the distribution of xi depends on the expression level of a set of parent genes pai chosen from a list of potential regulators. if the network formed by drawing directed edges from parent genes to children genes is acyclic, we can define a joint probability distribution for the expression levels of all genes as a product of conditional distributions,

p=∏i=1npi.     
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaacqwgwbaccqggoaakcqwg4baedawgaawcbagaegymaedabeaakiabcycasiabc6cauiabc6cauiabc6cauiabcycasiabdiha4naabaaaleaacqwgobgtaeqaaogaeiykakiaeyypa0zaaebcaeaacqwgwbacdawgaawcbagaemyaakgabeaakiabcicaoiabdiha4naabaaaleaacqwgpbqaaeqaaogaeiifawnaei4easnaemieag3aasbaasqaaiabdqgaqbqabagccqgg6agocqwgqbgacqghiiizieaacqwfqbaucqwfhbqydawgaawcbaacbigae4xaakgabeaakiabc2ha9jabcmcapiabc6cauiaaxmaacawljawaaewaaeaacqaixaqmaiaawicacaglpaaaasqaaiabdmgapjabg2da9iabigdaxaqaaiabd6eaobqdcqghpis1aaaa@5d1f@

this is the standard bayesian network formalism.

in a module network we assume that genes are partitioned into different sets called modules, such that genes in the same module share the same parameters in the distribution function . hence a module network is defined by a partition of { <dig> ...,n} into k ≪ n modules a
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbamrthrhal1wy0l2yhvtyaehbnfgdovwbhrxajfwnaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabawaaegaeaaakeaaimaacqwfaefqaaa@3821@k such that ∪k=1kak
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaacqwiqisvdaqhaawcbagaem4aasmaeyypa0jaegymaedabagaem4saseaamrthrhal1wy0l2yhvtyaehbnfgdovwbhrxajfwnagabaogae8haxh0aasbaasqaaiabdugarbqabaaaaa@3f88@ = { <dig> ...,n} and a
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbamrthrhal1wy0l2yhvtyaehbnfgdovwbhrxajfwnaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabawaaegaeaaakeaaimaacqwfaefqaaa@3821@k ∩ a
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbamrthrhal1wy0l2yhvtyaehbnfgdovwbhrxajfwnaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabawaaegaeaaakeaaimaacqwfaefqaaa@3821@k' = ∅ for k ≠ k', a collection of parent genes ∏k for each module k, and a joint probability distribution

p=∏k=1k∏i∈akpk.     
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaacqwgwbaccqggoaakcqwg4baedawgaawcbagaegymaedabeaakiabcycasiabc6cauiabc6cauiabc6cauiabcycasiabdiha4naabaaaleaacqwgobgtaeqaaogaeiykakiaeyypa0zaaebcaeaadaqeqbqaaiabdchawnaabaaaleaacqwgrbwaaeqaaogaeiikagiaemieag3aasbaasqaaiabdmgapbqabagccqgg8bafcqgg7bwecqwg4baedawgaawcbagaemoaaogabeaakiabcqda6iabdqgaqjabgigiolabg+givpaabaaaleaaiegacqwfrbwaaeqaaogaeiyfa0naeiykakiaeiola4caleaacqwgpbqacqghiiizt0uy0hwztfgdpnwy1egaryqthrhal1wy0l2yhvdaiqaacqgfaefqdawgaaadbagaem4aasgabeaaasqab0gaey4diunaasqaaiabdugarjabg2da9iabigdaxaqaaiabduealbqdcqghpis1aogaaczcaiaaxmaadaqadaqaaiabikdayagaayjkaiaawmcaaaaa@6e4a@

the conditional distribution pk of the expression level of the genes in module k is normal with mean and standard deviation depending on the expression values of the parents of the module through a regression tree that is called the regulation program of the module. the tests on the internal nodes of the regression tree are of the form x ≷ s
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaacqwg4baecqqggaaicqwi9=vbcqqggaaicqwgzbwcaaa@341d@ for some split value s, where x is the expression value of the parent associated to the node .

the bayesian score is obtained by taking the log of the marginal probability of the data likelihood over the parameters of the normal distributions at the leaves of the regression trees with a normal-gamma prior ). its main property is that it decomposes as a sum of leaf scores of the different modules:

s=∑ksk=∑k∑ℓsk,     
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaaieqacqwftbwucqgh9aqpdaaeqbqaaiab=nfatnaabaaaleaacqwgrbwaaeqaaogaeyypa0daleaacqwgrbwaaeqaniabgghildgcdaaeqbqaamaaqafabagaem4uam1aasbaasqaaiabdugarbqabagccqggoaakt0uy0hwztfgdpnwy1egaryqthrhal1wy0l2yhvdaiqaacqgfwesrdawgaawcbagaes4ehwgabeaakiabcmcapawcbagaes4ehwgabeqdcqghris5aogaeiilawiaaczcaiaaxmaadaqadaqaaiabiodazagaayjkaiaawmcaaawcbagaem4aasgabeqdcqghris5aaaa@526e@

where ℰ
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbamrthrhal1wy0l2yhvtyaehbnfgdovwbhrxajfwnaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabawaaegaeaaakeaaimaacqwfwesraaa@3785@ℓ denotes the experiments that end up at leaf ℓ after traversing the regression tree. a normal-gamma prior ensures that sk can be solved explicitly as a function of the sufficient statistics  of the leaves of the regression tree .

learning module regulation programs
for a given assignment of genes to modules, finding a maximum for the bayesian score  consists of finding the optimal partitioning of experiments into 'leaves' ℓ for each module separately, i.e., find a collection of subsets ℰ
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbamrthrhal1wy0l2yhvtyaehbnfgdovwbhrxajfwnaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabawaaegaeaaakeaaimaacqwfwesraaa@3785@ℓ ⊂ { <dig> ...,m} such that ⋃ℓℰ
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbamrthrhal1wy0l2yhvtyaehbnfgdovwbhrxajfwnaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabawaaegaeaaakeaaimaacqwfwesraaa@3785@ℓ = { <dig> ...,m}, ℰ
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbamrthrhal1wy0l2yhvtyaehbnfgdovwbhrxajfwnaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabawaaegaeaaakeaaimaacqwfwesraaa@3785@ℓ ∩ ℰ
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbamrthrhal1wy0l2yhvtyaehbnfgdovwbhrxajfwnaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabawaaegaeaaakeaaimaacqwfwesraaa@3785@ℓ = ∅ for ℓ ≠ ℓ', and

sk=∑ℓsk     
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaaieqacqwftbwudawgaawcbagaem4aasgabeaakiabg2da9maaqafabagaem4uam1aasbaasqaaiabdugarbqabagccqggoaakt0uy0hwztfgdpnwy1egaryqthrhal1wy0l2yhvdaiqaacqgfwesrdawgaawcbagaes4ehwgabeaakiabcmcapawcbagaes4ehwgabeqdcqghris5aogaaczcaiaaxmaadaqadaqaaiabisda0agaayjkaiaawmcaaaaa@4851@

is maximal. in particular we do not have to define the parent sets ∏k of the modules in order to find an optimal partition.

we use a bottom-up hierarchical clustering method to heuristically find a high-scoring partition. at each step of the process we have a collection of binary trees tα which represent subsets ℰ
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbamrthrhal1wy0l2yhvtyaehbnfgdovwbhrxajfwnaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabawaaegaeaaakeaaimaacqwfwesraaa@3785@α of experiments. the binary split of tα into its children tα1
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaacqwgubavdawgaawcbaaccigae8xsde2aasbaawqaaiabigdaxaqabaaaleqaaaaa@30d7@ and tα2
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaacqwgubavdawgaawcbaaccigae8xsde2aasbaawqaaiabikdayaqabaaaleqaaaaa@30d9@ corresponds to a partition of the set ℰ
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbamrthrhal1wy0l2yhvtyaehbnfgdovwbhrxajfwnaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabawaaegaeaaakeaaimaacqwfwesraaa@3785@α into two sets: ℰ
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbamrthrhal1wy0l2yhvtyaehbnfgdovwbhrxajfwnaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabawaaegaeaaakeaaimaacqwfwesraaa@3785@α = ℰα1
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaat0uy0hwztfgdpnwy1egaryqthrhal1wy0l2yhvdaiqaacqwfwesrdawgaawcbaaccigae4xsde2aasbaawqaaiabigdaxaqabaaaleqaaaaa@3a7d@ ∪ ℰα2
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaat0uy0hwztfgdpnwy1egaryqthrhal1wy0l2yhvdaiqaacqwfwesrdawgaawcbaaccigae4xsde2aasbaawqaaiabikdayaqabaaaleqaaaaa@3a7f@. the initial collection consists of trivial trees without children representing single experiments. to proceed from one collection of trees to the next, the pair of trees with highest merge score is merged into a new tree, and the collection of binary trees decreases by one, eventually leading to one hierarchical tree t <dig> representing the complete experiment set ℰ
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbamrthrhal1wy0l2yhvtyaehbnfgdovwbhrxajfwnaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabawaaegaeaaakeaaimaacqwfwesraaa@3785@ <dig> = { <dig> ...,m}. the simplest merge score is given by the possible gain in bayesian score by merging two experiment sets:

rα <dig> α2=sk−sk−sk.     
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaacqwgybgcdawgaawcbaaccigae8xsde2aasbaawqaaiabigdaxaqabawccqggsaalcqwfxoqydawgaaadbagaegomaidabeaaasqabagccqgh9aqpcqwgtbwudawgaawcbagaem4aasgabeaakiabcicaomrthrhal1wy0l2yhvtyaehbnfgdovwbhrxajfwnagabaiab+btifnaabaaaleaacqwfxoqydawgaaadbagaegymaedabeaaasqabagccqghqicycqgfwesrdawgaawcbagae8xsde2aasbaawqaaiabikdayaqabaaaleqaaogaeiykakiaeyoei0iaem4uam1aasbaasqaaiabdugarbqabagccqggoaakcqgfwesrdawgaawcbagae8xsde2aasbaawqaaiabigdaxaqabaaaleqaaogaeiykakiaeyoei0iaem4uam1aasbaasqaaiabdugarbqabagccqggoaakcqgfwesrdawgaawcbagae8xsde2aasbaawqaaiabikdayaqabaaaleqaaogaeiykakiaeiola4iaaczcaiaaxmaadaqadaqaaiabiwda1agaayjkaiaawmcaaaaa@6555@

in additional file  <dig> we define an alternative merge score related to the bayesian hierarchical clustering method of  <cit> . this merge score takes into account the substructure of the trees below tα1
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaacqwgubavdawgaawcbaaccigae8xsde2aasbaawqaaiabigdaxaqabaaaleqaaaaa@30d7@ and tα2
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaacqwgubavdawgaawcbaaccigae8xsde2aasbaawqaaiabikdayaqabaaaleqaaaaa@30d9@ in addition to the bayesian score difference , and tends to produce more balanced trees. in the final step, we need to cut the hierarchical tree t <dig>  to this end we traverse the tree from the root towards its leaves. if we are at a subtree node tα with children tα1
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaacqwgubavdawgaawcbaaccigae8xsde2aasbaawqaaiabigdaxaqabaaaleqaaaaa@30d7@ and tα2
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaacqwgubavdawgaawcbaaccigae8xsde2aasbaawqaaiabikdayaqabaaaleqaaaaa@30d9@, we compute the score difference . if this difference is negative, the total score is improved by keeping the split tα, and we move on to test each of its children nodes. if the difference is positive, the total score is improved by not making the split tα, and we remove its children nodes from the tree. the experiment set ℰ
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbamrthrhal1wy0l2yhvtyaehbnfgdovwbhrxajfwnaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabawaaegaeaaakeaaimaacqwfwesraaa@3785@α becomes one of the leaves of the regulation program, contributing one term in the sum .

the pseudocode for the regulation program learning algorithm is given in figure s <dig> in additional file  <dig>  in  <cit> , regulation programs are learned top-down by considering all possible splits on all current leaves with all potential regulators, so regulation trees and regulator assignments are learned simultaneously. as a result missing regulators or noise in the regulator data might lead to a suboptimal partitioning of the experiments in a module. in our approach we have focused on finding an optimal partition of the module regardless of the set of potential regulators. a module collects the data of many genes and therefore this partition will be less affected by noise or missing data than when it is determined by exact splits on single regulators.

regulator assignment
at a given internal node tα of the regulation tree t <dig>  the experiment set ℰ
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbamrthrhal1wy0l2yhvtyaehbnfgdovwbhrxajfwnaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabawaaegaeaaakeaaimaacqwfwesraaa@3785@α is partitioned into two distinct sets ℰα1
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaat0uy0hwztfgdpnwy1egaryqthrhal1wy0l2yhvdaiqaacqwfwesrdawgaawcbaaccigae4xsde2aasbaawqaaiabigdaxaqabaaaleqaaaaa@3a7d@ and ℰα2
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaat0uy0hwztfgdpnwy1egaryqthrhal1wy0l2yhvdaiqaacqwfwesrdawgaawcbaaccigae4xsde2aasbaawqaaiabikdayaqabaaaleqaaaaa@3a7f@ according to the tree structure. given a regulator r and split value s, we can also partition ℰ
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbamrthrhal1wy0l2yhvtyaehbnfgdovwbhrxajfwnaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabawaaegaeaaakeaaimaacqwfwesraaa@3785@α into two sets

ℛ1={m∈ℰα:xr,m≤s}ℛ2={m∈ℰα:xr,m>s},
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbamrthrhal1wy0l2yhvtyaehbnfgdovwbhrxajfwnaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabawaaegaeaaakeaafaqabegabaaabaacdagae83ghi1aasbaasqaaiabigdaxaqabagccqgh9aqpcqgg7bwecqwgtbqbcqghiiizcqwfwesrdawgaawcbaaccigae4xsdegabeaakiabcqda6iabdiha4naabaaaleaacqwgybgccqggsaalcqwgtbqbaeqaaogaeyizimqaem4camnaeiyfa0habagae83ghi1aasbaasqaaiabikdayaqabagccqgh9aqpcqgg7bwecqwgtbqbcqghiiizcqwfwesrdawgaawcbagae4xsdegabeaakiabcqda6iabdiha4naabaaaleaacqwgybgccqggsaalcqwgtbqbaeqaaogaeyopa4jaem4camnaeiyfa0naeiilawcaaaaa@61d6@

where xr,m is the expression value of regulator r in experiment m.

consider now two random variables: e which can take the values α <dig> or α <dig>  and r which can take the values  <dig> or  <dig>  with probabilities defined by simple counting, p = |ℰα1
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaat0uy0hwztfgdpnwy1egaryqthrhal1wy0l2yhvdaiqaacqwfwesrdawgaawcbaaccigae4xsde2aasbaawqaaiabigdaxaqabaaaleqaaaaa@3a7d@|/|ℰ
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbamrthrhal1wy0l2yhvtyaehbnfgdovwbhrxajfwnaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabawaaegaeaaakeaaimaacqwfwesraaa@3785@α|, p = |ℛ
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbamrthrhal1wy0l2yhvtyaehbnfgdovwbhrxajfwnaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabawaaegaeaaakeaaimaacqwfbeiuaaa@377d@1|/|ℰ
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbamrthrhal1wy0l2yhvtyaehbnfgdovwbhrxajfwnaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabawaaegaeaaakeaaimaacqwfwesraaa@3785@α|, etc. we are interested in the uncertainty in e given knowledge  of r, i.e., in the conditional entropy  <cit> 

h = p1h + p2h,     

where pi = p, h is the binary entropy function

h = -q log -  log,

and qi are the conditional probabilities

qi=p=|ℰα1∩ℛi||ℛi|,i= <dig> .
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaafaqabeqacaaabagaemycae3aasbaasqaaiabdmgapbqabagccqgh9aqpcqwgwbaccqggoaakcqwgfbqrcqgh9aqpiigacqwfxoqydawgaawcbagaegymaedabeaakiabcyha8jabdkfasjabg2da9iabdmgapjabcmcapiabg2da9maalaaabagaeiifaw3enfgdovwbhrxajfwnhbqeg0uy0hwztfgdpnwy1aaceagae4hmhu0aasbaasqaaiab=f7ahnaabaaameaacqaixaqmaeqaaawcbeaakiabgmiihlab+trisnaabaaaleaacqwgpbqaaeqaaogaeiifawhabagaeiifawnae43ghi1aasbaasqaaiabdmgapbqabagccqgg8bafaagaeiilawcabagaemyaakmaeyypa0jaegymaejaeiilawiaegomaijaeiola4caaaaa@6079@

in the presence of missing data, the probabilities pi and qi need to be modified to take into account this extra uncertainty, details are given in additional file  <dig> 

the conditional entropy is nonnegative and reaches its minimum value  <dig> when q <dig> =  <dig> or  <dig> , which means the ℰ
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbamrthrhal1wy0l2yhvtyaehbnfgdovwbhrxajfwnaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabawaaegaeaaakeaaimaacqwfwesraaa@3785@ and ℛ
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbamrthrhal1wy0l2yhvtyaehbnfgdovwbhrxajfwnaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabawaaegaeaaakeaaimaacqwfbeiuaaa@377d@ partitions are equal and the regulator – split value pair 'explains' the split in the regulation tree exactly. hence we assign to each internal node of a regulation tree the regulator – split value pair which minimizes the conditional entropy . since this assignment has to be done only once, after the module networks score has converged, the best regulator – split value pairs can be found by simply enumerating over all possibilities, even for relatively large data sets. the actual algorithm for assigning regulators to all nodes operates first on nodes closer to the roots of the trees where the most significant splits are located, and takes into account acyclicity constraints on the module network. it is presented in pseudocode in figure s <dig> in additional file  <dig> 

learning module networks
to find an optimal module network, learning of regulation trees is alternated with reassigning genes to other modules until convergence of the bayesian score. module initialization can be done using any clustering algorithm. here, we used k-means  <cit> , and reassigning is done like in  <cit>  by making all single-gene moves from one module to another which improve the total score.

network comparison
to obtain a gene network from a module network, we put directed edges from the regulators of a module to all the genes in that module. we compare inferred to true network by computing the number of edges that are true positive , false positive  and false negative . standard measures for the inference quality are precision and recall. precision  is defined as the fraction of edges in the inferred module network that is correct, and recall  as the fraction of edges in the true network that is correctly inferred, i.e.,

p=tptp+fpr=tptp+fn.
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaafaqabeqacaaabagaemiuaalaeyypa0zaasaaaeaaieaacqwf0badcqwfwbacaeaacqwf0badcqwfwbaccqghrawkcqwfmbgzcqwfwbacaaaabagaemouailaeyypa0zaasaaaeaacqwf0badcqwfwbacaeaacqwf0badcqwfwbaccqghrawkcqwfmbgzcqwfubgbaaaaaiabc6cauaaa@449c@

the f-measure, defined as the harmonic mean of precision and recall, f=2prp+r
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaacqwggbgrcqgh9aqpdawcaaqaaiabikdayiabdcfaqjabdkfasbqaaiabdcfaqjabgucariabdkfasbaaaaa@3557@, can be used as a single measure for inference quality.

the module content for different module networks can be compared by computing for each module in one network how many genes of it are also grouped together in one module in the other network, and averaging over the number of modules. we call this the average module overlap.

go overrepresentation analysis
go enrichment p-values for all modules were determined using the bingo tool  <cit> , which was incorporated into the lemone package. the overrepresentation of go biological process categories was tested using hypergeometric tests and the resulting p-values were corrected for multiple testing using a false discovery rate correction.

software
the latest version of syntren can be downloaded from  <cit>  and the latest version of genomica from  <cit> . lemone is implemented in java and available for download in source or executable form  <cit> .

RESULTS
implementation differences in lemone versus genomica
as a starting point for the development of lemone, we re-implemented the methodology described by segal et al.  <cit> , which is incorporated in the genomica software package. briefly, genomica takes as input a gene expression data set and a list of potential regulators. after an initial clustering step, the algorithm iteratively constructs a regulatory program for each of the modules  in the form of a regression tree, and then reassigns each gene to the module whose program best predicts the gene's expression behavior. these two steps are repeated until convergence is reached. in this process, the algorithm attempts to maximize a bayesian score function that evaluates the model's fit to the data  <cit> .

we used the same overall strategy and the same bayesian score function in lemone. however, with respect to the original methods described by segal et al.  <cit> , lemone incorporates an alternative strategy for inferring regulatory programs that offers some advantages . first, lemone uses a bayesian hierarchical clustering strategy to learn the regulation trees for the modules from the bottom up instead of from the top down. furthermore, contrary to genomica  <cit> , the partitioning of expression data inside a module is not dependent on the expression profiles of the potential regulators, but only on the module data itself. this should allow the program to better handle missing or 'hidden' regulators . as an additional advantage, the assignment of regulators to regulation program nodes can be postponed until after the final convergence of the bayesian score, which leads to considerable time savings .

a second modification in lemone is that regulators are assigned to the splits in the regulation tree  based on an information theoretic measure, namely the conditional entropy of the partition of the regulator's expression profile dictated by the data split, given the partition imposed by a particular split value . as a consequence, a data split does not impose, but merely prefers, a clean partition of the best-matching regulator's expression values around a certain split value. in comparison with genomica, where only such clean partitions are used, this strategy has the advantage that potential noise in the regulator's expression is taken into account. additionally, the conditional entropy can be used to estimate the quality of the regulator assignment, and thus suggest missing potential regulators for splits without a low-entropy regulator. information theory has been used before to analyze and cluster gene expression data  <cit> . our method introduces elements of information theory into the module networks formalism.

in the following sections, we use syntren data to test lemone in a completely controlled situation in which simulated microarray data is analyzed for a known underlying regulatory network of reasonable size, and we assess the performance effects of the aforementioned methodological changes with respect to genomica  <cit> . the lemone package and the source code are freely available under the gpl license .

modularity
a fundamental assumption of the module networks formalism is that real biological networks have a modular structure  <cit>  that is reflected in the gene expression data, and therefore groups of genes can share the same parameters in the mathematical description of the network. in lemone, as in other module network learning programs  <cit> , the desired number of modules has to be given as an input parameter to the inference program, and a main question is how the optimal module number has to be determined.

fewer modules means lower computational cost and more data points per module. this results in a better estimation of parameters, but possibly entails oversimplifying the network and missing important regulatory relations. more modules means more specific optimization of the network at higher computational cost. when modules become too small, there could be too few data points per module for a reliable estimation of the parameters. in this section we use the bayesian score to estimate the optimal number of modules.

throughout this manuscript, we make use of a syntren-generated synthetic network encompassing  <dig> genes of which  <dig> act as regulators . unless otherwise stated, we use all  <dig> regulators in this network as potential regulators while inferring module networks. figure  <dig> shows the bayesian score, normalized by the number of genes times the number of experiments, for this network and different numbers of experiments. in all three panels, the score reaches a maximum. the top panel , which has a true maximum for the score, illustrates that the network inference problem is underdetermined for very small data sets. increasing the number of modules beyond the location of the maximum lowers the fit of the model to the data. for larger data sets , the score saturates and after a certain point the model does not improve anymore by increasing the number of modules. hence, the optimal number of modules should be situated around the point where the bayesian score starts to level off. for increasing number of experiments, the optimal number shifts to the right. this suggests that increasing amounts of data enable the algorithm to uncover smaller and more finetuned modules. however, the rightbound shift of the optimum becomes less pronounced for increasing number of experiments. this reflects the fact that only a limited number of modules are inherently present in the true network.

we define the number of modules in the true network as the number of gene sets having the same set of regulators . this number is  <dig> for the  <dig> gene synthetic network we consider here, among which there are  <dig> with at least  <dig> genes and  <dig> with at least  <dig> genes. the saturation behavior of the score curves for  <dig> and  <dig> experiments in figure  <dig> more or less reflects the modularity in the true network.

network inference performance
a more detailed analysis of network inference performance is obtained by comparing the set of regulator to gene edges in the true  network and in the inferred module network. we use standard measures such as recall, precision, and f-measure .

a similar saturation with increasing number of experiments is seen for the precision curves  and the f-measure curves . whereas the precision continues to increase with the number of modules, the f-measure saturates, but does so at a higher number of modules than the bayesian score. taking into account the modular composition of the true network , the bayesian score and the recall curves seem to generate better estimates of the optimal number of modules than the f-measure curves.

we also investigated whether the inferred regulation programs provide any information regarding the quality of the regulators. when analyzing real data, such information could be useful to prioritize regulators for experimental validation. a first property which we tried to relate to a regulator's quality is its hierarchical location in the regulation program. it seems that regulators deeper in the regulation tree become progressively less relevant. figure  <dig> illustrates this effect by showing separately the precisions for the roots of the regulation trees , the children of the roots , and the grandchildren  for data sets with  <dig>   <dig>  and  <dig> experiments. the precisions for the various regulatory levels remain within each others standard deviation across the tested range of experiments, but the precision clearly diminishes with increasing levels in the regulation program. for each data set and inferred module network we created an additional network where each module is assigned a random regulator set of the same size as in the inferred network. the precision for these random regulation programs is shown in the bottom most curves in figure  <dig>  for regulation levels beyond level  <dig>  the precisions fall in this region of random assignments and they add almost exclusively false positives . in general, we can say that the top regulators are far more likely to represent true regulatory interactions.

an additional layer of information is provided by the regulator assignment entropies. a low value of the entropy corresponds to a regulator matching well with a split in the expression pattern of the regulated module. hence we expect regulators with low entropy to have a higher probability to be true regulators. this is illustrated in figure  <dig>  for the data set with  <dig> experiments and  <dig> modules, the subnetwork generated by all regulators with an entropy lower than, e.g.,  <dig>  has precision  <dig> , almost twice as high as the precision of  <dig>  for the whole module network. for the subnetwork generated by the regulators at the roots of the regulation trees, the precision increases from  <dig>  to  <dig>  by introducing the same entropy cut-off. other data sets show similar behavior .

performance of lemone versus genomica
next, we compared the performance of lemone and genomica  <cit> . both programs heuristically search for an optimal module network and are therefore bound to end up at a  local maximum of the bayesian score. we simulated  <dig> different data sets with  <dig> experiments for the same  <dig> gene network as before and inferred a network with  <dig> modules . the average precisions are  <dig>  ±  <dig> , resp.  <dig>  ±  <dig> , and average recalls  <dig>  ±  <dig> , resp.  <dig>  ±  <dig> , for lemone, resp. genomica. the average f-measure is  <dig>  ±  <dig> , resp.  <dig>  ±  <dig> . the similarity in performance at the level of the whole module network, with a bias for higher precision in lemone and higher recall in genomica, is further seen in figure  <dig>  where we plot recall – precision pairs for both programs at different noise levels. for each of the plotted series, lower noise levels correspond to points in the upper right of the series plot, and higher noise levels to points in the bottom left, illustrating a general decrease in performance for more noisy data.

the average module overlap between the module networks generated by lemone and genomica is  <dig>  ±  <dig> . both programs, although featuring similar performance, attain a different local maximum of the bayesian score, and the differences in the corresponding module networks can be quite substantial. in general we can say that both module network inference programs suffer from a high number of false positive edges. when using lemone, false positives can to some extent be filtered out by looking only at the highest levels in the regulation tree . to see whether this is also the case for genomica, we calculated the recall and precision for the subnetworks generated by the top regulators alone .

the recall for these subnetworks is generally lower as they contain far fewer edges than the complete module network. for lemone this decrease in recall is compensated by a large increase in precision. for genomica the decrease in recall is bigger, with only a slight increase in precision. there is no analogue of the assignment entropy in genomica, so we cannot compare the gain in precision by imposing an entropy cut-off.

one of the major differences in lemone with respect to genomica is the fact that the regulatory tree structures learned by lemone are only dependent on the expression data inside the module, and not on the expression profiles of potential regulators. we hypothesized that this might allow lemone to better handle missing or hidden regulators, a situation which might for instance occur if the true regulator is missing from the list of potential regulators. in order to test this hypothesis, we simulated  <dig> different data sets with  <dig> experiments for the same  <dig> gene network and inferred module networks with  <dig> modules using both lemone and genomica. in each of the ten runs we randomly left out 20% of the potential regulators from the regulator list . the average f-measure of the resulting networks is  <dig>  ±  <dig>  for lemone, versus  <dig>  ±  <dig>  for genomica. compared to the results when taking into account all  <dig> potential regulators , the performance drop for lemone is clearly less pronounced  than for genomica , indicating that lemone is indeed better at handling missing regulators.

regarding the speed of lemone versus genomica, we can say that lemone is considerably faster for larger data sets. this is mainly due to the fact that in lemone the regulators need only be assigned to the regulation programs once, after the final convergence of the bayesian score. this saves a considerable amount of time on scanning possible split values and performing acyclicity checks at each iteration. roughly, lemone and genomica performed equally in terms of speed on the syntren data set containing  <dig> genes and  <dig> experiments. on a real data set with  <dig> experiments  <cit> , lemone was about twice as fast as genomica when limiting the number of genes to  <dig>  and ten times faster when considering the whole data set .

biological data
for real biological data sets the underlying regulatory network is generally not known  and hence it is difficult to assess the quality of an inferred network. this is one of the main reasons why microarray data simulators such as syntren have to be used to validate the methodology. however, given the fact that data simulators seldom capture all aspects of real biological systems, any results obtained on simulated data should be approached critically and, where possible, validated on biological data sets. here, we investigate to what extent module networks inferred from real expression data can be validated using structured biological information.

for s. cerevisiae, there is partial information on the underlying network structure in the form of chip-chip data and promoter motif data  <cit> , and more profusely in the form of go annotations  <cit> . we learned module networks for budding yeast from an expression compendium containing data for  <dig> genes under  <dig> different stress conditions  <cit>   using the same number of modules  and the same list of potential regulators as segal et al.  <cit> . we then calculated the f-measure between the resulting regulatory network and the chip-chip network of harbison et al.  <cit> , considering in the former network only regulators that were tested by chip-chip. in general, the resulting recall and precision values are substantially lower than for simulated data of the same size, namely  <dig> , resp  <dig> . when looking at individual modules, only  <dig> out of  <dig> regulatory programs feature at least one regulator that is to some extent confirmed by chip-chip data. in addition, we tried to relate the regulatory program of a module to the module's gene content in functional terms using go annotation. overall, only  <dig> out of  <dig> programs possess one or more regulators belonging to a yeast goslim biological process category that is overrepresented in the module . remarkably, only  <dig> of these  <dig> programs overlap with the  <dig> regulatory programs featuring overlap with the chip-chip data. this observation suggests that both data types can actually be used only to a limited extent to infer the quality of regulation programs. indeed, many factors limit the use of chip-chip and go data as 'gold standards'. both types of data are noisy and offer incomplete information. for example, harbison et al.  <cit>  mainly profiled transcription factor binding in rich medium conditions, whereas the gasch data set contains primarily stress conditions. the parts of the transcriptional network that are active under these conditions may substantially differ  <cit> . moreover, the expression profile of a transcription factor is often not directly related to the expression profile of its targets, for example due to post-translational regulation of transcription factor activity. as a consequence, indirect regulators such as upstream signal transducers may feature in the regulation programs instead of the direct regulators, i.e., the transcription factors  <cit> .

as for go, many regulators appear not to be annotated to the go biological process categories of their target genes. taking these factors into account, the limited overlap with the available chip-chip and go data does not necessarily reflect the quality of the inferred regulatory programs.

on the contrary, we established that the regulatory programs do in fact contain a considerable amount of relevant and potentially valuable information. indeed, by manually investigating individual modules in more detail, we could in many cases qualitatively relate the regulators to the module's gene content. for example, the module shown in figure  <dig> is enriched in a.o. genes involved in the main pathways of carbohydrate metabolism , energy derivation by oxidation of organic compounds  and alcohol biosynthesis . none of the  <dig> regulators of this module could be related to the module's gene content based on chip-chip or go information. however, based on their description in the saccharomyces genome database   <cit> , all  <dig> regulators could be linked to glucose sensing or the response to  starvation, processes that can arguably influence the expression of carbohydrate metabolism genes.

however, one must keep in mind that it remains impossible to infer complete and accurate regulatory networks from gene expression data alone. expression data only provides information on one regulatory level, namely the transcriptional level. information on translational regulation is lacking. the current expression-based module network algorithms  try to remedy this problem by including signal transducers in the list of potential regulators in addition to transcription factors, in the hope to capture some of this non-transcriptional regulation from the expression profiles of key signal transducers. however, this trick can only be expected to uncover a fraction of such non-transcriptional regulatory interactions, and moreover the direct targets of these regulatory interactions are not identified. a potential remedy for this shortcoming would be to include other types of data, such as data on protein expression levels and protein phosphorylation, in the module network learning framework. unfortunately, such data are not yet available on a large scale.

in summary, our results indicate that structured biological information such as chip-chip data or go can not  be used to measure the performance of module network algorithms in an automated way. this is a strong argument for using data simulators such as syntren for the purpose of developing, testing and improving such algorithms.

CONCLUSIONS
we developed a module network learning algorithm called lemone and tested its performance on simulated expression data sets generated by syntren  <cit> . we found that the bayesian score can be used to infer the optimal number of modules, and that the inference performance increases as a function of the number of simulated experiments but saturates well below  <dig> 

we also used syntren data to assess the effects of the methodological changes we made in lemone with respect to the original methods used in genomica  <cit> . overall, application of genomica and lemone to various simulated data sets gave comparable results, with a bias towards higher recall for genomica and higher precision for lemone. however, lemone offers some advantages over the original framework of segal et al.  <cit> , one of them being that the learning process is considerably faster. another advantage of lemone is the fact that the algorithm 'lets the data decide' when learning the regulatory tree structure. the partitioning of expression data inside a module is not dependent on the expression profiles of the potential regulators, but only on the module data itself. as a consequence, the assignment of 'bad' regulators  to 'good' module splits  might suggest missing or hidden regulators. this situation might occur if the true regulator is missing from the list of potential regulators, or if the expression of the targets cannot be related directly to the expression of the regulator, e.g., due to posttranslational regulation of the regulator's activity. we have also shown that filtering the module network by the location of regulators in the regulation program or by introducing an entropy cut-off improves the inference performance. when inferring regulatory programs from real data, these criteria may prove useful to prioritize regulators for experimental validation.

finally, we explored the extent to which module networks inferred from real expression data could be validated using structured biological information. for that purpose, we learned module networks from a microarray compendium of stress experiments on budding yeast  <cit> . we found that the resulting regulatory programs overlapped only marginally with the available chip-chip data and go information. however, more detailed manual analysis uncovered that the learned regulation programs are nevertheless biologically relevant, suggesting that an automated assessment of the performance of module network algorithms using structured biological information such as chip-chip data or go is ineffective. this underscores the importance of using data simulators such as syntren for the purpose of testing and improving module network learning algorithms.

authors' contributions
t.m. and s.m. designed the study, developed software, analyzed the data and wrote the paper. e.b. and a.j. designed the study, developed software and analyzed the data. y.s. designed the study and developed software. t.v.d.b. and k.v.l. developed software. p.v.r., m.k., k.m. and y.v.d.p. designed the study and supervised the project.

supplementary material
additional file 1
contains  <dig> additional figures for the precision and f-measure as a function of the number of modules and experiments, as well as more details about the bayesian score and about the algorithm for learning module regulation programs.

click here for file

 acknowledgements
we thank eran segal for explanation about the genomica algorithm, and gary bader and ruth isserlin for refactoring the bingo code which allowed its incorporation into lemone. t.m. and s.m. are postdoctoral fellows of the research foundation flanders , a.j. is supported by an early stage marie curie fellowship. this work is partially supported by: iwt projects: gbou-squad-20160; research council kuleuven: goa-ambiorics, coe ef/05/ <dig> symbiosys; fwo projects: g. <dig> , and g. <dig> .

this article has been published as part of bmc bioinformatics volume  <dig>  supplement  <dig>  2007: probabilistic modeling and machine learning in structural and systems biology. the full contents of the supplement are available online at .

figures and tables mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaacqwghbqydawgaawcbagaegimaadabeaakiabgucarmaaqadabagaemyyae2aasbaasqaaiabdugarbqabagccqwg4baedaahaawcbeqaaiabdugarjabgkhitiabigdaxaaakiabdwgalnaacaaaleqabagaeyoei0iaemieagnaei4la8iaegynaujaegimaajaegimaadaaaqaaiabdugarjabg2da9iabigdaxaqaaiabd6gaubqdcqghris5aaaa@461a@ with x the number of modules and n =  <dig> 
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaacqwghbqydawgaawcbagaegimaadabeaakiabgucarmaaqadabagaemyyae2aasbaasqaaiabdugarbqabagccqwg4baedaahaawcbeqaaiabdugarjabgkhitiabigdaxaaakiabdwgalnaacaaaleqabagaeyoei0iaemieagnaei4la8iaegynaujaegimaajaegimaadaaaqaaiabdugarjabg2da9iabigdaxaqaaiabd6gaubqdcqghris5aaaa@461a@ with x the number of modules and n =  <dig> 
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaacqwghbqydawgaawcbagaegimaadabeaakiabgucarmaaqadabagaemyyae2aasbaasqaaiabdugarbqabagccqwg4baedaahaawcbeqaaiabdugarjabgkhitiabigdaxaaakiabdwgalnaacaaaleqabagaeyoei0iaemieagnaei4la8iaegynaujaegimaajaegimaadaaaqaaiabdugarjabg2da9iabigdaxaqaaiabd6gaubqdcqghris5aaaa@461a@ with x the number of modules and n =  <dig> 
