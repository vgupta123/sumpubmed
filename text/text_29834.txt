BACKGROUND
our predictive understanding of cell signaling is limited, in part because it is difficult to fully capture in a conventional model, such as a system of coupled ordinary differential equations , the system-level dynamics of molecular interactions that mediate cell signaling  <cit> . a major reason is combinatorial complexity  <cit> , the potential for molecular interactions to generate a large number of chemically distinguishable molecular states and molecular complexes. one cause of combinatorial complexity is multisite phosphorylation  <cit> . another is multivalent binding, which can mediate polymerization-like reactions that produce a distribution of oligomers  <cit> . combinatorial complexity is an inherent feature of cell signaling, because a typical signaling protein contains multiple functional components  <cit> . these components can include a protein interaction domain, such as a src homology  <dig>  or sh <dig> domain  <cit> ; a catalytic domain, such as a protein tyrosine kinase   <cit> ; a linear motif  <cit> , such as a proline-rich sequence  recognized by sh <dig> domains or an immunoreceptor tyrosine-based activation or inhibition motif   <cit> ; and one or more sites of post-translational modification, with a multitude of modifications being possible  <cit> . prominent examples of post-translational modifications include serine, threonine and tyrosine  phosphorylation, which is governed by antagonistic activities of kinases and phosphatases  <cit> , and ubiquitination, which is mediated by e <dig> ubiquitin ligases and other proteins  <cit> .

combinatorial complexity limits the application of conventional modeling approaches such as odes, because specification of a conventional model requires that one be able to list the possible reactions in a system, or the equivalent  <cit> . to overcome this problem, a new modeling approach has been developed: rule-based modeling  <cit> . in this approach, a model is specified in terms of rules for molecular interactions, rather than in terms of a list of possible reactions. reactions are implied by rules, and these reactions can be found in principle and sometimes in practice  <cit> , but there is no need to enumerate the possible reactions in a system to formulate or simulate a model  <cit> . a variety of algorithms and software tools have been developed for simulating rule-based models, including tools that account for steric effects and diffusion  <cit> , and these tools have been applied to study various aspects of a number of cell signaling systems  <cit> . it is now possible to formulate and simulate models that account comprehensively for the large numbers of molecules and molecular interactions that typically comprise a cell signaling system, which raises the issue of how to annotate and visualize large-scale rule-based models.

visualization of the elements of a rule-based model is natural to some extent because rule-based modeling, at least in some realizations, is based on or can be interpreted as being based on an underlying graphical formalism  <cit> , which serves as the foundation for the bionetgen language   <cit> . this model-specification language is supported by anumber of softwaretools  <cit> . another model-specification languageiskappa  <cit> , which is closely related to bngl. in the bngl formalism, which is briefly summarized in this section and described in greater detail below, graphs are used to represent molecules, and graph-rewriting rules are used to represent molecular interactions.

in a rule-based model for a cell signaling system, the graphs of a model typically represent proteins, which are taken to be the building blocks of most chemical species in the system. these graphs can be visualized according to the conventions of faeder et al.  <cit> . a graph representing a protein includes a colored vertex for each functional component of the protein. the color represents the type of protein being represented by a graph, i.e., the protein name is essentially the color of the graph representing the protein. the vertices of graphs can be associated with variable attributes to represent so-called internal states of components. an internal state is an abstraction that is often useful for representing, for example, the phosphorylation status of an amino acid residue. in graphs for molecular complexes, edges are used to represent bonds between molecular components. thus, the composition and the connectivity of a molecular complex  are tracked explicitly in a bngl-encoded rule-based model.

in general, the graph-rewriting rules in a bngl-encoded model specify simple operations on graphs, which define the outcomes of molecular interactions: the addition of an edge to represent an association event, the removal of an edge to represent a dissociation event, or the change of a vertex attribute to represent an internal state change, such as a post-translational modification event. rules can also be specified for synthesis and degradation reactions  <cit> . two important features of a rule are the specification of a reaction center  and the specification of the molecular context in which a molecular interaction occurs, i.e., the necessary and sufficient conditions that must be satisfied for a reaction to occur. another feature of a rule is an associated rate law, which is used to characterize all reactions implied by the rule up to statistical factors, which are derived from the properties of reactants  <cit> . thus, a rule can be interpreted as providing a coarse-grained definition of a class of reactions that arises from a particular interaction, with each reaction implied by a rule involving a common transformation and rate law. the granularity of a rule is adjustable.

although the rule-based modeling framework described above is expressive and sufficiently rich to describe a wide array of molecular interactions involved in cell signaling, the graphs of this framework are not sufficiently expressive to provide a completely natural representation of the substructures of signaling proteins. as discussed in detail below, components of a protein can themselves contain components, and so on. yet, in the framework described above, the components of a protein, regardless of their structural relationships, are represented in the same way, as the colored vertices of a graph, with a shared color indicating joint membership in the set of components of a particular type of molecule. in other words, if a component and a subcomponent of this component are both included in a model, the structural relationship between the component and subcomponent is lost. this representational limitation may not prevent a modeler from specifying a model with desired properties, but it may prevent others from easily connecting the formal elements of the model to the underlying biology and easily interpreting the model as intended.

here, mainly to enable better annotation of rule-based models, we introduce the concept of using hierarchical graphs to represent molecules, such as proteins, for which there are structural relationships among component parts. we also present an algorithm and software, which we have called hnauty, for assigning canonical labels to hierarchical graphs. canonical labeling enables one to determine if two graphs are the same or different simply by comparing their labels. this task, which is essentially equivalent to the solution of a graph isomorphism problem, is a routine part of network generation, the process of enumerating the reactions implied by a set of rules. network generation, which is not always practical, is an essential ingredient in the generate-first and on-the-fly approaches to simulation of a rule-based model  <cit> . thus, this report not only lays groundwork for using hierarchical graphs to annotate rule-based models but also lays groundwork for making such graphs elements of executable models.

in the remainder of this section, we provide additional background on the graphical formalism underlying bngl, on the hierarchical substructures of proteins, and on graph isomorphism and nauty  <cit> , a software tool for canonical labeling of colored graphs. we then provide examples of how hierarchical graphs can be used to represent proteins more naturally than the graphs of the bngl formalism, and we present a simple extension of the method implemented in nauty that allows for canonical labeling of hierarchical graphs. finally, we present and evaluate our implementation of the extended canonical labeling tool, hnauty. the hnauty software is freely available; the source code is provided as additional files  <dig> and  <dig>  its functionality can also be accessed from within bionetgen  <cit> .

methods
graphical formalism underlying the bionetgen language
the model-specification language bngl has evolved over time and has been described in detail  <cit> . it is based on a graphical formalism described initially by faeder et al.  <cit>  and then more formally and in greater detail by blinov et al.  <cit> . the formalism includes various types of graphs, two of which are relevant for our purposes: the molecular entity graph and the chemical species graph. let us recall the basic definition of a graph. a graph is a pair  where v is a finite set  and ℰ is a collection of pairs of vertices. a simple graph is a graph in which there is at most one edge between any two vertices. if this condition does not hold and the graph has multiple edges between at least one pair of vertices, then the graph is a multi-graph. all graphs are assumed to be simple unless otherwise noted. if a graph is directed, then the edges are ordered pairs; otherwise they are unordered. a labeled graph is a graph g= together with a set of labels, l and a map lv:v→l. it is also possible to label the edges via a map lℰ:ℰ→l. in an attributed graph, some vertices, in addition to fixed labels, are associated with variable attributes, which are used in bngl to represent internal states of components.

we are now ready to introduce the two types of graphs in the bngl formalism that are of interest here. a molecular entity graph is a labeled graph together with a map that assigns to each vertex a list of possible attributes. a chemical species graph is derived from a molecular entity graph or a collection of connected molecular entity graphs such that all variable attributes take on specific values. thus, molecular entity graphs model the types of molecules in a reaction network and chemical species graphs model specific chemical species, which are composed of molecules. these two types of graphs can be encoded in a machine-readable form according to the conventions of bngl  <cit> . as should be apparent from the above definitions, in models specified using bngl, all components  of proteins  are considered structurally equivalent . thus, the graphs of bngl can potentially obscure the structural relationships among the component parts of a protein.

two examples of proteins with hierarchical substructures
here, we discuss two examples of proteins with hierarchical substructures , meaning that functional components in these proteins have subcomponents.

graph isomorphism
graphs that are essentially the same are called isomorphic . as described elsewhere  <cit> , to generate a reaction network from a set of rules, bionetgen  <cit>  must determine, upon generation of a chemical species graph, if the graph has already been generated, i.e., if it is already part of the reaction network. if the graph does not already exist in the network, it is added to the reaction network. specifically, upon generation of a chemical species graph, the newly generated graph must be checked for isomorphism with every other existing chemical species graph in the reaction network. to reduce the time necessary for this procedure, bionetgen assigns to each chemical species graph a canonical label , or for computational efficiency, a pseudo canonical label, which is not guaranteed to be unique but often is in practice. here, we will only be concerned with true canonical labels, but in the case of either a canonical or pseudo canonical labeling algorithm, the algorithm must be called only once for each chemical species graph representing a newly generated reaction product. an algorithm assigning canonical labels can thus be used to determine graph isomorphism efficiently, as string comparisons are much more efficient than graph comparisons. in practice, if there are a large number of graphs that need to be compared to one another, it is efficient to assign canonical labels using an algorithm such as nauty  <cit>  to each graph and then to compare the graphs using their labels.

although hierarchical graphs are currently only proposed here for annotation purposes, such graphs could in principle be incorporated into models as formal elements. to enable the incorporation of hierarchical graphs into executable models, we describe a generalization of the nauty algorithm  <cit> , which takes as input hierarchical graphs and assigns them canonical labels.

RESULTS
hierarchical graphs for annotating rule-based models
definitions
we give exact definitions of hierarchical graphs before discussing how hierarchical graphs can be used to represent particular proteins with hierarchical substructures.

a hierarchical graph is a graph g= together with an acyclic parent function p:v→v. the parent function defines the hierarchy; the parent of a vertex is the next level up in the hierarchy. while the function p must be acyclic we do allow vertices to be their own parents; the assignment p = v is permissible . it is common to represent the hierarchy as a directed tree . a labeled hierarchical graph is a hierarchical graph with a labeling of the vertices  as above. although many proteins do indeed have a hierarchical substructure, the above definition may be too strict in some cases. an example of such a case is provided by overlapping linear motifs , because amino acid residues in the region of overlap cannot be considered to have a unique parent in a hierarchical graph. we will call such hierarchies pseudo-hierarchies and define a pseudo-hierarchical graph to be a directed acyclic graph. although individual nodes in pseudo-hierarchical graphs may not have a unique parent, the acyclicity of the hierarchy ensures there is still a "top-down" structure to the graph.

in models, we will want to essentially use both hierarchical  graphs and the conventional flat graphs of bngl at the same time: the first type of graph to show the structural relationships between molecular components and the second type of graph to show bonds between molecular components. thus, we will use graphs with two edge types, the first type will represent the hierarchy and will be directed, the second type will represent bonds and will be undirected.

the vertices of the graphs in bngl are not only labeled but are also attributed. this means, for example, that a vertex that represents a site of phosphorylation on a protein may either have the attribute "phosphorylated" or the attribute "not phosphorylated." technically, the label of a vertex stays the same, whereas an attribute of a vertex can change. this concept of variable attributes or internal states reflects an understanding that a protein is essentially the same molecule whether or not one of its amino acid residues is phosphorylated. formally, each vertex is assigned a list of possible attributes and then each vertex is assigned an attribute from the corresponding list. in bngl, labels cannot change during a simulation of a model; attributes can. hierarchical graphs can be attributed in the same manner.

hierarchical graph representation of lck
recall our earlier discussion of the hierarchical substructure of lck . a bngl-compliant molecular entity graph representation of lck is shown in figure 2a. this graph, which is drawn according to the conventions of faeder et al.  <cit> , includes the sh <dig> and sh <dig> domains of lck and three tyrosine residues that can each be either phosphorylated  or unphosphorylated : y <dig>  y <dig> and y <dig>  as discussed previously, phosphorylation of these residues regulates the binding and catalytic properties of the protein. note that the ptk domain of lck is not included in this graph. the reason is that, although enzyme-catalyzed reactions can be represented in bngl-encoded rules, explicit representation of catalytic domains is often dispensable for model specification and simulation. as a result, proteins are often represented without their catalytic domains for simplicity, as shown in figure 2a. briefly, other features of figure 2a are as follows. nodes are colored: they share the color "lck." to avoid actual use of color, the nodes are surrounded by a box. tildes proceed the possible states of a component; here, tyrosine residues may be phosphorylated  or unphosphorylated .

in figure 2b, a hierarchical graph representation of lck that corresponds to figure 2a is shown. the directed edges in figure 2b represent containing or ownership relations. in figure 2b, the ptk domain of lck is explicitly represented, so that membership of y <dig> in the ptk domain of lck is clear. similarly, one can see that y <dig> is part of the sh <dig> domain of lck. in this graph, possible internal states are indicated in boxes attached to the bottoms of component boxes, which is consistent with the conventions of hu et al.  <cit> .

a chemical species graph is a complete specification of a molecule or a molecular complex, including internal states. figure 2c shows a chemical species graph for free lck in which y <dig> and y <dig> are unphosphorylated  and y <dig> is phosphorylated . the hierarchical graph representing this chemical species suggests to a reader that intramolecular binding between the sh <dig> domain and phosphorylated y <dig> may affect the kinase activity of lck, because the kinase domain is located between the sh <dig> domain and y <dig> in the layout of the graph, which is consistent with ordering of components from the n-to the c-terminus of the polypeptide chain.

both of the hierarchical representations shown in figure  <dig>  capture the essential information of the protein sequence illustrated in figure 1a: the internal relationships among the domains and residues of lck. it differs from a non-hierarchical bngl-encoded representation of the molecule, such as lck, which tells us nothing about how the tyrosine residues relate to the domains. in contrast, in the hierarchical representation, one can see that y <dig> is inside the sh <dig> domain. one can also see that y <dig> is a tyrosine residue located at the c-terminus of the kinase domain, although this feature derives from the layout of the graph.

hierarchical graph representation of the tcr complex
to represent a multimeric protein like the tcr complex, we can represent each of its constituent polypeptide chains as a hierarchical graph, as demonstrated above for lck. the hierarchical graphs for the individual polypeptide chains can then be assembled into a larger hierarchical graph of the complex, as demonstrated in figure  <dig>  the root node of this graph indicates that the name of this molecular complex is tcr. nodes in the next layer show the names of the constituent subunits, which are homodimers and heterodimers. in the third layer, each node represents a single polypeptide chain that is part of a dimer in the second layer. the fourth layer lists the linear motifs in those polypeptides and the fifth layer lists amino acid residues that belong to the linear motifs in the fourth layer. thus, complexes can be represented by hierarchical graphs. from this hierarchical graph it is obvious that y <dig> appears in both the prs and itam of cd3ϵ. thus, it can be inferred that interactions involving y <dig>  the itam, and the prs may regulate one another. this is in fact the case, as discussed earlier.

algorithm for canonically labeling hierarchical graphs
above, we proposed that models of signal transduction networks should make use of graphs with two types of edges; one expressing the structural hierarchy of molecular components, the other the  bonds between components. thus, the edges of these graphs will be labeled either "hierarchy" or "bond." it is important to be able to use hierarchical graphs not just for improved annotation but also to incorporate them into executable models in the future. there are two methods to incorporate hierarchical graphs  into a computational setting. the first is to "flatten" the graph by removing the labels of all the edges, so that there is only one edge type. this simplification can be accomplished without losing the information contained in the edge labels. for each edge, we can insert a new vertex into the graph, labeled to indicate that edge's type. in particular, for an edge e of type l connecting the vertices x and y, we can delete e from the graph and insert a new vertex v. we can give v the label l and connect it to both x and y. performing this step for every edge in the original graph produces a bipartite graph with one edge type. although no information is lost using this method, it is visually inelegant and obscures the model .

another method which preserves the clarity of the original model is to simply keep the original edge types. to make the model executable, we can assign distinct values to each edge type from  <dig> to m, where m is the number of distinct edge types. then the graph can be represented by the following sort of adjacency matrix. set the ijth entry of the adjacency matrix to be ∑2e taken over edges with type e between vertices i and j. note that a non-directional edge e between vertices i and j will contribute to both the ijth entry and the jith entry, whereas a directed edge e from i to j  will only contribute to the ijth entry of the adjacency matrix. a graph can be reconstructed from such an adjacency matrix under the assumption that the graph does not contain multiple edges  of the same edge type. for biological models, the restriction to such graphs is natural. because our main motivation for using hierarchical graphs to model biochemical networks is to improve the clarity of models, we recommend this second method.

for instance, consider the chemical species graph of lck with sh <dig> connected to phosphorylated y <dig> . let the hierarchy edges be edge type  <dig> and the bond edges be edge type  <dig>  then in the adjacency matrix, a hierarchical edge from i to j will be represented by a  <dig> =  <dig> in the ijth entry, whereas a bond edge between vertices i and j will be represented by a  <dig> =  <dig> in both the ijth and the jith entries. the adjacency matrix  is given in table  <dig> 

the numerical entries in this table comprise a  <dig> ×  <dig> matrix.

as can be seen from the first row of the matrix in table  <dig>  lck contains sh <dig>  sh <dig>  y <dig> and ptk components. likewise, from the third and fourth rows, one can see that the sh <dig> component contains a y <dig> subcomponent and the ptk component contains a y <dig> subcomponent. from the pair of "2" entries, one can see that there is a bond between the sh <dig> and y <dig> components.

an important capability of bionetgen is the ability to distinguish between different graphs and to recognize isomorphic graphs  <cit> . we describe a slight generalization of the nauty algorithm which can canonically label graphs with several edge types. this algorithm, hnauty, has been incorporated into bionetgen  <cit> . although our algorithm is only slightly different from the one described by mckay  <cit> , we provide a brief description of the whole algorithm for clarity.

although the representation of graphs within computing systems can vary, it is useful to think of a graph as being represented by an adjacency matrix for the graph. however, the same graph can have several different adjacency matrices associated with it; different permutations  of the vertices may correspond to different adjacency matrices. if a graph is represented by an adjacency matrix, the problem of finding a canonical label for a graph is thus nothing more than picking a canonical adjacency matrix for each graph, that is a canonical permutation of the vertices. this can be done by brute force; there are n! permutations of the vertices of a graph with n vertices. each permutation corresponds to a possibly unique adjacency matrix. the adjacency matrices can be linearly ordered by considering each matrix as a binary string of length n <dig>  the first  such string can then be chosen as the canonical label  for the given graph. the problem with this method is that it involves producing and sorting n! strings.

comparing graphs: graph isomorphism and graph automorphism
graph isomorphism is closely related to graph automorphism; both play an important role in the nauty algorithm. we will define and briefly explain both concepts. two graphs g and h are isomorphic if there is a bijection ϕ  between the vertex sets of the two graphs such that  is an edge of g if and only if , ϕ ) is an edge of h. it is convenient to associate each isomorphism of a graph g to a permutation of the vertices of g; a graph with n vertices has n! isomorphic copies. a permutation π, of the vertices, is an automorphism of the graph g if each pair of vertices  is an edge of g if and only if the pair , π) is also an edge of g. the automorphisms of the graph are a formal description of the symmetries of the graph. for instance, two vertices are symmetric in the graph if there exists an automorphism which maps one vertex to the other. these concepts are illustrated in figure  <dig>  the second and third graphs are isomorphic copies of the first. however, the second is not generated by an automorphism of the first whereas the third is.

let us exam the graphs in figure  <dig> more carefully. the permutation, π <dig>  generating g <dig> from g <dig> is defined as follows: π <dig> = v <dig>  π <dig> = v <dig>  π <dig> = v <dig> and π <dig> = v <dig>  the permutation, π <dig>  generating g <dig> from g <dig> is defined as follows: π <dig> = v <dig>  π <dig> = v <dig>  π <dig> = v <dig> and π <dig> = v <dig>  note that π <dig> satisfies the definition of an automorphism of the graph g <dig> whereas π <dig> does not. the set of those permutations of the vertices that are automorphisms of a graph g is called the automorphism group of the graph g. the size of the automorphism group of a graph is a measure of the amount of symmetry in the graph. as will become clear later, it is often more difficult to find canonical labels for graphs that are highly symmetric  than for graphs with small automorphism groups.

determining graph isomorphism
a common element of methods for both assigning canonical labels and determining graph isomorphism is the individualization and refinement procedure  <cit> . the nauty algorithm also uses this procedure which is outlined below. the procedure involves partitions; a partition p of a set s, is a collection of non-empty pairwise disjoint subsets {si} of s whose union is s. the sets si are referred to as the cells of the partition. an ordered partition is formed by ordering the cells of a partition. in other words, the ordered k-tuple  is an ordered partition of s if the sets si form a partition of s. unless otherwise specified, in what follows, we will always use "partition" to refer to an ordered partition. the length of a partition is the number of cells in the partition. a partition is discrete if its length is equal to the size of the set s and trivial if it has only a single cell. a discrete partition of the vertex set of a graph is an ordering of the vertices and thus equivalent to a permutation of the vertex set. as the canonical labeling problem is equivalent to finding a canonical permutation of the vertices of a graph, it is also equivalent to finding a canonical discrete partition of the vertex set.

the individualization and refinement procedure relies heavily on so-called equitable partitions. an equitable partition is a partition p =  of the vertices of a graph g such that:

  ∀i,j∈{ <dig> ...,k} x,y∈si⇒d=d 

where d is the number of edges connecting the vertex x to elements of the cell sj . similarly, d is the number of edges connecting the vertex y to elements of the cell sj. thus, if every vertex in a graph has fixed degree k, then the trivial partition of the vertex set p =  is equitable. note also that for any graph, every discrete partition is equitable.

there is a natural partial order on the collection of partitions of a given set s. given two partitions p and q of the same set, we say p is finer than q, q is coarser than p, and p is a refinement of q  if each pi is a subset of some qj. in addition, for ordered partitions, we require p <dig> ⊆ q <dig>  and ∀i : pi ⊆ qj ⇒ pi+ <dig> ⊆ qk where k is either j or j + <dig>  for example, the partition  is a refinement of the partition .

as every discrete partition of a vertex set is equitable, it can be shown that every partition p of a vertex set has a unique coarsest refinement that is equitable  <cit> . this fact underpins the individualization and refinement approach. we refer to the unique coarsest refinements as equitable refinements. consider the equitable refinements of the trivial partitions of the vertex sets of two graphs, written as p =  and q = . if the graphs are isomorphic, these partitions will have the same shape, meaning that for each i, |pi| = |qi|. 

for example, let g <dig> be a graph with five vertices: v <dig> ..., v <dig> with edges between vi and vj if i - j ≡  <dig> modulo  <dig>  let g <dig> also be a graph with vertices v <dig> ..., v <dig> but with the edges {vi, vi+1}  so that we get a  <dig> cycle, together with an edge connecting v <dig> and v <dig>  see figure  <dig>  both graphs consist of five vertices; two of which have degree  <dig> and three of which have degree  <dig>   thus, by only looking at the degrees of the vertices of these two graphs, we cannot distinguish them. on the other hand, the graphs can be distinguished by finding the equitable partition of the vertex set for each graph. the unique coarsest equitable partition for g <dig> is . each vertex in the first cell is connected to three vertices in the second cell, and none in the first while each vertex in the second cell is connected to two vertices in the first cell and none in the second. on the other hand, the unique coarsest equitable partition for g <dig> is . here, each vertex in the first cell is connected to exactly one vertex from each of the three cells. the vertex in the second cell is connected to two from the first cell and zero from the third. as these two equitable partitions have different shapes, g <dig> and g <dig> cannot be isomorphic.

in general, equitable partitions are insufficient to distinguish between non-isomorphic graphs and therefore insufficient to determine canonical labels for graphs. they must be used together with individualization, which can be described as follows. suppose the partition p is not discrete; then let c be the first cell of p with more than one element. pick an element x in c and consider the partition p' formed by replacing the cell c with the two cells c\{x} and {x}. p' is a refinement of p, but it is not necessarily equitable. thus, it is necessary to find the equitable refinement of p'. continuing in this manner, it is possible to individualize and find further equitable refinements until a discrete partition is reached. as the individualized vertices were chosen at random, the procedure must be repeated for each possible choice of vertices. in this way, several discrete partitions are produced; this is the individualization and refinement procedure used in many canonical labeling algorithms including nauty. to finish, the algorithm must select a canonical discrete partition from among those produced by the individualization and refinement procedure.

if a graph has a small automorphism group then the individualization and refinement procedure will produce only a few discrete partitions; in this case it will be relatively easy to select a canonical label. conversely, if the automorphism group is large, the procedure will produce many discrete partitions, and it will take more effort to select a canonical label. for example, if a graph is completely symmetric then each permutation of the vertices gives an automorphism of the graph. in this case, every partition of the graph is equitable and the individualization and refinement procedure will produce each of the n! possible discrete partitions of the vertex set. recall the graphs g <dig> and g <dig> considered above. the automorphism group of g <dig> has size  <dig> whereas the automorphism group of g <dig> has size  <dig>  thus, the individualization and refinement procedure produces the following two discrete partitions for g2:  and . on the other hand, the six discrete partitions produced for g <dig> correspond to those permutations of the vertices where both v <dig> and v <dig> come before the three other vertices v <dig>  v <dig>  and v <dig> 

at this point it is common to use a brute-force method for finding a canonical partition from among those generated by the individualization and refinement procedure. each generated partition p of the vertices corresponds to a permutation π of the vertices. applying this permutation to the vertices of the graph, we get a new adjacency matrix a for the graph. if there are n vertices in the graph, then a is an n × n array of 0's and 1's. in fact, a can be considered to be a binary string of length n <dig>  comparing these strings as binary numbers, the smallest is selected and the corresponding partition is ordained the canonical label.

in general, the individualization and refinement procedure produces significantly less than n! partitions to be compared as binary strings. this efficiency is achieved because most graphs have small automorphism groups  <cit> . however, the method fails to significantly reduce the number of partitions that must be compared if the graph has a large automorphism group. for instance, a graph with n vertices containing every possible edge connecting these vertices has a full automorphism group, meaning that every permutation of the vertices is an automorphism. for this graph, and similarly for a graph containing no edges, the individualization and refinement procedure will completely fail to reduce the number of partitions to be compared; every discrete ordered partition will be generated by the procedure.

the nauty algorithm
for highly symmetric graphs, the nauty algorithm  <cit>  implements a fairly effective strategy to speed up the time taken to find a canonical label. it makes use of the automorphisms of a graph to further reduce the number of partitions produced by the individualization and refinement procedure. we will now give a brief overview of the search tree used in nauty to explain how nauty takes advantage of knowledge of automorphisms of a graph.

nauty takes as input a colored  graph; the coloring is taken to define a starting partition of the vertices. nauty then builds a rooted search tree by computing successive equitable refinements of the initial partition given by the coloring. elements of the search tree are called nodes so as not to confuse them with the vertices of the graph. the root of the search tree is the equitable refinement of the initial  coloring. branches are formed by individualizing vertices and finding successive equitable refinements after each individualization step. each movement down the search tree corresponds to individualizing an appropriate vertex and finding the equitable refinement of the resulting partition. thus, each node at distance k from the root of the search tree can be represented by an ordered k-tuple of vertices, with the ordering corresponding to the order of vertex individualization. the leaves of the search tree  correspond to discrete partitions. thus, each terminal node has a natural association with a permutation of the vertices of the graph.

the key idea is that automorphisms of the graph correspond to similar leaves in the search tree. to be more precise, we say that two permutations, π <dig> and π <dig>  of the vertices of the graph are equivalent if there is an automorphism of the graph, γ such that π <dig> = π <dig> * γ  then as γ is a permutation of the vertices, it can also be considered a permutation of the nodes of the search tree.  it can be shown that if ν is a node of the search tree, then νγ  will be as well. in fact, much more is true: the two sets of leaves of the search tree derived from the two nodes ν and νγ , respectively, will be equivalent to each other. in other words, the two sets of respective permutations will be equivalent  <cit> . thus, if γ is an automorphism of the graph, it is enough to produce all the terminal nodes stemming from a given node ν in the search tree, and we can ignore the terminal nodes stemming from νγ. in this way, knowledge of automorphisms can be used to eliminate the need to examine  parts of the search tree.

nauty discovers automorphisms in the following way. the algorithm is based on depth first search; it immediately starts generating terminal nodes. upon producing a terminal node, nauty applies the corresponding permutation to the original graph and then calculates the resulting adjacency matrix. two adjacency matrices produced in this way are equal if and only if the corresponding two permutations, π <dig> and π <dig>  are equivalent. in this case, there exists an automorphism γ of the graph such that π <dig> = π <dig> * γ. the nauty algorithm then calculates γ by evaluating π2−1*π <dig>  as such automorphisms are discovered, nauty can prune the size of the search tree as detailed above.

nauty also uses an indicator function to further prune the search tree. an indicator function is a map defined on the nodes of the search tree that is invariant under automorphisms of the graph. this function maps the nodes into a linearly ordered set  then nauty skips over nodes of the search tree where the indicator function is not minimal. as the indicator function is invariant under automorphisms of the graph, a canonical label will be found among those terminal nodes of minimal indicator function value.

hnauty
here we describe hnauty and explain how hnauty differs from mckay's description of nauty  <cit> . one difference is that, as hnauty allows for several different edge types, the adjacency matrices associated with the graphs in hnauty may contain not only 0's and 1's for entries but can have entries of the form ∑2i where i is taken over those edges of type i between the two given vertices. for a graph with two edge types , the entries in the adjacency matrix can be  <dig>   <dig>  22- <dig> =  <dig> =  <dig> or 1+ <dig> =  <dig>  a value of "3" should be interpreted to mean that there is both a hierarchy edge and a bond edge between two vertices.

another difference lies in how equitable partitions are calculated. we define a slight generalization to deal with labeled edges. a generalized equitable partition is an ordered partition p =  of the vertices of a labeled multi-graph such that for any edge label e, the graph restricted to the edges labeled e , denoted g|e, satisfies:

  ∀i,j∈{ <dig> ...,k} x,y∈ vi⇒d=d 

where d is the number of edges labeled e between x and si. in other words, the partition is equitable with respect to the graph restricted to any single edge type. it can be proved that, given a partition p, there exists a unique coarsest generalized equitable refinement of p. to see this, note that it is enough to prove it for un-ordered partitions.  now, suppose that q <dig> and q <dig> are both generalized equitable refinements of p. if q <dig> and q <dig> are different as un-ordered partitions, then clearly their join, q  is also generalized and equitable. in fact, a basic property of lattices implies that q is also a refinement of p. as q is coarser than both q <dig> and q <dig>  it follows that p has a unique coarsest generalized equitable refinement. this property is the only property of generalized equitable partitions that is necessary to use them in place of equitable partitions.

implementation
except for using generalized equitable partitions in place of equitable partitions, our implementation follows the description given by mckay  <cit> . apparently, the actual nauty program  <cit>  contains some efficiencies not described in  <cit> . thus, our algorithm is unlikely to be as finely tuned as nauty. for an indicator function, we use the shape of the partition together with the shapes of the parent nodes in the search tree. by shape we mean the sizes of the individual cells of the partition. the partition  has shape  as it has two cells of size  <dig>  one cell of size  <dig>  no cells of size  <dig> and one cell of size  <dig>  these tuples are lexicographically ordered. this indicator function is invariant under automorphisms of the graph as required. indeed it is invariant under any permutation of the vertices.

we implemented our algorithm in both perl and python. the perl version of hnauty is available as additional file  <dig>  the python version of hnauty is available as additional file  <dig>  hnauty is also available at the bionetgen website  <cit> . the perl version has been incorporated into bionetgen  <cit> . hnauty is turned off by default in bionetgen. it can be turned on with the command "setoption;" at the beginning of a bionetgen input file. the default for bionetgen is to calculate pseudo-canonical labels that do not distinguish all isomorphic graphs but are much faster to generate than hnauty. then any two graphs which share pseudo-canonical labels are checked for isomorphism using ullmann's algorithm  <cit> . the generation of pseudo-canonical labels followed by applying ullmann's algorithm to graphs with the same label always produces correct results, though it can be much slower than hnauty if a chemical species graph is composed of many isomorphic subgraphs. the hnauty code can be run as stand-alone code separate from bionetgen. the python version of hnauty uses the graph structures defined in the freely available package networkx  <cit> . the perl version of hnauty takes as input the graph adjacency matrix together with an initial partition of the vertices of a graph. the adjacency matrix should be in the form of a dictionary of dictionaries. the keys of the first dictionary are the vertices of a graph. each vertex i points to a second dictionary whose keys are the neighbors of vertex i in the graph. in this second dictionary, a vertex j points to an array containing the edge types between vertices i and j.  the initial partition of the vertices should be given in the form of an array of arrays, each of the smaller arrays being a set in the partition. hnauty returns as output a permutation of the vertices of the input graph. permuting the input graph under this permutation gives the canonical label of the graph .

testing
both the python and perl versions of hnauty were extensively checked using a database of isomorphic graphs  <cit> . the perl version was further checked against randomly generated graphs with two types of edge: directed and undirected. these graphs were generated using the erdős-rényi model for random graphs; the edges were chosen independently with uniform probability. edges were selected to be undirected with probability  <dig>  and directed with probability  <dig> . with probability  <dig>  an edge was not in the graph. one thousand graphs, each on two hundred nodes, were produced in this way. each was given as input to hnauty and then a random permutation of the vertices was applied to each graph; the result was also given as input to hnauty. a test was successful if the two isomorphic inputs resulted in the same canonical label. all of the tests were successful.

discussion
in the section above, we discussed the significance of our results as the results were presented. thus, this section will be brief. hierarchical graphs can be powerful visual aids in understanding complex molecular structures. for rule-based models of cell signaling systems, hierarchical graphs provide more natural representations of proteins than the regular flat graphs of bngl or kappa and thus promote clarity in building and annotating models. regular flat graphs can obscure the structural properties of molecules and molecular complexes. as shown above, hierarchical graphs can be used in a formal manner to model cell signaling systems. in addition, they can be incorporated into executable models in place of regular graphs. as an example, we have developed a version of the popular nauty code which can take as input hierarchical graphs . this is important because, as noted above, determining graph isomorphism can take a significant amount of computation time in network generation. as detailed above, hnauty differs only slightly from the main outline of nauty given by mckay  <cit> . indeed, the formalism distinguishing graphs and hierarchical graphs  is also slight. thus, we propose that the use of hierarchical graphs may, at little cost, allow for greater clarity of rule-based models for biochemical systems.

CONCLUSIONS
the graphs and algorithm introduced here lay the groundwork for rule-based models that are easier to understand, because molecules with complicated substructures can be more naturally represented.

abbreviations
bngl: bionetgen language; prs: proline-rich sequence; ptk: protein tyrosine kinase.

authors' contributions
nwl formulated, implemented and tested the hnauty algorithm. bh and wsh conceived the idea of using hierarchical graphs for annotating rule-based models and provided examples of proteins with hierarchical substructures. wsh planned the project. nwl, bh and wsh wrote the manuscript. all authors have read and approved the final version of the manuscript.

supplementary material
additional file 1
the hnauty source code written in perl.

click here for file

 additional file 2
the hnauty source code written in python.

click here for file

 acknowledgements
this work was supported by national institutes of health  grants gm <dig>  gm <dig> and us department of energy  contract de-ac52-06na <dig>  nwl thanks the center for nonlinear studies for funding that made visits to los alamos possible. the authors thank lily a. chylek, james r. faeder  and pieter swart for helpful discussions. we also thank jrf for incorporating hnauty into bionetgen.
