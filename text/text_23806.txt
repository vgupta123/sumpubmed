BACKGROUND
bicliques have a long history of applications. the enumeration of maximal bicliques can be traced at least as far back as the seminal work reported in
 <cit> . there the problem was defined in terms of rectangles, binary relations and concept lattices. subsequent progress on concept lattices was surveyed in
 <cit> . algorithms for their identification were applied to the analysis of gene co-expression data in
 <cit> .

a variety of biological challenges can be addressed by finding maximal bicliques in bipartite graphs. representative applications include biclustering microarray data
 <cit> , optimizing phylogenetic tree reconstruction
 <cit> , identifying common gene-set associations
 <cit> , integrating diverse functional genomics data
 <cit> , analyzing proteome-transcriptome relationships
 <cit> , and discovering patterns in epidemiological research
 <cit> . statistical approaches have been applied to some of these problems, but in many cases a discrete approach is beneficial or required because of the structure and diversity of the data under study.

let us describe a few specific examples. bicliques have been used in the analysis of gene expression data to represent subsets of genes and subsets of conditions, each pair with a high similarity score
 <cit> . graph theoretical approaches have been proposed in this setting to find bicliques in the resultant bipartite graphs that model genes and conditions with vertices, and co-expression levels with edge weights
 <cit> . bicliques have been used in phylogenetics to improve the accuracy of tree reconstruction
 <cit> . such a tree denotes evolutionary relationships among species thought to have a common ancestor. data with no fewer than k genes sampled from no fewer than m species are extracted from sequence databases. this operation is equivalent to finding maximal bicliques with partition sizes at least k and m. bicliques have been used in epidemiological research to identify sets of individuals who share common sets of features. bipartite graphs can help capture relationships between organisms and a wide range of factors. maximal bicliques are particularly useful in case-control studies involving categorical features such as genotypes and exposures
 <cit> .

our work has been largely motivated by the computational demands of systems like geneweaver
 <cit> , a web-based software platform for the integration of functional genomics data. geneweaver includes a database containing lists of genes from diverse sources, along with descriptive metadata associated with these lists. through gene homology, the lists can be combined across species such that genes on the lists are translated to a common reference. this enables the construction of a bipartite graph, with vertex partitions representing individual genes versus the gene lists. a suite of tools built on the enumeration of maximal bicliques and other bipartite analyses allows the user to identify groups of genes that are associated with related biological functions, all without any prior knowledge or assumption about such group associations. efficiency and scalability are paramount, because real-time maximal biclique enumeration is required for web-based user-driven analyses, as well as for effective computations over the entire data repository.

problem
in each of the aforementioned applications involving an integration of multiple sets of genome-scale data, bipartite graphs can be used to represent relationships across pairs of heterogeneous data types. an interpretation of such a relationship is accomplished through an enumeration of maximal bicliques. let us be precise about what this means. a bipartite graph is one whose vertices can be partitioned into a pair of non-empty, disjoint partitions such that no two vertices within the same partition are connected by an edge. let g denote a bipartite graph, let u and v denote its two vertex partitions, and let e denote its edge set. a biclique in such a graph is a complete bipartite subgraph, that is, a bipartite subgraph containing all permissible edges. the notion is formalized as follows:


definition  <dig>  let g =  denote a bipartite graph. a biclique c =  is a subgraph of g induced by a pair of two disjoint subsets u′ ⊆ u,v′ ⊆ v, such that ∀ u ∈ u′,v ∈ v′,  ∈ e.

a maximum biclique is a largest biclique in a graph. unlike the well-known maximum clique problem, there are two distinct variants of the maximum biclique problem: the vertex maximum biclique problem and the edge maximum biclique problem. the former asks that we find a biclique with the largest number of vertices, and can be solved in polynomial time
 <cit> . the latter asks that we find a biclique with the largest number of edges, and is
-complete
 <cit> . in biological applications, the edge maximum biclique is often desirable because it models more balanced connectivity between the two vertex classes. for example, an edge maximum biclique may group together numerous related biological processes and a modest set of their common genes, whereas a vertex maximum biclique may instead group together only a tiny set of related biological processes with great numbers of common genes.

a maximal biclique is one not contained in any larger biclique. examples of maximum and maximal bicliques are shown in figure
 <dig>  the enumeration version of our problem is to find all maximal bicliques in a bipartite graph. in so doing, it turns out that we actually generate both edge maximum and vertex maximum bicliques. thus, we are chiefly concerned with this enumeration problem, formalized as follows: 

input : a bipartite graph g = .

output: all maximal bicliques, or subsets u′ of u and v′ of v, for which the induced subgraph g is complete, and there are no subsets u′′ ⊇ u′ and
v′′⊋v′, or
u′′⊋u′ and v′′⊇v′, such that g is also complete.

as observed in
 <cit> , the maximal biclique enumeration problem cannot be solved in polynomial time since the number of maximal bicliques may be exponential in the graph size. nevertheless, there remains a demand for efficiency, because we often need exact solutions to large-scale instances in real time. the maximal biclique enumeration algorithm  that we will define here finds all maximal bicliques. it exploits structure inherent in bipartite graphs. it employs a branch-and-bound technique to prune non-maximal candidates from the search tree. its pruning is accelerated by directly removing dominated vertices from the candidate set. our experimental results demonstrate that the resultant reduction in search space enables mbea to scale to the tens of thousands of nodes currently encountered in analyzing large biological data sets. in addition, we created an improved version, imbea, that selects candidate vertices in the order of common neighborhood size and that uses an enhanced version of branch pruning.

related work
with widespread applications such as those just discussed, one would expect a plethora of algorithms targeting maximal bicliques on bipartite graphs. most algorithms that achieve this purpose, however, are either not tailored for bipartite graphs or not designed specifically for maximal biclique enumerations. most existing graph algorithms for solving this problem fall into two main categories:  those designed for bipartite graphs but that either place undue restrictions on the input or require reduction to other problems, and  those designed for general graphs and are thus unable to take advantage of bipartite graph structure. table
 <dig> lists these algorithms, their inputs and outputs , and the methods they use.

sanderson et al.
mushlin et al.
zaki et al.
uno et al.
li et al.
makino & uno
tomita et al.
eppstein
alexe et al.
liu et al.
algorithms for bipartite graphs
existing algorithms for finding maximal bicliques in bipartite graphs are further divided into the following three approaches: exhaustive search with restrictions on outputs, reduction to the clique enumeration problem on general graphs, and reduction to the frequent itemset mining problem in transaction databases.

the most intuitive approach entails exhaustively building all subsets of one vertex partition, finding their intersections in the other partition, and checking each for maximality. algorithms based on exhaustive search must generally place one or more restrictions on the problem to reduce its enormous search space. moreover, exhaustive search requires storing generated bicliques to determine their maximality. an iterative algorithm is presented in
 <cit>  to build subsets progressively, from pairs of vertices to collections of larger and larger sizes. it limits the sizes of both biclique vertex partitions, yet still requires enormous amounts memory to store the lists used to generate subgraphs and decide maximality. the algorithm described in
 <cit>  builds bicliques based on set expansion and extension operations. it employs a hash table that determines maximality to avoid pairwise biclique comparisons, and a queue to maintain bicliques prioritized by figure-of-merit values . users can specify constraints on the figure-of-merit values to filter out bicliques of insufficient interest.

the second approach relies on graph inflation. as observed in
 <cit> , the enumeration of maximal bicliques in a bipartite graph can be transformed into the enumeration of maximal cliques in a general graph by adding all possible edges between vertices within the same partition, thereby transforming each of the two disjoint vertex sets into a clique. this approach is neither practical nor scalable, however, due to the enormous number of edges that may be needed and the concomitant increase in problem difficulty that is incurred. given a bipartite graph g =  where |u| = m, |v| = n, |e| = e, the number of edges needed to transform g to a corresponding graph
gˆ is
n2+m <dig>  thus, this method transforms the problem of finding maximal bicliques in a bipartite graph with edge density
d=em×n to the problem of finding maximal cliques in a graph
gˆ with density
d=e+n2+m2m+n <dig>  note that
gˆ might be dense even if g is sparse. when g has two vertex sets of equal size and no edges ,
gˆ has a density
n2-n2n2-n≃50%. figure
 <dig> illustrates the correspondence between these two problems.
g2^ by adding edges  between every pair of nodes in the same partition. the vertices of b now form a maximal clique in
g2^. in , a transaction database is built from g <dig> by treating v as the transaction set and u as the item set. b can now be viewed as a frequent closed itemset in this database.

a third approach comes from the field of data mining. it was observed in
 <cit>  that a transactional database can be represented by a bipartite graph, with a one-to-one correspondence between frequent closed itemsets and maximal bicliques. a subset of items is defined as a frequent itemset if it occurs in at least one transaction. on one hand, a frequent itemset and the set of transactions containing the frequent itemset form a biclique. on the other hand, the adjacency lists of a bipartite graph can be viewed as a transaction database by treating each vertex in one set as an item and each vertex in the other set as a transaction that contains a subset of items. a biclique can thus be mapped to a frequent itemset. a maximal biclique corresponds to a frequent closed itemset, where a frequent itemset i is said to be closed if the set of transactions containing i do not contain a superset of i. the support of a frequent itemset is the number of transactions in which the set occurs. enumerating all maximal bicliques is equivalent to enumerating all frequent closed itemsets with support at least  <dig>  figure
 <dig> shows a mapping between these two problems. a correspondence between maximal bicliques of a general graph and frequent closed itemsets has been shown
 <cit> , leading to the suggestion that fpclose and similar frequent itemset mining methods
 <cit>  may be helpful in enumerating maximal bicliques. implementations of this approach require a post-processing step to obtain the transaction set for each frequent closed itemset, as described in
 <cit> . this is because the published methods output only the frequent itemsets . although this post-processing step is straightforward enough, it can be prohibitively time-consuming when the number of maximal bicliques is large. moreover, known methods take the support level as an input parameter, and find only frequent closed itemsets above the given support. 

algorithms for general graphs
maximal bicliques can also be found with algorithms designed for general graphs. such algorithms of course lack any efficiency gains that might be accrued from utilizing bipartite graph structure. the maximal biclique enumeration problem was studied from a theoretical viewpoint in
 <cit> , where the focus was on graphs of bounded arboricity. it was proved that all maximal bicliques in a graph of order n and arboricity a can be enumerated in o time. this approach is not practical for large graphs, however, because it is unrealistic to expect that arboricity would be limited in practice
 <cit> . a suite of consensus algorithms was presented in
 <cit>  for finding complete bipartite  subgraphs. unfortunately, these algorithms need to keep all maximal bicliques in memory. the modular input consensus algorithm , the most efficient among them, has space complexity
o and time complexity
o, where
 denotes the number of maximal bicliques. an algorithm  based on divide-and-conquer was proposed in
 <cit>  to mine large maximal bicliques from general graphs by putting size constraints on both vertex sets to iteratively prune the search space. the algorithm reduces the space complexity to o and the time complexity to
o. the algorithm on dense graphs from 2nd dimacs challenge benchmarks outperforms mica when minimum biclique sizes are constrained by certain thresholds.

to solve the biclique enumeration problem, restrictions on either inputs or outputs have been proposed to reduce the search space. these include bounding the maximum input degree
 <cit> , bounding an input’s arboricity
 <cit> , and bounding the minimum biclique size
 <cit>  or figure-of-merit
 <cit> . naturally, no algorithm relying on these restrictions can solve arbitrary bipartite instances.

methods
the algorithm we shall now describe achieves efficiency without i/o or other restrictions. performance testing on both synthetic and biological graphs demonstrate that it is markedly superior to mica
 <cit> , the best known algorithm for finding bicliques on general graphs, and to lcm-mbc
 <cit> , a state-of-the-art frequent itemset algorithm that improves upon and adds a post-processing step to lcm
 <cit> . the maximal biclique enumeration algorithm  combines backtracking with branch-and-bound techniques to prune away regions of the search tree that cannot lead to maximal bicliques. mbea is inspired by the classic maximal clique-finding method of
 <cit> , which was refined and shown to have optimal time complexity in
 <cit> . the search space for mbea is limited to disjoint vertex sets because, in a biclique, vertices in one set determine those in the other.

algorithmic basics
let g =  be a bipartite graph and assume, without loss of generality, that |u| ≥ |v|. mbea operates on the  set v, utilizing the following four dynamically changing sets of vertices:  r, a subset of v,  l, a subset of u containing all the common neighbors of r,  p, a subset of v containing candidate vertices that may be added to r, and  q, a subset of v containing former candidates, that is, vertices that were previously considered for r. the sets r, l, p and q are employed in a depth-first traversal of a recursion tree to form maximal bicliques. r and l are used to form such a biclique, where r determines l. p is used for biclique expansion. q is used to determine maximality. p, q and r are required to satisfy the following two conditions:

•  ∪  ∪  = ∅. that is, p,q,r are pairwise disjoint.

• p ∪ q = {v|v ∈ v∖r, ∃ u ∈ l,  ∈ e}. that is, p and q contain every vertex in v but not r that is adjacent to at least one vertex in l.


observation  <dig>  the subgraph induced by  is a biclique.

for simplicity, and since g is bipartite, we henceforth drop the reference to induced subgraph, and simply say that  is a biclique. note that  is maximal iff there is no vertex in u∖l that is adjacent to all vertices in r and no vertex in v∖r that is adjacent to all vertices in l. because l is defined by r, only the maximality of r need be considered.


observation  <dig>   is maximal iff no vertex in v∖r is adjacent to every vertex in l.

if p contains a vertex that is adjacent to all vertices in l, then  is not maximal. thus that vertex may as well be moved from p to r. this process can be iterated until no more vertices can be so moved. on the other hand, if none of the elements of v∖r is a common neighbor of all vertices in l, then  is maximal because l and r are the largest set of common neighbors of each other.


observation  <dig>  let s denote {v | v ∈ p &  ∈ e ∀ u ∈ l}. then  is a maximal biclique.

if q contains a vertex that is adjacent to all vertices in l, then not only  is not maximal, but also there can be no s as defined above for which  is maximal. we can actually say slightly more than this, as follows.


observation  <dig>  let t denote {v | v ∈ q &  ∈ e ∀ u ∈ l}, l′ denote any subset of l, and s′ denote any subset of p. unless t is empty,  is not a maximal biclique.

observation  <dig> is used to prune unproductive subtrees in a branch-and-bound style exploration of the maximal biclique search space. as observation  <dig> shows, if q contains a vertex v adjacent to all vertices in l, it means that biclique  is not maximal. we further observe that none of the bicliques extended from r contains v, since r does not contain v. however, v is adjacent to all vertices in any subset of l. thus, no bicliques extended from such a node is maximal and its subtrees can be pruned away. the utility of these observations is explicated in figure
 <dig> 

algorithmic description
to aid discussion, we refer the reader to pidgin pseudocode for algorithm: mbea.  overall, a depth-first search tree traversal is performed recursively using the core function biclique_find(). initially, all vertices are biclique candidates , while the biclique and former candidate sets are empty . as the computation proceeds, r grows but l and p shrink. at each node of the search tree, biclique_find takes as input a 4-tuple 〈l,r,p,q〉 and selects a candidate x from p. an extension step augments r with x to form r′, and forms l′ from l by removing all vertices not connected to x. this makes l′ a set of common neighbors for r′. p′ and q′ are then formed by eliminating vertices not connected to l′. p′ also loses vertices connected to all of l. these are added to r. if no vertex in q′ is connected to all of l′, then a maximal biclique  has been found. a recursive call is made with 〈l′,r′,p′,q′〉. x is removed from p and added to q. the process stops when either p is empty or a vertex in q is connected to all of l. an example of the search performed by mbea is depicted in figure
 <dig> 


theorem  <dig>  mbea finds all maximal bicliques in a bipartite graph.


proof. mbea explores the entire search space of all the subsets of one vertex set and finds all the bicliques by observation  <dig>  it checks their maximality by observation  <dig>  it eliminates only those that cannot lead to other maximal bicliques by observations  <dig> and  <dig>  therefore, upon termination, mbea has found all maximal bicliques.

improvements to mbea
we seek to improve mbea in two ways: by an early removal of vertices from the candidate set, and by a selection of candidate set vertices in non-decreasing order of common neighborhood size. both actions tend to help prune the recursion tree by avoiding the generation of non-maximal nodes.

tree pruning
recall observation  <dig>  which asserts that if p contains a subset s of vertices that are adjacent to all vertices in l, then  is a maximal biclique. our first modification is based on an extension of this observation. although it suggests the addition of candidates whose neighborhoods contain that of x, upon recursive return mbea treats vertices in s just as it does other vertices in the candidate set. that is, every vertex in s is still selected for expansion, even though some will lead to non-maximal subsets only. the generation of such branches can be avoided if we subdivide s into two subsets as follows. for any v ∈ s, either the neighborhood of v is a proper superset of the neighborhood of x  ⊃ n
l
), or its neighborhood is exactly the same as that of x  = n
l
).

vertices of the second group can thus be moved directly to q upon recursive return, because any biclique that excludes x but includes v is a subgraph of a biclique including both x and v. see figure
 <dig> for an example. this construction is formulated as follows:
 <dig>  and  the recursion trees t <dig> and t <dig> without and with the candidate selection method on g <dig> 


observation  <dig>  any vertex in p with neighborhood l must be an element of the current biclique, and thus can be added to r. otherwise, any biclique in the current subtree is non-maximal.

candidate selection
observe that mbea chooses candidates in given  order. the second modification we consider was inspired by noticing that leftmost branches, which are explored earlier, generally have more candidates to generate sub-branches than do rightmost branches, which are searched later, as long as the selected candidates have the same number of connections to l.

consider for example a connected bipartite graph g4 =  where |u| =  <dig> |v| =  <dig> and vertex v1 ∈ v is adjacent to all vertices in u ). if v <dig> is the first selected candidate, then both v <dig> and v <dig> are candidates at the same level because both connect to at least one vertex in u. both {v2} and {v3} are non-maximal, however, since they are subgraphs of bicliques including v <dig>  on the other hand, if v <dig> is the last selected candidate, then there is no vertex left in the candidate set because v <dig> and v <dig> have been explored earlier. vertex v <dig> is thus directly added to all bicliques according to observation  <dig>  since v <dig> is adjacent to all vertices in l. we conclude that selecting candidates in non-decreasing order of common neighborhood size may avoid generating numerous non-maximal subsets. moreover, it can lead to more balanced recursion trees, which is an important property in load-balanced parallelization.

improved algorithmic details
to distinguish the basic method from the improved, we shall denote the latter by imbea, the version incorporating the two modifications just discussed. in algorithm: mbea, these executable additions are indicated with starred lines. the vagaries of data are important, naturally, and so improvements may not always be what they seem. for example, an effective way to create and maintain a candidates list ranked by common neighborhood size is simply to insert a vertex into its proper place in the list. although well-suited to this particular task, such a use of insertion sort may actually create a tradeoff between the potential time saved in searching versus that spent inserting. to see this, consider that overall time is probably saved in the case of real or synthetic graphs with variable degree distributions. we may actually do better, on the other hand, to turn off this feature on highly contrived instances, especially those such as regular graphs in which all vertices have the same degree. see figure
 <dig>  which shows differences between recursion trees produced by mbea and imbea on a sample bipartite graph.  

algorithmic complexity
we first consider the time complexity of a brute-force algorithm that examines all subsets of the smaller vertex partition. let g =  denote a bipartite graph, with |u| = m, |v| = n, and m ≥ n. there are 2
n
 subsets of v. it takes o time to find each subset’s common neighbors in u. it also takes o time to decide maximality. thus, the worst-case time complexity of this simple scheme is o.

similarly, the worst case number of nodes in a recursion tree for mbea is 2
n
, again bounded by the total number of subsets of v. at each such node, the time complexity of biclique_find is o, where d is the maximum degree of any vertex in v . thus, the worst case time complexity of mbea is o. the total number of subsets examined by mbea is considerably less than 2
n
, however, because branch-and-bound prunes the recursion tree. we shall therefore note that the number of nodes in a recursion tree is at least as large the total number of maximal bicliques, and analyze time complexity in a fashion similar to that performed in
 <cit> ).


lemma  <dig>  every intermediate node in the recursion tree for mbea represents a distinct maximal biclique.


proof. nodes on mbea’s recursion tree represent maximal or non-maximal bicliques. without pruning, a non-maximal node may be formed only when a candidate or a former candidate’s neighborhood is a  superset of the current set l. in the former case, candidate vertices  whose neighborhoods contain l are automatically added to r by observation  <dig>  furthermore, if a candidate’s neighborhood exactly equals l, then no branching is needed based on observation  <dig>  the biclique at any intermediate node is thus maximal because further candidate additions would reduce the size of l and lead to another maximal biclique. in the latter case, a former candidate whose neighborhood contains l leads to no more maximal bicliques from that branch. a non-maximal node with a former candidate connected to all vertices in its l is therefore a leaf. we conclude that all intermediate nodes in the recursion tree are maximal.


theorem  <dig>  given a bipartite graph g =  where |u| = m,|v| = n,m ≥ n, and |e| = e, the time complexity of the maximal biclique enumeration algorithm for finding all maximal bicliques in g iso, where
is the number of maximal bicliques. the time complexity per maximal biclique is o.


proof. as proved in lemma  <dig>  mbea expands only the nodes that are maximal bicliques on the recursion tree, which means it creates only maximal bicliques as intermediate nodes on the tree and non-maximal bicliques can only be leaf nodes. in other words, the number of non-maximal bicliques created on the tree is at most the total number of the leaf nodes. for any intermediate node on the recursion tree, the number of its children that are leaf nodes representing non-maximal bicliques is less than n -  <dig>  in the worst case, the number of intermediate nodes is
b=∑i=0i, and the number of leaves is
d=o, where d is the maximum degree of any vertex in v. thus, the total number of nodes on the recursion tree is
o. we showed that the time complexity of biclique_find() is o. it can be restated as o, since mbea must scan all edges for maximality and biclique expansion in the worst case. combining time complexity o at each node with the total number of nodes in the recursion tree
o, we obtain a time complexity of
o for the overall algorithm, and a time complexity per maximal biclique of o.

to understand the algorithmic complexity a little deeper, we view mbea under the concept of delay time, which we define as in
 <cit>  as the running time between the output of two consecutive maximal bicliques. in this framework, mbea is a “polynomial delay time algorithm” because the elapsed time between the output of any two consecutive bicliques is polynomial in d and n.


theorem  <dig>  mbea is a polynomial delay time algorithm with delay complexity o.


proof. mbea takes o time to explore any single node in its recursion tree. a maximal  node can have at most n -  <dig> non-maximal neighbors . even in the worst case, mbea must traverse no more than back to the root of the tree to find the next maximal node. the depth of the tree is at most d. from this it follows that the delay complexity is o.


theorem  <dig>  given a bipartite graph g =  where |u| = m,|v| = n,m ≥ n, the worst-case space complexity of mbea is om).


proof. mbea uses two vectors to store the two vertex sets of the biclique in each node of the recursion tree. the space for storing them is o. when m > n, the space complexity at each node is o. since the depth of the tree is at most d, the overall space complexity of the recursion tree is o. meanwhile, mbea uses bitmap vectors to store adjacency matrix of the input bipartite graph, which requires o space complexity. therefore, the space complexity in total is o = om) = om).

thus, in the worst case, mbea’s space complexity is quadratic in the order of the graph. this should not be surprising. indeed, such a result is the best that can be achieved by any algorithm that stores its entire input, since the input size is determined by the number of edges.

implementations and testing
we implemented mbea and imbea and compared them to existing implementations of what should be the two strongest competitors: mica
 <cit> , currently the fastest graph theoretical algorithm for finding bicliques in general graphs, and lcm-mbc
 <cit> , currently among the most advanced data mining algorithms for finding pairs of frequent closed patterns, improving upon lcm
 <cit> . an efficient implementation of mica is available at
http://genome.cs.iastate.edu/supertree/download/biclique/readme.html. efficient codes for lcm can be found at
http://fimi.ua.ac.be/src/. version  <dig> is reported to be the faster of the two available lcm implementations. the authors of
 <cit>  graciously provided us with their implementation of lcm-mbc, which we used in our comparisons. mbea/imbea and mica accept graphs in a simplified dimacs edge list format. lcm/lcm-mbc is not dimacs compatible, however, and required us to convert an edge list into an equivalent adjacency list for the smaller bipartite partition. graphs come in many formats, of course, so we did not charge any time for this simple conversion.

all implementations were compiled on and timings performed under the ubuntu  <dig>   x <dig> operating system on a dell optiplex  <dig> minitower with an intel core i7- <dig>  <dig>  ghz processor,  <dig>  gb ddr <dig> non-ecc sdram memory at  <dig> mhz , and a  <dig> gb  <dig> rpm sata hard drive. only sequential implementations of mbea, mica and lcm-mbc were compared, each making use of a single compute core. mbea and imbea were written in c and compiled with the gnu gcc compiler with o <dig> optimization turned on. the mica and lcm-mbc implementations were also complied with o <dig> turned on. the wallclock running times we report include both i/o and computation, but exclude the time taken to print out the maximal bicliques. they are the average of ten, five or three runs for graphs that can be finished within one minute, one hour or three days, respectively. runs that exceeded three days were killed and omitted from the averages. we employed standard data reduction techniques to reduce the size of bipartite graphs for all methods tested. for example, during pre-processing, two or more vertices with the same neighborhood are merged into a single vertex; this process is reversed at post-processing.

biological graphs
we tested the algorithms on biological graphs derived from functional genomics data. one set of graphs, which was extracted from cerebellum data, was created using a matrix of correlation p-values for gene expression to phenotypes across strains of mice in a single population
 <cit> . the matrix consists of  <dig> genes represented by microarray measures of transcript abundance and  <dig> phenotypes to which the transcript abundances are correlated. a bipartite graph is obtained by placing an edge only where the correlation p-value is at or below some preset threshold. the density of this graph can be varied by adjusting the threshold. the lower the p-value threshold, the lower the graph density. to test a wide variety of densities, we created twenty graphs over a range of thresholds, from  <dig>  to  <dig> , with a step of  <dig> .

the second set of graphs, which represent phenotype-gene associations, was created from a correlation matrix between  <dig> phenotypes and  <dig> genes, calculated over a panel of more than  <dig> mice. for each threshold, a phenotype-gene edge is present if the correlation is at or above the threshold. we created graphs with a range of thresholds, so that the lowest threshold ran in a small fraction of a second and the largest in tens of minutes.

in both sets, edge density increases across the range of thresholds. from roughly  <dig> % to about  <dig> % in the cerebellum graphs, and from roughly  <dig> % to as high as  <dig> % in the pheno-gene graphs. computational demands increase even more rapidly, because the number of maximal bicliques tends to grow exponentially with a linear increase in threshold values.

random graphs
in addition to biological graphs, we tested imbea and lcm-mbc on random bipartite graphs, using two different random graph models. the first is the classic erdős-rényi random graph model. here, we fixed the number of vertices in each partition at  <dig> and varied the density from  <dig>  to  <dig> . the density range was selected so that the lowest would run in well under a second and the highest would require several minutes. we also tested graphs with  <dig> and  <dig> vertices, but the results were similar enough to graphs with  <dig> vertices that we omit their discussion.

for the second random graph model, we modified the erdős-rényi model so that we could study graphs with both high and low degree variability. the graph generator takes as input these four parameters: the size m of the larger partition, the size n of the smaller partition, the average vertex degree μ in the smaller partition, and the coefficient of variation cv of the degrees in the smaller partition.  these specifications were used to assign vertex degrees to the smaller partition. no edges were produced within a partition, of course. the assigned degrees in the smaller partition were used to place edges, selecting each endpoint in the larger partition with uniform probability. for example, if a vertex in the smaller partition had been assigned degree three, then three neighbors for it were uniformly selected from the larger partition.

we created three sets of random graphs with this graph generator. the first set fixed the number of vertices in one partition at  <dig>  and in the other partition at  <dig>  the edge density at  <dig> %, and varied the cv from  <dig>  to  <dig> . the purpose of this set was to test the behavior of mbea versus imbea when the cv is varied, it being our intuition that imbea might be better suited to graphs with higher cv. the second and third sets of graphs were created to test imbea versus lcm-mbc when the relative partition sizes were varied. in one set, the size of the larger partition is fixed at  <dig>  and the size of the smaller partition is varied from  <dig> to  <dig>  in the other set, the size of the smaller partition is fixed at  <dig> and the size of the larger partition is varied from  <dig> to  <dig> . in both sets we used an edge density of  <dig> %, which provided a wide spectrum of partition sizes while keeping runtimes within reason.

RESULTS
in this section, we compare runtimes of the various algorithms. mica turns out not to be competitive on any of our graphs. we therefore exclude its timings from our presentation. for instance, imbea outperforms mica by more than three orders of magnitude on even modest-sized biological graphs. on a somewhat larger graph, imbea finishes in under an hour while mica runs for over three days without completion. and on the largest graphs, mica runs out of memory. thus, we feel it is manifest that mica does not belong in the same class as algorithms such as mbea and imbea, which are specifically targeted at bipartite graphs. we first concentrate on mbea and imbea on both biological and random graphs in order to demonstrate the performance gained by imbea’s improved pruning. we then move on to compare imbea and lcm-mbc on two sets of biological graphs and three sets of random graphs.

comparison of mbea and imbea
in figure
 <dig> we compare the runtimes of mbea and imbea on the twenty cerebellum graphs. the curves cross at a p-value threshold of about  <dig> . imbea is roughly three times as fast as mbea at around threshold  <dig> . these results confirm our expectations that the relative simplicity of mbea wins on sparse graphs produced at lower thresholds, while the improvement overhead of imbea more than pays for itself once higher thresholds generate graphs that are sufficiently dense. we also compared mbea and imbea on random bipartite graphs. as shown in figure
 <dig>  while reasonably close, imbea consistently outperforms mbea. the sorted candidate vertex selection and enhanced pruning of imbea appear still to produce performance gains. these gains are not as significant, however, as they were for biological graphs. this may be due at least in part to the rather smoothed overall topology of random graphs, as opposed to the uneven density and highly irregular features typically seen in graphs like those in geneweaver. to look closer into this behavior, we varied the cv with which random graphs were built. we found, as illustrated in figure
 <dig>  that imbea outperforms mbea on random bipartite graphs over the entire cv range tested. the performance gap is smaller when the cv is low, probably due to mbea’s relative simplicity and reduced overhead. as the cv increases, however, the performance gap between mbea and imbea widens. these results help explain imbea’s superior performance on biologically-derived graphs, which very often exhibit high variation in vertex degree. when comparing our algorithms to other methods, we employ only imbea for simplicity. it is possible that on some inputs mbea would do slightly better.

comparison of imbea and lcm-mbc
figure
 <dig> shows the average runtimes of imbea and lcm-mbc on the biological graphs tested. part  is the pheno-gene graphs, and parts  and  are two ranges of p-values for the cerebellum graphs. the performance disparity is most notable when the graphs grow denser. on both the cerebellum and pheno-gene graphs, the maximal bicliques in the densest graph exceed the  <dig> gb disk storage limit of the lcm-mbc implementation, causing the program to halt prematurely, reporting only a portion of the maximal bicliques. the runtime of these two graphs would certainly be much higher if the limit were removed. the results of imbea and lcm-mbc on random bipartite graphs are shown in figure
 <dig>  both methods scale to graphs with thousands of vertices in each partition. the imbea algorithm, however, consistently and convincingly outperforms lcm-mbc.

these figures highlight imbea’s advantages in scalability. methods tend not to look very different when graphs are sparse. as data quality improves, however, geneweaver and analysis tools of its ilk tend to employ denser graphs in order to capture deeper latent structure. this is where the design enhancements of imbea really start to become conspicuous and unmistakable.

utility in geneweaver
geneweaver , formerly the ontological discovery environment
 <cit> , seeks to identify unique and shared relationships between genes and their roles in biological processes. aggregated genomic data is integrated, and relevant associations are represented, with discrete bipartite graphs. these allow relationships from diverse experimental sources to be combined. geneweaver employs mbea/imbea on these graphs to discover the ontology or structured inheritance of biological processes through the genesets that support them. this is accomplished through an enumeration of maximal bicliques, which are organized as a directed acyclic graph  to form an empirically derived interpretation of relationships between biological processes. an implementation of this systematic approach, including mbea/imbea, is embedded in the web-based geneweaver software platform. data availability has driven this application to emphasize genes as the primary biological entity through which relationships are inferred. nevertheless, the model is general enough to map easily onto other biological entities or attributes. thus, geneweaver provides a computationally scalable approach to subset-subset matching in the quest to increase our understanding of molecular networks that support biological function.

motivation
a major challenge in bioinformatics is to identify relationships among poorly characterized genes and their varied roles in biological processes, and to group these processes along functionally meaningful lines. for example, one may be interested in whether  the biological bases of psychiatric disorders such as anxiety or depression are also involved in alcoholism. each disorder may be attributable to multiple genes, and each gene may be involved in multiple disorders . biological processes are typically categorized by ontologists based on their external manifestations. unfortunately, phenomena such as convergent evolution  and other factors that result in functional similarity can lead to poor classification schemes that do not map onto the supporting biology. thus, for basic research into discovery of the biological underpinnings of diverse processes, a classification of biological functions can instead be based on sets of underlying genes. finite simple graphs are a natural way to represent relationships between such sets. graph algorithms are a useful tool in their analysis and interpretation. the need to study whole genome versus biological functional data makes bipartite graphs an appropriate model for finding associations between pairs of disparate data types. enormous correlational structures can arise in data of this size, however, potentially making the task of biclique enumeration a limiting computational bottleneck. this is because classification and assessment of the phenome space is theoretically unbounded, especially in the case of genome-scale ontological discovery. the mbea and imbea methods were therefore developed to harness fast algorithm design techniques and to exploit bipartite graph structure in order to satisfy the staggering computational demands that may be incurred in the creation of emergent phenotypic ontologies.

data
a biological pathway or process can be associated with a set of genes. such a set typically comes from some biological source, for example, an experiment related to drug abuse. gene sets can be generated with any methodology dedicated to gene-network creation. commonly used methods include differential gene expression, genetic correlation to gene expression, positional candidates from genetic mapping, associations obtained from text mining, and literature reviews and/or empirical studies in which researchers compile gene lists involved in various behavioral constructs such as pain, aggression, alcoholism and drug abuse.

the geneweaver database currently contains over  <dig>  gene sets covering nine species: caenorhabditis elegans , danio rerio , drosophila melanogaster , gallus gallus domesticus , homo sapiens , macaca mulatta , mus musculus , rattus norvegicus  and saccharomyces cerevisiae . when sets from different species are combined, gene homology is used to match genes onto a set of reference gene id clusters. although the gene-set space is unlimited, the genome space is constrained by the finiteness of the genome itself.  it should be noted that the method described here is extensible to include any biomolecule associated with a function or process, including mirna, transcript forms, gene products and their various states and many additional entities involved in biological processes. likewise, it is often desirable to use abundance or co-occurrence statistics to relate one class of biomolecules to another, including transcripts and mirna, or transcripts and proteins. thus, the size of the biomolecular vertex class is also potentially without bound.

model
a biclique-based model was developed to extract functions along with functionally similar genes from gene sets derived from various sources, and then to organize them as a dag to represent an entire ontology of biological functions. this model consists of three major components: a combine module to compute gene-set association matrices to construct bipartite graphs via thresholding and graph mapping, a biclique module using mbea/imbea to enumerate maximal bicliques from gene-set bipartite association graphs, and a phenome graph module to organize gene sets by integrating maximal bicliques into a dag to represent an ontology of functions.

graphs
the combine module melds gene sets from various sources, computes a real-valued scoring matrix to associate genes with functions, converts the matrix to binary by applying a suitable threshold, and transforms the matrix into a bipartite association graph. homology may be employed when more than one species is involved. scoring can be based on a variety of statistical metrics, including correlation coefficients, p or q values, literature associations and other categorical analyses. thresholding may be soft or hard, and is generally performed with the aid of low and high pass filters. keywords such as “drug,” “alcohol” and “cerebellum” are used to select gene sets, based on search term occurrence in metadata. these sets may be fused to form larger collections of putative biological functions.

biclique enumeration
the biclique module uses mbea/imbea to enumerate all maximal bicliques in the bipartite gene-set association graph. here a biclique represents the relationship between a set of biological functions and the genes with which they are commonly associated. maximality ensures that this relationship is not properly contained within another. a maximal biclique thus denotes a unique set of functionally similar biological processes along with the genes they share in common.

ontological integration
the phenome graph module constructs an ontology of functions. maximal bicliques are connected based on their relationships. the resultant hierarchical similarity graph represents sets of genes associated with common functions. note that dags are similar to hierarchies , except that a child node in a dag may have more than one parent node. the formulation of the hierarchical similarity graph is based on the following observation, which helps us define an inherent biclique ordering.


observation  <dig>  let p denote the set of phenotypes in a biclique, b, and let g denote its set of genes. given two maximal bicliques b <dig> and b <dig>  p ⊂ p if and only if g ⊃ g, and p ⊃ p if and only if g ⊂ g.

we can now define a hierarchical similarity graph using maximal bicliques for nodes and a partial ordering of the bicliques for arcs . node b <dig> will be an ancestor of node b <dig> iff p ⊃ p. in this case we say that b <dig> is a descendant of b <dig>  a node with no ancestors is said to be a root. one with no descendants is said to be a leaf. node b <dig> will be a parent of b <dig> iff it is an ancestor and there is no other node b <dig> for which p ⊃ p and p ⊃ p. in this case we say that b <dig> is a child of b <dig>  once these relationships have been formed, an arc is placed from a parent to each of its children.

figure
 <dig> illustrates this construction. a sample hierarchical similarity graph is built from three human gene sets taken from geneweaver using the drug-related gene sets listed in table
 <dig>  these sets contain many genes, but we are chiefly interested in the ten genes that are each shared by at least two of the sets. these genes and sets are used to build a gene-set association graph, from which a total of six maximal bicliques are extracted. despite geneweaver’s size and scope, mbea/imbea currently requires at most a few minutes to enumerate maximal bicliques on legitimate queries. a more subtle but equally important task that it must perform is the computation of significance levels for dag scoring  among graphs with the same number of genes, gene sets and gene-set associations. here a re-sampling procedure can be applied to simulate variations in gene-set intersection topology. such a procedure can easily require tens of thousands of re-sampling operations, however, each needing its own list of maximal bicliques. mbea/imbea can accomplish this task in less than an hour using current technologies, while previous methods were untenable, often consuming several days even on just a few hundred gene sets.

CONCLUSIONS
we introduced a novel algorithm, mbea, to enumerate maximal bicliques in a bipartite graph. the technique we described employs efficient branching and pruning strategies to eliminate paths that cannot lead to maximal bicliques. we also presented an improved version of this algorithm, imbea, that selects candidate vertices in non-decreasing order of common neighborhood size. extensive empirical evaluation revealed that imbea outperforms mbea on both biological and random graphs. furthermore, we tested imbea against mica, a fast consensus algorithm, and against lcm-mbc, a frequent closed itemset data mining method. we observed that both imbea and lcm-mbc are orders of magnitude faster than mica, which we thus eliminated from further consideration. we also found that imbea is significantly faster than lcm-mbc, on both random graphs and biologically-based graphs derived from geneweaver , an online system for the integration of functional genomics experiments. armed with imbea, geneweaver provides users with the computational capacity to perform genome-scale analyses of complex relationships derived from diverse biological experiments, with the goal to discover the ontology or structured inheritance of biological processes. mbea and imbea are apt to be well suited to any application in which bipartite graphs can be used to model relationships between two sets of diverse items.

availability and requirements
project name: maximal biclique enumeration

project home page:http://web.eecs.utk.edu/~langston/mbea.html

operating systems: linux

programming language: c

other requirements: none

license: gnu-gpl

any restrictions to use by non-academics: no

competing interests
the authors declare that they have no competing interests.

authors’ contributions
yz designed and implemented mbea/imbea algorithms and performed timings. cp investigated relationships with frequent itemset mining and performed confirmatory studies. gr aided in algorithm synthesis. eb and ec explored biological applications and oversaw integration into geneweaver. ml conceived of the project and directed the analysis. all authors read and approved the final manuscript.

