BACKGROUND
string set matching is an important operation in computational biology. for example, when proteomics data is used for genome annotation in a process called proteogenomic mapping  <cit> , a set of peptide identifications obtained using mass spectrometry is matched against a target genome translated in all six reading frames. given a large number of peptides and long translated genome strings, the fundamental problem here is to efficiently search for a large set of pattern strings  in a larger text string .

efficient substring search algorithms such as boyer-moore  <cit>  and knuth-morris-pratt  <cit>  that locate single pattern strings within a larger text string can be used in a multi-pass manner . however, this approach does not scale well with an increasing number of pattern strings. in particular, assuming p patterns with an average length of n and a text string of length m, naïve, multi-pass, approaches have computational complexity of o).

the aho-corasick algorithm  <cit>  provides a scalable solution to the string set matching problem in that it incorporates the search mechanism for the entire set of patterns into a single finite state machine . the power of aho-corasick stems from the ability of the algorithm to find the location of the strings in the pattern set in the text string in a single pass. the computational complexity of aho-corasick search is o where k is the total number of occurrences of the pattern strings in the text. this linear processing time complexity has resulted in the widespread use of aho-corasick in string matching applications.

the performance of the aho-corasick algorithm can be further enhanced by implementing it in hardware. tan and sherwood  <cit> were the first to describe an area-efficient hardware approach for implementing the aho-corasick for network intrusion detection systems implemented in application specific integrated circuits . however, the complexity and costs associated with asic development is a significant impediment in their adoption in computational biology. field programmable gate array  devices, on the other hand, can be repeatedly reconfigured to create a variety of application-specific processing elements. this reconfigurable nature makes fpgas a popular low-cost alternative to the development of specialized asics for a variety of application domains, including computational biology.

although the fundamental aho-corasick algorithm is identical for all string set matching applications, optimization for specific applications and target hardware results in significant performance and storage efficiencies. the main contribution of this paper is a case-study demonstrating how an aho-corasick architecture and finite state machine  organization can be specifically optimized for incorporation into proteogenomic pipeline using field programmable gate array  hardware. this paper also demonstrates how the 18-kbit random access memory  blocks available on xilinx's virtex- <dig> fpgas and 9-kbit ram blocks available in altera's fpgas can be utilized to create resource-efficient amino acid sequence set matching engines. furthermore, the use of ram instead of fpga logic resources for encoding fsm state transitions enable the fpga to be quickly reconfigured for matching different peptide sets.

related work
the aho-corasick algorithm  is widely used in computational biology for a variety of pattern matching tasks. for example, brundo and morgenstern use a simplified version of aca to identify anchor points in their chaos algorithm for fast alignment of large genomic sequences  <cit> . the troll algorithm of castelo, martins, and gao uses aca to locate occurrences of tandem repeats in genomic sequence  <cit> . farre et al. use aho-corasick as the search algorithm for predicting transcription binding sites in their tool promo v.  <dig>   <cit>  hyyro et al. demonstrate that aho-corasick outperforms other algorithms for locating unique oligonucleotides in the yeast genome <cit> . the siteblast algorithm  <cit>  employs the aho-corasick algorithm to retrieve all motif anchors for a local alignment procedure for genomic sequences that makes use of prior knowledge. sun and buhler use aho-corasick deterministic finite automata  to design simultaneous seeds for dna similarity search  <cit> . the ahopro software package adapts the aho-corasick algorithm to compute the probability of simultaneous motif occurrences  <cit> .

there has been a good deal of attention in the use of fpgas to address bottlenecks in computational biology pipelines. examples include the use of fpgas to improve the speed of homology search  <cit>  for computing phylogenetic trees  <cit> , for the pairwise alignment step in multiple sequence alignment using clustalw  <cit> , and for acceleration of the smith-waterman sequence alignment algorithm  <cit> . in computational proteomics, alex, et al.  <cit>  have demonstrated the use of fpgas to accelerate peptide mass fingerprinting.  bogdan et al.  <cit>  have applied fpgas to the problem of analyzing mass spectrometric data generated by maldi-tof instruments by developing hardware implementations of algorithms for de-noising, baseline correction, peak identification, and deisotoping.

hardware implementations of aca have been developed for applications other than bioinformatics. snort is a popular computer security program that looks for a set of "signature" patterns corresponding to known intrusion attacks in network packets. tan and sherwood  <cit>  split the aho-corasick implementation for snort into four separate fsms such that each fsm is responsible for two separate bit positions in the signature string set and network packet. this bit-split implementation is more efficient in terms of hardware area. however, their paper does not exploit the availability of specialized hardware resources in fpgas.

jung, baker and prasanna  <cit>  describe an implementation of the bit-split aho-corasick algorithm for snort using field programmable gate array  technology. they optimize the bit-split implementation of aho-corasick for snort by using ram blocks available on xilinx fpgas. however, in snort, the input alphabet consists of all  <dig> distinct symbols that can be represented using  <dig> bits in a byte. in string-matching for proteogenomic mapping, the alphabet consists of  <dig> amino acids and a small number of additional symbols that can be represented in five bits. furthermore, jung et al. do not exploit the dual-ported nature of ram blocks in modern fpgas that enables more efficient utilization of storage resources. therefore, the previously described bit-split implementations designed for snort are not optimal for proteomics processing in fpgas.

sidhu and prasanna describe a technique for constructing non-deterministic finite state automata  from regular expressions that can be used for string matching  <cit> . their solution requires o space where n is the number of characters in the regular expressions to be searched. because their nfa is implemented entirely in fpga logic, this technique requires large fpgas in order to implement searches for large string sets.

lin et al. describe a technique for improving the space efficiency by up to 20% for nfa implementations in fpga logic fabric  <cit> . their architecture optimizes space by sharing common prefixes, infixes, and suffixes between multiple regular expressions.

fide and jenks provide an extensive survey of string matching techniques and implementations in hardware  <cit> . the survey focuses on intrusion detection and network router implementation.

methods
the aho-corasick algorithm
the aho-corasick algorithm consists of an initial preprocessing phase that creates the fsm from the set of pattern strings. the fsm resulting from the preprocessing phase is subsequently used for performing the string set matching. the preprocessing phase has a runtime complexity of o and the search phase has a runtime complexity of o. detailed description and analysis of aho-corasick can be found in  <cit> . a brief description follows below.

in the preprocessing phase, the fsm is constructed using two steps. in the first step, a set of target strings is organized into a "keyword" tree. the root of the tree represents the state when no part of any pattern string has been found in the input message. the remaining nodes of the tree represent states where the pattern strings have been partially or fully matched. the edges in the tree represent the transitions resulting from the occurrence of specific symbols in the text string. the path from the root node to any node on the tree represents the subset of pattern strings that are potential matches.

in the second preprocessing step, "failure links" are added to the tree. failure links lead from nodes on one branch of the tree to nodes on other branches. failure links are needed because patterns strings can overlap in the text string and when the current branch of the tree fails to produce a match because of the current symbol in the text string, the fsm needs to resume processing from a new branch, without having to rescan input symbols.

in a computer, the fsm state transitions can be represented in the form of a table. figure  <dig> illustrates the organization of the fsm for an implementation of aho-corasick that matches the peptide set {acacd, ace, cac}; table  <dig> presents a table-oriented representation used for implementation of the same fsm. in figure  <dig>  the state  <dig> is the start state and the shaded states  <dig>   <dig>   <dig>  and  <dig> match peptides cac, acacd, ace, and cac, respectively. when the fsm is in any state and receives an input symbol not shown in the figure, the fsm transitions to state  <dig>  at runtime, the fsm interpreter reads the row corresponding to the current state from the table, reads the next input symbol from the reading frame, and determines the next state from the row entry corresponding to the input symbol. when the fsm transitions to as state, it looks at the pattern match column of the table's corresponding row in order to determine if a match has occurred. a non-null entry in the pattern match entry of row specifies the pattern that has been located by the fsm.

the bit-split aho-corasick implementation
the branching factor of the aho-corasick fsm tree depends on the number of symbols possible in the input text string. for example, the branching factor is  <dig> when eight bits are used for representing the alphabet of valid symbols in the strings . however, because only five bits are needed for representing all the  <dig> amino acids and additional special symbols , the size of the table can be reduced significantly by reducing the total number of columns.

additional savings in storage can be obtained by splitting the fsm into smaller fsms. following are two approaches to make an fsm smaller:

 <dig>  reduce the number of peptides in the peptide set. this will reduce the number of states in the fsm, and therefore, will reduce the number of bits required to store the "next state" transition value.

 <dig>  split the fsm into simpler fsms that are responsible for encoding and operating on individual bit positions of the symbols in the peptides patterns and the text string. for example, the fsm in table  <dig> can be split into five separate bit-split fsms, fsm <dig>  fsm <dig>  fsm <dig>  fsm <dig>  fsm <dig>  one for each of the five bit positions it takes to encode all the peptides. because the bit-split fsms operate independently from each other, all of the separate bit-split fsms must agree on a match before a peptide match is confirmed.

the general bit-split fsm algorithm is described in detail in  <cit> . the bit split fsm process is described below for the fsm in table  <dig>  resulting in the five bit-split fsms designated as fsm <dig>  fsm <dig>  fsm <dig>  fsm <dig>  and fsm <dig> shown in tables  <dig>   <dig>   <dig>   <dig>  and  <dig>  respectively. consider the construction of fsm <dig>  the bit-split fsm corresponding to bit position 0; table  <dig> describes the bitwise encoding of selected amino acids. state n in the original fsm is designated as fsm:n and state m in fsm <dig> is designated as fsm0:m.

initially, the root node fsm0: <dig> is added to fsm <dig>  next, all states in the original fsm that can be reached from fsm: <dig>  when the bit position in the transition is  <dig> are determined and aggregated into a new bit-split node fsm0: <dig>  in the example, fsm: <dig> and fsm: <dig> are aggregated to form fsm0: <dig>  because fsm0: <dig> does not already exist in fsm <dig> , it is added to fsm <dig> with a transition from fsm0: <dig> when the input bit is  <dig>  next, all states in the original fsm that can be reached from fsm: <dig> when the bit position in the transition is  <dig> are determined and aggregated; in this example, there are no such states. therefore, the transition from fsm0: <dig> goes back to fsm0: <dig> when the input bit is  <dig>  this process is repeated for all newly added states in fsm <dig> 

fsm0: <dig> was added previously and is examined next. note that fsm0: <dig> is an aggregate of fsm: <dig> and fsm: <dig>  therefore, all states in the original fsm that can be reached from either fsm: <dig> or fsm: <dig> when the input at bit position is  <dig> are aggregated into fsm0: <dig>  in this example, fsm0: <dig> is created from fsm: <dig> and fsm: <dig>  because fsm0: <dig> does not already exist in fsm <dig>  it is added to fsm <dig> with a transient of  <dig> from fsm0: <dig>  again, there is no transition from fsm0: <dig> when the input bit is  <dig>  therefore, state fsm0: <dig> transitions back to fsm0: <dig> when the input bit is  <dig> 

this process is continued until there are no new states added to fsm <dig>  note that only unique new nodes are added to fsm <dig>  when a new node fsm0:n is created by aggregation but another node, fsm0:k, created by aggregating the same set of nodes already exists in fsm <dig>  then instead of inserting the new node, fsm0:n, a transition to fsm0:k is inserted into fsm <dig>  peptide matches are also handled using aggregation . this process is repeated for all bit positions resulting in the five separate bit-split fsms depicted in tabular form in tables  <dig>   <dig>   <dig>   <dig>  and  <dig> 

because several states from the original fsm that match different peptides may be combined into a single state in a bit-split fsm, a mechanism to indicate multiple matches is required. in the bit-split fsm, a vector of bits is used to encode the peptide matching attribute of for each state. for example, state fsm0: <dig>  matches peptides  <dig> and  <dig>  and therefore, has a peptide matching bit vector containing  <dig>  using this mechanism, after the various state machines enter their respective new states, a bitwise logical and operation can be used to determine the peptide match that all five fsms agree on. for example, assume that a some point in time, the bit-split fsms in tables  <dig>   <dig>   <dig>   <dig>  and  <dig> are in states fsm0: <dig>  fsm1: <dig>  fsm2: <dig>  fsm3: <dig>  and fsm4: <dig> with match bit vectors of  <dig>   <dig>   <dig>   <dig>  and  <dig>  respectively. the bitwise logical and of the five match bit vectors results in the bit vector  <dig> that indicates that peptide  <dig> is matched in this case. however, if fsm <dig> is in state fsm0: <dig>  with a matching bit vector of  <dig>  then the result of the logical and will result in  <dig>  indicating that no peptides are currently matched.

fpga implementation
the aho-corasick algorithm can be implemented in an fpga by directly using the table representation depicted in tables  <dig>   <dig>   <dig>   <dig>  and  <dig>  implementing the bit-split state machines in this manner  is more resource efficient as compared with encoding sequences of conditional state transitions in the fpga logic fabric. in modern fpgas, the tables can be stored using either configurable logic block resources  or blocks of random access memory . however, bram is more efficient when storing large tables because it has higher storage density than distributed ram  <cit> .

xilinx fpgas provide a large number of 18-kbit brams that can be organized into  <dig> rows of 36-bit wide words  <cit> . the xilinx brams are dual ported; therefore, by tying the high order bit of the 9-bit bram address input to  <dig> on one port and to  <dig> on the other port, the bram can be divided into two independent 9-kbit ram blocks containing  <dig> rows of 36-bit words each. altera fpgas also provide a large number of 9-kbit brams that can be organized into  <dig> rows of 36-bit wide words   <cit> .

a  <dig> by  <dig> bit block of ram can hold  <dig> rows of a bit-split aho-corasick fsm. recall that the bit-split fsm reads the row corresponding to the current state in order to output the peptide match bit vector and to determine the next state. the fsm can transition into one of two states  depending on the input value . because  <dig> bits are required to represent each of the  <dig> possible next state values,  <dig> bits in each 36-bit wide row are used for storing the two possible next state values. the remaining  <dig> bits in the row are used to store the  <dig> position peptide match bit vector.

in order to conserve signal routing resources, the consensus peptide match vector is converted into a 5-bit numerical value using a 20-to- <dig> bit priority encoder . the encoder essentially scans the consensus peptide match vector in increasing index order and returns the index of the first bit that has a value of  <dig>  therefore, peptides that appear near the beginning of the list of peptides have higher priority than those appearing later. if all consensus peptide match vector bits are clear , the priority encoder returns an undefined value. therefore, in order to indicate that a peptide has been found, a valid output signal is also generated when any of the consensus peptide match vector bits are set.

typically, proteomics pipelines require the detection of more than  <dig> peptides. in this case, several aho-corasick tiles can be utilized in parallel as shown in figure  <dig>  the input reading frame is simultaneously streamed to all tiles. the output of the tiles is combined into a single output peptide number using a priority encoder. because the priority encoder produces an undefined value when no peptide is matched, a match indicator signal is also generated when any of the tiles indicate a valid match.

using the architecture described above, each tile can detect up to  <dig> peptides in an input stream of reading frame data. however, because the tile has a capacity of only  <dig> states per bit-split fsm, in some cases, it may be necessary to reduce the number of peptides that can be detected in order to create a bit-split fsm with no more than  <dig> states . a simple iterative greedy algorithm can be employed to allocate peptides to tiles using a trial-and-error approach. initially, the algorithm assigns a set of  <dig> peptides to a tile. if the bit-split fsm for the given number of peptides has more than  <dig> states, the algorithm reduces the number of peptides assigned to the tile and tries again until the bit-split fsm is successfully created.

in order to minimize the number of states required in the aho-corasick implementation, strings beginning with the same sequence of characters should be grouped together into the same tile. this is because the strings will share the same initial states in the fsm. one way to achieve this is to sort the set of peptide strings in ascending alphabetical order before being assigned to the aho-corasick tiles.

additionally, this bit-split aho-corasick implementation architecture can only indicate a single peptide match at any given time. this is typically not a problem unless one peptide is a suffix of another peptide. peptide ps is a suffix of peptide p if and only if the length of p is greater than or equal to the length of ps and p ends with a substring that is identical to ps. in this case, if the string for p appears in the text, it is sufficient to simply indicate that p has been found because this also implies that ps has been found. the priority encoding architecture ensures that the detection of a match with p receives higher priority than ps as long as p appears before ps in the sorted set of peptide strings. therefore the sorting of the peptide string set must account for both alphabetical and suffix-based priority ordering.

analysis of fsm storage utilization efficiency
assume that pi,  <dig> = pi =  <dig>  is the number of peptides that can be detected by tile i. this means that in each bit-split fsm table row,  <dig> – pi bits are unused for indicating matches. furthermore, in a majority of cases, a bit-split fsm requires fewer than  <dig> states to detect pi peptides. this means that when fsmb of tile i requires si,b states, such that  <dig> <si,b =  <dig>  then  <dig> – si,b rows of available storage in the 9-kbit ram block are unused.

the storage utilization efficiency of a single  <dig> by  <dig> bit block used by a single bit-split fsm is computed as follows:

  ηi,b=16si,b+si,bpi256×36=si,b <dig>  

the overall storage utilization for an implementation requiring t tiles can be computed using the following expression:

  η=∑i=1t∑b=04si,b5×9216×t=∑i=1t∑b=04si,b46080t. 

RESULTS
the bit-split aho-corasick algorithm was implemented on the xilinx virtex- <dig> fx- <dig> fpga. this device has  <dig> 18-kbit bram blocks, of which  <dig> are used for implementing aho-corasick tiles and the remaining  <dig> are reserved for meeting the storage requirements of other modules that support the implementation .

recall that a xilinx bram can be configured as two 9-kbit ram blocks. this means that there are effectively  <dig> ram blocks available that can hold a total of  <dig> tiles. because each tile requires five 9-kbit ram blocks and can search for at most  <dig> peptides, the maximum number of peptides that can be searched using this device is  <dig> × 20/ <dig> =  <dig> . note that larger fpga devices can be used to search for more than  <dig> peptides in a single pass. for example, the virtex- <dig> fx- <dig> has  <dig> bram blocks that can be configured to hold over  <dig>  peptides. for the experiments, sets of  <dig>  peptides were derived by performing in-silico trypsin digestion on reading frames corresponding to chromosome  <dig> of the human genome. the maximum size of the peptides was fixed at  <dig> amino acids. however, in order to measure the effect of peptide size on the storage efficiency, the minimum size was varied in order to produce  <dig> unique sets each of peptides with minimum sizes of  <dig>   <dig>   <dig>  and  <dig> 

the number of tiles required for the peptide sets with the minimum peptide length of  <dig> amino acids  varies between  <dig> and  <dig> with an average of  <dig>  peptides detected per tile. the average storage utilization is a much higher  <dig> %.

the average number of tiles required for the peptide sets with the minimum peptide length of  <dig> amino acids  is  <dig>  with an average of  <dig>  peptides detected per tile. the average storage utilization is relatively high at  <dig> %. this efficiency is comparable to the efficiency of the peptide sets with average size of  <dig> . however, while in the case of the shorter peptides, underutilization of row storage is the main cause of inefficiency, for longer peptides, underutilization of the peptide match vector storage has a larger contribution to the overall inefficiency.

the average number of tiles required for the peptide sets with the minimum peptide length of  <dig> amino acids  is  <dig>  with an average of  <dig>  peptides detected per tile. the number of tiles required is significantly larger than in the previous cases because the bit-split fsms have more states. the storage efficiency is also reduced to  <dig> % because of significant underutilization of match vector storage.

the runtime performance of the fpga-based bit-split aho-corasick implementation was compared to the performance of the aho-corasick implementation on a standard workstation. the bit-split aho-corasick design with supporting elements such as an embedded powerpc processor, an ata hard disk controller, an rs <dig> link, system busses, and memory are synthesized to run at a clock frequency of  <dig> mhz. the ata disk controller is used for reading data at a peak rate of  <dig> mb/s . the powerpc is responsible for initializing the disk drive and initiating the read operations. the powerpc also monitors the peptide match indications from the tiles and reports match data  to the host workstation over the rs <dig> link.

simulation results show that the aho-corasick tiles can operate at frequencies over  <dig> mhz, resulting in input rates exceeding  <dig>  gigabits per second. although the aho-corasick tiles can operate at faster frequencies, in this series of experiments the clock frequency was restricted to execute at  <dig> mhz system clock in order to eliminate the complexity that arises with designs containing multiple clock domains. essentially, the aho-corasick tiles operate at  <dig> mhz in order to match the ata controller's peak data delivery rate of  <dig> mb/s. note that the tiles do not introduce any processing delays . furthermore, in order to minimize processing and concomitant delays associated with a file system, the reading frame data is stored on consecutive sectors on a raw disk .

reading frame data is derived using software on a standard workstation by concatenating all the chromosomes in the human genome  and subsequently translating the concatenated genome data into reading frames. the six resulting reading frames are also concatenated together, giving  <dig> , <dig>  bytes of text to be searched for a set of  <dig>  peptides. the reading frame data is written to  <dig> , <dig> consecutive sectors on an ide disk drive, at a known starting location. a database of reading frame data for various genomes can be maintained in a similar manner on a large disk drive.

for testing the performance of the fpga-based implementation, the disk drive containing the reading frame data is connected to the fpga board. a flash ram module containing the aho-corasick implementation configuration file and ram block content implementing the fsm is also connected to the board. on bootup, the fpga board reads the configuration information from the flash ram and begins executing the aho-corasick algorithm.

for these experiments, a set of  <dig>  peptides that fit in exactly  <dig> tiles  was selected. note that storage efficiency of the selected peptide set has no bearing on the runtime performance of the bit-split aho-corasick implementation. this is because the aho-corasick tiles each search for a subset of  <dig> peptides in parallel. the performance of the fpga-based implementation was compared with the performance of a software implementation employing a traditional table-driven aho-corasick organization in which a single large table represents a single fsm with all the states for all  <dig>  peptides. the software implementation was executed on a windows xp workstation having a  <dig>  ghz intel core <dig> duo processor,  <dig> gb ram, and a pair of serial ata disks configured as a raid  <dig> disk drive , formatted as an ntfs volume.

five runs each of the fpga and workstation implementations were performed. the fpga implementation takes, on average,  <dig>  seconds to process the entire  <dig> gigabytes of reading frame data. the workstation implementation takes an average of  <dig>  seconds to complete the search. this means that the fpga-based implementation is nearly  <dig> times faster than the workstation implementation.

implementations of larger designs in fpgas typically have lower operating frequencies as compared with smaller designs. therefore, in order to study the practical limits of implementations with large numbers of tiles, xilinx's fpga application development tool, xst  <dig> , was used to implement a number of designs with varying number of aho-corasick tiles for a hypothetical board containing the virtex- <dig> fx- <dig> device. table  <dig> lists the performance statistics of the designs reported by xst. the smallest design composed of  <dig> tiles, requiring  <dig> bram blocks with a capacity of  <dig> peptides operates at a frequency of  <dig>  mhz. the largest design composed of  <dig> tiles, requiring  <dig> bram blocks with a capacity of  <dig>  peptides operates at a frequency of  <dig>  mhz. clearly, even the largest design meets the  <dig> mhz frequency requirement.

CONCLUSIONS
this paper describes a technique for accelerating string set matching implementation using fpgas for use in proteomics processing pipelines. fpgas provide a large number of embedded memory blocks that enable more efficient implementation of fsms than possible using the fpga logic fabric. furthermore, the synthesized tile-based design can be reused for different peptide sets by simply initializing the ram block content with appropriate bit-split fsm state data. this is much faster than having to rerun the significantly time consuming "placing and routing" synthesis stages required for logic-based implementations in fpga fabric for each new peptide set.

empirical results show that the fpga-based implementation outperforms the workstation implementation by a factor of  <dig>  this result shows that using specialized hardware to solve the string set matching problem can make a significant impact on the runtime of a number of computational biology processes where exact string matching is commonly required. the throughput of fpga implementation described here is essentially limited by the data transfer speed of the ata disk drives. higher frequency implementations utilizing serial ata  disk drives, parallel disk arrays, and gigabit ethernet interfaces under investigation as part of ongoing implementation efforts and future research.

this paper also demonstrates that the significantly smaller string alphabets found in computational biology enable more space efficient designs for string matching as compared to previously published implementations focused on network intrusion detection. although the case study focused on exact string matching, the aho-corasick algorithm can also accommodate regular expressions. the implementation described can easily be adapted for other types of search using, for example, spaced seeds.

the implementation presented here is restricted to searching for a maximum of  <dig>  peptides. two different approaches can be used to overcome this limitation. the simplest technique is to perform multiple passes over the string data such that a different subset of the peptides is encoded in the tiles during each pass. this approach requires only a single fpga, but increases the overall search time by a factor given by the following expression:

  f=⌈total number of peptides4000⌉. 

in other words, the complexity of the search becomes o).

a more performance oriented approach would be to use f separate fpgas performing the search on separate subsets of the peptides in parallel. the cost of replicating the reading frame data for a large f can be eliminated by implementing a data streaming interface between the separate fpga boards. tools to facilitate building such interfaces are typically provided by the fpga vendors  <cit> . using such an interface, only one board needs to be connected to a single disk drive containing the reading frames while the other boards are connected to each other in a chain. this way, the reading frame data can be streamed from the disk drive to each board . the runtime complexity of this latter implementation is essentially o, where λ represents the cumulative latency of transmitting a single character over the entire chain. the λ value will typically be negligibly small because modern fpgas are capable of performing serial communication at gigabit per second  rates.

authors' contributions
ysd developed the algorithm and implementation for string matching in fpga hardware and conducted the experiments. smb, scb, and ml formulated the proteogenomic mapping pipeline problem, identified the string matching bottleneck, provided data for developing and testing the system, and assisted with the analysis of results. ysd and smb wrote the manuscript.

