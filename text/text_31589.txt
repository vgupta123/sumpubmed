BACKGROUND
knowing where a protein resides in a cell can help biologists elucidate the functions of the protein. with the accomplishment of the various large-scale genome sequencing projects, an exponentially growing number of new protein sequences have been discovered
 <cit> . computation methods are required to automatically and accurately identify the subcellular locations of these proteins.

conventional methods for subcellular-localization prediction can be roughly divided into sequence-based methods and annotation-based methods. sequence-based methods include:  sorting-signals based methods, such as psort
 <cit> , wolf psort
 <cit> , targetp
 <cit>  and signalp
 <cit> ;  composition-based methods, such as amino-acid compositions 
 <cit> , amino-acid pair compositions 
 <cit> , gapped amino-acid pair compositions 
 <cit> , and pseudo amino-acid composition 
 <cit> ; and  homology-based methods, such as proteome analyst
 <cit> , pairprosvm
 <cit>  and other predictors
 <cit> .

annotation-based methods make use of the correlation between the annotations  of a protein and its subcellular localization. among them, methods based on gene ontology  information are more attractive. gene ontology a is a set of standardized vocabularies that annotate the function of genes and gene products across different species. the term ‘ontology’ originally refers to a systematic account of existence. in the go database, the annotations of gene products are organized in three related ontologies: cellular components, biological processes, and molecular functions. cellular components refer to the substances that constitute cells and living organisms. example substances are proteins, nucleic acids, membranes, and organelles. majority of these substances are located within the cells, but there are also substances locating outside the cells . a biological process is a sequence of events achieved by one or more ordered assemblies of molecular functions. a molecular function is achieved by activities that can be performed by individual or by assembled complexes of gene products at the molecular level.

as a result of the go consortium annotation effort, the gene ontology annotation  databaseb has become a large and comprehensive resource for proteomics research
 <cit> . the database provides structured annotations to non-redundant proteins from many species in uniprot knowledgebase 
 <cit>  using standardized go vocabularies through a combination of electronic and manual techniques. the large-scale assignment of go terms to uniprotkb entries  was done by converting a proportion of the existing knowledge held within the uniprokb database into go terms
 <cit> . the go annotation database also includes a series of cross-references to other databases. thus, the systematic integration of go annotations and uniprotkb database can be exploited for subcellular localization. specifically, given the accession number of a protein, a set of go terms can be retrieved from the go annotation database filec. in uniprokb, each protein has an accession number, and in the go annotation database, each accession number may be associated with zero, one or more distinct go terms. conversely, one go term may be associated with zero, one, or many different accession numbers. this means that the mappings between accession numbers and go terms are many-to-many.

from the perspective of go terms extraction, the go-based predictors can be classified into three categories:  using interproscan
 <cit>  to search against a set of protein signature databases
 <cit> ;  using the accession numbers of proteins to search against the go annotation database such as euk-oet-ploc
 <cit> , hum-ploc
 <cit> , euk-mploc
 <cit> , gneg-ploc
 <cit>  and an integrated method
 <cit> ; and  using the accession numbers of homologous proteins retrieved from blast
 <cit>  to search against the go annotation database, such as proloc-go
 <cit> , iloc-virus
 <cit> , iloc-gneg
 <cit>  and cell-ploc  <dig> 
 <cit> .

however, there exist multi-location proteins that can simultaneously reside at, or move between, two or more different subcellular locations. unfortunately, most of the existing methods are limited to the prediction of single-location proteins. these methods generally exclude the multi-label proteins or are based on the assumption that multi-location proteins do not exist. actually, proteins with multiple locations play important roles in some metabolic processes that take place in more than one compartment, such as fatty acid β-oxidation in the peroxisome and mitochondria, and antioxidant defense in the cytosol, mitochondria and peroxisome
 <cit> .

there are a few predictors
 <cit>  specifically designed for predicting viral proteins, generated by viruses in various cellular compartments of the host cell or virus-infected cells. studying the subcellular localization of viral proteins enables us to obtain the information about their destructive tendencies and consequences
 <cit> . it is also beneficial to the annotation of the functions of viral proteins and the design of antiviral drugs. to the best of our knowledge, there are two predictors, namely virus-mploc
 <cit>  and iloc-virus
 <cit> , capable of predicting multi-label viral proteins. iloc-virus performs better than virus-mploc because the former has a better formulation for reflecting go information and has a better way to predict the number of subcellular location sites of a query protein
 <cit> . recently, a method called knn-svm ensemble classifier
 <cit>  is proposed to deal with multi-label proteins, including viral proteins. it was found that the performance of the knn-svm predictor is comparable to iloc-virus and is better than virus-mploc.

conventional methods specializing for plant proteins, such as targetp
 <cit>  and predotar
 <cit> , can only deal with single-label proteins. plant-mploc
 <cit>  and iloc-plant
 <cit>  are state-of-the-art predictors that can deal with single-label and multi-label proteins of plants. iloc-plant performs better than plant-mploc because of the similar improvement as in iloc-virus versus virus-mploc.

this paper proposes an efficient multi-label predictor, namely mgoasvm, for multi-label protein subcellular localization prediction. here, the prefix “m” stands for multiple, meaning that the predictor can deal with proteins with multiple subcellular locations. mgoasvm is different from other predictors in that  it adopts a new decision scheme for an svm classifier so that it can effectively deal with datasets containing both single-label and multi-label proteins;  it selects a set of distinct, relevant go terms to form a more informative go subspace;  it constructs the go vectors by using the frequency of occurrences of go terms instead of using 1- <dig> values
 <cit>  for indicating the presence or absence of some predefined go terms. the results on two benchmark datasets and a newly created dataset full of novel proteins demonstrate that these three properties enable mgoasvm to predict multi-location proteins and outperform the state-of-the-art predictors such as iloc-virus and iloc-plant.

localization via direct table lookup
because the cellular component go terms have already been annotated with cellular component categories, it seems that what we need is to create a lookup table using the cellular component go terms as the keys and the component categories as the hashed values. such a naive solution, however, is undesirable, as will be explained below.

although the cellular component ontology is directly related to the subcellular localization, we cannot simply use its go terms to determine the subcellular locations of proteins. the reason is that some proteins do not have cellular component go terms. even for proteins annotated with cellular-component go terms, it is inappropriate to use these terms only to determine their subcellular localizations. the reason is that a protein could have multiple cellular-component go terms that map to different subcellular localizations, which are highly likely to be inconsistent with the true subcellular locations of proteins. another reason is that proteins with annotated subcellular localization in swiss-prot may still be marked as ‘cellular component unknown’ in the go database
 <cit> . because of this limitation, it is necessary to use the other two ontologies as well because they are also relevant  to the subcellular localization of proteins.

to exemplify the above discussion, we created a lookup table  and developed a table-lookup procedure to predict the subcellular localization of the proteins in the virus dataset ). table
 <dig> has two types of go terms: essential go terms and child go terms. as the name implies, the essential go terms
 <cit>  are go terms that are essential or critical for the subcellular localization prediction. in addition to the essential go terms, their direct descendants  also possess direct localization information. the relationships between child terms and their parent terms include ‘is a’, ‘part of’ and ‘occurs in’
 <cit> . the former two correspond to cellular component go terms and the third one typically corresponds to biological process go terms. as we are more interested in cellular component go terms, the ‘occurs in’ relationship will not be considered. for ease of reference, we refer to both essential go terms and their child terms as ‘explicit go terms’.

explicit go terms include essential go terms and their child terms. the definition of essential go terms can be found in
 <cit> . here the relationship includes ‘is a’ and ‘part of’ only, because only cellular component go terms are analyzed here. relationship: the relationship between child terms and their parent essential go terms;

no. of terms: the total number of explicit go terms in a particular class.

*:host endoplasmic reticulum.

for each class in table
 <dig>  the child terms were obtained by presenting the corresponding essential go term to the quickgo server
 <cit> d.

given a query sequence, we first obtain its ‘go-term’ set from the go annotation database. then, if one  of the terms in this set matches an essential go term in table
 <dig>  the subcellular location set of this query protein is predicted to be the one  corresponding to the matched go term. for example, if the set of go terms contains go: <dig>  then this query protein is predicted as ‘viral capsid’; or if the set of go terms contains both go: <dig> and go: <dig>  then this query protein is predicted as ‘host cytoplasm’ and ‘host nucleus’. further, if none of the terms in this set matches any essential go terms but one  of the terms in this set match any child terms in table
 <dig>  then the query protein is predicted as belonging to the class associated with the child go term. for example, if no essential go terms can be found in the set but go: <dig> is found, then the query protein is predicted as ‘viral capsid’; or if go: <dig>  go: <dig> and go: <dig> are found, then the query protein is predicted as ‘host cell membrane’, ‘host endoplasmic reticulum’ and ‘host cytoplasm’.

a major problem of this table lookup procedure is that the go terms of a query protein may contain many essential go terms and/or have child terms spanning across more classes than the number of true subcellular locations, causing over-prediction. for example, in the virus dataset,  <dig>   <dig> and  <dig>  proteins have explicit go terms that map to two, three and four locations, and  <dig>  proteins have explicit go terms that map to one location. by comparing with the true locations, there are totally  <dig> proteins whose explicit go terms are consistent with their true locations, of which there are  <dig> single-label proteins,  <dig> two-label proteins and  <dig> three-label proteins. this means that only about 67%  proteins are likely to be predicted correctlyd. this analysis suggests that direct table lookup is not a desirable approach and this motivates us to develop machine learning methods for go-based subcellular localization prediction.

RESULTS
datasets
in this paper, the virus dataset used in virus-mploc
 <cit>  and iloc-virus
 <cit>  and the plant dataset used in plant-mploc
 <cit>  and iloc-plant
 <cit>  were used to evaluate the performance of mgoasvm.

the virus dataset was created from swiss-prot  <dig> . it contains  <dig> viral proteins distributed in  <dig> locations ). of the  <dig> viral proteins,  <dig> belong to one subcellular locations,  <dig> to two locations,  <dig> to three locations and none to four or more locations. this means that about 20% of proteins are located in more than one subcellular location. the sequence identity of this dataset was cut off at 25%.

the plant dataset was created from swiss-prot  <dig> . it contains  <dig> plant proteins distributed in  <dig> locations ). of the  <dig> plant proteins,  <dig> belong to one subcellular locations,  <dig> to two locations,  <dig> to three locations and none to four or more locations. in other words, 8% of the plant proteins in this dataset are located in multiple locations. the sequence identity of this dataset was cut off at 25%.

performance metrics
to facilitate performance comparison, the concepts of locative proteins
 <cit>  and actual proteins were introduced here. if a protein exists in two different subcellular locations, it will be counted as two locative proteins; if a protein coexists in three locations, then it will be counted as three locative proteins; and so forth. but no matter how many subcellular locations a protein simultaneously resides, it will be counted as only one actual protein. mathematically, denote nloc as the total number of locative proteins, nactas the total number of actual proteins, m as the number of subcellular locations, nact  as the number of actual proteins coexisting in m subcellular locations. then, the nact and nloc can be expressed as: 

  nact=∑m=1mnact 

  nloc=∑m=1mm·nact 

in the virus dataset, m=6; and in the plant dataset, m= <dig>  then, from eq.  <dig> and eq.  <dig>  we obtain 

  nactv=165+39+3= <dig> 

  nlocv=1×165+2×39+3×3+∑m=46m×0= <dig> 

  nactp=904+71+3= <dig> 

  nlocp=1×904+2×71+3×3+∑m=412m×0= <dig> 

where the superscript v and p stand for the virus and plant datasets, respectively. thus, for the virus dataset,  <dig> actual proteins correspond to  <dig> locative proteins; and for the plant dataset,  <dig> actual proteins correspond to  <dig> locative proteins. the breakdown of these two benchmark datasets were shown in table
 <dig> and table
 <dig> 

in statistical prediction, leave-one-out cross validation  is considered to be the most rigorious and bias-free method
 <cit> . hence, loocv was used to examine the performance of mgoasvm. in each fold of loocv, a protein of the dataset  was singled out as the test protein and the remaining  proteins were used as the training data. this procedure was repeated n times and in each fold a different protein was selected as the test protein. this ensures that every protein in the dataset will be tested. here, ‘proteins’ refers to ‘actual proteins’ rather than ‘locative proteins’; otherwise the training set will contain identical proteins distributed across multiple classes, which violates the svm learning requirement that positive-class training patterns must be different from the negative-class training patterns.

the locative accuracy
 <cit>  and actual accuracy were used to measure the performance of multi-label predictors. specifically, denote
ℒ and
ℳ as the true label set and the predicted label set for the i-th protein pi, respectively. then, the overall locative accuracy is: 

  Λloc=1nloc∑i=1nact|ℳ∩ℒ| 

where |·| means counting the number of elements in the set therein and ∩ represents the intersection of sets. and the overall actual accuracy is: 

  Λact=1nact∑i=1nactΔ 

where 

  Δ= <dig>  ifℳ≡ℒ <dig>  otherwise. 

according to eq.  <dig>  a locative protein is considered to be correctly predicted if any of the predicted labels matches any labels in the true label set. on the other hand, eq.  <dig> suggests that an actual protein is considered to be correctly predicted only if all of the predicted labels match those in the true label set exactly. for example, for a protein coexist in, say, three subcellular locations, if only two of the three are correctly predicted, or the predicted result contains a location not belonging to the three, the prediction is considered to be incorrect. in other words, when and only when all the subcellular locations of a query protein are exactly predicted without any overprediction or underprediction, can the prediction be considered as correct. therefore, the actual accuracy is stricter than the locative accuracy.

despite its strict criteria, the actual accuracy is regarded to be more objective than the locative accuracy. locative accuracy is liable to give biased performance measure when the predictor tends to over-predict, i.e., giving large
|ℳ| for many pi. in the extreme case, if we predict every protein in the virus dataset to have all of the  <dig> subcellular locations, according to eq.  <dig>  the locative accuracy is 100%. but obviously, the predictions are wrong and meaningless. on the contrary, if we use the actual accuracy as the performance measure in this extreme case, the actual accuracy will be 0%, which definitely conforms to what we expect.

comparison with state-of-the-art predictors
table
 <dig> compares the performance of mgoasvm against two state-of-the-art virus-specialized multi-label predictors on the virus dataset. both virus-mploc
 <cit>  and iloc-virus
 <cit>  use the accession numbers of homologs returned from blast
 <cit>  as searching keys to retrieve go terms from the goa database. the knn-svm ensemble classifier
 <cit>  uses the true accession number of proteins directly as input. for a fair comparison with these two predictors, the performance of mgoasvm shown in table
 <dig> was obtained by using the accession numbers of homologous proteins as the searching keys. like virus-mploc and iloc-virus, mgoasvm uses blast
 <cit>  to find the homologs and then uses the accession numbers of the homologs as the searching keys. here, mgoasvm selects the top homolog for each protein. if blast cannot find a homolog for a protein, we assign zeros to all entries of the corresponding go vectors. in the virus dataset, a homolog can always be found for every protein.

“–” means the corresponding references do not provide the overall actual accuracy. knn-svm: the knn-svm ensemble classifier proposed in
 <cit> . host er: host endoplasmic reticulum.

table
 <dig> compares the performance of mgoasvm against two state-of-the-art plant-specialized multi-label predictors on the plant dataset. plant-mploc
 <cit>  uses similar methods as virus-mploc, and iloc-plant
 <cit>  uses similar methods as iloc-virus. here mgoasvm also selects the top homolog for each protein.

as shown in table
 <dig>  for the virus dataset, mgoasvm performs significantly better than virus-mploc and iloc-virus; for the plant dataset, mgoasvm also performs remarkably better than plant-mploc and iloc-plant. in the virus dataset, both the overall locative accuracy and overall actual accuracy of mgoasvm are more than 14%  higher than iloc-virus ; and in the plant dataset, the corresponding two measures are more than 19%  higher than iloc-plant . mgoasvm also performs significantly better than knn-svm ensemble classifier in terms of overall locative accuracy ; except for the host cytoplasm, mgoasvm is more accurate than knn-svm in predicting all subcellular locations. the results on both datasets demonstrate that mgoasvm is more capable of handling multi-label problems than virus-mploc, iloc-virus, knn-svm ensemble classifier, plant-mploc and iloc-plant. as for the individual locative accuracy, in the virus dataset, except for the “viral capsid” for which all of mgoasvm, virus-mploc and iloc-virus reach 100%, the locative accuracies of mgoasvm are remarkably higher than those of virus-mploc and iloc-virus; while in the plant dataset, the individual locative accuracies of mgoasvm for all of the  <dig> locations are impressively higher than those of plant-mploc and iloc-plant.

kernel selection and optimization
a support vector machine  can use linear, rbf or polynomial function as its kernel. some works
 <cit>  have demonstrated that rbf kernels achieve better results than linear and polynomial kernels. however, our results show that linear svms perform better in our case. table
 <dig> shows the performance of mgoasvm using different types of kernel functions with different parameters based on leave-one-out cross validation  using the virus dataset. for rbf svm, the kernel parameter σ was selected from the set {2− <dig> − <dig> …,25}. for polynomial svm, the degree of polynomial was set to either  <dig> or  <dig>  the penalty parameter  was set to  <dig>  for all cases. table
 <dig> shows that svms that use the linear kernel perform better than that with rbf and polynomial kernels. this is plausible because the dimension of go vectors is larger than the number of training vectors, aggravating the curse of dimensionality problem in non-linear svms
 <cit> . the over-fitting problem becomes more severe when the degree of non-linearity is high , leading to degradation in performance, as demonstrated in table
 <dig>  in other words, highly nonlinear svms become vulnerable to overfitting due to the high-dimensionality of the go vectors.

the penalty parameter  was set to  <dig>  for all cases. σis the kernel parameter for the rbf svm; d is the polynomial degree in the polynomial svm.

analysis of mgoasvm
table
 <dig> shows the performance of the go-vector construction methods. linear svms were used in both cases, and the penalty factor was set to  <dig> . the results show that term-frequency  achieves a bit better performance than 1- <dig> value in the locative accuracy, but performs almost 2% and 7% better than 1- <dig> value in the actual accuracy for the virus dataset and the plant dataset, respectively, which demonstrates that the frequencies of occurrences of go terms could also provide information for subcellular locations. the results are biologically relevant because proteins of the same subcellular localization are expected to have a similar number of occurrences of the same go term. in this regard, the 1- <dig> value approach is inferior because it quantizes the number of occurrences of a go term to  <dig> or  <dig>  moreover, the more remarkable improvement achieved for the plant dataset than that for the virus dataset also suggests that the term-frequency  construction method can boost the performance more impressively for datasets with larger size and more multi-label proteins.

to reveal that the high locative accuracies of mgoasvm are due to the capability of mgoasvm rather than due to over-prediction, we have investigated the distributions of the number of predicted labels in both virus and plant datasets. we consider
|ℳ| and
|ℒ|  in eq.  <dig> as the number of predicted labels and the number of true labels for the i-th protein, respectively. the distributions of the number of labels predicted by mgoasvm are shown in table
 <dig>  denote
nko,
nke or
nku as the number of proteins that are over-, equal-, and under-predicted by k  labels. also denote no, ne or nu as the total number of proteins that are over-, equal-, and under-predicted, respectively. here, over-prediction, equal-prediction and under-prediction are respectively defined as the number of predicted labels that is larger than, equal to, and smaller than the number of true labels. table
 <dig> shows that proteins that are over- or under-predicted account for a small percentage of the datasets only . even among the proteins that are over-predicted, most of them are over-predicted by one location only. these include all of the  <dig> proteins in the virus dataset, and  <dig> out of  <dig> in the plant dataset. none of the proteins in the virus dataset are over-predicted by more than  <dig> location. only  <dig> out of  <dig> proteins in the plant dataset are over-predicted by  <dig> locations, and none are over-predicted by more than  <dig> locations. as for under-prediction, all of the under-predicted proteins are only under-predicted by  <dig> location in both datasets. these results demonstrate that the over-prediction and under-prediction percentages are small, which suggests that mgoasvm can effectively determine the number of subcellular locations of a query protein.

ℳ: number of predicted labels for the i-th  protein;
ℒ: number of the true labels for the i-th protein; over-prediction: the number of predicted labels is larger than that of the true labels; equal-prediction: the number of predicted labels is equal to that of the true labels; under-prediction: the number of predicted labels is smaller than that of the true labels;
nko,nke or
nku: the number of proteins that are over-, equal-, or under-predicted by k  labels, respectively; no, ne or nu: the total number of proteins that are over-, equal-, or under-predicted, respectively.

table
 <dig> shows the performance of mgoasvm with different inputs and different numbers of homologous proteins for the virus and plant datasets. the input data can be of three possible types:  accession number only,  sequence only and  both accession number and sequence. mgoasvm can extract information from these inputs by producing multiple go vectors for each protein. denote #homo as the number of homologous proteins, where #homo∈{ <dig> , <dig> ,8} for the virus dataset and #homo∈{ <dig> ,2} for the plant dataset. for different combinations of inputs and numbers of homologs, the number of distinct go terms can be different. typically, the number of distinct go terms increases with the number of homologs.

s: sequence; ac: accession number; #homo: number of homologs used in the experiments; nd: number of distinct go terms. #homo= <dig> means only the true accession number is used.

table
 <dig> shows that the number of homologs can affect the performance of mgoasvm. the results are biologically relevant because the homologs can provide information about the subcellular locations. however, more homologs may bring redundant or even noisy information, which are detrimental to the prediction accuracy. for example, in the plant dataset, the performance of using one homolog is better than that of using two , which in turn suggests that we should limit the number of homologs to avoid bringing irrelevant information. moreover, as can be seen from table
 <dig>  the performance achieved by mgoasvm using sequences with the top homolog are comparable to that of mgoasvm using the accession number only.

table
 <dig> shows that mgoasvm using both sequences and accession numbers performs better than using sequences only, but worse than using accession numbers.

table
 <dig> shows the performance of mgoasvm for multi-location proteins using different inputs. denote l  as the number of co-locations. as the maximum number of co-locations in both datasets is  <dig>  the individual actual accuracies for l  are shown in table
 <dig>  note that high actual accuracies for l> <dig> are more difficult to achieve than that for l= <dig>  since not only the number of subcellular locations for a protein should be predicted correctly, but also the subcellular locations should be predicted precisely. as can be seen, mgoasvm achieves high performance not only for single-label proteins , but also for multi-label proteins . the results demonstrate that mgoasvm can tackle multi-label problems well.

s: sequence; ac: accession number; #homo: number of homologs used in the experiments; l : number of co-locations. #homo= <dig> means only the true accession number is used.

prediction of novel proteins
dataset construction
to further demonstrate the effectiveness of mgoasvm, a plant dataset containing novel proteins was constructed by using the criteria specified in
 <cit> . the complete procedures of constructing the novel dataset can be found in the mgoasvm web-server. specifically, to ensure that the proteins are really novel to mgoasvm, the creation dates of these proteins should be significantly later than the training proteins  and also later than the goa database. because the plant dataset was created in  <dig> and the goa database used was released on 08-mar- <dig>  we selected the proteins that were added to swiss-prot between 08-mar- <dig> and 18-apr- <dig>  moreover, proteins with multiple subcellular locations that falls within the  <dig> classes specified in table
 <dig> were included. after limiting the sequence similarity to 25%,  <dig> plant proteins distributed in  <dig> subcellular locations  were selected. of the  <dig> plant proteins,  <dig> belong to one subcellular location,  <dig> belong to two locations,  <dig> belong to three locations and none to four or more locations. in other words, 16% of the plant proteins in this novel dataset are located in multiple locations. the protein sequences of this new dataset can be donwloaded from the mgoasvm server.

the dataset was constructed from swiss-prot created between 08-mar- <dig> and 18-apr- <dig>  the sequence identity of the dataset is below 25%.

prediction procedure
because the novel proteins were recently added to swiss-prot, many of them have not been annotated in the goa database. as a results, if we used the accession numbers of these proteins to search against the goa database, the corresponding go vectors will contain all zeros. this suggests that we should use the acs of their homologs as the searching keys, i.e., the procedure shown in figure
 <dig> using sequences as input should be adopted. however, we observed that for some novel proteins, even the top homologs do not have any go terms annotated to them. to overcome this limitation, the following procedure was adopted. for the proteins whose top homologs do not have any go terms in the goa database, we used the second-top homolog to find the go terms; similarly, for the proteins whose top and 2-nd homologs do not have any go terms, the third-top homolog was used; and so on until all the query proteins can correspond to at least one go term. in the case where blast fails to find any homologs, we used the method pseaa
 <cit>  as a back-up. in this dataset, among  <dig> proteins,  <dig> of them require to use the backup method.

because blast searches were used in the above procedure, the prediction performance will depend on the closeness  between the training proteins and test proteins. to determine the number of test proteins that are close homologs of the training proteins, we performed a blast search for each of the test proteins. the e-value threshold was set to  <dig> so that none of the proteins in the lists returned from blast have e-value larger than  <dig>  then, we identified the training proteins in the lists based on their accession numbers, and recorded their corresponding e-values.

figure
 <dig> shows the distribution of the e-values, which quantify the closeness between the training proteins and test proteins. if we use a common criteria that homologous proteins should have e-value less than 10− <dig>  then  <dig> out of  <dig> test proteins are homologs of training proteins, which account for 42% of the test set. note that this homologous relationship does not mean that using blast’s homology transfers can predict all of the test proteins correctly. in fact, blast’s homology transfers  can only achieve a prediction accuracy of  <dig> % . as the prediction accuracy of mgoasvm on this test set  is significantly higher than this percentage, the extra information available from the goa database plays a very important role in the prediction.

prediction performance
table
 <dig> shows the prediction performance of mgoasvm on this novel protein dataset. as explained earlier, to ensure that these proteins are novel to mgoasvm,  <dig> proteins of the plant dataset ) were used for training the classifier. we compared mgoasvm with the plant-mploc
 <cit>  web-servere. as shown in table
 <dig>  mgoasvm performs significantly better than plant-mploc. the overall locative accuracy and the overall actual accuracy of mgoasvm are more than 17%, 21% higher than those of plant-mploc, respectively . for most of  <dig> individual subcellular locations, mgoasvm outperforms plant-mploc, except in cell membrane and peroxisome. given the novelty and multi-label properties of these proteins and the low sequence similarity , the locative accuracy of  <dig> % and the actual accuracy of  <dig> % achieved by mgoasvm are fairly high. on the other hand, due to the scarcity of data, mgoasvm does not perform well in some subcellular locations, such as cell wall and plastid. but the situation will be improved when more and more proteins are available for training our svm classifiers.

discussion
mgoasvm possesses several desirable properties that make it outperform virus-mploc
 <cit> , iloc-virus
 <cit> , plant-mploc
 <cit>  and iloc-plant
 <cit> , which are specified subsequently.

go-vector construction
virus-mploc and plant-mploc construct go vectors by using 1- <dig> value to indicate the presence and absence of some predefined go terms. this method is simple and logically plausible, but some information will be inevitably lost because it quantizes the frequency of occurrences of go terms to either  <dig> or  <dig>  the go vectors in iloc-virus and iloc-plant contain more information than those in virus-mploc and plant-mploc, because the former two consider not only the go terms of the query protein but also the go terms of its homologs. specifically, instead of using 1- <dig> value, each element of the go vectors in the iloc-virus and iloc-plant represents the percentage of homologous proteins containing the corresponding go term. however, the method ignores the fact that a go term may be used to annotate the same protein multiple times under different entries in the go annotation database. on the contrary, mgoasvm uses the frequency of occurrences of go terms to construct the go vectors. intuitively, this is because proteins of the same subcellular localization tend to be annotated by similar sets of go terms. the advantages of using the go term-frequency count as features is evident by the superior results in table
 <dig> 

capability of handling multi-label problems
an efficient way to handle multi-label problems is to predict the number of labels for each sample first, and then to predict the specific label set for each sample according to the order of the scores. let us compare mgoasvm with two kinds of existing approaches. 

• when predicting the number of subcellular locations for a query protein, iloc-virus and iloc-plant determine the number of labels of a query protein based on the number of labels of its nearest training sample. mgoasvm, on the contrary, determines the number of labels for a query protein by looking at the number of positive-class decisions among all of the one-vs-rest svm classifiers. therefore, the number of labels depends on the whole training set as opposed to the query protein’s nearest neighbor in the training set.

• as opposed to virus-mploc and plant-mploc which require a pre-defined threshold, our mgoasvm adopts a machine learning approach to solving the multi-label classification problem. the predicted class labels in mgoasvm are assigned based on the svms that produce positive responses to the query protein.

in summary, the superiority of mgoasvm in handling multi-label problems is evident in table
 <dig> 

from the machine learning perspective, prediction of multi-location proteins is a multi-label learning problem. approaches to addressing this problem can be divided into types: problem transformation and algorithm adaptation
 <cit> . the multi-label knn classifiers used in iloc-plant and iloc-virus belong to the first type whereas our multi-label svm classifier belongs to the second type. while our results show that multi-label svms perform better than multi-label knn, further work needs to be done to compare these two types of approaches in the context of multi-label subcellular localization.

go subspace selection
to facilitate the sophisticated machine learning approach for the multi-label problem, go subspace selection is adopted. unlike the traditional methods
 <cit>  which use all of the go terms in the go annotation database to form the go-vector space, mgoasvm selects a relevant go subspace by finding a set of distinct, relevant go terms. with the rapid growth of the go database, the number of go terms is also increasing. as of march  <dig>  the number of go terms is  <dig>  which means that without feature selection, the go vectors will have dimension  <dig>  this imposes computational burden on the classifier, especially when leave-one-out cross validation is used for evaluation. there is no doubt that many of the go terms in the full space are redundant, irrelevant or even detrimental to prediction performance. by selecting a set of distinct go terms to form a go subspace, mgoasvm can reduce the irrelevant information and at the same time retain useful information. as can be seen from table
 <dig>  for the virus dataset, around  <dig> to  <dig> distinct go terms are sufficient for good performance. therefore, using go subspace selection can tremendously speed up the prediction without compromising the performance.

CONCLUSIONS
this paper proposes an efficient multi-label predictor – mgoasvm – to predict the subcellular locations of multi-label proteins. by using the accession numbers of query proteins as the searching keys to search against the go annotation database, the go terms of each query protein are retrieved. for proteins without an accession number, blast is used to find their homologs and the accession numbers of the homologs are used as the searching keys. then the go terms are used to construct the go vectors, which are subsequently recognized by support vectors machine  classifiers equipped with a decision strategy that can produce multiple class labels for a query protein.

comparing with the exsiting predictors, mgoasvm has the following advantages:  the improved svm classifier used in mgoasvm can effectively deal with multi-label problems;  it selects a relevant go subspace from the full go vector space by using a set of distinct go terms; and  it constructs the go vectors by using the frequency of occurrences of go terms instead of using 1- <dig> values for indicating the presence or absence of some predefined go terms.

experimental results demonstrate that mgoasvm can efficiently predict the subcellular locations of multi-label proteins. this work also demonstrates that it is not necessary to use a large number of homologous accession numbers for searching the go annotation database. in fact, our results strongly suggest that using the top homologous accession number is already sufficient. for readers’ convenience, mgoasvm is available online at
http://bioinfo.eie.polyu.edu.hk/mgoasvmserver/mgoasvm.html.

