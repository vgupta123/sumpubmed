BACKGROUND
a genetic disease is caused by the abnormality in an individual's genome. genetic diseases have been studied extensively for decades by investigating the connection between diseases and genetic variations. in the human genome, chromosomes come in pairs; each gene consists of two alleles that reside in different chromosomes at the same locus. one of the two alleles comes from the father and the other comes from the mother. to study hereditary diseases in which the genetic variations are passed on to offspring, the ability to distinguish between paternal and maternal alleles is essential. unfortunately, the haplotype structure of a human genome is not available directly from the genotyping and the unordered genotype data does not tell us which allele comes from which parent. a haplotype is a collection of alleles at multiple loci on a chromosome that tend to be inherited as a unit. the determination of haplotypes from genotype data is called haplotype phasing or haplotype inference. algorithms for haplotype inference are indispensable and have been intensively studied.

the existing computational algorithms for haplotype inference can be classified into statistical and combinatorial and most of which were designed for genotype data collected from individuals in the form of a pedigree. a pedigree is a hierarchical structure that describes the parent-child relationship among members of a family. individuals without parents are called founders. there may be cycles in a pedigree, which are referred to as mating loops. a mating loop arises from a couple if they have children and both of them are offspring of certain family ancestors. an example of a pedigree, coupled with genotype data, is depicted in figure 1; each allele is denoted as  <dig> or  <dig> to represent its form within a gene. if two alleles of a gene are the same, the locus is homozygous; otherwise, it is heterozygous. a haplotype is regarded as a hereditary unit and therefore an input pedigree is preferred to be free of mutational events and to have minimum number of genetic recombinational events  <cit> . haplotype inference under this assumption is referred to as the minimum-recombinant haplotype configuration  problem, which requires the solving of the haplotype structure of the input pedigree with the minimum number of recombination events  <cit> . several algorithms have been proposed to solve the mrhc problem  <cit> . a special case of mrhc is zero-recombinant haplotype configuration  problem, which strictly follows the mendelian law of inheritance, namely that one haplotype of each child is inherited from the father and the other haplotype is inherited from the mother, without any mutation  <cit> . to reduce the complexity of the zrhc, some algorithms have been applied to pedigrees without mating loops   <cit> . in contrast to algorithms targeting tree pedigrees, so far no linear-time algorithm for zrhc has been proposed for general pedigrees, even though the number of mating loops in a human pedigree is usually very small and can be regarded as constant; the execution time of existing algorithms for zrhc using general pedigrees is polynomial  <cit> . regardless of whether it is a mrhc or a zrhc problem, some algorithms have been extended to handle pedigrees with mutations or missing data  <cit> . in addition to haplotype inference from pedigree data, algorithms have been proposed for population datasets that come from unrelated individuals. algorithms for population datasets try to decode the haplotype structure of each individual as well as the haplotype frequencies of a population  <cit> . all the above mentioned algorithms are mainly combinatorial. readers who are interested in statistical approaches for haplotype inference can consult a recent review  <cit> .

in this study, we have targeted the zrhc problem for pedigree data. if we assume we are given a pedigree with n individuals and m marker loci. then for general pedigrees, li and jiang proposed an o time algorithm by converting the inheritance process into an equivalent linear system of o equations over galois field gf and invoking gaussian elimination  <cit> . xiao et al. improved the method to take o time by removing redundant equations from the linear system  <cit> . doan et al. proposed an o) time algorithm by exploring constraints among marker loci rather than family members, where α is the inverse of the ackermann function  <cit> . for tree pedigrees, the execution time of the algorithm proposed by xiao can be reduced from o to o  <cit> . li and li proposed an o) time algorithm using disjoint-set data structures  <cit> . liu et al. further lowered the complexity of xiao's algorithm to linear time o  <cit> . chan et al. also proposed a linear-time algorithm by maintaining a graph structure  <cit> . chan's algorithm, however, only produce a particular solution. a particular solution assigns a numerical value to each system variable, while a general solution describes all possible solutions of the system by designating certain variables as free variables and the others as linear combinations of these free variables.

in this paper, we presented an o time algorithm that provides a general solution for zrhc for general pedigrees, where k is the number of mating loops. in human pedigrees, k is usually very small and can be regarded as constant. our algorithm therefore turns out to be linear for most of the practical cases. the proposed algorithm was subject to  <dig> experiments to verify its performance using different  combinations. the value of k was uniformly distributed between zero and six throughout all experiments. the experimental results show a great linearity of the execution time in relation to the input size when both n and m are larger than  <dig>  for those experiments where n or m are less than  <dig>  the proposed algorithm runs very fast, from thousandth to hundredth of a second on a personal desktop computer. we also showed that the proposed algorithm can be easily modified to detect inconsistencies among genotype data without loss of efficiency.

methods
to apply computational techniques, we transformed the input pedigree into a pedigree graph by connecting each parent directly to its children ). a pedigree graph is an undirected graph g = , where v is a set of nodes and e a set of edges. each node in v represents an individual in the pedigree; each pair of nodes is connected with an edge in e if and only if the two individuals have a parent-child relationship. g is defined to be undirected because the computational property of each edge is symmetric in our algorithm, even if the parent-child relationship is asymmetric. g may contain cycles. we only pay attention to two types of cycles: a cycle due to a mating loop, which is called a global cycle and a cycle due to a couple and two of their children, which is called a local cycle. global cycles and local cycles are referred to as basic cycles. for ease of cycle processing, we construct a spanning tree t  on g. a basic cycle can be obtained by adding a non-tree edge into t . the set of non-tree edges is denoted by ex. non-tree edges are further divided into two disjoint subsets elx and egx; members in elx induce local cycles and members in egx induce global cycles. mating loops seldom appear in human pedigrees and therefore |egx|=k is regarded as a small constant.

in the rest of this paper, we are assuming that g has n nodes and m loci, all alleles are bi-allelic , and the input dataset is free of genotyping errors. under this assumption, the input size of zrhc is o. the genotype data of a node ni are represented as a vector gni of size m. the genotype of ni at locus l, where  <dig> ≤ l ≤ m, is defined as follows:

 gni=0iflocuslishomozygousand bothallelesare0′s1iflocuslishomozygousand both allelesare 1′s2iflocuslisheterozygous 

genotype data are available, thus all g-variables can be regarded as constant ). we introduce a vector pni of size m to describe the haplotype information of ni; the paternal allele of ni at locus l, where  <dig> ≤ l ≤ m, is defined as follows:

 pni=0ifpaternalalleleis01ifpaternalalleleis <dig>  

the vector pni is regarded as unknown even though we know that pni=gni if ni is homozygous at locus l .

we formulated the zrhc problem as follows.

zrhc given a pedigree graph g with full g-constants, determine pni of each node ni in v.

the haplotype configuration of the input pedigree is identified by specifying the paternal haplotype of each family member.

a system of linear equations over gf
in this section, we introduce a system of linear equations based on g and g-constants; this system was first proposed in  <cit>  and will be reduced to determine all p-variables. since p-variables carry binary values, all equations in the linear system are defined over gf whose operations addition  and multiplication  are shown in table  <dig> 

the building block of the system: inheritance
"inheritance" is the building block of the system. what parents pass to their children must be the same as what children receive from their parents. for a parent ni and a locus l, ni passes pni +  <dig> to its children if and only if the genotype of ni at locus l is heterozygous and ni passes its maternal allele; otherwise ni passes pni  to its children. we introduce two auxiliary variables wnil and hni,nj to formally state the above argument. the variable wnil indicates if locus l of ni is heterozygous.

 wni=0ifgni≠21ifgni= <dig>  

the variable hni,nj indicates which allele of ni is passed to its child nj.

 hni,nj=0ifnipassesitspaternalalleletonj1ifnipassesitsmaternalalleletonj. 

therefore, pni+wni⋅hni,nj represents the allele at locus l that ni passes to nj.

on the other hand, assume that nj receives an allele from ni. if ni is nj's father, what ni passes to nj is the paternal allele of nj. in this case, we have pni+wni⋅hni,nj=pnj. if ni is nj's mother, there are two sub-cases. if locus l of nj is homozygous, what ni passes to nj must be the same as the paternal allele of nj. in this case, we have pni+wni⋅hni,nj=pnj. if locus l of nj is heterozygous, what ni passes to nj is the maternal allele of nj and is different from the paternal allele of nj. in this case, we have pni+wni⋅hni,nj=pnj+ <dig>  the variable wnjl can be used to indicate if locus l of nj is homozygous or heterozygous, the two sub-cases can therefore be combined into a single equation pni+wni⋅hni,nj=pnj+wnj. moreover, if we introduce another auxiliary variable dni,nj as follows,

 dni,nj=0ifniisnj′sfatherwnjifniisnj′smother, 

the inheritance relationship can be unified into the following equation:

  pni+wni⋅hni,nj=pnj+dni,nj 

note that the w- and d-variables are constant by definition, and the p- and h-variables are unknowns. equation  formulates the property of edge  in g: p-variables and w-constants are attributes of the nodes ni and nj, and h-variables and d-constants describe the inheritance relation associated with the edge . with the information provided by equation , various constraints on h-variables can be generated by traversing different paths in g. our algorithm was designed to first determine h-variables based on these constraints and then the solution to the zrhc problem can be obtained by determining all p-variables based on the solved h-values and equation . one point needs special care: if nj is a child of ni,hnj,ni and dnj,ni are undefined. in our algorithm, we make the h-variables and d-constants symmetrical such that hnj,ni=hni,nj and dnj,ni=dni,nj.

linear constraints on h-variables
to reduce the computational complexity of our algorithm, we try to make the number of unknowns in the coming linear system as small as possible. in the pedigree graph g, we have mn p-variables and at most 2n h-variables . observe that if a node ni itself or one of its parents is homozygous at locus l, pnil is determined by definition and equation . in this case ni is referred to as predetermined at locus l and the number of unknown p-variables is reduced by one. moreover, for an edge  ∈ e, where ni is a parent of nj,hni,nj is cancelled from equation  if wni= <dig> at locus l. if wni= <dig> holds for all  <dig> ≤ l ≤ m, no constraints are imposed on hni,nj and it becomes a free variable . in this case the number of h-variables to be determined is reduced by one, which is equipotent to the removal of edge  from g. accordingly, w-constants can be viewed as the weight of edges in g; we only pay attention to edges with weight one . to consider only the edges with weight one at locus l, we construct the lth locus graph gl = , where el = { | ni is a parent of nj, wnil=1}. moreover, the spanning forest t ∩ gl is denoted by t and is referred to as the lth locus forest ).

we define constraints on h-variables by traversing paths in the locus graphs. consider a path p = n <dig>  n <dig>  ..., ni in gl. assume that n <dig> and ni are predetermined and all other in-between nodes are non-predetermined. adding up all h-variables on the path will produce the following equation by equation :

  ∑j=0i-1hnj,nj+1=pn0+pni+ ∑j=0i-1dnj,nj+1=b. 

since n <dig> and ni are predetermined and all d-constants are known, b is a constant. the constant b is said to be the constraint of path p. note that the constraint b does not depend on the direction that path p is read because the h-variables and d-constants are symmetric. moreover, if the path is a cycle c = n <dig>  n <dig>  ..., ni, n <dig> in gl, we would have the following equation:

  ∑j=0ihnj,nj+1modi+1= ∑j=0idnj,nj+1modi+1=b′. 

again, since all d-constants are known, b' is also a constant. the constant b' is said to be the constraint of cycle c. on the basis of equations  and , we can generate constraint equations with only h-variables for cycles or for paths that connect predetermined nodes in gl. constraints can be classified into two categories with respect to the spanning tree t: cycle and path constraints derived from paths containing non-tree edges, and tree constraints derived from paths containing only tree edges.

cycle and path constraints
adding a non-tree edge e into the spanning tree t  generates a basic cycle c. if gl contains e, there are two cases of c in gl.

case  <dig> c is in gl. a cycle constraint bc of cycle c can be obtained by equation . the constraint is denoted interchangeably by bc or , which is also said to be the cycle constraint of e.

case  <dig> c is broken into several disjoint paths in gl by predetermined nodes. since these paths are disjoint, there is exactly one path p' of them containing e. along the path p', we identify a subpath p = ni ...nj containing e such that ni and nj are predetermined and all other in-between nodes are non-predetermined. a path constraint bp of the subpath p can be obtained by equation . the constraint is denoted interchangeably by bp or , which is also said to be the path constraint of e. path constraints are symmetric because  = .

tree constraints
for each connected component of t , we arbitrarily pick a predetermined node ns as the seed. for the unique tree path p that connects ns and another predetermined node nk in the same connected component, a tree constraint bt of path p can be obtained by equation . the constraint is denoted interchangeably by bt or . tree constraints are symmetric because  = . note that if there exists a component that has no predetermined nodes, locus l must be heterozygous across the entire pedigree and no tree constraints will be generated.

our algorithm in relation to the zrhc problem
our algorithm consists of four steps. we begin by initializing required data structures in the preprocessing step. the initialized data structures are subject to the constraint generation step to construct a system of linear constraints on h-variables. there are two issues should be addressed. first, since all constraints are derived from locus graphs that come from the same pedigree graph, there is usually redundancy in the system. second, we actually do not need to know all h-values to solve the zrhc problem. for a child node ni, there are two h-variables related to it and its parents. however, from equation  we know that one of the two h-values is sufficient to determine pni. so it is easy to see that the  h-variables in t  form a minimal sufficient set to solve the zrhc problem. in the third step, constraint reduction and transformation, we therefore try to eliminate redundancy in the system and transform as many path constraints into tree constraints as possible. finally, in the haplotype determination step, we introduce an efficient way to solve h-variables and further p-variables based on the reduced system.

step 1: preprocessing
the data structures of our algorithm are initialized by the following procedures:

 <dig>  transform the pedigree into a pedigree graph g = . each node ni in v is equipped with its genotype vector gni. since each individual has two parents, there are at most 2n edges in g, so we have |v| = o and | e | = o.

 <dig>  construct a spanning tree t  on g.

 <dig>  for each locus l,

 generate a locus graph gl,

 generate a locus forest t , and

 identify predetermined nodes as well as their p-values, all d-constants, and all w-constants.

the operations applied in this step are graph traversal and spanning tree construction, both operations can be performed in time o = o. the time complexity of this step is therefore o.

step 2: constraint generation
a system of linear equations on h-variables over gf will be constructed in this step. the system consists of three sets cc, cp, and ct that contain different kinds of constraints. cc contains cycle constraints, if any, of all non-tree edges at all loci. similarly, cp contains path constraints, if any, of all non-tree edges at all loci. finally, ct contains tree constraints at all loci. to reduce computational complexity, repetitions of set members are forbidden in our algorithm; we do nothing if an existing member is going to be added into the same set.

there are o trials to generate a constraint for a non-tree edge since there are m locus graphs and each of which contains o non-tree edges; in each trial we perform a cycle detection procedure to generate a cycle constraint or a path constraint, so we have | cc | + | cp | = o. the cycle detection procedure is usually implemented by depth first graph traversal and its execution time depends on the length of the cycle. consequently, if a non-tree edge induces a global cycle, the cycle detection procedure takes o time; otherwise the procedure takes constant time because each local cycle contains only four edges. the time to generate o cycle and path constraints is o since there are at most km trials to generate global cycle constraints. to generate tree constraints within a locus graph, we perform tree traversal on its locus forest. this procedure generates o tree constraints in o time. so we require o time to generate tree constraints at all loci. the time complexity to generate our constraint system is therefore o + o = o.

step 3: constraint reduction and transformation
redundancy arises in the constraint system if a constraint can be represented as a linear combination of other constraints. we are especially interested in the following two types of redundancies.

type  <dig> assume there is a basic cycle c in g and it can be decomposed into two edge-disjoint paths p <dig> and p <dig> both connecting nodes ni and nj. there must be exactly a non-tree edge e in c, and without loss of generality, we assume that e belongs to path p <dig>  if there is a cycle constraint  of c, a path constraint  of p <dig>  and a tree constraint  of p <dig>  we have bc = bp + bt by equations  and . that is, these three constraints are linearly dependent and each of them can be represented as a linear combination of the other two constraints ). a path constraint can therefore be transformed into a tree constraint by the equation bt = bp + bc, which is the basis of the reduction of our constraint system.

type  <dig> assume there are three tree constraints , , and  of paths p <dig>  p <dig>  and p <dig>  respectively. by definition we know that a tree constraint is the summation of all h-variables along a unique path in t, so we have

 b1= ∑∈p1hnx,nyb2= ∑∈p2hnx,nyb3= ∑∈p3hnx,ny. 

suppose that nl is the node closest to ni on the path p <dig>  we then have three paths p <dig> between ni and nl, p <dig> between nl and nj, and p <dig> between nl and nk such that p <dig> = p <dig> + p <dig>  p <dig> = p <dig> + p <dig>  and p <dig> = p <dig> + p <dig>  the tree constraints can therefore be rewritten as

 b1= ∑∈p4hnx,ny+ ∑∈p5hnx,nyb2= ∑∈p4hnx,ny+ ∑∈p6hnx,nyb3= ∑∈p5hnx,ny+ ∑∈p6hnx,ny⋅ 

because all constraints are defined over gf, we conclude that b <dig> + b <dig> = b3; the three tree constraints are linearly dependent and each of them can be represented as a linear combination of the other two constraints ). the above argument implies the following lemma.

lemma  <dig> for any three nodes ni, nj, and nk, the tree constraint of the path between nj and nk is equal to the total tree constraint of the path between ni and nj and the path between ni and nk.

lemma  <dig> still holds even if ni is on the path between nj and nk ), which means that if a tree path is partitioned into two disjoint sub-paths, the tree constraint of this path is equal to the total constraint of the two sub-paths.

in this step, we remove the type  <dig> redundancy by transforming as many path constraints to tree constraints as possible, and remove the type  <dig> redundancy by reducing ct to an equivalent set whose cardinality is at most .

for each non-tree edge e ∈ ex, if cycle constraint  exists, we remove all path constraints , if any, from cp and add tree constraints  into ct. since the size of cp is o, this procedure can be carried out in time o, and the new ct is of size o.

to further remove the redundancy in ct, we construct a constraint graph g* of g. the constraint graph g* shares the same set of nodes v as g; for each tree constraint  ∈ ct, we introduce an edge connecting nodes ni and nj in g* with weight bt ). an example of constraint graph is depicted in figure  <dig>  the constraint graph is used to reduce the size of ct. as shown in figure  <dig>  a constraint graph may not be connected. within each connected component in g*, we randomly choose a seed ns and try to assign each node ni a variable w to represents the tree constraint of the tree path between nodes ns and ni in the pedigree graph g. the assignment is carried out by the following steps in each connected component of g*.

 <dig>  w of the seed ns is assigned the value zero,

 <dig>  start from ns, perform a breadth-first-search traversal via tree constraints, i.e., we can traverse from node ni to node nj if  ∈ ct or  ∈ ct,

 <dig>  as we traverse from ni to nj through  or , if nj is unvisited, we assign w + bt to w based on lemma 1; otherwise we do nothing.

since w represents the tree constraint , it can be regarded as the summation of h-variables along the unique path on t from the seed ns to node ni, which implies the following lemma:

lemma  <dig> the h-value of a tree edge  in t can be obtained by hni,nj=w+w if ni and nj reside in the same connected component of g*.

therefore, if we can assign w-values to all nodes in v and make g* connected, g* would be equipotent to a reduced ct of size  that covers h-variables of all tree edges of t and is sufficient to solve the zrhc problem. the construction of the constraint graph takes o = o time.

the constraint graph g*, however, may not be connected with fully assigned w-values. we therefore introduced an extension procedure to extend g* by adding extra tree constraints, if any, into g*; we would like to reduce the number of connected component in g* as much as possible. to explore more tree constraints to be added into g*, we examine those non-tree edges e ∈ ex that do not have cycle constraints in cc. the basic idea is that if we can synthesize a new cycle whose constraint is the same as the expected cycle constraint of e, we may obtain new tree constraints by transforming known path constraints of e.

for a non-tree edge e without cycle constraint, we try to synthesize a cycle only if e∈egx. we do nothing if e∈elx because no extra tree constraints of e can be obtained by cycle synthesis. to see this, suppose the local cycle induced by e connects a couple na and nb and their two children nc and nd; without loss of generality, we assume e =  . we can examine the possible constraints derived from this local cycle. constraints of a single edge with predetermined endpoints are not of interest and can be ignored because the p-values of the endpoints are known; we need only pay attention to constraints whose path lengths are longer than one. in the lth locus graph, if wna=wnb= <dig>  a local cycle exists and we have cycle constraint  ); if wna= <dig> and wnb= <dig>  we only have the path p <dig> = ncnand with path constraint  ); if wna= <dig> and wnb= <dig>  we only have the path p <dig> = ncnbnd with tree constraint  ); if, wna=wnb= <dig> all four nodes are predetermined and we can determine their p-values directly ). no useful constraints other than , , and  can be derived from this local cycle. here we already know that  does not exist. if  is already in ct, it is the only useful tree constraint of e and we are finished. if  does not exist in ct, we cannot obtain  by combining bc and bp because  does not exist, even if the path constraint  is available. if this case holds for all  <dig> ≤ l ≤ m, our linear system actually provides no information to obtain the tree constraint of p2; the h-variable of each edge on p <dig> will eventually be assigned a free variable, or its value will depend on other free variables. therefore we do nothing if e∈elx.

assume that es is the set of non-tree edges in egx without cycle constraint. cycle synthesis is carried out by concatenating paths with known path constraints or tree constraints. the extension procedure is applied to es as follows.

e <dig>  for each e ∈ es, we check if there is an odd number, say 2t +  <dig>  of path constraints of e that link different connected components in g* to form a synthetic cycle ); a constraint is said to link two components a and b if one of its endpoints resides in a and the other resides in b. there is a special case whereby we can also obtain a synthetic cycle if two endpoints of a single path constraint reside in the same connected component . if no such 2t +  <dig> path constraints are found, we cannot synthesize a cycle of e and do nothing; otherwise we perform the following tasks:

e <dig>  assign the constraint  to the synthetic cycle, where

  bc ^= ∑∈sew+w+bp, 

in which se is the set of the chosen 2t +  <dig> path constraints;

e <dig>  for each path constraint  in cp, generate a tree constraint  and add the new constraint into g*;

e <dig>  update g*;

e <dig>  remove e from es;

e <dig>  if es becomes empty , or no synthetic cycle is synthesized , we stop the extension procedure; otherwise we go back to e <dig> to start the next iteration.

we thus try to synthesize a cycle for each non-tree edge in es to generate new tree constraints and update g*. to update g*, if more than one connected component is combined into a new one by new tree constraints, we arbitrarily choose one of the old seeds from these connected components as a new seed, and perform a graph traversal to update w-values within the new connected component. a non-tree edge that fails to receive a synthetic cycle in a trial of cycle synthesis may benefit from a later updated g* and therefore our extension procedure is designed to operate in an iterative fashion; the procedure terminates only if g*cannot be updated anymore. in this procedure, a non-tree edge may be checked many times  to form a synthetic cycle. in the worst case scenario, only one cycle is synthesized in each iteration, so we require k iterations to perform k +  + ... +  <dig> = o trials of cycle synthesis.

to verify the correctness of the extension procedure, we need first to explain the meaning of equation . follow a similar argument to that of lemma  <dig>  for two nodes nx and ny that reside in the same connected component of g*, we know that w + w is actually the tree constraint of the path from nx to ny on t. the synthetic cycle is conceptually a round trip through tree edges and the non-tree edge e. the value bc ^ in equation  is therefore the summation of h-variables along the round trip ). now we demonstrate that bc ^ is the same as the cycle constraint of e. we first show that there is exactly one h-variable of e in bc ^. according to equation , we have 2t +  <dig> h-variables of e in bc ^. since we perform additions over gf, 2t out of the 2t +  <dig> h-variables will be cancelled and we finally have only one h-variable of e in bc ^. to verify if bc ^is the same as the cycle constraint of e in g, we assume that the expected cycle constraint of e is bc. we generate a set se′ by converting path constraints  in se to tree constraints . it is easy to see that the converted 2t +  <dig> tree constraints also link connected components in g* to form a new synthetic cycle, and the corresponding round trip only contains tree edges in t. t has no cycle and therefore each edge of this new round trip must be visited an even number of times, which means that its h-variable will be cancelled in the new cycle constraint. so the constraint of the new synthetic cycle must be zero and we have the following equations:

 ∑∈se′w+w+bp+bc=bc ^+ ∑i=1|se′|bc= <dig>  

since there are 2t +  <dig> constraints in se′, we have ∑i=1|se′|bc=bc. we then obtain bc ^+bc= <dig> and conclude that bc ^=bc.

for each e ∈ es, the time to determine if there are odd number of path constraints that link connected components in g* to form a cycle is o. this time complexity can be achieved by regarding each connected component as a single node and each path constraint of e as a single edge, and following o edges to perform a depth-first traversal. since there are o cycle syntheses throughout the extension procedure, we require o time to find synthetic cycles. once we synthesized a cycle for e, we require o time to convert path constraints to tree constraints because there are at most m path constraints of e in cp. there are o non-tree edges in es and therefore the extension procedure takes o time to perform constraint conversion. to update g*, we require o time to perform breadth-first traversal on every connected component to modify w-values similar to the way we initialize g*. there are at most k synthetic cycles and therefore g* is updated o times in o time. in summary, the step  <dig>  constraint reduction and transformation, takes o + o + o = o time.

step 4: haplotype determination
to solve the h-values of the tree edges of t by lemma  <dig>  we try to make g* produced by step  <dig> connected. firstly, we pay attention to the founders in the pedigree. founders cannot be predetermined endpoints of paths with either path constraints or tree constraints and therefore founders must be isolated nodes in g*. it is also impossible to know whether an allele of a founder is paternal or maternal. we attach a founder nf to g* by assuming that it passed its paternal haplotype to an arbitrary child nc. the attachment can be done by assigning weight zero to the edge  of g*, which implies hnf,nc= <dig> . there are o edges in g* and therefore the attachment of founders to g* takes o time.

secondly, we check if there is any non-tree edge that can link any two connected components of g*. a non-tree edge e =  can link two connected components a and b if we can find a path constraint  of path p that, without loss of generality, satisfies the following two conditions:

 <dig>  nk and ni reside in a and have available w  and w  derived from the seed na of a,

 <dig>  nl and nj reside in b and have available w  and w  derived from the seed nb of b.

if we can find such a non-tree edge e, we can decompose p into three parts: a sub-path from nk to ni, the non-tree edge e, and the sub-path from nj to nl. the constraints of these three parts are w+w,hni,nj,w+w, respectively. this turns out that bp=w+w+hni,nj+w+w. the non-tree edge e therefore can be used to link components a and b with known h-value hni,nj=bp+w+w+w+w. since there are at most o path constraints to be checked, this procedure requires o time.

finally, assume that there remain t connected components of g*. we arbitrarily introduce  edges into g* to make it connected. our algorithm does not impose any constraint on these  edges and therefore the weights of these edges can be safely set as free variables. we then update all w-values within the new connected g* , and apply lemma  <dig> to determine the h-values of all edges in t. with these solved h-values as well as the w-constants and d-constants, we can determine the p-values of all nodes in the locus graphs by equation .

the update of g* takes o time. moreover, we require o time to determine all h-values of edges in t. for a locus graph, the determined h-values are used to solve all p-values in o time. since there are m locus graphs, we require o time to determine the p-vectors of all nodes in g. consequently, the three procedures of this step take o + o + o + o = o time.

RESULTS
an execution example
we use the pedigree given in figure  <dig> as an example to demonstrate how the proposed algorithm works. there are  <dig> individuals in the pedigree; eight of them are founders. each individual is equipped with genotype data collected from four marker loci. there is a mating loop in the pedigree.

in the first step, we transform the input pedigree into a pedigree graph g and construct a spanning tree t on g ). there are three local cycles a-h-b-i-a, d-k-e-l-d, and p-r-q-s-p and one global cycle b-f-c-g-d-l-o-q-n-i-b in g. edges a-h, e-l, q-r, and b-f are chosen as non-tree edges within the four cycles. from the pedigree graph g, we construct the four locus graphs and forests that are depicted in figure  <dig>  the p-values of predetermined nodes, w-constants of all nodes, and d-constants of all edges within the four locus graphs are also identified.

in the second step, we generate all cycle, path, and tree constraints for each of the four locus graphs using equations  and . for example, cycle a-h-b-i-a in the second locus graph has cycle constraint ha, h + hh, b +hb, i +hi, a = da, h  <cit>  + dh, b  <cit>  +db, i  <cit>  +di, a  <cit>  =  <dig> +  <dig> +  <dig> +  <dig> =  <dig>  and path g-c-f-b-i-n-q in the third locus graph has path constraint of the non-tree edge b-f hg, c + hc, f + hf, b + hb, i + hi, n + hn, q = pg <cit>  + dg, c <cit>  + dc, f  <cit>  + df, b <cit>  + db, i  <cit>  + di, n  <cit>  + dn, q <cit>  + pq <cit>  =  <dig> +  <dig> +  <dig> +  <dig> +  <dig> +  <dig> +  <dig> +  <dig> =  <dig> 

at the end of this step we receive cc = {, , }, cp = {, , , , }, and ct = {, , , , }.

in the third step, we obtain two new tree constraints  and  by  +  and  + , respectively. the set ct is therefore extended to {, , , , , , }. we construct the initial constraint graph g* based on the updated ct ). in the initial g*, we choose h, g, and q as component seeds to determine w-values. we can further find that the three path constraints ,, and  link three connected components to form a synthetic cycle of the non-tree edge b-f with constraint zero. so we further obtain three extra tree constraints , , and  derived from the synthetic cycle and add them to g*.

in the final step, we try to make g* connected to solve all h-values. we first arbitrarily introduce eight edges a-h, b-i, c-g, d-g, e-l, j-n, m-o, and p-r to attach the eight founders to g*; all the eight edges are of weight zero to imply that founders passes their paternal haplotypes to one of their children. now there are only two connected components in g*, one of which is an isolated node, f. we attach f to g* by set hb, f as a free variable. this final connected g* is depicted in figure  <dig>  after the final update of g*, all h-values other than hb, f are zero, and hb, f is free to be either zero or one. given these known h-values, all p-values over the four locus graphs can be solved by equation .

time complexity and experimental result
according to the analyses at the end of each step in section  <dig>  the time complexity of our algorithm is o  + o  + o  + o  = o. because k is regarded as a constant, our algorithm is linear.

to verify the efficiency and the correctness of our algorithm, we conducted some experiments using the proposed method. our algorithm was implemented in c and was evaluated on a desktop computer equipped with intel core i7- <dig>  <dig>  ghz cpu and  <dig> gb of ram. the desktop ran ubuntu release  <dig>  operating system with linux kernel  <dig> .0-16-generic and gnome  <dig> . <dig> graphical user interface.

in the experiments, we generated test cases by setting different number of individuals  and markers . we applied the algorithm developed by thomas et al.  <cit>  to generate  <dig> tree pedigrees with different n values ranging from  <dig> to  <dig>  to observe how the number of mating loops  affects our algorithm, each tree pedigree was preprocessed to produce four variants with zero, two, four, and six mating loops. for each pedigree, we examined  <dig> different m values ranging from  <dig> to  <dig>  each  combination was tested  <dig> times. each time we generated new genotypes and randomly selected one pedigree from the four variants of the given n. the haplotype configurations of all the  <dig> trials were correctly identified. the experimental results are listed in table  <dig> 

 average number of free variables.  execution time  to generate solutions. each entry in the table is the cumulative execution time of  <dig> replicates.  average number of mating loops.

finally, table  <dig> shows that mating loops existed evenly throughout all  <dig> trials, with the number ranging from zero to six per pedigree, and the number did not affect the linearity of the execution time of our algorithm in relation to the input size of n and m.

issue of spanning tree and seed node selection
in the first step, preprocessing, a spanning tree t is constructed on the pedigree graph g. as mentioned above, t is constructed for the ease of cycle processing; it is merely an auxiliary data structure used to generate linear constraints of all cycles and paths between predetermined nodes in g. we do not impose any constraint on the construction of t because predetermined nodes are defined by genotype data. once the input pedigree is given, all the cycles and paths as well as their constraints are bound, no matter which spanning tree is constructed on the pedigree graph. different spanning trees assign different edges as the non-tree edge in a cycle, and only affect the type of a constraint; a constraint may be a path constraint with respective to one spanning tree and a tree constraint with respect to another spanning tree. since different spanning trees are used to generate the same set of constraints, without considering their type, the construction of the spanning tree can be arbitrary. in our implementation, t was constructed by depth-first traversal.

in the second step, constraint generation, a seed node is arbitrarily selected from t to generate tree constraints. to see why the seed node can be selected arbitrarily, assume that there are two possible seeds ni and nj. for any other predetermined node nk, we have  =  +  by lemma  <dig>  which means that a tree constraint seeded with one predetermined node is a linear combination of two tree constraints seeded with another predetermined node. hence, tree constraints seeded with different predetermined nodes are mathematical equivalent; we can safely choose any predetermined node as seed. similarily, the seed nodes within a constraint graph can also be selected arbitrarily based on the above argument.

consistency checking
although we assume that the input pedigree is free of genotyping errors, our algorithm can be easily modified to detect inconsistencies within the genotype data without loss of efficiency. no recombination is allowed in the input pedigree and therefore inconsistencies will arise if there are different assignments of an h-value, that results in incompatible linear constraints. we may designate the following two checkpoints to detect inconsistencies within our linear system:

 <dig>  the generation of constraints. the constraint of a path or a cycle may be computed more than one time across all locus graphs; all these computations should arrive at the same value. so each time we compute a constraint, we check if it is the same as the current value, if any.

 <dig>  the initialization/update of g*. there may be loops in the constraint graph g* and therefore it is possible that there are more than one path from the seed ns to a node ni. it turns out that w  may be assigned more than once in the initialization or update procedures of g*. by the definition of w-variables, however, all the assignments to w are actually associated with the same path from ns to ni on t  and therefore should be identical. so each time we compute a w-value, we check if it agrees with the current value, if any.

CONCLUSIONS
in this study, we proposed and implemented an algorithm to solve the zero-recombinant haplotype configuration  problem for a general pedigree in o time. with the aid of free variables, our method provides a general solution to describe possible haplotype structures within a pedigree rather than a particular solution that only assigns a specific numerical setting to haplotypes. to the best of our knowledge, this algorithm is the first deterministic one to provide a general solution in linear time for pedigrees having small number of mating loops. moreover, the algorithm can be easily modified to detect inconsistency among genotype data without loss of efficiency. our experimental results confirm its linearity. in the future, we will try to extend the proposed algorithm to handle recombination and missing data in linear time for general pedigrees.

competing interests
the authors declare that they have no competing interests.

authors' contributions
eyl, wbw, tj, and kpw contributed to the algorithm design. eyl implemented the algorithms and performed the experiments. kpw and eyl analyzed the complexity of the algorithm and wrote the paper. all authors read and approved the final manuscript.

