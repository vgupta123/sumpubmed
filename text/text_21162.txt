BACKGROUND
in protein design and analysis, understanding the stability in sequence, structure, and function paradigms is of importance  <cit>  and hence there is a need for predicting the protein stability change due to mutation. single amino acid mutations can significantly change the stability of a protein structure  <cit> . to acquire a set of experimental annotations for every possible random mutation is combinatorial and requires significant resources and time. thus, accurate computational prediction would be of use for suggesting the destructive mutations as well as the most favorable and stable novel protein sequences. to this end, the prediction of protein stability change due to amino acid substitutions remains a challenging task in the field of molecular biology.

recent approaches fall into two major types: energy-based methods and machine learning approaches. energy-based methods using physical, statistical, or empirical forcefields perform a direct computation of the magnitude of the relative change in the free energy  <cit> . average assignment method  <cit>  and different machine learning algorithms, such as support vector machines  <cit> , neural networks  <cit> , and decision trees  <cit>  are trained on a data set to predict protein stability change. there are also hybrid approaches that combine energy-based and machine learning methods  <cit> ; they basically generate the input features fed into machine learning algorithms using energy-based models.

one can predict the direction towards which the mutation shifts the stability of the protein . it could be positive or negative, corresponding to an increase or decrease in stability, respectively. from a machine learning perspective, this is a binary classification task, where given x, information about the single-site amino acid substitution, the aim is to decide whether this is a positive or negative example, depending on whether the mutation is favorable or not. a third class of "doubt" can be defined for small changes that may be considered insignificant, and in such a case, one can train a three-class classifier  <cit>  or a two-class classifier with the reject option.

given a sample of n independent and identically distributed training instances, ,, ...,, where xi is the d-dimensional input vector coding the relevant information and yi ∈ {- <dig>  +1} is its class label, i =  <dig>  ..., n, a classifier estimates p and assigns the test instance to the positive class if p >  <dig> , and to the negative class otherwise. there can be different representations in coding x. deciding on the best data representation used is as important as selecting the classification algorithm.

another possibility in solving this using machine learning is to define it as a regression problem with ΔΔg directly as the numeric output. one can then decide based on whether the prediction is positive or negative, and again predictions that are close to zero can be rejected if the risk of misclassification is high. no single machine learning algorithm nor representation, in classification or regression, induces always the most accurate learner in any domain. the usual approach is to try many and choose the one that performs the best on a separate validation set unused during training. recently, it has been shown that accuracy may be improved by combining multiple learners  <cit> . there are three possible methods for combining multiple learners: early, late, and intermediate integration  <cit> .

in early integration, inputs are concatenated as one large vector and a single learner  is used. in late integration, multiple classifiers/regressors are trained over different inputs and their decisions are combined by a trained learner. these two approaches can be applied with any classification/regression algorithm.

late integration has been extensively used in bioinformatics. weighted voting was used in classifier combination for protein fold recognition  <cit> . majority voting was used for prediction of the drug resistance of hiv protease mutants  <cit> , secondary structure prediction  <cit> , detecting rare events in human genomic dna  <cit>  and identification of new tumor classes using gene expression profiles  <cit> . a trained combiner was used for secondary structure prediction  <cit> . a mixture of localized experts was used for gene identification  <cit> . cascading, which is a multi-stage sequential combination method, was used for secondary structure prediction  <cit> .

support vector machines allow combination in a third way, using multiple kernels; this is also called intermediate integration  <cit> . kernel functions basically measure similarity between data instances and a single learner can combine separate kernels for different data sources, instead of combining data before training a single learner  or combining decisions from multiple learners .

intermediate integration was used for protein location prediction and protein function prediction tasks, respectively, by combining kernels applied to different representations such as protein sequences, hydropathy profile, protein interactions, and gene expressions  <cit> . this method is also used in glycan classification by combining different tree kernels  <cit> .

our work has four aspects:  introduction of new protein residue features: the temperature factors of the backbone and side-chain carbon atoms  that reflect the thermal mobility/flexibility of the mutated residue; the local packing information in a higher resolution than that has previously been incorporated by considering the side-chain atoms as well; amino acid substitution likelihoods from pam <dig> matrix.  implementation of three different machine learning approaches , two of which, namely late and intermediate, have not been used before in the computational prediction of protein stability change.  comparison of classification and regression methods.  the use of a reject option in both classification and regression to check for cases where the learner has low confidence.

data
data sets
the first data set  was compiled from the data available online  <cit> , originally extracted  <cit>  from the protherm database  <cit> . this data set has been used previously and provides a basis for comparison  <cit> . the set originally contains  <dig> single-site mutation data from  <dig> different proteins. each instance has the following features: pdb code of the protein, mutated position and mutation itself, solvent accessibility, ph value, temperature , and the change in the free energy, ΔΔg, due to a mutation in a single position. as there are instances for the same mutation and position where ΔΔg differs with t and ph values, t and ph are kept as features in our data set. a subset  of the training set  was previously used as a test set for comparison between different predictors  <cit> . though some studies include the test set also in the training set, we remove it from the training set to have disjoint training and test sets, as done in  <cit> .

we also extract an up-to-date version   that contains  <dig> single-site mutations with known pdb code of the protein and ΔΔg values also from the protherm database. on this larger data set, we implement and compare both classification and regression integration methods and also their versions with the reject option.

added features
the substitution frequency of an amino acid for another is considered here as an additional feature with the point accepted mutation  matrix  <cit> . pam <dig> is chosen for the score of each amino acid substitution and is based on the frequency of that substitution in closely related proteins that have experienced a certain amount of evolutionary divergence.

another feature considered is the mobility/flexibility of the amino acid position in a given structure. the b-factors reported in the pdb file is a good and quick indicator of this feature. neighbors of the mutated residue in both amino acid sequence and 3d structure are the two other features that have been used recently  <cit> . a window size of seven in the sequence  <cit>  and a cutoff distance of 9Å in space was previously used to find the neighbors of the mutated position as the optimum sequence length and distance, respectively  <cit> . in our implementation, in addition to alpha-carbon atoms , beta-carbon  atoms are also considered to reflect the packing at a relatively higher resolution.

a mutation in a position of a protein sequence will change the number of side-chain atoms of the residue in that position. this may trigger a conformational change or local readjustments that may result also in a change in the atomic packing around that residue and the fluctuations of the surrounding residues and the mutated residue itself. nevertheless, as in other studies  <cit> , we neglect this effect.

removing the instances with non-available features and the redundant instances from s <dig> leaves us with training and test sets of  <dig> and  <dig> instances with total of  <dig> and  <dig> proteins. stabilizing mutations are  <dig>  per cent and  <dig>  per cent, respectively. after removing the instances with non-available features, s <dig> reduces to  <dig> instances from  <dig> different proteins and  <dig> of them  are stabilizing mutations. both data sets are available online.

mutation 
cα contacts 
cα b-factor 
cα b-factor 
mutation 
cα contacts 
cα b-factor 
cα b-factor 
in all three representations, amino acid substitution likelihood is used as a feature. b-factors of the cα and cβ atoms and spatial neighbor determined using both cα  and cβ atoms are features introduced into to and st. the abbreviations are given only for the features that we add.

methods
the effect of adding new features to the original data sets
to each of the three representations , the new features are added one at a time and as combinations of two and three . since all the new features except pam are structure-related, they are not added to so. all of the new features, including pam, are added to both to and st. we end up with  for so and  <dig>  for each of to and st combinations) a total of  <dig> possible feature sets .

the new features to each of the three representations  are added one at a time and as combinations of two and more. the original features are already given in table  <dig> and are not shown here.

performance assessment
having already left  <dig> test instances out as the test set for s <dig>  we use 20-fold cross-validation  on the  <dig> training instances using 19/ <dig> =  <dig> per cent for training proper and  <dig> per cent for validation. the best cross-validation strategy, that is, the number of folds, gets the best trade-off between the total amount of computation and training set size. with k folds, one needs k sets of training and validation and uses /k of data for training. we decided that the best is with k = 20; with higher k , there is too much computation and with smaller k, training set gets small and variance increases. classes should be represented in the right proportions when subsets of data are held out, not to disturb the class prior probabilities and we fulfill this requirement by stratification. repeating training  <dig> times, we choose the hyperparameter set that has the highest average validation accuracy. the  <dig> classifiers trained on the  <dig> training folds for that hyperparameter set are tested on the test set. if we are required to perform classifier combination, we use the same training and validation sets also for the combiner due to the small size of the training set  <cit> .

for all three integration methods, we use our own code; mosek  <cit>  is used for solving the optimization problems of support vector machines. we report averages over  <dig> test results obtained by testing the trained classifier of each fold on the test set; for comparing classifiers, we use the paired t-test over these  <dig> results.

we use a slightly different methodology for s <dig> because we train both classification and regression methods. first, we determine  <dig> split points for both stabilizing and destabilizing mutations as shown in figure  <dig>  each split contains approximately the same number of data instances as the other two splits of the same class. this splitting mechanism both maintains stratification and ensures that we give the regressors training instances with diverse output values. then, we take one-third of each split randomly to the test set and the remaining two-third is reserved as the training set. we apply 20-fold cv on the training set and obtain  <dig> folds. the learners  are trained on the  <dig> training folds and tested on the test set. the hyperparameter set that has the highest average validation accuracy for classification or the lowest mean square error for regression is selected and tested on the test set  <dig> times with the trained learners. this whole process is replicated  <dig> times each time using a different random test set. as a result, we obtain  <dig> ×  <dig> test set results and report the average of these results.

the accuracies on the test set are calculated as given in table  <dig> where tp, fp, tn, and fn, respectively refer to the number of true positives, false positives, true negatives, and false negatives. precision, recall, and fp rate are evaluation measures which give information about the reliability of the predictor. the same measures are also reported for regression methods after converting the output of the regressor to a class prediction by looking at the sign.

as we can see from figure  <dig>  ΔΔg values are clustered around zero and small changes in the prediction of a learner may change the predicted label for a test instance. when the risk of misclassification is high, we can allow a predictor to give a reject decision. we define a risk matrix in table  <dig> where r is the reject option, and the rows and columns correspond to the true and predicted class labels, respectively.

predicting the class label correctly does not incur any cost at all. if the learner rejects, a unit cost incurs. if the learner makes a prediction error, it pays a misclassification cost λ for fn and αλ for fp where α is the trade-off parameter for fp and usually depends on the application. these misclassification costs should be larger than  <dig> in order to make the learner reject when it is not confident about its prediction. given a risk matrix and p, we can calculate the risks of three possible actions as follows:

  

and the best action is selected as the action with minimum risk. one can then solve for the rejection thresholds based on the values of λ and α. for example, if λ =  <dig> and α =  <dig>  then we choose

  

we experiment with different λ  and α  values. if α =  <dig>  this means that fp and fn have equal misclassification costs assigned to them. in our case, by taking α >  <dig>  we say that predicting a destabilizing mutation as a stabilizing one is costlier than the other way around.

for regression where the output is not a probability but a number, we can not analytically solve for the two thresholds but need to do an exhaustive search. we search for two thresholds θ <dig>  and θ <dig>  on the validation sets given the values of λ and α that minimize the total classification risk. we choose the negative class if the regression output, y, for a specific test instance is less than θ <dig>  reject if θ <dig> < y <θ <dig>  and choose the positive class if y > θ <dig> 

early integration
different classifiers make different assumptions about the data and may fail in different instances  <cit> . we train three classifiers, namely k-nearest neighbor estimator, decision tree, and support vector machine, using so/so*, to/to*, and st/st* representations. we use a single regression method, namely support vector regression, on all representations.

k-nearest neighbor  classifier 
the k-nn classifier assigns the input to the class by taking a majority vote among its k neighbors. the best value of k is chosen from the set of  <dig>   <dig>   <dig>   <dig>   <dig>  and  <dig> using 20-fold cv.

decision tree 
a dt is a hierarchical model whereby the local region is identified in a sequence of recursive splits. when there is noise, growing the tree until it is purest, we may grow a very large tree. to alleviate such overfitting, tree construction ends when nodes contain few examples; this threshold, τ, is the hyperparameter to be tuned. τ parameter is selected from the trial values of  <dig> ,  <dig>  and  <dig> for s <dig> .

support vector machine 
svm finds the linear discriminant in the feature space with the maximum margin  <cit> . svm uses the training data in the form of dot products and allows embedding another feature space via kernel functions. the rbf  kernel was recently reported to work best for stability prediction  <cit> . the regularization parameter, c, is chosen from  and the kernel width, γ, is chosen from  where r is the average nearest neighbor distance over the training set.

support vector regression 
svr is an extension to svm for regression problems  <cit> . the regularization parameter, c, is chosen from  and the width parameter of the rbf kernel, γ, is chosen from  where r is the average nearest neighbor distance over the training set, the regression tube width, ϵ, is selected from .

late integration
it is possible to learn to combine the decisions of classifiers by a combiner classifier. by training the three classifiers described above with  <dig> data sets , we get  <dig> different combination triplets of  outputs where r, d, and b stand for representation, data set, and base-learner. the output of the combiner is the best subset combination of these  <dig> triplets. the two criteria to select the best combination are accuracy and diversity, in that, we want  triplets that fail in different regions of the input space. in order to see to what extent any two classifiers are correlated, mcnemar's test is used  <cit> . the same procedure can also be applied to combine regressors. we obtain  <dig> different regressors and the combiner chooses a subset from those. the correlation coefficient between the output of two regressors can be used to check the diversity between these regressors; a small correlation coefficient means that the two regressors are diverse.

the algorithm for selecting the most accurate and most diverse  triplets is a greedy, forward algorithm for subset selection. we start with an initial  that is the most accurate and search through the rest of the  triplets for those that are different from the initial one at significance level of α =  <dig>  by mcnemar's test. we add the most accurate one among those and iterate until there is no further improvement. the posterior probability outputs of the selected classifiers are then used to train a combiner that is an svm with the linear kernel. the pseudocode of the algorithm is given in table  <dig>  the algorithm for combining regressors is very similar to table  <dig> except three basic differences:  we select the regressor with the minimum mean squared error among candidate regressors.  we use correlation coefficient as the diversity measure between regressors.  we combine the outputs of selected regressors with a combiner that is an svr with the linear kernel.

the aim is to select the most accurate and at the same time the most diverse classifiers.

intermediate integration
when using multiple kernels in support vector machines, there are two different possibilities  <cit> : we can calculate kernel functions on different representations or calculate different kernel functions on the same representation.

one can take a sum over different kernels and summation rule is applied successfully in computational biology  <cit>  where heterogeneous data sets exist by the nature of the biological problems. 

replacing the kernel function with a weighted summation of p kernel functions was proposed  <cit> :

  

where the combination weights  are new parameters optimized in training. in addition to the flexibility of constructing weighted combination rules, using multikernel svms provides two important advantages:  information can be extracted about the classification task at hand. the feature sets used in kernel functions with larger weights are understood to give more relevant information in terms of classification. for example, obtaining information about important features in biological problems such as disease diagnosis and drug development is as important as classification accuracy.  kernel functions with zero weights can be eliminated. if such feature sets are obtained by using costly and time consuming experimental procedures, this decreases the overall complexity and cost.

for regression using intermediate integration, we use a variant of the localized multiple kernel learning model  <cit> . kernel combination weights can be modeled by using the softmax function as follows:

  

where the softmax guarantees that ηm ≥  <dig> and , and um are the kernel-specific parameters we need to learn. these parameters are optimized during training in an iterative manner.

in intermediate integration, we combine rbf kernels over feature subsets that form so/so*, to/to*, and st/st*. their width parameters are selected as the average nearest neighbor distances in the corresponding feature subsets.

RESULTS
s <dig> data set
early integration
we finetune the hyperparameters by inspecting the 20-fold cv misclassification error. for k-nn, k =  <dig> gives the most accurate cv results. the best parameter values for svms are , , and  for so/so*, to/to*, and st/st*, respectively. decision tree parameter, τ, is validated to be  <dig> in all representations.

accuracies of the best  triplets for each representation of the data are given in figure  <dig>  the effect of adding each extra feature is observed by adding one at a time and in combinations of two or more. svm yields the most accurate predictions in all three representations. the introduction of pam into so has no effect on accuracy, which is  <dig> . the average testing accuracy for to increases from  <dig>  to  <dig>  with the help of new features, which is not statistically significant. our results show that adding extra features to st does not improve the accuracy of  <dig> . the best accuracies with original and extra features for early integration are given in table  <dig>  table  <dig> lists the precision, recall, and fp rate values on the test set for the best classifiers for all three representations.

the accuracy of each base-learner trained with original data and with extra features added in so/so*, to/to* or st/st*. the values reported for each classifier are respectively the validation and test accuracies of the original representation and the new representation.

late integration
for k-nn, we choose k =  <dig> to give more informative posterior probabilities, rather than 0/ <dig> decisions, to the combiner in late integration.

the most accurate  triplet among all  <dig> classifier triplets is  that denotes a support vector machine  trained with st*  with the additional new features, pam and packing density from cα and cβ . the best complements turn out to be , , and  using the selection method of table  <dig>  when the outputs of the  triplets are given to the svm combiner, the average accuracy is  <dig>  on the test set and  <dig>  on the validation set . this accuracy is comparable to the reported values in previous studies  <cit> . similarities between selected  triplets calculated by mcnemar's test are given in table  <dig> 

intermediate integration
the test results for all data representations are given in table  <dig>  we can see that adding pam to so does not change the accuracy because pam is assigned zero weight; but adding extra features to to and st increase the average accuracy by  <dig>  per cent and  <dig>  per cent, respectively; both improvements are statistically significant. the highest accuracy is obtained with to* , which however is significantly less than  <dig>  of early integration.

so*
to*
st*
the kernel weights can be used to assess the relative importance of features . in all three representations, each feature subset except pam has a combination weight  greater than zero. the original representations have meaningful features for classification. the weights also show that ±  <dig> neighbors in the sequence carry as much information as ±  <dig> and ±  <dig> neighbors. in the modified representations , the new weights indicate that the added features, except pam, carry information for the stability of a protein. local spatial composition with cα and cβ  has larger weight than cα , which highlights the contribution of side-chain packing to stability. also, the information that reflects the extent of mobility/flexibility of each cα  and cβ  have nonzero weights, implying that they are informative.

st*
overall comparison of integration methods
to be able to compare the three integration methods, in all three representations, we chose the version that has the highest average validation accuracy and compared the three. the ones chosen are given in table  <dig> that shows the averages and standard deviations of validation and test accuracies. according to 20-fold paired t-test on the test results, there is no significant difference between early and late integration; both are significantly more accurate than intermediate integration.

early = late > intermediate according to paired t-test

s <dig> data set
early integration
we finetune the hyperparameters by inspecting the 20-fold cv misclassification error and mean squared error for classifiers and regressors, respectively. for k-nn, k =  <dig> gives the most accurate cv results. decision tree parameter, τ, is validated to be  <dig> in all representations. the best parameter values for svms are , , and  for so/so*, to/to*, and st/st*, respectively.  set works best for all svr simulations but the tube width, ϵ, is selected as  <dig>  or  <dig> . the cv and test accuracies for each representation with different learners are given in table  <dig>  we see that svm and svr clearly outperform k-nn and dt by improving accuracy more than  <dig>  per cent in all three representations. when we look at the effect of adding the new features to the original representations for svm and svr, we see that the new features do not change the test accuracy very much. the precision, recall, and fp rate values on the test set are also listed for svm and svr in table  <dig>  where we see that though svm and svr have comparable accuracies, svr almost halves the fp rate, for example on st*, it reduces from  <dig>  to  <dig> .

st*
the accuracy of each base-learner trained with original data and with extra features added in so/so*, to/to* or st/st*. the values reported for each classifier and regressor are respectively the validation and test accuracies of the original representation and the new representation.

late integration
first,  <dig> classifiers trained on s <dig> data set are combined with the procedure explained in table  <dig>  we obtain the average accuracy as  <dig>  on the test set and  <dig>  on the validation set . then, we combine  <dig> regressors trained, the average test set accuracy is  <dig>  and the average validation accuracy is  <dig> . again, we see that in terms of accuracy, svm and svr are comparable, though the latter has higher precision and lower fp rate.

intermediate integration
the test results for all data representations using multikernel svm and svr are given in table  <dig>  when we use multikernel svm, we can see that adding extra features does not change accuracy. the highest accuracy is obtained with st , which however is less than  <dig>  of early integration. using extra features in multikernel svr does not help increase the accuracy either. the best accuracy performance is obtained with to as  <dig> .

to*
st*
when we look at tables  <dig> and  <dig>  we can say that the added features carry information for predicting the energy change for single-site mutations even though they do not improve the average testing accuracy. as in s <dig> data set, local spatial composition with cα and cβ  has larger weight than cα  and the information that reflects the extent of mobility/flexibility of each cα  and cβ  has nonzero weights.

to*
to*
classification with reject option
we also perform simulations with reject option both for classification and regression, and give the performance measures obtained with early integration using so , late integration , and intermediate integration using to* , respectively. we see that increasing λ and α values increases the accuracy of predictors and decreases fp rate at the cost of rejecting some instances. the selection of λ and α values is of crucial importance and depends on the loss incurred for making wrong decisions. figures  <dig> and  <dig> show fp rate and rejection rate values for all integration approaches using svm and svr with the tried  pairs. we see that using late integration for svm case generally gives lower rejection rate than early and intermediate integration for a given fp rate; svr can attain much lower fp rate but needs to reject more.

discussion
we focus on the protein stability change prediction by adding new features and implementing the three different integration approaches, classification vs. regression, the effect of the reject option.

sufficiency of the data sets
training any classifier with an unbalanced data set in favor of negative instances makes it difficult to learn the positive instances. the unbalanced distribution in prior probabilities of the two classes in both training and test sets affects the reliability of the predictor in all integration approaches. nevertheless, the abundance of one class remains with the nature of the stability problem. stabilizing mutations are far less than destabilizing mutations. higher accuracies might be achieved with balanced training and test tests. for example, the test sets of s <dig> and s <dig> data sets have  <dig>  per cent and  <dig>  per cent destabilizing mutations, respectively. s <dig> data set does not have balanced training and test sets whereas we evenly distribute stabilizing and destabilizing mutations to training and test sets for s <dig> data set. for s <dig> dataset, we achieve  <dig>  the average test accuracy which is  <dig>  per cent higher than the percentage of destabilizing mutations. for s <dig> data set, this improvement is around  <dig>  per cent. ΔΔg values for the majority of both training and test data are in the interval {- <dig>  1}. we would expect the predictor to learn the pattern in this region better than the other regions in the data space. however, figure  <dig> suggests that it is not the case, and this is in agreement with previous studies  <cit> . even though the ΔΔg values are not provided to the classification algorithm numerically, the error rate is higher for smaller changes and lower for larger ones. this may be due to two reasons: either our predictor works best at dramatic stability changes; or possible experimental errors, being more significant for smaller ΔΔg values than the larger ones, confused our predictor. in separating the mutations into two distinct classes as positive and negative, the prediction may be ambiguous for data points close to zero. if we test our best classifier for s <dig> data set with the test instances outside of this interval , we obtain  <dig>  test accuracy. this last result shows the advantage of introducing a reject option and the approach we use by taking into account the losses of rejects and wrong decisions is the systematic way to choose the optimal thresholds.

furthermore, the mutations in the test set of s <dig> data set were conducted in physiological conditions  <cit> , having t in the range 20-30°c and ph in the range 6- <dig> whereas for the training set, the ranges are 0-86°c and 1- <dig> respectively. it is not ideal to train a learner with data within a wide range and test it only in a limited region; it is normally expected that the training and test sets follow the same probability distribution. in s <dig> data set, the test data and the training data are split randomly to alleviate this problem. because we do the splitting ten times and take the average, our results are more robust on s <dig> data set.

integration approaches
the most accurate predictor in early integration for s <dig>  data set is svm  classifier trained with st*  achieving a validation set accuracy of  <dig>   and a test accuracy of  <dig>  . we see in tables  <dig> and  <dig> that using structural information is useful with k-nn and dt; adding new features such as pam and cb improve cv accuracy, and in the case of to*, also improves test accuracy using svm, though not significantly. it may be said that to does not have enough packing information intrinsically and using b-factors and cβ may help.

in late integration for s <dig> data set, of the four triplets combined, two are svm, one is dt and one is k-nn. the fact that four different learners are chosen show that the learning algorithm is a good source of diversity. of the four, two use st* and so*, showing again that in terms of representations, there is also diversity for higher accuracy. note that this diverse set is found automatically by the selection algorithm we use.

the most accurate intermediate integration version for s <dig> data set uses to* with all new features; its test accuracy is  <dig> , which is significantly more accurate than the version with old features only  with test accuracy  <dig> . though it is not as accurate as the other integration methods, intermediate integration has the advantage of knowledge extraction through weights assigned to features. the kernel weights  show that when the protein structure is available, ca and cb are always preferred as a more valuable information source than any other features including sequence neighbors. based on the kernel weights, we can say that stability change is mostly a structure-driven phenomenon: for example, when we sum up the weights of structural features for s <dig> data set, using st*, we get ca + sa + cb + bfa + bfb =  <dig>  of  <dig> .

prediction using only the amino acid sequence
we analyze simulation results to see how accuracy changes if we have only the sequence information. for both data sets, the best performance in early integration is obtained with . the average test accuracies are  <dig>  and  <dig>  for s <dig> and s <dig> data sets, respectively. intermediate integration for s <dig> data set achieves  <dig>  average testing accuracy with so, which is higher than those of to and st . with the extra features, the accuracies are  <dig> ,  <dig> , and  <dig>  for so*, to*, and st*, respectively . the improvement with additional information in to* and st* is not significant when compared with so. for s <dig> data set, intermediate integration achieves  <dig>  test accuracy with so. all feature representations achieve statistically similar test set accuracies for both multikernel svm and svr.

prediction from only the sequence information could be considered more valuable at present as sequence-based data are more readily available. even if the average accuracy is increased by extra structural features, these features are obtained through costly experimental procedures like x-ray crystallography or nmr spectroscopy. spending more effort on making better use of sequence-only features with different learning methods might be more beneficial.

classification with reject option
when we compare the results of classification with reject option, we see that early and late integration methods tends to reject fewer test instances than intermediate integration with late rejects the least. for example, in order to achieve  <dig>  test set accuracy, early and late integration need to reject around  <dig> per cent of the test instances whereas intermediate integration rejects around  <dig> per cent of the test instances . another target can be achieving a specific fp rate. in this case, for example, early and late integration reject  <dig> per cent of the test instances and intermediate integration rejects  <dig> per cent of the test instances to get a fp rate less than  <dig> . the same behavior can also be observed for regression .

comparison with other studies
our methodology using 20-fold cv has comparable accuracy to previous studies  <cit> . s <dig> data set is based on protherm that has been also used by those studies. nevertheless, it is not exactly the same data set as we remove the test set from the training set, thus we represent our comparison with this caveat in table  <dig>  early integration approach is used in all referred works. they all report the performance of their predictors based on k-fold cv, also including the test set in cross-validation. the highest accuracy reported so far is  <dig>  evaluated on a subset of the training data  <cit> ; our early integration has the accuracy of  <dig>  on the independent test set. in those studies, higher accuracies are reported in the presence of structural information, which is in agreement with our findings though the difference is not significant in our case. ours is the first study that compares early, intermediate, and late integration to incorporate knowledge from different data sources for the problem of predicting protein stability, also analyzing the effect of different types of sequence and structural information.

 <dig>  
late
 <dig>  ,  <dig>  
*filtered from the set of  <dig> mutations  <cit> .

† a subset of the training set that was previously used in training.

‡ filtered from the set of  <dig> mutations  <cit> .

machine learning method, data set, performance assessment are the main features to be compared. 

CONCLUSIONS
in protein stability prediction, we investigate three approaches for combining multiple representations/learners, namely, early, intermediate, and late integration. these approaches can be used in both classification and regression. early integration uses a single learner to combine multiple inputs whereas late integration combines the decisions of learners using different inputs. intermediate integration combines inputs at the kernel level. we find that early and late integration are significantly more accurate than intermediate integration and intermediate integration allows knowledge extraction in the sense that it can pinpoint the features that are useful and how much they contribute. one advantage of combination is that if a new feature set, a kernel or a method for learning is proposed , it is always possible to include it among the set we use and thereby improve accuracy even further.

in general, we would expect early integration to suffer more from the curse of dimensionality when many input sources are concatenated. late integration combines decisions and therefore is expected to be more robust; the disadvantage would be the need to train/store/use multiple learners. intermediate integration is in between these two extremes where separate features are not used in a raw manner  nor are decisions extracted from them  but are converted to similarities  and fed to a single learner. the relative weights of features can be measured using intermediate integration. of course, ours is a single study and further research is needed before one can explain with enough confidence where and why each integration method works the best. of the three which one should be chosen depends on the application and other criteria, such as how much time and space can be afforded.

we see that in terms of accuracy there is no significant difference between interpreting this as a classification or regression problem except that a regressor tends to have a lower fp rate. we also conclude that introducing a reject option is useful to reject cases where a classifier or a regressor is not confident; it allows achieving a much lower fp rate taking into account the loss incurred for rejections and misclassifications.

as a future direction, we can add features, for example, to reflect the side chain conformation change due to a single-site mutation by a simple modeling.

authors' contributions
ao and mg developed the concept and the method under the guidance of ea and th. mg developed the web server. ao and mg drafted the paper. ea and th finalized the draft. all authors read and approved the final manuscript.

