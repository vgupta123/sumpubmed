BACKGROUND
more than  <dig> eukaryotic genome projects are on the way and will sooner or later generate hundreds of billion base pairs. the accurate annotation of genes in these many sequences is a challenging computational problem and impossible to complete by experimental methods alone. however, it is also estimated that about 50% of an organism's genes can be identified by strong sequence similarity to other organisms. the resulting sequence matching problems require simultaneous comparisons of large sets of sequences and are no longer efficiently handled by matching in turn each candidate sequence after the other as does blast and its various improvements including blat  <cit> . using suffix trees and suffix arrays, more efficient and exact methods of simultaneous sequence comparison exist. these methods quickly identify perfect matches of substrings. their application is justified by the observation, that approximately identical sequences have exact common substrings which are often specific enough to identify sequence similarities of interest. errors are rarely randomly distributed but cluster, leaving space for longer exact matches than expected from probability computations. hence, by almost perfect sequence matching, we can easily locate bacs and shorter sequences on chromosomes, relate single ests to full-length cdna and identify redundant and contaminated sequences. for instance, such methods quickly reveal large numbers of almost identical human ests stored in genbank which cause largely increased multiple output of spliced alignment programs, genome browsers use to map ests on chromosomes. one of the largest subset counts  <dig> human ests which are not human transcripts but part of the e. coli vector af <dig>  used for sequence amplification. sorek and safer  <cit>  describe various kinds of est contamination which are all detectable by analyzing matching substrings. by statistical analysis of complete est libraries these authors found  <dig>  human ests which are likely contaminated by intergenic, intronic or repetitive dna, and may have caused up to  <dig>  incorrect gene predictions. by exact string matching kurtz et al.  <cit>  discovered a  <dig>  bp repeat in the human chromosome  <dig> contig  <dig> caused by wrong sequence assembly that has been corrected. the genbank sequence of arabidopsis thaliana chromosome iii still contains a  <dig>  base pairs fraction of the cloning vector pbace <dig>  at position  <dig> , <dig>  four overlapping repeats found in chromosome iv are caused by a nine-fold tandem repeat of  <dig>  base pairs that needs careful investigation. such facts are generally discovered by chance since existing methods for sequence matching cannot simultaneously compare sequence data as large as necessary. the suffix tree approach requires too much memory. although the program mummer by delcher et al.  <cit>  is based on a more space efficient suffix tree implementation which is also used in repfind by kurtz and schleiermacher  <cit> , it cannot deal with more than  <dig> mb of sequence at a time using even  <dig> gb of ram. the next better program vmatch by abouelhoda et al.  <cit>  uses an enhanced suffix array. its recent version can handle at most  <dig> mb of sequence using the same amount of memory. other methods by burkhardt et al.  <cit> , höhl et al.  <cit>  and lefebvre et al  <cit> , also require at least  <dig> bytes of memory for each base pair to compare. however, we will soon need programs which are able to compare more base pairs of sequence than there are bytes of ram. one such program is clustdb  <cit>  based on a partitioned suffix array method. it needs less than four hours to simultaneously compare  <dig>  gb of human ests using a pc with  <dig> gb of ram. this program was further improved by a novel algorithm for match extension with errors which is the subject of this paper.

RESULTS
quality of window-alignment
clustdb extends to both sides all left maximal pairs of substrings exactly matching over at least m characters until a given number of errors k is exceeded in a window of given size w. this approach controls match quality independent of alignment length. its complete match option confines on listing sequences contained in others and pairs of sequences which overlap. the total number of errors could be controlled, too, as implemented in vmatch  <cit> . but this approach turned out to be impractical for large sets of sequences. from one exact match it often generates large numbers of differently extended matches while our approach reduces output by generating identical match extensions from different exact matches. we applied clustdb to a set of  <dig> medicago truncatula bacs published at the website  and found  <dig> complete matches using the parameters m =  <dig>  w =  <dig> and k =  <dig>  the numbers of errors reported were compared with the optimal alignment scores which took more than  <dig> hours to calculate even knowing the start and end positions of all matches. only  <dig> out of  <dig> cases showed differences to the optimal alignment score in either the number of mismatches or gaps. the total number of errors differed for  <dig> cases for which a histogram is shown in table  <dig>  the largest difference was  <dig> errors over an alignment of more than  <dig> kbp, a case discussed in the legend of figure  <dig> 

clustdb outperforms vmatch in speed and sensitivity
we applied clustdb to find redundant sequences in a smaller set of  <dig> finished medicago bacs downloaded from the ncbi  in order to identify overlapping sequences and sequences which are contained in others. consideration of both strands yields  <dig> sequences which add up to about  <dig> mb. using m =  <dig>  w =  <dig> and k =  <dig>  clustdb takes 11: <dig> minutes to identify  <dig> complete sequence matches, i.e. those which identify overlapping bacs and those contained in others. much shorter run times are obtained for larger values of m. for m =  <dig> clustdb takes only 6: <dig> minutes to derive  <dig> complete matches admitting  <dig> errors in each window of size  <dig>  hence,  <dig> complete matches do not include an exact match of length  <dig>  the calculations were performed on a pentium  <dig> pc with  <dig> gb of ram and  <dig>  ghz processor speed.

on the same computer, vmatch takes 16: <dig> minutes to find only  <dig> exact complete matches for m =  <dig> or 16: <dig> minutes to find only  <dig> exact complete matches with m =  <dig>  in this program m is called seed string length. admitting at most  <dig> errors – the maximal error count allowed in vmatch – it takes 17: <dig> minutes to derive  <dig> complete matches for m =  <dig> and 16: <dig> minutes to find  <dig> complete matches for m =  <dig>  furthermore the two sets of complete matches derived by clustdb contain  <dig> and  <dig> complete matches with at most  <dig> errors. vmatch should find all of these matches but fails. for technical reasons it considers the nucleotide 'n' to mismatch all other nucleotides including itself while clustdb takes the biologically more correct point of view and considers the letter 'n' to match all other nucleotides and finds more matches this way. hence, clustdb outperforms vmatch in speed and sensitivity.

runtime basically depends on how many matches are found. for another larger and match rich sample of  <dig> bacs as well as their complementary sequences  described in the next section clustdb took considerably longer times of execution shown in table  <dig>  the shortest time is  <dig> minutes for m =  <dig> w =  <dig> and k =  <dig>  vmatch performed very differently on this data set. while it was fast in generating all extended matches with at most  <dig> errors and seed string length m =  <dig>  it suddenly took more than  <dig> hours to derive all matches with up to  <dig> and more errors. the reason could be a bug in the program or an exponential increase of match extensions found. vmatch extends every left maximal pair of exactly matching substrings while clustdb does not extend matches which are contained in an already extended match. it is also shown in  <cit>  that vmatch is on its limit by processing about  <dig> mb of sequence with  <dig> gb of ram while the latest version of clustdb handles up to  <dig> gb of sequences. hence, swapping may be a reason, too. moreover, the output of vmatch makes not much sense for such problems and requests a massive additional effort to derive the results obtained by clustdb using the output of vmatch.

testing clustdb on tigr's current medicago bac assembly
the website  offers  <dig> bac assembly files named contig_lg <dig> dat to contig_lg <dig> dat. they contain  <dig> chains of sequences claimed to overlap by more than  <dig> nucleotides for each junction. the total number of sequences in these chains is  <dig> and they contain  <dig> overlapping sequence pairs which form our test set for clustdb. of these  <dig> sequence pairs  <dig>  were confirmed by application of clustdb to the  <dig> bacs and their complementary sequences  using parameters m =  <dig>  w =  <dig>  k =  <dig>  the complete match option, and reporting only extended matches of length greater than  <dig>  interestingly, these are in fact all correctly published overlaps of complete sequences as our following study shows.

clustdb was applied to the remaining  <dig> pairs with the complete match option switched off. the overlapping property could not even partly be confirmed for five pairs ct971491/ct <dig>  ac171618*/ac160842*, ac147960/cr <dig>  ac153162*/ac159662* and ac158173*/ac <dig>  the asterisk denotes working draft sequences which are incomplete and consist of a number of unordered sequence sections which must be considered separate sequences for a meaningful application of clustdb. tigr claims no confidence in the results published for these sequences. the two pairs of complete sequences ct971491/ct <dig> and ac147960/cr <dig> were studied using blast and no significant local alignments longer than  <dig> bp were found. trusting blast, we are convinced that these two cases are no real overlaps. in another  <dig> cases no match extended until one of both sequence ends. but in all these cases at least one and mostly both sequences were working draft sequences or had the tag "sequencing in progress" in their genbank locus fields. for the same reason we did not consider another  <dig> pairs of bacs.

the remaining  <dig> pairs of complete sequences are listed in table  <dig>  figure  <dig> shows the kind of match found in  <dig> of these cases . two excellent matches extend from both sides of the overlap, but a poorly matching sequence section stops the window alignment in nearby sequence positions. note that if the match extensions are not complete there are necessarily k +  <dig> =  <dig> errors in the last window of size w =  <dig>  hence, if the total number of errors is  <dig>  only one error occurs in the remaining part of the match indicating a very inhomogeneous alignment quality.

in three other cases , clustdb detects one match reaching from the start of the overlap to shortly before its end missing  <dig>   <dig> and  <dig> nucleotides, respectively. again, almost all errors occur in the last alignment window and hence, the tails of the upstream bacs should be studied. the overlap claimed by tigr for the sequence pair ac142394/ac <dig> splits into two sections . one section of length  <dig> aligns badly with  <dig> errors  and is followed by a section of length  <dig> that aligns perfectly with only  <dig> errors. this places serious doubts on the correctness of both bacs.

alternative assembly
clustdb applied to a large set of bacs, simultaneously, does not only confirm known matches but also detects large numbers of new alternative matches which are worth to consider. our application described in the previous section produced  <dig> complete matches of which at least  <dig> are not listed in the published medicago bac assembly tables which suggest alternative bac assemblies. just one example is discussed in figure  <dig>  it compares a bac assembly derived from our complete matches  with the result provided by the medicago sequencing consortium . table  <dig> presents the match errors for all involved pairs of overlapping bacs. there is a  <dig> bp long exact overlap of sequence ac150776+ with the sequence ac148343+ . it suggests an alternative assembly that covers the about  <dig> kbp gap of unknown sequence. however, there is no proof of it. assuming the consortium's assembly is correct, a long inverted repeat exists as has been observed very frequently in the human x chromosome  <cit> . we are far from solving this puzzle here, but this case proves the importance of good methods for sequence comparisons that make us think about such problems.

CONCLUSIONS
we proved window alignment an efficient way to find long sections of similar sequences. compared with traditional alignment, it is faster to calculate, reveals sequence sections of homogenous alignment quality, just such as expected for random errors, and also detects local systematic errors like sequence contaminations. such inserts are often overlooked by optimizing global scores for long alignments only tuning parameters like penalties for mismatches and gaps. the case depicted in figure  <dig> has an excellent global alignment score and still shows a severe local sequence matching problem that is important to detect. however, not only the quality of individual alignments but also the speed of simultaneous comparison of large set of sequences makes clustdb an indispensable tool for genomic sequence analysis.

we showed that clustdb outperforms vmatch in comparing bac size sequences mainly caused by an inappropriate match extension method and the high memory consumption of the latter program. application of the software blat to our data was stopped after several days of endless computation. note that bac assembly is just one application of clustdb. our alignment concept is also beneficial for mrna to cdna comparison in order to confirm exons, introns and alternative splice sites. alignments used in such contexts should tolerate sufficiently spaced single errors in larger numbers than dense blocks of errors. the program genomeflicer by mielordt et al.  <cit>  admits at most  <dig> errors in a window of length  <dig> in order to confirm genes and to distinguish nagnag acceptor isoforms  <cit> . we also expect that clustdb helps to study highly repetitive genes, a problem described especially challenging by check  <cit> . we developed clustdb to play a major role in future genome wide comparisons of genes and currently work on specialized program versions for est- and full-length cdna matching, genome wide detection of alternative splicing as well as distributed parallel processing  <cit> .

