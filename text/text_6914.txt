BACKGROUND
the paired-end sequencing technology, modified from the well-known single-end sequencing technology on next generation sequencing  platforms, plays increasingly important roles in genomics. by sequencing 5' ends of two strands of a dna  fragment, it provides not just nucleic contents but also positional information of the fragment, therefore is a powerful resource to resolve the assembly in repetitive regions or structural variants. in addition, it is capable of obtaining interacting long-range dna fragments <cit> , conveying information on both strands of the sequenced dna, resolving exon junctions <cit> , and many other applications <cit> .

a typical illumina's paired-end sequencing technology is performed as follows: double strands of dna fragments are both ligated with adapters and barcodes , and then the 5' ends of the double strands are attached to the flow cell surface followed by many bridge amplification cycles to generate clusters for better nucleotide synthesis and fluorescence imaging. both strands of each dna fragment can serve as sequencing templates by regenerating the clusters, and consequently paired-end reads are produced . according to the paired-end sequencing protocol of illumina, users are allowed to choose the size-selected length of the dna fragments  from  <dig> to  <dig> base pairs  with the sequencing quantity up to  <dig> millions of reads. paired-end reads obtained are of a machine specific sequencing length, such as 36x <dig>  75x <dig>  or 100x <dig> bp.

for dna fragments that are at least as long as the pre-specified sequencing length , the sequencing process initiated from the 5' ends of both strands will be constrained and terminated before sequencing the adapters, so that only the 'real' dna information is conveyed by the resultant paired-end reads . however, in the case when the dna fragments are shorter than  <dig> bp, the sequencer will 'read through' the real dna into the adapters . as a result, the paired-end reads generated will be appended with unwanted adapter sequences , and are likely dropped in the step of reference mapping.

to recover the "real" dna part from the reads, existing algorithms rely on the correct alignment between adapter sequences against the 3' ends of reads. such algorithms were originally designed for dealing with adapter contamination in single-end sequencing. they regard paired-end reads as two sets of single-end reads, and the adapter trimming is performed on each set independently. in practice, these single-end oriented adapter trimmers, such as fastx <cit> , cutadapt <cit> , ea-utils <cit> , tagcleaner <cit> , and trim_galore <cit>  , do not give satisfactory results for paired-end sequencing. it is largely because current modern sequencers have a significantly higher sequencing error rate at the 3' ends of reads . in other words, identifying the putative trimming positions by means of matching adapter sequence against read segments with poor sequencing qualities is highly error-prone. some trimmers, such as adapterremoval <cit> , seqprep <cit> , and trimmomatic <cit> , further filter positions found by the adapter sequencing scanning on each of the paired reads by examining the reversed complementarity between the untrimmed portions of the paired reads; however the accuracy still depends on the adapter sequence scanning on the error prone 3' ends. gatk readadaptortrimmer <cit>  looks for overlaps between forward and reverse reads in a pair to achieve high accuracy; however, it was designed specifically for streamlining with variant calling analysis pipeline in gatk <cit> , its input and output has to be in sam/bam format <cit> , which is cumbersome for other downstream analysis. the comparison of the performance of some of the trimmers has been investigated by several benchmark studies <cit> .

here, we propose a highly efficient and accurate adapter-trimming algorithm and its implementation, peat , designed specifically for paired-end sequencing. peat requires no adapter sequence input, which is particularly convenient when processing libraries using different adapters on a large scale. peat directly scans for the reverse complementarity between the good quality portions of the reads to avoid the loss of sensitivity during the filtering adopted by conventional approaches. we compared peat with many adapter-trimming tools. peat performed relatively well in simulated benchmarks and showed high scalability when applied to large real datasets. we applied peat to two public real datasets , multimillions of adapter-appended reads were successfully spotted, recovered, and mapped back to the reference. we further investigated the effects of peat to ten more real publicly available datasets of different sequencing applications such as chip-seq, mnase-seq, and rna-seq. comparisons between datasets processed with and without peat followed by the same typical downstream analyses revealed obvious pattern changes, which may deflect the biological notions toward the data. we suggest that more attentions need to be paid to adapter contamination in analyzing paired-end reads in all applications.

RESULTS
an overview of the peat algorithm
in a typical illumina paired-end sequencing protocol, a pair of adapter-appended reads emerges whenever a dna fragment shorter than the pre-specified sequencing length get sequenced . for a pair of reads sequenced from such a short fragment, the 5' ends of the reads, which correspond to the sequences of the real dna fragment, have to be the reverse complement to each other . the 3' ends, on the other hand, are corresponding to the adapter sequences, and should be equally long due to the fix pre-specified sequencing length.

based on the aforementioned observations, we propose a paired-end adapter-trimming  algorithm with an efficient two-stage string matching strategy to detect the junctions between real dna and adapters in paired-end libraries . the algorithm identifies multiple possible trimming positions by probing the reverse complementarity of the 5' end of the paired reads. to begin with, the reverse complement of a short 5' prefix  of one read of the pair is used as a template to scan for mismatch-tolerant hits against another read of the pair. this procedure is performed twice by taking each read of a pair as the template iteratively and generates two possible sets of putative trimming sites. the intersection of the two sets is then used to check the reverse complementarity of the accordingly determined real dna sequences  of each read in a pair, and the parts corresponding to the adapter sequences, are substantially the same . if none of the trimming position passes the check, peat reports that the pair is not appended with any adapter sequence.

by using 5' ends instead of 3' ends as both templates and targets for scanning, peat is able to determine the adapter trimming positions of the paired-end reads more accurately. peat is therefore more resistant to adapter contamination that is very short or having multiple adapter copies. optionally, peat can also take the parts corresponding to error-prone adapter sequences as an auxiliary criterion for reexamination when the forward- and reverse-strand adapters share similar sequence . peat also incorporates an open source single-end adapter trimming algorithm <cit>  to provide single-end adapter trimming functionality. peat supports multithreading for utilizing multiple computing nodes with data parallelism. detailed algorithms and implementation can be found in methods and the source code.

performance comparison
we evaluated the performance of peat, as well as other paired-end adapter trimmers, including adapterremoval, ea-utils, gatk readadaptortrimmer, seqprep, trimmomatic, and trim_galore with six benchmark simulations and two real life datasets. the parameters of running these tools can be found in supplementary methods . the benchmark simulations included datasets of three levels of quality: low-error-rate, middle-error-rate, and high-error-rate datasets, namely led, med and hed respectively, each of which had a million mock paired-end reads randomly sampled from a reference mouse genome  and half of the paired-end reads were selectively appended with the typical illumina adapter sequences. since typical illumina libraries use the similar forward- and reverse-strand adapters, we also generated three companion dled, dmed and dhed of which the prefix 'd' indicated that the reads were generated with the distinct forward- and reverse-strand adapters. in addition, we generated med-o/dmed-o in which each paired-end read shared a 50-bp overlap  to demonstrate that our algorithm would not be fooled by extra reverse complementarity within reads. mutations were introduced into reads according to a set of given sequencing quality scores . the quality scores were sampled from a real dataset. please see methods for more details.

we ran peat and other trimmers on a linux virtual machine and measure the execution time for trimming 1m of simulated reads of each of the eight datasets. all in all, with a linear-time algorithm  effectively implemented with a lower-level computer language , peat clearly achieved higher efficiency .

to evaluate the trimming performance, we calculated the sensitivity, specificity, accuracy, and matthews correlation coefficient  <cit>  of all trimmers . since some trimmers trim bases with low quality at 3' end and throw away reads that are too short after trimming by default, we used the options provided by the tools to make them behave similarly to the scenarios . peat topped at two general metrics  in most of the datasets. in general, the accuracy deteriorated when different adapters were used. adapterremoval seemed intolerant of different adapters in the paired-end libraries. overlapping reads did not make apparent difference to the performance of all trimmers. we further investigated the ratio of trimmed reads over untrimmed reads  and the length distribution of trimmed reads  obtained in eight datasets. the length distribution shows that some trimmers tended to trim a few bases at the 3' end , and some resulted in short fragments with a small chance . overall, the results of gatk readadaptortrimmer, peat, and seqprep showed only marginal differences to the gold standards.

we next applied peat and other trimmers to real life paired-end datasets  retrieved from geo . in the comparison of trimming time with other tools, peat operated faster than adapterremoval, ea-utils, trim_galore, gatk readadaptortrimmer, seqprep and trimmomatic by remarkable speedups of 20x,  <dig> x,  <dig> x, 9x, 13x, 7x respectively . the result consists with that in the benchmark simulations, suggesting that peat is more efficient and also more scalable than most of the existing trimmers.

*abbreviations: ar; ea; tg; gatk ; tm

peat identified  <dig> m  and  <dig> m  adapter-appended reads from gsm <dig> and gsm <dig> respectively . the identified adapter-appended reads were further aligned back to the mm <dig> reference with end-to-end alignment by bowtie <dig> <cit> .  <dig> m and  <dig> m reads were concordantly aligned one or more times to the genome, indicating that peat successfully had  <dig> % and  <dig> % of the identified adapter-appended reads of the two datasets properly processed and recovered. since there was no gold standard, we simply took the number of reverse-complemented trimmed pairs to approximate true positives, and denoted it as atp. peat gave the highest atp among all tools. comparing the insert length distribution of the original datasets to that processed by peat , we conclude that peat successfully recovered a significant amount of inserts shorter than 101bp without losing reads information conveyed in the original datasets.

for our tests, the results suggest that although some other trimmers also take advantage the reverse-complementarity to identify adapter contamination in different ways and also showed comparably performance, their algorithms do not scale very well and took much more time to complete the task. in addition, gatk readadaptortrimmer required extra 20+ hours of time just to transform between the formats for the two real life datasets  in the tests. it could be a burden for users that do not intent to use the gatk framework.

applications in rna-seq, chip-seq, and mnase-seq
in practice, the importance of adapter trimming is not fully recognized. it is not rare to assume that after size-selection--a common procedure to eliminate unwanted short fragments such as degradation products or rrnas--dna fragments having length shorter or greater than the size-selected length by a margin take only a very tiny part of the sequencing library. according to this assumption, dna fragments with lengths outside the peak  are extremely rare, which makes some believe the lost of information carried by these minority is tolerable. we applied peat to two real life rna-seq datasets gsm <dig> and gsm <dig> and provided evidence that this assumption might need to be adjusted .

we further collected publicly available paired-end sequencing datasets for three typical ngs applications from geo: rna-seq , chip-seq  and mnase-seq , and we tested the influence on the downstream analyses when a competent adapter trimmer  is included in the data processing. we used the local alignment option  in bowtie <dig> to relieve the problem of the non-mappability of the adapter-appended reads, which is a generally acceptable approach for the purpose <cit>  . to eliminate possible miscalculation of insert length, we further excluded the multi-mapping reads and found significant changes in the length distribution .

in chip-seq datasets, we found that, without applying peat, unique mapping reads were reduced for about 40% , but after closer examination, the reduction were largely due to the use of local alignment, which led to fewer unique alignment. we didn't observe significant influence to the power of the downstream peak calling with adapter trimming ; however, we would still suggest one should perform adapter trimming with bowtie end-to-end alignment, since loosing 40% of unique mapping reads might be too costly just for getting rid of adapter contamination. in rna-seq datasets, contrary to that in chip-seq and mnase-seq datasets , about 10% more unique mapping reads were found without peat. we can see an additional surge of the blue curve  around 100- <dig> bp in figure 4b and s10b, additional file  <dig>  we examined some of these alignments and found they were likely caused by the truncated junction reads ; therefore likely all the junction reads were reported shorter. however, using bowtie <dig> with the end-to-end alignment option threw away all these junction reads. the best practice here should be using peat followed by a splice junction mapper like tophat <cit> . the short  and long  inserts found with peat were annotated to different populations . short inserts were enriched in snornas and they were not found in the results without peat. in mnase-seq datasets, more than 30% of unique mapping reads were missed without peat . the absence of the short inserts affected the downstream v-plot analysis. the ctcf occupation profiles were less visible without adapter trimming, which may lead to wrong estimation of the size of the binding motifs . along with these observations, we strongly suggest that a competent adapter trimming is crucial for the correct interpretation of the paired-end sequencing data.

CONCLUSIONS
we herein propose the first paired-end specific adapter trimming algorithm and its implementation, namely peat. peat acknowledges the characteristics of current paired-end sequencing and takes advantage of the self reverse-complementarity nature of adapter-appended read pairs. it exploits a two-step process to search for reverse complement portions and accommodate high sequencing errors at the 3' ends. peat is written in c++ for more sophisticate control over memory and also equipped with multithreading for multiprocessor systems. besides, with its reverse complementarity examining algorithm for 5' end, peat is able to operate without any adapter sequence input. this feature makes peat more suitable than other tools to handle large-scale sequencing data processes, in which different adapter sequences were used during library preparation.

our simulation showed that single-end oriented trimmers that utilize post-processing to handle paired-end reads might be inappropriate. peat was able to determine the adapter trimming position of the paired-end sequenced reads with impressively high accuracy and efficacy. for the tests on real life datasets without gold standards, we used atp to estimate the performance of trimmers and showed that peat was among the best choices. in addition, typical downstream analyses of chip-seq, rna-seq, and mnase-seq were carried out and the results underlined the importance of a competent adapter trimmer.

peat currently is unable to handle barcode sequences in 5' ends, which will be improved in the future development. peat does not take into account of quality scores and indels. it is possible for peat to adopt a probabilistic model for scanning hits, although it is unpredictable if the model would help for better sensitivity or specificity, but it would likely reduce the speed. for sequencing platforms that introduce indels into reads , peat doesn't perform well, but in the algorithmic aspect, it is not difficult to allow a fix number of gaps when scanning for hits without lose of efficacy. in addition, solid reads in color space can be converted into nucleotide before processing by peat. we will support gapped alignment and color space alignment in the near future. the executable binaries and the standalone c++ source code package of peat are available at: .

