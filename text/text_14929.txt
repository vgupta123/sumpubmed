BACKGROUND
non-coding rnas  have recently been recognized as important regulators of the biological systems  <cit> . they participate in the control of alternative splicing  <cit> , gene transcription  <cit>  and translation  <cit> , and mrna localization  <cit> . most of the ncrnas exert their biological functions by folding into specific structures, which makes the study of the rna structurome a critical step towards complete understanding of the operational mechanism of the biological system  <cit> . recently, genome-wide rna structurome analysis has led to many interesting discoveries regarding novel regulatory mechanisms. for example, analysis of the rna structural elements in drosophila melanogaster 3’-utr suggests a cluster of ncrna elements that can direct the localization of their upstream genes within the spermatids  <cit> . similar studies have also been applied to the ciona intestinalis genome for novel ncrna family discovery  <cit> . with the finishing of the encode  <cit>  and modencode  <cit>  projects, we expect that much more rna transcripts will be experimentally identified. many of these rna transcripts may have exceptionally large sizes  <cit> , and calls for more efficient computational tools to analyze their structures.

as more rna transcripts are being discovered, the experimental approaches for probing ncrna structures are also being revolutionized, allowing more accurate functional investigation through exploiting the structure-function relationship. traditional rna three-dimensional  structure determination techniques such as x-ray crystallography, nmr and cryo-em are expensive, making them inappropriate for genome-wide survey of rna structures. currently, the emerging massive parallel sequencing technology has been incorporated into the traditional chemical probing methods, making genome-wide experimental determination of rna secondary structures possible and with low cost. available techniques in this category include pars  <cit> , fragseq  <cit> , and shape-seq  <cit> . the rna secondary structures determined by these techniques are much more accurate than those predicted by pure computational methods. for example, when coupled with shape-seq data, the free energy minimization approach  <cit>  is able to predict the secondary structure of a 16s rrna with over 95% accuracy  <cit> . in this case, the major purpose of this work is to develop an efficient and accurate rna secondary structure alignment algorithm to facilitate genome-wide comparative studies of these rna secondary structures.

there are many existing algorithms that focus on the rna secondary structure alignment problem  <cit> . rna secondary structures can be represented as tree structures, and the edit-distance between the tree structures can be used to represent their structural similarity  <cit> . algorithms using such strategy are usually called tree editing algorithms. using heavy path decomposition, klein  <cit>  improved the time complexity of the tree editing algorithm to o. recently, demaine et al. <cit>  further improved the time complexity to o based on klein’s algorithm. however, jiang et al. <cit>  proposed to compute tree alignment distance for the comparison of trees. algorithms that compute such a measure are called tree alignment algorithms. the tree alignment algorithm is a special case of the tree editing algorithm  <cit> . the tree alignment algorithm has been implemented into an rna secondary structure alignment tool called rnaforester <cit> . both the tree editing and tree alignment algorithms rely on tree representation of the rna structure, and make sophisticated scoring functions difficult to implement . in addition, both tree editing and tree alignment algorithms do not treat base pairs as units of comparison, and make it difficult to implement a complete set of base-pair edit operations for rna secondary structures editing . we demonstrate such a problem by showing a real example from the implementation of the widely-used rna secondary structure alignment tool rnaforester <cit> .

consider that the two rna structures shown in figure  <dig>  are being aligned as trees. in the first rna structure, due to the insertion of a uracil , an additional base pair is predicted . both structures are enclosed by g-c base pairs, and we focus on the alignment of their inner regions . following rnaforester’s extended tree representation  <cit> , the two rna structures can be transformed into two trees . the ‘p’ node represents a base pair formed between the two corresponding nucleotides. because there is no base pair in the second structure, the only allowed operations are bond breaking and base-pair deletion . for the bond breaking operation, the base pair formed between a and u is broken, leaving them aligned to a and g in the second structure, respectively . the alignment between the u  and g  introduces an unnecessary mismatch, making the alignment incorrect . for the base-pair deletion operation, the entire base pair  is deleted . this operation opens two unnecessary gaps in the alignment , making it underestimate the real structural similarity. on the other hand, we expect to handle the mis-predicted base pairs in a more straightforward way. as shown in figure  <dig> , we simply break the base pair interaction and disassociate the two corresponding nucleotides completely . these two nucleotides are then treated as regular unpaired nucleotides. we can use the standard sequence alignment algorithm  <cit>   to evaluate the pure sequence similarity between the boxed hairpin-loop regions . the resulting alignment contains only one gap, and correctly interprets the true structural difference between the two rna structures .

the above example clearly shows the limitation of the implementation of the tree-based rna secondary structure alignment algorithm rnaforester. implementing the complete set of base-pair edit operations under the tree representation appears to be not a trivial task. therefore, we propose to implement the general edit-distance alignment approach where all edit operations can be implemented naturally. to guarantee that the implementation is as efficient as the demaine et al.’s algorithm ), we incorporate the sparse dp technique into a simultaneous alignment and folding  algorithm rnascf <cit>  and restrict its input to fixed rna secondary structures . using this technique, we can reduce the original time complexity by reducing a factor from n <dig> to z, where n is the number of base pairs in the fixed rna structures and n<z<n <dig>  under the assumption of the polymer-zeta property of rna molecules  <cit> , it is expected that z≪n <dig> and even z∈o. in this case, the new general edit-distance rna structure-structure alignment algorithm will have a time complexity of o. the new time complexity has an expected cubic =o) growth behavior, and is the same as demaime et al.’s algorithm  <cit> . in addition, we also devise a novel online pruning technique to further speedup the new algorithm, which deletes obsolete candidates on-the-fly. by combining both speedup techniques, the new rna structure alignment algorithm is capable of comparing rna secondary structures efficiently and accurately.

we have implemented the proposed rna structure alignment algorithm into a program called era . the benchmark results showed that era has the expected o time complexity. we showed the o time complexity of era through aligning rfam  <cit>  rna structures that were carefully chosen to represent a wide rage of input sizes. we also used a bralibase ii  <cit>  benchmark to compare tools era, locarna and rnaforester when aligning rnas with known structures. nearly identical alignment quality can be observed for the general edit-distance alignment tools era and locarna, while both of them are more accurate than the tree alignment algorithm rnaforester. finally, we also concluded that era is efficiently implemented by observing an average of  <dig> fold speedup over locarna, and rnaforester in terms of real rna structure alignments. based on these results, we confirmed that the sparse dp technique and the online pruning technique are successfully incorporated into the original rnascf algorithm. we also anticipate that era will become an important bioinformatics tool for comparative rna structure analysis.

methods
in this section, we will present a novel general edit-distance rna structure alignment algorithm by incorporating the sparse dp technique into the rnascf algorithm. rnascf was originally designed to identify the consensus structure between two rna sequences. it guides the dp process though stacks and has a time complexity of o. comparing to locarna ), the indexing scheme used by rnascf makes it easier to incorporate the sparse dp technique, which aims to reduce the size of n instead of l. in addition to the sparse dp technique, we will also present an online pruning technique, which tries to reduce the search space of the algorithm as the dp proceeds. through combining these two speedup techniques, the novel algorithm will have an expected o time complexity, where n<z≪n <dig> 

the methods section is organized as follows: in section ‘preliminaries and definitions’, we will give the basic definition of rna structures and the rna alignment problem. in section ‘the original o algorithm’, we will reintroduce the rnascf algorithm as a basis to understand the novel algorithm that is developed in this work. in section ‘triangular inequality and optimal pair matchings’, we will present the triangular inequality in rna alignment with necessary proofs, which serves as a theoretical foundation for the sparse dp technique. in section ‘detection of optimal pair matchings’, we will further discuss the implementation details of incorporating the sparse dp technique. in section ‘a new algorithm with cubic time complexity’, we will present the novel rna alignment algorithm with the incorporation of the sparse dp technique. in section ‘online pruning of optimal pair matchings’, we will present the online pruning technique as an additional speedup step to the novel algorithm. finally, in section ‘pseudo-code’, we will summarize the new algorithm using pseudo-code that can be directly implemented.

preliminaries and definitions
we will begin with the introduction of the basic symbols and notations. the secondary structure of an rna a of length la is represented by a set of base pairs in a, denoted as pa. a base pair pa∈pa is an interaction formed between two nucleotides in the sequence of a, whose positions are denoted by l and r <r). the base pair pa can also be represented as ,r). the base pairs are partially ordered by the increasing order of their ending nucleotides, i.e. pia<pja if and only if r<r. since we do not consider rna ensembles, no crossing base pair is allowed. that is, we do not allow l<l<r<r. the two base pairs pia and pja are either enclosing or juxtaposing to each other. the base pair pja encloses pia if l<l<r<r, denoted as pia<ipja. the base pair pia juxtaposes to and beforepja if r<l, and is denoted by pia<jpja.

we also define loop regions  whose sequence similarities are assessed by the alignment. the loop regions can be viewed as the unpaired regions in the rna sequence that are segregated by the paired nucleotides. let a denote a continuous sequence region in rna a, which begins with the ith nucleotide and ends with the jth nucleotide. define l as the sequence a . if pia<ipja, define ll as the sequence a, and lr as the sequence a . if pia<jpja, define l as the sequence a .

the structure alignment between rna a and b is the optimal matching between their base-pair sets pa and pb and the corresponding loop similarities. in other words, the alignment between rnas a and b is a one-to-one binary relation a on the base-pair sets pa and pb. to ensure that the alignment will not lead to conflicting base-pair matchings, for any ∈a and ∈a, either pia<ipja and pi′b<ipj′b, or pia<jpja and pi′b<jpj′b. given the alignment  a, the matched base pairs in  a will partition the rna sequences a and b into two sets of loop regions, ℒaa and ℒab, respectively. the sequence similarity between these two sets of loop regions is added to compute the overall alignment score. the optimal alignment is the relation  a that maximizes overall alignment score m that combines both structure and sequence similarities:

  m=w1∗∑∈asstr+w2∗∑sseq. 

here, the first term is the summation of all structural similarities  between the annotated base pairs. the structural similarity score for base-pair substitution is set using the ribosum matrix  <cit> , denoting such base-pair substitution matrix as r. we do not give penalty for base-pair deletion or insertion, as we may expect incorrectly predicted base pairs in the input rna structures. the second term is the summation of the sequence similarities  on all loop  regions that are determined by base-pair matchings in a. the sequence similarity between two sequence regions is computed as traditional sequence alignment, with d as a 4-by- <dig> matrix that accounts for nucleotide substitution , g as the gap opening penalty, and e as the gap extension penalty  <cit>  . the weights w <dig> and w <dig> are used to balance the structural and sequence contribution to the overall alignment score, and we set w1>w <dig> to emphasize structural similarity. to simplify the expressions, in the rest of this article, we assume that w <dig> has been multiplied to all structural similarity terms , and w <dig> has been multiplied to all sequence similarity terms .

we will now define the matrices that are used by the dp algorithm. denote m as the optimal structure alignment score between the regions enclosed by pa and pb, given that pa is matched with pb. denote mh as the optimal alignment score when the matching of pa and pb corresponds to a hairpin loop in the consensus structure. similarly, ml stores the optimal alignment score when the matching of pa and pb corresponds to an internal, a bulge, or a multi loop in the consensus structure. assume that pia<ipa, and pi′b<ipb, ml can be computed by referring to the matrix mc, which stores the optimal alignment score between the juxtaposed base-pair chains  that end with pia and pi′b, respectively. the optimal alignment between a and b can be retrieved from m, where p0a and p0b are pseudo base pairs such that p0a=, p0b=, and sstr= <dig> <cit> .

the original o algorithm
in this section, we briefly reintroduce the rnascf <cit>  algorithm for rna consensus structure prediction as a basis for understanding the novel algorithm developed in this work. the recursive functions for the rnascf algorithm are outlined as follows:

  m=maxmh,ml. 

  mh=sstr+sseq,l). 

  ml=sstr+maxi,i′mc+sseq,lr). 

  mc=maxpja∈fpj′b∈fm+sseq,ll),mc+m+sseq,l),mc+g|+|l|),mc+g|+|l|). 

in these recursive functions, sstr denotes the structural similarity between two base pairs pa and pb, sseq denotes the sequence similarity between two unpaired regions, and g indicates the gap penalty for completely deleting the corresponding unpaired region. note that g=g+|l|∗e if |l|> <dig>  and g= <dig> otherwise. the base pair set f contains all base pairs that are directly before and juxtaposed to pia. in other words, if pja∈f, then there is no such base pair pka, such that pja<jpka<jpia. in most real scenarios, |f| is considered as a constant  <cit> . this chaining technique based on the  f set enables us to handle the multi-loop case efficiently, by only considering |f| cases when computing mc.

recall that the input rna sequences have an average length of l and form an average of n base pairs. this algorithm can be computed with an expected time complexity of o. to see the time complexity, first note that all sequence similarity scores that are referred in the recursive functions can be computed within o time. because all loop regions are segregated by base pairs, the number of loop regions is clearly bounded by o. therefore, there are o combinations of loop matchings, and computing each matching requires o time using a standard sequence alignment algorithm  <cit> . to this point, we assume all sequence similarities are computed using o time, and are stored in a matrix for constant-time lookup. now, observe that this algorithm computes the optimal alignment by filling up the dp table m, which contains o values. computing each value in the matrix m depends on the corresponding values of mh, ml, and mc. the computation of values in matrix mh can be finished in a constant time due to the pre-computed sequence similarities. the computation of ml requires o time, as determined by the necessity of traversing all possible combinations i and i′ . finally, mc can also be expected to be computed in a constant time, as |f| is assumed to be a constant. in this case, the computation of matrix m requires o time. adding up the time required to pre-compute all sequence similarities of the loops, the overall time complexity for this algorithm thus becomes o.

triangular inequality and optimal pair matchings
the triangular inequality property servers as the theoretical foundation for the sparse dp technique, which saves search space while maintaining the global optimality. for computational rna studies, this technique has been used in rna folding  <cit> , rna consensus folding   <cit> , as well as rna-rna interaction prediction  <cit>  applications. in this work, our aim is to bring this technique into the rna structure alignment application, where fixed rna structures are considered instead of rna structure ensembles.

consider the alignment between the rna secondary structures within the two regions a and b ). denote m as the optimal alignment score for such alignment. the triangular inequality can be summarized using the following inequality:

 m≥m+m, 

where i≤k<j and i′≤k′<j′. this is because the partitions of the regions a and b at positions k and k′, respectively, do not necessarily compatible with the optimal alignment.

to simplify the expression of the triangular inequality property, we define a number of pseudo base pairs to indicate specific regions of interest. a pseudo base pair is a void interaction, such that the structural similarity between any two pseudo base pairs is defined to be  <dig>  for instance, let p and p′ be two arbitrary pseudo base pairs, we will have sstr= <dig>  the pseudo base pairs are only used for the sake of representational simplicity, and are not required for the implementation of the algorithm. define a pseudo base pair pa= and a pseudo base pair pb=. in this case, the optimal alignment score between the regions a and b, i.e. m, can be rewritten as m. similarly, define pseudo base pairs pla=, pra=, pl′b=, and pr′b= ). the triangular inequality can be simplified using the following observation:

observation 1
 m≥m+m .

using observation  <dig>  we can detect potential redundant computations in the original algorithm. consider the structural configurations shown in figure  <dig> , and assume that the base pairs pa and pb are being aligned at the current stage. let p∗a and pχa be arbitrary base pairs such that pχa<ipa<ip∗a. note that pχa may also represent a pseudo base pair in order to consider an arbitrary subregion enclosed by pa. define pseudo base pairs pαa=,l-1), pβa=,l-1), pδa=+ <dig> r), pεa=+ <dig> r), pλa=,l-1), and pθa=+ <dig> r). pseudo base pairs are also added to b symmetrically ). we can then prove lemma  <dig> using observation 1:

lemma 1
if ∃pχa and pχ′b, such that m+m+m≥m, then m+m+m≥m+m+m.

proof
 m+m+m≥m+m+m+m+m≥m+m+m. 

□

the first inequality is a direct application of observation  <dig>  and the second inequality is specified in the condition of lemma  <dig> 


because p∗a and p∗′b are arbitrary base pairs, lemma  <dig> implies that the matching between pa and pb is guaranteed to be suboptimal. that is, the overall alignment score, given that pa matches with pb, is always lower than that when assuming they do not match . in this case, we can devise the dp algorithm to bypass the redundant references to the scenarios where pa matches pb. conversely, for the implementation of this idea, the dp algorithm will refer to the scenarios of matching pa and pb only when the condition specified in lemma  <dig> is not satisfied. these necessary base-pair matchings are called the optimal pair matchings . if the matching of pa and pb is an opm, we denote this opm as oa,b. similarly, we represent the opm formed by base pairs pia and pi′b as oi,i′a,b. the new rna alignment algorithm will maintain an opm list  o, which is modified online as the dp proceeds, so as to include newly identified opms and remove obsolete opms . if we assume that the rna molecules have the polymer-zeta property  <cit> , restricting the search space of the dp using the opm list  o will reduce the time complexity of the rna alignment algorithm to o .

detection of optimal pair matchings
in the previous section, we have proved that lemma  <dig> can be used to detect the opms and save redundant computations. in this section, we will briefly discuss how it will be implemented. lemma  <dig> states that if the alignment score assuming pa matches pb  is higher than the alignment score assuming pa does not match pb, the matching between pa and pb is an opm. therefore, to detect the opms, we need to compute two alignment scores, i.e. the one when assuming pa matches pb and the one when assuming pa does not match pb.

based on previous definition, the first alignment score is computed as m. in this case, we only need to compute the second alignment score. however, computing the second alignment score  is difficult. instead, we can compute the overall alignment score without assuming any restrictions. apparently, the overall alignment score includes both cases disregarding whether pa matches with pb. therefore, if m is greater than or equal to such an overall optimal alignment, it is guaranteed to be greater than the alignment score when assuming pa does not match pb, and ipso facto the matching of pa and pb is an opm.

recall that the alignment score m corresponds to the case where pa matches with pb, and therefore it can be decomposed as the sum of two parts: the structure similarity between the two base pairs themselves sstr, and the optimal alignment score between the regions a and b without any restrictions. in this case, define two pseudo base pairs p¯a=- <dig> r+1) and p¯b=- <dig> r+1), then m can also be decomposed as the sum of two parts: sstr, and the optimal alignment score between the regions a and b without any restrictions. note that p¯a and p¯b are both pseudo base pairs, and thus based on the definition, we have sstr= <dig>  therefore, m is exactly the overall alignment score we need to detect the opms.

in this case, based on lemma  <dig>  if m≥m, we will consider the matching of pa and pb as an opm, and add the opm oa,b to the opm list  o. the overhead for detecting the opm is that we need to double the computation for each combination of pa and pb. however, such overhead will not raise the time complexity, and it is worthy as it will lead to a more significant speedup of the algorithm. in the following section, we will devise a new algorithm by assuming that the opm list  o is available.

a new algorithm with cubic time complexity
in this section, we introduce a new general edit-distance rna structure alignment algorithm, which improves the original rnascf algorithm based on lemma  <dig> and has a time complexity of o). here, z is the size of the opm list  o, and we expect that z∈o when assuming polymer-zeta property  <cit> . if we also assume o=o , the overall time complexity of the new algorithm becomes o.

the new algorithm is developed based on the rnascf algorithm  <cit> . therefore, we adopt the same definition and notation as introduced in section ‘preliminaries and definitions’, as well as the similar recursive functions style used in section ‘the original o algorithm’. because the computations of m and mh are boundary cases for the algorithm and are directly computed without referring to previous alignment results, the recursive functions for computing them are exactly the same as in the original algorithm:

  m=maxmh,ml. 

  mh=sstr+sseq,l). 

the computation of ml, on the other hand, refers to the previous alignment results that assumes pia matches pi′b . using lemma  <dig>  it is clear to see that instead of traversing all combinations of pia and pi′b, we only need to consider the cases when the matching of pia and pi′b is an opm:

  ml=sstr+maxoi,i′a,b∈omc+sseq,lr). 

similarly, for the computation of mc, we need to refer to the scenarios where pia matches pi′b and pja matches pj′b. the matching of pia and pi′b is guaranteed to be an opm, as ensured by equation  <dig>  therefore, we only need to modify equation  <dig> to ensure that the matching of pja and pj′b is an opm:

  mc=maxoj,j′a,b∈fm+sseq,ll),mc+m+sseq,l),mc+sseq,l)+sseq,l). 

here, the set f contains all opms that are directly before the opm oi,i′a,b. the  f set regarding the opms is defined as the follows. if an opm oj,j′a,b∈f, then either pja∈f or pj′b∈f.

recall that the time complexity of the original algorithm is o. the first term o results from o computations by traversing all combinations of pa and pb  and o time for computing ml . in the new algorithm, we introduce the opm constraint to equation  <dig> and equation  <dig>  and thus reduce the time complexity for computing ml from o to o. in this case, the first term o of the original time complexity can be reduced to o.

the second term o in the original time complexity results from computing the sequence similarities between all loop regions. note that all loop similarities required for computing ml  and mc  are associated with opms. for example, in equation  <dig>  all the loops are defined according to pia and pi′a, whose matching is expected to be an opm. and in equation  <dig>  all the loops are defined according to pia and pi′a, as well as pja and pj′b, where both of these matchings are assumed to be opms. in this case, we do not need to compute loop similarities for all o base-pair combinations, instead we only need to compute the loop similarities that are associated with the opms. in this case, the time complexity for computing the sequence similarities between all loops that are required by the computation of ml and mc can be finished in o time.

the only exception for the sequence similarity computation is the hairpin loop similarity sseq,l), which is required for computing mh . the computation of mh is not constrained by the opm list, and therefore o time is still required. to resolve this issue, we observe that most of the rna structure alignment algorithms emphasize the structure similarity other than sequence similarity . in this case, if there exist some base pairs within the regions enclosed by pa and pb to be matched, we can expect that ml>mh in equation  <dig>  in this case, to avoid the unnecessary computation of mh, we can derive an upper bound m^h, which satisfies m^h>mh and can be estimated in unit time. note that if ml>m^h, we are sure that ml>mh by transition, and thus can save the computation of mh. the upper bound m^h can be easily derived by assuming maximum number of nucleotide matchings and minimum number of gaps:

  m^h=sstr+min|,|l|)∗dmax+i∗g+|-|l||)∗e, 

where dmax is the highest score in the 4-by- <dig> nucleotide substitution matrix d, and i is a boolean variable that is set to  <dig> if |l|≠|l| and set to  <dig> otherwise. for the computation of each m, we first estimate the upper bound m^h in a unit time, and then compute ml in o time. by comparing these two values, we will determine whether the computation of mh is necessary. the computation of mh is only necessary when there are only a few base pair enclosed by pa and pb to be matched. such condition implies the scenarios that either pa or pb is a real hairpin loop in the rna structures, whose number is bounded by o. overall, the hairpin loop similarity matrix mh can be computed in o time, and the overall time complexity of this algorithm is thus o).

online pruning of optimal pair matchings
in the previous sections, we have presented our approaches for detecting opms and building an opm list  o, as well as a more efficient algorithm that is developed based on  o. time complexity analysis of the algorithm claims that o) time is sufficient for this new algorithm. the size of the opm list  o, i.e. z, thus becomes an important factor that determines the efficiency of the novel algorithm. under the current algorithmic setup, as well as other similar works that implement a candidate list  <cit> , z continuously grows as the algorithm proceeds. in this case, it is desirable to devise an online pruning technique, which can remove the obsolete opms from  o, and thus achieve further speedup of the algorithm.

in this section, we will present such an online pruning technique to reduce the size of the opm list  o. the intuition of this online pruning technique comes from the following observation. the rna structures are primarily stabilized by a number of helices, or perfectly stacked base pairs. if pja is perfectly stacked on pia, then l=l- <dig>  and r=r+ <dig>  consider the alignment between two helices, where each one of them contains m+ <dig> perfectly stacked base pairs. assume that the first helix contains base pairs pia,pi+1a,…,pi+ma, and the second helix contains base pairs pi′b,pi′+1b,…,pi′+mb. based on lemma  <dig>  there will be at least m opms detected from such alignment, i.e. oi,i′a,b,oi+ <dig> i′+1a,b,…,oi+m,i′+ma,b. apparently, maintaining all these m opms is unnecessary, as these base pairs should be aligned together as two complete helices, rather than be aligned separately as two sets of individual base pairs. in this case, maintaining only one opm, i.e. oi+m,i′+ma,b, is sufficient to represent such an alignment. the other m opms become obsolete as soon as the opm oi+m,i′+ma,b is detected, and can be removed from the opm list  o to improve computational efficiency. in the following paragraphs, we will extend this idea to consider all situations in addition to the perfectly stacked scenario, as well as give formal description of this technique and related proofs.

we will demonstrate the major idea of our novel online opm pruning technique using figure  <dig> . imagine that at the current stage, m has just been computed and oa,b has been identified as an opm, where oχ,χ′a,b is an arbitrary opm that has been previously identified and is enclosed by oa,b . our aim is to estimate whether the detection of the opm oa,b will make oχ,χ′a,b obsolete. let p∗a and p∗′b be arbitrary base pairs such that pa<ip∗a and pb<ip∗′b. the regions enclosed by p∗a and p∗′b can be partitioned using at least one of the following ways: m+m+m ) and m+m+m ). if the corresponding score for the first path is higher than the second, m will not be referred to by any future matching between arbitrary base pairs p∗a and p∗′b, and thus making the opm oχ,χ′a,bobsolete. in this case, the opm oχ,χ′a,b can be removed from  o.

we can summarize the criterion for removing oχ,χ′a,b as an obsolete opm using the following inequality:

 m+m+m≥m+m+m, 

which can be rewritten as:

 m-m≥+. 

to utilize such criterion, we need to have access to all values included in the above inequality. however, we only know the values at the left hand side of the inequality , while the other values at the right hand side are unknown. this is because the definitions of these pseudo base pairs are determined by p∗a and p∗′b, which are arbitrary base pairs that have not yet been computed by the dp algorithm. to solve this issue, observe that the score m-m is strongly related to the regions a and b, and m-m is strongly related to the regions a and b. note that the regions a and a can be determined when pa and pχa are known, which makes the estimation of their impact on future alignments possible …r] and b). in this case, we can develop two upper bounds Ûβ and Ûδ, such that:

 Ûβ≥m-m,Ûδ≥m-m. 

in this case, if m-m≥Ûβ+Ûδ, we are sure that the criterion for characterizing oχ,χ′a,b as an obsolete opm will be satisfied, and we will be able to remove oχ,χ′a,b from  o immediately.

now, we can discuss the details for setting up the upper bounds Ûβ and Ûδ. because Ûβ and Ûδ are defined symmetrically, we only discuss the computation of Ûβ. note that the upper bound Ûβ needs to satisfy the condition Ûβ≥m-m. clearly, the difference between m-m directly comes from concatenating the region a to the region a, as well as concatenating the region b to the region b. the best case scenario for such an operation, is to assume that the concatenation of the regions a and b will result in as many new base-pair and nucleotide matches as possible.

assume that there are mβa base pairs that are annotated in the region a, and mβ′b base pairs that are annotated in the region b. also assume the maximum base-pair substitution score in the ribosum matrix r is rmax. by concatenating the regions a and b, we introduce at most max more base-pair matchings to the alignment indicated by m. this implies the maximum structure alignment score increment of max∗rmax. similarly, at most max|,|l) more nucleotide matches, or gap fill-ups, are possible, compared to the existing alignment indicated by the score m. the corresponding alignment score for such case is thus: max|,|l)∗. to explicitly represent the upper bound using only the identified opms, we rename Ûβ as Ûl . therefore, Ûl and Ûr can be computed using the following equations:

  Ûl=max∗rmax+max|,|l|)∗,Ûr=max∗rmax+max|,|l|)∗. 

with the upper bounds Ûl and Ûr, we are able to formally prove the correctness of the online opm pruning technique:

lemma 2
if m-m≥Ûl+Ûr, where Ûl≥m-m and Ûr≥m-m, then m+m+m≥m+m+m.

proof
 m≥m+Ûl+Ûr⇒m+m+m≥m+Ûl+Ûr+m+m⇒m+m+m≥m+m+m. 

□

as a result, when the condition given in lemma  <dig> is satisfied, the enclosed opm oχ,χ′a,b can be readily removed.

pseudo-code
the pseudo-code for the new rna secondary structure alignment algorithm that implements both speedup techniques is summarized in figure  <dig> 

RESULTS
we implemented the proposed general edit-distance rna structural alignment algorithm into a program called era  using gnu c++. in this section, we will show that  era has the expected o time complexity;  era is as accurate as the other state-of-the-art rna alignment tools; and  era runs much faster than the other rna alignment tools. in addition to these goals, we have also benchmarked era to demonstrate its o space complexity. for details regarding the space complexity issues please refer to the additional file 1: section s <dig> .

we benchmarked the era with two other state-of-the-art rna alignment tools: locarna as a representative of the general edit-distance rna structure alignment algorithms and rnaforester as a representative of the tree-based rna structure alignment algorithms. note that although locarna is developed to compare rna structure ensembles, its flexible parameter setup makes it easy to prune its input rna ensembles . however, the readers should note that locarna is used in a restricted case for fair comparison with era, and more potential applications of locarna should be recognized. we do not compare era with its predecessor rnascf, because rnascf is implemented to find consensus helical configurations that do not include individual base pairs  <cit> . both locarna and rnaforester were invoked using their default parameters.

running locarna
note that locarna was originally developed to compare two rna structure ensembles  <cit> . due to the recent technical advances in experimental rna structure probing, we anticipate that rna structures can be predicted with much higher accuracy. therefore, we develop era to compare two fixed rna structures. in this case, we need to prune the original inputs of locarna, so as to ensure that they only represent the fixed structures rather than any additional information.

the input rna ensembles for locarna are represented using the base-pairing probability matrices, which can be computed using the mccaskill’s algorithm  <cit> . in a base-pairing probability matrix, each base pair  is assigned with a probability to indicate its thermodynamic stability. our goal is to prune such a base-pair probability matrix, such that it only contains information regarding the fixed rna structure . for each base pair in the matrix, if it is not presented in the annotated structure, its corresponding probability is reset to  <dig>  on the other hand, if it is included in the annotated structure, its probability is reset to  <dig>  in this case, the pruned base-pairing probability matrix contains only the information regarding the fixed rna structure. we show an original and a pruned base-pairing probability matrix in additional file 1: figure s <dig> as an example. all locarna inputs for experiments mentioned in this article are preprocessed using this strategy.

time complexity
in this section, we expect to show that the proposed sparsification is successfully implemented, and era has the expected o time complexity. to show the o time complexity, we chose a number of rna families from rfam that have a wide range of sequence lengths. we then randomly selected two individual rna structures from each family  to run era alignment. the running time for their alignments, versus n <dig> =o), is plotted in figure  <dig> . we can clearly observe the expected o time complexity from the figure. in addition, we are also able to show that the speedup ratio, when comparing to the olocarna algorithm, is strongly correlated with the efficiency of pair matching reduction due to the sparse dp technique ). the relatively large deviations are observed for biocoid_3utr and snr <dig> rna structures. this is because they contain a large number of base pairs and have a high base pair to sequence length ratio. in this case, the overhead for maintaining the opm list becomes apparent and makes the speedup less significant. in summary, we have shown that the sparse dp technique is successfully implemented, era has an expected time complexity of o.

alignment quality
in addition to time complexity improvement, we also expect to show that era is as accurate as the other state-of-the-art general edit-distance rna structure alignment tools. we used bralibase ii  <cit>  as the reference data set, and used its corresponding structure annotations as the fixed input structures. we adopted two measures to indicate the alignment quality, i.e., the sum-of-pair score   <cit>  and the structure conservation index   <cit> . the benchmark results are shown in figure  <dig>  the alignment qualities of era and locarna are nearly identical, since incorporating the sparse dp technique will not compromise global optimality. the benchmark results also show that era and locarna can produce more accurate alignments when compared to rnaforester. this is because era and the restricted version of locarna are both general edit-distance rna alignment algorithms that are capable of flexibly handling incorrectly predicted base-pairs, while rnaforester is more sensitive to such errors, since it implements tree alignment.

running time speedup
finally, after benchmarking the time complexity and alignment accuracy of era, we also expect to show that era is an efficient implementation and can run faster than other state-of-the-art rna alignment tools. we compared the real running time of era, locarna, and rnaforester on the selected rna structures from rfam. the benchmark results are summarized in table  <dig>  we can observe that era is capable of speeding up locarna by a minimum of  <dig>  fold and a maximum of  <dig>  fold. era can also speedup rnaforester by a minimum of  <dig>  fold and a maximum of  <dig>  fold, with only one exception in which rnaforester is  <dig>  times faster than era. this is because the rna structures being aligned  contain only one stem-loop structure; and in such a special case, the time complexity of rnaforester becomes o  <cit> .

*era is slower than rnaforester when aligning snr <dig> rna structures.

to further investigate the real running time speedup of era on randomly selected rna structures, we compiled a much larger data set that contains  <dig>  pairs of randomly selected rna structures from rfam. the benchmark results on this large data set are summarized in figure  <dig>  in figure  <dig>  we can see that era  runs much faster than locarna  and rnaforester . in addition, we can also observe that the running time of era grows slower than those of locarna and rnaforester, which further confirms our previous time complexity analysis ). this speedup is significant, and renders era with the power of aligning long ncrnas that are revealed by recent research advances. in summary, era is an efficient and accurate rna structure alignment tool as compared to its state-of-the-art counterparts locarna and rnaforester.

discussion and 
CONCLUSIONS
in this article, we have presented a novel algorithm for efficient alignment of rna secondary structures by incorporating the sparse dp technique. the major theoretical contribution of this work lies in two parts. first, to our knowledge, this is the first application of the sparse dp technique to rna structure-structure alignment. second, the novel online opm pruning technique can provide insights for future algorithm designs that need to maintain a candidate list. the implementation of this novel algorithm is a tool called era, which can run in o time and o. such time and space complexity make era one of the most efficient rna structure alignment tools that are currently available.

the online opm pruning technique is newly developed from this work, which aims at deleting obsolete candidates as the dp proceeds. although this technique cannot improve the computational complexity, it is efficient in reducing the real running time. in additional file 1: table s <dig>  we summarized the running time of era in aligning individual rna structures, with or without the online opm pruning technique. we observed that by incorporating this technique, the running time of era was reduced by an average of  <dig>  fold. meanwhile, the speedup ratio is highly uniform  across rna structures with different sizes, meaning that it reduces running time by a constant factor. the online opm pruning technique can also be modified and incorporated into other related algorithms that implement the candidate list, such as the sparse dp algorithms for rna folding  <cit> , rna consensus folding  <cit> , and rna-rna interaction  <cit> .

the speedup of era is most significant when the number of base pairs in the rna structures is small. this is because the algorithm is indexed by base pairs and has a time complexity of o). as n increases, the term o will dominate the overall time complexity. in this case, an ideal application of era is to align fixed rna structures, because it guarantees that n<l. note that as a sparsified version of the saf algorithm rnascf <cit> , the new algorithm developed here is also capable of handling rna structure ensemble alignments. however, we do not implement this feature into era, because one cannot guarantee n<l for rna ensemble alignments. this would make the speedup of era less significant. besides, there are other alternative tools  <cit>  available for such a purpose.

with the completion of the encode  <cit>  and modencode  <cit>  projects, more and more rna transcripts will be experimentally revealed. at the same time, with the advance of high-throughput rna structure probing techniques  <cit> , the secondary structures of these rna transcripts will also be predicted with a much higher accuracy. in this case, era, which can compare fixed rna structure efficiently and accurately, becomes an ideal computational tool to evaluate the structural similarities of these rna transcripts. era can be used to perform all-against-all alignments on these rna transcripts, which will then be subsequently summarized as the distance matrix for clustering purposes. various clustering algorithms  <cit>  can then be applied to identify ncrna families with similar secondary structures and infer their amazing cellular and molecular functionalities.

competing interests
the authors declare that they have no competing interest.

authors’ contributions
sz contributed with the conception of the research. sz and cz designed the algorithm. cz implemented the algorithm and performed benchmark analysis. sz and cz wrote the manuscript. both authors read and approved the final manuscript.

supplementary material
additional file 1
supplementary information. this file contains four sections. in section s <dig>  we briefly discuss the space issue of era and provide related experimental results. in section s <dig>  we document the randomly selected rna structures used for experiments mentioned in the main article. in section s <dig>  we evaluate the impact of the online opm pruning technique in speeding up era. in section s <dig>  we give examples of the pruned base-pairing probability matrix for executing locarna.

click here for file

 acknowledgements
this work is supported by the national institute of general medical sciences of the national institutes of health, usa .
