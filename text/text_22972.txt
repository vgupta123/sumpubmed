BACKGROUND
assessment of data quality is an important component of the analysis pipeline for gene expression microarray experiments  <cit> . although careful pre-processing and normalisation can ameliorate some problems with microarray data, including background fluorescence, dye effects or spatial artifacts  <cit> , many sources of variation can affect the experimental procedure  <cit>  and it is inevitable that variations in data quality will remain. in this article we demonstrate an approach in which variations in data quality are detected and adjusted for as part of the differential expression analysis. the method is widely applicable, easy to use and can have a high payoff.

quality assessment procedures can be applied at the probe level or at the array level. probe quality is influenced by local factors on the array such as printing irregularities or spatial artifacts. for spotted microarrays, spot-specific morphology and signal measurements obtained from image analysis software can be used to assign a quality score to each probe on the array  <cit> . spots with low quality scores are commonly removed from further analysis. an alternative approach is to measure agreement between gene expression values from repeat probes directly and eliminate those spots with inconsistent replicate values  <cit> . for high-density oligonucleotide microarrays with multiple probes per gene, quality measures can be obtained from probe level models . image plots of robust weights or residuals obtained from robust plms can highlight artifacts on the array surface  <cit> .

probe quality assessment is not sufficient because some artifacts only become evident at the array level. indeed the detection of problems is even more critical at the array level than at the probe level because a single bad array may constitute a sizeable proportion of the data from a microarray experiment. the quality of data from an entire array can be influenced by factors such as sample preparation and day-to-day variability  <cit> . sub-standard arrays are typically identified using diagnostic plots of the array data  <cit> . the correlation between expression values of repeatedly spotted clones on an array is also used as an array quality measure  <cit> . where large data sets are available, a statistical process control approach can identify outlier arrays  <cit> . in affymetrix genechip experiments, array quality can be assessed using plm standard errors or from rna degradation plots  <cit> .

almost all the methods cited above classify the data as either "good" or "bad", and exclude "bad" probes or arrays from further analysis. in our experience however the "bad" arrays are usually not entirely bad. very often the lesser quality arrays do contain good information about gene expression but which is embedded in a greater degree of noise than for "good" arrays. in this article, a graduated, quantitative approach is taken to quality at the array level in which poorer quality arrays are included in the analysis but down-weighted.

quality assessment methods can be divided into those which are "predictive" and those which are "empirical". the operational meaning of quality is that high quality features produce highly reproducible expression values, while low quality features produce values which are more variable and hence less reproducible. predictive quality assessment methods attempt to predict variability by comparing features such as spot morphology to normative measures. on the other hand, methods which compare duplicate spots within arrays are empirical in that they observe variability.

in this article we extend the empirical approach to multi-array experiments for which we measure the discrepancies between replicate arrays. in order to be as general as possible, we do not limit ourselves to simple replicate experiments, but work with a linear model formulation which allows us to handle experiments of arbitrary complexity including those with factorial or loop designs. the degree of replication in such experiments is reflected in the residual degrees of freedom for computing the residual standard errors. our method is implemented by way of a heteroscedastic variance model. it is common for statistical models of microarray data to allow each probe to have its own individual variance. our heteroscedastic model allows the variance to depend on the array as well as on the probe. the array variance factors then enter into the subsequent analysis as inverse array quality weights. importantly, our method not only detects variations in data quality but adjusts for this as part of the analysis.

our approach can be combined with predictive quality assessment methods and is an effective complement to them. predictive methods can be used to filter spots or to provide quantitative prior spot weights which are incorporated into the linear model analysis. however the causes of poor quality data cannot always be clearly identified. the empirical array weight method described here estimates and accommodates any variation in quality which remains after the spot quality weights have been taken into account, i.e., after prediction has achieved as much as it can. our approach is particularly effective when arrays vary in quality but the problems cannot be isolated to particular regions or particular probes on the offending arrays.

the presence of array-level parameters in our heteroscedastic model means that the statistical analysis can no longer be undertaken in a purely gene-wise manner. a naive approach to fitting the model would be computationally expensive. we propose two computationally efficient algorithms for estimating the model by the well-recognised statistical criterion of residual maximum likelihood . these algorithms view the microarray data as many small data sets, one for each probe, with a small number of shared parameters corresponding to the array variance factors. an innovative gene-by-gene update procedure is proposed for particularly fast approximate reml estimation.

the array weight method developed here can be applied to any microarray experiment with array-level replication, including experiments using high-density oligonucleotide arrays, but our experience is mainly with experiments using spotted microarrays. high density arrays allow the additional possibility of measuring reproducibility for multiple probes for each gene rather than relying on gene or probe-set summaries  <cit> . a full treatment of empirical array quality for these platforms is therefore likely to involve an analysis of reproducibility at both the probe level and probe-set level, a further development which is not investigated in this article.

in this paper, the linear model approach to microarray data analysis is reviewed and the heteroscedastic model which includes array weights is introduced. next, the experimental and simulated data sets used in this study are explained and results for these data are presented. the computational algorithms for fitting the heteroscedastic model are then described, followed by discussion and conclusions. supplementary materials including data, r scripts and additional plots are available  <cit> .

linear models for microarray data
linear models provide a convenient means to measure and test for differential expression in microarray experiments involving many different rna sources  <cit> . the linear model approach allows a unified treatment of a wide variety of microarray experiments, including dye-swaps, common reference experiments, factorial experiments and loop or saturated designs, with little more complication than simple replicated experiments. although the statement of the linear model, given below, requires some mathematical notation, the application of the methods we describe is in practice very simple using available software. consider a microarray experiment with expression values ygj for genes g =  <dig>  ..., g and arrays j =  <dig>  ..., j. the expression values could be log-ratios from two-colour microarrays or summarised log-intensity values from a single-channel technology such as affymetrix genechips. we assume that the expression values have been appropriately pre-processed, background corrected and normalised. the term gene is used here in a general way to include any ests or control probes that might be on the arrays. assume that the systematic expression effects for each gene can be described by a linear model

e = xβ g     

where yg = t is the vector of expression values for gene g, x is a known design matrix with full column rank k, and βg = t is a gene-specific vector of regression coefficients. the design matrix will depend upon the experimental design and choice of parameterisation and the regression coefficients represent log-fold changes between rna sources in the experiment  <cit> . for example, consider a two-colour microarray experiment with three replicate arrays comparing rna sources a and b. the individual log-ratios ygj = log <dig>  where rgj and ggj are the cy <dig> and cy <dig> intensities, measure differences in gene expression between the two samples. for a simple replicated experiment with sample b always labelled cy <dig>  the design matrix would be a column of ones, and the coefficient βg would represent the log-fold-change for gene g in sample b over a. replicated experiments with dye-swaps would be the same except that minus ones would indicate the dye-swap arrays. consider another example where samples a and b are compared through a common reference sample. if there are two arrays for each sample and the common reference is always cy <dig>  then the design matrix would be

x=.
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaacqwgybawcqgh9aqpdaqadaqaauaabaaaeiaaaaqaaiabigdaxaqaaiabicdawaqaaiabigdaxaqaaiabicdawaqaaiabigdaxaqaaiabigdaxaqaaiabigdaxaqaaiabigdaxaaaaiaawicacaglpaaacqgguaglaaa@38e8@

here the first coefficient βg <dig> estimates the log-fold-change between a and the common reference while the second coefficient βg <dig> estimates the comparison of interest between b and a. the design matrix can be expanded indefinitely to represent experiments of arbitrary complexity.

the linear model also assumes

var = σg2
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaaiigacqwfdpwcdaqhaawcbagaem4zacgabagaegomaidaaaaa@30ec@/wgj     

where wgj is a prior spot quality weight and σg2
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaaiigacqwfdpwcdaqhaawcbagaem4zacgabagaegomaidaaaaa@30ec@ is the unknown gene-specific variance factor. the spot quality weights will usually have arisen from a predictive spot quality assessment step, with large weights representing good quality spots and low weights representing poor quality spots. to avoid unnecessary complications we will assume throughout that all the ygj are observed and that all the spot weights are strictly positive, wgj >  <dig>  in practice, the methods developed in this article can be modified to accommodate missing y-values or zero weights, but this complicates the presentation somewhat and will be omitted.

for simplicity we will assume that the ygj are normally distributed and that expression values from different arrays are independent. the weighted least squares estimator of βg is

β^g=−1xtΣg−1yg     
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaaiiwacuwfyogygaqcamaabaaaleaacqwgnbwzaeqaaogaeyypa0jaeiikagiaemiwag1aawbaasqabeaacqwgubavaagccqqhjowudaqhaawcbagaem4zacgabagaeyoei0iaegymaedaaogaemiwaglaeiykakyaawbaasqabeaacqghsislcqaixaqmaagccqwgybawdaahaawcbeqaaiabdsfaubaakiabfo6atnaadaaaleaacqwgnbwzaeaacqghsislcqaixaqmaaacbegccqgf5bqedawgaawcbaacbagae03zacgabeaakiaaxmaacawljawaaewaaeaacqaizawmaiaawicacaglpaaaaaa@4be8@

where Σg = diag is the diagonal matrix of prior weights. the t-statistic for testing any particular βgk equal to zero is

tgk=β^gksgcgk
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaacqwg0baddawgaawcbagaem4zacmaem4aasgabeaakiabg2da9maalaaabaaccigaf8nsdimbakaadawgaawcbagaem4zacmaem4aasgabeaaaoqaaiabdohaznaabaaaleaacqwgnbwzaeqaaowaaoaaaeaacqwgjbwydawgaawcbagaem4zacmaem4aasgabeaaaeqaaaaaaaa@3e00@

where sg2
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaacqwgzbwcdaqhaawcbagaem4zacgabagaegomaidaaaaa@3091@ is the residual mean square from weighted regression and cgk is the kth diagonal element of −1
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaacqggoaakcqwgybawdaahaawcbeqaaiabdsfaubaakiabfo6atnaadaaaleaacqwgnbwzaeaacqghsislcqaixaqmaagccqwgybawcqggpaqkdaahaawcbeqaaiabgkhitiabigdaxaaaaaa@3931@.

it is important to appreciate that the spot weights wgj act in a relative fashion for each gene. the t-statistic tgk and its associated p-value would be unchanged if all the wgj for a given g were scaled up or down by a constant factor. hence it is only the relative sizes of the wgj across arrays j for any given g which are important.

the t-statistic has j - k degrees of freedom. in microarray analyses with a small to moderate number of arrays, for which j - k is small, it is usually beneficial to replace sg2
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaacqwgzbwcdaqhaawcbagaem4zacgabagaegomaidaaaaa@3091@ with a variance estimator which is shrunk or moderated across genes to obtain moderated t-statistics  <cit> . genes can then be selected for differential expression based on large moderated t-statistics or small p-values.

a heteroscedastic model for probes and arrays
in this article we allow the unknown variance factors to depend on the array as well as on the gene,

var = σgj2
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaaiigacqwfdpwcdaqhaawcbagaem4zacmaemoaaogabagaegomaidaaaaa@3249@/wgj.     

we need a model for the variance factors σgj2
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaaiigacqwfdpwcdaqhaawcbagaem4zacmaemoaaogabagaegomaidaaaaa@3249@ which reflects the fact that the genes differ in variability and also that the arrays in the experiment may differ in quality in a way which increases or decreases the variability of all or most of the probes on a particular array. the simplest model which does this is the additive log-linear model

log σgj2
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaaiigacqwfdpwcdaqhaawcbagaem4zacmaemoaaogabagaegomaidaaaaa@3249@ = δg + γj     

 <cit> . we impose the constraint ∑j=1jγj=0
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaadaaewaqaaiabeo7annaabaaaleaacqwgqbgaaeqaaaqaaiabdqgaqjabg2da9iabigdaxaqaaiabdqeakbqdcqghris5aogaeyypa0jaegimaadaaa@3841@ so that the σg2
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaaiigacqwfdpwcdaqhaawcbagaem4zacgabagaegomaidaaaaa@30ec@ = exp δg represent the gene-wise variance factors while the γj represent the relative variability of each array. array j will have γj <  <dig> or γj >  <dig> depending on whether it is relatively better or poorer quality than the average. for instance, an array with exp γj =  <dig> is twice as variable as a typical array and will be given half weight in an analysis. note that the variances are assumed to depend multiplicatively on array quality. this is more appropriate than, say, an additive model of gene and array variances because it preserves relativities between the gene-wise precisions as array quality varies. the log-linear variance model also has substantial numerical and inferential advantages over other variance models in that positivity for the variances is ensured for any values of the δg and γj parameters.

the fact that all the genes contribute to the estimation of the γj means that, once estimated, the array weights can be taken to be fixed quantities when analysing each individual gene. the array weights vj = 1/exp γ^j
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaaiigacuwfzowzgaqcamaabaaaleaacqwgqbgaaeqaaaaa@2ff3@ can be incorporated into a differential expression analysis simply by combining them with the prior weights into modified weights wgj∗
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaacqwg3bwddaqhaawcbagaem4zacmaemoaaogabagaey4fiocaaaaa@31f3@ = wgjvj. the weighted least squares calculations described in the previous section  can then be conducted with wgj∗
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaacqwg3bwddaqhaawcbagaem4zacmaemoaaogabagaey4fiocaaaaa@31f3@ replacing wgj throughout. the use of appropriate array weights will produce more precise estimates of the gene expression coefficients and improve power to detect differentially expressed genes.

note that, although the scaling of the array weights is in principle arbitrary, our convention that ∑j=1jγj=0
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaadaaewaqaaiabeo7annaabaaaleaacqwgqbgaaeqaaaqaaiabdqgaqjabg2da9iabigdaxaqaaiabdqeakbqdcqghris5aogaeyypa0jaegimaadaaa@3841@ means we always choose the array weights vj to have geometric mean equal to one.

data
the use of array quality weights will be demonstrated on both real and simulated data sets. the first data set was acquired as a quality control step in the array fabrication process at the peter maccallum cancer centre, melbourne. this data set contains  <dig> microarrays representing 4– <dig> arrays taken from the beginning, middle and end of  <dig> different print batches. the arrays were printed with a human  <dig>  k cdna library and six copies of the lucidea microarray scorecard  set of control probes  <cit> . each array was hybridised with cy <dig> labelled mrna from the mcf <dig> breast cancer cell line and cy <dig> labelled mrna from the jurkat t-cell leukemia cell line. test and reference lms spike-in mixes were added to the mrna samples prior to labelling to produce predictable fold changes for the control spots . the ratio control spots should show three-fold or ten-fold changes while the dynamic range spots should not be differentially expressed. the array images were analysed using spot  <dig>   <cit>  and the intensities were background corrected by subtracting morphological  background values. the morph background treatment ensures that all intensities remain positive after background correction, and damps down the variability of the log-ratios for low intensity spots  <cit> . this eliminates the need for intensity-based filtering of spots in the subsequent analysis. we use this data for two purposes. firstly, log-ratios were print-tip loess normalised  <cit> . standardised residuals, /sg, were computed where ygj are the normalised log-ratios and y¯g
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaaiegacuwf5bqegaqeamaabaaaleaacqwfnbwzaeqaaaaa@2fc5@ and sg are the probe-wise means and standard deviations. standardised residuals from the 75% most highly expressed probes in the  <dig>  k cdna library were used as a population of non-normal deviates for generating simulated data sets. the other analysis of this data uses only the  <dig> lms control spots on each array. log-ratios from these control spots were global loess normalised  <cit> , using a relatively wide span of  <dig>  because of the relatively small number of spots used. the resulting data will be referred to as the qc lms data set in the remainder of the article.

the second data set arose from a study aimed at identifying novel methylated markers in myeloid malignancy using the leukemia cell line kg1a. microarrays were printed with the same cdna library and controls as the first data set. a known inhibitor of dna methylation, 5-azacytidine, was added to kg1a cells in varying doses . both direct and indirect comparisons between the  <dig> mm and  <dig> mm treatments and the  <dig> mm treatment were made on a total of  <dig> arrays . the panel reference rna consisted of a pool of rna from  <dig> cancer cell lines. the arrays were scanned on a genepix 4000b scanner and image analysed using genepix pro  <dig> . the intensities were background corrected using the model-based 'normexp' method with an offset of  <dig>  <cit> . again, this background correction method avoids negative intensities and the need for intensity-based filtering. log-ratios were print-tip loess normalised  <cit> . this data set will be referred to as the meth experiment.

simulations
for the simulation studies, normal and non-normal expression values  from replicate arrays were generated with g =  <dig> genes and j =  <dig> and  <dig> arrays in six different scenarios. for each simulation, different array variances  were assumed, and the gene-specific variances  were sampled from the estimates  obtained from the qc data set. non-normal deviates were sampled from the standardised residuals of the qc data set. these deviates are considerably more heavy-tailed than normal. in each data set, 5%  of genes were simulated to be differentially expressed at either 2-fold  or 3-fold , while the remaining 95% were simulated to have mean zero.

for the simulations with  <dig> arrays, the expression values for the third array were generated to be twice as variable as those from the first two arrays in simulation  <dig> , ten times as variable as the first two arrays in simulation  <dig>  or five times more variable on the second array and ten times more variable on the third array relative to the first in simulation  <dig> .

simulations with  <dig> arrays were generated to have at least two more variable arrays. in simulation  <dig>  expression values on the fourth and fifth arrays were simulated to be two times and four times more variable than those on the first three arrays . in simulation  <dig>  expression values from the fourth and fifth arrays were five and ten times more variable than those on the first three arrays . for simulation  <dig>  the expression values were two times, four times, six times and ten times more variable on arrays two to five respectively relative to the first array .

the six different scenarios and the true array weights in each case are listed in the first two columns of table  <dig>  recall that only the relative sizes of the array weights are relevant so, by the convention described earlier , we always scale the array weights so that they have geometric mean equal to one.

RESULTS
simulations
first we demonstrate the ability of the algorithms to return the correct array weights for simulated data sets where the true array variances are known. for each of the six simulation scenarios described in the previous section,  <dig> independent data sets were generated and the variance model  was fitted to each. this was carried out for both normal and non-normal data. for each data set, estimates were obtained using the full reml algorithm and the approximate gene-by-gene update algorithm . table  <dig> shows the means and standard deviations of the estimated array weights vj. the full algorithm is shown to assign weights almost exactly consistent with the predicted values. the gene-by-gene update method returns array weights which are slightly less extreme, i.e., slightly flattened towards equal weights, although still broadly accurate. the gene-by-gene estimates are also somewhat more variable than those for full reml, a consequence of the fact that the reml estimators are theoretically optimal. all the standard deviations are small enough however that the variability is negligible, even for the approximate algorithm. the results are virtually unchanged whether the data is normal or non-normal. although the accuracy of the full reml algorithm is impressive here, it is important to appreciate that very precise estimates of the array variances are not required for a weighted analysis to be effective, so that the gene-by-gene algorithm may be adequate in practice.

note also that the reml algorithms are invariant with respect to the gene-wise means or standard deviations, so the results given in table  <dig> remain the same regardless of how the gene specific means or standard deviations are generated.

next we turn to the detection of differential expression and false discovery rates. for each simulated data set, differentially expressed genes were selected using ordinary t-statistics and using the empirical bayes moderated t-statistics implemented in the limma software package  <cit> . these differential expression measures were used to compare three different array weighting schemes. we considered that an experimenter might choose  to use all the arrays equally in the analysis ,  to use the array weights estimated by the reml algorithm, or  to remove the worst one or two arrays from the analysis entirely . false discovery rates were calculated to compare the three weighting schemes. figure  <dig> shows the average number of false discoveries plotted against the number of genes selected using ordinary t-statistics  or moderated t-statistics  for the  <dig> array simulations listed in table  <dig>  each line represents the average of  <dig> simulations. panels ,  and  show the normal results for simulation  <dig>   <dig> and  <dig> respectively, while panels ,  and  give the corresponding results for non-normal data. the same layout is used in figure  <dig> for the  <dig> array simulations.

the black lines show the results obtained after removing the most variable array from simulations  <dig>   <dig> and  <dig> , or after removing the two most variable arrays in simulations  <dig>   <dig> and  <dig> . the light gray lines show the number of false positives obtained using equal weights and the dark gray lines indicate the false discovery rates when array weights from the full reml algorithm are used.

the first striking feature of figures  <dig> and  <dig> is that the moderated t-statistics easily outperform the ordinary t-statistics regardless of the simulation assumptions, consistent with findings in other studies  <cit> . the second feature is that the use of array weights always gives the lowest false discovery rate of the three weighting schemes, regardless of which t-statistic is used. array weighting outperforms both equal weighting and array filtering in all cases, although in simulation  <dig> equal weighting is nearly as good . it is interesting that the strategy most commonly proposed in the literature, that of array-filtering, is generally the worst performer across the scenarios, except in simulation  <dig> with moderated t-statistics, when equal weighting is worst. the use of array-filtering with ordinary t-statistics is very poor indeed. this is despite the fact that the simulation results make array-filtering appear somewhat better than it could be in practice. this is because we always removed the one or two arrays which were known to be the most variable, whereas in real data situations the true status of each array is uncertain and must be inferred using diagnostic plots or other methods. the results in figures  <dig> and  <dig> are for the full reml algorithm, however the results are virtually identical when the approximate gene-by-gene update algorithm is used instead  <cit> . this shows that the differences in estimated weights between the full and approximate reml algorithms observed in table  <dig> are relatively unimportant from the point of view of evaluating differential expression.

qc lms data
the qc lms data set provides an example of real data where we know the differential expression status of each spot. this example has the structure of a simple replicated experiment. the very large number of replicates allows us to assess accurately the effect of array weights. the variance model  was fitted to the log-ratios for the  <dig> lms control spots across the  <dig> arrays. the array weights, vj = 1/exp γ^j
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaaiigacuwfzowzgaqcamaabaaaleaacqwgqbgaaeqaaaaa@2ff3@, are shown in figure  <dig>  the weights vary from a minimum of  <dig>  for array  <dig> to a maximum of  <dig>  for array  <dig>  the least squares estimate of the log-fold change between the two rna sources for each gene is the weighted mean of the individual array log-ratios with these weights. inspection of ma-plots shows that arrays with lower estimated weights do indeed appear to return the theoretical fold changes more poorly than arrays with higher weights .

the differential expression status of the lms control spots are known, so we can use them to assess our ability to distinguish probes which are differentially expressed from those which are not. figure  <dig> plots t-statistics for testing differential expression for the  <dig> lms controls. ordinary t-statistics were calculated using either equal weights or using the array weights shown in figure  <dig>  the t-statistics for all classes of ratio controls  move further from zero when array weights are used while the distribution of t-statistics for the dynamic range controls does not noticeably change. this demonstrates that the array quality weights increase statistical power to detect true differential expression without increasing the false discovery rate.

meth data
in order to demonstrate our method on a smaller and more complex experiment, we now turn to the meth data. for this experiment, replication takes the form not only of duplicate arrays but also of redundancy between the direct and indirect comparisons available for each pair of treatments. the linear model requires three coefficients to represent differences between the three rna treatments and the common reference leaving seven residual degrees of freedom. of primary interest are the coefficients β1- <dig> and β3- <dig> which measure the gene expression differences 1mm-0mm and 3mm-0mm respectively. the design matrix was generated automatically using the limma software package. the linear model was fitted to all genes in the  <dig>  k library and control probes were excluded.

the experimenters who conducted the meth experiment were suspicious of the reliability of the first  <dig> arrays hybridised, which they believed were not giving consistent results with the last  <dig> arrays.

methods
need for new algorithms
we now turn to the problem of computing reml estimates for the array variance parameters in the probe-array variance model . algorithms for fitting heteroscedastic linear models are already available  <cit> , however the high dimensionality of microarray data limits the usability of conventional algorithms. there are g + j -  <dig> parameters in the variance model and a further gk parameters in the linear model itself. the fact that the array parameters in the variance model are shared by all the genes means that the usual strategy of fitting models separately for each gene is not available. even computers with many gigabytes of memory will run into memory limits using conventional algorithms with g much larger than around  <dig>  using a conventional algorithm for a typical microarray experiment with tens of thousands of genes is out of the question.

the basic difficulty from an algorithmic point of view is not the large number of expression values but rather the large number of parameters to be estimated. in the next section we develop a strategy for eliminating the gene-wise parameters βg and δg from the estimation problem.

nested iterations
conditional on the array variance factors γj, the gene-wise coefficients βg and variances δg can be computed in closed form using weighted least squares as described in the linear models section . the method of nested iterations is a strategy to reduce the dimension of an estimation problem by eliminating conditionally estimable parameters  <cit> . the idea is applied here to eliminate the gene-specific parameters from the reml likelihood function. this reduces the estimation problem to one involving just the j -  <dig> array weights.

explicit expressions for the reml log-likelihood for heteroscedastic models such as ours can be found in  <cit>  and  <cit> . write f for the contribution to the reml log-likelihood for gene g with γ = t. the reml likelihood already has the property that the linear model parameters βg are eliminated. the reml log-likelihood to be maximised is

ℓ = ∑g=1gf
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaadaaewbqaaiabdagamjabcicaogqabiab=lha5naabaaaleaacqwgnbwzaeqaaogaei4oasdccigae4htdq2aasbaasqaaiabdeganbqabagccqggsaaliiqacqqfzowzcqggpaqkasqaaiabdeganjabg2da9iabigdaxaqaaiabdeeahbqdcqghris5aaaa@4028@     

rather than deal with this large dimensional problem, we eliminate the δg by considering the profile reml likelihood for γ. write δ^g|γ
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaaiigacuwf0oazgaqcamaabaaaleaacqwgnbwzcqgg8bafcqwfzowzaeqaaaaa@330d@ for the value of δg which maximises f for given γ. the profile reml log-likelihood for γ is

ℓp = ∑g=1gf
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaadaaewbqaaiabdagamjabcicaogqabiab=lha5naabaaaleaacqwgnbwzaeqaaogaei4oasdccigaf4htdqmbakaadawgaawcbagaem4zacmaeiifawnae43sdcgabeaakiabcycasggabiab9n7anjabcmcapawcbagaem4zacmaeyypa0jaegymaedabagaem4raceaniabgghildaaaa@4359@     

we consider now the nested iteration for maximising the profile likelihood. write

ug,γ=∂f∂γ.     
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaacqwgvbqvdawgaawcbagaem4zacmaeiilawcccigae83sdcgabeaakiabg2da9maalaaabagae8naiyraemozaymaeiikagccbegae4xeak3aasbaasqaaiabdeganbqabagccqgg7awocqwf0oazdawgaawcbagaem4zacgabeaakiabcycasggabiab9n7anjabcmcapaqaaiab=jgi2kab9n7anbaacqgguaglcawljagaaczcamaabmaabagaegioagdacagloagaayzkaaaaaa@48e7@

also let

ag=     
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaacqwgbbqqdawgaawcbagaem4zacgabeaakiabg2da9maabmaabaqbaeqabigaaaqaaiabdgeabnaabaaaleaacqwgnbwzcqggsaaliigacqwf0oazcqwf0oazaeqaaagcbagaemyqae0aasbaasqaaiabdeganjabcycasiab=r7akjab=n7anbqabaaakeaacqwgbbqqdawgaawcbagaem4zacmaeiilawiae83sdcmae8htdqgabeaaaoqaaiabdgeabnaabaaaleaacqwgnbwzcqggsaalcqwfzowzcqwfzowzaeqaaaaaaogaayjkaiaawmcaaiaaxmaacawljawaaewaaeaacqai5aqoaiaawicacaglpaaaaaa@50a4@

be the reml information matrix for gene g. the derivative of f with respect to γ is simply ug,γ evaluated at δg = δ^g|γ
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaaiigacuwf0oazgaqcamaabaaaleaacqwgnbwzcqgg8bafcqwfzowzaeqaaaaa@330d@. the information matrix for γ from gene g, conditional on δg = δ^g|γ
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaaiigacuwf0oazgaqcamaabaaaleaacqwgnbwzcqgg8bafcqwfzowzaeqaaaaa@330d@ is

ag,γ⋅δ=ag,γγ−ag,γδag,δδ−1ag,δγ     
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaacqwgbbqqdawgaawcbagaem4zacmaeiilawcccigae83sdcmaeyyxictae8htdqgabeaakiabg2da9iabdgeabnaabaaaleaacqwgnbwzcqggsaalcqwfzowzcqwfzowzaeqaaogaeyoei0iaemyqae0aasbaasqaaiabdeganjabcycasiab=n7anjab=r7akbqabagccqwgbbqqdaqhaawcbagaem4zacmaeiilawiae8htdqmae8htdqgabagaeyoei0iaegymaedaaogaemyqae0aasbaasqaaiabdeganjabcycasiab=r7akjab=n7anbqabagccawljagaaczcamaabmaabagaegymaejaegimaadacagloagaayzkaaaaaa@5920@

evaluated at δg = δ^g|γ
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaaiigacuwf0oazgaqcamaabaaaleaacqwgnbwzcqgg8bafcqwfzowzaeqaaaaa@330d@ <cit> .

the derivative of the profile reml log-likelihood ℓp therefore is

uγ=∑g=1gug,γ     
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaacqwgvbqvdawgaawcbaaccigae83sdcgabeaakiabg2da9maaqahabagaemyvau1aasbaasqaaiabdeganjabcycasiab=n7anbqabaaabagaem4zacmaeyypa0jaegymaedabagaem4raceaniabgghildgccawljagaaczcamaabmaabagaegymaejaegymaedacagloagaayzkaaaaaa@4153@

and the information matrix associated with ℓp is

aγ⋅δ=∑g=1gag,γ⋅δ     
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaacqwgbbqqdawgaawcbaaccigae83sdcmaeyyxictae8htdqgabeaakiabg2da9maaqahabagaemyqae0aasbaasqaaiabdeganjabcycasiab=n7anjabgwsixlab=r7akbqabaaabagaem4zacmaeyypa0jaegymaedabagaem4raceaniabgghildgccawljagaaczcamaabmaabagaegymaejaegomaidacagloagaayzkaaaaaa@48d9@

evaluated at δg = δ^g|γ
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaaiigacuwf0oazgaqcamaabaaaleaacqwgnbwzcqgg8bafcqwfzowzaeqaaaaa@330d@. the reml estimate of γ can be evaluated by the nested scoring iteration

γ = γ + aγ⋅δ−1
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaacqwgbbqqdaqhaawcbaaccigae83sdcmaeyyxictae8htdqgabagaeyoei0iaegymaedaaaaa@3559@uγ     

where γ is the ith iterated value and aγ·δ and uγ are to be evaluated at γ = γ. the iteration will begin from a suitable starting value γ.

full scoring iterations
in this section, convenient expressions will be derived for the quantities aγ·δ and uγ. for any value of γ, the least squares estimator for βg can be computed using weighted least squares computations  with working weights wgj∗
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaacqwg3bwddaqhaawcbagaem4zacmaemoaaogabagaey4fiocaaaaa@31f3@ replacing the prior weights wgj. the standardised residuals from this regression are

egj=wgj*1/ <dig>      
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaacqwglbqzdawgaawcbagaem4zacmaemoaaogabeaakiabg2da9iabdeha3naadaaaleaacqwgnbwzcqwgqbgaaeaacqggqagkcqaixaqmcqggvawlcqaiyagmaagccqggoaakcqwg5bqedawgaawcbagaem4zacmaemoaaogabeaakiabgkhitgqaaiab=hha4naadaaaleaacqwgqbgaaeaacqwgubavaaaccmgccugfyogygaqcamaabaaaleaacqwgnbwzaeqaaogaeiykakiaeiilawiaaczcaiaaxmaadaqadaqaaiabigdaxiabisda0agaayjkaiaawmcaaaaa@4e14@

where xj is the jth row of x.

let

hg=Σg−1/2x−1xtΣg−1/2=     
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaacqwgibasdawgaawcbagaem4zacgabeaakiabg2da9iabfo6atnaadaaaleaacqwgnbwzaeaacqghsislcqaixaqmcqggvawlcqaiyagmaagccqwgybawcqggoaakcqwgybawdaahaawcbeqaaiabdsfaubaakiabfo6atnaadaaaleaacqwgnbwzaeaacqghsislcqaixaqmaagccqwgybawcqggpaqkdaahaawcbeqaaiabgkhitiabigdaxaaakiabdifaynaacaaaleqabagaemivaqfaaogaeu4odm1aa0baasqaaiabdeganbqaaiabgkhitiabigdaxiabc+caviabikdayaaakiabg2da9iabcicaoiabdigaonaabaaaleaacqwgnbwzcqggsaalcqwgqbgacqwgrbwaaeqaaogaeiykakiaaczcaiaaxmaadaqadaqaaiabigdaxiabiwda1agaayjkaiaawmcaaaaa@5c3e@

be the projection matrix from the regression and write hgj = hg,jj for the diagonal elements or leverages of hg. finally, let z be the j × j design matrix

z=     
 mathtype@mtef@5@5@+=feaafiart1ev1aqatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaacqwgabgwcqgh9aqpdaqadaqaauaabeaafuaaaaaabagaegymaedabagaegymaedabagaegimaadabagaes47iweabagaegimaadabagaegymaedabagaegimaadabagaegymaedabagaes47iweabagaegimaadabagaeso7i0eabagaeso7i0eabagaeso7i0eabagaesy8i8eabagaeso7i0eabagaegymaedabagaegimaadabagaegimaadabagaes47iweabagaegymaedabagaegymaedabagaeyoei0iaegymaedabagaeyoei0iaegymaedabagaes47iweabagaeyoei0iaegymaedaaagaayjkaiaawmcaaiaaxmaacawljawaaewaaeaacqaixaqmcqai2agnaiaawicacaglpaaaaaa@5878@

using these expressions we can write down computable expressions for quantities from the previous section. the conditional reml estimator of δg is δ^g|γ
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaaiigacuwf0oazgaqcamaabaaaleaacqwgnbwzcqgg8bafcqwfzowzaeqaaaaa@330d@ = logsg|γ2
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaacqwgzbwcdaqhaawcbagaem4zacmaeiifawhccigae83sdcgabagaegomaidaaaaa@33bf@ with

sg|γ2=1j−k∑j=1jegj <dig>      
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaacqwgzbwcdaqhaawcbagaem4zacmaeiifawhccigae83sdcgabagaegomaidaaogaeyypa0zaasaaaeaacqaixaqmaeaacqwgkbgscqghsislcqwglbwsaawaaabcaeaacqwglbqzdaqhaawcbagaem4zacmaemoaaogabagaegomaidaaaqaaiabdqgaqjabg2da9iabigdaxaqaaiabdqeakbqdcqghris5aogaeiola4iaaczcaiaaxmaadaqadaqaaiabigdaxiabieda3agaayjkaiaawmcaaaaa@4a6c@

the score vector for γ is

ug,γ=12z2tzg     
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaacqwgvbqvdawgaawcbagaem4zacmaeiilawcccigae83sdcgabeaakiabg2da9maalaaabagaegymaedabagaegomaidaaiabdqfaanaadaaaleaacqaiyagmaeaacqwgubavaaacbegccqgf6bgedawgaawcbagaem4zacgabeaakiaaxmaacawljawaaewaaeaacqaixaqmcqai4aaoaiaawicacaglpaaaaaa@4053@

where z <dig> is the last j -  <dig> columns of z and zg is the vector with components

zgj=egj2/sg|γ2−     
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaacqwg6bgedawgaawcbagaem4zacmaemoaaogabeaakiabg2da9iabdwgalnaadaaaleaacqwgnbwzcqwgqbgaaeaacqaiyagmaagccqggvawlcqwgzbwcdaqhaawcbagaem4zacmaeiifawhccigae83sdcgabagaegomaidaaogaeyoei0iaeiikagiaegymaejaeyoei0iaemiaag2aasbaasqaaiabdeganjabdqgaqbqabagccqggpaqkcawljagaaczcamaabmaabagaegymaejaegyoakdacagloagaayzkaaaaaa@4cc8@

for j =  <dig>  ..., j. the information matrix is

ag=12ztvgz     
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaacqwgbbqqdawgaawcbagaem4zacgabeaakiabg2da9maalaaabagaegymaedabagaegomaidaaiabdqfaanaacaaaleqabagaemivaqfaaogaemovay1aasbaasqaaiabdeganbqabagccqwgabgwcawljagaaczcamaabmaabagaegomaijaegimaadacagloagaayzkaaaaaa@3d8d@

where vg is the j × j matrix with diagonal elements  and off-diagonal elements hg,jk2
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaacqwgobaadaqhaawcbagaem4zacmaeiilawiaemoaaomaem4aasgabagaegomaidaaaaa@3417@. efficient algorithms exist to compute ag  <cit> . alternatively, it is often satisfactory to approximate the dense matrix vg with the diagonal approximation vg <dig> = diag  <cit> . with this approximation, a straightforward calculation gives

2ag,γ·δ = diag) + l - 1j−k
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaadawcaaqaaiabigdaxaqaaiabdqeakjabgkhitiabduealbaaaaa@30d5@ ) )t     

where hg = t and l is the j -  <dig> × j -  <dig> matrix of 1's. the nested information matrix aγ·δ therefore has diagonal elements given by

2aγ⋅δ,ll=∑g=1g{1−hgl+1−hgj−2/}     
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaacqaiyagmcqwgbbqqdawgaawcbaaccigae83sdcmaeyyxictae8htdqmaeiilawiaemibawmaemibawgabeaakiabg2da9maaqahabagaei4easnaegymaejaeyoei0iaemiaag2aasbaasqaaiabdeganjabdygasbqabagccqghrawkcqaixaqmcqghsislcqwgobaadawgaawcbagaem4zacmaemosaoeabeaakiabgkhitiabcicaoiabdigaonaabaaaleaacqwgnbwzcqwgkbgsaeqaaogaeyoei0iaemiaag2aasbaasqaaiabdeganjabdygasbqabagccqggpaqkdaahaawcbeqaaiabikdayaaakiabc+caviabcicaoiabdqeakjabgkhitiabduealjabcmcapiabc2ha9jaaxmaacawljawaaewaaeaacqaiyagmcqaiyagmaiaawicacaglpaaaasqaaiabdeganjabg2da9iabigdaxaqaaiabdeeahbqdcqghris5aaaa@671c@

and off-diagonal elements given by

2aγ⋅δ,lm=∑g=1g{−1j−k}     
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaacqaiyagmcqwgbbqqdawgaawcbaaccigae83sdcmaeyyxictae8htdqmaeiilawiaemibawmaemyba0gabeaakiabg2da9maaqahabagaei4easnaeiikagiaegymaejaeyoei0iaemiaag2aasbaasqaaiabdeganjabdqeakbqabagccqggpaqkcqghsisldawcaaqaaiabigdaxaqaaiabdqeakjabgkhitiabduealbaacqggoaakcqwgobaadawgaawcbagaem4zacmaemosaoeabeaakiabgkhitiabdigaonaabaaaleaacqwgnbwzcqwgsbabaeqaaogaeiykakiaeiikagiaemiaag2aasbaasqaaiabdeganjabdqeakbqabagccqghsislcqwgobaadawgaawcbagaem4zacmaemyba0gabeaakiabcmcapiabc2ha9jaaxmaacawljawaaewaaeaacqaiyagmcqaizawmaiaawicacaglpaaaasqaaiabdeganjabg2da9iabigdaxaqaaiabdeeahbqdcqghris5aaaa@69f6@

in matrix terms we can write

2aγ·δ = diag + ujl -ntn/     

where n is the matrix with ith row hgj- hg and uj = ∑g=1g
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaadaaewaqaaiabcicaoiabigdaxiabgkhitiabdigaonaabaaaleaacqwgnbwzcqwgqbgaaeqaaogaeiykakcaleaacqwgnbwzcqgh9aqpcqaixaqmaeaacqwghbwra0gaeyyeiuoaaaa@3ae4@. with these quantities, the nested scoring iteration  is very memory efficient and can be carried out easily on a standard personal computer.

gene-by-gene scoring iterations
although memory efficient, the nested scoring iteration may still require a lot of computation for large g since g gene-wise regressions must be evaluated for every iteration. if the prior spot weights are equal, wgj =  <dig>  the gene-wise regressions can be computed very quickly but, if not, a full set of least squares computations must be repeated for each gene and each iteration. in this section we explore a much lighter computation scheme in which only one pass is done through the genes and the array variance parameters are updated for each gene. this results in a very efficient gene-by-gene update algorithm which produces approximate reml estimators for the array weights.

the gene-by-gene update algorithm is given by

γ = γ + - <dig> ug,γ     

where ug,γ is as above  while a* is an accumulating information matrix defined by

ag,γ⋅δ*
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaacqwgbbqqdaqhaawcbagaem4zacmaeiilawcccigae83sdcmaeyyxictae8htdqgabagaeiokaocaaaaa@368f@ = ag− <dig> γ⋅δ*
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaacqwgbbqqdaqhaawcbagaem4zacmaeyoei0iaegymaejaeiilawcccigae83sdcmaeyyxictae8htdqgabagaeiokaocaaaaa@386c@ + ag,γ·δ     

where ag,γ·δ is evaluated at γ and δ^g|γ
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaaiigacuwf0oazgaqcamaabaaaleaacqwgnbwzcqgg8bafcqwfzowzaeqaaaaa@330d@. the iteration is started from γ <dig> =  <dig> and

a <dig> γ⋅δ*=10jz2tz <dig>      
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaacqwgbbqqdaqhaawcbagaegimaajaeiilawcccigae83sdcmaeyyxictae8htdqgabagaeiokaocaaogaeyypa0zaasaaaeaacqaixaqmcqaiwaamcqggoaakcqwgkbgscqghsislcqwglbwscqggpaqkaeaacqwgkbgsaagaemowao1aa0baasqaaiabikdayaqaaiabdsfaubaakiabdqfaanaabaaaleaacqaiyagmaeqaaogaeiola4iaaczcaiaaxmaadaqadaqaaiabikdayiabieda3agaayjkaiaawmcaaaaa@4ab7@

these starting values begin the iteration from equal array variances with the information weight of ten genes. the effect of accumulating the information matrix in this way is to gradually decrease the step size of the iteration as the iteration passes through all the genes, resulting in a convergent iteration. the final value γ is taken as the estimate of γ and is used to assign array weights. in our implementation in r  <cit> , this algorithm calculates the array variance parameters in less than a second for the qc lms data and in around  <dig> seconds for the meth data set on a  <dig>  ghz pentium m computer. the gene-by-gene nature of the algorithm means that minimal ram is required for these computations.

while the gene-by-gene update algorithm is fast, it provides only an approximation to the reml estimators γ, and we need to check the accuracy of this approximation. to do this, expression values  were simulated from normal distributions for j =  <dig> arrays and g =  <dig> genes. the array variance parameters  were equally spaced over the interval . as already noted, the reml algorithm is invariant with respect to the gene-wise means and variances, so the gene-specific mean and variance parameters were set to zero in our simulations.

discussion and 
CONCLUSIONS
this article has presented an empirical method for estimating quantitative array quality weights which is integrated into the linear model analysis of microarray data. computationally efficient algorithms are developed to compute the array quality weights using the well-recognized reml criterion. as well as full reml estimation, a fast gene-by-gene update method which requires only one pass through the genes is described.

examples of array quality weights which give less influence to the gene expression measurements from unreliable microarrays and relatively more influence to the measurements from reproducible arrays have been presented. in both simulated and real data examples, it has been demonstrated that array weights improve our ability to detect differential expression using standard statistical methods. the graduated approach to array quality has also been shown to be superior to filtering poor quality arrays both in simulations and for an experimental data set. in the simulations, filtering is shown to perform quite poorly, especially in combination with ordinary t-statistics. in the data example, filtering resulted in no significant genes to follow up, whereas the weighted analysis provided a few hundred sensible candidates.

the method is restricted for use on data from experiments which include replication with at least two residual degrees of freedom. for simple replicated experiments, a minimum of three arrays are needed and results from simulation studies show that this method is reliable in these situations, even in the presence of non-normally distributed data. simulations were also used to show that array variance parameters are estimated with greater accuracy when more genes are available for the gene-by-gene update algorithm, and that these computational savings do not seriously compromise the accuracy of the final estimates. as a rule of thumb, we recommend that the full reml array weights be used when there are fewer than  <dig> probes and that the gene-by-gene update method be used otherwise. the analysis of the control probes from the qc lms data set showed that useful array weights can be obtained from the gene-by-gene algorithm with as few as  <dig> genes. the situation is different when there are no spot weights or missing expression values in the data. in this case the full reml algorithm can be implemented very efficiently and so is recommended for any number of probes.

the empirical array weights form part of the quality and analysis pipeline and are not intended to replace the usual background correction, normalisation and quality assessment steps. in particular, array weights are not designed to account for spot-specific problems. the array weights method is instead designed to incorporate spot quality weights which might arise from gene filtering or from a predictive quality assessment step. the use of zero weights as prior weights  presents no problems for the method, although some special numerical treatment not discussed here is needed to ensure the sum to zero constraints are satisfied.

the array weight approach is also not intended to replace diagnostic array quality plots such as ma-plots, and arrays which are catastrophically poor quality should still be discarded. taking a graduated approach to array quality, does however allow arrays of less than ideal quality, which would otherwise have to be discarded, to be kept in the analysis, but down-weighted.

the authors have applied the array weight method to very high quality data sets which featured arrays with low background, well-behaved controls and a good dynamic range of spot intensities. for such data sets, the method assigns approximately equal array weights to each array . this indicates that the method does no harm when it is not required.

one further topic that deserves some attention is the use of robust linear models to estimate the gene expression coefficients. the array weights method has the same motivation as robust regression methods, but accumulates information on variability across genes on each array, which gene-wise robust regression methods are unable to do. another consideration is sample size. while robust methods perform well on large sample problems, many microarray data sets such as the meth experiment consist of a small number of arrays and, in these situations, robust methods may not be suitable.

authors' contributions
mer performed the data analyses, coded the algorithms and drafted the manuscript. gks suggested the model and algorithms, helped with the coding and analyses and finalised the manuscript. the arrays from the qc data set were manufactured and hybridised by dd, rvl and ah. the meth experiment was planned and conducted by jn and ad.

