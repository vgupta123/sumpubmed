BACKGROUND
computational protein sequence homology detection has become a central component in genome analysis. today sequences of unknown function are routinely searched against databases of known proteins and this has become an important aid for sequence annotation and to guide laboratory experiments. without the development of software tools for the detection of protein homology from amino acid sequence this would not have been possible. such homology detection tools aim to find similarities between related proteins and to score them above the noise level. different methods have varying degrees of success and it has been shown that profile-based methods, which consider information from a number of sequences, perform better than pairwise methods <cit> . in particular, profile hidden markov models  <cit>  have generated good results, and are today employed by several databases. pfam <cit>  and superfamily <cit>  for example, are large collections of protein families where each family is represented by a profile hmm. the profile hmm is a probabilistic model of a multiple sequence alignment of the family and is used to represent the family in database searches.

several aspects of profile hmm technology have been further developed since its initial conception. various schemes for sequence weighting have been proposed <cit>  and different null models have been studied <cit> . the introduction of dirichlet mixtures to model prior distributions <cit>  constituted a major step forward. the maximum likelihood technique employed to estimate such prior distributions has, however, been shown to be problematic for transition priors <cit> . discriminative training has been incorporated into model building and been shown to give improved performance <cit> . methods that incorporate phylogenetic information directly into the profile hmm and bypass the need for ad-hoc sequence weighting, have been developed and proved promising for homology detection  <cit> . secondary structure prediction has been combined with profile hmms into a probabilistic framework for more accurate fold recognition <cit> . finally, explicitly including knowledge about the taxonomic distribution of protein domains has proved to enhance protein domain discovery <cit> , as has the incorporation of knowledge about the likelihood of certain domain combinations <cit> . these examples of hmm improvements are only a few and by no means a complete listing.

two widely used profile hmm packages are sam <cit>  and hmmer <cit> . it is of interest for users to know the relative performance of the programs, and for profile hmm developers to know the key factors for good performance. madera and gough contributed the most recent and still most thorough comparison of the two programs <cit> . the authors divided their analysis into the two main steps of profile hmm homology detection: model building and database searching. model building involves converting a multiple alignment of the family into a probabilistic model, while database searching involves scoring a sequence to the profile hmm. the two steps are independent and by using a program to convert hmmer models into sam format and vice versa, madera and gough were able to separately evaluate the building and scoring performance of the two programs. sam model building was found to be clearly superior to hmmer model building, while no conclusion could be made concerning the scoring algorithms. e-value calculation, low complexity masking and time consumption were also investigated, but neither of the packages stood out as clearly better than the other.

profile hmms often model complete protein domains while real proteins may contain several domains. it therefore makes sense to look for a local match of the protein to the hmm. "global/local matching" forces the entire hmm to match a part of the sequence. this is often the desired mode if the hmm is built from one domain and the entire domain can be expected also in other proteins, perhaps in combination with other domains. in contrast, "local/local matching" means that a part of the hmm is matched locally to the sequence. the choice between the two modes depends on the application. local/local searches can find fragmentary protein sequences that would get poor scores if they were forced to match the entire model. however, in case the query sequences contain full domains, the sensitivity of the global/local mode should be better.

madera and gough compared the packages only for local/local mode. the first of the two objectives of this article is to extend their analysis to global/local searches. the second objective is to find the key features for profile hmm performance with a particular focus on model building. profile hmm estimation involves choices concerning for example sequence weighting, prior probabilities, and model architecture, and the two programs approach these issues differently. by comparing sam and hmmer run with non-default settings and with parameters borrowed from each other, we show which model parameters are crucial for profile hmm performance.

the article has the following structure. first we introduce the sam and hmmer packages and explain the role of the model building components that we will investigate. second we go through the test procedure, the data sets and the performance measure that we use. in the result section we compare the packages and analyse the influence of algorithmic components and parameters on the hmm performance in terms of sensitivity and specificity.

profile hmms – hmmer, sam and relevant parameters
the sam package comes from the university of california santa cruz. the package includes the sam-t2k iterative procedure to generate multiple alignments and hmms starting from a single sequence <cit> . another feature is "multi-track hmms", to process more than just the primary sequence data. secondary structure information can, for example, be incorporated in a probabilistically sound way for better modelling <cit> . this article will not evaluate these two additional features , but deals with traditional profile hmms built from multiple alignments. the sam package is used by the superfamily <cit>  database. hmmer is developed by sean eddy and is open-source, well documented and easy to use. hmmer and the protein family database pfam have co-evolved, but today hmmer is the engine also in other databases, including tigrfams <cit>  and smart <cit> .

in this study we used sam version  <dig>  and hmmer version  <dig> . <dig> 

hmm architecture and construction
a profile hmm is a probabilistic model of a multiple alignment of related proteins. the alignment is modeled using a series of nodes  each composed of three states: match, insert and delete. match and insert states emit amino acids with probabilities learned during model estimation while delete states are quiet. insertions and deletions with respect to the hmm are modeled by insert and delete states and transition probabilities to them. the original profile hmm architecture allowed transitions between all states, which gives  <dig> ×  <dig> =  <dig> possible transitions for each node. sam has kept this architecture, while hmmer since version  <dig>  allows seven transitions only. in the hmmer architecture transitions from insert to delete states, and vice versa, are forbidden.

both hmmer and sam allow the user to "label" columns in the multiple alignment to tell the program which columns should be seen as match/delete states and which should be seen as insert states. in case such information is missing, sam will assign every column to a match state and produce an hmm with one node per column. in hmmer an algorithm will assign columns to match or insert states so as to maximize the posterior probability of the aligned sequences, given the model. compared to sam, this normally results in shorter models since some of the columns are assigned to insert states.

prior probability alternatives
profile hmm parameters are estimated by combining the observed data  and a prior over probability distributions. if the multiple alignment were a good representation of the underlying protein family, there would be less need for using a prior. however, this is often not the case, primarily because the alignment includes too few sequences. the strength of priors is in compensating for small sample size and to distribute probability also to unseen events.

sam and hmmer both use dirichlet mixtures to model emission prior probabilities <cit> . a dirichlet mixture consists of a number of dirichlet components, which are distributions over probability parameters. each component typically captures a specific feature of columns observed in multiple sequence alignments, i.e. hydrophobicity or polarity, but also the degree of conservation to certain amino acids. during model building, the dirichlet components are weighted probabilistically for each column in the multiple alignment  and combined with the observed amino acid frequencies to obtain the posterior emission probabilities. the default emission prior in sam is currently a mixture of  <dig> components, while hmmer's default is a mixture of nine components. transition prior probabilities are modeled by single distributions in both sam and hmmer, but differ in two ways. first because sam employs nine parameters and hmmer only seven, i.e. one per transition. second because sam assigns a higher prior probability to deletions and insertions than hmmer.

sequence weighting: relative and total weights
the weight assigned to a sequence determines its influence on the final hmm. without sequence weighting, a high redundancy among the sequences would make the model skewed and it would not recognize under-represented sequences. the sequence weights are calculated in a two-step process: relative weights are first determined and then scaled to sum to the total weight , which is calculated separately.

the relative weights determine the influence of one sequence relative to the others. there are several algorithms for relative sequence weighting and common for all of them is to assign less weight to similar sequences and more to the divergent but still trusted family members. the hmmer default algorithm derives weights from a sequence tree relating the sequences <cit> , while sam uses an unpublished algorithm based on relative entropy . relative weights do not sum to any particular value, but are scaled to add up to the total weight. the total weight thus governs the weight of the multiple sequence alignment relative to the prior probabilities. hmmer and sam calculate the total weight in two very different ways. hmmer applies an algorithm that groups sequences by single-linkage clustering and counts the number of clusters above a specified level of identity. sam scales the weights according to an entropy target that specifies the number of bits per column to save during model building, i.e. the information content of the final model compared to a background model.

global or local scoring
a sequence can be scored locally to the entire profile hmm  or to a part of it . in hmmer, the search mode is specified in the hmm at the time of model building. two hmms can thus be built from the same alignment, one global/local and one local/local, and both are scored using the same algorithm. sam estimates only one hmm for each multiple alignment, and the search mode is instead specified at the time of model scoring.

a scop/pfam based benchmark
data sets
a large number of studies have used the scop <cit>  structural classification for evaluating the performance of sequence homology detection methods <cit> . scop is a database classifying all protein domains of known structure into a hierarchical order of four levels: class, fold, superfamily and family. two domains belong to the same family if they have a clear common evolutionary origin revealed either by a minimum of 30% sequence identity or very similar structure and function. two domains belong to the same superfamily but different families, if a common evolutionary origin is not obvious from sequence identity, but probable from an analysis of structure and functional features. the fold level is grouping all superfamilies and families that have a common pattern of secondary structure elements. finally, the class level divides domains into large classes based on secondary structure components.

in this work we evaluated the performance of profile hmms for homology detection at the superfamily level. we wanted to avoid conditioning the results on the use of a particular program to generate the multiple alignment. following coin et al <cit> , we therefore developed a test set that combines the high quality pfam alignments and the scop classification. pfam is a database of protein families based on sequence similarity rather than structural similarity. a manually curated sequence alignment is provided for each family, as is a profile hmm to search for homologs. we used the astral data set filtered to a maximum of 40% sequence identity for the scop sequence classification <cit> . astral is a database derived from scop and provides sequence files filtered to various levels.

to generate the test dataset, pfam families were linked to the superfamily level in the scop classification. we kept all pfam families that contain sequences that belong to one and only one scop superfamily. we also required that the scop domain definition for at least one of the sequences spanned the entire pfam domain. using pfam  <dig>  and the astral dataset this gave a test set of exactly  <dig> families. we imposed two extra conditions: that the pfam seed alignment had at least  <dig> sequences and that the average sequence length was above  <dig> amino acids. this gave  <dig> families from which we extracted every second family in alphabetical order to get a large enough but yet computationally feasible set of  <dig> families. all in all, the dataset contains  <dig>  <dig> positive and  <dig>  <dig>  <dig> negative test sequences.

test procedure
the test procedure was the following. we built profile hmms from the seed alignments of the  <dig> pfam families. we scored the entire astral dataset to the hmms and classified the matches from their scop classification. matches to the scop superfamily mapped to the query pfam family were classified as true hits. matches to a different scop fold were classified as false hits, while matches to the same scop fold as the query but a different superfamily were ignored. for each hmm, the searching generated a list of hits that we sorted on e-values. we went through this list from top to bottom and for each level of false positives we recorded the number of true positives. this gave a plot of true positives versus false positives, which is the standard way of displaying results from this type of tests.

RESULTS
default settings
sam and hmmer were compared for both local/local and global/local mode. we first ran the packages in local/local mode using all default settings, except that sam scoring was performed by the viterbi algorithm. figure 1a shows that sam performed considerably better than hmmer; building and scoring using sam detected more true positives than building and scoring using hmmer, and this was true across all error rates. however, the best results were obtained when sam models were converted to hmmer models and scored by hmmer. in contrast, hmmer models converted to sam models followed by sam scoring produced the worst results. it is thus fair to say that model estimation is considerably better done by sam, while scoring is better done by hmmer.

it is striking how much worse hmmer performed in local/local mode compared to global/local. in contrast, the sam results for local/local mode were very close to those for global/local mode. remember that the two packages have solved the issue of global or local scoring in different ways: while hmmer has two separate models and one way of scoring, sam has one model and two ways of scoring. could it be that the hmmer local/local model architecture, rather than the actual parameter estimation, is causing the poor local/local performance? if this were the case, sam models converted to hmmer format and configured for local/local scoring should be less accurate than sam models converted to hmmer format and configured for global/local scoring. this was not the case in our test . instead, the reason must be poorer model building in hmmer than in sam, affecting local/local models more than global/local models.

to conclude this section we note that although hmmer proved comparable to sam for global/local scoring, sam is the preferred package as it performed much better in local/local mode. sam produced better models, but lost some of the advantage due to an inferior scoring program. while hmmer model building was underperforming overall, local/local models proved particularly poor. in what follows we will seek explanations to these differences by analysing the effect of relevant model estimation parameters and algorithmic choices.

prior probability options
the default sam amino acid emission prior  has more than twice the number of free parameters compared to the default hmmer emission prior . we ran hmmer using recode <dig> comp on our test. this gave an increase in performance both for global/local and local/local models, showing that the emission prior is important in explaining why sam model building is more sensitive .

we also investigated the role of the transition prior. this is not as straightforward since the hmmer transition prior has only seven parameters and the sam prior has nine; the delete-insert and insert-delete transitions are non-existing in the hmmer architecture. nevertheless, we ran hmmer with the sam transition prior ignoring the two superfluous insert-delete parameters, and sam with the hmmer transition prior plus the insert-delete parameters from the sam prior. in local/local mode we could see almost no effect of using a foreign transition prior , but in global/local mode the performance deteriorated considerably .

the test of prior probabilities thus revealed that the sam emission prior is an important factor to explain sam model building superiority, while the default transition priors were program-specific for global/local mode. in all subsequent hmmer experiments, we used the sam emission prior in order to reduce the difference in parameter settings.

sequence weighting
sequence weighting involves  the relative weight assigned to each sequence and  the total weight given to all sequences as a group. while the relative weights determine the influence of one sequence relative to the others, the total weight gives the influence of the sequences vis-à-vis the prior probabilities. in addition, sam model building involves a filter that reduces the number of training sequences such that no two sequences have more than 80% sequence identity. excluding the filter had no important impact on sam results , hence the filter was removed in subsequent runs.

we analysed whether differences in sequence weighting could be a source for package-specific results. first we turned off both the relative weighting scheme and the total weight calculation in both packages. the effect of these changes is that each sequence gets a weight of  <dig> , such that all sequences will be equally important and the total weight will be the number of training sequences. these changes had a negative effect on both packages, but the effect was much worse for sam . two conclusions could be drawn: 1) sequence weighting does play a major role for performance, and 2) the sam weighting procedure is more important for performance than the hmmer weighting.

would sam weighting work better also for hmmer? to answer this question the hmmer code was modified to read sequence weights from file, with the option to rescale those weights according to hmmer's total weight calculation. we let sam generate weights and used them in hmmer model building. for local/local models this had a very large effect and sensitivity improved greatly when using sam weights instead of hmmer weights .

we next analysed what makes sam weights better: the relative weighting algorithm or the total weight calculation. in order to answer this we needed to isolate the effect of the two weighting components. we let hmmer read sam weights from file but rescaled them by the hmmer total weight; in this way hmmer was run using the sam relative weighting algorithm but the hmmer total weight calculation. performance dropped to a level comparable to all-hmmer weighting , which indicates that the sam total weight calculation is the crucial factor. to verify this we implemented our own version of the sam "bits saved" method for total weight calculation in the hmmer code . we used the sam default target value of  <dig>  bits saved relative to the background distribution. using hmmer relative weighting and the "bits saved" method produced as good results as using sam weights. the conclusion is that the sam "bits saved" method for calculating the total weight is much better than the hmmer method and a main source of the difference in performance, while the schemes for relative weight calculation are essentially equivalent.

the previous tests were all done for local/local scoring. for global/local scoring the picture was less clear. running hmmer with sam weights in global/local mode decreased performance  compared to using hmmer weights, i.e. a result opposite to what we saw for local/local mode. however, when we also added the sam transition prior, in addition to the sam emission prior used for all runs, the results were improved . remember that the sam transition prior earlier proved far from optimal for global/local hmmer usage . apparently the transition prior and the total weight cannot be specified independently in order to obtain sensitive global/local hmms.

in global/local mode, sam sequence weights thus gave more accurate hmmer models provided they were combined with the sam transition prior. we again split this effect into relative weighting and total weight calculation, and as for local/local scoring, the improvement was entirely due to the sam method for total weight calculation .

the total weight calculation emerges from this study as a very important component in profile hmm building. the higher the total weight, the larger will be the influence of the multiple alignment on the hmm, at the expense of the prior probabilities. is sam performing better because it assigns more weight or less weight to the multiple alignment, compared to hmmer? to answer this question, we investigated the output of the sam and hmmer methods for total weight calculation on our test set of  <dig> pfam families. sam produced an average total weight of  <dig>  and hmmer an average total weight of  <dig> . profile hmms by hmmer are thus relatively more determined by the multiple alignment, while sam gives a stronger influence to the prior probabilities. hmmer's weak performance in our test together with these numbers suggest that hmmer might overfit its models to the training data.

in conclusion, sam sequence weighting proved more accurate than hmmer weighting. the difference was entirely due to sam's method for total weight calculation, while the methods for relative weighting seemed to be of equivalent quality. the choice of transition prior had no influence on local/local searches. however, for global/local models, the transition prior employed and the method for calculating total weights could not be chosen independently. the best performance was obtained using sam total weight and the sam transition prior. however, if hmmer's transition prior was employed, the hmmer total weight calculation was more appropriate.

choosing match nodes
hmmer labels columns in the multiple alignment as "match" or "insert" nodes based on an automatic procedure where the overall probability of the sequences is maximised. sam has no such algorithm and treats every column as a match column, in case nothing else is specified in the alignment. we turned off the hmmer automatic algorithm and made it assign every column to match/delete states, as is sam default. this had a slightly negative effect on performance, suggesting that the hmmer automatic algorithm is sensible and gives some improvement .

model scoring
as seen in figure  <dig>  hmmer model scoring is more accurate than sam's. we believe that the principal reason for the difference lies in the used null model. both packages calculate log-odds scores, that tell how much better the sequence matches the family-trained model than the null model. the simplest null model is based on the average amino acid frequencies in protein coding sequences. by default, hmmer and sam use more advanced alternatives designed to compensate for the effect of biased sequence composition. this occurs when a sequence gets a relatively high score only because its overall amino acid composition is close to that of the modelled domain. hmmer compensates for biased composition by correcting the score using a second null model which is calculated as the average over all emission probabilities of the states in the target sequence's path through the model. sam on the other hand uses the score of the reversed sequence as null model score. unfortunately, the reversed sequence null model is compulsory for sam's e-value calculation, hence we were unable to investigate the effect of the null model. in any case we can only improve the free hmmer code, which already seems to have the superior method.

comparison to earlier work
madera and gough carried out a similar benchmark of hmmer and sam <cit> . the authors analyzed local/local mode only and concluded that sam was better at model building while the results for model scoring were not clear as different tests generated different results. our study agrees with theirs on model building, but not for model scoring where our results indicate that hmmer is more accurate. from where does this discrepancy stem? madera and gough ran the test the way a non-expert user would, i.e. with all default settings. this means forward scoring  for sam and viterbi scoring  for hmmer . on our test set and for both packages, forward scoring was more accurate than viterbi scoring, but is a slower algorithm. if the authors had compared similar scoring algorithms they would most likely have concluded that hmmer scoring performs better.

CONCLUSIONS
we have presented a comparison of the sam and hmmer packages. sam stands out as the better package for building hmms; particularly so for local/local searches. sam loses some of this advantage due to a slightly worse performing search algorithm, and for global/local mode the hmmer package was actually at par with sam. however, if default settings are applied, sam should be the preferred package.

we furthermore sought for the key factors in profile hmm estimation by analysing what makes sam build more sensitive hmms. sam's emission prior proved clearly superior to hmmer's. the relative sequence weighting schemes of the two packages, although different, proved to perform essentially equivalently. the main effect, however, was due to how prior probabilities and multiple alignment counts are combined. the total sequence weight, which determines the degree of faith in the observed data relative to the prior probabilities, seems to be much better handled by the sam package. it is generally correct to say that, compared to hmmer, sam puts more belief in the prior and less in the observed alignment. our results suggest that hmmer is overfitting models to the observed data while sam is better utilising the dirichlet mixture's capability to extrapolate observed amino acids to the underlying distribution.

by dissecting the importance of the different components in hmm building and scoring, we were able to combine the best features of hmmer and sam into a modified hmmer program that is superior to both programs. the code for this and the test used in the study is freely available from the authors via ftp . profile hmms are used by many databases that have a large influence on genome annotation. improvements to the profile hmm technology will therefore be of potentially large importance, which should render the results presented here valuable for many genome projects.

looking ahead, a recent development is profile hmm – profile hmm scoring <cit>  which has showed significantly higher sensitivity than ordinary profile hmm to sequence searches as well as profile – profile <cit>  searches. profile hmm – profile hmm searches can detect remote homology between two protein families. alternatively, a multiple alignment can be constructed automatically around a single query sequence; from this a profile hmm can be built and used in a search against for example the pfam database. the inclusion of homologs in the search improves sensitivity, and one can speculate that profile hmm – profile hmm searches gradually will out-compete profile hmm to sequence searches. profile hmm estimation, however, is a fundamental issue also for this novel technology and we expect there is room for improvements.

