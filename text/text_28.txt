BACKGROUND
gene expression in eukaryotes is controlled by combinatorial regulation of transcription factors and cis-regulatory elements. many types of transcription factors are bound to their respective regulatory dna elements, and the interactions between the factors and elements control the gene expression. molecular experiments can identify several binding sites for selected transcription factors, but they are too laborious and time-consuming to be applied to large-scale studies. computational methods are thus required for processing genomic data to reveal the combinatorial regulation on a genomic scale.

recently, some computational methods have been developed to detect combinations of patterns  of cis-regulatory elements. they process data of upstream sequences selected from genomic sequences, as well as data of either expression levels measured by dna microarrays or binding information given by chip-on-chip arrays  <cit> . one widely used type of computational method  <cit>  employs genes that are co-expressed at a certain threshold level. methods of this type first enumerate possible combinations of single motifs and then select significant combinations that specifically appear in upstream sequences of co-expressed genes  <cit> . alternatively, such methods search directly for a pattern of several closely spaced motifs in the upstream sequences  <cit> .

another type of computational method is based on regression analysis between expression levels and motif scores  in input sequences  <cit> . this type calculates a matching score of a motif  along each of the upstream sequences, for which the expression levels of the corresponding genes are measured by microarrays. it then takes regression between the motif scores in the upstream sequences and the expression levels of the corresponding genes to calculate the goodness-of-fit of the regression. this goodness-of-fit is obtained for each of the possible motifs , and then motifs with the best fit are selected. these procedures are interpretable under the simple assumption that the occurrence frequencies or the weight matrix scores, which approximately correlate with the binding energy of the transcription factors to dna elements  <cit> , in upstream sequences influence the levels of gene expression  <cit> , and that the scores of genuine motifs or motif combinations must explain much of the variation of expression levels. well-known regression methods used for this purpose are the  linear regression method  <cit>  and the multivariate adaptive regression spline  method  <cit> . the former method assumes a linear function between the motif scores and expression levels, and the latter method has hockey-stick functions as basis functions, though it does not explicitly assume a particular function because it is a non-parametric method. this type of computational method can take full advantage of the information about expression levels, since it does not compulsively dichotomize expression levels by a threshold into a binary code to indicate whether or not a gene is expressed.

an integrated web tool  to search for motif combinations has already been developed based on the widely used type of method above ; however, there is no integrated web tool that employs regression methods to systematically search for motif combinations. moreover, rgs-miner and the previous regression methods practically handle combinations composed of only two or three motifs; however, more than two or three motifs can be involved in combinatorial regulation in higher organisms  <cit> . hence, this case needs to be addressed.

we therefore developed motifcombinator, a web-based tool that uses regression methods to systematically search for combinations of regulatory motifs. this tool is equipped with two kinds of regression methods, the multivariate linear regression and mars methods, and it also includes logistic regression, which is a regression method for regulatory motifs that uses co-expressed genes  <cit> . it also employs the genetic algorithm to search for combinations composed of any desired number of motifs. for systematic combination search, motifcombinator includes a series of procedures such as determining single motifs that will constitute motif combinations, filtering out redundant single motifs that resemble each other, and calculating the goodness-of-fit for possible combinations. as with the integrated tool rgs-miner  <cit> , these systematic procedures are realized in interactive multistage pipelines with a simple screen layout that can be easily used by experimental biologists. motifcombinator will thus help users to find combinations of regulatory motifs that are important for combinatorial regulation.

implementation
multi-step pipelines
for the systematic search for motif combinations, motifcombinator uses a four-step pipeline structure. the four steps are 1) uploading a data set of upstream sequences and gene expressions; 2) determining single motifs that will be used to constitute possible motif-combinations; 3) cutting out redundant or irrelevant single motifs; and 4) searching possible combinations composed of the filtered motifs. we will introduce the framework here; supplemental details on how to use the tool are also provided online.

preparatory steps
in the first step, users upload a data set consisting of both upstream sequences and gene expressions. users can upload such a data set through files or by using a copy-and-paste function. data of upstream sequences should be formatted in the fasta format, and ids of the upstream sequences should be indicated following a greater-than  symbol in the format. the gene expression data should consist of two columns, a column of ids of gene expressions, and a column of expression levels or expression binaries. the expression levels are typically log ratios of expression levels for genes that are measured by microarrays, and will be subsequently processed by the linear regression or mars. the expression binaries are  <dig> or  <dig>  which indicate whether or not a gene is expressed, and will be subsequently processed by the logistic regression. after uploading both types of data, motifcombinator matches up ids in the sequence data with ids in the expression data to manage together the both types of data. users can also use pre-calculated non-homologous upstream sequences in the human and mouse genomes as sequence data.

the second step is to determine single motifs that will be used later to constitute candidate motif-combinations. motifs are represented by position frequency matrices. these single motifs can be determined through motif-finding tools, the jaspar database  <cit> , and users' stored motifs. three motif-finding tools based on different strategies are available to find de novo single motifs from input sequences: meme  <cit> , which mainly utilizes the em algorithm, annspec  <cit> , which mainly utilizes gibbs sampling, and mdscan  <cit> , which mainly utilizes the word enumeration strategy. users can adjust several parameters for these tools on the web screen. the transfac   <cit>  and jaspar  <cit>  databases are among well-established databases of transcription factor binding motifs, but currently, only freely-downloadable jaspar is pre-installed and its motifs can be uploaded with a simple mouse-click. users can also upload their own motifs. after the upload, users can confirm the matrices of uploaded motifs and can delete them if necessary.

the third step  is to cut out redundant or irrelevant single motifs. the single motifs used in combination searches sometimes include redundant – i.e., similar – motifs, which can result in combinations that are composed of many similar motifs. such similar motifs also make the computational time unnecessarily long. in addition, single motifs for combination search may include irrelevant motifs that do not contribute to the expression levels and are likely not to contribute to them even if they are combined in a motif combination. such irrelevant motifs also increase the computational time. hence, it is necessary to cut out redundant or irrelevant single motifs at this stage before listing the possible combinations of single motifs at the next stage. for the first purpose, users can classify groups of similar motifs by clustering analysis and select one motif per cluster to obtain distinct motifs. our tool uses the average kullback-leibler divergence calculated by matcompare  <cit>   as the distance between motifs to perform hierarchical clustering of the r language, and randomly selects one motif per cluster as a representative. for the second purpose, users can calculate how much variance in the input expression levels is explained by weight matrix scores of a single motif  in input sequences. for each single motif, the tool calculates the linear regression or the logistic regression between the motif scores in input sequences and input expression levels and then calculates the proportion of the variance of input expression levels explained by those expression levels that are predicted by the regression . a single motif that hardly contributes to the explanation of input expression levels may not contribute to the expression levels even if it is used to constitute a motif combination. users can remove such a single motif.

combination search
at the fourth step , users can search for motif combinations that are important for expression levels. motifcombinator generates candidate motif combinations from motifs that are selected through the previous steps, or motifs that are selected at this step by users with checkboxes on the screen. for each of the motif combinations, the tool calculates the weight matrix scores  of the combination in input sequences, and performs the regression between the scores and input expression levels to calculate the goodness-of-fit of the regression. it then selects motif combinations with the best fit. these procedures are iteratively performed through the genetic algorithm.

the genetic algorithm  consists of a coding system to express motif combinations and four procedures to handle the coded motif combinations. in the coding system, a motif combination, which in the language of the genetic algorithm is referred to as an individual, is coded in a series of names of uploaded motifs or the name null to indicate the absence of a motif. for example, the code |m1|m2|null|, where ms denote motif names and null denotes not having a motif, represents a motif combination composed of motif m <dig> and m <dig>  a more complex code is allowable. for example, the code |m <dig> m2|null m3|m <dig> m5| represents a motif combination that has a module composed of motif m <dig> and m <dig>  a module composed of motif m <dig>  and a module composed of motif m <dig> and m <dig>  a module is a unit used in the scoring of a motif combination as described below. a user has to specify both the number of modules and the number of motifs that constitute modules on the web screen. a user can input values of greater than two; thus a user can search for combinations composed of more than two or three motifs, or rather, any number of motifs.

the first procedure in the genetic algorithm is initialization. initial individuals  are randomly generated in the number that a user specifies. more specifically, motifs to constitute a motif combination are uniformly selected from all uploaded motifs at the probability of  <dig>   and are selected from the null motif  at the probability of  <dig> .

the second procedure is selection. for each of the motif combinations coded as described above, the matching scores of the motif combination are calculated from input sequences as follows:

si,j=log⁡2{∑m∑wpr⁡pr⁡},     
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaacqwgtbwudawgaawcbagaemyaakmaeiilawiaemoaaogabeaakiabg2da9igbcygasjabc+gavjabcegannaabaaaleaacqaiyagmaeqaaowaaiwaaeaadaaeqbqaamaaqafabawaasaaaeaacyggqbaucqggybgccqggoaakcqwg3bwdcqqggaaicqqgmbgzcqqgybgccqqgvbwbcqqgtbqbcqqggaaicqwgnbqtdawgaawcbagaemyba0gabeaakiabcmcapaqaaigbccfaqjabckhayjabcicaoiabdeha3jabbccagiabbagamjabbkhayjabb+gavjabb2gatjabbccagiabd2eannaabaaaleaacqqgwaamaeqaaogaeiykakcaaawcbagaem4dachabeqdcqghris5aawcbagaemyba0gabeqdcqghris5aagccagl7bgaayzfaagaeiilawiaaczcaiaaxmaadaqadaqaaiabbwgaljabbghaxjabb6cauiabbccagiabigdaxagaayjkaiaawmcaaaaa@68ff@

where i and j denote the module and the sequence, m denotes any of the motifs belonging to the module i, mm is the probability matrix of the motif m, m <dig> is the third-order markov model estimated from all input sequences, and w denotes a string of any of the sliding windows in the sequence j. when a user specifies the option of the number of motifs that constitute modules as one , this scoring is exactly the same as that used in the multivariate linear regression method  <cit> . then, for the motif combination, the scores and input expression levels are regressed, and the goodness-of-fit of the regression is calculated. a user can select one of three regression methods: the multivariate linear regression  <cit> , the multivariate adaptive regression spline   <cit> , or the multivariate logistic regression method  <cit> . the goodness-of-fit is akaike's information criterion  for the linear/logistic regression, or the generalized cross-validation score  for mars. by the goodness-of-fit, each motif combination  is evaluated and only motif combinations with the best fit are selected in the number that a user specifies.

the third and fourth procedures are crossover and mutation. in the crossover, two different individuals are randomly chosen from the selected individuals with the best fit, and one-point crossover is performed between the codes of the two individuals to reproduce codes of two new individuals at the next generation . this operation is repeated until the number of new individuals at the next generation reaches that of the old individuals at the previous generation. at the fourth procedure, mutation is performed on codes of the new individuals. here, mutation is random replacement of one motif with another at a site on the code of an individual . first, sites of motifs to be replaced are randomly selected across all individuals in the number of  l*m, where l is the number of motifs in all individuals and m is the mutation rate specified by a user. then old motifs at the selected sites are replaced with new motifs that are randomly selected as in the initialization step. by this procedure, one iteration loop is closed. the next iteration loop starts with the second procedure, selection, which in turn evaluates the new codes of motif combinations that are updated through crossover and mutation at the previous iteration. these iterations repeat for the number of times specified by the user.

on the web screen, users can obtain results about motif combinations with the best fit. the motif combinations listed there are the best ones throughout all iterations. by clicking the formula button, users can see an estimated regression formula, together with the constituent motifs, regression coefficients, evaluation score , and contribution rate . by clicking the umotif button, users can see motifs that constitute a motif combination. by referring to the two figures on the screen, users can intuitively grasp how the combination search has proceeded and thereby can get hints to evaluate the results. one figure on the screen shows the history of the best goodness-of-fit values during the combination search, i.e., the best goodness-of-fit value at the selection step versus each of the iterations during the search. if users observe, for example, that the values are steadily falling, in other words, getting better according to the iterations, this suggests that users should not stop the calculation but continue. the other figure on the screen shows a brief landscape of the goodness-of-fit values during the search, i.e., the values of all individuals in all iterations versus a metric whose different values are intended to represent different motif combinations. the metric is the sum of the distances of constituent motifs from the reference motif, of which the length is  <dig> and the probability matrix is composed of  <dig>  for each nucleotide base. the distance is measured by the average kullback-leibler divergence between a constituent motif and the reference motif, and is calculated by matcompare  <cit>  . if users observe, for example, that a point of the goodness-of-fit value is alone positioned extremely low in the y-axis  and isolated far from all other points that are scattered thoroughly across the x-axis, this may suggest that the value is worthwhile and the motif combination with this value may be close to the optimal solution.

finally, our tool has a backup system for re-calculation later, since the combination search takes a long time when the sizes of the parameters are large. users can dump an archive file needed for re-calculation by simply clicking the backup button. then, they can shut down the computer. users can easily restart the calculation by uploading the archive file on the web screen.

in summary, the characteristic points at the combination search are as follows.

• users can search for combinations composed of any number of motifs, using the genetic algorithm.

• users can use the three types of regression methods  to find motif combinations that well explain the variations of expression levels.

• users can intuitively understand how the search has proceeded by the two visualization systems, which show a history and a brief landscape of the goodness-of-fit scores during the search.

• users can easily store all records by the backup system, and even after shutting down the computer, they can easily restart the search by just uploading the backup file on the web screen.

RESULTS
tests by simulated data
using simulated data sets, we tested whether the tool can correctly recover motif combinations composed of given motifs from many irrelevant motifs. the simulated data sets consisted of simulated upstream sequences and simulated expression levels. we generated the simulated upstream sequences in  <dig> bps by the third-order markov model estimated from the human genome. into the upstream sequences, we randomly planted modules with motifs neighboring within  <dig> bps of each other, following the poisson distribution  for the number of modules in each upstream sequence, and following the probability matrices of motifs to plant strings of the motifs into each upstream sequence. we generated ten different sets of such simulated upstream sequences, into which we respectively planted ten different modules.

we generated two types of simulated expression levels. one was generated by the linear combination of the scores of modules as follows:

∑iaixig+c+kεg,     
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaadaaeqbqaaiabdggahnaabaaaleaacqwgpbqaaeqaaogaemieag3aasbaasqaaiabdmgapjabdeganbqabagccqghrawkcqwgdbwqcqghrawkcqwgrbwaiigacqwf1oqzdawgaawcbagaem4zacgabeaaaeaacqwgpbqaaeqaniabgghildgccqggsaalcawljagaaczcamaabmaabagaeeyzaumaeeycaenaeeola4iaeeiiaaiaegomaidacagloagaayzkaaaaaa@47cc@

where i and g are the indices of a module and a gene, respectively, x is the score  of a module, c and k are constants, and ε is a n  gaussian noise. c was adjusted for the mean of expression levels across genes to be zero, and k was adjusted for the standard deviation of noises to be a certain percent of the standard deviation of expression levels across genes. we used this type of simulated expression level for the test of the linear regression method. the other simulated expression levels were generated by the two-order interaction terms between different modules in addition to the linear combination  <cit>  as follows:

∑iaixig+∑i<jbijxigxjg+c+kεg.     
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaadaaeqbqaaiabdggahnaabaaaleaacqwgpbqaaeqaaogaemieag3aasbaasqaaiabdmgapjabdeganbqabagccqghrawkdaaeqbqaaiabdkgainaabaaaleaacqwgpbqacqwgqbgaaeqaaogaemieag3aasbaasqaaiabdmgapjabdeganbqabagccqwg4baedawgaawcbagaemoaaomaem4zacgabeaaaeaacqwgpbqacqgh8aapcqwgqbgaaeqaniabgghildgccqghrawkcqwgdbwqcqghrawkcqwgrbwaiigacqwf1oqzdawgaawcbagaem4zacgabeaaaeaacqwgpbqaaeqaniabgghildgccqgguaglcawljagaaczcamaabmaabagaeeyzaumaeeycaenaeeola4iaeeiiaaiaeg4mamdacagloagaayzkaaaaaa@5b87@

we used this type of simulated expression level for the test of mars. we added the gaussian noises at 0%, 20%, 40%, 60%, and 80% of the standard deviation of expression levels across genes.

for these data sets , we tested whether motifcombinator can correctly recover motif combinations of planted modules from all jaspar  <cit>  motifs . for all jaspar motifs, we first performed the step of motif cutting based on the clustering analysis at a cut height of  <dig>  then at the step of combination search, we set the options as follows: number of individuals =  <dig>  top individuals in selection =  <dig>  mutation = 10%, and iterations =  <dig>  we set module × motif according to the modules used  and set the regression type to be the linear regression and mars for the two types of expression levels in eq.  <dig> and eq.  <dig>  respectively. using these settings, we executed the search and obtained the results. for each data set, we took up the top ten motif combinations  that were evaluated and recovered by the tool. we calculated how well the tool recovered a motif combination, based on the hypergeometric test:

p={×}/,
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaacqwgwbaccqggoaakcqwg0badcqggpaqkcqgh9aqpdawcgaqaamaacmaabawaaewaaeaafaqabegabaaabagaemivaqfabagaemidaqhaaagaayjkaiaawmcaaiabgena0oaabmaabaqbaeqabiqaaaqaaiabduealjabgkhitiabdsfaubqaaiabdugarjabgkhitiabdsha0baaaiaawicacaglpaaaaiaawuhacagl9baaaeaadaqadaqaauaabeqaceaaaeaacqwglbwsaeaacqwgrbwaaaaacagloagaayzkaaaaaiabcycasaaa@4858@

p=1−∑i=0t−1p,
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaacqwgqbaucqgh9aqpcqaixaqmcqghsisldaaewbqaaiabdchawjabcicaoiabdmgapjabcmcapawcbagaemyaakmaeyypa0jaegimaadabagaemidaqnaeyoei0iaegymaedaniabgghildgccqggsaalaaa@3ef7@

where k is the number of all motifs, k is the number of motifs  that constitute a motif combination we planted, t is the number of all motifs in a motif combination recovered by the tool, and t is the number of true motifs included in the motif combination recovered by the tool. we calculated the p value for each of the top ten motif combinations in each data set, and kept two types of p values: the best p value among the top ten and the  averaged p value across the top ten in each data set. then we averaged both p values across all data sets. table  <dig> shows that, in the case of the averaged p values across the top ten , the values were always under  <dig>   in all noise and regression types, though the values got worse according to the increase of noise. the best p values  were always under roughly 10- <dig> . the tool significantly recovered motif combinations that were exactly or approximately the same as those we planted.

we tested if the tool can correctly recover planted motif combinations, using simulated data sets. we evaluated the results based on p values of the hypergeometric test . "linear" and "quadratic" indicate types of simulated expression levels given by eq.  <dig> and eq.  <dig>  respectively, and "noise" indicates the degree of noises added into the simulated expression levels. "average" and "best" correspond to the cases of the p value  averaged across the top  <dig> motif combinations and the best p value among the top  <dig>  respectively . "log10" indicates log <dig> of the p values. "c.r." indicates the contribution rate, which is the proportion of the variance of input expression levels explained by the scores of a motif combination. "log10" and "c.r." values in each row are averaged across ten data sets.

tests by muscle-specific transcripts
we tested the tool using real data sets, which consisted of upstream sequences and expression levels of muscle-specific transcripts. we obtained skeletal muscle-specific transcripts and their expression levels from a data file  included in a study of an extensive microarray survey of gene expression in normal human tissues  <cit> . that study measured the expression levels in two tissues related to skeletal muscle: abdominal muscle and right calf muscle. for the upstream sequences, we used genome sequences in the human ncbi build  <dig> and obtained sequences 2000-bps upstream  from the muscle-specific transcripts. a set of  <dig> muscle-specific transcripts was uploaded into the tool. we also prepared position weight matrices of motifs  known to be involved in muscle-specific expression  <cit>  using the jaspar database  <cit> , and uploaded them.

we tested whether the tool could correctly select motif combinations composed of these motifs from among all jaspar motifs . we first performed the step of motif cutting based on the clustering analysis at a cut height of  <dig> . then, in the step of combination search, we set the options as follows: number of individuals =  <dig>  top individuals in selection =  <dig>  mutation = 10%, and iterations =  <dig>  we set module × motif to  <dig> ×  <dig> and regression type to mars. among a dozen of the top motif combinations that were evaluated and selected by the tool, three  were found out of the five muscle-related motifs in the abdominal-muscle data set and three  were found in the right calf-muscle data set. for each motif combination, we evaluated the results by the hypergeometric test described above. table  <dig> shows that, in the abdominal-muscle data set, the best p value was under  <dig>  and the combinations with the best p value included mef <dig> and srf, and myf and srf. in the right calf-muscle data set, the best p value was roughly 10- <dig>  and the combination with the best p value included mef <dig>  sp <dig>  and srf.

we used upstream sequences and expression levels of muscle-specific transcripts  <cit>  to see if the tool can select a motif combination composed of motifs  involved in muscle-specific expression from all jaspar  <cit>  motifs. we employed mars as the regression method. we evaluated the results based on p values of the hypergeometric test . "examined tissue" indicates tissues that the study  <cit>  examined as tissues of skeletal muscle. we list here results on a motif combination with the best p value among a dozen of the top motif combinations selected by the tool. "log10" indicates log <dig> of the p values. "c.r." indicates the contribution rate, which is the proportion of the variance of input expression levels explained by the scores of a motif combination. "selected muscle motifs" indicates muscle-related motifs that were included in the motif combination selected by the tool.

CONCLUSIONS
sequencing of genomic dna deepens our understanding of dna codes of protein products on genomic sequences in organisms; however, the codes that control gene expression or protein products are not well understood because of their complexity. such complexity arises partly from the combinatorial regulation of cis-regulatory elements – many short dna segments are combined to confer the ability to express genes specifically to tissues or environments. to understand the combinatorial regulation, it is necessary to develop a computational tool that efficiently searches possible combinations of patterns  of cis-regulatory elements to find combinations important for gene expression measured by, for example, microarrays.

we developed motifcombinator, a web-based tool that searches for combinations composed of any desired number of motifs using the genetic algorithm and that employs well-known regression methods to find motif combinations that well explain the variations of expression levels directly – without dichotomizing expression levels into the "expressed" or "non-expressed" categories. this tool also has two visualization systems for intuitive evaluation of the search and has a backup system for continuing a long calculation. convenient preparatory steps  are also implemented for systematic search of the combinations. using simulated data sets and muscle-specific transcripts, we tested the tool and found that the tool indeed recovered appropriate combinations of motifs for these data. recently, information on known motif combinations has been increasing, as in transcompel  <cit> , which is a database of two  closely-located binding sites on dna sequences. this information can in principle be integrated into a system that handles combinations of any number of position frequency matrices, such as our tool, and the integration would increase the accuracy and convenience of the system. in conclusion, motifcombinator will help users to efficiently search for motif combinations that are important for gene expression measured in genome-wide experiments.

availability and requirements
project name: motifcombinator

project home page: 

operating system: platform independent 

any restrictions to use by non-academics: none

abbreviations
- mars: the multivariate adaptive regression spline

- aic: akaike's information criterion

- gcv: the generalized cross-validation score

- eq.: equation

authors' contributions
mk planned the research, performed the analyses, and wrote the manuscript. tt reviewed the manuscript. all authors read and approved the final manuscript.

