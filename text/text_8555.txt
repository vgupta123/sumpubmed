BACKGROUND
tandem mass spectrometry  analyses of heterogeneous protein samples typically provide large amounts of data. current methods allow the identification of hundreds or even thousands of proteins from a given complex sample. but the acquisition of such comprehensive ms data may require long machine running times, sometimes measured in weeks, depending on the type of analysis and number of replicates performed. the thorough analysis of the complex data produced can be achieved using multiple tandem ms search engines and other specialist tools. however, the handling of proteomics data is not a trivial task. in addition, processing can be very demanding in terms of computer resource and laboratories without a specialized computer infrastructure are limited in their analytical capacity. in order to address these issues, we have developed an automated proteomics pipeline designated as app that integrates a set of tools and allows distributed execution on most available computers with minimal setup. app also addresses usability issues and minimizes the computer skills needed to perform complex analyses. it is readily usable in any laboratory environment, both locally and with regards to cloud computing.

implementation
the core components and plugins of app were written in java version  <dig> using the sun netbeans ide environment . java was selected to aid deployment over heterogeneous computer environments, thereby allowing windows, os x and linux machines to provide their own unique tools. app is used through two applications, i.e. a server/worker application and a user interface application . the app project homepage provides prepackaged bundles of all tools and a tutorial manual with step-by-step instructions for server setup, installation of all components and use of app for the analysis of ms data. the bundles are regularly updated to coincide with tpp releases. a processing node functioning on either a linux or windows system becomes available after unpacking the single zip/tar.gz file corresponding to the packaged bundles. any adapted settings of app can be mirrored by simply copying the corresponding folder into a new system. app grids are built to function with minimal privilege. only the server needs to be accessible to the clients or nodes, thereby placing no requirement for administrative privilege on the other systems. app does not aim to supplement systems management tools for large deployments. if resources such as high-performance shared storage are available, app can utilize them but this is not a requirement. app can utilize binaries from any location, including network shares, thereby allowing access of shared folders to all app nodes, or folder syncing. app allows file download from the server to local drives for further work on the files. file security on the nodes falls outside the reach of app and the software does not add any demand of accessibility to nodes.figure  <dig> 
job handling on app. overview of the general app server and worker setup with jobs being distributed and executed on workers.



plugin model
proteomics and other tools are provided by app as plugins. each plugin has its own first in/first out  type of queue. individual plugins use a set of files as input and process them before specifying which output files should be passed on to the next plugin. thus, complex tasks can be defined easily by linking sets of plugins. most of the plugins depend on open source tools, allowing the backend tools to be distributed along with the app server software.

server software
the server software handles the central parts of app, job submission, execution scheduling, timing out non-responsive tasks and tracking of results. it can also be run in worker mode, allowing it to connect to an already running server, and be served single jobs to execute, acting as a simple grid node . this offloads computing tasks from the main server and allows parallel processing of jobs without requiring the complex task of setting up a standard grid or rewriting any software for distributed computing. workers can be added and removed during runtime, allowing use of computers as they become available. for example, office computers can be used to process long running tasks overnight and then be reclaimed by their owners without affecting the overall processing. virtualized servers can also be added easily to cope with increased demand. this allows easy use of local computers or computing resources from a cloud computing service such as amazon web services or microsoft azure. since the app core is written in java, the server software is inherently cross-platform. most plugin codes are automated to find and use either linux or windows binaries, thereby enabling easy mixing of gnu/linux and windows systems. plugins for use with the trans-proteomic pipeline  are included with all installations of app along with a set of freely redistributable database search engines and their plugins. each worker client can be configured independently. possible setups include a central server with a set of desktop computers connected for executing tasks at low priority, allowing computer power not needed for desktop tasks to be used by app. in other setups, specific search engines are executed only on computers with enough computing power while slower computers handle less computationally intensive tasks. app can accept data in different formats at any stage of the analysis, including raw ms data from vendors such as waters, agilent or thermo scientific, as well as mgf, pkl and dta files. app automatically manages file formats containing fixed paths. all app jobs are executed using a temporary path structure to ensure non-destructive processing and the jobs are updated to their primary paths upon successful completion. thus, execution can indifferently take place locally or remotely. files generated on the server can be referenced directly when submitting new jobs, avoiding needless transfer and replication of data. nodes have tasks submitted and then request needed files. two methods are deployed to avoid bottlenecks. by default, each node accepts 110% worth of its free core in jobs. this allows file transfers to be performed while the node is processing important jobs. additionally, file checksums are stored when received and sent. thus, files that are repeatedly used, such as databases, are only transferred once to the node. the file cache is cleared after no job has utilized a file for a preset time, with the smallest files being cleared first. finally, app can be pointed to folders containing commonly used files, which will then be passed by reference rather than transferred. this is useful for storage of databases on all nodes or mapping of shared storage solutions. very large files such as .raw files can cause bottlenecks for initial transfer to processing nodes, but this is normally not rate limiting because processed raw data are transferred faster than they are processed.

the most salient advantage of app is the integration of multiple plugins for a whole range of tools . this is illustrated by the combination of currently available plugins, i.e. msconvert  for raw data format conversion, and database search engines such as x!tandem  <cit> , myrimatch  <cit> , omssa  <cit> , comet  <cit> , inspect  <cit> , spectrast  <cit>  and ms-gf+  <cit> . the current pipeline also integrates several plugins for validation of the search results, namely peptideprophet  <cit> , including support for libra, xpress and asapratio for itraq or silac quantitation  <cit> , iprophet  <cit>  and proteinprophet  <cit> . in addition, a separate general search settings plugin reads post-translational modifications in unimod format  <cit>  and generates a universal parameter format that can be used for all search engine plugins. a label-free quantitation plugin is also available, which can utilize spectral counting or ms <dig> tic values  <cit>  as a basis of protein quantitation. additional plugins provide smaller services such as standardizing the names of spectra, allowing extraction of specific peptide information and images of spectra, or converting additional formats such as biolynx xml files into appropriate formats for use in app workflows. app is packaged together with most of the tools it supports, such as the tpp base installation and all database search engines supported. in cases where underlying software cannot be legally redistributed, plugins can be downloaded individually from the project homepage. the server software typically runs with a user interface to allow easy configuration, but it can also be run completely from a command-line interface for use on server operating systems. it is also possible to configure a server using the gui and then run it headless.figure  <dig> 
sample task. all workflows on app clusters are provided as a set of linked plugins. the figure shows how the major plugins are linked in the example task. housekeeping plugins such as spectrumnamefixer and idconvert are excluded for legibility.



interface software
the interface application is designed to be as intuitive as possible, automatically detecting any app servers running on a local network and facilitating the setup and submission of complex pipelines by simply linking one plugin to another. the interface also allows users to browse previous tasks and results from the server, easily retrieving any file for local storage. when setting up a task app pre-calculates the result of each operation, allowing browsing of exactly which output files will be created and forwarded in the task. when attempting to submit a task for processing, a series of checks are run to ensure that each plugin will be provided with proper inputs, for example ensuring that a database search engine is receiving a search-settings file, at least one data file and a target database. any plugin that fails a test is highlighted to the user and its requirements are presented.

RESULTS
app and similar software
several commercial platforms for the analysis of ms-based proteomics data, such as sorcerer , scaffold  and peaks  are available, but their access is typically expensive. other pipelines that incorporate solutions for analyzing and validating results from several ms/ms search engines are freely available, e.g. openms/topp  <cit> , tpp  <cit> , cpas  and maspectras  <cit> . however, they typically require specific knowledge of each supported search engine, such as parameter formats and supported input and output formats. compared to the abovementioned tools, app has the advantage of offering a user-friendly proteomics server software enabling distributed computing with minimal configuration. the flexible plugin model allows the establishment of unique proteomics pipelines tailored to the needs of the data. this makes routine use of complex workflows feasible and allows simple scaling of processing capacity with demand. since submitted tasks can be continuously monitored during execution, app provides feedback at every step of the process and is never a black box for the user.

the need for a general solution to distribute software tools has been acknowledged by projects such as taverna workbench   <cit> , yabi , knime  and galaxy . however, these depend on the maintenance of one or several grid engines to provide distributed and remote processing. knime relies on a functional setup of sun gridengine. likewise both galaxy and taverna workbench depend on the establishment and maintenance of an existing computational cluster. yabi can utilize a number of such grid engines, but does not fundamentally change the need for advanced setup and maintenance. this is beyond both the abilities and needs of many research groups. app focuses on simplifying setup of it infrastructure on commodity computers and does not depend on any tool outside of the core application for distributed processing. any virtual or physical machine capable of executing app can easily be made part of its processing network. for this reason, the task of setting up and maintaining a processing infrastructure is practical for “pure research” groups and precludes the need for access to core shared infrastructure.

app aims to make task execution as simple and powerful as possible by providing distributed processing for multiple search engines compatible with tpp. for advanced and automated workflows, it is possible to script pipelines, but this places great demands on user computer skills and does not by default handle distribution, parameter generation or job monitoring. unlike the petunia web-based interface provided by tpp, app addresses these issues by providing a number of template tasks and default optimized executions without any need to know specific commands or parameter input formats. the app plugin model preserves much of the flexibility of the scripting approach. thus, app combines the great flexibility of scripted pipelines while providing a simple way to execute standard tasks. users are encouraged to refer to the tutorial section of the app manual available on the project homepage to gain a good understanding of the app task model.

example of a workflow
an example of data processing using app is presented in figure  <dig>  the data representing an in-gel plasma-membrane digest of the recent proteomics study of srivastava et al.  <cit>  were used for the analysis. they were converted from  <dig> mgf files into  <dig> mzml files using the msconvert plugin, each mzml file containing a portion of the spectra from its parent file. this was done to allow more efficient parallelization of data processing. the task included multiple database search engines, i.e. comet, ms-gf+, myrimatch and x!tandem using both k!score and native scores. searches were performed against the black cottonwood  protein sequence database  <cit>  concatenated to its own reverse protein sequences. searches were performed using tryptic settings, with one tryptic missed cleavage allowed. a precursor tolerance of 50 ppm and a fragment tolerance of  <dig>  da were used. the fixed peptide modification selected was ethanoylated cys. a single variable mode for oxidized met was used. the myrimatch output was processed through the app spectrumnamefixer plugin to standardize the naming of the spectra. ms-gf+ had its output mzid files converted to pep.xml using idconvert, prior to the standardization of the names of the spectra with the spectrumnamefixer plugin. results from each search engine were validated using peptideprophet/iprophet and proteinprophet. the iprophet output from each search engine was then combined using iprophet and a resultant protein list created using proteinprophet. a spectral library was then constructed using high scoring peptide spectral matches  from the combined iprophet result. this spectral library was combined with search results from the two additional gel samples ran previously in  <cit> . decoy spectra were added to the final spectral library at a ratio of  <dig> decoy spectrum per real spectrum. spectrast was then used to perform a spectral search on all files utilizing the newly generated spectral library. the spectral search results were analyzed using peptideprophet/iprophet and database and spectral search outputs were combined using an iprophet plugin. a proteinprophet plugin was used to create the final protein list. the input data contained around  <dig> ms/ms spectra. two setups were used to compare results from centralized and distributed executions:  a single high-end compute optimized amazon instance was used to process the task, which is equivalent to the utilization of a single very powerful computer;  several smaller compute optimized instances were used to illustrate distributed processing over several smaller nodes.

amazon computing power can be measured in virtual cpus . the total number of vcpus was kept constant, with  <dig> vcpus for the single c <dig> xlarge compute instance and an equivalent  <dig> vcpus for the  <dig> c <dig> xlarge amazon instances . this approach illustrates any impact of app scheduling on task speed. while the network io and drives are faster for the single powerful instance, this difference is less important than pure processing power since app handles file transfers during processing of previous jobs, allowing workers to process continuously while jobs are provided. a second task was also submitted to the app server. in this case, the label free data extractor plugin was used to export peptides and psms from all combined results and search engines, using the following criterion: each proteinprophet protein with a probability above  <dig>  had supported peptide sequences with a probability above  <dig>  indexed. these had all post-translational modifications  stripped and each supporting psm with a probability above  <dig>  was exported. psms with a probability above  <dig>  are treated as supportive by proteinprophet and thus gave a positive contribution to peptide probability. the exported results were filtered to keep only a single instance of any repeat psms or stripped peptide sequences. additionally, before counting unique peptide sequences all leu residues were replaced with ile since these residues are indistinguishable by ms.

results from the workflow used as an example
the results obtained from the above example workflow are depicted in additional file 1: figures s <dig> and s <dig>  and summarized in table  <dig>  the versions of the software used are listed in additional file 1: table s <dig>  the execution time for all tasks in the distributed setup was 6 h whereas the single instance required a somewhat longer execution time of about 8 h. it is noteworthy that a majority of computation time was spent to process the ms-gf+ search results, with an average processing time of over 1 hour per data file in both setups . this is more than at least  <dig> times longer than needed for the other search engines to process the same data. it is thus a limitation for users with limited computer resources. however, ms-gf+ search jobs are run in parallel, which uses less total time than sequential runs of jobs. some differences in speed were experienced with different plugins running on a single instance compared to the distributed execution. typically, comet was slightly faster in the single instance execution mode, while x!tandem with native score was slower. likewise, myrimatch processed its results slightly faster using a single node, while ms-gf+ was slower despite the fact that the amount of memory available and disk speed is advantageous in the single node execution setup. most differences in processing speed are offset by increased parallelism in the distributed task, with myrimatch executing  <dig> parallel instances when distributed, but only a single job utilizing all  <dig> vcpus on average when running on the single instance mode. overall, the observed execution times show that distribution of processing is at least as performant for large tasks as runs on a single powerful computer. this illustrates the ability to assemble an efficient processing infrastructure from multiple slower nodes.table  <dig> 
summary of number of hits and processing time for each search engine 


x!tandem: native score
x!tandem: k-score
myrimatch
ms-gf+
spectrast
comet
all database search
all db search and spectrast
see additional file 1: figure s <dig> for an overview of the output provided by each search engine.



future developments
app is a plugin-based infrastructure with virtually unlimited opportunities for expansion. it allows the management of all aspects of proteomics analysis through a single interface. app distributes the processes and wraps applications in a way that does not require their re-writing. it will be continuously upgraded through the implementation and addition of new plugins. for example, we are currently integrating an external mascot server support  as well as support for msblender  <cit>  and idpicker  <cit>  to allow other validation pathways. more integration targets are uninovo  <cit>  for use in de novo sequencing and blast2go  <cit>  for the functional annotation of search results, along with plugins for the generation of inclusion and exclusion lists for use in repeated ms/ms runs. plugins allowing the structured export of data from app projects into other data backends will also be released to aid integration of app with an external database repository or other analysis tools. the additional plugins will be released on the project homepage as they are tested and pass quality controls.

CONCLUSIONS
app is a user-friendly and powerful tool that allows research groups to easily set up and perform distributed proteomics processing. its modular plugin nature greatly facilitates complicated proteomics tasks, such as analysis by several database search engines. app also greatly simplifies information management and provides multiple tools for non-search related tasks, including spectral counting or housekeeping tasks such as fixing spectral references in search engine outputs. deploying app computing nodes for database searches is as easy as unzipping a single archive. thus, even groups without dedicated it support are able to perform large scale distributed computing independently. the parallel utilization of several search engines provides significant advantages over the use of a single engine, both in terms of coverage and validation. each search engine identifies a number of unique peptide sequences and spectra that are missed by other search engines. individual engines also provide their own scores for use in validation of commonly identified peptides. in the example provided here, ms-gf+ and myrimatch identified the largest number of spectra and peptides, whereas myrimatch and x!tandem with k-score identified the largest number of peptide sequences not matched by another search engine. comet and x!tandem have a very high performance and might be the recommended pair of search engines to use when performing searches on limited hardware.

availability and requirements
project name: automated proteomics pipeline.

project home page:https://sourceforge.net/projects/automatedproteo.

programming language: java version  <dig> 

operating system: platform independent, packaged for windows and ubuntu.

other requirements: java runtime  <dig>  or higher; the web portion requires perl  <dig>  and apache web server.

additional file
additional file 1: 
table s <dig>  software versions used for example tasks. figure s <dig>  output of the example workflow. a) number of identified peptide sequences by each search engine; while many peptides are common, each search engine provides a unique set of identified peptides. b) equivalent output as in a), but for psms; the figure highlights matched spectra rather than peptide sequences. figure s <dig>  output of the combined workflow. venn diagrams showing the extent of overlap between different combinations of search engines. a) and b) represent overlap of unique identified peptide sequences and psms, respectively. note that iprophet filters out low-scoring psms and peptides.



abbreviations
appautomated proteomics pipeline

tpptrans proteomic pipeline

ms/mstandem mass spectrometry

psmpeptide spectral match

ptmpost-translational modification

vcpuvirtual central processing unit

competing interests

the authors declare that they have no competing interests.

authors’ contributions

ekm wrote and developed the software. ekm, vs, gs and vb conceived and designed the experiments. ekm, vs and gs executed experiments. ekm and vb wrote the paper. all authors read and approved the final manuscript.

