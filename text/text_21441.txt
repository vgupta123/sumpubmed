BACKGROUND
miniature inverted repeat transposable elements  are short non-autonomous transposable elements  that move by cut-and-paste mechanisms  <cit> . they do not produce transposases, proteins that mobilize tes, and are therefore dependent on those produced by autonomous elements for transposition  <cit> . compared to typical cut-and-paste transposons, mite families often have high copy numbers, and transposition of these elements generates widespread genomic variations  <cit> . due to their small sizes, mite insertions are much less disruptive to genes than the larger elements. therefore, they can often be found in genic regions, introducing phenotypical changes in some cases. for example, an insertion of a stowaway mite named dtstu <dig> in the flavonoid 3′,5′-hydroxylase  gene of a potato leads to red pigmentation, and a mping insertion in the rice hd <dig> gene results in changes in flowering time  <cit> . most mite insertions may not cause phenotypical changes, but rather they alter gene expression levels and epigenetic profiles that may contribute to the overall fitness of the organisms under certain conditions  <cit> . while understanding how mites transpose to achieve high copy numbers can further our knowledge on their influence on genome evolution and provide mite based genetic tools  <cit> , genome wide identification and characterization of mite families broaden our views on different types of mites and the scale of their activity and amplification during evolution  <cit> . new mite families may become better candidates for studies of their transposition and amplification as well as for genetic markers.

mites were first discovered from the genetic variation caused by an insertion at the maize wx-b <dig> locus  <cit> . computational approaches were employed to assist the characterization of mites with the increasingly available genomic sequences in databases around early 1990s  <cit> . due to their well defined structural features including small size , terminal inverted repeats  and target site duplications , the task to discover mite families at genomic levels is suitable for automation. however, the complexity of higher eukaryotic genomes presents a major challenge for such automation. the tsds and tirs of mites are very short sequences that can occur at a high frequency by chance, resulting in a large number of false output entries that need to be manually analyzed  <cit> . automated genome wide identification of mites can be time consuming because of the large sizes of higher eukaryotic genomes and high te contents. such computing tasks are often demanding on computing resources such as the number of cpus and the amount of ram.

the program findmite was developed and used for the discovery of eight novel mite families in the malaria mosquito anopheles gambiae genome from a sequence database containing short entries  <cit> . its input parameters include a predefined sequence or size of tsd, the length of tirs, and the minimal distance between tirs. all sequences satisfying the parameters are retrieved and processed. the program must, mite uncovering system, is based on string matching to identify candidate tir structures followed by checking the presence of a flanking tsd pair  <cit> . all candidates are retrieved and grouped. for genome wide analyses of higher eukaryotic mites, findmite and must generate a large number of false positives because many sequences that satisfy the defined parameters can occur by chance. mite-hunter was developed to decrease the number of false positives  <cit> . it uses multiple sequence alignment to filter out sequences otherwise meeting mite signature criteria but bearing similar flanking sequences. as a result, mite-hunter has a false positive rate of  <dig> - <dig> % compared to 85% of findmite and 86% of must  <cit> . in these programs, all of the candidate elements were retrieved and analyzed while, theoretically, the identification of only a single element is necessary for a mite family with hundreds of copies. therefore the existing algorithms are resource expensive and require lengthy processing time. for example, it took mite-hunter ~44 hours to process the rice genome database  with a linux cluster using five cpus. the  <dig> raw output entries were reduced and grouped into  <dig> mite families with manual downstream analyses.

here, an algorithm was developed to increase processing efficiency by reducing or avoiding redundant computing, therefore shortening the processing time and reducing the requirement for computing resources. the novel algorithm was implemented in mite digger, one of the few te analysis programs featuring graphical user interface  <cit> . when tested with the rice genome sequence database, it took mite digger ~15 hours on a quad core windows system to complete processing with a typical memory use of ~150 mb. comparative analyses of the mite digger output with the mite hunter output showed that mite digger is accurate with low false positive and false negative rates.

methods
database and programs
the rice genome sequence database was obtained from irgsp/rap build  <dig>  <cit> . the output from mite-hunter was obtained from yujun han and sue wessler   <cit> . analyses of mite families and comparisons were performed with mak <dig>   <cit>  . mite digger was based on the perl script used for the retrieval of aton elements  <cit> . blast +  <dig> . <dig> was used to perform sequence similarity searches. mite digger output was generated using its default parameters. the mite digger entries that do not match those in the mite-hunter output were searched against the rice repeat database using repeatmasker . genome sequences of rapa, tomato, potato and sorghum were downloaded from plantgdb .

implementation and testing system
the algorithm was implemented in activeperl  <dig> . <dig> with perl tk  <dig>  and bioperl modules  <cit> . mite digger was tested on windows xp and windows  <dig> systems.

RESULTS
redundant computing in genome wide discovery of mites
a mite family typically consists of several hundred highly similar copies. therefore, when every candidate element is processed in genome wide analyses, a mite family can be computed hundreds of times. such repetitions can occur at multiple stages including signature feature  identification, screening, multiple sequence alignment or clustering. these repetitions also occur to the elements that do not qualify for the input criteria such as the element length. furthermore, genomes often contain highly repetitive sequences such as retro elements that have the structures of short inverted repeats flanked by short direct repeats buried in their internal sequences. these non-mite sequences can occur more often than mite families and each family may be computed hundreds or thousands of times depending on their copy numbers.

these redundant computing can take up a major portion of the total processing time. in addition, after retrieval of every element of a family, the need to remove redundancy or to group elements into a family can be time consuming and resource intensive. particularly, when multiple sequence alignment is used to identify candidates with different flanking sequences, aligning elements in a family with several hundred copies takes a significant amount of time. finally, when database entries are sliced into very short fragments to reduce memory use, the processing efficiency can be dramatically affected because of the overhead on retrieving and analyzing a large number of sequences.

measures to reduce redundant computing
elimination or reduction of these redundant computing should dramatically increase efficiency. theoretically, only a single complete copy of a mite family is sufficient to represent the whole family and repetitions on other copies are unnecessary. therefore, computing on each member of a candidate mite family or a false family can be reduced to the computing on a representative of the family. once a representative is identified, later occurrences of the family can be filtered out from the database entries. the redundancy is heavily concentrated toward the later part of a genome sequence database. if the members of a family with n copies are distributed randomly in a genome, the probability  of not having any copy present in the first x portion of the genome is: p = n, therefore the portion of the genome to have at least one copy at this probability can be calculate as x = 1-p1/n. the portion of a genome to have at least one copy of a family with  <dig>   <dig>   <dig> copies at different probability level can be calculated . accordingly, the probability of missing an element of a mite family with  <dig>   <dig>  or  <dig> copies in 37%, 21% and 8% of a genome database is only  <dig> , i.e. the probability to contain at least one copy of these families in respective portions of the genome database is high . less than 5% of the genome database is needed to contain at least one copy for mite families with > <dig> copies with the probability of  <dig> , i.e. probability of  <dig>  to miss . therefore, only a small portion of a genome may be necessary to retrieve most of the mite families; this is particularly useful in the processing of large genome databases. the members of a mite family are normally expected to be located in different genomic loci, a false family can be identified as that having similar flanking sequences for every individual copy. instead of an alignment of the flanking sequences of all copies of a family, comparison of those of a small subset of the members is sufficient and can reduce processing time dramatically. in addition, the removal of low complexity regions at start can eliminate the need to process false tir and tsd motifs that are often found in such regions. finally, processing the database entries in large sizes with high sensitivities will reduce the overhead of processing numerous small entries.

pipeline algorithm and parameters
mite digger takes a genome sequence database file in fasta format as input. the entries are automatically sliced to the maximal size of  <dig>  nt if the entries are larger than this size . each entry of the sliced database was used to search against a reverse complementary sequence of the entry to reduce memory consumption and increase sensitivity. this search was performed with highly sensitive parameters  to reveal very short inverted repeats. tabular output format was used to reduce memory use. simple inverted repeats such as those with stretches of a single or dinucleotides and those only contain g/c or a/t were ignored. a pair of short stretches of sequences  flanking the inverted repeats within the defined length range  were used to find direct repeats of  <dig> to  <dig> nt in size. since tsds of some elements such as stowaways and piggybac tes may be present in inverted repeats, the search for direct repeats is also performed on the most terminal  <dig> nt of the inverted repeats if direct repeats are not found in the flanking sequences. the dna sequences between each qualified inverted repeats were then used to search against the whole genome database and the number of full length copies were counted. when a candidate meets the copy number threshold, the flanking sequences of  <dig> nt on each side were retrieved. the flanking sequences of different copies of the candidate family were compared. when qualified for the number of different flanking sequences, the candidate sequence was deposited into the filter database and the output if a similar sequence is not already in the output. otherwise, the sequences meeting the copy number threshold but not the number of different flanking sequences are deposited into the filter database and the false output. the filter database is used to mask the upcoming genome database entries. the processing information is printed to a report file each time a new candidate is identified. when a new candidate or false sequence is deposited, the filter database and the output database  were reformatted for blast searches.

performance analyses
mite digger was used to process the rice genome database to identify mites with a size range of  <dig> to  <dig> nt. on a windows xp system with  <dig> cpu cores, processing finished in  <dig>  hours with a typical memory use of ~150 mb. a total of  <dig> candidate mite sequences and  <dig> false sequences were generated . entries from mite digger output can be used directly for downstream analyses. when the numbers of output entries were plotted against the portions of the genome processed, it is apparent that the number of candidates retrieved in a certain amount of genome sequences decreases with the increase of the amount of processed genome sequences. this reflects the reduction in redundant computing . the most apparent increase in the number of candidates is in the first 20% of the genome. the curve nearly flattens out for the last 20% of the genome. while the processing rate fluctuates because of different levels of complexity of sequences in different regions, it clearly more than doubled from <3% of the genome sequence database per hour at the beginning to >6% at the end of the processing . predicted remaining time to completion decreases dramatically particularly during the first 10% of the genome database. filtering has also dramatically reduced the number of false elements per database unit over the course .

mite digger allows customized input of parameters. database entries larger than the defined entry size will be automatically sliced and automatically formatted. the option to set the number of cpus allows optimal performance of mite digger in platforms with different hardware settings. the option for probability level allows timely processing of large genome databases with a minor chance of missing a mite family. changes to other parameters such as the copy number threshold, different flank sequence threshold and sensitivity will affect the number of output entries. the predicted running time is based on the current average processing rate, therefore the actual total run time can be dramatically shorter than the predicted time at the early part of processing because of acceleration .

evaluation of mite digger output
the output from mite digger was compared with that of the mite hunter. first, the entries in the mite digger output were cross matched with those in the mite hunter output, resulting in  <dig> non-redundant matching pair records. since the mite hunter output contains entries up to 1500 bp, only those between  <dig> and 800 bp were considered as mites. among the  <dig> records,  <dig> pairs cover at least 80% of the length of both query and hit sequences. the remaining records were manually inspected and four additional matching pairs were found. because a mite family may contain several subfamilies, one entry from mite digger can match several entries in mite hunter and vice versa. therefore, the  <dig> matching pairs consisted of only  <dig> mite digger entries and  <dig> mite hunter entries . in the remaining  <dig> records,  <dig> mite digger entries match the terminal sequences of some mite hunter entries, suggesting that these mite digger entries represent new subfamilies in the families of the mite hunter entries . the rest of the records match short regions in the internal sequences of some long entries of the mite hunter output and were considered non-informative records. therefore, of the  <dig> mite digger output entries,  <dig> can be classified with the mite hunter output entries. the remaining  <dig> entries were scanned with rice repeat database using repeatmasker,  <dig> of them were previously annotated elements or can be manually classified. six  of them are false positives: two rice simple repeats and four retroelements . the other five were dna elements: two stowaways ; one harbinger , one mutator and one unknown category . therefore a total of  <dig>  mite digger output entries are classifiable mite families that are not in the mite hunter output . the remaining  <dig> entries cannot be classified even though they have the characteristics of class ii tes.

to estimate the accuracy of mite digger, the output was compared with the mite entries in repbase and the entries in mite hunter output. repbase contains  <dig> entries of non-autonomous class ii elements shorter than 800 bp. among these sequences, only  <dig> did not have a match in the mite digger output. none of these elements meet the criteria for mite: five  do not bear tirs and the other  <dig>  have less than  <dig> complete copies in the genome. therefore, all of the mite entries in repbase were retrieved by mite digger. the accuracy was also calculated as the percentage of the mite digger output entries matching entries of the mite hunter output in the same size range . of the mite hunter entries,  <dig> are shorter than 800 bp and  <dig> of them also have at least  <dig> full length copies. of these  <dig> mite hunter entries,  <dig> entries were found in the mite digger output, resulting in a missing rate for mite digger of  <dig> %  . close inspection of these  <dig> elements revealed that, with the exception of os_mhat <dig> and os_mhat <dig>  all of them have a significant part  of their sequences matching an entry in the mite digger output , suggesting that these elements were missed because elements of a different subfamily are present in the mite digger output. the reason os_mhat <dig> and os_mhat <dig> were missed remains unknown.

to calculate the false negative rate, the entries of the mite digger false output were cross matched with the mite hunter output entries. a large number of matching pairs are those matching the internal regions of mites of the mite hunter output as expected. only three mite digger false output entries were found to be real mites that matched mite hunter output entries , therefore the false negative rate is  <dig> % .

to see how fast mite digger runs with other genomes, the recently released genome databases of banana , potato , tomato , chinese cabbage  and sorghum  were used. genome wide characterization of mite families has not been previously performed in these genomes. all of these genomes gave much fewer numbers of entries than rice in the mite output . it is apparent that the running times for the databases are not simply determined by the size of a database. the factors affecting running time include the size and complexity of a genome, the number of entries in a database, the number of candidate and false entries.

CONCLUSIONS
in summary, mite digger retrieved exemplars of mite families from the rice genome with high accuracy and low false positive and false negative rates. importantly, mite digger is not computing resource intensive and the output requires minimal manual processing. therefore, it can be used routinely to perform genome wide identification of mites in higher eukaryotic genomes.

availability and requirements
project name: mite digger

project homepage: http://labs.csb.utoronto.ca/yang/mitedigger

operating system: windows

programming language: perl

other requirements: n/a

license: by the developer

any restrictions to use by non-academics: license needed

abbreviations
te: transposable elements; mite: miniature inverted repeat transposable element; tir: terminal inverted repeat; tsd: target site duplication.

competing interests
the author declares that they have no competing interests.

authors’ contributions
gy developed and implemented the algorithm, performed tests and analyses, wrote the paper.

supplementary material
additional file 1
mite digger report and output for the rice genome database.

click here for file

 additional file 2
comparison of the output of mite digger and mite hunter.

click here for file

 acknowledgment
the mite hunter output was kindly provided by dr. yujun han and dr. susan wessler. i would like to thank dr. brad cavinder for comments on the manuscript. funded by national sciences and engineering research council  of canada; canadian foundation for innovation ; ontario research fund  and university of toronto.
