BACKGROUND
protein structure prediction has become one of the key tasks in computational biology of the post-genomic era. due to the growing size of structural databases, the most important and widely used method is homology modeling. this methodology relies on the existence of structures of homologous protein in databases. the major parts of this procedure are i) recognition of homology between two proteins and ii) correct alignment for the pair of two proteins for which homology was recognized. here we focus on the latter, still challenging problem. accurate alignment is essential for many state-of-the-art 3d protein structure prediction algorithms  <cit> . the development of novel threading algorithms however is hindered by i) lack of a general consensus on scoring schemes and ii)plethora of different variants of the same scoring function described in literature but not available as a ready-to-use software.

our contribution presents a versatile tool for the fast and extensive aligning of two proteins with each other. the alignment can be based on i)the two sequences, ii) one sequence and one structure or iii)on the two structures. the first case, corresponding to pairvise sequence alignment is trivial and can be solved by dynamic programming. however, the other two  are np-hard problems  <cit> . our novel object-oriented application, incorporated within the bioshell package  <cit> , is an integrated framework to heuristically tackle these protein-to-protein alignment problems. the application is written in java language which facilitates its easy use on various systems and architectures. the advantages and novelties of the software over the existing and downloadable ones  <cit>  are: 

i) it employs monte carlo  to sample the alignment space so an approximate solution to np-hard 3d threading problem can be found,

ii) each scoring term type is a separate object that can be easily switched on/off and fully customized with user-provided data, e.g. in a single run, several secondary structure similarity scores may be used, each of them based on a different secondary structure prediction,

iii) new potentials and scoring schemes can be easily implemented by users,

iv) as a result, the user obtains the best scoring solution and a number of suboptimal alignments, ranked by their score; the alignments can be outputted in the modeller  <cit>  format file and easily used to build final model structures.

v) it can be used as a structure alignment software, also capable of producing suboptimal structure alignments.

vi) it can read in and score any arbitrary alignment provided by the user. this can be very helpful in the manual refinement of alignments or for threading force field development.

the project website provides extensive documentation of the library  and numerous examples which show how to run the executable threading application and how to interact with the software library.

implementation
the source code was divided into four main blocks: i) encoding alignment as system coordinates, ii) moves , iii) scoring and iv) gathering results. each of these components forms a separate sub-package in the source code tree: jbcl.simulations.threading, jbcl.simulations.threading.movers, jbcl.simulations.threading.ff and jbcl.simulations.threading.observers, respectively. these routines are supported by other generic bioshell components such as monte carlo sampling and i/o operations. for user’s convenience we provide also a stand-alone application. to run calculations, the user specifies: i) input data, ii) modification scheme and the of mc sampling and iii) scoring function .

alignment representation
protein-to-protein alignment between query  and template  proteins is defined as a list of blocks . every block represents a gapless alignment stretch between a query and a template sequence  <cit> . an ith block is of the length l
i
, where the fragment starts at the ith position in the query sequence and at the jth position in the template sequence and ends in i+l
i
 and j+l
i
 positions in the query and the template sequences respectively. in the course of code optimization we introduced two restrictions into the program. the first one states that any single block cannot be shorter than the min_block length which by default is set to  <dig>  making this value smaller  results in considerably higher computational cost but occasionally might lead to better alignments. the second rule states that an alignment must consist of at least the min_number_of_blocks, by default equal to  <dig>  this second rule is only a technical trick that gives all movers  a chance to be executed successfully and thus make the sampling process more effective. since we do not require two neighboring blocks to be separated by a gap, it is always possible to represent a long alignment block as concatenation of several shorter ones. for instance, a perfect alignment of a  <dig> amino acid sequence with itself may be defined as  <dig> blocks of  <dig> residues each, by  <dig> blocks of  <dig> residues, or by many other combinations of blocks which are not separated by gaps. all of them however lead to the same alignment and have the same score. thus the second rule does not limit the sampled conformational space. moreover, both restricting parameters may be changed by the user from the command line.

alignment sampling
a list of blocks defines a point in the conformational space of all possible sequence alignments between two proteins. sampling of this space is performed by a set of movers i.e. objects that attempt to modify an alignment. the following seven types of movers have been implemented so far: shift a block, shrink/expand a block, merge two blocks, split one block into two new blocks, jump part of the one block to a neighbor block, create a new block and annihilate a block. the move types have been schematically depicted in the figure  <dig>  the background grid represents a classic dynamic programming  matrix; solid and dashed lines denote an alignment before and after a move, respectively. blockshift shifts a block horizontally and/or vertically on the dp matrix with a uniform distribution within the allowed space . blockshrink & blockexpand can shrink or expand a block on either end within the allowed space. a block cannot shrink to a length shorter than the min_block_length. the length n of shrinking/expanding is generated with 1/2
n
 distribution. blockpartjump performs a jump of a part of a block to a neighboring block. the length of the jumping part was generated with uniform distribution which does not violate the min_block_length. blocksplit can split a block into two parts with conservation of the min_block_length for both of the two parts. the split is performed with a uniform distribution. blocksmerge can merge two neighboring blocks when possible. merging continues as long as the min_number_of_blocks is fulfilled. blockannihilate can annihilate one of the alignment blocks if the min_number_of_blocks is not violated. finally, blockcreate creates a new block. the user can define how often each of the move types is attempted. once a mover has been executed and an alignment modified, the new conformation is accepted  according to the metropolis criteria  <cit> . the sampling process is governed either by simulated annealing   <cit>  or by replica exchange monte carlo   <cit> . the latter offers a very effective way to sample the conformational space of all possible alignments. as an example , we show energy distributions obtained by a remc search comprising ten replicas running at  <dig> distinct temperatures:  <dig> ,  <dig> ,  <dig> ,  <dig> ,  <dig> ,  <dig> ,  <dig> ,  <dig> ,  <dig> ,  <dig> . the distributions exhibit large overlap with neighboring replicas which facilitates random walk in the temperature space and results in highly enhanced sampling. in this particular example 2pcya query chain was modelled on 2azaa template with  as the energy function. however, we found this set of temperatures to be very universal and working very efficiently for various scoring schemes and different protein lengths. therefore remc with these temperature settings  was used for all the numerical experiments described in this contribution.

alignment scoring
each particular alignment is assessed by a scoring function . this function is defined as weighted combination of distinct terms. the scoring terms implemented in the package can be divided into six categories:  structure based scores, such as tm-score  <cit>  or crmsd,  contact potentials such as miyazawa-jerningan  <cit> ,  environmental potentials, e.g. solvent accessibility score  sequence profile similarity measures,  secondary structure similarity measures and  gap penalty functions. the full list of available scoring methods is provided in table  <dig>  group  of scores require the query structure to be provided and can be used either for benchmarking purposes  or for a structure-to-structure monte carlo  alignment. group  scores transform a template contact map onto a query sequence based on a current alignment. finally, scores from groups , , and  use various kinds of profiles: sequence profiles, predicted propensity for a certain secondary structure type, predicted solvent exposure level etc.

an inheritance diagram depicting basic relationships between the classes is shown in the figure  <dig>  in which each rectangle denotes an abstract interface and a box with rounded corners - an implemented score type. all the score types are derived from alignmentenergy. some of them also inherit from byatomenergy which means that the score value may be decomposed into a sum over all aligned residue pairs. substitutionscore based on a substitution matrix such as the blossum  <cit>  or pam  <cit>  matrix is obviously a byatomenergy example, while rmsdalignscore cannot be implemented in this manner. byatomenergy ability is very important for the program as it enables the calculate energy change without the evaluating whole alignment. one a mover has altered an alignment, it returns a list of alignment columns  that have been affected. then the program evaluates the energy difference at these positions only. further, some of the byatomenergy scores can be pre-calculated for every query-template residue position once the program is started and stored in a 2d array. such scores implement a bigmatrixenergy interface and substitutionscore is an example of it. an interesting case is strgappenalty derived from contactbasedenergy. indeed, the penalty for a gap introduced into a template structure is assessed based on the number of lost contacts. the user can easily implement one’s own scoring function by extending one of the provided abstract classes  <cit> .

RESULTS
here we use the application in two real life examples to demonstrate the robustness and possible applications of the software. the scripts used in the experiments with the relevant input data were published on the project website.

threading as a structural alignment algorithm
threading where both the query and the template protein structures are known is equivalent to the protein structural alignment. the calculation of such alignments is a perfect test for searching strategies. in the bioshell-threading package there are three scoring functions which can be used for this purpose: tm-score, rmsd and dali-score. in this contribution we compare the tm-align  <cit>  algorithm with 3d threading in which -tmscore  <cit>  was used as an energy function. the benchmark set  <cit>  comprises more than  <dig> pairs of homologous proteins. remc simulation was performed for  <dig> replicas with temperatures distributed from  <dig>  to  <dig>  dimensionless units. it can be be seen in the figure 5a that alignments found by remc search are in most cases very close to tm-align results. in a very few cases, however, 3d threading can find a significantly better match which suggests that the heuristic search implemented in tm-align, although very fast, does not always find the optimal solution. the calculations were repeated with the fragment-based variant of tm-align   <cit>  which resolved virtually all of the discrepancies. on the other hand, other structural alignment tools such as ce or dali yielded alignments with worse tm-scores . this was expected since these tools were designed to optimize their own z-scores rather than the tm-score parameter. it should be noted that this parameter was arbitrarily chosen in this experiment to test sampling efficiency. searching with bioshell-threading also generates sub-optimal structural alignments which are often very close , but may differ significantly from the optimal solution .

quality of query sequence-template structure alignments
to test the threading algorithm on more realistic problems, the malidup  <cit>  benchmark has been used. results are shown in the figure 5b. malidup benchmark comprises  <dig> protein pairs of diverged duplicated domains. it was chosen because the evolutionary relation for the domains under consideration is fairly recognized and not biased by sequence similarity. the 3d-threading algorithm was compared with four other methods: global sequence alignment with the blosum <dig> matrix , profile-to-profile alignment  with the picasso <dig>  <cit>  scoring function, threading1d  <cit>  and the widely used, state-of-the-art method: hhalign  <cit> . for profile-to-profile, threading 1d and threading 3d runs sequence profiles were generated with five psiblast  <cit>  iterations against the nr <dig> database and e-value threshold below  <dig> . for the hhalign algorithm, multiple sequence alignments , were created in the local searching mode with hhblits <cit>  on the nr <dig> database created on january  <dig>   <dig>  subsequently, these msas were used in aligning query and template sequences with hhalign, in the global alignment mode.

the following scoring terms were used: envscore, probabilisticsecondaryscore, picasso <dig>  golikescore, twobodycontact with miyazawa-jernigan contact scoring and strcgappenalty. the following weights:  <dig> ,  <dig> ,  <dig> ,  <dig> ,  <dig>  and  <dig> , respectively were optimized on the prosup  <cit>  dataset. the objective of this test was the quality of calculated alignments i.e. average tm-score and alignment overlap with manually curated alignments. the latter was measured as the percent of correctly aligned positions al0p and the fraction of aligned positions predicted with an error of at most four positions al4p. for the malidup set it can be observed that the threading algorithm, which incorporates 3d information from the template structure , performs better than the other tested algorithms, both in respect of average tm-score and overlap with manual alignments . profile-based aligners: threading 1d and hhalign perform comparably on these benchmarks, whereas bioshell-threading performs much better. in particular, when compared to hhalign , it achieves approximately  <dig>  higher al0p and  <dig>  higher al4p. this is partially due to the fact, that in case of unrecognized homology, hhalign returns a null alignment . there are some possible applications of this result. it can be used to generate alignment boundaries for protein modeling algorithms which can use such the information  <cit> . in this case the alignment boundary is the range for every query’s residue to which it can align within the template structure. it is also possible, using sub-optimal alignments, to create more diverse spatial constraints for algorithms such as modeller  <cit> .

practical considerations
the computational approach utilized in this contribution is an example of a stochastic simulation rather than a typical alignment method. user has to define a number of parameters to control this process, such as the number of monte carlo replicas and the respective set of their temperatures. fortunately, several methods have been devised for remc parameters selection, e.g.  <cit> . in general, these parameters depend both on query and template proteins and should be optimized separately for each case. however, for the sake of simplicity, for any benchmark calculation presented in this contribution we used the same set of ten replicas as described above. this temperature set is wide enough to obtain good results for all the test cases but inevitably increases the computational effort. optimization of these parameters might also occasionally lead to better alignments. however, even for the optimal set of parameters it takes from several minutes to more than an hour to reliably sample the low energy area of the alignment space. the three-dimensional threading monte carlo simulation will always be at least an order of magnitude slower than a dynamic programming calculation but is usually faster than raptor - another three dimensional threading where calulations even for short sequences take more than an hour  <cit> . raptor method however employs branch-and-bound approach and, unlike a stochastic simulation, the reach of the global optimum of a scoring function is guaranteed. other parameters a user should optimize are: scoring function weights and probabilities of particular alignment modifications . the extensive study of this parameter space is beyond the scope of this paper and will be described elsewhere. in this work, to avoid overtraining, we optimized the scoring function and movers set on prosup data set  <cit> , which has not been used for benchmarking purposes.

the 3d threading application can also be used as a structural alignment method. in the presented benchmark, it has been compared with tmalign and yielded nearly the same results. cpu time required by tmalign was however about two orders of magnitude shorther . this result is a direct consequence of the number of times each of the two programs calls the tm-score evaluation routine. in order to test the convergence of the threading, calculations were started from a random alignment. during the simulation tm-score has to be evaluated at every monte carlo move which, unlike scores derived from byatomenergy, cannot be recalculated locally just for the moved block. tmalign, on the other hand, starts from an alignment computed by a dynamic programming procedure and evaluates tm-score a few times until convergence is reached. the threading simulation however provides a numer of different suboptimal alignments which all fall within  <dig>  range in tm-score units.

CONCLUSIONS
bioshell-threading implements a three-dimensional protein threading algorithm based on a monte carlo search scheme. the code has been written in java language which makes it virtually machine independent. it implements numerous scoring  functions. some of them can be applied in regular dynamic programming. for others, the optimization becomes a np-hard problem and demand more time consuming methods . the package provides a ready to use command-line application and a java software library. this makes bioshell-threading a component that can be very easily incorporated into larger protein structure pipelines  <cit> . by providing suboptimal alignments, the package can increase the accuracy of widely used protein folding softwares and proteins structure classification methods. however, the main goal of bioshell-threading is the refinement of query-to-template alignments. at the time, when fold recognition methods are fast and quite accurate, alignment accuracy is the limiting factor. thus using certain fast algorithms  <cit>  to search the whole protein databases and then refine top hits with more sophisticated scoring function seems to be of a great value to the protein modeling community.

availability and requirements
• project name: bioshell threading 3d

• project home page:http://www.bioshell.pl/threading3d

• operating system: platform independent

• programming language: java

• other requirements: java  <dig>  or higher

• license: creative commons by-sc-nd

• any restrictions to use by non-academics: licence required

competing interests
the authors declare that they have no competing interests.

authors’ contributions
pg, ak, ak, dg developed the idea and the framework of the software. pg and dg implemented the software and carried out analyses. all authors wrote, read and approved the final manuscript.

