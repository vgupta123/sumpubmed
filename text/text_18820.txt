BACKGROUND
structural variations  are the main source of intra- and interspecies variation and have been shown to play an important role in the evolution of many species  <cit> . sv detection is now playing a leading role in the advancement of research for many organisms such as plant breeding and our understanding of human diseases and disorders  <cit> . indeed, svs are of interest to researchers from varying backgrounds aiming to address svs from different angles. therefore the need to identify the most efficient and reliable tools for sv analysis is critical to the advancement of genomic research for all organisms.

large genomic structural variants, such as insertions and deletions of more than  <dig> base pairs , copy number variants and translocations are often induced during the course of dna repair. several dna repair mechanisms exist in plants and animals, but usage may vary according to structure and arrangement of the genome being studied. some relevant, sv-inducing mechanisms include non-homologous end-joining  associated with dna-repair at regions with very limited or no homology, non-allelic homologous recombination  in highly similar regions , fork stalling and template switching  as in replication-error mechanisms, and finally transposable element -mediated mechanisms of repair .

in addition to variations in the types of sv induced, genomes may also vary in their degree of complexity. in contrast to vertebrate genomes, for example, plant genomes are more susceptible to hybridization and to further increases of genome complexity  <cit> . these challenges can often exacerbate the numbers of sequencing errors and mapping uncertainties which further add to the complexity of identifying structural variants  <cit> . this may lead to differences in behavior of the sv detection tools that were solely designed with homo sapiens or animal data in mind. while previous studies have sought to address problems of sequencing errors and mapping uncertainties in human genomes with the development of new sv tools  <cit> , we are motivated by the need for insight into the performance of sv tools on non-human genomes. it is critical that multiple tools be used in identifying svs as each tool is likely to respond to these changes in genome structure with varying degrees of success  <cit> . this should be taken into consideration when choosing a sv detection tool as some are more suited to one purpose than another. for this reason we have chosen to benchmark tools using varying sv techniques.

sv detection techniques
four general techniques are employed to detect structural variations from paired-end sequencing data. each approach has merits and shortcomings. here we provide a brief sketch of each technique and list a few tools which make use of them.

coverage: the coverage, that is the amount of reads aligning to a genomic region, can be used to draw conclusions on its copy number status. when a region is not covered by any reads, for instance, one can conclude that the respective part is not present in the genome under investigation. an advantage of this technique is that it allows for a direct estimate of the copy number. however this technique only applies to larger events and can be affected by sequencing biases. in general, this type of methods works best for comparing pairs of samples sequenced using the same platform/protocol. examples of such tools include cnver and cnvnator  <cit> .

internal segment size : the internal segment  is the unsequenced part between the two read ends in a paired-end sequenced  fragment. library preparation and sequencing protocols determine the shape of the distribution of internal segment sizes. when alignments at a particular locus give rise to estimates of an is size that deviates significantly from this background distribution, the locus is likely to be affected by a structural variation in the genome being examined. as tools draw conclusions based on statistics of is length, their performance rates crucially depend on the shape of those distributions. in general, they perform best for unimodal distributions with a small standard deviation. as the observed is size increases in the presence of insertions, the maximal length of insertions that can be detected is limited by the mean is size. this limitation, however, does not exist for deletions. examples of is size-based sv discovery tools include breakdancer, clever, gasv, hydra, modil, svdetect and variationhunter  <cit> .

split-reads: split-read methods try to align reads across structural variation breakpoints. that is, one of the two read ends is aligned such that the sv is part of the unaligned read. this technique has the advantage of yielding single base pair resolution. however, performance is dependent on the length of the reads as shorter reads lead to more, ambiguous  alignments, especially in repetitive regions of the genome. examples of such tools include pindel, splazers, and crest  <cit> . standard read mappers like bwa, bowtie, gsnap or stampy, to a certain extent, can also provide correct, gapped alignments for insertions and deletions  shorter than 50 bp  <cit> .

local assembly: structural variations can also be detected by running a de novo assembly and comparing the resulting contigs with the reference genome. this method is unbiased, yields single base-pair resolution and is, in general, the only way of detecting insertions of novel sequence longer than the read length. short reads and repetitive areas, however, make it difficult to build sufficiently long contigs from ngs reads. examples of assembly tools include allpaths, soapdenovo and velvet  <cit> .

combined: in recent years, several hybrid methods using more than one of these four paradigms have been developed .

creating a “meta-tool” for all organisms
the difficulty in selecting tools for sv prediction in non-human genomes is manifold.first, tools developed so far are often tailored towards human or vertebrate genomes  <cit> . that is, tools may expect genomes to be diploid and of a certain repetitive structure, gene count, cg content and so on. without further analysis, it remains unclear which tools are robust with respect to changes in gc content, complexity and, last but not least, ploidy. reliable benchmark datasets that reflect such modifications are required to properly evaluate tool performance.

second, creating an optimal selection of sv calls from the applicable tools is another, involved issue. to do this, one needs a statistically sound procedure by which to create reliable and strong consensus call sets from the tools chosen, and one, again, needs to rigorously evaluate such consensus call sets.

third, tools should be evaluated in a standardized pipeline. because sv discovery is still a relatively recent and active area of research, benchmark datasets that reflect both true sequence context and sv abundance are hardly available  <cit> . what confounds all the issues further is that many tools, due to being in active use, frequently undergo updates, which may decisively touch upon their strengths and weaknesses.



testing and comparing multiple tools in a standardized fashion is daunting for both researchers and programmers. a “meta-tool” platform addresses these many considerations as it is flexible with respect to frequent version updates, integration of new tools and new datasets. here, we provide such a platform in the sv-autopilot virtual machine. this platform allows forevaluation of new tools.

running multiple sv callers in a single run from an easy, out-of-the-box program.

interoperability with downstream analysis as all outputs are in vcf format.



in order to identify the sv tool most adaptable to non-human genomic research, we further propose to benchmark all tools of interest on known genomes with validated svs through a standardized pipeline.

in summary, we present sv-autopilot, a structural variation automated pipeline optimization tool. sv-autopilot standardizes the sv detection pipeline and can be used on existing computing infrastructure in the form of a virtual machine  image. modularization of components allows for easy integration of additional tools, version updates and other benchmark datasets. in addition, the benchmarking data of tool performance and computational demands provided here demonstrates the critical need for using multiple sv tools for predicting svs. using this platform, researchers are able to identify svs from multiple sv detection tools with the choice of merging the call sets according to the statistically-sound approach provided here. false positives are thereby reduced and the call set becomes enriched for ‘true’ sv events. sv-autopilot provides a much needed resource for biomedical researchers, bioinformaticians and tool developers. the sv-autopilot is available with a user guide via the open source repository github https://github.com/allbio/allbiotc <dig> and the vm is hosted on the allbio web site https://bioimg.org/sv-autopilot.

methods
benchmarking: datasets
tools were benchmarked on a reconstructed genome using validated svs from the arabidopsis thaliana lansberg  ecotype  <cit> . the sv calls were incorporated into the tair <dig> genomic sequence as per the procedure previously described  <cit>  for craig venter’s genome  <cit> . reads were simulated to correspond to illumina hiseq paired-end 100 bp read data with a fragment size of 500 bp and 30x coverage, using simseq with the illumina hiseq error profile  <cit> .

most sv tools were developed for human or animal genomes  <cit> . in order to compare the performance of the tools on human and plant genomes, simulated reads from the human chromosome  <dig> of venter’s genome were used , where read simulation proceeded analogously to the read simulation for the ‘ler’ arabidopsis genome. in this way, reads correspond to illumina hiseq paired-end 100 bp read data with a fragment size of 500 bp and 30x coverage. we chose venter’s genome as the set of variants arising from it make an independent, high-quality choice of a set of variants which has already been used in previous studies  <cit> . most importantly, this set of “truth” variants does not suffer from tool-specific biases, as, for example, sets of variants obtained from the  <dig> genomes project. as the variants from the  <dig> genomes project stem from computational tools, those tools would clearly outperform the others when evaluated on such datasets.

we determined two standard deviation  settings for insert sizes, one of which reflects a popular, realistic scenario  and the other one of which represents a “worst-case” scenario , which reflects less optimal sequencing library protocols. this analysis highlights how the performance rates of tools behave relative to increased standard deviation. although we can expect much better sd values using the latest technologies, an sd of  <dig> is not atypical. the  <dig> genomes project, for instance, contains samples with sd values in this range. table  <dig> provides detailed parameters for each of the datasets used here. note that, one can “downsample” these datasets to also emulate scenarios of lower coverage if desired.table  <dig> 
overview of test datasets



type
genome
sequencer
length
insertsize 
insert sd
coverage

illumina  <dig>  fastq paired end
tair9
simseq illumina profile
100
500
15
30x

illumina  <dig>  fastq paired end
tair9
simseq illumina profile
100
500
50
30x
arabisopsis  and human  datasets were simulated using a simseq illumina  <dig>  paired end profile with 100 bp reads and an insert size of  <dig>  two standard deviations of insert size were created for each dataset, more ideal  and less ideal . all datasets were simulated to 30x coverage.



benchmarking: sv tools
for benchmarking, several well-known sv discovery tools were selected as defined by the following criteria:open source .

support of command line mode .

default parameters provided and applicable in all cases considered here.

scaled to process a moderate size genome with the operating limits of a common laptop.



the tools selected varied in terms of their approaches. we included paired-end methods, split-read methods and combinations thereof, as those combined approaches reflect the state-of-the-art in indel discovery. in detail, we selected breakdancer, clever, delly, gasv, pindel, prism, and svdetect  <cit>  for being included in sv-autopilot, as a selection of well-known state-of-the-art sv discovery tools. in addition, the modularized structure of sv-autopilot conveniently allows one to replace and add tools according to individual preferences. all tools were run using the most recent releases available as of january  <dig>   <dig>  although many tools are able to predict varied types of structural variants , the emphasis here is on insertions and deletions of more than 20 bp. we leave an extension of our platform towards those other classes of svs as promising future work. all technology presented here is easily adapted to also allow for these extensions.

discovery of insertions and deletions smaller than 20 bp is a prevalent part of variant discovery pipelines  and poses no further challenges to the user, while discovery of indels greater than 20 bp still comes with substantial difficulties. therefore, the focus of this work will be on insertions and deletions larger than 20 bp. they may be referred to as ‘indels’ or structural variants  although we recognize that this may occasionally clash with existing nomenclature.

benchmarking: sv size classes
for the purposes of benchmarking, insertions and deletions events were divided into  <dig> size categories: 20-49 bp, 50-99 bp, 100-249 bp, 250-999 bp, 1kbp-50kbp. distinguishing between those size classes allows one to identify size-dependent strengths and weaknesses of the tools considered. the first class, 20-49 bp is, to a certain degree, still in reach of even ordinary alignment tools, while generally constituting the major area of activity of split-read aligners. 50-99 bp can in general be considered as the most difficult size range, where both split-read aligners and is based approaches face non-negligible challenges. overall, the first three size ranges, 20–49 bp, 50–99 bp and 100-249 bp have sometimes been referred to as the twilight zone of sv calls as all of them are rather difficult to identify. above 250 bp, the svs are usually larger than the insert range, which makes calling them relatively easy for is based approaches. we determined 50kb, the size of the largest validated sv documented in test datasets, as an upper limit for the purposes of the benchmarking documentation provided here. it is noteworthy that most tools that are able to detect 50kb svs can also detect larger svs. validated sv counts in the various size classes for both  data sets are provided in table  <dig> table  <dig> 
counts of validated svs used to benchmark sv tool performance



data type
type
length 20-49
length 50-99
length 100-249
length 250-999
length 1000-50000

tair v.9
insertion
8094
446
82
44
3
deletion

tair v.9
deletion
3595
781
393
572
370


virtual machine
virtual machines  ensure the consistency, reproducibility and reliability of our test environment. each vm was equipped with the same software installation. the virtual machines were installed with ubuntu  <dig> . <dig> lts using default configuration. after installation of the essential system components, the software of each sv tool was installed, and a non-persistent system image was cloned from the master machine. the non-persistent image provides a consistent and reliable working environment to run the benchmarking analyses.

for initial testing of computational performance by each tool, vms were created for varying numbers of cpu cores  and varying amounts of available main memory . multiple machines were booted with this non-persistent image, sv discovery tools were run and the resulting data was collected. different settings were tested to explore the computational resource requirements of the sv discovery tools.

analysis pipeline
sv-autopilot was implemented using makefiles according to the gnu make syntax. a modularized setup was employed, which allows one to disable and replace aligners and sv discovery tools as needed or as per personal preference. additionally, such modularity enables tool-wise parallelization.

while generation of a bam file from raw reads proceeds sequentially, sv discovery tools may be run in parallel . additional scripts written in python have been included to transform the output of the tools into vcf, if needed. additional parameters can be set for the performance metrics analysis and the optional merge step, discussed below. the makefiles for sv-autopilot are supported and are available via the github repository . the pipeline for sv-autopilot, including pre-processing via fastqc  <cit>  and sickle  <cit> , is detailed in figure  <dig> figure  <dig> 
sv-autopilot pipeline. illumina pair-end ngs data in the form of a fastq file is submitted to the pipeline for sv analysis along with a genomic reference sequence. a quality report is provided by fastqc, and sickle is used for trimming low quality reads. modularity allows for a choice of read aligner and sv tools. samtools flagstat is run to evaluate the quality of the mapping. each tool’s output is converted to a vcf format, unless already provided by the program, for downstream use by the researcher. for those wanting to benchmark tool performance, the performance metrics for the tools can be compared in the pdf report provided. finally, when using multiple tools as part of a pipeline leading to sv validation, the option to merge sv calls according to the statistical method provided here is available to enrich the call set with true calls by merging results and reducing false-positive calls.



merging: statistical considerations
the difficulty in creating a “consensus” call set from different, individual call sets consists in identifying virtually identical calls and merging such calls into one, unifying call. while a few ad-hoc procedures have been suggested in the literature  <cit> , neither of them addresses how to control the false discovery rate, that is the amount of calls that are merged mistakenly because of random effects. moreover, they also do not address the specific strengths and weaknesses of the tools whose usage led to generation of the individual call sets. a statistically sound merging procedure should be guided by two insights:the accuracy of sv breakpoints provided can vary substantially among sv discovery tools. while split-read aligners tend to deliver highly accurate breakpoints, internal segment size based approaches deliver inaccurate breakpoints. this has two implications: first, merging criteria for internal segment size based approaches should be more relaxed and, second, the consensus call should indicate the most accurate breakpoint predictions available.

calls may be mistakenly merged, simply due to random effects, such as fluctuations of call density, too large individual call sets, and so on, and one would like to control the false discovery rate, that is, the amount of mistakenly merged events. in other words, merging criteria should be such that randomly chosen call pairs meet them only with low probability.



while 1) can be addressed by evaluating tools on benchmark datasets, 2) needs further elaboration. consider, for example, two tools that, on a genome of length g, within a certain size range---for example, deletions of size 20–50 bp---have generated call sets of size k <dig> and k <dig>  respectively. that is, k <dig> out of g bases in the genome are affected by a breakpoint  of a deletion of size 20–50 bp predicted by the first tool, respectively k <dig> out of g bases are affected by breakpoints  predicted by the second tool. let the merging criterion be that the breakpoints of two calls do not deviate by more than l basepairs . the probability pk <dig> k <dig> g that the breakpoints of two randomly picked calls, one from the first tool and one from the second tool, are at a distance of at most l basepairs is pk <dig> k <dig> g=1−1−1−1−lgk1k2=1−1−lgk1k2≈1−exp−k1k2lg 

merging: note on reciprocal overlap as criterion
reciprocal overlap does not represent a sound criterion for merging two calls, and also for evaluating calls, because:for large deletions, breakpoints are allowed to deviate by massive amounts of base pairs. for example, requiring 50% reciprocal overlap for two deletions of  <dig>  bp in length allows a distance of 5000 bp between breakpoints. a random caller that randomly places breakpoints in the genome is considerably more likely to place a “good” breakpoint than, for example, when considering 100 bp deletions.

for truly small deletions, say of 20 bp in length, breakpoints are only allowed to deviate by at most 10 bp . this, however, is oblivious to the repetitiveness of many genomes and to the fact that gap placement is difficult, which renders it possible that two different calls are virtually identical although deviating by up to 50 bp in terms of breakpoints.

there is no obvious, overlap-based criterion for insertions.



in summary, the idea of using  overlap for merging and evaluating calls is statistically unsound and introduces severe, misleading biases when merging calls.

merging: parameters
guided by the considerations outlined above, we determine that two calls are to be merged if their breakpoints do not deviate by more than 50 bp and the lengths of the indels predicted do not deviate by more than 20 bp. while the merging algorithm is able to take tool-specific criteria into account, we found that the unifying criteria in use here yielded excellent results in our benchmark. as a general guideline for adapting criteria to tools, we recommend stricter criteria for split-read aligners , because alignment based breakpoint predictions tend to be very accurate  whereas for is based approaches 100 bp distance and 100 bp length deviation are still the most sensible, because on top of the usual issues due to repetitive sequence, these tools can predict highly inaccurate indel breakpoints.

it is worth noting that the probability that the breakpoints of two calls do not deviate by more than 50 bp is never larger than  <dig> , for any of the tools and genomes considered here when merging calls whose lengths do not deviate by more than 20 bp---which determines the sizes and k <dig> and k <dig> of two different call sets to be compared, as computed by the above formula. therefore, criteria of this order of magnitude  are a good general choice when studying within-species genetic variation.

merging: algorithm
the merging algorithm receives calls  from different tools, all of which are specified by a breakpoint and the length of the variant in question  to have discovered the same insertion or deletion in the genome under consideration.

as a formal model to capture this, consider a graph, in the sense of graph theory. the nodes of the graphs are the calls from the different tools, and an edge between two calls reflects that the breakpoints are at a distance of not more than 50 bp and that the length does not deviate by more than 20 bp, which, as per the considerations from above, translates into statistical evidence that the two calls correspond to the same indel.

after having constructed this ‘call graph’, all of its maximal cliques are identified. we recall that, by definition, a clique is a subset of nodes all of which are pairwise connected by edges. hence, a clique translates into a set of calls all of which are statistically likely to represent virtually identical variants. maximal cliques, that is cliques to which no further nodes can be added without violating the clique property, represent maximal sets of calls that point at the same, likely correct indel. hence, they are maximal call subsets that one should merge into one unifying call.

enumerating all maximal cliques proceeds by making use of an algorithm that greatly profits from the fact that calls can be ordered by their breakpoints in a left-to-right fashion. the algorithm was successfully used in other graph-based settings where nodes specified genomic loci and could be ordered in a left-to-right fashion  <cit> . the merging algorithm is implemented in python. the algorithm is very fast; for example, using a macbookpro <dig>  , it merges call sets from as many as  <dig> tools within only  <dig> or 3 minutes.

benchmarking: comparative analysis report
in the final step of the sv-autopilot pipeline, the predictions of each tool are compared to the true annotations if available. in this, the considerations are similar to those used for merging. that is, we take into account that the breakpoint and length specifications of tools can deviate from the true annotations, even though they have indeed discovered the true indel in question. reasons for this are plentiful. as expected, internal segment size based approaches are unable to specify breakpoints  accurately. even  alignment based approaches may fail to provide accurate breakpoints, as accurate gap placement in alignments has remained an algorithmic challenge in bioinformatics .

a predicted insertion/deletion is considered as a match to a true insertion/deletion if the distance of their center points and their length difference are below user defined thresholds. when choosing thresholds, the tools’ characteristics, the genome under investigation, and the insert size distribution of the sequencing library should be taken into consideration. as discussed above, split-read methods tend to be more accurate than paired-end methods in terms of breakpoint resolution. a large standard deviation of the sequencing library will lead to read pair methods being less accurate when estimating the length of an indel.

here, two different sets of parameters were used, which we refer to as strict and relaxed. the strict parameters require a center distance of at most 50 bp and a length difference of at most 20 bp, while the relaxed criteria ask for a center distance of at most 100 bp and a length difference of at most 100 bp. both definitions still ensure that a match is statistically significant , which has been guided by considerations that are similar to the ones we have described for merging call pairs -- the difference here is that one of the call sets are the true annotations. the relaxed setting was included to show that some tools make calls that are near true events but don’t exactly hit them . based on these criteria, the analysis scripts reports various different statistics stratified by length range. the above parameters were used in benchmarking; however, these can be modified by sv-autopilot users and adapted to their dataset and tool set.

to assess general performance, the absolute number of calls as well as precision and recall are reported. precision is the percentage of predictions that match a true annotation and thus measures the fidelity of the calls made by a given tool. recall, on the other hand, is the percentage of true events that have been spotted by the given tool and thus measures the comprehensiveness of the delivered call set. reporting these two performance statistics allows researchers to choose a tool that suits their needs. for instance, when seeking to discover new variants, high recall may be more important than high precision so as to capture as many true calls as possible. conversely, when validation is planned, a low false positive rate is imperative and the focus of sv detection would be on high precision. following validation, realignment may be performed and the preference may again change to that of a high recall rate for the purposes of sv discovery, knowing you may encounter a higher number of false positives. for the purposes of presenting an overall tool performance metric, the f-measure is provided, defined as 2*precision*recall/. thus, this measure integrates recall and precision into one single performance indicator.

some false positive predictions of insertions or deletions are caused by substitution  events where a stretch of dna in the reference genome has been replaced by another piece of dna in the donor genome under study. the lengths of the deleted and the inserted parts need not be equal and we refer to their difference as the effective length of a substitution event. internal segment size based approaches are especially prone to confusing such events with insertions or deletions of the same effective length. therefore, the reports provided by sv-autopilot contain another column  with the percentage of predictions that do not match an insertion/deletion but do match a true mixed event of similar effective length.

to assess the accuracy of each tool in terms of the reported breakpoint positions, we also report the average center point distance as well as the average length difference of all predictions that match a true event. knowing the accuracy in terms of breakpoint coordinates can be valuable for correctly merging calls of different tools and for the design of primers used in sv validation.

interpretation of the results with radarplots
to ease the interpretation of the performance metrics, radarplots, generated using matplotlib  <cit> , are plotted providing the measurements of tool performance for recall, precision, and the f-measure. some tool types are expected to perform better than others for a given metric. in general, it is expected that split read aligners will be more accurate at reporting breakpoints and thus perform with higher precision than other types of aligners. the radar plots provided here are in the shape of a pentagon . each angle of the pentagon relates to a size class of sv evaluated. tool performance data is plotted for each size class and the points are connected to provide a visual representation of performance across all size classes.figure  <dig> 
radar plot interpretation. each corner of the pentagon represents a size class of sv. performance is measured on a scale of 0– <dig> , with  <dig>  as the most accurate calls. each tool is associated with a color as indicated in the associated figure legend. tool performance across all size classes is easily assessed by evaluating the total area of the radar plot covered by a given tool.



RESULTS
the sv-autopilot pipeline was created to provide a “meta-tool” platform for using multiple sv-tools, to standardize benchmarking of tools, and to provide an easy, out-of-the-box sv detection program. as most sv tools have been designed, and/or optimized for performance on human datasets, benchmarking tool performance on another organism was needed to determine whether some tools are more adaptable to a non-human genome than others. as the field of sv detection continues to develop and evolve, and more tools continue to become available, a standardized method of evaluating their performance relative to other existing tools was also needed. here we show that sv-autopilot addresses each of these needs.

sv-autopilot was used to benchmark seven structural variation  prediction tools. the tools were tested on their ability to identify svs in the two reconstructed genomes described, human chromosome  <dig> and the arabidopsis lansberg  genome, a plant genome. human chromosome  <dig> was chosen as a representative sample of the human genome which is small in size and for which many structural variants have been validated. as most sv tools were designed for use with the human genome, it is expected that tools will perform well on the human dataset and that it can be used in a comparison of tool performance on the arabidopsis genome. for reports on tool performance on the human genome as a whole, please see the original sv tool publications. in addition, we have provided the results of the entire venter genome data as an example of a larger, whole genome run in the additional file  <dig>  as expected, the tools perform much the same, however some tools were unable to meet the demands of managing such a large genome, likely due to the higher memory needs for sv processing.

the tools included in the sv-autopilot virtual machine and which were used for benchmarking included gasv, delly, breakdancer, pindel, clever, svdetect, and prism. due to the modularized set-up employed by sv-autopilot, sv tools can be easily added or removed from the pipeline. in addition, the user is able to choose which of several alignment algorithms is used in their analysis. for example, in the initial testing phase, both bwa-mem and bowtie <dig> were tested for each tool. bwa-mem was chosen for continued downstream use in the benchmarking as all the tools tested performed a few percentage points higher in recall and precision . for the purposes of benchmarking, the ability of a tool to accurately call an sv was measured using the analysis tools described and reports were generated for both ler and human chromosome  <dig> data at standard deviations of  <dig> and  <dig> .

performance metrics
often researchers are unable to predict the computing requirements for a given tool as this information may be missing in the literature or beyond the reach of the average biologist. for those required to make specific requests for computing time at computing centers or on the cloud, this can be a severe bottleneck to initiating their research. to facilitate future analysis of tool performance, each tool in this study was evaluated for its computing performance  in addition to sv prediction assessment. data was collected for ram and cpu usage, run time, as well as io and threading abilities.table  <dig> 
typical computational performance by sv tools used for a single run



tool
multi- threading
mem use on tair 
mem use on human 
cpu time tair 
cpu time human 
algorithm
sv’s
log files document computation performance for each tool used in this benchmarking study. documentation from a single run shows memory  usage and cpu time need to run each tool on arabidopsis  and on the human dataset used in the benchmarking. additional columns refer to the type of algorithm used  and the svs that the tool is reported to be able to predict . raw log files are included in the supplementary data.



each tool was run independently on the arabidopsis dataset and evaluated for computational performance. as shown in table  <dig>  cpu time varied widely across tools. for example, gasv completed the run in 2 minutes, while pindel took 3 hours and 3 minutes to run. clever and pindel both allow for parallelization while the others tools run on a single thread. although parallelization generally improves performance, pindel does not appear to show the gains expected. this may be due to the large volume of calls made by pindel in addition to pindel’s very verbose vcf file.

prediction performance
the ability of each sv tool to accurately call an sv event was evaluated and a pdf report produced as part of sv-autopilot’s pipeline . while there are multiple ways of defining ‘accuracy’, in statistics it is typically defined as /. as ‘true negatives’ are not applicable in this setting, we choose to use an integrative measure of recall and precision, provided here as the f-measure. in a biological context, ‘accuracy’ can refer to a measure of how close the breakpoint predictions of true positive calls were to the true breakpoint coordinates. therefore we provide the average length difference and the center point distance between true call and prediction. we have separated statistics into ‘strict’ and ‘relaxed’ categories which implicitly address questions of tool accuracy.

each length class of sv was examined individually to evaluate performance. table  <dig> provides an overview of performance by each of the tools on ideal  and less ideal  datasets for arabadopsis and human chromosome  <dig>  when examined for precision, the ability to match a true insertion/deletion, and recall, percentage of predicted true insertion/deletions out of total true svs provided in the dataset, a few tools were shown to be more adaptable to the arabidopsis dataset than the others: clever and pindel, with delly performing well in the largest size class .table  <dig> 
best performing sv tool for each size class of insertion and deletion using normal and less-ideal datasets of arabidopsis and human chromsome 21



a. precision
data type
std dev
length 20– <dig> p 
length 50– <dig> p 
length 100– <dig> p 
length 250– <dig> p 
length 1 k-50 k p 

insertion

deletion

b. recall
data type
std dev
length 20– <dig> r 
length 50– <dig> r 
length 100– <dig> r 
length 250– <dig> r 
length 1 k-50 k r 

insertion

deletion
for this work, a standard deviation of  <dig> is considered normal while a standard deviation of  <dig> is considered less-ideal. recall and precision were two measures used to evaluate the ability of a tool to accurately predict svs. here the winner for each length class is provided along with the tools winning value for that category. . the additional file  <dig> contains all tool performance statistics in the pdf reports. in table 4a both ‘relaxed’ and ‘strict’ criteria   are provided for the precision measurements which indicates how accurate the tools are at making their calls. in table 4b the scores of tool recall demonstrate how much of the svs the tools are able to discover.




effect of different standard deviations
in the purification of ligation product step of llumina paired-end sample preparation protocol, different settings may cause the resulting dna fragment library to have an insert library with variations in standard deviation  of the insert size  <cit> . therefore simulated reads for each sample were prepared at both sd  <dig> and  <dig> 

in the low quality  arabidopsis dataset, pindel outperformed other tools in precision and recall at sv lengths ranging from 20– <dig>  whereas in human chromosome  <dig>  clever showed better precision and recall. at the better standard deviation of  <dig>  clever consistently performed with the best recall in all sv length classes .figure  <dig> 
data quality affects the performance of sv tools in human and arabidopsis data sets. some tools are more affected by changes in data quality than others. the standard deviation of the insert size of paired end reads was used as a measure of data quality. the recall and precision of deletion calls are measured for human and arabidopsis datasets at the less optimal  and more optimal standard deviation .



unlike the other tools, delly showed no change in calling ability between the sd  <dig> and sd  <dig> datasets. delly consistently excelled at recall in the largest sv classes of deletions . for other tools the change in sd resulted in more significant changes in performance. for instance, breakdancer’s performance dropped considerably in the lower quality dataset, especially for the smaller size classes. however, this is consistent with breakdancer documentation  <cit> .

adapting to non-human datasets, benchmarking in arabidopsis
tools tested in this study were initially developed for use in human genome analysis. however, with the reduction in sequencing costs, many non-human genomes are being sequenced to identify svs. arabidopsis is a well-studied plant species with many validated svs. in this analysis we compared the ability of various tools to accurately call svs in the genome of a species for which it was not initially designed.

only  <dig> of the tools tested were able to predict insertions: breakdancer, pindel, clever and svdetect. however, although svdetect made a few predictions of insertions in the human dataset, it did not make any predictions at all in the arabidopsis dataset regardless of sequence library insert size standard deviation. this was unusual as although more tools performed at sd  <dig> than  <dig>  all the other tools were able to make predictions for both genomes.

as most tools performed better overall on the datasets with a smaller standard deviation, the comparison of tool performance, between human chromosome  <dig> and arabidopsis, provided here is limited to the sd  <dig> datasets. when compared to the human chromosome  <dig> dataset, sv tools performance on the arabidopsis dataset showed reduced precision of calls in size classes spanning from 50-99 bp and 100-249 bp, but higher recall over all size classes among insertion events. when examining deletions, the arabidopsis dataset had comparable recall to the human dataset at 50-99 bp, but was reduced in the class 20-49 bp. above 100 bp, the arabidopsis data set performed with higher recall than the human dataset, however, it is possible that the limited number of validated events in the human chromosome  <dig> dataset in this size class may limit the statistical power of this analysis. when examining calls on the basis of recall and precision, pindel and clever consistently out-performed other callers. in general, clever had higher overall recall while pindel was found to perform with higher precision in its calls. however, prism often performed with better recall in the human dataset, but not in arabidopsis. interestingly, delly showed the highest recall in the largest size class of arabidopsis. this suggests that pindel and clever may be able to offer the best calls for non-human datasets with delly being useful for identifying deletions in the largest size class.

meta-tool performance
benchmarking of the arabidopsis dataset used here has shown that some sv tools may be more adaptable in working with a non-human dataset than others. as demonstrated here, tools may vary considerably in their performance depending on the size class of svs to be identified as well as the quality of the genomic reads. therefore, it is clear that a meta-tool is needed to not only provide sv calls, but to group the call-sets from multiple sv tools and provide a filtered output based on the performance metrics of the individual tools. in sv-autopilot, a merging script was developed to take all the calls, filter them, and provide a merged output . this merging may be initiated by the user following the completion of all sv tool runs and parameters set to tailor the output according to user preferences pertaining to recall and precision.

unlike other sv merging tools, here researchers receive fewer and more accurate calls to begin their investigations to validate svs. when arabidopsis  calls were filtered through the merge script, total calls were reduced by as much as 70%  with recall diminished, on average, 27%. in merging a small portion of recall is lost for the benefit of a reduction of more than half of the calls total . this results in an enriched set of true calls in the call set for validation.

as shown in figure  <dig>  the merging script is able to cluster calls by evaluating their breakpoints relative to the tool algorithm type applied . the user may select which vcf outputs from the various tools run in the sv-autopilot pipeline to be considered in the merging process. merged call-sets, as with the other tools included in the pipeline, are provided in vcf format and can be visualized on any genomic browser .figure  <dig> 
example of merged call set compared to individual call sets. integrated genome browser view of merged predictions. calls made by each tool are shown in individual tracks, and the merged call set provided by sv-autopilot is shown in the bottom track. in this example a larger call by breakdancer has been recentered by the merging algorithm. the red lines on the bottom indicate the position of the reference variants.



tool use and development
the sv-autopilot meta-tool is packaged as a vm. this allows for standardization of the pipeline for sv prediction. sv tool benchmarking on new genomes, and provides a platform for evaluating the performance of sv tools under development. the sv-autopilot virtual machine is packaged with  <dig> of the most popular sv tools currently available, reflecting the most recent updates and versions . in addition, a merge script has been added which will filter and rank calls providing researchers with an accurate and condensed set of calls curated from all the tools. for the purposes of this work, sv-autopilot has been run in a whole with all sv-modules enabled. default configuration of the pipeline is set to the pipeline described for the benchmarking in this work, however, it is also customizable to allow for a tailored analysis.

each of the modules, both sv-callers and pre- and post-processing steps, can be modified by changing the predefined running parameters while maintaining the structure. a general pipeline config file hosts the configuration for the pipeline. project specific or sample specific settings, involving file conventions, locations of genome files and program definitions can be altered from the invocation. more specific settings can be changed or a new procedure added into the pipeline .

for example, the alignment algorithm used in this project was bwa-mem  <cit> . the modularized design of sv-autopilot allows for other aligners, currently provided in the modules section , to be used. this allows a comparative study of different settings or versions of software using the same reproducible setup. indeed, we cannot claim that our decision to do alignment with bwa-mem is the best practice now or in the future. therefore the pipeline allows replacement of functional components with alternative implementations. it is our intention that this tool be used not only by researchers for generating comprehensive sv calls, but also by programmers/developers for the testing performance of tools they are developing against currently available tools. sv-autopilot is packaged in a vm and allows for just that. the tool is available at https://bioimg.org/sv-autopilot.

CONCLUSIONS
here we have taken ‘human’ sv prediction technology and applied it to a non-human organism, arabidopsis. we have provided benchmarking data on the performance of seven of the most popular sv prediction tools and tested them on reads of varying quality. tools were shown to vary in their ability to adapt to a non-human genomic dataset and datasets of varying quality.

this work demonstrates the importance of using multiple sv tools in order to cover a wide range of sv size classes and to minimize false-positive calls. we have packaged several of these tools into a single virtual machine pipeline, sv-autopilot, to facilitate reproducible research and coupled that with a powerful merging script that filters and ranks calls providing researchers with an accurate dataset on which to begin their bench validations. all call-sets have been formatted to fit the standard vcf format to facilitate visualization in genomic browsers and interoperability with other genomic tools. sv tool developers and sv researchers are able to test new tools against existing tools to examine performance, evaluate new datasets for tool optimization, and to generate a high quality enriched set of sv calls for further validation. the sv-autopilot vm can be downloaded with all datasets, tools and algorithms presented here at https://bioimg.org/sv-autopilot.

additional file
additional file 1: 
the data sets supporting the results of this article are available in the as part of the sv-autopilot virtual machine, in
https://bioimg.org/sv-autopilot
. the scripts used as the basis for the virtual machine described in this article are available via the github repository, in https://github.com/allbio/allbiotc2/.



competing interests

the authors declare that they have no competing interests.

authors’ contributions

wyl created and maintained the virtual machine, designed and implemented the pipeline to facilitate for this research project. tm participated in the design of the study and designed the evaluation script for assessing benchmarking results. lf participated in the conception and design of the study. yp participated in the sequence alignment. lm participated in the design of the virtual machine. as performed the statistical analysis, which includes the design of the merging algorithm, and helped to draft the manuscript. tym conceived of the study, and participated in its design and coordination and drafted the manuscript. as and tm are the developers of clever. in order to ensure the objective nature of this work, all sv tools included for benchmarking are strictly followed the exactly same selection and parameter tuning procedure as stated in the section of "benchmarking: sv tools". all authors read and approved the final manuscript.

