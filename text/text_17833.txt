BACKGROUND
experimental evidence at the single-cell level suggest that random fluctuations at the microscopic scale can have an important impact in determining the complex behaviour of living organisms  <cit> . these findings have raised significant interest towards discrete stochastic  models of biological systems as a tool for bridging the gap between stochastic events arising at the molecular level and the corresponding macroscopic phenomena. in ds models, the system evolves according to a stochastic algorithm which samples the probability of the next state transition from a given probability density function . biochemical reactions, in particular, are often modelled as discrete-state, continuous-time markov processes . this method represents an alternative to the traditional continuous deterministic modelling  approach when random fluctuations must be properly taken into account. this is the case, for instance, of systems composed of a small number of elements like molecular subsystems in living cells . in this context, descriptions provided by reaction rate equations fail both to predict the fluctuations in molecular populations and to capture stochastic-driven phenomena such as stochastic focusing  <cit> , stochastic switching  <cit>  and multiplicative noise effects  <cit> . the gillespie's stochastic simulation algorithm   <cit> , based on  <cit>  and  <cit> , is probably the most popular algorithm used for simulating ds models of chemical systems. the gssa relies on a monte carlo technique, namely the inverse transform sampling . gssa is used to numerically simulate the markov process described analytically by the set of differential equations from the chemical master equation . since the cme can rarely be solved either numerically or analytically especially for large systems, gssa provides a computational method to generate statistically correct trajectories  of the cme. these trajectories are obtained by drawing random samples from the so-called reaction probability density function   <cit>  through the its.

gillespie's ssa is designed for simulating sets of elementary chemical reactions occurring in a well-stirred mixture in a fixed volume and at a constant temperature  <cit> . thus, the straightforward application of gssa to a biochemical context can be difficult. indeed, it is easy to realise the difficulties in specifying all the elementary reactions composing a given biochemical system, mainly because of the lack of needed information. indeed, only macroscopic and mesoscopic events can be observed experimentally and, thus, it is not possible to know the complete list of elementary reactions. the usual strategy for tackling this problem consists of abstracting away the non-observable elementary steps and replacing them with a single reaction event rendered as a "markov jump" with the transition time  sampled from a negative exponential distribution. even though heuristic, this strategy can lead to simulation results showing a good agreement with experimental data .

however, the impact of the approximations introduced by this abstraction process is difficult to evaluate or estimate, as reported by gillespie in  <cit>  for enzymatically catalysed reactions. one crucial issue of this abstraction-approximation strategy is related to the modelling of the time needed for a reaction to occur: even though each of the elementary reactions composing a biochemical system can be described as a ctmp , the waiting times between two subsequent events observed at a mesoscopic or macroscopic scale can be non-exponential, as reported, e.g., in  <cit>  and confirmed by experimental evidence  <cit> . it can be demonstrated  and thus, strictly speaking, it cannot be a markov process. these arguments suggest the need for modelling frameworks that allow us to deal with a more general notion of waiting times, thus managing non-memoryless  systems' evolutions. in terms of waiting times, this corresponds to considering frameworks in which the pdf describing transition times can be different from a negative exponential.

various proposals have been developed for addressing the aforementioned issues. biopepad  <cit>  offers the possibility of adding deterministic delays to the duration of a reaction. in  <cit>  an extension for process calculi is proposed, allowing the expression of activity durations through general probability distributions. a similar approach is proposed in  <cit>  for extending petri nets. furthermore, in  <cit>  the authors improved the beta workbench  framework with the possibility of sampling waiting times from pdfs that are different from the negative exponential, such as the erlang or hyperexponential. this strategy results in better matches with the observed non-markovian biological behaviours. however, even though the data-fitting can enhance results, the considered pdfs do not exactly match the experimental evidence. hence, they may themselves introduce unpredictable approximations.

in this paper, we propose a constraint programming approach that is suited for being embedded in monte carlo algorithms for discrete-state continuous-time stochastic simulation of biochemical reactions. our method allows us to sample random numbers from pdfs that may not necessarily follow a negative exponential distribution including, e.g. the erlang and hyperexponential distributions considered in  <cit> .

relying also on the results about single-molecule enzyme reactions presented in  <cit> , we exploit our method for efficiently and accurately simulating the occurrence of enzyme catalysed reactions that follows the michaelis-menten  scheme. noticeably, our approach allows us to simulate this kind of reactions as a single s→ p  step without any loss of accuracy, i.e., without introducing approximations.

the contribution of this paper is hence twofold: on the one hand we propose a general method for building discrete-state continuous-time stochastic simulations of chemical systems, sampling waiting times from general pdfs distributions; on the other hand, exploiting our method, we provide an efficient and accurate strategy for the stochastic simulation of mm enzyme reactions. in the latter case, we provide a simulation technique that overcomes some of the limitations of the corresponding gssa approach.

our method is implemented on top of the gecode library , an efficient framework to solve constraint satisfaction problems  <cit> . essentially, we use the real intervals constraint support of gecode for solving sets of interval constraints. although specific numerical methods may be computationally more efficient, declarative methods as constraint programming provide a flexible framework able to quickly adapt to different situations, as we explain later. hence, the modellers have at their disposal a more general  tool that minimises the need for writing new code when the parameters of the model change.

we will show the features of our method through its application tot the simulation of enzyme reactions following the mm scheme. to do this, we first introduce in the following subsection some details regarding the mm reaction scheme and the results about single-molecule enzyme reactions obtained in  <cit> .

simulating single-molecule enzyme reactions
a convenient  way of describing all the elementary steps of an enzymatically catalysed reaction is through the michaelis-menten  model. according to this reaction scheme, a catalysed reaction of the kind s→ p  can be approximated with three "elementary" reactions:

  e+s ⇌k-1k1es →k2e+p 

the reaction set  can be simulated as a ctmp via gssa using k <dig>  k− <dig> and k <dig> as "elementary" rate constants. it is described as a single markov step and, thus, the corresponding transition time follows a negative exponential pdf. the propensity is calculated through equation , where v is the rate of product formation,  the substrate concentration and km the mm constant .

 v=k2+km 

mm kinetics is particularly convenient because it effectively reduces the three reactions in equation  to a single reaction s → p with rate v. moreover, the necessary parameters are easier to measure experimentally than the rate constants ki.

however, modelling enzymatic reactions with the mm kinetics introduces approximations at two different levels. the first level of approximation is inherent to the mm kinetics itself. indeed, it should be noted that equation  does not capture the dynamics of reaction set  exactly, being based on assumptions  that are approximately valid. the steady-state approximation is the first important assumption involved in the mm reaction scheme. according to this approximation, the concentration of the es complex will rapidly reach the steady-state, i.e., after an initial burst phase, the concentration of es will not change appreciably until a significant amount of substrate is consumed  <cit> . in in vivo experiments this assumption may not necessarily hold because the enzyme concentrations can be comparable to the substrate concentrations  <cit> . the steadystate approximation is well studied in the deterministic setting, where the reaction set  is described through a set of ordinary differential equations .

building a stochastic model à la gillespie of the reaction scheme , relying upon mm kinetics, requires the conversion of an ode model into a stochastic model. as previously pointed out, this is straightforward if the odes describe elementary reactions. some authors  compared the output of a stochastic model that uses mm kinetics and the corresponding model decomposed into the three "elementary" reactions in , and no significant differences in simulation results were found. the work in  <cit>  verified the equivalence of the deterministic and the stochastic mm approximations under a restricted set of initial conditions. in spite of these results, however, there is no general  method for converting mm terms from the deterministic to the stochastic setting. this problem has been exhaustively studied in  <cit> , where it is shown that a "full" stochastic model of the reaction set in equation , describing explicitly the three reactions, can be safely reduced to one s→ p reaction with stochastic rate v under certain conditions, namely, after the pre-steady-state transient period.

the second level of approximation regards the markovian modelling paradigm. modelling the reaction set in equation  as a single markov jump defined by the lumped reaction s→ p with rate v, implies subsuming that the process satisfies the markov  property: the probability of transition from the current state to one of the possible successors depends only on the current state. this, in turn, means that the pdf describing the waiting time τ must be a negative exponential function. as showed by single-molecule experiments  <cit> , the pdf describing the occurrence of τ is significantly different from an exponential. in other words, experimental evidence suggests that the occurrence of an enzymatically catalysed reaction is not a markov process. the problem of evaluating the approximation introduced by markovian models of natural systems is well known in physics and in some cases can be quantified  <cit> .

in the cases that have been studied, the waiting time τ for a biochemical reaction catalysed by a single enzyme results to be distributed according to the following pdf:

  fτ=k1k2s2a 

where  is the substrate concentration, k <dig>  k− <dig>  k <dig> and are the kinetic constants ) and

 a=24-k1k2b=- <dig> 

we note that a> <dig> and b< <dig>  differently from the classical ensemble experiments , a single-molecule experiment records the stochastic time trace of repetitive reactions of an individual enzyme molecule. in particular  the measured quantities regard the duration of the waiting time that passes between a reaction and the following one. therefore, in the absence of dynamic disorder, f  describes the temporal behaviour of the single-molecule mm system in equation  at any specified substrate concentration. this pdf is exact and does not invoke the steady-state assumption, but it can be reduced to the steady-state case  <cit> .

note that equation  is very different from the negative exponential pdf for waiting times proposed by gillespie. this suggests that gssa may be not adequate to simulate biochemical reactions catalysed by enzymes. another remarkable fact to notice is that the reciprocal of the mean waiting time 1τobeys a mm-type equation :

  1τ=-22bk1k2=k2+km 

in the next section, we show how our technique allows us to build a monte carlo-based algorithm for simulating the occurrence of  single-molecule enzymatic reactions, by sampling waiting times from equation  through the its method.

methods
sampling waiting times through the its method
for the sake of readability, let us write the equation  as:

  fτ=α 

where β≥γ and

 α=k1k22aβ=a+bγ= 

let fτ∈ <dig> . <dig> be the cumulative distribution function for fτ:

  f= ∫ -∞τfdτ=αeβ-eγτγ-α1β-1γ=r 

at this point, the its technique requires to find those values of τ such that f  = r by finding an analytical expression for the equation τ = f − <dig>  unfortunately, it is only possible to obtain such an expression in some particular cases, e.g. when β = 2γ.

it is easy to see that f   satisfies the following:

- for β < γ the plot of f  is the one depicted in figure  <dig> on the right and so the equation f  = r  has no solutions.

- for β > γ the plot of f  is that depicted in figure  <dig> on the left and so the equation f  = r  has certainly one  solution for each r when τ > <dig>  this solution is rarely available analytically but it can be estimated through numerical methods.

in the next section, we present an efficient method based on constraint programming for computing a solution to the equation τ = f − <dig>  this technique will be shown to be useful for sampling the waiting times taken from general pdfs. then, we shall describe our method based on experiments of individual enzyme molecules, reporting the obtained simulation results. in particular, we will compare our results with the homologous ones presented in  <cit>  in order to evaluate the differences between markovian  and non-markovian simulations in our case study.

the constraint programming approach
as we have seen, the its method requires to compute a solution for f  = r given a set of values for the constants of the density function. then, it generates a set of random values for τ sampled from equation , simulating for i-times the occurrence of a single-molecule enzymatic reaction, with parameters k <dig>  k <dig> and k <dig> . to solve these equations, we use the gecode library , a state-of-the-art framework for constraint programming including a real intervals constraint system . constraint systems are at the heart of constraint logic programming  <cit>  where problems are solved declaratively: one states the problem and a search engine searches automatically for a solution. in constraint programming, constraints are asserted by means of propagators that prune the domain of the variables through efficient techniques such as hull, box and kb−consistency , thus allowing for solving sets of interval constraints.

an interesting feature of this programming paradigm is that constraints represent relations between the variables rather than assignments to values. the function of the propagators is then to discard the values on the domain of the variables that are not part of any solution . let us explain this situation with a simple example. assume, for instance, three variables x <dig>  x <dig>  x <dig> with domains  , , , respectively. if we add the constraint x <dig> +x <dig> = x <dig>  the propagators implementing the relation between the expression "x <dig> + x2" and the right-hand side x <dig> will prune the domains of the three variables to assert that  +  = . hence, l <dig> ≥ l <dig> + l <dig> and u <dig> ≤ u <dig> + u <dig> 

rarely, propagation of constraints is enough to solve a constraint satisfaction problem. in our example, if x <dig> =  <cit> , x <dig> =  <cit>  and x <dig> =  <cit> , the propagators can only narrow the domain of x <dig> to  <cit>  by discarding the unfeasible values  <cit>   in the lower  part of the interval. at this point, when no further propagation is possible, the search engine chooses a variable x =  such that u − l is greater than a given precision e. then, the problem is split into two: one searching for a solution considering x =  where u/ <dig> is the mid-point. this is known in constraint programming as labelling or enumeration and leads to a depth-first search strategy.

the combination of constraint propagation and enumeration yields a complete solution method: all solutions generated are indeed solutions to the problem and, if a solution exists, the procedure will eventually find it. in our previous example, the domains  x <dig> =  <cit> , x <dig> =  <cit> , x <dig> =  <cit>  are one of the possible solutions for the constraint x <dig> + x <dig> = x <dig> 

now we show how to find a solution for equation  by using the constraint programming approach implemented in gecode. the main parts of the needed code are in figure  <dig> and explained below.

lines 2- <dig> include the required libraries from gecode. line  <dig> defines the class exp function as a subclass of the the gecode class script. hence, an instance of the class exp function can be used to solve our problem since this class actually defines the solver, i.e., the variables and the constraints needed.

the variables  are declared in line  <dig>  the required constants, i.e., the parameters of the function, are declared in line  <dig>  in lines 16- <dig> we declare the constructor of the class. the constructor takes as parameters the concentration  and the rates k <dig>  k <dig> and k <dig>  the first parameter opt is needed in gecode to determine the number of solutions that the solver must generate. lines 18- <dig> initialise the variables. note for instance that tau is a variable that can take any value greater than  <dig> . as we know, b ) cannot be positive and so this variable is initialised in the interval  = r. for instance, in line  <dig> we establish the relation between r and the rest of variables. as we already explained, such a relation allows us to both determine r given a τ and compute τ given some r . we note that we simply write the relations as the equations presented in the previous section by using the appropriate notation such as, for instance, sqrt to denote the square root and exp to denote the exponential function.

the labelling strategy is in line  <dig> where we specify that the variable tau is chosen for labelling and the values not greater than the mid-point are explored first.

it is worth mentioning some advantages of using constraint programming instead of classical numerical methods to solve f  = r. the most important one is that in constraint programming, interval arithmetic allows us to bound numeric errors appearing when doing calculations. such accuracy is the result of representing a real number by means of an interval  instead of a single floating-point number. hence, when a solution is found, we have a guarantee that the result is indeed a solution satisfying all the constraints. another advantage is that in constraint programming, it is possible to find all the solutions for a given set of constraints. moreover, due to the labelling process, the method is complete, i.e., if there is a solution, the solver eventually will find it. finally, in constraint solving no initial parameters for iteration are required .

implementation
now we are ready to show how to implement our technique to simulate biochemical reactions. the input of our tool is a biochemical system specified through a set of reactions having the generic:

  a1x1+…+anxn→kb1y1+…+bmym 

where the constants a <dig>  ..., an and b <dig>  ..., bm are the stoichiometric coefficients. k stands for the kinetic rate constant. therefore, a1x <dig>  ..., anxn are reactants that interact  yielding to the products b1y <dig>  ..., bmym. in addition, for each reaction we can define the corresponding pdf  that will be used to sample the duration of a particular reaction.

besides the parser which loads the input, the tool is composed by two main modules that work together. one module is invoked each time we want to compute a solution for f  = r. it takes as input the concentrations of the reactants, and a reaction; then it chooses the suitable pdf and it uses the constraint programming approach to compute the solution. the other module is the core engine of the tool:

it takes the value of τ for each reaction for which there are enough reactants in the system and then it chooses which reaction will take place, selecting the one with the smallest τ value. at this point, it simulates the designated reaction by consuming the reagents and adding to the system the products. after that, τ is added to the current time and it starts over again. in this way, given a set of reactions and a set of concentrations, we are able to simulate the evolution of the modelled system. the output of the tool is a list comprising a time stamp, the concentrations at that time, and the last reaction used.

RESULTS
to show how our method works we report on two experiments consisting of generating random samples of equation  and comparing the sampled data with the pdf used.

example  <dig>  consider the following set of parameters taken from  <cit> :

 a1:k1=107m-1s-1a2:k1=107m-1s-1a3:k1=107m-1s-1k2=250s-1k2=250s-1k2=250s-1k-1=0s-1k-1=50s-1k-1=2000s-1= <dig> mm= <dig> mm= <dig> mm 

by using the code in figure  <dig>  we obtained  <dig> samples of τ. the histogram of the resulting values and the plot of the equation  for the three sets of parameters is depicted in figure  <dig> 

the second example is used to illustrate how our method can be used for simulating reactions catalysed by single enzymes based on the parameters studied in  <cit> . that paper provides kinetic parameters referring to the enzyme β-lactamase which is present in bacteria such as s. aureus and e. coli. this enzyme hydrolyses benzylpenicillin so preserving the micro-organisms from being killed by this antibiotic. the kinetic parameters from  <cit>  are not measured from single-molecule assays but rather from traditional "ensemble" observations, in which reactants and enzymes are allowed to react in concentrations of the order of moles per litre. our aim is to verify whether our method, which satisfies the relation expressed in equation , can be used to perform simulations also using data coming from ensemble experiments which are the most frequently present in the literature.

example  <dig>  let us consider the following set of parameters reported in  <cit> :

 b1:k1=41μm-1s-1b2:k1=22μm-1s-1b3:k1=123μm-1s-1k2=1920s-1k2=62s-1k2=980s-1k-1=2320s-1k-1=196s-1k-1=11800s- <dig> 

we range  from  <dig>  to  <dig>  for each value of  we compute the average of  <dig> values for τ . in figure 5we show the plot of  vs 1τalong with the mm saturation curve obtained from equation .

as shown in figure  <dig> and confirmed by the good results of a fit test , the values of τ we obtained through our method are consistent with the underlying mm model which is represented in each figure together with the respective 1τ plot. these results, again, show that the technique we propose allows us to faithfully simulate in one step the occurrence of an enzymatic reaction directly using the data coming from the literature.

the method we have presented for sampling probabilistic distribution functions can be generally applied to other ones such as exponential  and erlang by using the same parameters reported in  <cit> .

example  <dig>  let f  = λ e−λτ for τ ≥  <dig> be an exponential pdf and f  =  <dig> − e−λτ be the corresponding cumulative distribution function. figure  <dig> shows the histogram of the occurrence of τ obtained with a gecode code similar to that in figure  <dig>  the parameter λ is set to  <dig> .

example  <dig>  let f  and f  be an erlang pdf  defined as:

 f=λkxk-1e-λx!f=1-∑n=0k-11n!e-λxn 

with the parameters k =  <dig> and λ =  <dig> . figure  <dig> shows the histogram of the occurrence of τ obtained with a gecode code similar to that in figure  <dig> 

now let us show how our method can be used to simulate a network of biochemical reactions.

example  <dig>  consider the following elementary reactions:

 a → b  a → c

initial concentrations are a =  <dig>  b =  <dig> and c =  <dig>  reaction  follows the pdf in equation  with parameters k <dig> =  <dig> , k <dig> =  <dig>  and k− <dig> =  <dig> . in reaction  τ is sampled from the exponential pdf f  = 10e−τ. the results are depicted in figure  <dig> 

comparing markovian and non-markovian simulations

in this section we analyse the differences emerging in describing the reaction set in equation  through two different ds models. in one case, we use an approach àla gillespie, lumping the reaction scheme in equation  into one s → p reaction. in this scenario, the occurrence of a reaction is seen as a single markov transition with the waiting time distributed accordingly to a negative exponential pdf. the propensity a = v is calculated from equation , as suggested in  <cit> . in the other case, we reduce the reaction scheme in equation  to a single s → p reaction but the waiting times are computed  according to equation , thus obtaining a non-markovian model.

as previously noticed, experimental evidence provided by studies on single molecule experiments suggests that the occurrence of a reaction catalysed by single enzymes when observed at the mesoscopic level  exhibits non-markovian dynamics. our aim here is to evaluate the impact of the approximation introduced by simulating single-molecule enzymatic reactions as a markov process through the gssa. to do this, we first compare the trend of the two pdfs for waiting times ) when the initial values of s , k <dig>  k− <dig> and k <dig> are varied. it can be noticed in figure  <dig> that the differences between the two pdfs mainly concern the low values of waiting times: according to the negative exponential pdf, waiting times close to zero have higher values of f , while accordingly to the pdf in equation  the higher values for f  are not close to zero. noticeably, these differences are greater when s <dig> is low and when k− <dig> is significantly less than k <dig>  this implies that, with respect to the experimental findings on single-molecule enzymatic reactions, the markovian approach introduces more approximations when the modelled system is composed of a low number of reactants and when the kinetic characteristics of the enzymatic reaction  prevent the system from quickly reaching the steady state.

to study the impact of the differences amongst pdfs on the dynamics of the system, we simulated the occurrence of single-enzyme catalysed reactions as single s → p markov or non-markov jumps. we compared the obtained results with the outputs of simulations performed describing the set of reactions in equation  through the gssa specifying each single step . as proposed in  <cit> , given the correctness of gssa, the full model can be used as a convenient benchmark for evaluating the precision of simulations against the mm model. as can be noticed in figure  <dig> , the results of our simulations fit the full model significantly better than the corresponding markovian approach. thus, our technique allows us to describe the considered enzymatic reaction as a single s → p step with an accuracy comparable to that of the full model.

comparison with other systems
in this section, we compare the computational cost of our method with respect to gillespie's direct method . our interest here is to consider only those implementations of gssa which provide exact solutions as our method does. thus, we will not consider approaches such as the tau-leaping  <cit>  that can be computationally less costly but provides approximate solutions of the cme. the other exact implementation of gssa, namely first reaction method , is known to be computationally more expensive than the dm and hence does not represent a good benchmark for our comparative tests. the same rationale applies also to gibson and bruck next reaction method which, in essence, is an optimisation of the frm and has been shown to have a worse performance than the so-called optimised direct method   <cit> .

we shall consider two different implementations of gillespie's dm:  an implementation in the package r of gssa as-it-is  and  an implementation of the odm provided by stochkit, a popular extensible of the algorithm as-it-is, provided by the "gillespiessa" package for the r suite  and  an implementation of gillespie's odm provided by stochkit, a popular extensible stochastic simulation framework developed in c++ . we choose gillespie's odm as representative of a group of methods, such as logarithmic direct method  <cit> , sorting direct method  <cit>  and a tailored version of a kinetic monte-carlo method  <cit> , which aim at optimising gillespie's dm through various heuristics that reduce the complexity of finding the next reaction to be fired. according to the literature, the computational performances of these methods are similar. hence, we chose to consider only the odm whose implementation in stochkit is well known and verified by the users.

comparing our approach with both a native and an optimised version of the dm will provide more complete information. the odm, in particular, increases the efficiency of the reaction-selection step in which the random number r is generated , which is a key bottleneck in the dm. this is done in the odm by pre-ordering the reactions so that those with larger propensity functions have smaller index values in the search list so that reactions occurring more frequently are higher up , thus reducing the search depth of the linear search. moreover, the odm only updates the propensity functions that change and a pre-simulation step is performed in order to ascertain the relative frequencies of each reaction.

in our comparative tests, we considered two different scenarios:  the mm reaction scheme;  a linear chain of reactions. all the simulations presented here were performed on an imac  <dig> ghz, with a quad-core intel core i <dig> and 8gb of ram. the data reported correspond to the average of executing the tests  <dig> times.

test set 1: the michaelis-menten reaction scheme
in the previous subsections we showed that, using our approach, we can safely lump the mm reaction scheme into one s → p reaction. we also showed that, for achieving the same accuracy exhibited by our method, the corresponding simulation a la gillespie must be performed considering explicitly all the reactions of the mm scheme . given these results, for analysing the computational cost of our approach, we performed a series of tests simulating the occurrence of enzymatically catalysed reactions. we assumed that the considered enzyme exhibits mm kinetics and thus we compared our method versus the corresponding full gillespie approach. our aim here is to show that our method allows us to safely lump the mm reaction scheme into a single s → p reaction without significant loss of computational efficiency.

we found that our method outperforms the corresponding gillespie approach when the reaction system becomes more stiff, i.e., the reaction rates will assume significantly different values spanning various orders of magnitude. to show this, we performed different tests, varying the value of the k <dig> parameter. as k <dig> takes lower values  the system becomes more stiff. for each value of k <dig>  we recorded the computational time and the number of iterations needed for obtaining  <dig> molecules of the product p , starting from  <dig> molecules of s and  <dig> molecules of e . the results of these tests are shown in table  <dig>  noticeably, our method outperforms the native r implementation for each one of the selected values of k <dig>  moreover, it turns out that when k <dig> becomes smaller our method outperforms also the stochkit implementation. this can be explained by the following facts. as the value of k <dig> decreases, the values of the sampled τ also decreases. hence, the simulation time needed to reach a given amount of the product  is greater. in our approach, the number of iterations for producing the  <dig> units remains the same since in each case  we always need to sample the pdf  <dig> times. on the contrary, gssa requires more iterations to deal with simulations where the simulated time is longer. hence, the computational time grows.

times in seconds reported correspond to the average of  <dig> runs. constants k <dig> and k <dig> were set to  <dig> and k <dig> varies as shown in the table. the initial concentrations of s and e were set to  <dig> and  <dig> molecules, respectively.

test set 2: a chain of reactions
in this test we aimed to investigate the variations of the computational effort needed for performing simulations when the number of reactions composing the system grows. to do this, we tested both our method and the stochkit implementation of the odm against simple systems composed of "chains" of chemical reactions, i.e., series of reactions in which the product of a given reaction becomes the reactant of the following. in each of our tests, the number of reactions composing the chain was increased by one. the smallest system comprised a single a → b reaction, while the largest system we considered comprised twenty reactions. in each simulation all the parameters, namely the rate constants and the initial amount of reactants were kept constant, allowing only the length of the "chain" to vary. the results are reported in table  <dig>  it turned out that our method scales better than stochkit when the number of reactions grows in the tests performed. moving from n to n +  <dig> reactions, in our case, implies that an extra value of τ for the new reaction must be computed. moreover, the linear search for the lowest value of τ needed in each iteration must consider an array of n +  <dig> positions. we note that stochkit is a more general tool than the one we are proposing here including, for instance, different simulation algorithms. hence, it could be the case that more complex data structures are involved. this may explain why by increasing the number of reactions we get a better performance than the one exhibited by stochkit for the set of experiments reported in table  <dig> 

in each case, the kinetic constants were set to  <dig> , the initial amount of each component is  <dig> molecules and the simulation time corresponds to  <dig> time-units.

CONCLUSIONS
in this paper, we presented a method for describing stochastic simulations of nonmarkovian processes. in particular, we used this method for sampling waiting times from general distributions and from a pdf inferred from wet-lab experiments regarding reactions catalysed by single-enzyme molecules. for this case-study, we provided a simulation algorithm which has some advantages over the corresponding markovian approach. specifically, it turned out to be more precise in those cases characterised by a low number of molecules and by a dynamics that makes the steady-state not quickly reachable. encouraged by these findings, we are planning to use our technique for performing case-specific discrete-state continuoustime non-markovian algorithms for sampling waiting times from experimentally inferred pdfs. moreover, we are currently embedding the algorithm proposed here in bioways  <cit> , our piece of software designed for modelling and simulating biochemical processes. another interesting issue for future work would be to study through our method how competition for enzymes by different reactions may affect the overall dynamics of the investigated system.

list of abbreviations
pdf: probability density function; ds: discrete stochastic; ctmp: continuous-time markov process; cdm: continuous deterministic modelling; ssa:  stochastic simulation algorithm; its: inverse transform sampling; cme: chemical master equation; rpdf: reaction probability density function; bwb: beta workbench; mm: michaelis-menten; odes: ordinary differential equations; odm: optimised direct mehod; dm: direct mehod.

competing interests
the authors declare that they have no competing interests.

authors' contributions
dc, mf, dh and co designed the framework. dh and dc selected the case studies, and discussed them with co, mf and lt. co and lt designed and implemented the software tools, discussing them with dc, mf and dh. all authors contributed to write the manuscript. all authors read and approved the final manuscript.

