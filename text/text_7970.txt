BACKGROUND
next-generation sequencing technologies  have dramatically reduced the per base cost of sequencing and, applied to metagenomics, have opened a new window into yet-uncultured organisms in the environment  <cit> . the ever-increasing rate of data generation, however, makes the processing and interpretation of large datasets increasingly expensive  <cit> . running blastx against the approximately  <dig> billion amino acid ncbi nonredundant protein database on  <dig> gbase of sequence requires approximately  <dig>   <cit>  cpu-hours. amazon on-demand extra-large ec <dig> instances at $ <dig> /hour put the computational cost of running blastx in the range of $ <dig> per gbase. by analyzing sequenced dna fragments and returning the coordinates and amino acid translations of orfs that are likely coding regions, gene prediction can reduce the computational burden of protein similarity searches in metagenomic datasets by nearly a factor of  <dig> 

ab initio gene prediction tools  are currently used in popular metagenomic annotation pipelines. methods for identifying genes in complete genomes  have been adapted for use on short fragments   <cit>  and metageneannotator   <cit> ). new algorithms have also been introduced, including orphelia   <cit> , fraggenescan   <cit> , and prodigal   <cit> . fgs is used in mg-rast  <cit> , fgs and metagene in camera  <cit> , metageneannotator  in the annotation pipeline at the j. craig venter institute   <cit> , genemark and mga in smashcommunity  <cit> , orphelia in comet  <cit> , and a combination of tools including prodigal, metagene, mgm, and fgs in img/m  <cit> . the downstream processing of shotgun sequences in these pipelines uses various approaches to identify predicted protein fragments. mg-rast uses blat against a protein database; camera uses blastn against reference genomes; the jcvi pipeline uses a combination of blastp and protein hidden markov models; comet uses a machine-learning-based classifier ufo; and img/m and smashcommunity use blastp. these all  take advantage of the fact that ab initio gene calling is computationally inexpensive compared with the protein annotation step.

table  <dig> lists the running times of the ab initio gene callers for  <dig> gbase of sequence data on an intel xeon 2 ghz linux server. performing nucleotide-to-protein similarity searches against the  <dig> billion amino acid nr database requires  <dig>  hours for blastx  <cit>  or approximately  <dig> hours for rapsearch  <cit> . a protein-only search would require an estimated  <dig> hours for blat  <cit> . even the slowest ab initio gene callers take no more than  <dig>  and  <dig>  hours to process  <dig> gbase. since the time to apply even the slowest gene callers is still much smaller than the time required for downstream annotation by database searching, gene prediction is unlikely to be the limiting step in analysis of protein sequences from shotgun sequencing.

compared with downstream analyses, ab initio gene calling is computationally inexpensive.

to be useful for large-scale sequence processing, gene callers must not utilize prior knowledge of the sequence environment—they must be one-size-fits all—and they must not require expensive computation such as a similarity search step. these requirements make self-training  <cit>  and homology-based  <cit>  gene callers suited for smaller-volume, higher-value annotation applications but not for raw reads.

the accuracy of gene prediction tools for short reads is limited by several factors, notably read lengths and sequencing errors. read lengths  are shorter than typical gene sizes  and may contain partial genes, gene boundaries, and sequencing errors. error can vary widely as a result of sample quality and composition, sequencing preparation methods, vendor technology, and sequencing hardware maintenance. vendor estimates of sequencing error range from  <dig>  to 4%  <cit> . further investigation suggests that the error range may be much higher  <cit> . while some fragments can capture entire short genes, in the regime where fragment lengths are shorter than typical gene sizes, most fragments will contain a single partial gene or fragments of two adjacent genes. achieving good prediction performance on the largest likely gene fragment is the desired behavior for a read annotation system, since the largest fragment is both the most valuable and the strongest evidenced.

previous studies have examined the accuracy of gene-calling algorithms to substitution errors typical for sanger sequencing in 700 bp fragments  <cit>  and the effect of insertion/deletion errors typical of roche 454-pyrosequencing   <cit> , and have compared subsets of the current gene-calling programs  <cit> . here we compare the performance of five gene-calling algorithms—fgs, mga, mgm, oph, and prd—in the presence of varying rates of simulated sequencing error  as well as their performance on “real” metagenomic datasets.

RESULTS
accuracy in simulated data across varying error and fragment length
detailed evaluation procedures are included in the methods and additional file  <dig> sections. in short, a single reading frame is identified at the center of each fragment as the “correct” reading frame if it is coding and the gene prediction tools are judged against this single correct answer for each read. the reading frame at the center of each fragment was calculated using the genome coordinates from which the fragment was taken and the genome coordinates of the first annotated gene overlapping the center of the fragment. fragments whose center was not included within a gene were labeled explicitly as "noncoding". thus each fragment was labeled with one of seven labels representing the "annotated reading frame". sensitivity is the ratio of correctly predicted coding fragments to fragments annotated as coding; specificity is the ratio of correctly annotated noncoding fragments to fragments annotated as noncoding; and overall accuracy is an incidence-weighted combination of the two, explained more fully in the methods section. unlike some prior evaluations, this work explicitly counts gene predictions in the wrong reading frame as errors and explicitly defines and counts true negative  predictions.

the overall accuracy of the five gene callers was determined on simulated shotgun sequences from fourteen prokaryotes as a function of fragment lengths between  <dig> and 1000 bp at four rates of artificially introduced insertion/deletion error . these error rates were selected for comparison with previous studies  <cit> . the overall accuracy is plotted against fragment length in figure  <dig> 

applied to error-free fragments, all the tools have similar accuracy, and all the gene callers become more accurate with longer fragments, increasing from 60–77% for 75 bp fragments to 93–96% for 1000 bp fragments. starting at insertion rates of  <dig> %, where most reads have at least one error, the gene callers other than fgs demonstrate decreasing accuracy with increasing length. for long  fragments containing errors, gene callers make predominantly false-negative mistakes, failing to predict genes where annotated genes are present. thus, current methods classify long, error-containing fragments as noncoding, most likely because of errors that induce frame shifts or generate spurious stop codons. this situation is problematic for metagenomic analysis because fragments that are incorrectly identified as noncoding are lost for further analysis.

for short fragments, the most common error is to call the gene on the reverse strand. chargaff’s rule for oligomers  <cit> , the observed similarity between the abundances of short nucleotide sequences and their reverse complements, may partly explain this type of error: this property makes the reverse complement of the correct frame have codon frequencies more similar to coding frames than other incorrect frames.

fraggenescan is more accurate than the other four methods at predicting the correct reading frame in fragments with error rates above  <dig> %. the differences in accuracy in the presence of errors are small for short  sequences but become as great as 25% for long  fragments with errors. orphelia, by contrast, showed lower overall accuracies than did the other four methods, particularly in the presence of substitution errors. prodigal showed poor performance for fragments shorter than 200 bp.

the overall accuracy, sensitivity, specificity, and positive predictive value figures for four previously published benchmark datasets with varying insertion/deletion rates are reported in table  <dig>  and for five datasets with varying substitution rates in additional file 2: table s <dig>  using the  <dig> % dataset as an example, fgs correctly labels only  <dig> % of noncoding sequences, whereas mga, mgm, and prodigal have specificities of  <dig> %,  <dig> %, and  <dig> %, respectively. the overall accuracy as a function of error rate for the benchmark datasets is plotted in additional file 3: figure s <dig>  showing that insertion and deletion errors cause loss of accuracy faster than do substitution errors, which do not alter the reading frame.

the relationship between sensitivity and the specificity at different thresholds for gene identification can be calculated for three of the gene callers  that give scores to each predicted gene, where lower false-positive rates can be explored by applying more stringent thresholds than default to the gene predictions. graphs of sensitivity vs. specificity   <cit>  are given in figure  <dig> for varying rates of introduced error, both insertion/deletion and substitution, these show a clear tradeoff in the choice of tools; for error-free data, prodigal and mga significantly outperform fgs, offering comparable sensitivity at lower false-positive rates. but at rates of  <dig> % insertion/deletion errors and  <dig> % substitution errors, prodigal and mga miss 40% of the genes that are present.

the better sensitivity of fgs in error-containing, short-read data comes at the cost of lower specificity—fgs is less able to recognize non-coding regions—and predictions of genes that are longer than the refseq annotations. fgs translates noncoding regions as coding and tries to correct pseudogenes by inferring frameshifts as erroneous insertions and deletions.

unlike the other four tools, fgs explicitly predicts probable insertion and deletions in individual fragments; these result in longer  predicted coding regions. the other methods report multiple predicted gene fragments when they find conflicting reading frame evidence. fgs, because of its algorithm, is forced to choose between overlapping potential genes and cannot issue overlapping predictions.

the contamination of predicted genes with nonsense protein sequence is an inevitable consequence of uncorrected sequencing errors, and the gene callers treat this issue in different ways. figure  <dig> shows an artificial fragment containing an insertion that disrupts gene calling and causes all of the gene callers to miss at least some of the correct amino acids. fraggenescan predicts the insertion in the wrong place, leading to seven out-of-frame peptides adjacent to the insertion. the other gene prediction tools do not attempt to predict insertions, and all either predict nonsense amino acids at the end of predicted gene <dig>  or miss most of the coding sequence . this illustrates the main consequence of the difference between fgs and the other tools—fgs’s predictions are longer, more sensitive, and contain more nonsense than those of the other tools.

it is in principle possible to infer the presence of frame shifts in the output of mga, mgm, and prodigal by recognizing adjacent or overlapping reading frames and guessing that a frameshift has occurred  <cit> . with additional evidence from an alignment to a reference sequence or model, the location of frame shifts can be positioned more precisely. this technique has been to correct frameshift errors in reads with alignments  <cit> .

coding fraction profiles on real metagenomic data
to investigate the behavior of the current generation of ab initio gene callers on real metagenomic data, we applied all five gene callers to three shotgun sequencing datasets that span three next-generation sequencing technologies in two medium-complexity metagenomic environments: one from cow rumen  <cit>  and two from distal human gut  <cit> .

the predicted coding fraction, defined here as the fraction of the reads at least n bases long that have the nth base contained within a predicted gene  <cit> , is plotted in figure  <dig> as a function of position in the read for these three datasets for each of the five gene callers. mga, mgm, orphelia, and prodigal all predict similar coding fractions for all the datasets, while fgs predicts higher coding fractions. all the programs predict high coding fractions  for the shortest  reads at 125 bp and smaller coding fractions for the longer   <dig> reads. a surprising result is that for the dataset generated by using the roche- <dig> pyrosequencing titanium platform, all the gene callers  predict a coding fraction that decreases from 80% at the beginning of the fragment to 50% at the modal sequence length of 500 bp. this result is consistent with the expectation that error rates increase with position in pyrosequencing reads  <cit> . this decreasing coding fraction suggests that sequencing errors may be disrupting the identification of genes near the end of the fragments. it is reasonable to expect that quality filtering  <cit>  and quality-aware read trimming  <cit>  before gene calling will improve accuracy of the predicted translations.

artificial datasets containing insertions and deletions did not have a pronounced change in the predicted coding fraction between the beginning and end of the reads except at the highest substitution error rate tested . additional file 3: figure s <dig> shows coding fraction profiles for benchmark datasets with known errors for comparison with the metagenomic datasets. since the datasets simulate shotgun data, the distribution of “real” annotated genes in the fragments is uniform over the fragment length. for longer  fragments with errors, mga and mgm show lower densities of predicted genes in the center of the fragment than at the ends, suggesting that the enumeration of open reading frames  results in biases in gene calling that depend on position within the read.

discussion
the exclusive use of sensitivity and positive predictive value   <cit>  in training and describing the accuracy of gene-calling tools has had unintended effects on their development  <cit> . current tools accurately identify noncoding regions but are poorly equipped to handle data containing sequencing errors, even at the relatively modest levels reported by technology vendors.

to quantify gene prediction accuracy, the gene detection literature has used sensitivity and specificity for whole genes  <cit> , reading-frame-aware sensitivity and specificity  <cit> , alignment-based sensitivity and ppv  <cit>  and amino acid sensitivity  <cit> . some of these metrics penalize false-positive and false-negative predictions essentially equally. we find that reading-frame-aware, prospective sensitivity agrees with amino acid sensitivity better than with per fragment alignment-based sensitivities on the same datasets.

the frequency and impact of inaccurate gene calls are relatively low in noncoding dna. combinations of sensitivity and specificity that weigh the errors according to their expected number are an effective way to gauge prediction accuracy while utilizing the assumption that most   <cit>  of the sequence in prokaryotic genomes is annotated as coding. such an expected-incidence combination was introduced as “prediction accuracy”  <cit> , but the testing dataset used was engineered to have specific gene boundaries and had only a 50% coding fraction as a result. when overall accuracy is used on datasets engineered to mimic shotgun data  <cit> , the results are close reflections of sensitivity.

the observation that at high error rates increasing fragment length does not improve gene prediction accuracy is instructive. sequencing errors, particularly frameshift errors, dilute the evidence for coding regions by spreading the signal among competing adjacent reading frames. since only bases without an interrupting error can contribute in the correct frame, increasing length will improve accuracy only until the length well exceeds the mean distance between errors, twice the reciprocal error rate. for fragment lengths below 100 bp and error rates above 2%, reading-frame prediction accuracy is poor. this argues against applying ab initio gene callers unless read error rates can be pushed below 2%. for the pacbio systems  <cit>  platform, which offers raw reads >3 kb at error rates of 15% and circular template corrected reads at 400 bp with error rates <1%, ab initio gene prediction can be expected to work on the corrected reads but fail on the uncorrected reads despite their length.

CONCLUSIONS
when annotating individual reads, sequencing errors cause a loss of predicted coding regions, leading to loss of signal. fraggenescan exhibits superior sensitivity in error-containing reads with respect to reading frame prediction, and tends to over-predict nonconcoding regions as nonsense. mgm, mga, and prodigal offer accurate predictions as long as reads are error-free. prodigal performs somewhat better than mgm and mga on error-free data.

the evaluation procedure for the algorithms to predict genes inevitably guides the future progress of gene prediction tools. treating reading-frame prediction as a binary classification problem leads to overestimation of the accuracy of the programs and tuning of these programs to accurately identify noncoding regions. for this reason, evaluation schemes that explicitly test reading frame and those that count aligned amino acids are preferred over methods that count only the number of alignments found.

sequencing technologies at present can produce multiple billions of reads as long as 250 bp  <cit> , a length regime where prokaryotic gene prediction accuracy is around 90%. protein annotation steps remain computationally expensive and stand to become even more so as the size of reference databases grow. ab initio gene calling trades accuracy for speed. the annotation pipelines for raw reads have taken this tradeoff—a factor-of- <dig> cheaper annotation in exchange for missing perhaps 10% of the genes that are there. it is likely that the experimenter’s choice of sequencing methods will be dominated by length limitations in other stages in the processing of metagenomic data, such as similarity searching, where fragments shorter than 400 bp show diminished sensitivity  <cit> .

