BACKGROUND
calculation of the distance and shortest sequence between chromosome structures
reconstruction of chromosome structures is considered based on the model of chromosome structure as an arbitrary set of paths and circles composed of vectors: genes denoted by the index i and paralogs of any gene i denoted by the index i.j. the model includes four operations transforming one structure into another referred to as standard as well as accessory operations deleting and inserting a chromosome region. detailed description of the model is given in the section “definition of the model of chromosome structure”. significant constraints were imposed on the model in  <cit>  and many other publications: constant gene content is provided in the sequence of transformations from one structure into another, paralogs are not allowed, operation weights are equal , etc.

if the weights are considered at the level of an exact algorithm, they should have a specific form considering the np-hardness of the considered problem. part “exact linear algorithm calculating the distance between chromosome structures” of this work proposes an almost linear algorithm transforming one chromosome structure into another working in the absence of all these constraints, although we had to impose a condition on the proportion between operation weights. this cannot be avoided owing to the np-hardness of the considered problem in general terms. the proposed proportion of weights differs from commonly accepted ones. the reconstruction of structures in part “reconstruction of chromosome structures for mitochondria of sporozoans and plastids of rhodophytic branch” had to rely on the proportion between the weights for which our algorithm is heuristic although close to exact.

the term almost appears due to the problem of paralogs, it is solved by means of linear programming, which is known to produce an exact solution within almost linear time .

although the algorithm proposed here conforms to the basic concept of the algorithm in  <cit> , it is radically more complex; while the exactness proof was essentially trivial for the algorithm in  <cit> , the exactness here is a kind of a theory. the current work introduces a sequence of lemmas constituting this proof, although certain details were given in  <cit> . the algorithm was implemented as a computer program available together with calculation samples, tests on artificial data, and the user manual at http://lab <dig> iitp.ru/en/chromoggl/.

computer-aided comparison of our algorithm with other heuristic ones is problematic, since the model of chromosome rearrangement at the level of generalization used here was considered only in  to our knowledge. these publications offer no program implementation. it should be noted that a computer implementation in the absence of the insertion and deletion operations as well as the operation weights was presented in  <cit> ; however, this is far from our case.

let us recall that an algorithm is exact if it was proved that it always produces the minimum corresponding functional; in this case, the minimum total weight for the sequence of operations transforming one chromosome structure into another. here we use a slightly relaxed version of this: our algorithm produces the sequence with the total weight differing from the minimum by a fixed additive quantity d, for example  <dig>  . one more concern pertinent to the algorithm exactness is discussed in the beginning of part “algorithm for the reconstruction of chromosome structures with cubic complexity and sufficient approximation ratio” the solution produced by the algorithm can differ from the minimum by a multiplicative value k, for example  <dig>  apparently, an algorithm with such complexity can distort the tree topology . a linear algorithm has linear computation time over the input size and uses linear space.

reconstruction of chromosome structures
as part “exact linear algorithm calculating the distance between chromosome structures” shows, a matrix of pairwise distances can be easily generated for a given set of chromosome structures. phylogenetic tree with the best conformity with this matrix is required. this means that the distance between any two leaves along the tree is the closest to the corresponding distance in the matrix; the residual is determined for each pair of leaves as the difference between these distances. since this problem is np-hard, a tree with an a priori unknown conformity with the matrix is generated.

many popular algorithms for tree reconstruction require more informative input such as an alignment of nucleotide or amino acid sequences. widely used sophisticated reconstruction programs  use a linear form of the reconstructed object and are, apparently, inapplicable in our case. for chromosome structures, a simple algorithm based on the conformity with the distance matrix rapidly generates their evolutionary tree. the data and results described in part “reconstruction of chromosome structures for mitochondria of sporozoans and plastids of rhodophytic branch” demonstrate that this algorithm outputs sensible trees for mitochondria and plastids. the algorithm is given at the same page http://lab <dig> iitp.ru/en/chromoggl/. basically, it is a upgma variant, but neighbor joining or other algorithm proficient in bringing into conformity with the distance matrix can be used instead.

part “algorithm for the reconstruction of chromosome structures with cubic complexity and sufficient approximation ratio” considers the natural problem of reconstructing chromosome structures in internal nodes of a phylogenetic tree from the chromosome structures specified in its leaves using the tree generated by the algorithm or an existing one.

backing away the problem of chromosome structures, for species the algorithms reconstructing evolutionary scenarios with cubic computational complexity are given in  <cit> . a similar problem for regulatory systems is considered, e.g., in  <cit> . actually, to our knowledge, many heuristic algorithms but few exact algorithms with low  polynomial complexity were proposed for the reconstruction of objects specified in the leaves. this specifically applies to the problem of chromosome structure reconstruction using the model defined in the section “definition of the model of chromosome structure”.

arrangement is a function that assigns a chromosome structure to each node of the tree; hereafter, a node and an object assigned to it are synonymous. the functional defined for all arrangements  or also for all trees with specified leaves amounts to the total distance between edge ends for all edges. in this case, the breakpoint and biological distances are considered; the latter essentially is also the edit distance between two structures, and thus is an analog of pairwise sequence alignment.

we recall that the breakpoint distance is the number of gene extremity pairs that are adjacent  in one structure and not neighboring or missing in the other plus the number of genes that are present in one structure and absent in the other. the biological distance between structures is the minimum total weight for the sequence of operations transforming one structure into the other; all operations are a priori given individual weights. the calculation of the distances is also discussed in the sections “calculation of the breakpoint and biological distances for structures with paralogs” and “calculation of biological distance with paths present”.

let us recall that the considered structures can have any number of linear and circular chromosomes, variable gene content, and paralogs; all operations, both standard and accessory, as well as any operation weights are allowed.

it has been proven that the result of the algorithm described in part “algorithm for the reconstruction of chromosome structures with cubic complexity and sufficient approximation ratio” falls within the  segment, where a is the absolute minimum and k is a small approximation ratio. algorithms with such a property are called approximate algorithms. part “exact linear algorithm calculating the distance between chromosome structures” and  sets the coefficient k equal to  <dig>  while in part “algorithm for the reconstruction of chromosome structures with cubic complexity and sufficient approximation ratio” it equals  <dig> or 11/ <dig>  these cases are fundamentally different from heuristic algorithms, whose results are in unknown relation to the minimum  solution. moreover, even the convergence of the computational process has not been confirmed for many heuristic algorithms, and it is terminated following a not substantiated rule. in practical terms, the approximation ratio of  <dig> can give rise to inadequate trees. this difficulty is concerned for our data in part “reconstruction of chromosome structures for mitochondria of sporozoans and plastids of rhodophytic branch”.

part “algorithm for the reconstruction of chromosome structures with cubic complexity and sufficient approximation ratio” follows the work in  <cit>  presenting an algorithm of reconstruction for 0– <dig> sequences. it is readily applicable to biological sequences. to our knowledge, reconstruction of chromosome structures within the frames of the model described in the section “definition of the model of chromosome structure” has never been considered as an exact problem or realized as a computer program.

thus, the problem in part “algorithm for the reconstruction of chromosome structures with cubic complexity and sufficient approximation ratio” is as follows. we are given m chromosome structures. it is required to find a binary tree t with m leaves and the given structures assigned to them as well as the arrangement of structures at all internal nodes with the minimum total distance between edge ends for all edges. this sum is called the weight of tree t or the weight of the corresponding arrangement.

the case of a non-binary tree is similar to that of a binary one and presents no new difficulties. the same holds true for the case of an unrooted tree.

finally, part “reconstruction of chromosome structures for mitochondria of sporozoans and plastids of rhodophytic branch” illustrates the algorithms described in parts “exact linear algorithm calculating the distance between chromosome structures” and “algorithm for the reconstruction of chromosome structures with cubic complexity and sufficient approximation ratio” and one more algorithm proposed in  <cit>  by generating phylogenetic trees and reconstructing chromosome structures of mitochondria in sporozoans and plastids of rhodophytic branch. the test on artificial data is available at http://lab <dig> iitp.ru/en/chromoggl/.

results of most relevant works
let us briefly review the background of the algorithm in part “exact linear algorithm calculating the distance between chromosome structures”. following the work by david sankoff  <cit> , pavel pevzner  and many other researchers addressed the distance problem associated with models of chromosome structures; thousands of papers, books, and lecture courses concerning this problem are available. analysis of the research in the field deserves a separate extensive survey accounting for fine distinctions between the studied models. let us consider several publications most relevant to our work. yancopoulos et al.  <cit>  proposed a set of operations to transform chromosome structures; here they are called standard and are included in our set of operations. this work presents an algorithm to calculate the shortest distance between structures composed of paths only ; the algorithm computation time tends to linear but was not explicitly evaluated. these operations applicable only to paths correspond to inversion, translocation, fusion, and fission operations defined in  <cit> . the distance problem for linear chromosomes only was solved in  <cit> . the general case for the same gene content and the same operation weights was solved in  <cit> . the case of different gene content requires extra operations, deletion and insertion of special gene loci, which were defined in  <cit> .

the adjacency graph is used in  <cit> : its nodes are adjacent extremities of genes that belong to both structures as well as extremities of the initial paths. such nodes are connected by an edge if they include the same gene. in addition, the path extremity is considered as connected to a telomere . a region with genes that belong to a single structure  can reside between adjacent extremities of common genes; such genes are assigned to the corresponding node. such graph clearly differs from the common graph defined here. the algorithms computing the shortest sequence transforming one structure into another using the same operations as in our work proposed in  <cit>  have a linear running time. all operation weights equal  <dig> in  <cit> , while the standard operation weights equal  <dig> and the weights of deletions and insertions are the same and do not exceed  <dig> in  <cit> . it remains unclear if the algorithms from these works can be related to our algorithm. the proof that the algorithms in  <cit>  are exact is not available to us, and the accompanying notes give no necessary details.

the same model as in our work is considered in  <cit> . it proposes a linear algorithm that relies on the addition of special genes to both initial structures providing that the operation weights are the same. thus, the problem is reduced to the case with the same gene content, and the total number of genes increases by k+t, were k and t are the numbers of special genes in the initial structures. the used graph includes an additional pair of extremities for each special gene, which increases their graph relative to that used in our algorithm. the graph and the algorithm differ from those proposed below. the proof that their algorithm is exact is not available to us, and the accompanying considerations give no necessary details.

compeau  <cit>  describes the generalization of the algorithm in  <cit>  for the case when all chromosomes are circular, standard operation weights equal  <dig>  and the weights of deletions and insertions are the same. the proof of the algorithm exactness as well as the proper description of the algorithm need to be described in full.

methods, 
RESULTS
exact linear algorithm calculating the distance between chromosome structures
definition of the model of chromosome structure
the model of chromosome structure is described as a finite set of paths and circles with directed edges including loops. such set can be considered as a directed graph referred to as a chromosome structure. the graph edge represents a gene; an individual graph path or circle represents a chromosome. each gene is denoted by name, usually by number i, which can be repeated  and takes the form i.j. as usual, this model disregards the lengths of genes and intergenic regions as well as their content. the edge direction indicates the strand on which the gene is located. graph node connects adjacent genes irrespective of their orientation, i.e., it identifies  two extremities of adjacent genes. usual structures include many paths and circles, which leads to a sort of interaction between them. that is why the cases with many chromosomes in their structure are in marked contrast with those with a single chromosome.

the model includes operations over a chromosome structure; first four of them given in  <cit>  will be referred to as standard. let us recall their definitions. double-cut-and-paste is cutting two pairs of adjacent gene extremities and cut-and-pasting four extremities, which gives rise to a new structure. sesqui-cut-and-paste is cutting two adjacent extremities and joining one extremity to an unconnected extremity so that the other extremity remains free. cut-and-join is cutting two adjacent extremities resulting in two free extremities or, vice versa, joining two free extremities.

we are given chromosome structures a and b; a gene that belongs to both structures is called a common gene, while a gene that belongs to one structure only is a special one; an a-gene belongs to structure a; and a b-gene, to structure b. let us introduce two accessory operations that transform a into b: deletion of a  region of special a-genes and insertion of a region of special b-genes.

if the deleted region was strictly within a path or circle, the resulting free extremities of common genes are joined; if the region terminated the path, the common gene extremity becomes free; if the region was a separate chromosome, it is naturally deleted. if a  region is inserted strictly inside a path or circle, the insertion point is cut, which is not a separate operation; insertion can occur into a path end or as a new chromosome. it is easy to prove that deletions of non-longest  regions of special a-genes do not decrease the distance between structures. similarly, cutting within special a-regions, insertion of special b-genes into a special a-region, and double- and sesqui-cut-and-paste operations resulting in cutting a region of special a-genes and its circularization can also be excluded from the first three operations. such “unnatural” operation variants are not allowed.

thus, six operations are given and each of them is assigned a positive rational number referred to as its weight. the inclusion of weights is the key point of the model. the objective is to find the shortest sequence of these operations that transform structure a into structure b. naturally, the shortest sequence has the minimum total weight of all its operations. each operation in the sequence is considered together with the chromosome structure to which it is applied.

reduction of the problem of paralogs to linear programming
for brevity, let us denote structures with paralogs as “par-structures” and structures without paralogs as “structures.” the distance between two par-structures is defined as the minimum distance between structures resulting from a bijection between paralogs of every gene present in both initial par-structures. specifically, gene i from both par-structures a and b can have a different number of paralogs that belong to sets Ра and Рb, respectively. let fi be the bijection between parts of sets Ра and Рb; i.j indices are found for all paralogs in Ра and Рb, for which fi is the identity function; all paralogs not included in the function fi domain and range have different indices. of course, the parts have no repetitive indices. the numbering has natural interpretation: if y = fi, y is “inherited” from x; other paralogs from Ра and Рb are independent mutually different genes, and thus they have different j indices. paralogs that do not belong to the domain and range of fi are considered as lost and emerged, respectively . now the distance between a and b is defined as the minimum distance between a’ and b’, which are derived from a and b for all specified indices of paralogs from par-structures a and b.

the calculation of the distance between par-structures is initially reduced to integer linear programming , which is known to give an exact solution with close to linear time and memory complexity for random data . this special property of linear, integer, and boolean programming is formulated as an almost linear algorithm; it is considered in numerous publications and is not discussed here. thus, the solution found by ilp specifies a set of bijections {fi |i} between paralogs. then arbitrary indices of paralogs corresponding under these bijections are selected; the result does not depend on index selection. finally, the algorithm described in the section “definition of the common graph and its final form” is applied to calculate the distance between the obtained structures a’ and b’. the reduction to ilp is described in the sections “calculation of the breakpoint and biological distances for structures with paralogs” and “calculation of biological distance with paths present”.

since the algorithm presented below is linear, the calculation of the distance between par-structures becomes almost linear. the exactness is still observed. thus, one can assume the absence of paralogs in the remainder of part “exact linear algorithm calculating the distance between chromosome structures”.

definition of the common graph and its final form
in the common graph a+b of two structures a and b, the nodes are extremities of common genes as well as all longest continuous regions of special genes; each extremity is taken once. in more formal terms, gene extremities are assigned the gene name with indices  <dig> and  <dig> for its beginning and end, respectively. nodes of the first and second types are referred to as conventional and special, respectively. an edge connects two conventional nodes if the extremities are adjacent in one of structures, i.e., neighbor each other on the chromosome. an edge connects conventional and special nodes if an extremity of the common gene is adjacent to a marginal gene in a region of special genes. the edges in the first and second cases are called conventional and special, respectively. the marginal edge with a special end in a path from a+b is referred to as hanging. edges are denoted a or b depending on the structure where joining occurred; nodes can be connected by double edges. special nodes are denoted a- or b-nodes depending on the source structure. a graph can contain isolated nodes – regions of special genes. if such region is a circle in the initial structure, a loop called special is added to the node. this yields an undirected graph referred to as a+b.

analogs of five operations over structures can be applied to the common graph a+b as follows .  delete two non-incident edges with the same index and connect four resulting ends by two new non-incident edges with the same index.  delete an edge  and connect one of its ends with a conventional node non-incident to the a-edge or with a special a-node with no more than one incident a-edge.  delete any edge.  use an edge  to connect nodes each of which is a conventional and non-incident to the a-edge or a special a-edge with no more than one incident a-edge. if an operation results in two incident special nodes, they are merged ; the resulting node is given a name combining those of initial nodes.  delete a special node or a special loop. if this node had two conventional nodes incident to it, they are connected with an edge. an analog of the sixth operation, insertion, is easy to define; however, it turns out that it can be omitted without loss of generality. this is a not trivial statement; see the beginning of the section “calculating the distance between structures”.

the final form of the common graph a+b is defined as a common graph consisting of isolated conventional nodes and final 2-circles. the latter is defined as a graph of two conventional nodes connected by conventional edges, one from a and one from b. it is easy to show that the initial objective is equivalent to transforming the graph a+b into the final form with certain constraints on operation weights, in particular, when operations other than insertion and deletion have the same weight.

calculating the distance between structures
let us recall that this section assumes the absence of paralogs but all operations, different gene content, and any operation weights are allowed. a common graph a+b is trivially constructed from initial structures a and b. the algorithm goal is to transform a+b into the final form. let us denote the length of a path or circle by the number of internal special nodes plus the number of conventional edges. for instance, a 2-circle is a circle of length  <dig> 

having the same framework, the algorithm depends on the proportions between operation weights, which are fixed in advance. the algorithm is the following.step  <dig>  delete all special a-loops.

step  <dig>  cut out a conventional edge not included in a 2-circle and close it into the final 2-circle using a double-  or a sesqui-cut-and-paste  or a join  operation. repeat the operation if possible. if the double-cut-and-paste weight does not exceed that of sesqui-cut-and-paste, all double operations are performed first; otherwise, all sesqui operations go first. figures shown in # <dig> section of additional materials can be helpful for understanding the algorithm flow.

let us explain steps  <dig> and  <dig> prior to their formal description. step  <dig> uses operations transforming certain combinations of two, three, or four paths into a single path. each operation applied decrements the number of special nodes by  <dig>  the combinations are specified by the type of a path or circle, which is defined below. step  <dig> is used if the deletion of a b-node has a higher weight compared to all other operations. the current set of paths and circles is split into pairs, joint processing of which replaces the deletion of a b-node with a lower weight cut-and-paste operation joining two b-nodes; the total number of operations remains unaltered. we have demonstrated that the sequence procedures specified below in steps  <dig> and  <dig> provide for the optimal result.

let us define the types. a path is referred to as odd and even if its length is odd and even, respectively. a-path denotes an isolated b-node or an odd path where extreme non-hanging edges marked as a; b-path is defined symmetrically. the paths and circles remaining after steps  <dig> and  <dig>  are assigned the following types: a-circle, for a 2-circle containing an a-node but not a b-node; b-circle, vice versa; circle, for a circle including both a- and b-nodes; loop, for a special b-loop.

a-paths are assigned to the following types: 1а if the path has a single hanging edge; 2а, if it has two hanging edges; 2a’, if it is an isolated special b-node; 3а, if it has no hanging edges but has both a- and b-nodes ; and 3a’, if there are neither hanging edges nor b-nodes. b-path types are defined in a similar way. even paths are assigned to the following types:  <dig>  if the path has a single hanging edge and a b-node; 1', if it has one conventional node and one special a-node incident to it; 1" if it has one conventional node and one special b-node incident to it;  <dig>  if it has two hanging edges and a non-hanging edge; 2', if it has only two hanging edges; and  <dig>  if it has only non-hanging edges. type  <dig> is subdivided into types 1a and 1b if the extreme special node is an a-node and b-node, respectively. type 2a is a combination of types 2a and 2a’; type 3b, 3b and 3b’; type 1b, 1b and 1″ and type  <dig>   <dig> and 2'.

let us introduce a special type 1c corresponding to a deferred choice between path types 1a and 1b, which are possible results of the operation. the algorithm stores both results up to steps  <dig> – <dig>  when a decision on either of two results is made, and thus the whole sequence of operations becomes unambiguously defined.

in the description of step  <dig> below, a combination of path types  on the left of ‘=’ is transformed into a combination of path types on the right of ‘=’. the resulting combination omits isolated conventional nodes and final 2-circles; no type is assigned to them. hereafter, if a substep includes several equations, actions of the first one are described; other substeps are analogous.

step  <dig>  the algorithm performs the actions described below; each action is repeated as long as it is applicable. figures in # <dig> section of additional materials can be helpful. <dig> . 1a + 1b = 1c. cut an extreme non-hanging edge in one of two paths of types 1a and 1b and join the corresponding special node with the extreme special node of the other path .

 <dig> . 2a + 3b = 1b, 2b + 3a = 1a, 2b’ + 3a = 1a, 2b + 3a’ = 1a, and 2b’ + 3a’ = 1'. cut an external edge in the 3b-path and join the special node with the extreme special node of the 2a-path.

 <dig> . 2 + 3 = 1c. cut an external edge in the 3-path and join the special node with the extreme special node of the 2-path. this results in a path of type 1a or 1b depending on which of two external edges was cut.

 <dig> . 1b + 2a + 3 = 2 + 3 = 1c, 1a + 2b + 3 = 2 + 3 = 1c, and 1a + 2b’ + 3 = 2 + 3 = 1c. first carry out the 1b + 2a =  <dig> operation  and then the 2 + 3 = 1c one.

 <dig> . 1a + 3b + 2 = 3 + 2 = 1c, 1b + 3a + 2 = 3 + 2 = 1c, and 1b + 3a’ + 2 = 3 + 2 = 1c. first carry out the 1a + 3b =  <dig> operation  and then the 2 + 3 = 1c one.

 <dig> . 1a + 2 = 2a and 1b + 2 = 2b. cut an external edge in the 1a-path and join the special node with the extreme special node of the 2-path.

 <dig> . 1a + 3 = 3a and 1b + 3 = 3b. cut an external b-edge in the 3-path and join the special node with the extreme special node in the 1a-path.

 <dig> . 1a + 1a + 2b + 3b = 2 + 3 = 1c, 1a + 1a + 2b’ + 3b = 2 + 3 = 1c, 1b + 1b + 2a + 3a = 2 + 3 = 1c, and 1b + 1b + 2a + 3a’ = 2 + 3 = 1c. first carry out the 1a + 2b =  <dig> and 1a + 3b =  <dig> operations; then the 2 + 3 = 1c one.

 <dig> . 1a + 1a + 2b = 3a + 2b = 1a, 1a + 1a + 2b’ = 3a + 2b’ = 1a, and 1b + 1b + 2a = 3b + 2a = 1b. first carry out the 1a + 1a = 3a operation ; then 2b + 3a = 1a one.

 <dig> . 1a + 1a + 3b = 1a + 3 = 3a, 1b + 1b + 3a = 1b + 3 = 3b, and 1b + 1b + 3a’ = 1b + 3 = 3b. first carry out the 1a + 3b =  <dig> operation; then the 1a + 3 = 3a one.

 <dig> . 1a + 1a = 3a and 1b + 1b = 3b. join the extreme special nodes of two 1a-paths.

 <dig> . 1a + 2b =  <dig>  1a + 2b’ =  <dig>  and 1b + 2a =  <dig>  cut an external edge in the 1a-path and join the special node with the extreme special node of the 2b-path.

 <dig> . 1a + 3b =  <dig>  1b + 3a =  <dig>  and 1b + 3a’ =  <dig>  cut an external edge in the 3b-path and join the special node with the extreme special node of the 1a-path.

 <dig> . 2a + 2b + 3 + 3 = 2 + 3 = 1c and 2a + 2b’ + 3 + 3 = 2 + 3 = 1c. first carry out the 2a + 2b + 3 =  <dig> operation ; then the 2 + 3 = 1c one.

 <dig> . 3a + 3b + 2 + 2 = 3 + 2 = 1c and 3a’ + 3b + 2 + 2 = 3 + 2 = 1c. first carry out the 3a + 3b + 2 =  <dig> operation; then the 2 + 3 = 1c one.

 <dig> . 2a + 3 + 3 = 1a + 3 = 3a, 2b + 3 + 3 = 1b + 3 = 3b, and 2b’ + 3 + 3 = 1b + 3 = 3b. first carry out the 2a + 3 = 1a operation; then the 1a + 3 = 3a one.

 <dig> . 3b + 2 + 2 = 1b + 2 = 2b, 3a + 2 + 2 = 1a + 2 = 2a, and 3a’ + 2 + 2 = 1a + 2 = 2a. first carry out the 3b + 2 = 1b operation; then the 1b + 2 = 2b one.

 <dig> . 2a + 2b + 3 = 2a + 1b =  <dig> and 2a + 2b’ + 3 = 2a + 1b =  <dig>  first carry out the 2b + 3 = 1b operation; then the 1b + 2a =  <dig> one.

 <dig> . 3a + 3b + 2 = 3a + 1b =  <dig> and 3a’ + 3b + 2 = 3a’ + 1b =  <dig>  first carry out the 3b + 2 = 1b operation; then the 1b + 3a =  <dig> one.



step  <dig>  if the weight of double-cut-and-paste is greater than that of sesqui-cut-and-paste, actions  <dig> – <dig>  are sequentially performed whenever possible; otherwise actions  <dig> '– <dig> ' specified when they differ from the corresponding actions  <dig> – <dig>  are performed. figures in # <dig> section of additional materials illustrating all actions can be helpful. <dig> . “loop” + any type t with a b-node = type t. join the b-node of the loop with the b-node of t-type chromosome by double-cut-and-paste  or by sesqui-cut-and-paste .

 <dig> . “circle” + any type t with a b-node and an a-node = type t. insert the circle  near the b-node from t-type chromosome on the side of the a-node; cut out the resulting conventional edge.

 <dig> . 2a + 2b = 2 + 1'. perform the sesqui-cut-and-paste with cutting out two 2b-path nodes  and joining the resulting extremity with the extreme special b-node of the 2a-path.

 <dig> '. 2a’ + 2b = 2 + 1'.

 <dig> . 3a + 3b =  <dig>  cut an external edge in the 3a-path and join the special node with the extreme conventional node of the 3b-path.

 <dig> '. 3a + 3b’ =  <dig> 

 <dig> . 2a + 3 = 1a and 2b + 3 = 1b. cut an external b-edge in the 3-path and join the special node with the extreme special node of the 2a-path.

 <dig> '. 2a’ + 3 = 1a.

 <dig> . 3a + 2 = 1a and 3b + 2 = 1b. cut an external edge in the 3a-path and join the special node with the extreme special node of the 2-path.

 <dig> '. 3a + 2' = 1a and 3b’ + 2 = 1b.

 <dig> '. join the extreme special nodes of the two paths.

 <dig> . 2a’ + 2a = 2a.

 <dig> . 3a + 3a = 3a and 3b + 3b = 3b. connect two extreme conventional nodes of the paths by a conventional edge, and then cut out this edge.

 <dig> '. 3b’ + 3b = 3b.

 <dig> . 1a + 2a = 1a and 1b + 2b = 1b. connect the extreme special nodes of the two paths.

 <dig> '. 1a + 2a’ = 1a.

 <dig> . 1a + 3a = 1a and 1b + 3b = 1b. connect two extreme conventional nodes of the paths by a conventional edge, and then cut out this edge.

 <dig> '. 1b + 3b’ = 1b.

 <dig> . 2a + 2 =  <dig> and 2b + 2 =  <dig>  connect the extreme special nodes of the two paths.

 <dig> '. 2a’ + 2 =  <dig>  2a + 2' =  <dig>  and 2b + 2' =  <dig> 

 <dig> . 3a + 3 =  <dig> and 3b + 3 =  <dig>  connect two extreme conventional nodes of the paths by a conventional edge, and then cut out this edge.

 <dig> '. 3b’ + 3 =  <dig> 

 <dig> . 2 + 2 = 2 + 1'. perform the sesqui-cut-and-paste operation with cutting out two nodes of the 2-path  and joining the resulting terminus with the extreme special b-node of the other 2-path.

 <dig> '. 2' + 2 = 2 + 1'.

 <dig> . 3 + 3 =  <dig>  cut an external a-edge in the 3-path and join the resulting extremity with the b-extremity of the other 3-path.

 <dig> '. null action.

 <dig> . 1a + 1a = 1a, 1b + 1b = 1b, and 1b + 1c = 1b . cut an external non-hanging edge in the 1a-path and join the special node with the extreme special node of the other 1a-path.

 <dig> '. 1" + 1b = 1b and 1" + 1c = 1b .

 <dig> . 1a + 1b = 1a, 1b + 1a = 1b, and 1a + 1c = 1a . cut an external non-hanging edge in the 1b-path and join the special node with the extreme special node of the 1a-path.

 <dig> '. 1a + 1" = 1a.

 <dig> . 1a + 1a = 1a, 1b + 1b = 1b, and 1b + 1с = 1b . cut an external edge in the 1a-path and join the special node with the extreme special node of the 1a-path.

 <dig> '. 1b + 1" = 1b.

 <dig> . 2a + 1b = 2a, 2b + 1a = 2b, and 2a + 1c = 2a . cut an external non-hanging edge in the 1b-path and join the special node with the extreme special node of the 2a-path.

 <dig> '. 2a’ + 1b = 2a, 2a + 1″ = 2a, and 2a’ + 1c = 2a .

 <dig> . 3a + 1a = 3a, 3b + 1b = 3b, and 3b + 1c = 3b . cut an external edge in the 3a-path and join the special node with the extreme special node of the 1a-path.

 <dig> '. 3b’ + 1b = 3b, 3b + 1" = 3b, and 3b’ + 1c = 3b .

 <dig> . 2 + 1a =  <dig>  2 + 1b =  <dig>  and 2 + 1c =  <dig> . cut an external non-hanging edge in the 1a-path and join the special node with the extreme special node of the 2-path.

 <dig> '. 2' + 1a =  <dig>  2' + 1b =  <dig>  2 + 1" =  <dig>  and 2' + 1c =  <dig> .

 <dig> . 3 + 1a =  <dig>  3 + 1b =  <dig>  and 3 + 1c =  <dig> . cut an external edge in the 3-path and join the special node with the extreme special node of the 1a-path.

 <dig> '. 3 + 1" =  <dig> 

 <dig> . 1a + 1c = 1a , 1b + 1c = 1b , 1a + 1с = 1a , 2b + 1c = 2b , and 3a + 1c = 3a .

 <dig> '. null action.

 <dig> . for the remaining paths of type 1c, set c = b and perform the 1b + 1b = 1b operation.

 <dig> '. null action.

 <dig> . paths with a non-hanging edge are closed into circles by joining , sesqui-cut-and-paste with merging the special nodes  or without it . set c = b after closing a path of type 1c. when closing a path of type  <dig>  select the variant with merging two b-nodes and delete the a-node from the resulting path of type 1'. cut out conventional edges from the circles resulting from closing paths of type 3a or 3b. then execute step  <dig>  again.



step  <dig>  delete isolated special nodes and loops. delete special notes from the remaining paths. cut out 2-circles from circles longer than  <dig> so that two b-nodes merge . delete special nodes from 2-circles.



proof of the algorithm exactness
clearly, the time and memory complexity of the algorithm are linear. its exactness is demonstrated using the following sequence of lemmas 1– <dig> and the constraint presented in the following subsection; certain details can be found in  <cit> .

for initial structures a and b, the shortest sequence of operations transforming a into b is referred to as the shortest sequence.there exists the shortest sequence with no operations that include cutting a region of a-special genes. this is proved by induction on the weight of such sequence.

there exists the shortest sequence subject to the previous condition where all deletions precede all insertions. accordingly, the common graph transformation into the final form can be done without the insertion operation. this is proved by displacement of all operations decreasing the number of special nodes to the beginning of the sequence.

the sequence of operations specified in step  <dig> provides the greatest possible saving in the number of operations relative to processing each path individually. this is proved by induction on actions in step 3: the resulting sequence can be continued upon the completion of each action as long as such saving remains possible. thereafter, the path or circle is called a component.

after an action in step  <dig> is executed, it cannot be applied again , i.e., further actions do not introduce any components to which this action can be applied. this is proved by enumerating actions in step  <dig> 

after step  <dig>  there are  <dig>   <dig>  or  <dig> components with a b-node excluding the initial circles with a b-node but no a-node. this is proved by contradiction: if there were more than two such components, they would be subject to one of actions in step  <dig>  which contradicts the previous lemma.

the sequence of actions specified in step  <dig> provides for the greatest possible number  of replacements of high-weight b-node deletion operation with another one. this follows from the previous lemma and from the opportunity to transform any component with b-nodes into the final form using a sequence containing exactly one operation of b-node deletion.

the total weight c of a sequence of operations generated by the algorithm is derived from readily calculated properties of the initial common graph. namely, c = b + s + d–p + ε, where b is the number of special nodes, s is the sum of integer parts of half-lengths of the longest regions composed of conventional edges plus the number of such boundary regions of odd length minus the number of such circular regions, d is the number of operations not decreasing the number of special nodes that are required for the transformation of odd chromosomes individually into the final form excluding the operations in step  <dig> , p is the number of operations saved in step  <dig>  ε is the weight of b-node deletion minus  <dig>  b’ is the number of circles with a b-node but with no a-nodes, and n is  <dig>   <dig>  or  <dig> 

induction on the total weight m of the shortest sequence is used to prove that c = m. inductive step: for any operation o applied to any common graph g, its weight is at least c–c), where c is defined for a given g as in the previous lemma. this is proved by enumerating all operations and types of paths and circles to which they are applied.



condition for the exactness of the algorithm and operation weight values
in practical computations we considered two weight patterns referred to as circular and linear applied to plastids and mitochondria, respectively. when passing from a to b, the patterns are defined by any inexact descent in operation weights in the following order. circular pattern: b-node deletion, sesqui-cut-and-paste, a-edge insertion or b-edge deletion, double-cut-and-paste, and a-node deletion. linear pattern: b-node deletion, double-cut-and-paste, sesqui-cut-and-paste, a-edge deletion or b-edge insertion, and a-node deletion. the sequence of transformations from a to b has the minimum length when the length is minimal among all possible sequences of transformations from a to b.

the proposed algorithm is exact in two cases:  when the given structures have the same gene content and the weight pattern is cyclic or linear  and  when inequality d≤c ≤2d is satisfied for the weight c of b-node deletion and identical weights d of other operations.

in case , the total weight for the sequence of operations generated by the above algorithm differs from the total weight of the shortest sequence by no more than d; this uncertainty stems from the accuracy to  <dig> to which the number of operation replacements is maximized at step  <dig> 

in the case of arbitrary weights in the range from  <dig>  to  <dig> , which we actually used, the algorithm becomes heuristic although the deflection of its result from the minimum solution is no more than  <dig>  times according to our tests .

part “reconstruction of chromosome structures for mitochondria of sporozoans and plastids of rhodophytic branch” considers circular and linear patterns of operation weights with the following weight values :  <dig> ,  <dig> ,  <dig> ,  <dig>   <dig> , and  <dig> . clearly, computations for other weight values and routine analysis of the obtained results are of interest; however, this will generate an enormous volume of data.

algorithm simulation example
let us consider structures a and b shown in fig.  <dig> fig.  <dig> two chromosome structures



figure  <dig> shows the sequence of structures and operations generated by the algorithm to transform the common graph a+b of structures a and b shown in fig.  <dig> into the final form.fig.  <dig> sequence of structures and operations generated by the algorithm for the example shown in fig. 1




the algorithm generates this sequence for any operation weights. this sequence is the shortest for linear weights with the total weight of  <dig> . for circular weights, this sequence is not the shortest; its total weight is  <dig> , while that of operations shown in fig.  <dig> is  <dig> .fig.  <dig> shortest sequence of structures and operations in the case of circular weights for the example shown in fig. 1




algorithm for the reconstruction of chromosome structures with cubic complexity and sufficient approximation ratio
approximate algorithms solving the reconstruction problem with the approximation ratio of  <dig> and 11/ <dig> have been developed for the breakpoint and biological distances between chromosome structures. the two developed algorithms have a cubic and a quintic polynomial complexities, respectively. these two algorithms and the respective proofs are presented below. let n be the total number of genes  in a given set of m structures.

just as alon et al.  <cit> , we reduce the reconstruction problem to the minimum steiner tree problem. let us remind it. given an undirected graph g with non-negative numbers  assigned to its edges; m nodes of the graph called terminals are fixed. it is necessary to find a connected tree s  in g that includes all terminals and has the minimum sum of numbers assigned to all edges in s. this sum is called the weight of tree s.

in order to solve the reconstruction problem, let us consider g as a complete graph of all chromosome structures with no more than n genes, where each edge is assigned the distance between two structures at its ends. the nodes corresponding to m given structures will be taken as terminals. the following lemma establishes a correspondence between the reconstruction problem and the steiner problem for the specified g.

lemma
any solution t of the reconstruction problem with linear complexity can be transformed into a solution s of the steiner problem, and the weight of s is no more than the weight of t. any solution s of the steiner problem with the same complexity can be transformed into a solution  of the reconstruction problem, and the weight of t is no more than the weight of s.

proof
forward. let us join every set of t-nodes with identical labels into a single node. eliminate circles, e.g., by generating any spanning tree in the derived graph, and the result is isomorphically embedded in g.

backward. if there is a node of degree  <dig> in s, let us take it as a root; otherwise let us add a root node to one edge and assign a structure of one of its ends to it. let us add an incident edge to each terminal non-leaf node in s with the same structure at the end, which gives us a leaf in t; this ensures that all given structures are present in the leaves of t. to generate the proper t, let us remove non-terminal leaves in s together with edges incident to them and non-root nodes of degree  <dig>  and then join the edges. each non-binary node is arbitrarily binarized, and the structure assigned to it is assigned to new nodes. this gives us a binary tree t with the weight not exceeding that of s.

two algorithms are known to solve the steiner problem, and each of them can be transformed to solve the reconstruction problem.

the first algorithm solving the reconstruction problem for structures without paralogs
this algorithm is faster but has the approximation ratio of  <dig> owing to the corresponding solution of the steiner problem  <cit> . the second one is slower but has the approximation ratio of 11/6; it is considered in the section “the second algorithm solving the reconstruction problem for structures without paralogs” below.

let us recall the first algorithm solving the steiner problem. it generates the complete graph g’, whose nodes are m given terminals, and each edge  is labeled by the length of the shortest path between u and v in the initial graph g. a minimum spanning tree is generated for g’. each edge in it is replaced with some shortest path in g. the circles are eliminated by removing the edges, and the resulting tree is the solution of the steiner problem. the approximation ratio of the algorithm is  <dig>  i.e., the weight of the solution differs from the minimum one by a factor of no more than  <dig> 

our first algorithm operates on the graph g that was used in the lemma. it has a number of nodes exponential in n, but it does not have to be processed completely: only m chromosomal structures are needed. indeed, it follows from the triangle inequality that the shortest path between the vertices in g is the edge connecting them. accordingly, plotting the graph g’ is equivalent to computing a distance matrix for initial m structures. considering that the computation of the breakpoint distance between structures without paralogs has a linear complexity on the size of structures, the matrix can be computed in nm <dig> steps. the minimum spanning tree in a graph with m nodes is generated using the prim’s algorithm in m <dig> steps. thus, the proposed algorithm has the complexity of nm <dig> and the approximation ratio of  <dig> 

the biological distance between structures a and b is asymmetrical, i.e., the distance from a to b can be not equal to the distance from b to a. thus, hereafter, biological distance denotes the mean of these two distances. all properties of biological distance specified above remain unaltered in this case. if an edge to which structures a and b are assigned is directed, i.e., the edge is in a rooted tree and a is closer to the root, the biological distance for the edge is computed from a to b and is called the one-way biological distance.

according to our data , the computation of the biological distance between structures without paralogs also has a linear complexity. consequently, our first algorithm and the conclusions concerning it remain unaltered for the biological distance.

calculation of the breakpoint and biological distances for structures with paralogs
if there are paralogs and the breakpoint distance is considered, its computation is reduced to a boolean linear programming as implemented in the reconstruction of chromosome structures along the tree in  <cit> . in this case, the tree includes a single edge with chromosome structures at its ends. from this, the algorithm complexity is easy to evaluate; the approximation ratio remains unaltered.

assume that there are paralogs and the biological distance is considered. let us show how its computation can be reduced to integer linear programming if all chromosomes are circular and operation weights are equal. the first limitation is lifted in the following section, while the second one remains in effect through the end of this part “algorithm for the reconstruction of chromosome structures with cubic complexity and sufficient approximation ratio”.

hence, the common graph includes only circles, and the length of the shortest path equals b+s1–s <dig>  where b is the number of blocks  in the common graph, s <dig> is the sum of integer parts of half of lengths of maximum  regions  composed of conventional edges, and s <dig> is the number of circles composed of conventional edges  <cit> . the following reduction to the specified programming is used to compute the summands b, s <dig>  and s <dig>  we will call a pair of adjacent gene extremities an adjacent pair.

let a and b be two given chromosomal structures. let us define a boolean variable zkij; it equals  <dig> if paralog i of gene k in structure a corresponds to paralog j of the same gene k in structure b, otherwise it equals  <dig>  the constraints for these variables are that the sums of variables over the third index are no more than  <dig> for any fixed k and i .calculation of b. each adjacent pair s in structure a is described by a boolean variable xas; it equals  <dig> if this pair is at the border of an a-block, otherwise it equals  <dig>  a similar description holds for structure b. the respective constraints are that if an extremity of paralog i <dig> of gene k is adjacent to an extremity of paralog i <dig> of gene l in s, then xas≥∑jzki1j−∑jzli2j and xas≥∑jzli2j−∑jzki1j; similar inequalities hold for pairs in b. these inequalities mean that if ∑jzki1j and ∑jzli2j are not equal, i.e., a common and a special genes are adjacent in s, then xas =  <dig> 

let us define the minimized function as f= <dig> ⋅∑sxas+xbs+…, where other summands are described below. if ∑jzki1j equals ∑jzli2j, then xas =  <dig>  since xas and xbs are summands of f with the positive coefficient. each block is assigned two boundary variables so that the sum of xas and xbs with coefficient of  <dig>  equals b.

calculation of s <dig>  each adjacent pair s in structure a is described by a boolean variable yas; it equals  <dig> if this pair is at the border or within a block. a similar description holds for structure b. for adjacent pairs of common genes, variables yas and ybs take on alternating values of  <dig> and  <dig> within each region of conventional edges, and this alternation starts from  <dig> at one of borders. let us describe the constraints.

two adjacent pairs are defined as potential neighbors  if they belong to different structures and include the same extremity of paralogs of the same gene. the following constraints are imposed for any potentially neighboring s <dig>  and s <dig> : yas1≤4−zkij−∑jzk1i1j−∑jzk2ji2−ybs <dig> and ybs2≥zkij+∑jzk1i1j+∑jzk2ji2−2−yas <dig>  where paralog i of gene k is adjacent to paralog i <dig> of gene k <dig> in s <dig>  and paralog j of gene k is adjacent to paralog i <dig> of gene k <dig> in s <dig>  these inequalities mean that the values of yas and ybs alternate at each region of conventional edges.

let us continue the definition: f=⋯+∑s+⋯, where other summands are described above and below. at the borders of regions with odd length composed of conventional edges as well as within or at the borders of a block, variables yas and ybs equal  <dig>  since they are summands of f with the positive coefficient. thus, the sum of all variables yas and ybs equals s <dig> 

calculation of s <dig>  each adjacent pair s in structures a and b is described by an integer  variable us limited by the inequality us ≤ ms, where ms takes values from  <dig> to the total number of adjacent pairs in a and b. let us also introduce a boolean variable ps limited by the inequality psms ≤ us, which indicates whether us takes the  value of ms.



let us continue the definition: f=…−∑sps, where other summands are described above; ps variables are terms of f with the negative coefficient; hence, if us equals ms, then ps =  <dig>  let us add the constraints for each adjacent pair s with a paralog i of gene k in a: us≤ms∑jzkij as well as similar constraints us≤ms∑jzkji for adjacent pairs in b. these inequalities ensure that us =  <dig> if s is within or at the border of a block. let us add the constraints for any potentially neighboring adjacent pairs s <dig> in a and s <dig> in b: us1 ≤ us2 + ms1∙ and us2 ≤ us1 + ms2∙, where s <dig> includes paralog i of gene k and s <dig> includes paralog j of gene k. these inequalities ensure that us1 = us <dig> for two neighboring edges s <dig> and s <dig> of the common graph. accordingly, variables us take the same value, and exactly one of these variables reaches its maximum for each circle of conventional edges. for circles that contain blocks, these variables equal zero so neither of them reaches its maximum. thus, the number of variables us that reach their maximum  equals s <dig> 

let us evaluate the number of variables and the number of limitations by an example: let each structure include genes with numbers from  <dig> to  <dig> and each gene has  <dig> paralogs; thus, each structure has  <dig> genes. then the number of variables zkij is  <dig> and there are  <dig> constraints for them. the number of variables xas does not exceed  <dig> and there are no more than  <dig> constraints for them. the same is true for xbs. the total number of variables yas and ybs does not exceed  <dig> and there are no more than  <dig> constraints for them. the total number of variables us and ps does not exceed  <dig> and there are no more than  <dig> constraints for them. overall, no more than  <dig> variables and no more than  <dig> constraints are introduced, so that the volume of data can be processed by integer linear programming packages. in particular, such task is executed by the lomonosov supercomputer at moscow state university.

calculation of biological distance with paths present
if structures a and b include paths in addition to circles, the following approximate  algorithm is used. let us close all paths in a into circles; the resulting structure will be referred to as a’. apply the above algorithm to calculate the distance between structures a’ and b’. the obtained distance added to the total number of paths in a and b is the algorithm output, which should be close to the distance between the initial a and b.

let us evaluate the accuracy of this algorithm. suppose n <dig> and n <dig> are the numbers of paths in a and b, respectively; while t and t’ are the minimum numbers of operations to transform a into b and a’ into b’, respectively. it follows from the triangle inequality that n1 + t + n2 ≥ t’ and n1 + t’ + n2 ≥ t, then t’ ≤ n1 + n2 + t and n1 + t’ + n2 ≤ t +  <dig>  the number of operations that the algorithm needs exceeds the minimum number of operations by no more than  <dig> 

remark
martinez et al.  <cit>  presented the calculation of the biological distance between two chromosome structures when chromosomal deletions and insertions are not allowed. it is reduced to integer linear programming, and it is assumed that two structures can have different gene content but special genes are ignored after bijections fi are established between paralogs. each pair of paralogs k.i and k.j of gene k from different structures is given a similarity value s, which ranges from  <dig> to  <dig>  the minimized function is augmented with a penalty for incomplete similarity between paralogs, which equals the sum of 1–s for all pairs of paralogs k.i and k.j with established bijections. paralogs can correspond to each other only if the similarity between them is strictly positive, and there are no two free  paralogs with a positive similarity. in our terms, these ideas can be easily realized by supplementing f with the sum of zkij∙) for all pairs of paralogs k.i and k.j, and by adding the constraints that zkij =  <dig> if s =  <dig> and that ∑j'zkij'+∑i'zki'j≥ <dig> if s >  <dig> 

the second algorithm solving the reconstruction problem for structures without paralogs
essentially, it is the zelikovsky’s algorithm, which has the approximation ratio of 11/ <dig>  <cit>  as completely proved elsewhere  <cit> . first, recall the zelikovsky’s algorithm. for an arbitrary graph g, define t as the weight of minimum spanning tree in it, and g is a graph derived from g by zeroing the numbers on any two out of three edges connecting the nodes that belong to z, where z is a set of three nodes in g.step  <dig>  build a complete graph g’ where m given terminals are the nodes and each edge  is labeled by the length of the shortest path from u to v in graph g.

step  <dig>  for each triplet z = {a,b,c} of different terminals in graph g, a node v with the minimum sum d of labels on edges , , and  is sought.

an empty set a is defined.

step  <dig>  it is required to find triplet z of terminals with the maximum value of w = t–t–d. if w ≤  <dig>  then go to step  <dig>  otherwise take graph g’ as g’, add node v to a, and return to step  <dig> 

step  <dig>  build a complete graph g” that extends g’. its nodes include m given terminals and all nodes from a, and each edge  is labeled by the shortest distance from u to v in graph g. a minimum spanning tree is generated in g”. each edge in it is replaced with some shortest path in graph g. circles are eliminated by removing edges; and the resulting tree is a solution of the steiner problem.



let us follow these steps to describe our algorithm solving the reconstruction problem for the breakpoint distance. the distance matrix is computed at steps  <dig> and  <dig>  at step  <dig>  the structure v is generated and d is calculated using our algorithm  <cit> , which arranges chromosome structures at the ancestral nodes of the given tree to minimize the sum of breakpoint distances between structures for all edges of the tree. namely, it is applied to the tree with three leaves originating from a common ancestor . the structures from the triplet z are identified among leaves. the structure v is assigned to the root. the time of calculation of v and d for a single triplet z is linear in n  <cit> .

let us evaluate the maximum cardinality of the set a that does not exceed the maximum number of iterations at step  <dig> and also evaluate the number of these iterations.

it is easy to show that if graph g <dig> is produced from graph g <dig> by zeroing the label at edge e, the minimum spanning tree t <dig> for g <dig> can be derived from the minimum spanning tree t <dig> for g <dig> in the following way. if e belongs to t <dig> or already has a zero label, then t2 = t <dig>  otherwise, let us consider the only circle in t1 + e, select the edge e’ with the greatest label, and replace the edge e’ with e in t <dig>  which gives us the tree t2; this circle is identified by depth-first traversal of t <dig> within time linear in m. at each iteration, the labels of two edges of the graph are zeroed, and at least one of these edges has a positive label . thus, each iteration adds at least one edge to the spanning tree of graph g’, which remains there until the end of step  <dig>  since the number of edges in the spanning tree does not exceed the number of nodes m, |a| ≤ m and the number of iterations does not exceed m.

each next spanning tree is derived from the previous one by edge replacement described above. consequently, we have the following estimates of the proposed algorithm complexity: nm <dig> at step  <dig>  nm <dig> at step  <dig>  m <dig> at step  <dig>  and nm <dig> at step  <dig>  the total complexity evaluates to m3∙max. since the modification concerned the way how steps are taken but not their results, the approximation ratio of 11/ <dig> is preserved.

if the biological distance is used instead of the breakpoint one, steps  <dig> and  <dig> are executed in the same manner due to our linear algorithm calculating the distance between two structures; step  <dig> also remains unaltered.

in this case, a problem emerges at step  <dig>  we are unaware of an exact polynomial algorithm finding structure d for structures a, b, and c with the minimum sum of distances between d and these structures even for the same gene content. that is why the node v and the value d are calculated heuristically, which makes the whole algorithm heuristic. this is the first heuristic algorithm proposed in this paper. specifically, the shortest path of operations is found to transform a into b and to transform every intermediate structure into c. symmetry operations are executed for pairs  and . the structure with the minimum total distance to a, b, and c is chosen as d among all encountered structures.

the case of paralogs
for the breakpoint distance, the problem of searching the node v as well as the problem of calculating the distance between two structures is reduced to the problem of boolean linear programming in a manner similar to reconstruction of chromosome structures along the tree  <cit> . in the present case, the tree consists of three edges going from the root, and chromosome structures a, b, and c are assigned to the leaves. the algorithm generates the ancestral structure v in the root.

for the biological distance, the problem of searching the node v becomes more complex. the result obtained for the breakpoint distance can be improved by local rearrangements using the descent algorithm in  <cit> . but we start from the exact breakpoint decision  <cit> .

to our knowledge, these are the first algorithms with such exactness and polynomial complexity. the test on artificial data is available at http://lab <dig> iitp.ru/en/chromoggl/.

reconstruction of chromosome structures for mitochondria of sporozoans and plastids of rhodophytic branch
this part illustrates the algorithms from parts “exact linear algorithm calculating the distance between chromosome structures” and “algorithm for the reconstruction of chromosome structures with cubic complexity and sufficient approximation ratio” as well as the descent algorithm from  <cit>  using the data on mitochondrial and plastid chromosome structures. the algorithm from part “exact linear algorithm calculating the distance between chromosome structures” works adequately with any data, while the algorithm from part “algorithm for the reconstruction of chromosome structures with cubic complexity and sufficient approximation ratio” presumably does not always give the correct answer with complex data. this can be attributed to the twofold difference from the minimum solution, which can distort the tree topology in some cases. we used the descent algorithm mentioned above as an alternative to the algorithm from part “algorithm for the reconstruction of chromosome structures with cubic complexity and sufficient approximation ratio”. it is of interest that, despite the absence of many usual tools , these algorithms generate sensible reconstructions. we considered relatively close mitochondrial genomes as an example of simple data; and quite distant plastid genomes with intricate organization, as complex data.

let us recall the descent algorithm from  <cit> . an evolutionary tree is generated based on its similarity to the matrix of pairwise distances as described in the beginning of the section “reconstruction of chromosome structures”. the proper reconstruction first finds the arrangement of chromosome structures at internal nodes of the generated tree with the minimum sum f of breakpoint distances between the structures at the edge ends for all edges. this is performed using the exact algorithm described in detail in  <cit> , in the absence of paralogs. boolean linear programming is used in the presence of paralogs  <cit> . then, the obtained arrangement is sequentially improved with reference to the biological distance. namely, all operations applicable to a given structure assigned to an internal tree node are searched through to find the operation and structure that provide for the greatest decrease in the sum  g of biological distances between structures at the edge ends, and the result replaces the initial structure at the node. this yields the next arrangement. the process is repeated until the sum g reaches the minimum, and the algorithm outputs the final arrangement. its computer implementation is available at http://lab <dig> iitp.ru/en/chromoggl/.

in the case of paralogs, their coordination among all edges is used for the calculation of tree distance as well as for tree reconstruction.

protein clustering algorithm and data
all data were obtained from genbank. proteins were clustered using the algorithm described elsewhere  with the parameters e =  <dig> , l =  <dig>  and h =  <dig> . orthology of genes was determined from thus obtained clustering. the database of plastid and mitochondrial protein clusters is available at http://lab <dig> iitp.ru/ppc/redline67/. genome compositions were checked by blast alignments and rfam database search.

the evolution of mitochondrial chromosome structure was studied in the sporozoan class aconoidasida composed of subclasses haemosporida and piroplasmida . here, even closely related species can have linear and circular chromosomes . no paralogs were found in the considered mitochondria.table  <dig> mitochondrial chromosome structures in the class aconoidasida

leucocytozoon fringillinarum

leucocytozoon majoris

leucocytozoon sabrazesi

plasmodium berghei

plasmodium falciparum

plasmodium floridense

plasmodium fragile

plasmodium gallinaceum

plasmodium juxtanucleare

plasmodium knowlesi

plasmodium mexicanum

plasmodium reichenowi

plasmodium relictum

plasmodium simium

plasmodium vivax
babesia bovis

theileria parva

theileria annulata
circular and linear chromosomes are marked by c and l, respectively. everywhere in the list of genes asterisk indicates the complementary strand relative to that specified in genbank. the rightmost column shows the gene order using standard gene names



the analyzed  <dig> species with rhodophytic plastids are listed in table  <dig>  in the analysis of the evolution of plastid chromosomal structure, the genes available in many species and encoding proteins with a certain function were used: chaperone clpc; subunits of photosystem i psaa, psab, psac, psad, psae, psaf, psai, psaj, psak, psal, and psam; subunits of photosystem ii psb <dig>  psb <dig>  psba, psbb, psbc, psbd, psbe, psbf, psbh, psbi, psbj, psbk, psbl, psbn, psbt, psbv, psbx, psby, and psbz; rubisco large subunit rbcl; rna polymerase subunits rpoa, rpob, rpoc <dig>  rpoc <dig>  and rpoz; ribosomal proteins rpl <dig>  rpl <dig>  rpl <dig> rpl <dig>  rpl <dig>  rpl <dig>  rpl <dig>  rpl <dig>  rpl <dig>  rpl <dig>  rpl <dig>  rpl <dig>  rpl <dig>  rpl <dig>  rpl <dig>  rpl <dig>  rpl <dig>  rpl <dig>  rpl <dig>  rpl <dig>  rpl <dig>  rpl <dig>  rpl <dig>  rpl <dig>  rpl <dig>  rpl <dig>  rpl <dig>  rpl <dig>  rps <dig>  rps <dig>  rps <dig>  rps <dig>  rps <dig>  rps <dig>  rps <dig>  rps <dig>  rps <dig>  rps <dig>  rps <dig>  rps <dig>  rps <dig>  rps <dig>  rps <dig>  rps <dig>  rps <dig>  rps <dig>  and rps19; and elongation factor tufa. paralogs of the psby gene can be found in odontella sinensis, phaeodactylum tricornutum, thalassiosira pseudonana, thalassiosira oceanica, ulnaria acus, asterionella formosa, asterionellopsis glacialis, didymosphenia geminata, lithodesmium undulatum, eunotia naegelii, chaetoceros simplex, roundia cardiophora, cerataulina daemon, and thalassiosira weissflogii. paralogs of the clpc gene can be found in theileria parva, babesia bovis, chromera velia, thalassiosira oceanica, nannochloropsis gaditana, nannochloropsis granulata, nannochloropsis oculata, nannochloropsis salina, nannochloropsis limnetica, nannochloropsis oceanica, and rhizosolenia imbricata. consecutive paralogs of the rpoc <dig> can be found in theileria parva, leucocytozoon caulleryi, and plasmodium chabaudi. in rhizosolenia imbricata, a long duplication includes the psba, psac, rps <dig>  clpc, rps <dig>  rps <dig>  and rps <dig> genes. notice formal errors in gene names in genbank annotations: rpo instead of proС <dig> in nannochloropsis gaditana, rpoc instead of proС <dig> in cyanidioschyzon merolae, and rpoС2-n-terminal instead of proС <dig> in babesia bovis.table  <dig> analyzed  <dig> species with rhodophytic plastids

asterionella formosa
asterionellopsis glacialis
aureococcus anophagefferens
aureoumbra lagunensis
babesia bovis t2bo
calliarthron tuberculosum
cerataulina daemon
chaetoceros simplex
chondrus crispus
choreocolax polysiphoniae
chromera velia
chromerida sp. rm11
coscinodiscus radiatus
cryptomonas paramecium
cyanidioschyzon merolae strain 10d
cyanidium caldarium
cylindrotheca closterium
didymosphenia geminata
durinskia baltica
ectocarpus siliculosus
eimeria tenella strain penn state
emiliania huxleyi
eunotia naegelii
fistulifera solaris
fucus vesiculosus
galdieria sulphuraria
gracilaria salicornia
gracilaria tenuistipitata var. liui
grateloupia taiwanensis
guillardia theta
heterosigma akashiwo
kryptoperidinium foliaceum
lepidodinium chlorophorum
leptocylindrus danicus
leucocytozoon caulleryi
lithodesmium undulatum
nannochloropsis gaditana
nannochloropsis granulata
nannochloropsis limnetica
nannochloropsis oceanica
nannochloropsis oculata
nannochloropsis salina
odontella sinensis
pavlova lutheri
phaeocystis antarctica
phaeocystis globosa
phaeodactylum tricornutum
plasmodium chabaudi chabaudi
porphyra purpurea
porphyridium purpureum
pyropia haitanensis
pyropia perforata
pyropia yezoensis
rhizosolenia imbricata
rhodomonas salina
roundia cardiophora
saccharina japonica
thalassiosira oceanica ccmp1005
thalassiosira pseudonana
thalassiosira weissflogii
theileria parva strain muguga
toxoplasma gondii rh
trachydiscus minutus
ulnaria acus
vaucheria litorea
vertebrata lanosa
#prot, number of plastid-encoded proteins in the species; #clust, number of clusters containing at least one from the species and one out of the species; and #sing, number of plastid-encoded proteins from the species not included in any cluster



evolution and reconstruction of mitochondrial structures in sporozoans
the reconstructions of chromosome structures of mitochondria in sporozoan class aconoidasida were generated using the biological distance from data shown in table  <dig> 

the tree shown in fig.  <dig> was generated by the descent algorithm. it consists of two clades including mitochondria of piroplasmids  and haemosporids , respectively. two genera plasmodium and leucocytozoon cannot be resolved on the tree, in particular, due to the presence of linear and circular mitochondrial dna in both of them.fig.  <dig> the tree of chromosome structures of mitochondria in sporozoan class aconoidasida generated by the descent algorithm. 



the phylogenetic reconstruction generated by the descent algorithm of mitochondrial chromosome structures in aconoidasida is shown in table  <dig> table  <dig> phylogenetic reconstruction of mitochondrial chromosome structures in sporozoan class aconoidasida


plasmodium fragile – babesia bovis

theileria annulata – babesia bovis

theileria annulata – theileria parva




plasmodium fragile – plasmodium berghei

plasmodium juxtanucleare – plasmodium berghei

plasmodium juxtanucleare – leucocytozoon sabrazesi

plasmodium juxtanucleare – plasmodium gallinaceum





plasmodium fragile – plasmodium relictum

plasmodium reichenowi – plasmodium relictum

plasmodium floridense – plasmodium relictum



plasmodium reichenowi – plasmodium mexicanum

plasmodium reichenowi – plasmodium falciparum




plasmodium fragile – plasmodium simium

plasmodium fragile – leucocytozoon fringillinarum

plasmodium fragile – plasmodium vivax

plasmodium fragile – plasmodium knowlesi

plasmodium fragile – leucocytozoon majoris






reconstruction was generated by the descent algorithm for the tree in fig.  <dig>  circular and linear chromosomes are marked by c and l, respectively. the left column shows a non-leaf tree node by the first and the last leaves. the right column shows the chromosome structure in the node . the leaves are labelled by , only their chromosomal structures are feeded to the input of our algorithm



for mitochondria, the algorithm from the section “the first algorithm solving the reconstruction problem for structures without paralogs” generated a valid unrooted non-binary tree shown in fig.  <dig>  the leaves with the same structures generated by the same algorithm were combined into a single leaf. namely, the leaves of plasmodium vivax, leucocytozoon majoris, plasmodium fragile, and plasmodium knowlesi are represented by the former ; the same applies to the leaves of plasmodium falciparum, plasmodium reichenowi, and plasmodium mexicanum as well as of leucocytozoon sabrazesi, plasmodium juxtanucleare, plasmodium gallinaceum, and plasmodium berghei. the tree was rooted at the node to provide the best tree as the total one-way distance along all directions from the root to edges. the proper reconstruction generated by the same algorithm is shown in table  <dig>  thus, both algorithms reconstructed identical evolutionary scenario of chromosome structures.fig.  <dig> the tree of chromosome structures of mitochondria in sporozoan class aconoidasida. the tree was generated by the algorithm from the section “the first algorithm solving the reconstruction problem for structures without paralogs”. 


theileria parva –leucocytozoon sabrazesi

theileria parva–theileria annulata





plasmodium falciparum–plasmodium vivax

plasmodium falciparum–plasmodium floridense




leucocytozoon fringillinarum–plasmodium vivax



reconstruction was generated by the algorithm from the section “the first algorithm solving the reconstruction problem for structures without paralogs” for the tree in fig. 5




evolution of chromosome structures in plastids of rhodophytic branch
the tree  generated by the algorithm from the sections “calculation of the breakpoint and biological distances for structures with paralogs” and “calculation of biological distance with paths present” for the data shown in table  <dig> is not reasonable. this can be attributed to the twofold difference between the weights of trees reconstructed by this algorithm and the minimum tree.

the tree of plastids generated by the descent algorithm is shown in fig.  <dig>  and it seems quite possible. we discuss it below.fig.  <dig> tree of chromosomal structures of rhodophytic plastids generated by the descent algorithm. the data were obtained from genbank for chromosomes listed in table  <dig>  the chromosome structures that were fed to our algorithm are shown in additional file  <dig>  # <dig>  tables s3a–s3b in rows denoted by . 



this tree is in good agreement with previously published data, in particular, with the corresponding trees of species. the most significant distinctions are special tree positions of photosynthetic alveolate chromera velia and rhodophytic alga porphyridium purpureum, whose order of genes substantially differs from that in related species. this has been mentioned previously in the study of the moeb gene regulation  <cit> . a separate clade was formed by plastids of the nannochloropsis genus, which constitute an isolated portion of the large stramenopiles phylum  <cit> .

all diatoms composed a large clade also including certain stramenopiles as well as alveolate species durinskia baltica and kryptoperidinium foliaceum, whose plastids are of tertiary origin descending from diatom ones  <cit> .

another large clade was formed by plastids of rhodophytic algae excluding porphyridium purpureum, cryptophytes, certain alveolates, haptophytes, and stramenopiles aureococcus anophagefferens and aureoumbra lagunensis  <cit>  as well as raphidophyte heterosigma akashiwo  <cit>  and xanthophyte vaucheria litorea.

all brown algae ectocarpus siliculosus, fucus vesiculosus, and saccharina japonica  <cit>  composed another clade.

the alveolate species whose plastids are close to those of rhodophytic algae include all considered sporozoans as well as the photosynthetic alveolate chromerida sp. rm <dig>  the common origin of these plastids has been previously confirmed by protein alignment  <cit> . in addition, we have predicted a uniform ycf <dig>  expression regulation in plastids of sporozoans and certain rhodophytic algae  <cit> , which corroborates the close positions of these species on the generated tree. a significant variation between plastids is observed among stramenopiles. the distinction of haptophytes agrees with the independent origin of plastids in haptophyta and stramenopiles proposed previously  <cit> . however, the independent origin of cryptophyte plastids is not confirmed. overall, one can propose that plastids of rhodophytic branch are monophyletic and descend from plastids of rhodophytic algae, while this statement seems questionable for cryptophytes and sporozoans.

the tree of chromosome structures in apicoplasts was reconstructed using an entirely different approach in  <cit> , fig.  <dig>  it shows some similarity with the corresponding subtree of our tree of plastids. for instance, chromerida is an early separated branch in both cases. according to the number of edges on the path, plasmodium neighbors toxoplasma and the both neighbor theileria. at the same time, the trees are distinct, which can be attributed to a different number of analyzed genes and species .fig.  <dig> 
a evolutionary scenario of chromosome structures along the small tree. the following events are shown on edges: − <dig>  loss of one of two paralogs of gene psby; + <dig>  emergence of a paralog of gene psby; +r, emergence of an inverted repeat of a chromosome segment; i <dig>  inversion of a chromosome segment; t <dig>  transversion of a chromosome segment; t <dig>  translocation of a chromosome segment; i <dig>  insertion of a chromosome segment, and d – disappearance of a chromosome segment. the number of the events is given in parentheses when greater than  <dig>  for the reconstruction details, see table s3a in additional file  <dig>  # <dig>  b evolutionary scenario of chromosome structures along the large tree. the following events are shown on edges: − <dig>  loss of gene psby; − <dig>  loss of one of two paralogs of gene rpoc2; + <dig>  emergence of a paralog of gene rpoc2; + <dig>  emergence of a paralog of gene clpc; i <dig>  inversion of a chromosome segment; t <dig>  transversion of a chromosome segment; t <dig>  translocation of a chromosome segment; 2 f, fusion of two paralogs of gene rpoc <dig> into one large gene, and d, deletion of a chromosome segment. the number of the events is given in parentheses when greater than  <dig>  for the reconstruction details, see table s3b in additional file  <dig>  #3



reconstruction of chromosome structures in rhodophytic plastids along the tree of their evolution by the descent algorithm
for brevity, the reconstructions in two subtrees of the tree shown in fig.  <dig> are presented: from the common ancestor of leptocylindrus danicus and odontella sinensis  and from the common ancestor of porphyra purpurea and vaucheria litorea nc  <dig> . the result of reconstruction for the small tree is given in additional file  <dig>  # <dig>  and the corresponding evolutionary scenario is shown in fig. 7a. the corresponding reconstruction for the large subtree is shown in table s3b and fig. 7b.

in tables s3a–s3b, the genes are specified according to their order on the chromosome; everywhere asterisk marks genes on the complementary strand. both trees were reconstructed using a boolean linear programming with  <dig> millions of variable and  <dig> millions of linear equalities and inequalities. two paralogs of the рsby, rpoc <dig>  clpc, and some other genes can be distinguished by the subscript index. if a structure contains several chromosomes, they are separated by vertical lines.

note that all plastid chromosomes are circular in the reconstruction.

the result of reconstruction for the large tree is shown in additional file  <dig>  # <dig>  and the corresponding evolutionary scenario is shown at fig. 7b. as previously, all chromosomes are circular; the most of ancestral structures include a single chromosome in the subtree up to the common ancestor of porphyra purpurea and galdieria sulphuraria; while most structures contain several chromosomes in the remaining part of the subtree. this can point to active chromosome rearrangements in ancestral species in this part of the subtree.

the presence of several circular chromosomes in a structure does not necessarily indicate the presence of an ancestral species with such structure, since it can correspond to evolutionary periods when translocations of chromosome regions occurred. indeed, translocation is represented by two consecutive operations: cutting out and circularization of a fragment and its insertion into a different locus. thus, reconstruction can expose intermediate states of such rearrangements. the generated scenario includes only a small number of such events.

CONCLUSIONS
a high-level model of chromosome structure was proposed together with computer programs that allow its efficient utilization. a database of protein families encoded in rhodophytic plasmids was generated . the scenarios of chromosome rearrangements were deduced in rhodophytic plastids and sporozoan mitochondria. the scenarios, in particular, demonstrate the similarity of chromosome structures in sporozoan apicoplasts and rhodophytic plastids, which agrees with the previously proposed common origin of expression regulation in a few genes from these species, including the common pattern of translation initiation regulation for genes coding for dna-directed rna polymerase beta chain and the protein sufb involved in iron-sulfur cluster formation. the similarity of chromosome structures is observed in rhodophytic and cryptophytic plastids. on the other hand, our results indicate an early and independent segregation of diatom and haptophyte plastids.

chromosome structures in plastids of the rhodophyte alga porphyridium purpureum and the photosynthetic alveolate alga chromera velia deviate considerably from those in their relatives. in such cases, chromosomes cannot be used to infer phylogenetic relationships but can provide comparative information for understanding the role of chromosome rearrangement in gene expression regulation. such analysis was published for plastids of higher plants  <cit> .

chromosome rearrangements can considerably affect patterns of gene expression, particularly due to competition between rna polymerases  <cit> . in chromosomes with labile structures, transcription terminators are naturally expected to occur between genes, and gene expression is largely regulated at the translation level, which was described for many plastids e.g.,  <cit> .

the model and computer programs can be used to explore the evolution of chromosome structures in other genomes.

declarations
availability of data and materials
the database of plastid and mitochondrial protein clusters is available at http://lab <dig> iitp.ru/ppc/redline67/. the programs below were tested on several artificial sets of data, which are available together with program distributives.chromo program: project name: chromo

 project home page: http://lab <dig> iitp.ru/en/chromoggl/

 operating system: windows 7

 programming language: c++

 license: freeware



chromoreconstruction program: project name: chromoreconstruction

 project home page: http://lab <dig> iitp.ru/en/chromoggl/

 operating system: windows 7

 programming language: delphi

 license: freeware





additional file
additional file 1: 
# <dig> ; # <dig> ; # <dig> . 



competing interests

the authors declare that they have no competing interests.

authors’ contributions

val and kyg conceived all related algorithms and mathematical statements. rag programmed all algorithms and computed the data. avs, kyg, and val analyzed the computer output. val, kyg, and avs wrote the manuscript. they have read and approved the final manuscript.

