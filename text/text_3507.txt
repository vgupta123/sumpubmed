BACKGROUND
the gap between the growth rate of biological sequence databases and the capability to characterise experimentally the roles and functions associated with these new sequences is constantly increasing  <cit> . this results in an accumulation of raw data that can lead to an increase in our biological knowledge only if computational characterisation tools are developed. we focus here on the annotation of protein function. a generic approach to this problem consists of transferring the annotation from sequences of known function to uncharacterised proteins  <cit> . the transfer mechanism might be subdivided in two steps:  to establish the list of known proteins with significant sequence similarity to the uncharacterised sequence;  to select the known sequence from which the annotation is transferred  <cit> . the first step is usually performed with sequence alignment tools such as fasta  <cit>  or blast  <cit> . when sensitivity is critical, alternative tools such as psi-blast  <cit>  and hidden markov models  <cit>  can be used. finding homologous proteins can also be accomplished using alignment-independent sequence comparison tools, which have been developed to overcome the limitation arising from the assumption of contiguity between homologous segments  <cit> . then, the challenge is the selection of true homologues from the list of similar sequences. most of the above tools provide a score measuring the degree of similarity between the sequences compared. a simple criterion to single out a homologue is to choose the most similar sequence i.e. the highest scoring sequence. more elaborate methods have been designed to enhance the precision and reliability of the annotation process. these rely on the combination of the annotations of more than one homologue  <cit>  or, for example, on semantic analyses of annotation lines  <cit> .

this type of annotation process relies on the assumption of a strong relationship between protein sequence and function. this hypothesis is generally fair  <cit>  even though many studies have demonstrated the existence of counter-examples that can lead to annotation errors  <cit> . two major origins of errors can be distinguished:  the short listed homologous protein have a different function from the sequence to be annotated ;  the transferred annotations were themselves not correct . the second type of errors along with the iterative usage of annotation transfer gives rise to the specific problem of error propagation when newly annotated sequences are included in the reference database used for the homology search. recent studies have shown that dramatic consequences on the reliability of database annotations are likely to arise from this process  <cit> . in order to improve our control on these two types of errors, it would be very useful to associate a measure of reliability to the annotations obtained. in this way, we might limit the introduction of new errors and limit their propagation by not admitting the transfer of the less reliable annotations.

in this work, we address this issue by developing a probabilistic framework to the homology-based annotation process. our approach relies on the usage of a reference dataset where protein sequences are classified into functional classes. here, an annotation is a membership to a functional class, thus, function sharing is evident. the possibility for a protein to perform a particular function is then assessed based on its similarity relationships with all protein sequences known to perform this function; it enables for instance to take into consideration both the presence and the absence of similarity. this possibility is used during the training step of machine-learning approaches for sequence annotation, which relies on the availability of a classified reference dataset  <cit> . note that most other methods proposed to date map function to proteins by first "clustering" proteins based on sequence similarities and second combining the functional description of the characterised proteins to propose a description for the uncharacterised sequences. the present approach inverts this process by mapping sequences to a functional classification instead of mapping functions to a sequence clustering. following this idea, we propose a method to build correspondence indicators  between sequences and functional classes. then, we explore two bayesian annotation frameworks based on the comparison of the cis of a sequence of unknown function with the observed cis for the reference protein sequences. this framework provides probabilities for a sequence to belong to the different functional classes. we advocate the use of these probabilities as a direct measure of the reliability of annotations.

to validate both probabilistic methods for automatic annotation, we applied them to the well-established classification of enzymes. our results show that both methods allow distinguishing proteins whose annotation is reliable from the others. at the highest level of reliability, the two methods predict the four ec digits with a very low error rate  for  <dig> % and  <dig> % of enzymes respectively. we compared these results with the simple strategy consisting in transferring the ec number of the blast best hit. our best method has an error rate half that of the best-hit strategy at the same coverage level.

RESULTS
defining correspondence indicators
given a functional classification, annotating a new protein consists in establishing to which functional class or classes it belongs. to approach the problem we defined a correspondence indicator  between the new protein and each of the functional classes, and second, formulated a classification scheme based on these indicators. this section is devoted to the first point, whereas the second one will be treated in the following section.

using the bit-scores of sequence alignments , we can imagine many different scoring strategies to measure this correspondence. for instance, we could use the number of hits , or the best bit-score between the new protein and the functional class members. alternatively, we might choose to compromise between the two above options by taking the sum of the bit-scores between the new protein and the class members.

here, we propose a measure that unifies these three strategies. let Ω <dig>  ..., Ωn symbolise the set of n functional classes with respective sizes n <dig>  ..., nn. we denote sc,d the blast bit-score between two proteins c and d. then, we define the ci yΩj  parameterised by α∈[ <dig> +∞), between a new protein c and the class Ωj as follows:

yΩj=∑d∈Ωjsc,dα,     

where the sum is taken over bit-scores sc,d greater than a given threshold s <dig>  for c≠d. yΩj  measures the strength of the homology relationship between the new protein c and the family Ωj as the sum of the pairwise bit-scores to the power α between c and all class members. the possibility to choose the parameter α allows modulating the relative weight of each hit with a class: the relative weight of hits with larger bit-scores increases with α. using α =  <dig>  all the hits have the same weight and yΩj  is simply the "number of hits" of c with Ωj. when α =  <dig>  the weight of each hit is its bit-score and yΩj  is the "sum of the bit-scores". finally, as α→∞ only the hit with the largest bit-score counts and yΩj  reduces to max⁡d  ∈  jα, which is equivalent to the "best bit-score" scoring strategy.   as the best bit-score with class Ωj: yΩj  = max⁡d  ∈  j). thus, the choice of α enables a continuous variation between the strategies where only the number of hits or only the bit-score of the best hit counts. to our knowledge, such a parametric approach to sequence search metrics has not been proposed previously. note that a more sophisticated combination of the cis obtained for different α values could take advantage of various aspect of information captured by each of these α values.

different strategies of annotation
best correspondence indicator strategy
given a fixed value for α, the simplest classification scheme is to assign the new protein c to the class Ωj <dig> that maximises the ci. for α =  <dig>  it is the functional class with the greatest number of hits with c. when α→∞, this amounts to the class containing the sequence closest to c: a simple "best hit" strategy of annotation. note that different values of α may result in a different classification of c.

estimating the probability for a protein sequence to belong to a functional class: an univariate bayesian approach
a limitation to the "best ci" strategy of annotation is the lack of a reliability assessment for the functional assignments. to overcome this limitation, we propose to estimate, independently for each of the functional classes, the probability p ) for a protein c drawn at random, to belong to class Ωj given yΩj  i.e. we estimate probabilities knowing one variable  only. using bayes theorem, we can show  that this conditional probability can be estimated by:

p^)=nΩj±λ)n±λ).     

where nΩj±λ) and n±λ) are respectively, the number of proteins truly belonging to class Ωj and the number of proteins from the entire dataset, whose correspondence indicator with class Ωj is comprised in  . this mechanism is illustrated in additional file  <dig>  figures s <dig>  λ is fixed for the annotation of each new protein such that the total number of sampled proteins n   ± λ) is always equal to  <dig>  this can be viewed as an adaptive smoothing of the data: λ is increased until the interval  contains a predetermined quantity of information .

determining the most likely functional class of a protein sequence: a multivariate bayesian method of annotation
in the previous approach, we assessed the membership of a new protein to a functional class using only the ci with this class. because this process is performed independently for each class, it allows several probabilities to be close to  <dig>  in such circumstances functional assignment is ambiguous. to improve the control on these cases, we propose to estimate the probability p  ... yΩn }) of a new protein c to belong to Ωj knowing the set {yΩ <dig>  ... yΩn } of its cis with all the functional classes i.e. we estimate probabilities based on multiple variables . using bayes theorem, we can show  that:

p^…yΩn})=nΩj…yΩn},r))n…yΩn},r)).     

estimating this probability amounts to consider the n-dimensional space of cis and to look in that space what is the functional composition of the proteins that have their position within the sphere b   ... yΩn }, r) of radius r, centred at {yΩ <dig>  ... yΩn }. in other words, we count the number of proteins within the sphere b   ... yΩn }, r) that truly belong to class Ωj. the ratio between this number and the total number of proteins in the sphere is p^   ... yΩn }). this mechanism is illustrated in additional file  <dig>  figure s <dig> 

as previously for λ, r is determined for each protein such that the total number of proteins sampled n  ... yΩn }, r)) is always  <dig>  note that this method amounts to find the  <dig> closest proteins from the reference dataset to the point {yΩ <dig>  ... yΩn } in the ci space. the logic behind this adaptive methodology is that the local density of proteins in the ci space can be highly variable depending on the average level of homology between proteins in each functional class. hence, using constant value for λ and r is not adequate. in this framework, it does not make sense to attempt classifying proteins into classes with less than  <dig> members. the particular choice of  <dig> corresponds to a trade off between precision  and coverage i.e. the number of ec classes considered .

determining the optimal correspondence indicator
the freedom of choice of the parameter α in the ci yΩj  ) allows us to combine in different ways the bit-scores of the alignments of protein c with the proteins of the class Ωj. the choice of α enables a continuous variation between the strategies where only the number of hits above the threshold s <dig>  or only the bit-score of the best hit  counts . to optimise the parameters α and s <dig>  we re-annotated each enzyme  using the best ci strategy  with different combinations of their values. in figure  <dig>  we report the number of annotation errors e for each combination of these parameters. at a fixed value of s <dig>  we observe that the higher α, the lower the number of errors. moreover, the difference between the number of errors at α =  <dig> and at α =  <dig> soars for small s <dig> values  =  <dig> and e = 122). this effect is due to the poor specificity of alignments having a small bit-score. with no cut-off , all sequences hit one another and thus, for α =  <dig> all the functional assignments are made to the largest class. this illustrates that the choice of the α value can be critical, and that for small α values, the sensitivity to s <dig> is higher. at a fixed value of α, by increasing the cut-off s <dig> we minimise the number of errors as expected, but simultaneously the coverage of annotated proteins drops significantly . indeed, a protein cannot be annotated if all its hits have a bit-score below the cut-off. this shows that if we do not want to lose too much coverage, there is very little latitude on s <dig> 

by minimising the number of errors to determine the optimal value for α, we conclude that the best bit-score strategy  is the one which best describes the relation between an enzyme and its functional class. moreover, given the weak sensitivity to s <dig> for α→∞, we choose the smallest value s <dig> =  <dig> for the threshold in order to maximise the coverage. then, from now on, the only ci we will be using is yΩj  for s <dig> =  <dig>  denoted yΩj . the best ci strategy with α→∞ reduces to a blast best-hit strategy . its performance depends only on the threshold s <dig> that also directly controls the coverage . it will serve as a reference to compare to the results obtained with the two probabilistic approaches. in this way, given the same input , we will assess the improvement in annotation quality obtained by an efficient usage of a functional classification on the reference dataset. recently developed database search methods exploit sequence profiles and often outperform blast in terms of sensitivity for the detection of remote homologies. however, this increase in sensitivity usually comes at the expense of specificity, which is the most important feature in the present set up. indeed, most enzymes have easily detectable homologies with sequences from their ec class.

re-annotation with the univariate bayesian approach
the univariate bayesian approach allows estimating the probabilities for an enzyme to belong to a particular ec class Ωj, given only yΩj  . to annotate an enzyme using this method, we derive probability estimates for its membership in each functional class ) and assign it to the class for which the probability is largest. we re-annotated all enzymes of the reference dataset via this approach, using the leave-one-out method . the results of this re-annotation are presented table  <dig>  there is a total annotation error rate r =  <dig>  , which is more than twice as large as for the re-annotation of the reference dataset by the best-hit strategy . however, we can take advantage of the assignment probabilities that do not exist for the best-hit strategy and that are a direct measure of the confidence we have in an assignment. considering the large proportion of proteins  that are annotated with the highest confidence , we notice that r =  <dig>  , two fold smaller than for the best-hit strategy. the reduction of the error rate remains very significant even if we take into account the coverage of annotation: at the same coverage, the best-hit strategy leads to a rate of error of  <dig>  which is  <dig>  larger . to achieve the same rate of error with the best-hit strategy the coverage drops to 54% . interestingly, for assignment probabilities smaller than  <dig>  the error rate dramatically increases . these results demonstrate that flagging annotations with the assignment probabilities allows us to filter out likely errors. finally, we note in table  <dig> that  <dig> proteins are reported to be correctly annotated with an assignment probability equals to  <dig>  these proteins only hit their true class and so, can be assigned only to it. however, because their ci with their class falls in a range of values with only protein from other classes, the assignment probability is equal to zero ).

in this mode of automatic annotation, the probabilities of membership of a protein to each functional class are estimated independently, allowing for two or more probabilities to be significant e.g.  <dig> and  <dig> . in principle, this property permits to assign a protein to more than one functional class. nevertheless, if proteins can belong to one functional class only, as for the set of enzymes considered here , these situations correspond to ambiguous cases that are more likely to lead to annotation errors than instances where proteins have only one significant probability. indeed, out of the  <dig> enzymes annotated with an assignment probability of  <dig> ,  <dig> have their second highest probability equal to  <dig> . for these "clear cases", the error rate is significantly reduced to r =  <dig>   which is  <dig> times smaller than the error rate for the maximum bit-score strategy at the same annotation coverage . this result strongly suggests that taking into account simultaneously the cis with all functional classes can lead to significant improvement in the annotation process. this approach is investigated in the next section.

re-annotation with the multivariate bayesian method
we now explore a multivariate bayesian method taking into account all cis concurrently. more precisely, each protein is mapped to a point in an n-dimensional space where each dimension corresponds to one of the n possible functional classes. in this space, the coordinates of a protein are the cis yΩj   with each family. the probabilities for a protein to belong to each functional class are estimated simultaneously according to the functional class of the  <dig> proteins of the reference dataset closest to the unclassified protein in this space ). note that compared to the univariate bayesian approach, protein neighbourhood is determined globally, just once. as a result, the sum of all the probabilities is always 1; there cannot be more than one significant class membership probability  per protein.

we re-annotated all enzymes of the reference dataset via this method . compared with the univariate approach, we note a decrease of the global error rate . at the highest annotation confidence , we observe a significant increase of the annotation coverage  concomitant with a stable error rate . the error rate at the highest confidence level is half that of the best-hit strategy for the same coverage. we observe that to achieve a similar error rate the coverage of the best-hit strategy would dramatically drop to 51% . interestingly, the assignment probabilities closely match the empirical error rates. for instance, for the set of enzymes annotated with an assignment probability of  <dig> , we measure an error rate of  <dig>  .

comparing the two bayesian annotation strategies
the two bayesian methodologies differ significantly on the coverage of the database of enzymes annotated at the maximum level of reliability :  <dig> %  for the univariate approach in contrast with  <dig> %  for the multivariate method. this increase of coverage actually associated with a constant number of errors  corresponds to  <dig> more correct annotations in favour of the multivariate method . this is due to the fact that the multivariate bayesian method regards a protein sequence as a single point in the ci space while the univariate bayesian approach considers the orthogonal projection on each ci axis separately. figures  <dig> and  <dig> propose two examples to illustrate the consequences of this difference.

exploring the ci space for ec classes  <dig> . <dig>   and  <dig> . <dig>  
focusing on protein o <dig>  from ec  <dig> . <dig> , we note figure  <dig> that its cis  with both ec classes are similar . to calculate the probabilities to belong to each ec classes with the multivariate bayesian method, we look at the functional distribution of the proteins closest to o <dig> in the ci space ). this process is represented by the dotted circle in figure 3; it leads to p <dig> . <dig>  =  <dig>  and p <dig> . <dig>  =  <dig>  and, thus, to a correct annotation of o <dig>  by contrast, when annotating this protein with the univariate bayesian approach, these probabilities are calculated independently ). p <dig> . <dig>  falls to  <dig> because on the ec <dig> . <dig>  axis, around bit-score  <dig> , we sample only proteins belonging to ec  <dig> . <dig> . in the same manner, for ec  <dig> . <dig>  around bit-score  <dig> , we observe only one protein out of  <dig> that truly belongs to ec  <dig> . <dig>  so that p <dig> . <dig>  =  <dig> . hence, we wrongly assign o <dig> to ec  <dig> . <dig>  but with a very low assignment probability p =  <dig> .

exploring the ci space for ec  <dig> . <dig>  ) and ec  <dig> . <dig>  )
there is also strong sequence similarity between proteins from these two ec classes and there exists a quite well defined "boundary" that is densely populated ). very clearly the projections on the ci axes intrinsic to the univariate approach tend to mix the  <dig> proteins from the two ec classes leading to poor performances  whereas the multivariate method can adapt to the boundary and leads to improved performances . these cases clearly exemplify that the projections on the ci axes can have great influence on the probability calculation and may result in annotation errors. it also shows that the multivariate method outperforms the univariate approach because of its ability to adapt to the shape of the boundary between functional classes in the ci space.

analysing the origins of annotation errors
the proposed bayesian annotation strategies optimise the exploitation of the functional information carried by cis built upon sequence similarity clues . we explore examples of the failure of these clues leading to annotation errors when using the multivariate bayesian method.

annotation errors between glyceraldehyde 3-phosphate dehydrogenases
proteins from classes ec  <dig> . <dig>  and ec  <dig> . <dig>  catalyse the same reaction  but ec  <dig> . <dig>  proteins are nad-dependent while ec  <dig> . <dig>  proteins can use both nad and nadp as cofactors. as illustrated in figure  <dig>  there exists strong cross-similarity between sequences from these two classes but each class tends to occupy a separate part of the ci space so that annotation can be done accurately. we note four exceptions: four proteins from ec  <dig> . <dig>   are closer to the ec  <dig> . <dig>  cloud than to the other ec  <dig> . <dig>  proteins in the ci space and thus are wrongly re-annotated as ec  <dig> . <dig>  proteins. the erroneously re-annotated ec  <dig> . <dig>  sequence o <dig> is bacillus subtilis gapb protein. protein gapa , also from b. subtilis belongs to class ec  <dig> . <dig> . it was shown that gapa can acquire the gapb activity with only two amino acids mutations   <cit> ; actually, gapb possesses these mutations. therefore, a reasonable hypothesis is that gapa and gapb originate from a gene duplication event followed by divergent evolution. from the topology of figure  <dig>  it is possible that similar scenarios apply to the three other "misplaced" ec  <dig> . <dig>  sequences. here, functional specialisation can be achieved with only a few modifications at specific sites. general alignment tools like blast do not capture the higher significance of mutations at these sites compared to alterations at other sites; this leads to annotation errors difficult to avoid with automatic general-purpose tools.

annotation errors between two-sector atpases
another interesting example of annotation errors comes from the classes ec  <dig> . <dig>  and ec  <dig> . <dig> , both of which contain transporting two-sector atpases, the former transporting h+ and the latter na+. in the ci space, the two clouds of points marking the proteins from these classes exactly overlap  i.e. cis based on blast bit-scores do not capture any sequence specificity distinguishing the two ec classes . ec  <dig> . <dig>  being much less populated than ec  <dig> . <dig>  , this particular topology results in the  <dig> ec  <dig> . <dig>  sequences to be wrongly assigned to ec  <dig> . <dig>  with a high confidence  because a large majority of their neighbours in the ci space belongs to ec  <dig> . <dig> . more generally, when cis do not allow the distinction of two classes then we expect most sequences to be assigned to the larger class with an assignment probability equal to the relative size of this class. hence, unless one class is greatly larger than the other one, assignment probabilities will be significantly smaller than  <dig> allowing us to filter out these specious annotations. in other words, the  <dig> erroneous annotations of ec  <dig> . <dig>  proteins originate from a class size effect. in most situations class sizes are of the same order and such a local topology of the ci space leads to easily detectable annotations errors . this example of annotation errors actually explains how, by scanning the local configuration of the ci space, the bayesian strategies can avoid a number of errors.

example of annotation error propagation
in the present work, we considered the annotations associated to the sequences in the enzyme database to be exact. nevertheless, analysis of the origins of annotation errors using visual representations of the ci space as shown figure  <dig>  revealed peculiar configurations of the sequence-function relationship. a close investigation of these cases allowed us to identify three clear annotation errors. figure  <dig> provides an example of error identification. protein p <dig>  is annotated as a member of ec  <dig> . <dig>  -utilizing glutamate dehydrogenase) but the multivariate bayesian method assigned it to ec  <dig> . <dig>   with an assignment probability of  <dig>  indeed, p <dig> is close to a group of ec  <dig> . <dig>  proteins in the ci space. tracing the source of this annotation, we noted that its strong ci value with ec <dig> . <dig>  originated from a strong sequence similarity with protein p <dig>  annotated as ec  <dig> . <dig> . by checking the publication associated with the annotation of p <dig>  we noted that this protein was wrongly annotated and actually belongs to ec  <dig> . <dig>   <cit> . correcting this database annotation error, the ci value of p <dig> with ec  <dig> . <dig>  increases while its ci value with ec  <dig> . <dig>  decreases so that in fact the multivariate bayesian method correctly classifies it to ec  <dig> . <dig>  ). interestingly, this example provides an illustration of an annotation error susceptible to propagate  <cit> . the correction of the annotation of p <dig> was submitted to the enzyme database and is expected to be included in future releases. another example comes from p <dig>  that we classify as ec  <dig> . <dig>   in disagreement with its database annotation: ec  <dig> . <dig>  . actually, the ec  <dig> . <dig>  activity of p <dig> has been described in the literature  <cit> . in addition, we found that q <dig>   should be annotated as ec  <dig> . <dig>  . the experts of enzyme have validated these two annotation errors and corrected the corresponding database entries.

discussion
the maintenance of various aspects of protein function is intricate due to the inhomogeneity of the sequence-function relationship. for example, 60% of ec classes with more than  <dig> members could not be perfectly discriminated by sequence similarity at any blast threshold  <cit> . moreover, the  <dig>  ec digits were systematically identical only above 80%  sequence identity in structural alignments, while at the other end of the spectrum, the preservation of the  <dig> ec digits was observed at as low as 16% identity  <cit> . consequently, the threshold below which sequence similarity should not be considered for annotation transfer at a given confidence level should in general be determined for each functional class independently. however, it is typically set in a uniform manner. in sharp contrast, the two bayesian methods developed here take into account how functional classes are distributed locally in the relevant part of the ci space or along ci axes and assign a low probability where the sequence-function relationship is ambiguous.

interestingly, with both bayesian approaches, a large majority of proteins have been re-annotated with an assignment probability of  <dig> . in the case of the multivariate bayesian method, it means that for  <dig> % of the enzymes of our dataset their  <dig> nearest enzymes in the ci space have the same ec number. also, at the fourth level of the ec hierarchy,  <dig> classes out of  <dig>  are isolated i.e. the  <dig> proteins out of  <dig>  belonging to these classes have no blast hit  with the proteins of the other classes. this illustrates that there exists a high level of clustering of enzymes sharing their four ec digits in the ci and sequence spaces. thus, for the filtered enzyme database we considered in this analysis , ci based on sequence similarity is a meaningful clue to predict the full ec code. in contrast, considering ec digit conservation based on pairwise sequence comparison, it was found that a good practical rule was to transfer  <dig> ec digits above 15% sequence identity  <cit> . there is no contradiction here. essentially, when considering sufficiently populated ec classes, for most sequences we find very close homologues within their class allowing a clear functional annotation. this property of large ec classes also explains why the optimal cis are obtained for α→∞  i.e. why the optimal cis reduce to the best blast bit-score with each class while the number of hits is not taken into consideration : the important property in the sequence-ec class relationship is that the ec class contains at least one highly similar sequence to the query sequence under study. this situation also clarifies the reason for the good performance of the simple blast best-hit strategy for the tested data set . a priori, the well-specified clustering of sequences belonging to the same class cannot be generalised to other classifications of proteins, so depending on the sequence classification scheme under consideration it is important to measure the optimal α value. in situations where this value is small , it is predictable that the difference between the performances of the bayesian approaches and the simple blast best-hit method will be greatly increased.

CONCLUSIONS
the importance of standardising the systems by which biological functions are described is now generally recognised  <cit> . this has opened up the possibility for high-throughput automatic retrieval of sequences based on functional characteristics. in the present work, we demonstrate the great potential offered by a classification of protein functions to improve the quality of sequence annotations. indeed, the availability of such a functional classification allows the definition of measures of correspondence between a sequence and all functional classes i.e. it permits taking advantage of the complete set of similarity relationships of a query sequence with the sequences from a reference database. the automated bayesian methodologies provide reliable information about the sequences whose assignment probability is large enough  leaving behind the more "difficult" cases. in an annotation pipeline, these methodologies could be an efficient filter to focus the work of human experts on the more error prone cases  <cit> . along the same lines, inconsistencies between automated annotation and database annotation could be used to highlight possible annotation errors  <cit> ; in this context, visual representations like those presented in figure  <dig> can be a useful tool for human experts.

an important aspect of this work is the construction of correspondence indicators between sequences and functional classes ). here, we used blast bit-scores for this process but the score from any pairwise protein comparison can be used instead e.g. structural comparison  <cit>  or alignment-independent measures that can be computed from the primary sequence like length, word frequency, molecular weight or total charge  <cit> . note that in principle, any measure of relationship between sequence and function can be used instead of cis. in a previous study, it was shown that the simple blast best-hit approach outperformed three machine-learning methods based on alignment-independent features for the classification of enzymes within the ec hierarchy  <cit> . in contrast, the two bayesian classifiers based on cis outperform sequence similarity alone in term of sensitivity and specificity. this suggests that cis could reveal themselves to be powerful features as input to machine-learning approaches for protein classification  <cit> . it remains to be seen whether the performance of cis based on pairwise blast bit-scores is constant across various classification problems e.g. when there is only remote homology between class members  <cit> .

the analytical development leading to cis can be extended to construct a measure of correspondence between two functional classes that describes the degree of their overlap in the ci space . since a strong overlap indicates that two functional classes cannot be distinguished by the cis, we can build an "adapted" functional classification by merging functional classes based on this new criterion. interestingly, this amounts to empirically solve the problem of the extent of the functional annotation that can be transferred  <cit> . for example, ec  <dig> . <dig>  and ec  <dig> . <dig>  exactly overlap in the ci space , this means that blast-based cis simply do not differentiate these two types of transporting two-sector atpases. it is more effective in an automated system to group these two classes in a meta ec class "na+ or h+ transporting two-sector atpases" that we can reliably assign to. a key feature of the proposed methodologies is the quantification of the reliability of annotations; the assignment probability represents an attractive candidate, both versatile and compact, to qualify non-experimentally based annotations. in principle, it could be taken into account by the bayesian annotation framework allowing its iterative usage without risking the propagation of annotation errors  <cit> . it is our hope that the bayesian annotation strategies presented herein will contribute to more robust automatic annotation pipelines.

