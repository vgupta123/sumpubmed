BACKGROUND
graphs provide simple but often useful formal representation of biological networks capturing one-to-one relationships between biological entities  <cit> . different classes of graphs make it possible to incorporate different levels of knowledge. protein-protein interaction networks, for example, are usually stored as simple undirected graphs. for studying graph-theoretical properties of metabolic networks  one often uses directed  graphs. more quantitative relationships are captured by bayesian networks, an example for directed weighted graphs.

for networks with signal or information flow such as signal transduction or  regulatory networks, interaction graphs are the graph model of choice. interaction graphs  are directed signed graphs where each edge  carries a + or - sign indicating a directed causal relationship between the two involved players, e.g. "molecule a activates or inhibits another molecule b". interaction graphs are widely used; they serve often as illustrative maps in databases or textbooks and help to represent and to interrogate qualitative knowledge. apart from statistical properties  <cit> , important functional network properties can be derived from these models:

a) feedback loops: they are the sources of complex dynamics  <cit> . recently, kwon and cho  <cit>  showed that coherent coupling of feedback loops might be a design principle of cell signaling networks devised to achieve robustness.

b) signaling paths show the different positive and negative routes along which a molecule can affect another.

c) dependency matrix: stores for each ordered pair  of nodes an attribute summarizing the global  dependence of b upon a  <cit> . for example, a is an activator of b if at least one positive path from a to b exists but no negative one.

d)  cut sets: for a given set of feedback loops or signaling paths one may compute a set of interventions interrupting the signal flow in them  <cit> .

even though interaction graphs are qualitative models, they also play an important role in representing and analyzing structural relationships of dynamic models. a key property of systems formally described with ordinary differential equations is the jacobian matrix j and its sign structure, sgn), which gives rise to an interaction graph: if jik≠ <dig> then an edge from k to i is drawn and sgn) gives the sign of the edge  <cit> . in general, sgn) depends on the state x where j is evaluated, but in many biological examples it is constant for all  x rendering it a structural invariant. in systems biology, where the description of kinetic rate laws is usually hampered by limited knowledge on kinetic parameters and mechanistic details, such structural invariants provide a great opportunity to derive network properties that are independent on this uncertain information. in fact, some fundamental systems properties on qualitative dynamics can be derived from the underlying interaction graph of j:

e) multistationarity  requires a positive feedback in sgn)  <cit> .

f) another multistationarity theorem has been given by craciun et al.  <cit> . even though it is based on unsigned graphs, it requires the analysis of certain cycles in the graph .

g) oscillations require a negative feedback of length two or higher in sgn)  <cit> .

h) systems behave monotone with respect to changes in the initial conditions if no  negative cycle is contained in the interaction graph of j  <cit> .

i) the initial and steady state response of a system upon perturbations can partially be derived from the interaction graph  <cit> .

actually all the listed applications of interaction graphs require either an enumeration of all paths/loops in the network  or the determination of the shortest positive and shortest negative paths and cycles  as in . although of fundamental importance, these algorithmic problems have so far been discussed only to a minor extent in systems biology. algorithms for the enumeration of paths and cycles have been developed already in the 70s and we will start with a short review on them. we will also compare these standard algorithms with an alternative approach proposed recently  <cit> . the main part of this work is devoted to the computation of shortest positive and negative paths and cycles in signed graphs. whereas algorithms for the determination of shortest paths and cycles in unsigned graphs are well-known and of polynomial complexity, in signed graphs, this problem  is much more complicated and is, in general, np-complete. there are only very few references dealing with this problem. here we will introduce new algorithm variants which provide either, in polynomial time, approximations of the real shortest paths and cycles or are improvements for finding the exact solution. using various examples of biological interaction graphs, we demonstrate the performance of these algorithms and show that even in larger networks the exact solution can be found in reasonable time.

RESULTS
definitions
we summarize some standard terminology and notations from graph theory. a graph g =  consists of a set v of nodes  and a set e of edges between those nodes. here we are only concerned with finite graphs meaning that v and e are finite. in undirected graphs, an edge e ∈ e is a pair of nodes: e = {u, v}; u, v ∈ v, whereas in directed graphs  an edge  is an ordered pair e =  giving it a direction from one node  to another . edges may have additional properties: in a weighted graph every edge has a weight  represented by a real number . in a signed graph every edge carries either a + or - sign indicating in biological graphs a causal relationship between both species. it is possible that the same pair of nodes may be connected by a positive and negative edge in parallel. all three edge properties – direction, weight and sign – can be combined independently giving rise to different classes of graphs. herein we will mainly be concerned with the analysis of signed  digraphs , albeit we will sometimes also refer to methods from the other classes.

a walk is an alternating sequence of nodes and edges v <dig>  e <dig>  v <dig>  e <dig>  ... en, vn  which fulfills the condition that the nodes vi- <dig> and vi are connected by the edge ei . a trail is a walk in which no edge occurs twice. a path is a trail in which additionally no node occurs twice. the property that a node must not occur twice is sometimes emphasized by calling a path 'simple' or 'elementary'. here we use the path/trail distinction which makes the use of additional attributes unnecessary. finally, a cycle is a closed trail with no repeated nodes except for the first and last node which must be identical.

concrete paths or cycles are here written as alternating sequences of nodes and arrows, e.g. a → b → c, which gives a unique identifier for a path or cycle if no parallel edges exist between the involved nodes.

the length of a path/cycle is calculated by summing up the edge weights while its sign is obtained by multiplying the edge signs. a signed digraph is therefore not equivalent to a weighted digraph with positive and negative edge weights. we will denote the overall sign of a concrete path or cycle by a superscript sign at the end node, e.g. a → b → c → a-.

a strongly connected component  is a maximal subgraph of a digraph in which a path between every pair of distinct nodes exists. the sccs of a graph can be computed in linear time with tarjan's algorithm  <cit> . in a digraph, every cycle lies in exactly one scc . also, every node belongs to exactly one scc .

an important concept in relation to signed graphs is balance  <cit> . a signed undirected graph is called balanced when every cycle in the graph is positive. a directed graph is balanced if the underlying undirected graph is balanced and it is cycle-balanced when all directed cycles are positive . it can be proven that a signed digraph g is cycle-balanced if and only if every scc of g is balanced .

algorithms for enumeration of paths and cycles
when we are interested in a full enumeration of paths and cycles we need not to distinguish between unsigned and signed graphs. for the latter, paths and cycles can always be computed in the underlying unsigned graph and the overall sign for each path and cycle can easily  be attributed afterwards by counting the negative edges involved in the path or cycle.

all paths starting in a certain  node can be generated by performing a breadth-first or depth-first traversal starting from that node. although this method is easy to implement, the number of paths in a graph can, depending on its structure, quickly explode which can make exhaustive enumeration impractical.

specialized algorithms for the enumeration of all cycles in a digraph have been developed by various authors, e.g. tarjan  <cit>  and johnson  <cit> . they typically rely on backtracking strategies and reduce the search space through temporary blocking of nodes. johnson's algorithm is the more efficient variant and has a time complexity that is proportional to the number of cycles in the graph where the proportionality constant is the number of nodes and edges . in particular, johnson's algorithm successively determines the strongly connected components of the graph and removes previous start nodes so that the next iteration leads to new cycles.

since there can be a great number of paths and cycles in a graph and often not all of them are relevant for the question at hand we devised an algorithm that allows one to restrict the paths and cycles to be computed. nodes and edges that must be passed through are termed obligatory nodes and edges. an obligatory edge can be directly transformed into two obligatory nodes by making its start and end node obligatory. in addition, all other outgoing edges of the start node and all other incoming edges of the end node can be deleted. when enumerating cycles it is now sufficient to process the strongly connected component that contains all obligatory nodes . before paths are enumerated, all nodes that can neither reach nor be reached from any of the obligatory nodes are deleted. reachability is thereby tested by executing an  normal shortest-path algorithm before the enumeration . in addition, reachability can be exploited to reduce the search space when the end nodes of the paths are restricted .

in klamt et al.  <cit>  it was shown that path and cycle enumeration can be achieved alternatively by elementary-modes computation, which is a procedure that is often used in the analysis of metabolic networks  <cit> . briefly, elementary modes  can be seen as a formalization of metabolic pathways in which substrates are converted into products while intermediary metabolites are strictly balanced . if irreversible reactions are part of an em then they can only operate in their specified directions. as third condition, ems are support-minimal, i.e. if a reaction from an em is removed the remaining reactions of the mode are not able to assemble a pathway fulfilling the steady-state and reversibility condition. cycle enumeration can be mapped to elementary-modes computation because  cycles can algebraically be represented in an equivalent way as ems. one considers vectors c  with |e| elements fulfilling a conservation-law 

  

 and a directionality  condition 

  

the solution space of this linear equality/inequality system defines a polyhedral cone whose extreme rays  correspond to the cycles of the graph. since elementary modes correspond also to the extreme rays  we could make use of the elementary-modes algorithm and thereby benefit from recent improvements  <cit> . as shown in  <cit> , elementary-modes computation could also be used for enumerating of paths. in a later section  we will briefly investigate whether it pays off to use such a strategy for path/cycle enumeration or whether regular graph-algorithms perform better.

algorithms for computing shortest signed paths and cycles
the determination of shortest paths in weighted unsigned digraphs is a well-known problem which can be efficiently solved e.g. with dijkstra's algorithm  <cit> . if the graph is unweighted  then even a simple breadth-first search can be used. shortest-paths algorithms usually determine the paths that originate from a fixed start node . in order to calculate the shortest paths between all pairs of nodes the single-source problem can be simply iterated over all nodes in the graph. typically, a shortest path algorithm also calculates the shortest cycle back to the start node. therefore only the shortest path problem is discussed here.

in general, somewhat surprisingly, even the existence problem for negative or positive paths and cycles  in signed digraphs is np-complete  <cit> . obviously, by neglecting the edge signs we could still compute the shortest paths in the underlying unsigned graph. for a given pair of nodes, we can then easily check whether this path is positive or negative. the difficulty in the general case is to find then the shortest path of the opposite sign. however, it is possible to determine the shortest positive and shortest negative paths  in polynomial time when either the graph does not contain any negative cycles  or when the graph is undirected. in the latter case the graph is transformed into an unsigned undirected graph by splitting each edge with a positive sign into two edges with half the weight of the original edge. for this type of graph a polynomial time algorithm has been devised that calculates the shortest paths with an even or odd number of edges  <cit> . shortest paths with an even number of edges are then the shortest positive paths and those with an odd number of edges the shortest negative ones.

since herein we are interested in signed directed graphs we cannot use these polynomial algorithms. however, as mentioned above, signed digraphs not containing negative cycles can be treated exactly with the polynomial double-label algorithm.

double-label algorithm 
the double-label algorithm  is a modification of dijkstra's shortest path algorithm. dijkstra's main procedure determines the shortest paths from a selected start node to the other nodes . this procedure is repeated for every node in the graph when dealing with the all-pairs problem. during its operation, the shortest paths to the other nodes are calculated whereby the path lengths of the shortest paths successively increase. the algorithm keeps track of the currently known shortest distances from the start to every other node as well as  backward pointers that can be used to reconstruct the actual path.

in a signed graph it is necessary to store in each node both the length of the shortest positive  and of the shortest negative  path together with the associated backward pointers. this is the main feature of the dla . during the elongation step, it is now necessary to combine the current shortest positive and/or negative path with all positive and negative edges to test which combination yields a shortest positive or negative path to a neighboring node. assume we want to compute the shortest positive and negative paths from a to all other nodes in figure 1a. since we consider an unweighted graph the dla can run as a breadth-first search. after the first iteration it delivers a → b+  = 1) and a → d+  = 1), after the second iteration a → b → c+  = 2) and a → d → e-  = 2), and after the third iteration a → d → e → c- = 3). the latter path is of length three and thus longer than the path leading from a to c via b, however, the dla keeps for each node the length of the shortest positive and shortest negative path separately  and for c we thus finally have: l+ =  <dig>  and l- =  <dig> .

the dla delivers exact results in polynomial time if the signed digraph does not contain negative cycles . it usually fails if negative cycles are present as illustrated by the graph in figure 1b : assume we are interested in the shortest paths leading from a to b. during the 4-th iteration, the standard dla runs into a negative trail from a to b via a → b → c → f → b- containing the negative cycle b → c → f → b- thus visiting b twice. in its simplest form, the dla would report a negative path from a to b of length  <dig> which is apparently wrong.

in fact, in the most general case, what the simple dla  computes are the shortest positive/negative walks where nodes and even edges may be visited twice . only if no negative cycle is present in the graph these walks coincide automatically with the shortest positive and shortest negative paths. this raises the question why negative cycles are problematic when determining shortest paths. first of all, consider an acyclic digraph: assume that the shortest positive and negative paths from a to b and from b to c are known . with this information the shortest positive or negative path from a to c via b can directly be constructed . this circumstance is exploited by the shortest path algorithms and makes it unnecessary to search through all possible paths for the shortest one. positive cycles do not pose a problem because they would only elongate  an existing shortest path and therefore do not prevent the identification of the shortest path even if the search algorithm does not explicitly employ checks to avoid cycles. in contrast, a negative cycle, can transform a path from a node x to a node y into a walk from x to y  having the opposite sign. simple dla does not employ checks for cycles and such a walk could thus wrongly be reported as a shortest path if the real shortest path is longer or, even worse, if no such path exists. however, this can only happen at all for a given pair of nodes if the graph contains a negative cycle and if both a positive and a negative edge sequence between them is reported by the dla. in this case the shorter of the two is certainly a correctly identified path while the longer sequence could be a walk with repeated nodes/edges. the determined length of the latter can therefore only serve as a lower bound . a small modification by which a shortest path can often correctly be found even when a shorter walk exists is described in the following section.

note that a different problem is posed by negative edge weights in unsigned weighted digraphs: if a cycle is present whose sum of edge weights is negative then a shortest path algorithm is in danger of repeatedly traversing such a cycle thereby shortening the path length indefinitely. special shortest paths algorithms can detect such situations . however, negative cycles characterized by a negative sum of edge weights should not be confused with negative cycles considered here which arise by multiplication of edge signs.

double-label algorithm with check for cycles 
during each elongation step in the double-label algorithm the backward pointers can be used to check whether the current edge sequence closes a cycle and is thus a trail that can be discarded . this strategy has been employed by klamt et al.  <cit> . applied to figure 1b, the cycle in the trail a → b → c → f → b- would be detected and a negative path from a to b would thus not be reported by the dla. the modifications needed to extend single-source dla to dlacc are explained in more detail in additional file  <dig> .

dla with cycle check  is still polynomial in time, however, even a check for cycles cannot avoid that the dla may fail to detect the correct shortest paths. this is illustrated in figure 1c: in this expanded version of figure 1b, a negative path from a to b exists, namely a → g → h → c → f → b-, but it would not be identified for the following reason: when looking at the shortest paths to/from intermediate node c these are a → b → c+ and c → f → b- which together would include a cycle . therefore, dlacc would correctly discard this trail. yet, when looking at intermediate node g or h it becomes clear that the correct shortest negative path form a to b could be composed by adding the shortest positive path from a to g or h and the shortest negative path from there to b.

to summarize, for a given pair of nodes, the dlacc can miss existing paths or deliver longer path lengths than the real shortest if the following three conditions are fulfilled:  the graph has a negative cycle,  positive and negative paths between both nodes exist, and  there is a segment on a real shortest path that itself is not shortest, i.e. if a shortest signed path from a to b can be written as a → ... → x → ... → y → ... → b so that the segment x → ... → y is not a shortest path  from x to y.

dlacc with transitive inference 
the dlacc extension described in the following delivers correct results  also for figure 1c. note that for this extension the single-source dlacc must have been applied to every node in the graph. first of all, if the graph contains a negative cycle it is ensured that the dlacc will identify at least one negative cycle, namely one with shortest length in the whole network. as stated above, for a given pair of nodes, the dlacc may have missed existing paths or may have delivered longer path lengths if positive and negative paths between the start and the end node exist. the unsigned shortest path length will always correctly be identified during the dlacc . therefore, for all those pairs  of nodes between which at least a positive path  or a negative path  has been found with dlacc we check for the longer path length max  whether shorter paths can be constructed by concatenating shortest paths that run via any of the other nodes between a and b. this means that positive/negative shortest paths candidates are constructed by concatenating the appropriate positive/negative shortest paths from a to x and x to b where x can be any node except a or b ). if such a candidate – identified by transitive relationships – does not contain a cycle and is shorter than the previous shortest path, then the candidate replaces the previous one. the pseudo-code for this transitive inference is given in additional file  <dig> . in figure 1c, the negative path from a to b via g, h, c and f would now be identified: dla with cycle check delivers l+ =  <dig> and l- = ∞. we would therefore search for a smaller l-. we see that l+ =  <dig> and l- =  <dig>  hence, there might be a path with l- =  <dig>  using the backward pointers we have to check that the concatenated path does not involve a cycle  and then we have confirmed that l- =  <dig> 

unfortunately, the result of the dlacc with transitive inference in postprocessing  is, in general, still only an approximation of the true values as can be illustrated with the further extended graphs in figures 1d and 1e. in figure 1d the shortest negative paths from g or h to b would run via a . therefore, the shortest negative path from a to b can not be composed by concatenating shortest paths to/from any other nodes  resulting in l- = ∞ instead of  <dig>  in figure 1e, a negative path from a to b with length  <dig> exists which will be returned by the dlacc as the current shortest path. then, a negative path from a to b via i, j, k will be found by the transitive inference. as the latter path is shorter  it replaces the one found by dlacc. however, the real shortest path is even shorter , which means that the length of the found path is only an upper bound for the length of the real shortest path – and this holds for all values found by transitive inference. again, negative cycles are the cause that we can only give upper bounds . however, in realistic biological networks, it turns out that the results of the dlacc-ti are often close  to the exact values .

to summarize, the dlacc-ti is an approximative approach with polynomial complexity. it combines the output of the dlacc with a search for transitive relationships that can lead to the identification of paths missed during dlacc. the length it returns for each pair of nodes is exact for the minimum of l- and l+, and an upper bound for the other. the latter could be combined with the lower bounds that can be found with simple dla: if both bounds are finite and coincide then the dlacc-ti has found a shortest path.

exhaustive search and existence of negative cycles
hansen  <cit>  describes a branch-and-bound strategy that can be used to augment the dla to identify walks for which a new search has to be conducted to find the real shortest paths. however, in a first naïve implementation this strategy turns out to be very inefficient. in order to get the exact shortest paths length we apply an exhaustive traversal working in a depth-first manner and storing for each node the current shortest positive and negative distance to the start node. it is easy to implement, requires only a linear amount of memory and turns out to be still sufficiently fast for many of the networks that we have analyzed . pseudo-code for a single-source implementation  is given in additional file  <dig> .

however, exhaustive search may sometimes be impracticable because of combinatorial explosion of paths to be visited. as mentioned above, calculating shortest positive and negative paths in digraphs is only hard when negative cycles are present, i.e. if at least one scc of the graph is not balanced . whether this is the case is easy to decide by testing every scc with a simple linear-time algorithm for balance  <cit> . briefly, this algorithm employs a breadth-first search which determines whether or not between some pair of nodes two paths with different signs exist. if such paths can be found it can be concluded that a negative cycle exists and that the scc is unbalanced . alternatively, as mentioned above, the dlacc reports automatically whether a negative cycle exists in the network or not .

two-step algorithm : exact computation of path lengths combining exhaustive and simple search
the considerations above suggest a method to improve the exact calculation of shortest paths and cycles in signed digraphs . first of all, the unbalanced sccs in the graph are determined . then, separately for each unbalanced scc, the shortest paths and cycles between the nodes of the scc are calculated with an exhaustive search . with this information, the nodes and edges of the unbalanced sccs are then replaced in the following manner : first of all, each node x is split into two variants x and x'. all incoming edges to x from outside the scc are connected to x whereas the edges going out of the scc from x now start from x'. the node x is then connected with all other nodes y' of the scc with edges that carry the weight of the shortest positive and/or negative paths between the nodes x and y. in addition, a positive edge x → x' with weight zero is added for every pair of split nodes. the resulting transformed graph is free of negative cycles and e.g. the dla  can now be used to calculate the remaining shortest positive and negative paths . a split node is handled in the following way when reading the results: if the path starts at a split node then the x variant is chosen and if it ends at such a node the x' variant is selected. this two-step algorithm  relies on the fact that a path can pass through any given scc only once. the reason is that if a path would run through the same scc twice then the subpath between the two intersections with the scc would have to be part of this scc . a summary of this procedure is given in additional file  <dig> .

the strategy outlined above shows its largest effect if the network has several smaller sccs that are separated by regions without cycles. one particular favorable situation is the following: suppose there are two unbalanced sccs in the graph and the nodes of the second scc are reachable from the first scc . if an exhaustive search is applied to the whole graph, then the two sccs act like a large one because for every path that runs through the first scc all possible continuations through the second scc need to be followed. with the strategy above, both sccs can be independently preprocessed, which in this case can significantly decrease the number of paths that need to be explored.

implementation
the described algorithms for cycle and path enumeration and for shortest path computation in signed graphs have been implemented within the framework of cellnetanalyzer , a matlab toolbox with graphical user interface for network analysis in systems biology . cna calls these algorithms within several routines and they are also available via cna's application programming interface.

performance
below we discuss benchmark tests of the shortest signed paths and path/cycle enumeration algorithms. regarding the running times it has to be taken into account that they are implemented with the matlab scripting language to make them readily available for cellnetanalyzer. the performance of such scripts is usually significantly lower than when using compiled languages such as c or c++. however, even though the absolute running time should not be considered as state-of-the-art it does allow for a relative comparison of the different algorithms.

we used various test networks for evaluating the performance:

 t-cell: interaction graph of a recently published logical model for t-cell receptor signaling  <cit> .

 egfr: interaction graph of a model for egfr/erbb signaling constructed in our group  <cit> .

 t-cell+egfr: an artificial interaction graph  constructed by linking each node of the output layer of the t-cell network to three randomly selected nodes in the input layer of the egfr network.

 regulon db  <dig>   <cit> : this database contains information about transcription factors and their targets in e. coli. only evidence-based regulation rules where factor and target have associated blattner numbers and a definitive + or - sign are considered here. for the six transcription factors that consist of two subunits each subunit alone is considered to be able to exert the regulation.

 hippocampal ca <dig> neuron  <cit> : the interactions in this network represent signaling pathways and cellular machines of this neuron. only interactions with a definitive + or - sign are considered here.

 cancer signaling network  <cit> : this network contains genes and their products which have been found to be relevant during cancer development. only interactions with a definitive + or - sign are considered here.

the number of nodes and edges in the networks are shown in table  <dig> 

the running times when using elementary modes computation  are compared with those of the graph-algorithms . the number of edges refers to unique edges . the values for the combined network "t-cell+egfr" are mean and standard error over ten runs with different random connections between the two networks. an entry n/a indicates that the procedure quickly ran out of memory  because of a combinatorial explosion of paths or cycles. the platform used was matlab  <dig> b under  <dig> bit linux with an intel e <dig> processor.

enumeration of paths and cycles
cna performs breadth-first traversal for the enumeration of paths. in particular, options to restrict start- and end-nodes or the path length are provided as well as the possibility to calculate only those paths that run via certain nodes and/or edges. for performance measurements the calculation of input-output  paths is used. these paths connect input nodes  with output nodes . input and output nodes define the boundaries of the network model. it can be seen in table  <dig> that the enumeration of i/o paths is possible – partially in seconds – in medium-scale networks . as can also be seen elementary-modes calculation of the paths falls quickly behind breadth-first traversal when the network gets larger . note that the number of i/o paths do not simply correlate with the number of nodes and edges in the graph: although the regulon db network has many more nodes and edges than the egfr network, the latter contains many more i/o paths. in the ca <dig> neuron, although having fewer nodes and edges than regulon db, there are so many i/o paths that full enumeration becomes impractical.

for the enumeration of cycles, cna now uses johnson's algorithm. we briefly compare its performance to enumeration via elementary-modes  computation. it can be seen in table  <dig> that for cycle enumeration johnson's algorithm is more efficient, but em calculation is also practical as long as the number of cycles is not too high. again, the performance of em calculation deteriorates quickly for larger networks. more importantly, the running time of johnson's algorithm is known to scale linearly with the number of cycles whereas the scaling behavior of em calculation is still an open question.

shortest paths and cycles in signed  graphs
the following algorithms for computing the shortest positive/negative paths and cycles are implemented in cna:

• double-label algorithm with cycle check , optionally with transitive inference in postprocessing .

• exhaustive search with depth-first traversal .

• two-step algorithm .

we compared the performance of these algorithms for the all-pairs problem in the respective test networks . surprisingly, exhaustive search  is possible in five of the six networks. in the smaller networks , it requires less than one second and is even faster than dlacc-ti and tsa, since the latter need a certain demand of overhead. this becomes even more significant in the case of regulon db. this network contains only  <dig> cycles which indicates that the network has a rather simple  structure and explains why the exhaustive search is very fast despite the large number of nodes and edges.

the running times for the different algorithms are shown and the quality of the approximation with dlacc-ti is assessed. also, the number of usccs in the networks together with the number of nodes that they contain is shown. in the column "ti corrections" the number of shorter paths that can be identified with transitive inference after having run dlacc is given. the "remaining errors" column shows how many shortest paths  differ in their length compared to the exact results delivered by tsa or dft. when an algorithm ran longer than  <dig> hours it was considered impractical and terminated. therefore, no exact results were determined for the cancer signaling network and consequently the quality of the approximation with dlacc-ti cannot be given  for the ca <dig> neuron, the search depths in the two-step algorithm and in the exhaustive search were limited to length  <dig> to make calculations practicable. therefore some paths may have been missed. the longest shortest path identified for this network with the dlacc-ti is also of length  <dig>  the computational environment is the same as in table  <dig> 

the dlacc-ti algorithm delivering approximative results performs sufficiently well in all networks, in particular in the cancer signaling network where an exact result could not be obtained in reasonable time with exhaustive search or tsa. only the dlacc-ti can be applied here to get an approximative solution. in general, as can be seen by the number of corrections, transitive inference in postprocessing may strongly reduce the number of incorrect results delivered by the dlacc . furthermore, the number of remaining errors after dlacc-ti  is very low or even zero . we conjecture that this is a general property of biological signaling and regulatory networks and is due to the relatively low number of negative feedback loops .

the tsa best exploits situations where at least some sccs are connected as in the t-cell+egfr example. t-cell and egfr alone comprise only one single scc where tsa cannot lead to a better performance. however, tsa can also be favorable when the search depth is restricted in complicated networks because it is then sufficient to restrict the search depth only when traversing the unbalanced sccs. this is demonstrated for the ca <dig> neuron where the two-step algorithm with restricted dfs search achieves the same result as a restricted dfs search of the whole network but uses only one quarter of the computation time.

CONCLUSIONS
the enumeration of paths and cycles  and the calculation of shortest positive/negative paths in interaction graphs are fundamental issues in systems biology. enumeration of paths  and cycles  are standard problems in graph theory. we compared it with enumeration by elementary-modes computation, an algebraic technique borrowed from metabolic network analysis. it turns out that algorithms exploiting explicitly the graph structure  are superior to the more general elementary-modes approach which has been developed for hypergraphs where hyperedges  may connect more than two nodes.

apart from full enumeration of paths and cycles, we identified the calculation of shortest positive/negative paths and cycles in  interaction graphs as a key problem for many applications. in contrast to standard shortest path computation, this problem is np-complete and only very few algorithmic approaches have been described in the literature so far. we proposed here extensions and several new algorithms, for both computing exact results  and approximations . benchmarks in realistic biological networks showed that exact results can be obtained in networks with up to several hundreds nodes and interactions, a property which one would not expect in random networks. a class of even larger graphs can still be treated exactly by the two-step algorithm combining exhaustive and simple search strategies. finally, an approximative algorithm  for large networks  was introduced herein which seems to deliver results that are very close or even equal to the exact values. again, this phenomenon can probably be attributed to the particular topology of cellular signaling and regulatory networks which contain only a relatively low number of negative feedback loops.

all algorithms described herein have been implemented in the cellnetanalyzer framework  and are thus publicly available for biological network analysis.

authors' contributions
sk initiated this study. both authors contributed equally in developing, implementing and testing algorithms and in writing the paper. both authors read and approved the manuscript.

supplementary material
additional file 1
pseudo-code. pseudo-codes of shortest paths algorithms in signed directed graphs discussed in the main text.

click here for file

 additional file 2
adjacency matrices for transformed graph. adjacency matrices  for the transformed graph in figure  <dig> 

click here for file

 acknowledgements
this work was supported by the german federal ministry of education and research , by macs  and by the ministry of education of saxony-anhalt .
