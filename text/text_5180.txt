BACKGROUND
in the majority of the classification tasks found in the literature, a single class  is assigned to a given instance , and the problem classes assume a flat  structure. however, in a variety of real-world applications, classes are organized in a hierarchical structure, where they are specialized into subclasses or grouped into superclasses. these classification problems are known in the machine learning  literature as hierarchical classification , since instances are assigned to classes associated with nodes of a hierarchy. depending on the domain problem, a hierarchical class structure can be represented as a tree or as a directed acyclic graph .

in hierarchical problems with classes structured as a tree, each class node has only one parent node. in dag structures, however, a class node can have multiple parent nodes. therefore, in tree-structured problems, each class has a single depth value , because there is just one possible path between the root and any other node in the hierarchy. hierarchies structured as dags, on the other hand, allow for multiple depth values, since there may be more than one path between the root node and any other given hierarchical node. these characteristics should be considered in the development and evaluation of hierarchical classifiers. figure  <dig> depicts hierarchies structured as either trees or dags.
fig.  <dig> hierarchies structured as:  trees;  dags. the “ ·” symbol separates classes from superclasses/subclasses . adapted from  <cit> 



in this paper, we investigate a particular case of hc problems in which instances can be simultaneously assigned to many classes that belong to the same hierarchical level. these problems are known as hierarchical multi-label classification , and can be formally defined as:

definition
considering x the space of instances, the classification problem consists of finding a function  f to map each instance xi∈x to a set of classes ci∈c, with c the set of classes in the problem. the function f must respect the constraints of the hierarchy, and optimize a quality criterion.

to respect the constraints of the hierarchical structure means that when a class is predicted, all its superclasses should also be predicted. as quality criterion, one could chose to optimize que predictive performance of the classifier. this could consider, e.g., the distances between the predicted and true classes in the hierarchy, measured as the number of edges between the classes. considering that closer classes tend to represent more similar categories, one could weight incorrect classification proportionally to the number of edges between the true and predicted classes. the classification error then tends to increase with the number of edges between classes.

the are some problems related to assigning weights to the edges of the hierarchy, specially when its depth varies significantly for different leaf nodes. when this occurs, errors involving classes near the root are less penalized than errors involving classes located deeper in the hierarchy.

in this direction, lord et al.  <cit>  showed that when the path connecting two classes has to go through the root node, and one of the classes is located in a deeper level than the other, this does not necessarily mean that the deeper class provides more significant information than the class located in a higher level. thus, consider depth without considering class information may be a problem. because of this, in this manuscript we consider only the predictive performance of the classifiers as quality criterion, without assigning weights to edges in the hierarchy.

hmc problems can be solved by either local or global approaches. regarding local approaches, classification algorithms such as decision-tree induction or support vector machines are used to obtain a hierarchy of classifiers, which are later used to classify unlabeled instances following a top-down strategy  <cit> . according to silla et al.  <dig>  <cit> , different strategies can be used in the local approach: one local classifier per node , one local classifier per parent node , and one local classifier per level . while lcn induces one binary classifier for each class  <cit> , lcpn induces a multi-class classifier for each parent node, in order to distinguish between its subclasses  <cit> . the lcl strategy induces one multi-label classifier for each hierarchical level, where each one predicts the classes of its associated level  <cit> .

local-based strategies can be seen as particular cases of ml reductions. we call reductions the techniques used to transform more complex problems into well-studied ml problems. these simpler problems are solved using any existing learning algorithm. these solutions to the simpler problems are then used to solve the original problem  <cit> .

the global approach, differently from the local one, trains only one classifier to cope with all hierarchical classes. the classification of new instances is performed in just one step  <cit> . because only one classifier is used, the specificities of the classification problem must be considered. thus, it is not possible to use traditional classification algorithms, unless they are adapted to cope with class hierarchies.

protein function prediction is a typical case of hmc, since protein functions are hierarchically organized. this is a very relevant classification task, since almost all functions related to cell activity are performed by proteins. they can have a great variety of forms and perform functions such as biochemical reactions, cell signaling, structural, and mechanical functions  <cit> .

in this paper, we approach the protein function prediction hmc problem with a new reductionist method termed hierarchical multi-label classification with local multi-layer perceptrons . a very preliminary version of hmc-lmlp has been reported in  <cit> , where we associated one multi-layer perceptron  to each hierarchical level, and used the instances as input to the mlp associated with the first hierarchical level. from the second level onwards, each mlp was fed only with the output provided by the previous mlp. differently from the version in  <cit> , the method proposed in this paper uses the output from the mlp trained for level l as part of the input of the mlp for level l+ <dig>  thus, the outputs from the mlp associated with level l are now used to augment the feature vectors that are employed to train the mlp for level l+ <dig>  the idea is to guarantee that label dependencies between classes are taken into account, and also to allow the mlp classifiers to discover these dependencies by themselves.

two other variants of hmc-lmlp, reported in  <cit> , are considered as baseline approaches to verify whether hmc-lmlp is capable of significantly improving classification accuracy. in the first variant, the true labels of the training instances are used as part of the input to train each mlp. therefore, when training an mlp for level l+ <dig>  the feature vector is augmented with its true classes for level l. this modification forces the label dependencies between classes to be taken into account, with these dependencies being provided by the training instances . the second variant ignores the labels associated with the classes to augment the feature vectors. this can be considered as a baseline version that allows us to examine whether the use of the labels to augment the feature vectors results in an improved classification performance.

to the best of our knowledge, our study is the first one that employs neural networks for hmc function prediction problems within the lcl strategy. a competitive neural network was proposed in  <cit>  and applied to dag structured hierarchies, while in  <cit>  neural networks were used in a lcpn strategy specific for hierarchies structured as trees. in  <cit> , stacked extreme learning machines  <cit>  neural networks were used for classification. structured classification problems, which include hierarchical classification of protein functions, were addressed by  <cit>  using a decision tree-based method.

our contribution is centered in the funcat hierarchy  <cit> , a famous taxonomy for the functional organization of proteins of prokaryotic and eukaryotic origin. the taxonomy is a tree with up to six levels in depth, consisting of  <dig> main functional categories that cover functions like cellular transport, metabolism, and communication. figure  <dig> illustrates a small portion of the funcat taxonomy.
fig.  <dig> part of the funcat hierarchical taxonomy. adapted from http://www.helmholtz-muenchen.de/en/ ibis




related work
typically, the protein function prediction problem is solved by using homology, comparing proteins through some alignment tool, and also comparing protein folds and biding sites  <cit> . this section discusses some recent hmc methods reported in the literature that make use of ml for protein and gene function prediction.

vens et al.  <cit>  investigated methods based on predictive clustering trees : the global clus-hmc method, which trains only one decision tree considering all the classes in the hierarchy, the local clus-sc, which trains a separated decision tree for each class, and ignores the relationships between classes, and the local clus-hsc, which also trains a decision tree for each class, but explores the relationships between them. in another study, schietgat et al.  <cit>  combines the clus-hmc method using bagging.

alves et al.  <cit>  proposed a global method using artificial immune systems  for the generation of hmc rules. the method is divided into two basic procedures: sequential covering  and rule evolution . the sc procedure iteratively calls the re procedure until all  training instances  are covered by the discovered rules. the re procedure evolves classification rules  that are used to classify the instances. the best antibody is added to the set of discovered rules.

an ensemble of lcn-based classifiers was proposed by valentini  <cit> , where each classifier gives the probability that an instance belongs to a class. a combination phase then estimates the consensual probability. in  <cit>  and  <cit> , this method was modified to modulate relationships between the predictions of the classes and their descendants.

a global-based method using ant colony optimization  was proposed by otero et al.  <cit>  to discover classification rules in the format if …then …. the method uses a sequential instance-covering procedure to create rules that cover the majority of the instances. an empty set of rules is initialized, and rules are added to the list while the number of instances not covered by any rule is larger than a given threshold.

cesa-bianchi and valentini  <cit>  investigate the synergy between different lcn-based strategies applied to protein function prediction in the funcat hierarchy. kernel-based data fusion tools and ensemble algorithms were integrated with cost sensitive hmc methods  <cit> . synergy was defined as the improvement in the prediction accuracy, considering any evaluation measure, due to the use of concurrent learning strategies. synergy is detected if the combination of two strategies achieves better correct classification rates than the average of the correct classification of the two strategies used individually  <cit> .

the work of stojanova et al.  <cit>  reports a method which considers self-correlation in hmc, i.e., the statistical relationships between the same variable on different but related instances. the method is called network hierarchical multi-label classification , and builds a generalized form of decision trees using the pct framework, like clus-hmc. during training, nhmc uses both the features of the instances, and the self-correlations between instances. the self-correlations are modeled as a network, which is exploited by the method during the learning phase.

yu et al.  <cit>  propose a method to predict protein function using incomplete hierarchical labels. the idea is to take the hierarchical and flat  similarities between functions and define a combined similarity between the labels. this similarity, together with the known labels, is used to estimate the missing functions of the proteins in the hierarchy. afterwards, the method uses information about the interactions between proteins to predict their functions. in their study, the authors simulated the situation in which labels are missing in the hierarchy by randomly masking the leaf functions of a protein.

in this work, four methods reviewed in this section were used as baselines during the experimental analysis: the global decision tree based method clus-hmc, and its local reductionist variants clus-hsc and clus-sc  <cit> ; the ant colony optimization based method hmant-miner  <cit> , which is a global method that achieved competitive results with clus-hmc; and the method proposed by stojanova et al.  <cit> , which provides further information about the interaction among proteins.

these methods were chosen because they were evaluated using the same datasets we use. also, they provide the same output format as hmc-lmlp, and the executables are freely available. therefore, we were able to compare the prediction performance of these methods in detail.

the remainder sections of this paper are organized as follows. “methods” section presents the details of the new proposed hmc-lmlp variation, together with a brief description of its previous variants, and the methodology employed for the empirical analysis. the results are presented in “results” section, where the proposed method and its variants are compared with state-of-the-art methods for hmc on  <dig> protein function prediction datasets structured as trees. in “discussion” section we present the analysis and discussion on the results, and also perform an analysis to identify which functional combinations are predicted well and which ones are not. finally, we summarize the conclusions and suggest topics for future work in “conclusions” section.

methods
the idea behind hmc-lmlp is to divide the learning process into a number of steps, aiming at learning a complex model through the combination of fewer simpler models, which are learned sequentially. this strategy is known in the ml literature as reduction, which converts a problem of minimizing a loss function into a problem of minimizing another, simpler loss function  <cit> . in our case, by reducing the problem, each model in sequence is forced to learn something different from the previously trained models, breaking down the complex learning process into simpler processes.

in hmc-lmlp, the reductionist approach works by learning mlp networks sequentially, one for each level of the class hierarchy. each mlp is responsible for extracting local information from the instances at each level, which we believe to be useful in the classification of unlabeled instances. since hmc problems are usually very complex, our hypothesis is that different patterns can be extracted from the instances in the different hierarchical levels. whereas many different classification strategies could be employed in a similar architecture, we decided to use neural networks because of the simplicity in associating a class per output neuron. therefore, obtaining a multi-label prediction for an instance is carried out in a straightforward fashion.
fig.  <dig> hmc-lmlp-predicted architecture. a training an mlp at the first level; b using the output of the first mlp to augment the feature vector of the instances that are part of the training set of the mlp at the second level; c using the output of the second mlp to augment the feature vector of the instances that are part of the training set of the mlp at the third level



initially, an mlp is associated with the first hierarchical level. in order to allow the neural network to predict a set of labels, each output neuron is associated with one class. after the mlp has been trained for the first hierarchical level , a second mlp is associated with the next level of the hierarchy . the input for this network is now the instances feature vectors, augmented with the output provided by the previously trained mlp. thus, each mlp from the second level onward uses the augmented feature vectors of those instances belonging to its respective associated level as inputs. the feature vectors that are used to train an mlp network at level l are augmented with the output from the mlp trained at level l− <dig> 

the neural network associated with the first level is trained with all training instances , since all instances are assigned to the classes from the first hierarchical level. at the second level, the mlp input is now the training instances that are assigned to the classes belonging to level  <dig> , combined with the output provided by the previously trained mlp. the advantage of using the augmented feature vector for training each mlp is the incorporation of label dependency in the learning process. a similar approach was proposed in , where labels were used to augment the feature space of the instances in order to enable binary classifiers to discover existing label dependency by themselves.

the training of the neural network at the third level follows the same procedure adopted for the second level . this supervised incremental greedy procedure continues until the last level of the hierarchy is reached. recall that when training an mlp network for level l, the neural network associated with level l− <dig> is used only to provide the inputs that will augment the feature vectors of the training instances for the mlp network associated with level l. mlps associated with previous levels are not re-trained, because their training has already occurred in the previous steps.

for convenience, from now on the new version proposed here will be referred as hmc-lmlp-predicted, considering that it employs the classes predicted by an mlp in one level to complement the feature vector of the instances that are part of the training set of the mlp in the subsequent level.

also for convenience, from now on when we want to refer to all hmc-lmlp variants at the same time, we are going to use only the term hmc-lmlp.

algorithms  <dig> and  <dig> show the pseudocodes for the hmc-lmlp-predicted training and testing procedures. in algorithm  <dig>  φ and φ′ represent, respectively, the sigmoidal logistic activation function and its derivative regarding the argument. the gradients are represented by δ, and Δ is used to denote the update to be applied to the synaptic weights.



hmc-lmlp variants
here we briefly present the other three previously proposed variants of hmc-lmlp, which will be considered baseline methods in the experiments. the very preliminary version  <cit>  will be henceforth named hmc-lmlp-labels, since it makes use of the classes predicted in one level as the single input to the mlp responsible for the predictions in the subsequent level. thus, the instances feature vectors are used only to train the mlp associated to the first level.

the difference between hmc-lmlp-predicted and hmc-lmlp-labels, although subtle, is very important. from the second level onward, hmc-lmlp-labels does not consider the instances attributes anymore. only the predictions made at the previous level are used as input to the current mlp. thus, there is no complementation of the feature vectors.

the other variants  <cit>  will be called hmc-lmlp-true and hmc-lmlp-nolabels. the first one employs, at each level, instead of predictions, the true labels of the instances from the previous level to complement the feature vectors. to treat hmc-lmlp-true as a baseline may sound counterintuitive, since using true labels seems to be better than using predictions. however, the idea here is to verify whether the neural networks are capable of detecting the class relationships by themselves, and verifying if the knowledge learned by an mlp can be useful in the training of the subsequent mlp. this idea was previously applied in the context of non-hierarchical multi-label classification  <cit> . in hmc-lmlp-true, on the other hand, the neural networks do not learn the class relationships by themselves, since they are fed a priori with the training class labels.

the hmc-lmlp-nolabels variant uses only the original feature vectors to train the mlp at each level. thus, an individual mlp is trained for each hierarchical level without using neither true nor predicted class labels to augment the feature vectors.

computing final predictions
in the test phase of hmc-lmlp-predicted and hmc-lmlp-true , a top-down strategy is employed. the test instance is given as input to the mlp associated to the first level, and the output from this mlp is used to augment the feature vector <dig>  this augmented feature vector is then used as input to the mlp at the second level, whose prediction values will, once again, augment the input for the mlp at the third level. this procedure continues until the last mlp is reached. as previously mentioned, in both the training and test phases of hmc-lmlp-predicted, the augmentation of feature vectors is non-incremental, i.e., the feature vector being fed into an mlp associated with level l is only augmented by the output from the mlp associated with level l− <dig>  the same is true for hmc-lmlp-true, with the difference that the true class labels are used in the training phase and the predicted classes are used in the test phase. in hmc-lmlp-nolabels, each mlp associated to each level is fed with the instances classified in classes belonging to the level. each mlp then gives independent predictions for the instances at each level. in hmc-lmlp-labels, only the mlp associated with the first level is fed with instances. from the second level onwards, each mlp is fed only with the output provided by the previous mlp.

to compute the final prediction for a test instance – considering all hmc-lmlp variants – we apply thresholds to the output prediction values from each mlp to define the predictions for each level. if the output of a neuron j is equal to or larger than a threshold, the instance is classified in class cj. as final classification, hmc-lmlp outputs a binary vector v of size |c|, where c is the set of all classes. if the output value of neuron j is equal to or larger than a given threshold, the value  <dig> is assigned to position vj. otherwise, the position is set to  <dig>  different threshold values result in different predicted classes. because we use the logistic sigmoid function as activation function in the neurons, the output values range from  <dig> to  <dig>  we can then use threshold values in the interval  <cit> . larger threshold values lead to small number of classes predicted, and smaller threshold values lead to higher number of classes predicted. during the classification process, the output values that are passed from network to network are not the values obtained after the application of a threshold . the regular output values from the previous-layer neurons, which are within  <cit> , are not modified. the application of the threshold is only performed to compute the final predictions.

considering all variations, after hmc-lmlp has provided the final predictions, a post-processing phase is employed to correct eventual classification inconsistencies, i.e., when a subclass is predicted without its superclass. this may occur because each neural network makes its own predictions, and even though these individual mlps make use of data from the previous levels, this does not guarantee that the superclasses of all predicted subclasses have also been predicted. this problem is intrinsic to the lcl strategy  <cit> . the post-processing guarantees that the final predictions are consistent with the hierarchy.

we use a very simple procedure to correct inconsistencies in the predictions. the post-processing phase simply removes those predictions that do not have predicted superclasses.



computational complexity
in hmc-lmlp-predicted and hmc-lmlp-true, each mlp has a time complexity of o, with wl the number of weights and biases of the mlp at level l. assume that a is the number of attributes in the dataset, hl is the number of hidden neurons of the mlp at level l, and ol is the number of output neurons of the mlp at level l. we can then define w <dig> as ×h1+×o <dig>  from the second level onwards, wl is defined as ×hl+×ol. thus, the training cost of each neural network at each level l in hmc-lmlp is then o, with ml being the number of training instances assigned to classes belonging to level l, and n the number of training epochs.

in hmc-lmlp-nolabels, the computational cost is naturally lower, since the class labels are not used to augment the feature vectors. for hmc-lmlp-labels, the computational cost in the first level considers only the number of features of the data. from the second level onwards, only the number of classes is considered, since the classes are the unique input of the mlp networks.

hmc literature methods
besides the previous proposed variants, we compare hmc-lmlp-predicted with the following hmc methods used for protein function prediction: pct-based methods clus-hmc, clus-hsc, clus-sc  <cit> , and hmant-miner  <cit> . these methods are briefly described next: 
clus-hmc: global-based method that builds a single decision tree to cope with all classes simultaneously;

clus-hsc: lcn-based method that applies a top-down strategy to induce a decision tree for each hierarchical class considering the hierarchical relationships;

clus-sc: lcn-based method that induces one decision tree for each hierarchical class without considering hierarchical relationships;

hmant-miner: global-based method that uses concepts from aco to generate hierarchical multi-label classification rules.



besides the aforementioned methods, we also compared our results with those provided by the method of stojanova et al.  <cit> , namely nhmc . differently from the other methods, nhmc considers the interaction among proteins. this interaction is calculated based on the class label vectors associated to each protein. nhmc is built within the clus-hmc framework, and also trains only one decision tree to cope with all classes simultaneously.

datasets
in the experiments, we used ten freely available <dig> protein function prediction datasets. the attributes of the datasets are related to issues like phenotype data and gene expression levels. the function are organized in a tree, according to the funcat taxonomy.

the datasets are divided in subsets: training, validation and testing. table  <dig>  <cit>  presents their main characteristics, regarding to number of classes and instances. we present a brief description below, but more detailed biological description of each dataset can be found in  <cit>  and in the corresponding references. 
 <dig> - seq: has attributes related to statistics obtained directly from the amino acid sequences, such as amino acid rates, sequence length and molecular weight. the atributes are mostly real value numbers, and were obtained using protparam  <cit>  or taken from mips  <cit> ;


 <dig> - pheno: has attributes related to phenotypical data. they represent knock-out mutants missing in the sequence, regarding their growth or lack of growth. the data was obtained from databases such as mips  <cit>  and triples  <cit> . the attribute values are all discrete, and the dataset is sparse;

 <dig> to 10: has real value attributes obtained using microarray chips to test the expression levels of genes across genomes  <cit> ;



we performed a pre-processing step before running hmc-lmlp over these datasets. we used the one-attribute-per-value strategy to convert all nominal attribute values into numeric values. in this strategy, an attribute with k categories is transformed into k binary attributes. in this study, we used − <dig>  and  <dig>  for each binary attribute. these are more suited for training neural networks  <cit> . the attributes were then standardized . additionally, all missing values for nominal and numeric attributes were replaced, respectively, by their mode and mean values.

evaluation method
as discussed in “methods” section, the outputs of hmc-lmlp for each class are real values in the interval  <cit> , which is also true for the literature methods. thus, a threshold value was employed to compute the final predictions from all methods. for the classification of an instance, if the output value for a given class is equal to or larger than the threshold, the instance is assigned to the class. otherwise, it is not.

to choose an “optimal” threshold value is difficult, because low values lead to many predictions to each instance, resulting in high recall and low precision. on contrary, large values result in very few predictions, leading to high precision and low recall. some studies try to find the “optimal” threshold value by modeling a threshold function as a linear function  <cit> . others try to tune the threshold value by optimizing a given evaluation measure, or searching for the global maximum of the evaluation measure by using an optimization strategy  <cit> .

in this work, we dealt with the problem of choosing a threshold by using precision-recall curves   <cit> . to produce a pr-curve for a classification method, thresholds in the interval  <cit>  are applied to their outputs, resulting in different values of precision and recall , one for each threshold used. the union of these points form a pr-curve, and the area under the curve is calculated. different methods can be compared based on their areas under the pr-curves.

the calculation of the area under the pr-curve is performed by the interpolation of the precision-recall points   <cit> , and posterior connection. if we just connect the points without interpolation, the area below the curve would be artificially increased. here, we used three variations of pr-curve: the area under the average pr-curve ) and the weighted average of the areas under the individual  pr-curves .

the definitions of au and auprc¯w are given below  <cit> . the values of measures are in the interval  <cit> . the index i, in these equations, ranges from  <dig> to |c|. the number of true positives, false positives, and false negatives, are represented, respectively, by tp, fp, and fn.

area under the average pr-curve
after applying a threshold, a pr-point  is obtained through eqs.  and . these equations are the micro-average of precision and recall. 
  <dig> prec¯=∑itpi∑itpi+∑ifpi 

  <dig> rec¯=∑itpi∑itpi+∑ifni 

weighted average of the areas under the individual pr curves
we can obtain the weighted average of the areas under each pr-curve for each class separately. after calculating the auprci for each class, we compute the auprc¯w through eq. . 
  <dig> auprc¯w=∑iwi×auprci 

in eq. , we use wi to weight the contribution of each class given its frequency, i.e., wi=vi/∑jvj, with vi the ci’s frequency in the dataset  <cit> . we also set all weights to be equal to 1/|c|. in this case, we refer to the measure as auprc¯.

in hierarchical classification, it is important to give different weights to classes according to their level in the hierarchy. in protein function prediction, nodes located at deeper levels represent more specific protein functions, and thus are more frequent in the dataset. nodes located at higher levels represent more general functions, thus being less frequent. it is then reasonable to consider that more frequent classes are more important depending on the application.

the significance of the results was verified using the non-parametric friedman and nemenyi statistical tests, more suitable when comparing many classifiers using several datasets  <cit> . the confidence level of  <dig> % was adopted. as in  <cit> , 2/ <dig> of each dataset were used to train the classifiers , and 1/ <dig> for test. we used exactly the same partition provided by vens et al.  <dig>  <cit> .

parameters
we investigate the performance of hmc-lmlp using the conventional back-propagation algorithm  <cit> . the hmc-lmlp parameters were optimized using the eisen validation dataset. this dataset was selected because it was one of the datasets where clus-hmc and clus-hmc-ens achieved their best performances, and also because it has a relatively small number of attributes, which makes it possible to run several experiments in a reasonable amount of time without feature selection. the following parameters were optimized: 
 number of neurons in each hidden layer. we considered all mlps, from the one associated to the first level, to the one associated to the last level;

 parameters of the backpropagation algorithm: learning rate and momentum constant;

 initial values of the neural network’s weights.



the number of hidden neurons of the mlps associated to each level was gradually decreased as the corresponding level becomes deeper. this was performed to avoid overfitting, because as we go deep in the hierarchy, the number of training instances becomes smaller. also, we try to reduce parameter selection influence by setting the number of hidden neurons as a fraction of the number of attributes used as input. we used the validation dataset to execute hmc-lmlp with different values for each of the parameters. we could not use all sets of values because of the large number of possibilities.

for the initial weights of the neural networks, parameter optimization showed higher initial values increased the chance of overfitting, resulting in a better performance on frequent classes but a worse overall prediction performance. the initial weights were varied by randomly selecting them initially from , but gradually increasing the range to . regarding the number of neurons, a limited number of neurons for each hidden layer was tested. we gradually decreased these number from  <dig> / <dig> / <dig> / <dig> / <dig> / <dig>  neurons in each layer until  <dig> / <dig> / <dig> / <dig> / <dig> / <dig> . these numbers represent the fraction of the number of network attribute inputs. thus, if a mlp has  <dig> inputs,  <dig>  means that it has  <dig> hidden neurons.

we started our experiments with the same values used in the weka machine learning toolkit  <cit>  for learning rate and momentum. the learning rate is set to  <dig>  and the momentum to  <dig> . gradually decreasing these values, we noticed that the neural networks became less prone to overfitting as these values decreased. the final parameters obtained for hmc-lmlp after the preliminary experiments are listed next. 
number of hidden neurons in each level :  <dig> / <dig> / <dig> / <dig> / <dig> / <dig> ;

backpropagation learning rate and momentum constant for the hidden and output layers: { <dig> , <dig> } and { <dig> , <dig> }, respectively;

mlps initial weights: within ;



RESULTS
this section presents the experiments that were carried out to compare the prediction performance of the hmc-lmlp-predicted with its previous variants  <cit>  and the literature hmc algorithms, namely, clus-hmc, clus-hsc, clus-sc, and hmant-miner. we compared those methods based on their overall prediction performance in all datasets, and also compared their performance in specific classes and levels of selected datasets. in the tables showing results, we refer to the hmc-lmlp variants as labels, true and nolabels , and predicted . besides the evaluation measures, we also performed an analysis to verify which protein functions are well predicted by hmc-lmlp-predicted, and also identify which ones are not.

in the experiments using hmc-lmlp, the results are the mean and standard deviation over  <dig> executions, each with randomly initialized weights. given that hmant-miner is a stochastic method, we also executed it  <dig> times and show the mean and standard deviation over all executions. clus-hmc, clus-hsc, and clus-sc are deterministic algorithms and thus need to be executed only once.

when training hmc-lmlp, at each epoch we calculated its au for the validation dataset. when this value stops increasing for  <dig> epochs, we stopped the training process and tested the best neural networks in the test dataset.

in addition, we also compared our results with the results provided by network clus-hmc , a clus-hmc variation proposed by stojanova et al.  <cit> . this variation considers the protein features and additionally uses protein-protein interaction networks.

overall comparisonstable  <dig> 
au, auprc¯w and auprc¯ values


 <dig> 
 <dig> 
 <dig> 
 <dig> 
 <dig> 
 <dig> 
 <dig> 
 <dig> 
 <dig> 
 <dig> 
 <dig> 

 <dig> 
 <dig> 
 <dig> 
 <dig> 
 <dig> 
 <dig> 
 <dig> 
 <dig> 
 <dig> 
 <dig> 

 <dig> 
 <dig> 
 <dig> 
 <dig> 
 <dig> 
 <dig> 
 <dig> 
 <dig> 
 <dig> 
 <dig> 
 <dig> 
 <dig> 
best results are highlighted in bold face


table  <dig> average rankings according to the friedman statistical test

au
auprc¯w
auprc¯



according to nemenyi test, hmc-lmlp-predicted outperformed clus-hsc, clus-sc, hmant-miner, and hmc-lmlp-labels with statistical significance considering both the au and auprc¯w measures. no statistically significant differences were detected between the hmc-lmlp variants and clus-hmc. considering the auprc¯ measure, no statistically significant differences were detected among hmc-lmlp-predicted and the other methods.

the critic diagrams presented in fig.  <dig> show the nemenyi test results for the pairwise comparisons of all classifiers. in this kind of diagram, we connect the methods where no statistically significant results were detected. the auprc¯ measure seemed to favor the pct local-based methods, since clus-hsc was statistically superior to hmc-lmlp-labels, hmc-lmlp-true, hmc-lmlp-nolabels and hmant-miner. recall that this measure considers all classes equally important.
fig.  <dig> results of the nemenyi statistical test


fig.  <dig> pr-curves of hmc-lmlp-predicted, clus-hmc, clus-hsc, clus-sc, and hmant-miner



comparisons considering specific classes and levels
in this section, we compared the hmc methods considering specific classes of the hierarchy, and also evaluate the methods level by level. we do so in order to examine their behavior when predicting classes in different hierarchical levels. we perform two sets of comparisons. first, we compared the methods to verify whether the use of the predictions to augment the feature vectors improved the results in specific classes and levels. for this purpose, we selected the eisen dataset, which is the dataset where hmc-lmlp-nolabels achieved its best classification results  considering the au measure. we selected, for each level, the three classes where hmc-lmlp-nolabels achieved its best results, going down until the fourth level because in deeper levels the classes have a very low frequency in the training dataset . the results for the eisen dataset are shown in table  <dig>  the best absolute values are highlighted in bold. we did not consider the classes from the first level because the hmc-lmlp variants are different from each other only from the second level onwards.

 <dig> 
 <dig> 
 <dig> 
 <dig> 
 <dig> 
 <dig> 
 <dig> 
 <dig> 
 <dig> 
 <dig> 
 <dig> 
 <dig> 
 <dig> 
 <dig> 
best results are highlighted in bold face



in a second set of comparisons, we analyzed the results provided by hmc-lmlp-predicted and the literature methods, i.e., clus-hmc, clus-hsc, clus-sc, and hmant-miner. as clus-hmc is the state-of-the-art method so far, we performed the comparisons in the seq dataset, in which clus-hmc showed the best results considering the au measure . we selected, in each level, the three classes where clus-hmc obtained its best results. we adopted the same procedure applied in the eisen dataset, analyzing until the fourth level of the hierarchies when comparing performances in specific classes, but this time adding the results provided for the first hierarchical level. these results are presented in table  <dig>  with the best absolute values highlighted in bold.

 <dig> 
 <dig> 
 <dig> 
 <dig> 
 <dig> 
 <dig> 
 <dig> 
 <dig> 
 <dig> 
 <dig> 
 <dig> 
 <dig> 
 <dig> 
 <dig> 
 <dig> 
 <dig> 
 <dig> 
 <dig> 
best results are highlighted in bold face



comparison with nhmc considering protein-protein interactionstable  <dig> 
auprc¯ values for hmc-lmlp variations and nhmc


 <dig> 
 <dig> 
 <dig> 
 <dig> 
 <dig> 
 <dig> 
 <dig> 
 <dig> 
 <dig> 
 <dig> 
best results are highlighted in bold face



stojanova et al.  <cit>  also reported au values obtained by nhmc in seven of the datasets used here. the reported values are the ones obtained using the dip network with α= <dig> . table  <dig> shows the comparison of the hmc-lmlp results with their reported nhmc results.au values of hmc-lmlp variations and nhmc


 <dig> 
 <dig> 
 <dig> 
 <dig> 
 <dig> 
 <dig> 
 <dig> 


analysis regarding the predicted functions
tables  <dig> and  <dig> present, respectively, the results for the best and worst predicted functions by hmc-lmlp-predicted, together with the results obtained by clus-hmc. by best predicted functions, we mean the functions where hmc-lmlp-predicted obtained an auprc value higher than clus-hmc in nine or more datasets. by worst predicted functions, we reported the functions where clus-hmc performed better than hmc-lmlp-predicted in nine or more datasets. in tables  <dig> and  <dig>  we give the descriptions of the these best and worst predicted functions. these descriptions were obtained from http://mips.helmholtz-muenchen.de/funcatdb/.


discussion
the results presented in table  <dig> show that all hmc-lmlp variants outperformed the two local versions of the pct-based methods clus-hsc and clus-sc by a large margin, considering the absolute values of the evaluation measures. the variants hmc-lmlp-predicted, hmc-lmlp-true, and hmc-lmlp-nolabels achieved better results than the global methods clus-hmc and hmant-miner for the vast majority of the datasets. moreover, hmc-lmlp-predicted improved the results achieved by versions hmc-lmlp-true and hmc-lmlp-nolabels, which confirms that the predictions at one level were indeed useful in the learning process of the subsequent level.

it is interesting to see how the use of the predictions  instead of the true classes  improved the algorithm’s classification performance. this is an indication that the neural networks were capable of better exploring the relationships between classes at each level when making use of the predictions, and that these relationships were learned during the training process.

the results shown in table  <dig> also suggest that the variants hmc-lmlp-predicted, hmc-lmlp-true, and hmc-lmlp-nolabels achieved their best results in the most frequent classes in the hierarchy. as we can see, although the pct-based methods performed better in the auprc¯ measure, the performances of all methods were more similar in this measure, which gives equal importance to all classes. given that the other two measures consider the frequencies of the classes in the datasets, the results suggest that hmc-lmlp performed better in the most frequent classes. for the auprc¯w measure, the evaluation decreases the importance of the auprc values obtained in less frequent classes and increases the importance of more frequent classes.

according to the results from table  <dig>  the use of the predictions improved the classification performance in the majority of the classes. hmc-lmlp-predicted also achieved the best correct classification rates when compared to the state-of-the-art methods. by analyzing the per-level au values, all methods had a poor performance, specially from the third level onwards. nevertheless, note that hmc-lmlp-predicted outperformed the other hmc-lmlp variants.

another feature that can be seen in table  <dig> is that, from the third level onwards, the hmc-lmlp variants were outperformed  by the literature methods. this confirms the results observed in table  <dig>  where hmc-lmlp obtained the best auprc¯w values, indicating that the best results were achieved in the most frequent classes. the very low frequency of the classes located at the deepest levels may explain the hmc-lmlp performance in these levels.

it is also possible to observe how much hmc-lmlp-labels underperforms compared to the remaining methods, considering the deepest classes in the eisen dataset. this behavior was expected, since hmc-lmlp-labels does not employ the original attributes of the instances in the training process of the neural networks from the second level onwards, but only the predictions.

according to table  <dig>  hmc-lmlp-predicted provided the best results in all analyzed classes. in the per-level evaluation, we can see that hmc-lmlp-predicted obtained the best results in the top levels of the hierarchy, while the best performances in the deepest levels were obtained by the pct-based methods. this is another evidence that hmc-lmlp performed better in the most frequent classes, as confirmed by its better overall results considering the auprc¯w evaluation measure.

considering the comparisons with network clus-hmc , hmc-lmlp-predicted provided the best results in the majority of the cases. these results are particularly interesting given that our method makes use of features information only. we believe we could extend hmc-lmlp so it also considers protein-protein interactions, paving the way for a further increase in predictive performance.

regarding the functions predicted, we can see by table  <dig> that, for the best functions predicted by hmc-lmlp-predicted, the differences between the auprc values obtained by hmc-lmlp-predicted and clus-hmc are much higher than the ones observed for the functions where clus-hmc performed better than hmc-lmlp-predicted . this explains the best overall au values obtained by hmc-lmlp-predicted. although clus-hmc performed better in more classes, the individual auprc values for the classes where hmc-lmlp-predicted performed better are much higher in favor of hmc-lmlp-predited.

in figs.  <dig> and  <dig>  we show the hierarchical positions of the best and worst predicted classes by hmc-lmlp-predicted. these figures show the complete subtrees where the classes are located. we highlighted the classes shown in tables  <dig> and  <dig>  since the subtrees represent the transitive closure  of the classes presented in tables  <dig> and  <dig> 
fig.  <dig> subtree with best predicted functions by hmc-lmlp-predicted in  <dig> % of the datasets

fig.  <dig> subtree with worst predicted functions by hmc-lmlp-predicted in  <dig> % of the datasets



by analyzing fig.  <dig>  we can have some insights about the prediction behavior of hmc-lmlp-predicted. we can see that, in  <dig> % of the datasets investigated, it obtained best results than clus-hmc mainly in the classes closer to the root. if we look at fig.  <dig>  we see that the functions where clus-hmc performed better than hmc-lmlp-predicted in  <dig> % of the datasets are mainly located at deeper levels. this confirms the results we’ve been observing so far.

we also performed an analysis considering the functions better predicted in six of the ten datasets. in fig.  <dig>  we show the subtrees with the functions where hmc-lmlp-predicted obtained better auprc values than clus-hmc. in fig.  <dig>  we present the functions where clus-hmc performed better than hmc-lmlp-predicted. we can see from these figures that the neural networks behavior remains the same, with the best predicted functions spread across the levels closer to the root, while the worst predicted functions more concentrated at the deepest levels, down until the fifth. again, recall that figs.  <dig> and  <dig> show the transitive closure of the best and worst hmc-lmlp-predicted predicted functions. thus, to improve visualization, we deleted the nodes which are not in the set of the best and worst predicted functions.
fig.  <dig> subtree with best predicted functions by hmc-lmlp-predicted in  <dig> % of the datasets

fig.  <dig> subtree with worst predicted functions by hmc-lmlp-predicted in  <dig> % of the datasets



another characteristic that can be observed in the figures showing the subtrees is that hmc-lmlp-predicted obtained its best results in complete paths starting at the root node. for example the paths  <dig> . <dig>  and  <dig> . <dig>  the path  <dig> . <dig>  particularly, contains the classes where hmc-lmlp-predicted obtained its best auprc values  <dig>  ,  <dig>   and  <dig>  .

as we use the logistic function in the output neurons of each mlp, the outputs of the neurons associated to each class can be interpreted as probabilities of instances to belong to the corresponding class. as hmc-lmlp-predicted obtained better results than clus-hmc in classes closer to the root , we can say that the neural networks provided stronger evidence about the pertinence of the proteins to the functions considered more important in the problem domain. recall that both hmc-lmlp and clus-hmc weights the classes during evaluation, considering more important the frequent classes.

still, higher auprc values associated to a given class means that, for high thresholds applied to the output of the neurons, the precision and recall values remain high. this can be interpreted as a high reliability associated to the prediction given by the neuron.

even though we validate the neural networks and evaluate their final classification predictive performance using au, this is not the loss function minimized during the network training. each mlp is trained by minimizing the mean square error  of its corresponding layer. as previously mentioned, when an mlp is being trained and validated for level l, it minimizes the mse only for the level l, even though the au for the hierarchical classification considering the predictions made in every level of the hierarchy up to that point is being calculated. despite reducing the hmc problem to several flat  multi-label problems, we are interested in reaching satisfactory precision and recall values within the original hmc problem. when training and validating an mlp at level l, a model is being induced for a hierarchy with l levels. in several neural networks applications, it is very common to minimize the mse during training, whereas the classifier predictive performance is evaluated using another evaluation measure  <cit> .

according to  <cit> , when reducing a problem y to another problem x, a method to solve the problem x can solve the problem y using a transformation. in hmc-lmlp, we transform a hierarchical multi-label problem into k non-hierarchical multi-label problems, and minimize the mse for each problem separately. thus, we transform the original hierarchical multi-label distribution d into non-hierarchical multi-label distributions d′. if we consider hmch the hierarchical multi-label method proposed, and h the individual neural networks applied to each flat multi-label problem, the error obtained by hmch on d is bounded by the error obtained by h on d′, i.e., e≤e. in hmc problems, errors committed for a given level are propagated to deeper levels. thus, the worst case error in d occurs when an hmch error committed in the first level is propagated to the the last level, which is a leaf. this is equivalent to summing up the individual h errors obtained in d′ for each level.

the hmc-lmlp variants estimate different quantities depending on the input used in the neural networks. the distributions are modified in each variant, modifying the input of the mlp at each level. for example, in hmc-lmlp-nolabels, only the features are taken into account, resulting in the estimation of probabilities p, where y is a class of the hierarchy. the variants hmc-mlp-predicted and hmc-lmlp-labels also estimates p because the predicted labels are functions of x. the hmc-mlp-predicted variant uses both the original features and the specific functions of these features . on the other hand, hmc-lmlp-labels strongly constrains the hypothesis space, because from the second level onwards it uses only functions of original labels. this is the reason this method performs poorly.

the variant hmc-mlp-true, in turn, estimates p probabilities, where y′ are the true class labels in the previous level. as we have previously observed in the empirical analysis, this difference between the variants lead to different results. indeed, estimating p resulted in an increased classification performance in the case of hmc-lmlp-predicted. in both hmc-lmlp-predicted and hmc-lmlp-true, the output from the previous level  are treated as new features. the difference between hmc-lmlp-predicted and hmc-lmlp-true is that, in the former, these new features are real values  <cit> , which are functions of x, while in the latter the new features are either  <dig> or  <dig>  and not functions of x .

CONCLUSIONS
in this study, we have proposed a new reduction strategy for hierarchical multi-label classification. we have presented a substantial extension of a previous method we proposed for hierarchical multi-label classification, namely hierarchical multi-label classification with local multi-layer perceptrons , which trains a multi-layer perceptron  per hierarchical level, with each mlp being responsible for the predictions in its associated level. the novel method, namely hmc-lmlp-predicted, uses the predictions made in a given level to augment the feature vectors of all instances that are used in the training of the mlp for the subsequent level. additionally, in order to verify whether the use of the predictions improved classification performance, we used two additional variants. the first variant makes use of the true classes to augment the feature vectors in each level , and the second variant employs the input features alone, without any further augmentation .

we performed several experiments using datasets. according to the experimental results, the newly proposed hmc-lmlp variant achieved the best classification results overall, when compared to different state-of-the-art methods from the literature. besides, the new variant – hmc-lmlp-predicted – improved the classification performance when compared with hmc-lmlp-true and hmc-lmlp-nolabels. we identified which functions were better and worst predicted by our method, and demonstrated, by using two different variants of the area under the precision-recall curves, that hmc-lmlp performs better for the most frequent classes of the hierarchies.

as future work, we intend to implement an ensemble of hmc-lmlp, and compare it with the clus-hmc ensemble. although neural networks have a higher computational cost, we believe that the use of gpu-based parallel computation techniques will speed up the hmc-lmlp training process, allowing for a fair comparison with ensembles of pct. we also plan to use hierarchies structured as dags and to incorporate protein-protein interaction information during learning. finally, we want to further investigate the impact of different strategies for solving the error-inconsistency problem within hmc-lmlp.

endnotes
 <dig> recall that, in the test phase, the true labels are not available to the mlps.

2https://dtai.cs.kuleuven.be/clus/hmcdatasets/.

