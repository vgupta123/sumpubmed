BACKGROUND
next generation sequencing  technology has become the de facto indispensable tool to study genomics and epigenomics in recent years. its ability to produce more than one billion sequencing reads within the timeframe of a few days  <cit>  has enabled the investigation of tens of thousands of biological events in parallel  <cit> . applications of this technology include chip-seq to identify sites of transcription factor binding and histone modifications, rna-seq to profile gene expression levels, and methyl-seq to map sites of different types of dna methylation with high spatial resolution, among many others. to convert these data into useful information, the sequencing reads must be aligned to reference genomes so that coverage – the number of aligned reads at each base pair – can be calculated. a genome browser is a very handy tool that can be used to visualize the coverage along with other genomic annotations, such as genes, repeats, conservation scores, and genetic variants as stacked tracks  <cit> . designing a genome browser that can effectively manage the enormous amount of genomic information has become an important research topic in the past decade with dozens of tools being developed to date  <cit> .

as more ngs data are being generated at reduced cost  <cit> , researchers are starting to ask more detailed questions about these data. for example, after chip-seq data for a given histone modification  is generated, one might ask:  <dig>  what is the enrichment of this mark at transcriptional start sites  as well as several kb up- and down-stream?  <dig>  if a ranked gene list is obtained based on the enrichment of this mark, does it associate with gene expression?  <dig>  does this mark show any co-occurrence with other marks and do their co-enrichments define gene modules? to answer these and many additional questions, it would be very helpful to retrieve the coverage for a group of functional elements together, perform data mining on them, and then visualize the results. classic examples of functional elements include tsss, transcriptional end sites , exons, and cpg islands . with the availability of high-throughput assays, novel functional elements – such as enhancers and dnase i hypersensitive sites , are being discovered by computational programs at a very rapid pace. progress is being facilitated further by the human encode project  <cit> , where researchers found recently that ~80% of the human genome is linked to biochemical functions.

on the other hand, the development of tools that can be used to explore the relationships between ngs data and functional elements within the genome has lagged. some programs  <cit>  have incorporated simple functions for a user to generate average profile plots at tsss, tess, or genebody regions, but with very limited options to customize the figures. a few program libraries  <cit>  have been developed to facilitate the calculation and plotting of coverage from ngs data, but they require a user to have substantial programming skills and involve a steep learning curve. several programs  <cit>  with graphical interfaces have been developed, featuring a point-and-click workflow to perform these tasks. they are greatly helpful for investigators with limited programming experience. however, their designs often limit the choices a user has and it is not always easy to import and export data from these programs.

to address this important need, we have developed ngs.plot: a quick mining and visualization tool for ngs data. we tackle the challange in two steps. step one involves defining a region of interest. we have collected a large number of functional elements from major public databases and organized them in a way so that they can be retrieved efficiently. the ngs.plot database now contains an impressive number of  <dig> , <dig> functional elements . step two involves plotting something meaningful at this region. our program utilizes the rich plotting functionality of r  <cit>  and contains  <dig> visual options for a user to customize a figure for publication purposes. ngs.plot’s unique design of configuration files allows a user to combine any collection of ngs samples and regions into one figure.

total count of functional elements is  <dig> , <dig> 

the ngs.plot package contains multiple components: a main program for region selecting and plotting; a genome crawler that grabs genomic annotations from public databases and packs them into archive files; a script that is used to manipulate the locally installed genomic annotation files; another script that can be used to calculate and visually inspect correlations among samples; a plug-in that allows ngs.plot to be integrated into the popular web-based bioinformatic platform – galaxy  <cit> . ngs.plot has been developed as an open-source project and has already enjoyed hundreds of downloads world-wide thus far. here, we will first describe the design and implementation of ngs.plot. we will then discuss some implementation strategies by using performance benchmarks. finally, we will employ a few examples to demonstrate how ngs.plot can be used to extract and visualize information easily, with rich functionality in plotting.

implementation
ngs.plot workflow and algorithms
the workflow of ngs.plot is depicted in figure  <dig>  initially, ngs.plot searches through its database to find the genomic coordinates for the desired regions and uses them to query the alignment files of an ngs dataset. it then calculates the coverage vectors for each query region based on the retrieved alignments. it finally performs normalization and transformation on the coverage and generates two plots. one plot is an average profile that is generated from the mean of all regions. this plot provides the overall pattern at the regions of interest. the other plot is a heatmap that shows the enrichment of each region across the genome using color gradients. the heatmap can provide three-dimensional details  of the ngs samples under study.

a user can specify the plotting regions using a genome name, such as “mm9” and a region name, such as “genebody”. further options are provided to choose a particular type of region, otherwise the default is used. for example, exons are classified into “canonical” , “variant”, “promoter”, etc.; cgis are classified into “proximalpromoter” , “promoter1k”, “promoter3k”, etc.; gene lists can be provided to create subsets of the regions. for convenience, we have provided the gene names/ids in both refseq  <cit>  and ensembl  <cit>  format. to be more flexible, a user can also use a bed  file for custom regions. a bed file is a simple tab-delimited text file that is often used to describe genomic regions. this is particularly useful if a user performed peak calling for a transcription factor and would like to know what is happening at or around the peaks.

the alignment files must be in bam  <cit>  format, which is now used widely for short read alignments. ngs.plot conforms to the sam specification  <cit>  of bam files and can work with any short read aligner. a bam file is compressed and indexed for efficient retrieval. in ngs.plot, the “physical coverage” instead of the “read coverage” is calculated for both chip-seq and rna-seq. this is achieved by extending each alignment to the expected dna fragment length according to user input. the coverage data are then subjected to two steps of normalization. in the first step, the coverage vectors are normalized to be equal length and this can be achieved through two algorithms. the default algorithm is spline fit where a cubic spline is fit through all data points and values are taken at equal intervals. the alternative algorithm is binning where the coverage vector is separated into equal intervals and the average value for each interval is calculated. this first step of length normalization allows regions of variable sizes to be equalized and is particularly useful for genebody, cgi, and custom regions. in the second step, the vectors are normalized against the corresponding library size – i.e., the total read count  for an ngs sample to generate the so called reads per million mapped reads  values. the rpm values allow two ngs samples to be compared regardless of differences in sequencing depth.

we have implemented many functions to manipulate the visual outputs of an ngs.plot run, as follows:

rna-seq mode
ngs.plot can accurately calculate coverage for rna-seq . rna-seq experiments are unique because the short reads are derived from messenger rnas and other expressed rnas, many of which result from exon splicing. the ngs.plot database contains the exon coordinates for each transcript so that the coverage vectors for exons are concatenated to simulate rna splicing in silico.

bam-pair
ngs.plot can also calculate the log <dig> ratios for one sample vs. another and display the values using two different colors in a heatmap. this is a very useful feature for chip-seq where a target sample is often contrasted with a control sample to determine bona fide differences in enrichment.

visualization options
we have implemented a few approaches to generate average profiles. besides mean values, the standard error of mean  across the regions is calculated and shown as a semi-transparent shade around the mean curve. this provides users with a sense of statistical significance when two samples are being compared. it is known that the mean value is most influenced by extreme values that can sometimes deleteriously distort the average profiles. we therefore implemented robust statistics  by removing a certain percentage of the extreme values before the average is taken. as well, curve smoothing was implemented to remove the spikes from average profiles as an option that can be controlled by moving window size. heatmaps can be tuned by custom color scales and color saturation.

gene ranking
in contrast to an average profile, a heatmap contains an additional dimension – individual genomic regions. this additional information allows the regions to be organized to reflect the underlying biology. we have therefore implemented six different algorithms to rank such regions:

• total . regions are ranked by the sum of the enrichment values. this always puts the most enriched regions at the top.

• hierarchical clustering. this method groups the most similar regions together first followed by the less similar ones. this process is performed repeatedly from bottom up until all regions are included in the grouping to form a tree-like structure. when dealing with multiple ngs samples, the clustering is applied to all of them together.

• max. regions are ranked by the maximum of the enrichment values. this is similar to the “total” algorithm but is most useful when dealing with epigenomic marks that have sharp peaks.

• product. regions are ranked by the product of the sums of all ngs samples. this algorithm is useful when a user is studying several marks that may act in concert with one another.

• difference. regions are ranked by the difference of sums between two ngs samples. when two marks are mutually exclusive, such as h3k27ac and h3k27me <dig>  this algorithm can maximize the appearance of such relationships.

• principal component analysis . pca is performed on all ngs samples and then the first component is used to rank regions, which captures the largest proportion of the variance. this algorithm is complementary to the above mentioned methods.

finally, a user can choose not to rank the regions and just use the input order . this is particularly useful if a user has already ranked the regions. for example, a user can rank genes by expression levels and then plot the enrichment for histone marks to see if there is any association.

multi-plot and configuration
in a multi-plot, an arbitrary number of plots can be combined into one figure and each plot can represent an ngs sample at a subset of the entire genomic region; a configuration file can be used to describe this combination. the configuration is a tab-delimited text file where the first column contains the alignment file names; the second column contains the gene list names or bed file names; the third column contains the titles of the plots; the fourth and fifth columns are optional and contain fragment lengths and custom average profile colors, respectively. ngs.plot will parse a configuration file and obtain a list of unique bam files and a list of unique regions . some pre-processing steps will be performed on each bam file, such as calculating the number of alignments and indexing. the unique regions and unique bam files are used to organize heatmaps into a grid so that each row represents a unique region and each column represents a bam file.

other tools
included in the ngs.plot package are several additional useful tools. a python script called ngsplotdb.py can be used to install downloaded genome files, list currently installed genomes, or remove existing genomes. an r script called plotcorrgram.r can be used to calculate all pairwise correlations for samples in a configuration and visually display them as a corrgram  <cit> . another r script called replot.r can be used to re-generate an average profile or a heatmap with different visual options so that users can tune their figures without extracting data again.

coverage extraction
coverage extraction is at the core of the ngs.plot workflow. this process often consumes a lot of computational resources because of the large size of genomes  and because alignment files are also very large . in the history of ngs.plot, we first used a strategy called “run-length encoding”  to represent genomic coverage vectors. rle uses a very simple approach so that consecutive and repetitive values are represented by the value and number of repeats. for example,

original
 <dig> 

rle
    .

this leads to very efficient representation if the original coverage vectors are sparse. for histone marks, such as h3k4me <dig>  which tends to generate sharp peaks, a run-length encoded  <dig> million short read sample only occupies ~15 mb on a hard-disk if stored as a binary file. however, as sequencing output has increased rapidly in recent years , this strategy soon became a major problem: the rle files grew too large and consumed a lot of memory during loading. another challenge arose when dealing with epigenomic marks that have broad patterns of enrichment – the coverage vectors are dense and may consume a lot of memory.

therefore, we developed another strategy that uses a two-step procedure . first, the query regions are grouped into chunks and the bam index is loaded into memory to perform alignment retrieval. second, the retrieved alignments are used to calculate coverage on-the-fly for each region. a bam file is indexed using hierarchical binning and linear index to allow very efficient retrieval so that only one disk seek  is often required for each query  <cit> . grouping regions into chunks allows us to avoid frequent index loading which is very expensive in comparison to alignment reading. this strategy has an additional advantage: no extra files need to be generated to represent coverage vectors. when the storage of many ngs samples becomes problematic, this advantage is highly desirable.

we also explored additional alternatives . we used samtools to pre-calculate the genomic coverage vector for an ngs sample, merged the neighbouring base pairs that contain the same value, and compressed them using gzip to save space. we then used two different approaches to index the output file. tabix  <cit>  is a generic indexing program for tab-delimited text files that contain a position column and a value column, and uses the same indexing algorithm as bam. it can directly create an index on a compressed text file. bigwig  <cit>  files are converted from wiggle  files. it is a binary format that includes a data structure called r-tree as index. we first converted the output file to a variable-step wiggle file and then created the bigwig file using tools from the ucsc genome browser.

genomic annotation databases
we developed a genome crawler that fetches various genomic annotations from public databases, and processes and saves them into r binary tables . r binary tables are very easy to create and their columns are indexed by r internally. this helps to avoid setting up local databases, which turns out to be a convenience for users. currently, we considered ensembl  <cit> , ucsc  <cit> , and encode  <cit>  , and will incorporate more public databases in the future. ensembl and ucsc provide classic genomic features such as genes, transcripts, exons, and cgis, while encode provides more recent epigenomic features such as enhancers and dhss. because these databases host genomic information at different servers that are setup by separate groups of people, there is no uniformity in constructing the url for a specific genome. sometimes, a large database  may store different classes of species, such as animal and plant, using slightly different naming schemes. to address this issue, we used json format to manually create configuration files for each naming scheme so that an automated pipeline can pull data from different sources. new naming schemes can be handled by simply adding json configuration files. the files that are downloaded by the genome crawler include gene transfer format , gene prediction , bed, and mysql database inquiries, each of which is processed by a separate program module. the refseq annotations downloaded from ucsc are in gp format, which can be converted into gtf files using the “genepredtogtf” utility from ucsc. the gtf files are parsed by custom scripts to generate uniformly formatted text files that are further converted into r binary tables. the gene annotations are used to derive gene deserts. locations about heterochromatic regions such as centromeres and telomeres are downloaded from ucsc and are used to derive pericentromeres and subtelomeres. all the gene annotations, gene deserts, pericentromeres and subtelomeres are used to build a genome package for the “region analysis” utility  on the fly, which is used to perform location-based classifications on cgis and dhss. in total, more than  <dig> million functional elements have been incorporated into ngs.plot’s database so far . additional genomes can be added at any time as needed. the functional elements for each genome are packed into a compressed archive file that can be installed on demand by a user. a python script  is provided to manage the locally installed genomes. in the following, we describe each type of functional element and how they are processed.

genes and transcripts
genes and transcripts are categorized into five types: protein_coding, pseudogene, lincrna, mirna, and misc  according to gtf files. gene/transcript ids/names are indexed for random access. each gene is represented by the isoform with the longest genomic span.

exons
exons and their neighbouring regions are known to contain chromatin modifications that may facilitate exon recognition and influence alternative splicing  <cit> . we thus developed an exon classification algorithm  that classifies each exon into seven categories :

• promoter: the 5’ end.

• polya: the 3’ end.

• canonical: common to all isoforms of the gene.

• variant: absent from some isoforms.

• alternative donor: have varied 3’ end.

• alternative acceptor: have varied 5’ end.

• alternative both: have both varied 3’ and 5’ ends.

the first two categories are terminal exons while the other five categories are internal exons. briefly, our algorithm goes through each gene and carries out pairwise comparisons for all transcripts within the gene. all exons are initialized to “canonical” category and will be continuously updated when the program sees alternative boundaries or missing exons in comparison to other transcripts.

enhancers
enhancers are important transcriptional regulators that can activate distal promoters via dna looping. they often regulate subsets of genes in a cell type specific way and are marked in part by the enrichment of h3k4me <dig> and h3k27ac  <cit> . we have built into our database the enhancers of  <dig> human cell types and  <dig> mouse cell types  by using data from the encode  <cit>  and muencode projects  <cit> . for human enhancers, we incorporated data from the encode analysis working group  which performs integrated analysis of all encode data types based on uniform processing. we will continuously monitor the status of their download page and update our database as new data become available. we excluded the enhancers that are within ± <dig> kb of tsss. the distance of  <dig> kb is a cutoff inspired by this work  <cit>  to avoid classifying promoters as enhancers accidentally. each enhancer is assigned to their nearest genes whose ids/names are also indexed.

dhss and cgis
dhss are thought to be characterized by open, accessible chromatin and are functionally related to transcriptional activity. dhss have been used as markers of regulatory dna regions  <cit>  including promoters, enhancers, insulators, silencers, and locus control regions. high-throughput approaches, namely dnase-seq  and dnase-chip , were used to map dhss on the human genome  <cit> . in encode, dnase-seq was recently used to map genome-wide dhss in  <dig> human cell and tissue types  <cit> . we have built into ngs.plot’s database the dhss of  <dig> human cell types  from the download page provided by awg and will update them in the future. cgis are genomic regions that contain high frequency of cpg sites and are often involved in gene silencing at promoters. cgis are provided in ngs.plot  based on the annotations from the ucsc genome browser. both dhss and cgis are classified into different groups based on their genomic locations using the region analysis utility.

galaxy integration
ngs.plot command interface features simple and easy usage. this allows users to blend ngs.plot with other bioinformatic and unix tools seamlessly. however, the command interface may be intimidating to wet lab biologists. therefore, we developed a plug-in so that ngs.plot can be integrated into galaxy  <cit>  – a very popular web-based bioinformatics platform, which allows users to build their own point-and-click workflows using various tools. the plug-in features an easy-to-use graphic interface that can typically generate a figure in 3- <dig> steps. we have created a wiki-page to demonstrate such an example: https://code.google.com/p/ngsplot/wiki/webngsplot. currently, this plug-in requires a locally installed galaxy instance and is not available on the main galaxy server.

website and community involvement
ngs.plot’s hosting website provides manuals, source code, installation files, and links to many other resources. the source code is tracked by google’s git server and is open for public contributions. to facilitate users in using ngs.plot, we have created nine wiki-pages so far and will keep adding new ones. issue tracking is used for users and developers to report bugs and make suggestions. as this manuscript is being written, users from all over the world have downloaded ngs.plot for hundreds of times. we have also created an online discussion group for users to ask questions and help one another. so far, there are  <dig> active members who have contributed to  <dig> topics. we also use this opportunity to collect opinions from users so that we can improve the program further.

ngs data processing
the ngs data used in this manuscript were obtained from the sequence read archive . the accession numbers and references of the datasets are listed in table s <dig> . chip-seq data were aligned to the reference genome by bowtie  <cit> . peak calling was accomplished by use of macs  <cit>  using default parameters. rna-seq data were analyzed by the tuxedo suite  <cit> . the differential chromatin modification sites were detected by diffreps  <cit>  using default parameters and the fdr cutoff was set as  <dig> .

RESULTS
benchmarking the performance of ngs.plot
to benchmark different coverage extraction methods, we used a chip-seq dataset that we previously published  <cit> . h3k9me <dig> is a histone mark that displays dispersive enrichment patterns and is often associated with gene silencing  <cit> . the chip-seq samples were derived from a mouse brain region  where two biological conditions were assessed: chronic morphine and chronic saline administration. for each condition, three biological replicates were analyzed. we merged and sorted the alignment bed files for the three biological replicates under saline conditions and used bedtools  <cit>  to create a large bam file that contains nearly  <dig> million alignments. from this file,  <dig>   <dig>   <dig>   <dig>  and  <dig> million alignments were randomly sampled to create a series of bam files that increase in alignment size exponentially. different methods were used to extract coverage vectors for the tss ±  <dig> kb regions of all protein coding genes . a number of metrics such as run time, memory usage, and file size were measured for different alignment sizes. all tests were performed on a linux workstation with two  <dig>  ghz cpu cores and sufficient memory.

at first, coverage needs to be pre-calculated for tabix, bigwig, and rle. this takes a long time to complete and the run time is strongly associated with the alignment size . it takes samtools around  <dig>  s to calculate the coverage for a  <dig> million read bam file and more than  <dig>  s for a  <dig> million read bam file. rle is much faster but involves a more rapid increase in time than samtools: it takes 80 s for a  <dig> million read bam file and more than 800 s for a  <dig> million read bam file. this is because rle tries to load all alignments into memory and then performs calculations in a batch while samtools does the calculations by reading alignments in a stream. after coverage calculations, tabix and bigwig also require the coverage files to be indexed. the indexing is more than  <dig> times faster than coverage calculation and shows strong association with the alignment file size . tabix is faster than bigwig: this is most likely because bigwig uses more than one index for different zoom levels  <cit> .

memory usage is a big problem for rle. even for the  <dig> million read bam file, it uses 6 gb to finish the run, while for the  <dig> million read bam file, it uses 75 gb . in contrast, the memory footprint for tabix indexing is very small: it uses ~50-60 mb for all bam files. bigwig uses more memory for indexing than tabix but is still reasonably small: at  <dig> million alignments, it uses 2 gb to finish the run .

file size is another important metric. both tabix and bigwig create large coverage files that strongly associate with alignment file size : at  <dig> million alignments, the tabix coverage file is  <dig>  gb while the bigwig coverage file is 1gb. as a comparison, rle files are three times smaller: at  <dig> million alignments, the rle file is 330 mb. both tabix and bam have very small index file sizes. for bam, the index remains around 6 mb for all alignment sizes while tabix index is three times smaller. for bigwig, the index is an integral part of the format and its size is unknown to us.

by grouping regions into chunks we can save resource in index loading. this strategy worked well in our tests . based on a  <dig> million alignment file, it took the bam method  <dig>  s to load all tss ±  <dig> kb regions into memory for chunk size of  <dig>  for a chunk size of  <dig>  the time was reduced to less than 200 s – a six fold reduction. the time was further reduced to 88 s for a chunk size of  <dig>  the other two methods – tabix and bigwig – enjoyed similar degrees of time reduction by use of region grouping. it should be noted that tabix used much less time than bam at small chunk sizes. this is expected since the tabix index is much smaller than the bam index . bigwig used the longest time among the three methods at small chunk sizes , suggesting its index is larger than the other two.

in our tests, tabix was implemented with the rsamtools  <cit>  package and bigwig was implemented with the rtracklayer  <cit>  package. note that tabix is a generic index program for text entries. after the texts are loaded into memory, they must be converted into binary representation of numerical numbers. the rtracklayer package, however, will unfortunately merge and sort the query regions before coverage vectors are retrieved. this means that the loaded coverage vectors are mixed and must be distinguished between the query regions for them to be useful for our purposes. all of the above operations require a significant amount of computational resources. at chunk size of  <dig>  it took bigwig > <dig>  s and tabix > <dig>  s to finish the operations . in comparison, it took bam only 64 s to calculate the coverage vectors on-the-fly. in the end, we abandoned support for tabix and bigwig for this reason. a future goal of the field is to re-write the extraction functions in rsamtools and rtracklayer extensively in order to optimize the retrieval time. once that is done, we can add support for these two file formats.

finally, we tested the entire process of coverage extraction and calculation for both bam and rle for different alignment sizes with regard to time and memory usage. the bam method was tested with chunk size of  <dig> that is the default value for ngs.plot. bam functioned superiorly compared to rle on both metrics at all alignment sizes . bam’s run time only slightly increased from 143 s to 165 s for  <dig> and  <dig> million alignments; and its memory usage remained stable: less than 1 gb for all alignment sizes. in contrast, rle used  <dig>  gb ram at  <dig> million alignments and increased to  <dig>  gb ram at  <dig> million alignments. rle’s run time was also significant: at  <dig> million alignments, it took > <dig>  s to finish – seven times longer than bam.

in summary, the bam strategy we chose in ngs.plot is a versatile, low profile approach that works robustly even with very large alignment files. this approach was introduced in ngs.plot v <dig>  and has remained the approach of choice ever since.

analysis of tet <dig> and 5hmc chip-seq data in the differentiation of p <dig>  cells
an easy-to-use and flexible visualization method of ngs data is necessary for computational biologists to formulate and validate hypotheses quickly. to demonstrate the power of ngs.plot, we used chip-seq data  to study the relationship between tet <dig> , a methylcytosine dioxygenase, and 5-hydroxymethycytosine  in the differentiation of mouse embryonal carcinoma p <dig>  cells. p <dig>  cells can be differentiated into neurons or glia by exposure to retinoic acid   <cit> , and are widely used in research on stem cell differentiation. tet family proteins play important roles in the conversion of 5-methylcytosine  into 5hmc, 5-formylcytosine , and 5-carboxymethylcytosine  in dna  <cit> , and are important regulators in the maintenance and differentiation of embryonic stem cells   <cit> . 5fc and 5cac are present low abundance in mammalian genomes  <cit>  and are difficult to be detected by chip-seq. therefore, we focus on 5hmc in this study. 5hmc is known to be enriched at tsss, exons, cgis, and enhancers  <cit> . the distributions of tet proteins and 5hmc across the genome roughly overlap, while tet <dig> and tet <dig> prefer cpg enriched regions  <cit> . this preference is at least partially due to their cxxc domains  <cit> .

first, we used ngs.plot to investigate the enrichment profiles of tet <dig> and 5hmc in p <dig>  cells at different genomic regions, including genebodies, cgis, exons, and enhancers . as the genebody plot  shows, tet <dig> is most enriched at tsss but generally depleted at genebodies. cgi plots  indicate that tet <dig> is enriched at all kinds of cgis at similar levels  and demonstrates a clear drop of enrichment at flanking regions . this suggests that the cxxc domain of the tet <dig> protein highly prefers cpg abundant regions. in addition, tet <dig> shows some enrichment at exons as well as enhancers  but the enrichment levels are weaker than that of cgis, with enhancers being the weakest. as we expected, the enrichment patterns of 5hmc are highly similar to those of tet <dig> , indicating concordance between the two marks. all of the above plots can be generated by ngs.plot with only one command for each. the user only needs to input into ngs.plot which regions and samples to examine and the size of the flanking regions.

5hmc plays an important role in stem cell differentiation, where its conversion from 5mc is mediated by tet <dig>  <cit> . the activities of enhancers are known to be specific to differentiated cell types and are often marked by the dynamics of 5hmc  <cit> . here we illustrate the role that tet <dig> plays in the conversion of 5hmc by studying the differential sites of tet <dig> between control and ra-induced p <dig>  cells . diffreps is a powerful program to detect differential chromatin modification sites using chip-seq data  <cit> . we used diffreps to find  <dig>   tet <dig> differential sites in total. to restrict the analysis to enhancers, we used h3k27ac as a mark for active enhancers  <cit> . peak calling using macs was performed in both control and ra-induced p <dig>  cells and the two peak lists were combined to obtain  <dig>  h3k27ac enriched sites . the peak list was used to filter the tet <dig> differential sites that are not in enhancer regions. after filtering, we obtained  <dig> increased and  <dig>  decreased enhancer-specific tet <dig> sites induced by ra, whose genomic coordinates are then converted into two separate bed files. ngs.plot was applied on each bed file to plot the enrichment of both tet <dig> and 5hmc . it can be seen clearly that the trends of 5hmc dynamics follow those of tet <dig> dynamics, with an overall consistency ratio of 82% . their log fold changes are also weakly correlated . this is a vivid example illustrating how different computational tools can be used to identify biologically meaningful genomic regions and then feed them into the ngs.plot program for visualization.

integrative analysis of poised and active promoters in esc
integrative analysis using genomic sequence information and multiple ngs samples is essential to investigate gene transcription and epigenomic regulation. ngs.plot’s ability to graph both chip-seq and rna-seq samples allows a user to quickly establish correlations between different epigenomic marks and associated gene expression levels. here, we demonstrate this feature of ngs.plot by use of multiple chip-seq samples, including several histone marks  and transcription factors , and an rna-seq sample, from mouse escs  . h3k4me <dig> is a promoter-enriched histone mark that is generally associated with transcriptional activation  <cit> . h3k27ac is an activation mark that locates at both promoters and enhancers  <cit> . the enrichment of both h3k4me <dig> and h3k27ac provides a signature of cpg-related promoters  <cit> . h3k27me <dig> is catalyzed by the polycomb group proteins and is implicated in the silencing of genes  <cit> . the enrichment of both h3k4me <dig> and h3k27me <dig> marks the so-called “bivalent” domains that are prevalent in escs. they maintain the silencing or low expression of many genes in escs, which are poised for activation in differentiated cell types  <cit> . suz <dig> is a subunit of the polycomb repressive complex  <dig>  – a transcriptional repressor that catalyzes h3k27me <dig>  <cit> . oct <dig>  also known as pou5f <dig>  is a critical transcription factor in the self-renewal of escs  <cit> .

we divided all promoters  of the coding regions of genes into two groups, namely, polycomb-targeted  and non-polycomb-targeted , based on the presence or absence of h3k27me <dig> peaks. to reveal the relationship between genomic sequences and epigenomic regulation, we sorted all promoters within each group based on their cg di-nucleotide percentages  and entered the gene lists into ngs.plot’s configuration files. we ran ngs.plot with its ranking algorithm set to “none” so that it used the input order. we also used a dna input sample to pair with each epigenomic mark so that ngs.plot’s bam-pair functionality plots log fold changes. the use of the input sample is to counteract various biases introduced in chip-seq experiments  <cit> . all of the chip-seq samples within each group were then plotted with one command by use of the configuration file . we also plotted the rna-seq sample using the same gene list with another command using the “rna-seq” mode .

figure  <dig> shows that the pt group has lower gene expression levels than the npt group, indicating that genes containing the h3k27me <dig> mark are suppressed. conversely, the activation mark h3k27ac shows lower enrichment in the pt group. as previously reported  <cit> , h3k27ac is mutually exclusive with h3k27me <dig>  however, another activation mark, h3k4me <dig>  appears to be enriched in both groups. h3k4me3’s enrichment in the pt group demonstrates the prevalent existence of the “bivalent” domain in mescs. the heatmaps of figure  <dig> also indicate that there are strong correlations between certain epigenomic marks as well as with gene expression. to quantitatively measure these correlations, we used the plotcorrgram.r script included in the ngs.plot package to calculate and visually demonstrate all pairwise correlations between the samples. all the correlation coefficients and p-values are presented in . the corrgram is presented in . as expected, h3k27me <dig> and suz <dig> show very strong correlations in both groups . interestingly, cgps show a moderate correlation with gene expression in the npt group , but this correlation is significantly decreased in the pt group . as we mentioned above, tet <dig> has a preference for cg-rich regions due to its cxxc domain. a moderate correlation is observed between tet <dig> and cgps in the pt group , while a weak correlation is observed in the npt group . tet <dig> also shows a moderate correlation with oct <dig> in both groups . it has been reported that tet <dig> can replace the role of oct <dig> in inducible pluripotent stem cell  reprogramming, a process that is implicated in the regulatory circuit of escs  <cit> . this example demonstrates the ngs.plot’s capability to quickly correlate multiple epigenomic marks with other genomic features and with gene expression and creates figures that are publication-ready. a user can use these figures to gain biological insights into their ngs data and even generate novel hypotheses.

examination of rna-seq 3’ bias
the rna-seq mode of ngs.plot can perform exon splicing in silico and this functionality can be exploited during rna-seq quality control. for instance, in studies of human postmortem brain tissue, a major problem is that the rna samples are often severely and variably degraded, as measured by the rna integrity number   <cit> . an rna sample with low rin is often associated with strong 3’ bias, which can impair the ability to otherwise assess the sample’s mrna quantity. to demonstrate this, we analyzed an in-house rna-seq dataset  from human postmortem brain tissue obtained from two individuals with schizophrenia: one sample has an acceptable rin  and the other sample has a very low rin . the figure  generated by ngs.plot shows that the sample with low rin is clearly biased towards 3’ in comparison to the sample with high rin. a plot like this provides a visual inspection of the read coverage of rna-seq samples and can help an investigator derive useful information from suboptimal tissue, while guiding decisions regarding whether a sample should be discarded or not.

CONCLUSIONS
high throughput assays that utilize ngs platforms have revolutionized biomedical research  <cit> . biology is becoming more of a data-driven discipline than ever. the bottleneck is now in the processing and interpretation of the massive amount of data that are being generated  <cit> . we have developed ngs.plot – a quick data mining and visualization program for plotting ngs samples. ngs.plot is easy and simple to use but yet still very powerful. its signature advantage is a built-in database of functional elements that are ready to use, which saves users considerable time in managing genomic coordinates on their own. these features help make ngs.plot a popular tool among bioinformatics researchers.

over the past few years, we have seen many exciting developments in applying ngs technologies to epigenomics. large international efforts such as the encode project  <cit>  and the nih roadmap epigenomics project  <cit>  have generated an enormous amount of data about the human and other mammalian genomes. the scale of such projects is unprecedented. these data have provided an invaluable resource of information concerning the functional elements that regulate genes and non-genic regions. understanding how these functional elements are controlled by different protein regulators to yield numerous, diverse phenotypic outputs is essential to advance our knowledge of genome regulation and function. in this great adventure, ngs.plot represents a highly useful tool that helps fill the gap between data and information. nevertheless, a lot of work is still needed to curate these data and to incorporate them into our database.

another direction for future research is to make the ngs.plot program more interactive. as we incorporate tens of millions of additional functional elements into our database and perform more elaborate classifications, a command line interface will become too cumbersome to use. therefore, a google search like interface should be developed to help users find genomic regions of interest from our database, upon which the ngs.plot visualization engine can be used to display enrichment patterns and to perform related data mining tasks.

availability and requirements
project name
ngs.plot.

project home page
https://code.google.com/p/ngsplot/.

operating system
platform independent.

programming language
r and python.

other requirements
r package domc; bioconductor package bsgenome, rsamtools and shortread.

license
gnu gpl <dig> 

any restrictions to use by non-academics
contact lisa placanica  or the technology transfer office of mount sinai.

abbreviations
ngs: next-generation sequencing; tss: transcriptional start site; tes: transcriptional end site; cgi: cpg island; dhs: dnase i hypersensitive sites; sem: standard error of mean; rle: run length encoding; gtf: gene transfer format; gp: gene prediction; 5hmc: 5-hydroxymethycytosine; ra: retinoic acid; 5mc: 5-methylcytosine; 5fc: 5-formylcytosine; 5cac: 5-carboxymethylcytosine; esc: embryonic stem cells; prc2: polycomb repressive complex 2; cgp: cg di-nucleotide percentage; rin: rna integrity number.

competing interests
the authors declare that they have no competing interests.

authors’ contributions
ls designed and lead the development of the program, analysed the data and wrote the manuscript; ns contributed to the code, performed the computational experiments and drafted the manuscript; xl contributed the ngs.plot galaxy plug-in; en participated in the writing. all authors read and approved the final manuscript.

supplementary material
additional file 1
supplemental materials including exon classification algorithm, figures1- <dig>  table s1- <dig> 

click here for file

 additional file 2
correlation coefficients and p-values of all pairwise comparisons between the samples in figure  <dig> 

click here for file

 additional file 3
corrgrams of histone marks, transcription factors, and gene expression using the same data as figure  <dig>  each region is represented by the row sum of the data matrix. the left panel represents pt promoters and the right panel represents npt promoters. the upper triangle represents correlation coefficients: the sizes of pies represent the absolute values of the correlation coefficients; blue represents positive correlation; red represents negative correlation. the lower triangle represents scatter plots using ellipses. the red lines represent lowess fit to the scatter plots.

click here for file

 acknowledgements
we would like to thank peter briggs from the university of manchester for contributing to ngs.plot’s code, and the ngs.plot user community for positive suggestions and bug reports. this work was supported by the friedman brain institute ; and the national institutes of health .
