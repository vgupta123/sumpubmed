BACKGROUND
genome assembly reconstructs a genome from many shorter sequencing reads as faithfully as possible  <cit> . since reasonable formulations of the problem are np-hard  <cit> , practical implementations often return an approximate solution that contains errors. recent assembly evaluations like gage and the assemblathon  <cit>  have highlighted the chaotic nature of genome assembly, in which assembler performance varies widely across datasets and small parameter changes can have drastic effects. in gage-b  <cit>  for example, each dataset required a different k-mer parameter, the best assembler was not consistent across datasets, and the continuity difference between best and second best was often two-fold.

although genome assembly is a complex problem, validating assemblies is more straightforward. the quality of a genome assembly can be confirmed by verifying that the layout of reads is consistent with the sequencing process used to generate the data  <cit> . multiple tools have been recently developed for validating genome assemblies both with and without the use of a reference genome  <cit> . thus, given the chaotic nature of assemblers and the relative ease of validation, it is recommended to generate multiple assemblies and use validation to determine the most appropriate one. this is akin to a “hypothesis generation” view of assembly  <cit> , which can be most easily implemented as an ensemble of independent methods. unfortunately, running multiple assemblers is a time consuming, non-trivial task requiring substantial installation, learning, and maintenance costs.

there exist a limited set of tools that integrate automated parameter selection and validation into the assembly process. the a <dig> pipeline  <cit>  automates the microbial assembly process, but is limited to a single assembler and includes limited validation. cg-pipeline  <cit>  is targeted to  <dig> sequencing. velvetoptimizer  <cit>  automates a parameter sweep of k-mer sizes for the velvet assembler  <cit> , but uses contig n <dig> size as the optimization metric, which is not always representative of assembly quality  <cit> . more recently, a number of assembly methods have been developed that incorporate assembly likelihood estimates into the primary assembly algorithm  <cit> . however, none of these tools robustly automate the execution of multiple assembly methods and validation metrics to achieve the best possible assembly. here we present imetamos, which automates the process of ensemble assembly and validation.

implementation
whereas metamos  <cit>  was developed for metagenomic assembly, imetamos is an isolate-focused extension that encapsulates the current best practices for microbial genome assembly using illumina  <cit> ,  <dig>  <cit> , ion  <cit> , or pacbio  <cit>  sequencing data. building on the conclusions of gage and the assemblathon, imetamos runs multiple, independent tools to generate and validate assemblies. uniquely, imetamos automates the entire ensemble assembly process including automated parameter selection and sweeps, execution of multiple assembly and validation tools, preliminary gene annotation, and identification of potential contaminating sequences. this ensemble approach is robust to individual tool failures and reliably generates high-quality assemblies with minimal user input.

pipeline design
figure  <dig> details the imetamos pipeline, which treats each assembly project as a competition among multiple assemblers. as an added benefit to the ensemble approach, imetamos is robust to failure; if any tool or parameter combination fails, imetamos will continue the analysis using only the ones that succeeded. a “winning” assembly is then automatically selected based on the combined validation results. however, users may also browse the validation metrics to choose their own preferred assembly, such as one that optimizes consensus accuracy without regard to continuity.

imetamos is primarily written in python and builds upon ruffus  <cit>  for pipeline management. however, it incorporates many freely available tools written in a variety of languages. to simplify installation, imetamos is distributed as 64-bit os x and linux binaries, including all supported assemblers, tools, and required databases. on 32-bit systems, imetamos automatically downloads and installs the required dependencies, as needed, which significantly simplifies installation.

modular infrastructure
to support future extensibility, imetamos includes a generic framework to add new tools to the pipeline. currently supported modules are for assembly and classification. when a new tool is available, no code modification is need. instead, a configuration is written to specify parameters for the tool and required inputs and outputs. imetamos will automatically load this configuration and run the requested tool. when an external tool is executed, a corresponding citation is output to ensure users of imetamos properly credit the tools on which it relies.

reproducibility
imetamos enables reproducible analysis by recording all commands, software versions , and intermediate inputs and outputs. the single, comprehensive binary is generated via pyinstaller  <cit> , which also serves to fix and archive the exact version of all programs used. reproducibility of custom analyses is supported via workflows. a workflow defines the software required for an analysis, as well as optional parameters and input data. workflows support both local and remote file names, as well as sra run identifiers, and can inherit their parameters from other workflows, allowing users to easily add or modify input data or parameters. given a workflow, imetamos will download any required remote data and run the analysis using pre-specified parameters. for further reproducibility, a workflow is automatically created for every imetamos run, which can be easily shared with remote collaborators. if the data are available on the internet, the entire analysis can be reproduced by two simple commands.

assembly
assembly is treated as a hypothesis generation and testing problem. multiple assembly tools are run to ensure robustness to failure and a thorough exploration of the hypothesis space. the following assemblers are currently supported: abyss  <cit> , cabog  <cit> , idba-ud  <cit> , masurca  <cit> , metavelvet  <cit> , mira  <cit> , ray/raymeta  <cit> , sga  <cit> , soapdenovo <dig>  <cit> , spades  <cit> , sparseassembler  <cit> , velvet  <cit> , and velvet-sc  <cit> . for de bruijn assemblers, a k-mer size is automatically selected using kmergenie  <cit> . alternatively, users can specify a list of k-mers and imetamos will run each assembly with each specified k-mer. in this mode, imetamos can operate similarly to velvetoptimizer  <cit> , but for multiple assemblers and with more appropriate validation measures.

validation and annotation
each assembly is treated as a hypothesis subject to validation. the following validation tools are supported: ale  <cit> , cgal  <cit> , frcbam  <cit> , freebayes  <cit> , lap  <cit> , quast  <cit> , and reapr  <cit> . both reference-based and reference-free validations are performed. for reference-based validation, a mumi distance  <cit>  is used to recruit the most similar reference genome from refseq  <cit>  to calculate reference-based metrics. for reference-free validation, the input reads and read pairs are verified to be in agreement with the resulting assembly using both likelihood-based methods and mis-assembly features. in addition, to provide an initial annotation and comparison between gene content, the assemblies are automatically annotated using prokka  <cit> .

from the ensemble, the “winning” assembly is selected using the consensus of the validation tools. for each selected metric, the assemblies are assigned an order from best to worst . by default, the top assemblies are selected as those that are in the top 10% for at least half the metrics. the best assembly is then selected as the top scoring assembly with the highest count of best scores. a user can select a single metric  or an arbitrarily weighted combination of metrics for validation. importantly, this allows users to customize the validation process to suit their downstream project goals. for example, studies focused on phylogenetic tree reconstruction may prefer to minimize consensus errors, while structural variation studies may instead focus on maximizing continuity and minimizing long-range errors.

contamination detection
although imetamos focuses on single-genome assembly, all inputs are considered as a metagenome to control against possible contamination. the winning assembly’s contigs and unassembled reads are analyzed by a taxonomic classification program. by default, imetamos uses the k-mer based kraken  <cit>  tool, but the alternative methods of fcp  <cit> , phylosift  <cit> , phmmer  <cit> , and phymmbl  <cit>  are also supported. contigs are partitioned into separate, taxon-specific directories  according to their classification, so that contaminating sequence can be easily identified and removed. this process also serves as an initial species identification when assembling novel organisms.

the classification result is dependent on the classifier and database used, and serves as only a preliminary species identification or indicator of potential contamination. manual follow-up is recommended to confirm the classification. for example, recently acquired genomic elements, such as phage integrations, may be incorrectly classified. nevertheless, this initial binning facilitates rapid identification of the assembled organism and easier contaminant removal before downstream analysis or submission to a nucleotide archive.

results display
the final output of imetamos is a self-contained html <dig> summary page. here, users can browse the output files as well as drill down to detailed results from any step in the pipeline. this includes fastqc  <cit>  reports for the preprocess step, quast  <cit>  graphs and metrics from the validation step, and an interactive krona  <cit>  display of the taxonomic classifications.

RESULTS
automated assembly evaluation
with imetamos it is possible to automatically recreate an assembler evaluation for every sample. we used imetamos to perform ensemble assembly of the rhodobacter sphaeroides  <dig> . <dig> miseq dataset from the recent gage-b evaluation  <cit> . in addition, our automated evaluation included four additional assemblers  and validation metrics not utilized by gage-b .

the gage-b evaluation included assemblers run with multiple, manually selected k-mers for each assembler that ranged from a minimum of  <dig> to a maximum of  <dig>  for a thorough comparison, the r. sphaeroides dataset was downloaded from the gage-b website , and two imetamos runs generated, both with an auto-selected k of  <dig> as well as all k-mer sizes divisible by  <dig> from 25– <dig>  the original gage scripts  <cit>  were used to calculate both corrected and raw n50s on all imetamos assemblies and those from gage-b. in some cases, imetamos ran a more recent assembler than gage-b. repeating the experiment using the exact software versions as gage-b produced the same results, with the exception of spades, which showed assembly improvement in version  <dig> . the entire auto-selected k-mer imetamos run can be reproduced using the following commands:  

the best assembly of this dataset, as selected by imetamos with an automatically chosen kmer-size of  <dig>  was masurca, matching the gage-b result. however, the corrected n <dig> of the imetamos masurca assembly increased to  <dig> kbp from the  <dig> kbp using the manually selected k-mer size of  <dig> reported in gage-b. similar improvements were observed for four assemblers when compared to the manually selected k-mer in gage-b. this improvement is the result of selecting a value of k to maximize assembly correctness, rather than the gage-b approach of maximizing the uncorrected contig n <dig> size. in cases where imetamos did not outperform the gage-b results, gage-b had utilized ea-utils  <cit>  to pre-process the data. while ea-utils is supported by imetamos, using raw sequencing data generated the best assemblies in gage-b, so pre-processing was disabled.

figure  <dig> shows the raw and corrected n50s for all assemblers with k ranging from 25– <dig>  this example illustrates the power of imetamos, with each run being equivalent to a gage-style assembly evaluation. in addition, for  <dig> of  <dig> assemblers, the kmergenie auto-selected k of  <dig> provided a ratio of corrected to raw n <dig> contig size within 10% of the optimal . because the corrected assemblies are broken at each mis-assembly, the ratio of corrected to raw n <dig> size is a good indicator of error rate. thus, these results suggest that simply running each assembler with an auto-selected value of k will produce high-quality assemblies without the computational expense of producing separate assemblies for multiple values of k.

the benefit of intelligently choosing a minimum overlap length  or a value of k  is also obvious from figure  <dig>  as it changes the relative rankings of assemblies compared to the gage-b evaluation. in one example, mira goes from a corrected n <dig> of  <dig> kbp  to  <dig> kbp —an increase of over 3-fold. the comparative ranking of assemblers on this dataset is given in table  <dig> 
r. sphaeroides 
dataset

the table lists the relative ranking, assembly, and corrected n <dig> for each of the  <dig> assemblers common between gage-b and the imetamos run using an automatically-selected k-mer. assembly n <dig> was computed using the reference as the true genome size. corrected n <dig>  was calculated as in gage  <cit> . the short-range errors are a sum of snps and short and long indels. the long-range errors are a sum of translocations, relocations, and inversions.

contaminant detection
the detection and removal of contaminating dna sequences is an often-overlooked phase of assembly. for example, the assemblathon  <dig> dataset included mock contaminant, which only a few teams attempted to detect and remove  <cit> . failure to remove real contaminant from assemblies significantly affects the quality of public databases to which these genomes are submitted.

to assist in contaminant detection and removal, imetamos supports multiple tools that taxonomically classify the assembled contigs and reads left unassembled. to test this process on a large scale, we downloaded and analyzed the raw sequencing data from  <dig> samples from a recently published study of mycobacterium tuberculosis <cit> . all  <dig> runs corresponding to project erp <dig> were downloaded, and imetamos was run using the ensemble of spades, masurca, and velvet. the imetamos run for an individual sample can be reproduced using the following commands, which downloads the data directly from the sra:  

this also represents the first assembly of these samples, as the original publication focused only on read mapping . the dataset included paired-end and single-end data and sequence length ranged from 51 bp to 108 bp. the average number of contigs using unpaired data was  <dig>  n <dig> was 17kbp, and average k-mer size used was  <dig>  for paired-end data, the average number of contigs was  <dig>  n <dig> was 43kbp, and average k-mer size used was  <dig>  the spades assembly was the best 88% of the time . on average, an imetamos analysis of a single sample took  <dig>  hours using  <dig> cores. the assembly, validation, and findorfs steps took approximately 50% of the runtime. classification to identify contaminant took approximately 34% of the runtime .
m. tuberculosis
samples

the table lists the average run per sample for the longest-running steps within imetamos. timings were collected on a 16-core  <dig> ghz amd with 32g ram. full runtime details are available in additional file  <dig> 

while the majority of samples  indicated no contamination, several showed signs of having multiple organisms present, such as sample err <dig>  in this case, the assembly has significantly more bases than expected  and an unusually large number of contigs . figure  <dig> shows the html summary for sample err <dig>  with the validation tab selected. this tab provides information on the selected assembly, quality statistics for all assemblies, as well as an indication of contamination in the sample. figure  <dig> summarizes the imetamos classification output for sample err <dig>  m. tuberculosis is clearly the dominant constituent, but a significant fraction of sequences are assigned to other bacteria or are left unclassified . to validate the imetamos output, we aligned the classified sequences to m. tuberculosis nitr <dig>  and s. aureus usa <dig>  using dnadiff  <cit> . sequences classified as mycobacterium had an average identity of  <dig> % and  <dig> % coverage of the reference. sequences classified as staphylococus had an average identity of  <dig> % and  <dig> % coverage. over half the s. aureus reference genome is present in the dataset, confirming the contamination as the most likely source of these reads. the difference in reference coverage between all assembled contigs and classified contigs was less than 1%, indicating the classifier accurately assigned contigs. all 7 m. tuberculosis samples identified by imetamos as potentially contaminanted were manually examined and had similarly large assemblies with an unusual number of sequences classified as either microbial or unknown. using blast  <cit>  confirmed both eukaryotic  and microbial contaminant in these samples.

discussion
we have developed an open-source microbial analysis pipeline, imetamos, which automates the process of ensemble assembly. in addition, its modular architecture is extensible and able to incorporate additional analyses or alternative tools. a potential enhancement is assembly correction, or contig breaking, which imetamos does not currently support. however, the infrastructure required to support this is largely in place. for example, reapr  <cit>  is included with imetamos and capable of splitting assembled contigs at predicted mis-assemblies. using this and other supplied validation tools, assembly breaking could be iteratively performed until the validation scores are no longer improving or no more corrections are possible. alternatively, because imetamos generates multiple assemblies, assembly reconciliation techniques  <cit>  could be incorporated into the pipeline. however, in practice, we have found the simple process of running multiple assemblers with multiple parameters is capable of generating high-confidence assemblies on its own, while merging assemblies can increase the risk of mis-assembly without significantly improving continuity  <cit> .

the imetamos extensible framework also supports customizable workflows and parameters on a per-user or per-run basis. because all components of imetamos are open source, users and tool authors are able to contribute improved parameters to the repository. users can also contribute custom workflows tailored for specific analyses. in this way, imetamos can serve as a best-practice repository for multiple assemblers, data types, and analysis tools.

CONCLUSIONS
imetamos enables accurate and reproducible genome assembly via a “gage-in-a-box” analysis, allowing non-expert users to run multiple assemblers, validation metrics, and annotations with a single command. results are presented in a simplified and interactive html <dig> format, and reproducibility is enabled through detailed logging and workflows. the current implementation supports over thirteen assemblers and seven validation tools, and its modular architecture supports the easy addition of future tools. ensemble assembly is more robust, reproducible, and accurate than manual assembly, even surpassing the quality of gage-b assemblies using the same data and tools. most importantly, imetamos provides users with a simple means to generate multiple assemblies and validation metrics, empowering them to choose the best assembly for their specific needs.

availability and requirements
project name: imetamos.

project home page:http://www.cbcb.umd.edu/software/imetamos.

operating systems: linux/os x.

programming language: python, c++, perl, and java.

other requirements: perl , python , java , r , gcc , git, curl.

license: imetamos and metamos-specific code are released open source under the perl artistic license  <cit> .

all assemblies described here are available for download from http://www.cbcb.umd.edu/software/imetamos. the exact version of imetamos used for analysis in this manuscript is available from ftp://ftp.cbcb.umd.edu/pub/data/metamos/imetamos_pub.tar.gz. however, we recommend using the latest release for all analyses.

competing interests
the authors declare that they have no competing interest.

authors’ contributions
sk and amp conceived the method and drafted the manuscript. sk, tjt, and cmh developed the software. mp led the development of the metamos framework. all authors edited and approved the final manuscript.

supplementary material
additional file 1
assembly statistics and reference-free validation scores for all assemblers used on the 
m. tuberculosis 
dataset.

click here for file

 additional file 2
computational time for the longest-running steps within imetamos as well as total times per sample for the 
m. tuberculosis 
dataset.

click here for file

 acknowledgements
we thank magoc et al. and comas et al. who submitted the raw data that was used in this study. we thank lex nederbragt and an anonymous reviewer for detailed comments on the manuscript and imetamos software, usability, and documentation. the contributions of sk, tjt, and amp were funded under agreement no. hshqdc-07-c- <dig> awarded by the department of homeland security science and technology directorate  for the management and operation of the national biodefense analysis and countermeasures center , a federally funded research and development center. the views and conclusions contained in this document are those of the authors and should not be interpreted as necessarily representing the official policies, either expressed or implied, of the u.s. department of homeland security. in no event shall the dhs, nbacc, or battelle national biodefense institute  have any responsibility or liability for any use, misuse, inability to use, or reliance upon the information contained herein. the department of homeland security does not endorse any products or commercial services mentioned in this publication. mp and cmh were supported by nih grant r01-ai-100947and the nsf grant iis- <dig> 
