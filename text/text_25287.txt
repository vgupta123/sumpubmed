BACKGROUND
in diploid individuals, such as humans, each chromosome exists in two copies, also referred to as haplotypes. one haplotype is inherited from the father while the other haplotype is inherited from the mother. although these two copies are highly similar, they are not identical, reflecting the genetic differences between mother and father. a single nucleotide polymorphism  is a variation of a single nucleotide that occurs at a specific position, called locus, in the pair of sequences. given a set of heterozygous variants, i.e., loci where the two alleles differ, e.g. snps, the problem of assigning each of the two alleles at each locus to one of the two haplotypes is known as phasing.

phasing snps is important for many applications. haplotype-resolved genetic data allows studying epistatic interactions, for instance. gene regulation and epigenetics have also been demonstrated to be haplotype specific in many instances  <cit> . one of the prime uses of haplotype panels, i.e., large sets of haplotypes present in a population, lies in the imputation of missing variants, which is instrumental for lowering costs and boosting power of genome-wide association studies  <cit> . not surprisingly, constructing high-quality haplotype panels for human populations has been one of the central goals of several large-scale projects . further uses of haplotype data include studying evolutionary selection, population structure, loss of heterozygosity, and for determining the parental origin of de novo mutations. refer to  <cit>  for a detailed review of these and other applications.

currently, the most prevalent phasing tools use genotype information for a large number of individuals as input. therefore, phase information has not been observed directly, but is inferred based on the assumption that haplotype tracts are shared between individuals in a population. the resulting approaches are statistical in nature, based on, e.g., latent variable modeling , and markov chain monte carlo  techniques  <cit> .

noticeably, one of the major drawbacks of these statistical phasing methods is the lack of direct information that pairs of neighboring snps are on the same haplotype – something that is ultimately needed if one is chaining together the snps to form a pair of haplotypes. this can be provided by a sequencing read, i.e., a fragment of the actual dna sequence. the existence of a read containing a pair of heterozygous snps is direct evidence that they come from the same haplotype. however, current sequencing technologies often do not provide long enough reads to sufficiently link neighboring snps. this is why the most widely used phasing methods are based on statistical information compiled from a large amount of data about the relationship between snps, such as linkage disequilibrium  <cit> , or from patterns that arise in existing haplotypes, such as these aforementioned haplotype panels  <cit> .

it is long reads that will really solve this problem, one of the major reasons for the recent interest in long-read technologies. while still not competitive in terms of per-base cost and error rates, and not yet sufficient to completely overcome the above drawbacks, cutting edge technologies such as pacbio’s single molecule real time sequencing   <cit>  or oxford nanopore technology’s minion  <cit>  are already on the market. this is only the beginning – these technologies will mature and improve, and other ones are under development. this might eventually enable routine use of haplotype-resolved sequencing in clinical diagnostics and pharmaceutical research. so, in the next decade, when long reads become cheap and widely available, this will push to the forefront those methods that phase snps based on read information alone, the so-called haplotype assembly methods, a research area that has, until now, remained mostly of theoretical interest .

the haplotype assembly methods do exactly this: they assemble haplotypes from a set of sequencing reads. if two reads overlap on a snp position, and their base-pairs at this position are different, i.e., they are “conflicting”, then one can deduce that they are on different alleles of the chromosome. the idea of this is that one can take this conflict information between pairs of reads to obtain a bipartitioning of the reads into two sets, i.e., the two alleles. this, combined with reads that link neighboring snps would give us a complete phasing of all snps, i.e., a set of haplotypes based on direct observation, in contrast to being based only on statistical information. this is where the long reads come in: they will someday provide this information, making haplotype assembly a much-needed tool for phasing.

real data contains upstream errors, from the snp calling phase, or the read-mapping phase, and so this becomes an optimisation problem: to obtain such a bipartitioning that involves correcting the minimum number of errors to the base-pairs of the reads. there are several different types of optimisation criteria in the literature, some of them equivalent. however we focus here on the minimum error correction   <cit> , as it is the most general of the criteria. current read information is in the form of many short reads, that may pile up on certain snp positions. up to  <dig>  the current state-of-the-art of haplotype assembly methods  <cit>  solved mec with approaches that scale, in terms of computational complexity, with the read-length. in addition to this drawback, these algorithms take advantage of the fact that many neighboring snps are not linked by these reads, because it allows to decompose this optimisation problem into independent subproblems. when reads get longer, these subproblems will no longer be independent – they should not be, since the goal is to link all of the snps. also, a proportionally lesser coverage, i.e., the number of reads that cover a snp position, will eventually be needed to obtain relevant information.

it is for these reasons that the authors of  <cit>  introduced whatshap, the first fixed-parameter tractable   <cit>  approach for solving the weighed minimum error correction   <cit>   where coverage is the only parameter. the runtime of this approach is linear in the number of snps per read, which is the term that will increase by orders of magnitude as longer and longer reads become available.

a distinguishing feature of whatshap with regards to the other currently available proposals is that it is exponential in the sequencing coverage and not in in read length. this appears to be very relevant when considering current trends in future generation sequencing technologies: technical improvements will clearly yield longer reads. the whatshap algorithm has been implemented in a freely available toolkit .

because whatshap is the first approach in this promising direction, it appeared worthwhile to speed up its implementation by parallelising it. this paper presents pwhatshap, an optimised parallelisation of whatshap, and its implementation in a toolkit which is also freely distributed . pwhatshap has been a developing project, evolving together with the very active development of whatshap. preliminary results on the parallelisation experiment of the core structure of the algorithm were reported in  <cit> . in this paper we report on the parallelisation of the latest version of whatshap, which has matured into an integrated framework engineered according to the current trends in genetic applications, and capable of analysing data in standard file formats  used in genomic analysis.

the merits of this work are: 
the pwhatshap project provides the research community with a freely available application, which can easily be embedded in analysis pipelines requiring the solution of haplotyping problems. the core of the parallel haplotyping algorithm consists of an advanced and optimised implementation tailored to multi-core architectures. such an enhanced core has now been engineered in the integrated framework described above, supporting standard data formats. this is a major engineering step, requiring the embedding of several c++ core functions, coherently running as a parallel application, into a framework developed in python. this allowed the pwhatshap project to move from a prototype development phase to a mature, open-source product. haplotyping can be typically employed in larger pipelines, for instance including other typically expensive steps, such as data acquisition and result analysis. the provision of efficient solutions to haplotyping, such as pwhatshap, empowers more accurate analysis in all those contexts.

the incremental construction of haplotypes in whatshap is the type of algorithm whose parallelisation is very difficult. these algorithms process a large amount of data and are therefore sensitive to the availability of sufficiently large amounts of memory . their exponential complexity , and the huge datasets currently available, easily make memory availability a critical parameter. parallelising one of the problems of this type represents an engineering challenge. the solution adopted is supported by the fastflow framework  <cit> , which provides high-level parallel programming constructs, such as skeletons and parallel design patterns. thanks to the high-level programming paradigm adopted, it has been possible to build pwhatshap retaining most of the overall structure and code of whatshap. the chosen paradigm has also the advantage to limit the need for mutual exclusion mechanisms, known to be typically slow. the clear performance improvement obtained supports the efficient treatment of large datasets and high coverage. it is important to note that the presented results can be obtained by computers that may easily equip current state-of-the-art genomic laboratories. such improvement in the computational efficiency of haplotyping, made available at affordable costs, may be key in several analysis pipelines.

a comprehensive evaluation of the obtained results has been carried out, both theoretically and experimentally. first, the correctness of pwhatshap has been validated against whatshap: both applications return identical results in terms of the wmec score of the computed optimal solutions. following correctness, the accuracy of pwhatshap has been discussed in terms of the accuracy of whatshap, which is known to be strong. we discuss various aspects of the accuracy of whatshap and review the several constraints under which the competing approaches to haplotyping work. pwhatshap emerges as an accurate and largely applicable approach. the efficiency of pwhatshap is discussed against theoretical complexity results, and validated by means of experimental results over benchmark datasets. overall, the large applicability and accuracy of pwhatshap, together with its increased efficiency, make it a reference player in the quick developing quest for solutions to the haplotyping problem.



in the next section, methods, the problem of haplotyping will be defined and the whatshap approach described. then, the details of the construction of pwhatshap are illustrated and the choices made in the engineering of the parallel solution discussed. an account of fastflow, the supporting high-level parallel programming framework, concludes the section. the results section evaluates the performances of pwhatshap. two main parameters are considered to illustrate the validity of the developed application: accuracy of the returned results, and efficiency of the computation. the accuracy of pwhatshap builds on top of the accuracy of whatshap, as discussed. efficiency, instead, is demonstrated by means of suitable experimental results on benchmark datasets. concluding remarks follow.

methods
haplotyping: a fixed-parameter tractable solution to wmec
the haplotype assembly problem takes as input a set of reads of a diploid genome that has been mapped to some reference genome. for such a genome, the snp positions are known, and the set of alleles are arbitrarily re-labelled to  <dig> and  <dig> for each snp position. this makes the input as a matrix with reads as rows and snp positions as columns.

more formally, the input data for n reads and m snp positions is organised in an n×m matrix f. the cells fi, j of f have values in { <dig> ,−}, indicating whether the read i at snp position j has the value of allele  <dig> or of allele  <dig>  or it does not cover the snp site at all, i.e., the respective read is not active at this snp position. a confidence value  vi, j is assigned to each active fi, j as part of the input to the problem. the weight vi, j is obtained at preprocessing as a combination of the confidence degree of that value after the sequencing phase  and after the mapping phase . in this way, the weight gives a measure of how likely value of fi, j is correct. that is, this weight represents the “cost” of flipping fi, j in the optimisation problem wmec, which aims to correct with higher priority the bases with higher probability of being inexact, as in  <cit> .

we say that two reads rp and rq have a conflict at a snp position j if they are both active and have different values at column j. if there were no errors, two reads in conflict necessarily come from different alleles. a correct haplotype assembly is a bipartitioning of the rows of matrix f  into a pair of conflict-free sets r and s. both r and s contain each the whole set of reads that have been identified as belonging to the same haplotype. however, conflict-free bipartitioningss rarely can be found in existing datasets because of sequencing and mapping errors. therefore, it is important to be able to determine a minimum-weight set of corrections to such errors capable of making the bipartitioning conflict-free. as an example, the following fragment matrix f has not a conflict-free bipartitioning of its fragments : 
 f=19190318− <dig> 

subscripts are a measure of confidence of each datum, i.e., vi, j, the cost to be paid to “correct” it. the minimum cost, conflict-free bipartitioning r={f <dig> f2}, s={f3} can be obtained by correcting the element f <dig> , i.e., flipping it to a  <dig> at a cost of  <dig> 

several heuristic proposal to solve the mec, e.g. the greedy approaches of  <cit>  to assemble haplotypes of a genome, based on sampling a set of likely haplotypes under the mec model  <cit> , and the much-efficient follow-up, analogous to  <cit> , and based on an iterative greedy approach to optimise the max-cut of a suitably defined  <cit> . improved perfomrmances do not impact on accuracy. mousavi et al.  <cit>  reduces mec to max-sat, which is then be solved by a heuristic solver.

a heuristic, by definition, provides no bound on the quality of the obtained results, what each of these above methods are. in order to solve optimally the mec problem, several non-heuristic, exact algorithms exist in the literature. examples include the integer linear programming techniques of  <cit> . another way to solve a problem optimally is fixed-parameter tractable  algorithms. several fpt algorithms for the mec have been developed in  <cit> . nonetheless, the complexity of  <cit>  is exponential in the read length, or the number of snps per read, which will soon become larger quite quickly with the developments of sequencing techniques. in turn, hapcol  requires the fragment matrix to be gapless , which exclude the applicability to datasets with paired end reads. also, given that the hapcol is exponential in the number of corrections , then it actually solves a constrained version of the mec problem where the number of correction is bounded a priori. whatshap  <cit>  is an algorithm that is fixed parameter tractable in the coverage, rather than in read length it is hence much more suitable to the trends in development of current sequencing techniques. not long after the publication of whatshap, a very similar algorithm that is based on belief propagation was developed independently by kuleshov  <cit> . the following section gives a brief summary of the whatshap algorithm.

whatshap: the algorithm
the original sequential whatshap uses dynamic programming. it takes as its input the fragment matrixf  and a set of confidence values associated to the reads’ active positions. whatshap returns a conflict-free bipartitioning of the set of reads of minimum cost, using a dynamic programming approach.

the cost matrixc built by whatshap has the same number of columns as f , and is constructed in an incremental way, a single column at a time. fj represents the set of active reads in the j-th column. c) is the cell in the j-th column of c corresponding to , one of the possible bipartitionings of fj. then, whatshap computes the minimum-cost c) of making  conflict-free, over all possible bipartitionings  of fj.

a read that spans several consecutive snp positions induces dependencies across the columns, given that such a read must be consistently assigned to the same allele over all the positions for which it is active – e.g. read   <dig> in the matrix of the previous example. when whatshap computes the cost of the bipartitionings of fj in order to construct the j-th column of c, the  cost that is inherited by constructing compatible partitionings in the previous position fj− <dig> must also be considered. such a cost, on its turn, carries the price for consistency with the preceding columns.

in the initial column of c, which refers to s belonging to f <dig>  entries c) depend only on the cost of making r and s conflict-free .

the cost wr <dig> of making r⊆f <dig> conflict-free by flipping to 1s all 0s in fk, <dig>  is equivalent to the sum of the weights associated to the 0s which are flipped. alternatively, we indicate with wr <dig> the cost of making r conflict-free by flipping to  <dig> all the 1s. at any such step, whatshap takes the alternative that is most advantageous: 
 c)=minwr <dig> wr0+minws <dig> ws <dig>  

when building column j-th, the cost associated to each partitioning is the sum of the cost coming from the column itself, computed as in the first column, and the cost of a compatible bipartitioning inherited from the previous column. that is, when computing c), with j> <dig> and  a bipartitioning of fj, the local contribution of the jth column is the minimum cost of making r and s conflict-free over the jth column of f. then, the cost of ensuring that  is consistent on all the columns i<j must be added. this is the minimum cost of all the c), such that  is “compatible” with . a partitioning  defined at j and a partitioning  defined at j− <dig> are compatible, written ≅, when each element in fj∩fj− <dig>  i.e., the active reads in both j and j− <dig>  is assigned to the same subset in  and in . importantly, in such incremental construction the cost in the preceding column j− <dig> summarises all correction costs made to keep  conflict-free from column  <dig> up to column j− <dig>  it follows: 
 c)=minwr <dig> wr0+minws <dig> ws0+minc)|≅ 

the implementation of such an algorithm for the j-th step consists of 
all the possible  at j are defined;

column j is made conflict-free and the minimum cost for this is determined;

the minimum-cost compatible partitionings computed at step/column j− <dig> are identified;

the entry c) is filled in with the sum of all outcomes of the previous two steps.



after the completion of the construction of c, the result of the input wmec instance is contained in the conflict-free partitioning  of smallest cost in the final column. such solution also encodes all the  corrections made during the construction of c, based on assigning reads in f to partitionings compatible with .

the maximum number of bipartitionings computed in the construction of each column determines the complexity of whatshap. at each column j the possible bipartitionings are 2|fj|. therefore, the complexity is exponential in the number of active reads at any position, i.e., the the sequencing coverage .

the sequential version of whatshap makes use of several optimisation to speed up the computation. among them, one is actually relevant for its parallelisation: the order in which bipartitionings are taken into account. specifically, when computing column j of c, the possible bipartitionings of fj are processed in a specific order, that is, according to its gray code ordering. gray code guarantees that the binary representation of each bipartitioning differs from that of the previous one by only one bit, for example,  <dig> and  <dig> . this entails that two subsequent partitionings differ only because of a single read moving from a set to another. this results in an incremental computation that is more efficient, since, the computation of the new cost for the subsequent partitioning comes from the cost of the previous one in constant time, because updating wr <dig> wr <dig> ws <dig> ws <dig> requires constant time when they differ only because of a specific single read. as we will see, this organisation is relevant when partitioning the workload in parallel tasks.

whatshap: an integrated toolkit for haplotyping
since the first prototype described in  <cit> , the sequential version of whatshap is currently an integrated toolkit. to facilitate seamless integration into data analysis pipelines, a new command-line user interface supporting general file formats  has been added. considerable effort has also been invested into optimised algorithms for read pruning, e.g. in order to control the maximum coverage. furthermore, the major modules have been reengineered in python, a suitable and largely used development environment in bioinformatics. the core haplotyping algorithm is still a c++ application.

pwhatshap: high-performance whatshap on multi-core architectures
the focus of this work is on parallelising the core haplotyping algorithm embedded in the whatshap integrated toolkit described above. the main rationale behind such a choice are the desirable properties of whatshap: solving wmec with a complexity that does not depend on read length, but is exponential only in the sequencing coverage. this appeared to be particularly relevant when considering the future trend of sequencing technology, which are inching towards longer reads. furthermore, solving the weighted version of the problem caters to its accuracy.

two main approaches to parallelisation can be followed, respectively focusing on the haplotyping of a single chromosome or many of them. actually, single chromosome datasets that can be decomposed in “independent” sets of snps, i.e., no read covers any two of these sets, can be addressed as if the sets were belonging to different chromosomes. the many instances of haplotype assembly required for the different genes of a whole genome, or independent sets of snps of the same gene, are completely independent. they can be run concurrently in an embarrassingly parallel fashion. since haplotyping is a memory-bound algorithm, it exhibits the best scalability when executed on distributed platforms  where the memory hierarchy and the file system are not shared resources among executors. independent runs of pwhatshap could be supported by the cloud computing services, which are regarded as enabling technologies for bioinformatics and computational biology because they can provide pipelines with computing power and storage in an elastic and on-demand fashion. in this paper we address the parallelisation of the core haplotyping algorithm for a single chromosome, and the consequent development of the pwhatshap toolkit, i.e., the parallel version of the whatshap toolkit. in this, we directly selected multi-core as target platforms class for three fundamental reasons: 1) simplicity of porting; 2) minimal disruption with respect to existing sequential code; 3) concurrency grain availability in the fine- to very fine-grained range.

pwhatshap: the parallel algorithm
in the parallelisation of the core haplotyping algorithm for a single chromosome, the structure of whatshap clearly imposes strong constraints on the parallelising approach that can be followed. the incremental approach of whatshap when building the solution, i.e., the column-wise exploration of the input matrix, imposes a strong linear dependency of each step on the immediately preceding one. this makes very difficult to imagine a possible decomposition of the problem by sets of columns that can be independently processed in parallel.

given that whatshap follows the described linear incremental construction of a solution by columns, and this makes the decomposition of the problem in sets of columns independently processed not viable, a “row-based” parallelisation has been adopted. each parallel executor processes a number of the elements  of the column of the cost matrix under consideration, that is, each executor evaluates some of the bipartitionings  of fj, which are the active reads on column j. a column-based decomposition, as well as hybrid solutions possibly mixing the two approaches, are the scope of future work.

the first step when moving from the sequential design of whatshap to a row-based parallel implementation was profiling the efficiency of whatshap in terms of the time needed to generate the j-th column of c, the minimum cost matrix c . this is useful to determine whether a column of a given coverage requires enough work to be worth parallelising it. table  <dig> shows data from a profiling test on a given dataset. the time required by the sequential algorithm for processing a column is reported in the second row, according to the column dimension. this is a function of the number of possible bipartitionings of the active reads on the column, i.e., it depends on the coverage . it is easy to appreciate its exponential growth. from the results summarised in the table, the cost for the smaller columns  is negligible, less than one ms, therefore not justifying the parallel overhead. differently, when c> <dig>  the cost varies from a few milliseconds to a few seconds for each column . columns with coverages bigger than 16/ <dig> are worth being parallelised.whatshap profiling. test for an input data sample with coverage  <dig> on a  <dig> cpu xeon e5- <dig> @ <dig>  ghz, 12-core x  <dig> context for each cpu,  <dig> gb ram



what is also interesting is to gauge how many columns worth being parallelised are present in a given dataset. this of course is highly dependent on the specific dataset, but carried out experiments show that a sufficiently large number of high-coverage columns justify the parallelisation, as shown in the section results. statistical analysis of this kind are useful to predict the gain that can be achieved. depending on factors like the specific architecture, the incurred overhead of parallel executions, and data distribution, it might be worth it to implement an adaptive partitioning, where the number of executors is tuned to the dimension of each column. after some empirical validation, we have abandoned this possibility because it did not appear to be of much value for our reference architecture and settings. overall, this appears as a fine-grained algorithm, typically difficult to be parallelised, but, interestingly and not surprisingly, the best speed-ups can be obtained with large coverages, which are of great interest, since they provide increased accuracy.

in the following, the parallel construction of a minimum cost matrix c that we designed for pwhatshap is presented through a simple example . let us consider the fragment matrix f in fig.  <dig>  which has two columns only, with associated weights . in f, for instance, read f <dig> is  <dig> in snp  <dig> with confidence  <dig>  while read f <dig> covers snps  <dig> and  <dig>  where is  <dig> and  <dig> with confidence  <dig> and  <dig>  respectively.
fig.  <dig> the fragment matrix f




the cost matrix c), reported in fig.  <dig> and associated to the first column of f, is built by considering all the possible bipartitionings  of the reads active on snp  <dig>  i.e., f <dig> f <dig> and f <dig>  in the matrix c), partitionings are represented as binary strings in gray-code order , as reported in the first three columns. in the example under consideration, the set of all possible bipartitionings is split between two executors . parallel executors work on disjoint section of the partitioning space. in order to retain as much as possible the original structure of the sequential algorithm, bipartitioningss are processed sequentially by each executor according to the gray code order. a bit of care is necessary to properly identify the entry points for each executor, i.e., the as in red in the matrix, in the gray code sequence. suppose that an executor is expected to process a set of partitionings starting from the r−th one. this will not necessarily be identified by the r−th binary number, as expected, but actually by the r−th entry in the gray code. for instance, in the matrix, the second entry point a is not  <dig>  as one would expect, but  <dig> 
fig.  <dig> the cost matrix c)



each entry in the column c <dig> in the matrix c) reports the cost of making the corresponding partitionings conflict-free. this is the only cost incurred so far, dealing with the construction of the first column. for instance, partitioning   requires flipping f <dig> to  <dig> at a cost of  <dig> , so that r is conflict-free and s empty.

the last three columns of c) show the corrected values of the reads.

considering cj, the j-th column of c and k executors, each executor computes a number of bipartitionings of fj in the range of 2cj/k, with cj the coverage and k that may be dynamically adapted according to the coverage . each one of the k executors processes the assigned bipartitioning in parallel. this is the map-phase, see fig.  <dig> 
fig.  <dig> the fastflow skeleton used in pwhatshap. each entity is a concurrent thread. the emitter  produces and schedules tasks towards a pool of workers . each worker sends results to the reducer  and asks for new tasks from s




in the construction of cj, the cost of any specific bipartitioning of the reads active on the j−th column depends on the minimum costs of the bipartitionings in cj− <dig> which are compatible with that partitioning. in our example, f <dig> and f <dig> are active in both columns  <dig> and  <dig>  bipartitionings  <dig> and  <dig>  from columns  <dig> and  <dig> respectivley, are compatible and could eventually lead to . instead,  <dig> and  <dig> are not compatible . cost information about compatible partitionings between any two columns is recorded in a suitable matrix . in our example, such matrix would be the one reported in fig. 4: each executor over-writes the currently discovered best cost for that specific partitioning. this may cause write conflicts, whenever different executors report costs associated to the same row. in the example this is indicated by w, in red, in the matrix, and it is due to the two executors working on c) and attempting to update the  cost of having both f <dig> and f <dig> in the “0” partitioning. note that there are two cases in which this happens, marked in red in the partitioning columns of c) in fig.  <dig> , and these two cases are being dealt with by different executors. such case of write conflict has been addressed by constructing local copies of the table for each executor, and then managing their merging by means of a sequential reduce-phase, executed in pipeline with the map-phase .
fig.  <dig> cost information about compatible partitionings between any two columns



minimum costs recorded as in fig.  <dig> are then accumulated in the definition of the so-far-incurred costs in the construction of the cost matrix for the next column of the fragment matrix f, as shown in fig.  <dig> . this last matrix is built on top of the three reads in the second column of f. the c <dig> column reports the cost of the local corrections for making each partitioning of {f <dig> f <dig> f4} conflict free, as standard. the minj−i carries over the minimum costs recorded in the previous table ,1) in our example). the last column Σ reports the so-far-incurred minimum costs to make each partitioning conflict-free as the sum of the previous two columns. possible concurrent read accesses to the previous table, as the ones in red ,1) is copied twice - possibly by different executors, in minj−1), are of no particular concern.
fig.  <dig> the cost matrix c)



the partitioning  is conflict free and minimal cost, once that f <dig> has been corrected in  <cit>  at the cost of  <dig>  this is an optimal solution found by pwhatshap, built in the last and first rows, respectively, of the two cost matrices above.

it is worth remarking that whenever two or more solutions with the same minimum cost exist, due to the interplay of the different amounts of time spent by different executors to accomplish their parallel tasks, non-determinism may occur when overwriting minimum costs, and, as a consequence, different optimal solutions of same cost can be returned from different runs. the comparison and properties of such equivalent solutions is scope for future work.

pwhatshap: the parallel implementation
the focus of the present work is the parallelisation of the core whatshap haplotyping algorithm, which is a component of a larger application whose main module is written in python, with cython used for interfacing python and c++. our starting point is the whatshap core algorithm written in c++, which is actually embedded into a larger, multi-language application, making the development of the parallel version very elaborated, for instance requiring us to work on the edge of different programming paradigms during both debugging and tuning.

the parallel construction of the minimum cost matrix c proceeds independently over the possible bipartitionings  of the current column fj. we aimed to exploit the maximum possible parallelism in this construction by exploiting both task and data parallelism. for this we used a pipelined map-reduce paradigm, i.e., pipeline.

in the map-phase, all the possible bipartitionings of the fragments in fj are generated; their cost is also computed. in the reduce-phase, the cost matrix c is updated with with the minimum cost found among all the bipartitionings generated in the previous stage.

in fastflow, this can be easily realised by nesting patterns implementing map and reduce phases within the pipeline pattern. the map-phase can be implemented by way of the task-farm-with-feedback pattern, which make it possible to execute independent tasks in parallel, i.e., generate and analyse all the possible bipartitionings. the feedback loop feature enables the pattern to implement a effective dynamic load balancing strategy. the reduce-phase can be implemented in a single worker since it is much lighter than the map-phase and is actually never a bottleneck for the whole process. overall:

pipeline, sequential)

where s is a task scheduling, wi, i= <dig> .n is array of workers for the map-phase, and r is a reducer worker for the reduce-phase  and eventually sends the produced data as a single task to the second stage of the overall pipeline . this way, for each worker’s input task, is produced an output task containing maximum chunksize different results. the second stage receives tasks from all workers  and then updates the cost matrix c with the minimum cost found . the r thread, is the only thread that performs write accesses to the cost matrix.

overall, it is possible to exploit: 1) scheduler–workers pipeline parallelism: the scheduler s computes all possible bipartitionings sending disjoint sub-partitionings to workers wi using a dynamic scheduling policy; 2) parallelism among workers: the computation of local minimum costs proceeds in parallel in all the wi; and 3) workers-reducer pipeline parallelisms: the reducer r receives multiple results in chunks from each worker.

it is worth noting that, the parallelisation strategy just described, is applied to only those columns that have a coverage larger than a given size .

this is because, the overhead introduced in the parallelisation of an excessively fine level of granularity with respect to computation , might overcome the advantages of the parallel execution. for this, is necessary to cut the application of parallel computing to kernels exploiting a minimum level of granularity. as we shall discuss in the results section, for pwhatshap the threshold value is set around coverage  <dig>  this value being almost independent of the input dataset considered.

the proposed parallelisation is quite direct and, importantly, requires minimal changes to the original sequential whatshap code. furthermore, a high degree of parallelisation is involved due to the many entries of the large fragment tablef corresponding to many  tasks that can be executed in parallel on the available cores.

the fastflow parallel framework
fastflow  <cit>  is a programming framework supporting high-level parallel programming for shared memory multi/many-core and heterogeneous distributed systems. it is implemented in c++ on top of the posix threads and the libfabric standard interfaces and provides developers with a number of efficient, high-level parallel programming patterns.

the framework offers a methodological approach that allows applications to be rapidly and efficiently parallelised on a broad range of multi/many-core platforms. thanks to its efficient lock-free run-time support  <cit> , applications developed on top of fastflow typically exhibit a good speedup because of the reduced synchronisation cost  and with a minimal tuning effort.

the parallelisation of whatshap here presented is based on fastflow. it exploits the cache-coherent shared memory of the underlying architecture, making it unnecessary to move data between threads, which is a typical source of overhead. however, if shared memory greatly simplifies the parallelisation, it also introduces concurrent data access problems which eventually turn into synchronisation overheads. parallel patterns defined and implemented by the fastflow framework solve these problems by defining clear dependencies among different parts of the computations, hence avoiding costly synchronisations.

fastflow has proven to be effective in parallelising a broad class of sequential applications and in redesigning concurrent applications originally developed with low-level abstraction programming tools, which typically hinder portability and performance on new multi-core platforms, e.g. . for the development of parallel version of whatshap, fastflow offered a methodological approach capable to support the parallelisation while keeping the needed modifications to the sequential code at a minimum.

RESULTS
the pwhatshap project focused on the design and development of a high-performance, parallel application for the solution of the haplotype problem. this has been done building upon the whatshap framework, an evolving tool-kit which currently supports several stages in the haplotyping pipeline and supports data analysis in standard formats. as illustrated, the choice of whatshap is justified by its performance in terms of accuracy, i.e., being able to provide solutions with a low percentage of errors, and its interesting computational complexity, which depends on the coverage of data sets rather than on the length of reads. this appeared as a desirable property in the light of the future trends in sequencing technologies that will yield longer and longer reads. indeed, other proposals based on similar approaches to computational complexity are being developed.

building upon the feasibility study presented in  <cit> , pwhatshap addresses in particular the efficiency of the core algorithm for the construction of correct haplotypes, and provides a multi-core, high-performance version of it that is fully integrated with the other stages of the whatshap framework. thanks to the parallelisation technique adopted, which requires minimal modifications to the the sequential code, the developed solution retains the accuracy properties of whatshap.

a detailed description of the accuracy and efficiency properties of pwhatshap is reported in the following. accuracy reduces to the accuracy of whatshap, since the sequential and parallel frameworks return identical results in terms of the wmec score, i.e., solutions of the same minimal cost, although pwhatshap can return a richer set of cost-equivalent solutions than whatshap. therefore, the accuracy of pwhatshap can be properly accounted for on the basis of the results existing in literature on the accuracy of whatshap. efficiency instead has been validated by suitable tests on a medium-size, shared-memory, multi-core computer, which could reasonably equip a genomics analysis facility. test results show the effectiveness of the parallel pwhatshap developed, as far as the core haplotyping module is concerned.

accuracy
in this section we compare the accuracy of pwhatshap against the accuracy of state of the art approaches to haplotyping. as explained, this is done by exploiting existing data about the accuracy of whatshap, given that pwhatshap exhibits the same behaviour as whatshap. in order to make this explicit, we will use whatshap where appropriate in the rest of this section.

the accuracy of reconstructed haplotypes can be validated by considering both error rate  <cit> , that is the count of phased variants presenting some discrepancies, and phased positions, that is the count of genomic positions for which a phased prediction can be identified out of all the phasable positions in the whole dataset. whatshap is compared to three tools which have been specifically designed for the long reads coming from third generation sequencing technologies: probhap  <cit> , a recent approach that uses a probabilistic graphical model to exactly optimise a specific likelihood function; refhap  <cit> , a heuristic method presenting very high accuracy; and hapcol  <cit> , a fixed-parameter tractable algorithm that computes linearly in relation of the number of snps and exponentially in function of the coverage. more precisely, hapcol’s time complexity is in o∑s=0kcovs·cov·l·m, where l is the length of the read, m the number of snps, cov the coverage, and k is hapcol’s input parameter of the maximum number of errors it corrects per column, while whatshap’s complexity is in o.

both a real and a synthetic data set have been considered for the comparison. the real dataset  was analysed in the hapmap project  <cit>  and it is a standard benchmark for haplotyping algorithms designed to work with long reads, since the haplotype of this patient, and also those of her parents, was independently reconstructed using genome sequencing techniques. the dataset consists of  <dig>  reads with average length of ∼ <dig> kb and with average coverage of ∼3x. variant calls have been achieved using the gatk  <cit>  considering the  <dig> , <dig> positions covered by the na <dig> dataset and are trio-phased. whatshap, refhap, hapcol, and probhap have been tested on each chromosome independently. the dataset used does not include paired end reads because hapcol cannot handle them. moreover, despite the fact that whatshap and hapcol can compute haplotypes outside the all-heterozygous hypothesis , in this test case, the all-heterozygous assumption was enforced for all the tools. even if the all-heterozygous assumption has no impact on their time/space complexities, the comparison between solutions achieved under different hypothesis may produce misleading results. considering that all the snps in the dataset are heterozygous with high confidence, this assumption is not strictly necessary in this case.
fig.  <dig> accuracy comparison amongst state of the art toolkits. whatshap  is top in minimising errors as well as in properly phasing, together with hapcol. data extracted from  <cit> 



in  <cit>  a synthetic dataset was also generated and used for comparative analysis on accuracy. specifically, the analysis aimed to assess how accuracy changes while varying the coverage of the dataset. given that the real, standard benchmark dataset previously used relies on the all-heterozygous assumption, and hence contains only heterozygous snp positions and has low average coverage, a synthetic datasets has been used to characterise the behaviour of tools against the long reads that will be soon available thanks to future-generation sequencing technologies .

the dataset has been generated inserting all the variants of chromosomes  <dig> and  <dig> of the venter’s genome into the hg <dig> assembly genome. long reads have been generated at length  <dig>   <dig>   <dig> , and  <dig>  using a uniform indel distribution of  <dig> % and substitution rates  <dig> and  <dig> %. these rates have been defined according to the information currently available about the accuracy of long read data generated using future-generation sequencing technologies . the final in silico datasets were achieved extracting from each set of simulated reads subsets with maximum coverage of  <dig> ×,  <dig> ×, and  <dig> ×.

since probhap and refhap require that haplotypes are computed outside the all-heterozygous hypothesis, only tests regarding whatshap and hapcol are relevant. data in  <cit>  shows a substantial coherence of whatshap and hapcol in terms of accuracy , and illustrate how accuracy, measured as error rate, improves with larger coverages. trends of such improvements are reported in fig.  <dig>  such data provides further grounds to the interest for pwhatshap, whose speed-up increases with coverage.
fig.  <dig> accuracy as error rate for increasing coverages. the curves in figure show how the accuracy scales up  with larger coverages. curves represent data for venter’s chromosome  <dig> and  <dig> with substitution error rate  <dig> and  <dig> %. from coverage  <dig> to coverage  <dig> the error rate decreases by about  <dig> %. based on data extracted from  <cit> 



although hapcol, together with whatshap, has high accuracy on these datasets, it is worth recalling that hapcol has a couple of substantial drawbacks with respect to whatshap. the first one is the above mentioned requirement for the fragment matrix f to be gapless, which results in the heavy limitation of not being usable with paired end reads. the second one is that hapcol actually solves a constrained version of the mec problem  that limits to a given parameter k the amount of errors that can be corrected. this is due to efficiency reasons, because hapcol takes time and space exponential in the amount of corrected errors. moreover, for the same reason, hapcol actually requires the assumption that errors are uniformly distributed, which is not very realistic for certain sequencing technologies. finally, the computational complexity of hapcol is also exponential in the coverage, even if not as strongly as whatshap.

efficiency
in this section we outline results of experiments aiming at assessing the performance of the proposed parallel algorithm. all the experiments have been performed on a platform equipped with two e5-2695@ <dig>  g hz ivy bridge intel xeon processors, each with  <dig> cores,  <dig> g bytes of memory, linux red hat  <dig> . <dig> with kernel  <dig> . <dig>  cpu dynamic frequency scaling and turbo frequency boost have has been disabled to ensure a fair comparison among codes using a different number of cores. both parallel and sequential codes have been compiled with gcc  <dig> . <dig> using –o <dig> optimisation level. the parallel version was executed using the shell command numactl –interleave=all to exploit all the available memory bandwidth of the  <dig> numa nodes of the hardware platform.

experiments have been run on a range of synthetic data sets with maximum coverage of  <dig> , <dig> , <dig>  and  <dig>  which have been generated from a single data set with an average coverage of  <dig>  mapped to human genome and then pruned to smaller coverage data sets . such coverages correspond to fairly large data sets. performance has been evaluated by measuring the computation time elapsed in the computation of subsets  of each data set. the dimension of each subset was chosen to guarantee that the entire produced output could fit in main memory.

firstly, we executed a set of tests aimed at assessing the time needed to compute columns of different coverage. on the considered platform we observed that it is worth parallelising only columns with a coverage ≥20; we define them as higher coverage columns. columns with coverage of  <dig> have an average computation time of about  <dig>  ms. the average time from processing columns with a coverage < <dig> is less than  <dig> ms; we defined them as lower coverage columns.

for higher coverage columns, we observed that the best execution time was obtained by using all the cores of the platform , specifically  <dig> worker threads for the map phase and  <dig> thread for the reduction phase. conversely, for columns with lower coverage the synchronisation overhead exceeds the performance gain, thus they are computed with sequential code.

the speedup of the proposed parallel pwhatshap against the original sequential whatshap is reported in table  <dig>  specifically, the table reports the average computing time for a column for the reference dataset, filtered by different maximum coverages. for each filtering, the whatshap and pwhatshap performance is reported together with the speedup of pwhatshap over whatshap, defined as speedup = tseq/tpar. for all coverages, the amount of main memory used was fixed to ∼ <dig> gb in all the tested cases.
tseq
tpar


considering the case of the dataset filtered for max coverage  <dig>  the fraction of sequential time, including both the columns whose construction is not parallelised and inherently sequential parts of the application, amounts to about  <dig>  % of the overall computation time. in that case, from amdahl’s law  <cit>  it follows that the maximum possible speedup would be around  <dig> . indeed, if f is the fraction of the algorithm that is strictly sequential, i.e.,  <dig>  % in our case, which is about 1/ <dig> , then the theoretical maximum speedup that can be obtained with n threads is s=1/f+1n, i.e., 1/f≃ <dig>  with n→∞.

the average execution time for computing columns with fixed coverage for several different coverages is reported in table  <dig>  the per-column gain obtained, is in the range 1– <dig> , with a gentle but monotonic increase of speedup in the tested range. due to the rapid increase of used memory, the biggest coverages in the table are somehow limit cases for speedup increase, since memory limitations strongly affect performances. as previously discussed, due to amhdal’s law, a further significant increase of speedup will probably require improvements in the non-parallel parts of the algorithms, possibly leading to a major restructuring of the code.
tseq
tpar


CONCLUSIONS
the work presented in this paper contributes to the haplotype assembly approach, a developing methodology for phasing snps based on direct evidence from reads obtained by dna sequencing. phasing grants us a better understanding of haplotype information, which is relevant in many contexts, including gene regulation, epigenetic, genome-wide association studies, evolutionary selection, population structure and mutation origin.

in this context, our contribution consists of a framework, pwhatshap, that improves the efficiency of state of the art haplotype computational analysis. importantly, pwhatshap is aligned with the future trends of sequencing technology, which will provide long reads, i.e., long fragments of dna sequences. building on whatshap, pwhatshap improves the efficiency of solving the weighted mec optimisation problem for haplotyping and supports a faster analysis of datasets with large coverage. this also caters to the accuracy of the results, which in the current settings, increases with coverage.

pwhatshap is a multi-core, parallel porting of whatshap. experimental results and benchmark tests show increased performance that can be obtained using computational facilities which are available today at affordable costs. the core haplotyping algorithm is embedded in a larger framework, the same as whatshap, which enables the treatment of standard formats for sequencing datasets. as pwhatshap is distributed as a freely available toolkit, our contribution aims to be widely accessible to researchers, as well as companies.

the development of pwhatshap has been a challenging parallelisation exercise for a fine-grained, data intensive algorithm. such features made the process difficult. we have addressed this by exploiting fastflow, a high-level parallel programming framework specifically targeting the parallelisation of fine-grained tasks, which allowed us to develop pwhatshap with minimal modifications to the sequential code.

common to similar frameworks dealing with large datasets, a critical aspect of pwhatshap is the trade-off between memory usage and performance. a large amount of information is currently kept in memory for efficient access. however, the amount of available memory represents a rigid limit, after which the necessary virtual memory management and swap to secondary memory devices, i.e., disks, start to have an impact on performance. we envision two possible approaches to solve this problem and push even further the efficiency of pwhatshap.

the first one is based on optimised, ad-hoc memory management. the memory access pattern is fully sequential: a large bulk of data is sequentially written, then sequentially read in reverse order to build the solution. data is never accessed in random order except for the very last column. an intelligent memory management, aware of such problem-specific information, could maintain relevant data in a limited amount of memory while needed, and swap to disk data outside such a working set . the difficulty lies in providing programmers with suitable abstractions that allow them to transparently deal with data swapping, i.e., technically, a user-space virtual memory optimised to manage the sequential data scheme used by pwhatshap.

the second approach is based on memory compression, which is making a comeback mainly because of the availability of multiple core processors. memory compression has been considered recently in projects regarding linux, chromeos, android and os x. intelligent memory compression would also exploit haplotyping specific information. the two approaches could be combined together, and paired with advanced data management techniques.

the large availability of cores would allow such data management processes to be offloaded to one or more processor cores in a quite seamless way.

this is the scope of future developments.

authors would like to thank the anonymous reviewers for their comments and suggestions that have contributed to improve our paper. this work has been partially supported by the eu fp <dig> project n.  <dig> “paraphrase: parallel patterns for adaptive heterogeneous multicore systems” , and by the eu h <dig> project “rephrase: refactoring parallel heterogeneous resource-aware applications - a software engineering approach” .

declaration
publication charges for this supplement were funded by the eu h <dig> “openaire2020” project grnt n.  <dig>  this article has been published as part of bmc bioinformatics volume  <dig> supplement  <dig>   <dig>  selected articles from the 11th international meeting on computational intelligence methods for bioinformatics and biostatistics . the full contents of the supplement are available online https://bmcbioinformatics.biomedcentral.com/articles/supplements/volume-17-supplement- <dig> 

availability of data and materials
dataset used are publicly available as indicated in the provided references. pwhatshap is distributed as open source software at https://bitbucket.org/whatshap/whatshap.

authors’ contributions
mt and ab designed the parallelisation of pwhatshap. mt and ma implemented, tested and tuned pwhatshap. np, tm and mp had a major role in designing and developing whatshap and contributed to its parallelisation. im, np and ab contributed to the comparison with other state of the art approaches. all the authors contributed to the writing of the paper. all authors read and approved the final manuscript.

competing interests
the authors declare that they have no competing interests.

consent for publication
not applicable.

ethics approval and consent to participate
not applicable.
