BACKGROUND
expressed sequence tags  and full-length cdnas  are an invaluable source of evidence to infer reliable gene structures and discover potential alternative splicing events  <cit> . their biological potential can be fully exploited through the clustering in which expressed sequences are linked to their specific gene loci of origin. to generate reliable gene-oriented clusters of ests, in presence of a complete or draft genome assembly, we developed easycluster that resulted the most accurate when compared to the state of the art software in this field  <cit> . nowadays, thanks to technological advances, est-like sequences can be produced by pyrosequencing using the roche  <dig> platform. indeed, this is a technology able to generate, through the gs flx+ titanium chemistry, sequence reads up to 1kb long   <cit> . in addition, very long reads  can be currently obtained through the third generation of sequencers as the pacbio based on single molecule real-time  technology   <cit> .

handling huge amount of est-like data is extremely useful to detect alternative isoforms, improve gene annotations or simply create gene-oriented clusters for expression studies. since est-like data provide a fragmented overview of their genomic loci of origin, transcript assembly may be an optimal solution to annotate user-produced sequences.

since the advent of next generation sequencing technologies, however, no updated software to employ genome-based clustering of long transcriptome reads has been released. indeed, as a novelty, we found the program  <cit> , developed to group and assemble ests pre-aligned to a reference genome, and an improved wcd  <cit>  release to cluster ests without genomic information. while wcd implements a new algorithm based on suffix arrays to handle huge amount of reads generated by high-throughput sequencers  <cit> , rcda has been conceived only for ests produced by the classical sanger sequencing and, thus, never tested on long sequences produced by next generation technologies as those from roche  <dig>  <cit> .

to fill this gap and benefit from both genome assemblies and long transcriptome reads, we developed easycluster <dig>  <cit> , a reimplementation of easycluster, that can now manage genome scale transcriptome data and produce reliable gene-oriented clusters from  <dig> reads, enabling the assembly of full-length transcripts and facilitating downstream analyses.

easycluster <dig> accepts read alignments in the standard gff <dig> format  generated by various mappers such as gmap  <cit> , refines the read clustering using information of shared splice sites, and resolves potential mapping errors at exon-exon junctions using dynamic programming.

the novel easycluster <dig> software can now handle unspliced reads  and optimize the cluster definition with known gene annotations. a graph-based approach is used to assemble full-length transcripts belonging to a specific cluster, thus simplifying the investigation of post-transcriptional events as alternative splicing. indeed, the astalavista  <cit>  program has been integrated in our tool allowing a quick way to explore alternative splicing without known reference transcripts.

in absence of large curated benchmarks in which the relationship between reads and genomic loci of origin is perfectly known, the reliability of easycluster <dig> has been assessed by simulated reads generated taking into account the titanium roche  <dig> chemistry. same simulated datasets have been used to compare easycluster <dig> results to those obtained using other recent programs as rcda  <cit>  or clustering software not genome-based as wcd  <cit> .

easycluster <dig> has been written in java programming language and its graphical interface has the aim to simplify genome-level analyses to researchers not fully skilled in bioinformatics. the main executable and documentation is freely available at the google code page: https://code.google.com/p/easycluster <dig> 

methods
overview of easycluster2
the easycluster <dig> workflow is summarized in the following steps:

 <dig> an individual alignment file in gff <dig> format is provided as input and parsed in memory exploiting java classes of a custom library. then reads are grouped according to their 'exon' features included in the gff <dig> file;

 <dig> initial clusters are generated by overlapping genomic coordinates;

 <dig> refined clusters are then produced using to the biological criterion of splice site sharing;

 <dig> potential mapping errors are corrected by an ad-hoc re-alignment strategy;

 <dig> unspliced  and mixed  reads are included in relevant clusters using proper criteria;

 <dig> clusters can be merged to take into account the fragmented locus sequencing;

 <dig> known annotations  can be exploited to improve clusters correctness;

 <dig> full-length transcripts are assembled from generated clusters by a graph-based procedure;

 <dig> alternative splicing events can be predicted using the embedded astalavista module.

the software has been developed in java programming language and tested on unix based machine equipped with  <dig> quadcore cpus and 16gb of ram.

cluster refinement in easycluster2
easycluster <dig> implements a novel strategy to refine the clustering procedure in order to mitigate the effect of alignment errors in regions surrounding splice sites.

the relative pseudocode is described in algorithm  <dig> 

transcript assembly
a novelty of easycluster <dig> is the procedure to assemble full-length transcripts from reads allocated to specific clusters. the algorithm is based on the building of directed acyclic graphs and the pseudocode is described algorithm  <dig> 

algorithm  <dig> cluster refinement

1: function refinecluster()

2:    for all exon ∈ est do

3:      if i-exon is not the final exon of the est then

4:        take the donor site of exoni 

5:        take the acceptor site of exoni+ <dig> 

6:        get the nucf asta of the fasta in an interval of  <dig> coordinates on the left of donori and  <dig> coordinates on the right of acceptori+1

7:        create new nbdonor and nbacceptor which are classes composed by a coordinate, score and occurrence of that splicing site in the p rof ilecluster

8:        for all j ∈  do

9:            nbdonor.coord ← donori + j ▷ j +  <dig> is used for having array index from  <dig> to 9

10:            nbacceptor.coord ← acceptori+ <dig> + j

11:      end for

12:      for all j ∈  <cit>  do

13:          if nbdonor.coord ∈ profilecluster: then

14:            get the nucgenomeindonor of the genomic sequence in an interval of  <dig> bases on the left of nbdonor.coord and  <dig> bases on the right of nbdonor.coord

15:            nbdonor.score ← smith-waterman 16:            nbdonor.occ ← profilecluster.occ

17:            if nbacceptor.coord ∈ profilecluster then

18:              get the nucgenomeinacceptor of the genomic sequence in an interval of  <dig> bases on the left of nbacceptor.coord and  <dig> bases on the right of nbacceptor.coord

19:              nbacceptor.score ← smith-waterman

20:              nbacceptor.occ ← profilecluster.occ

21:              get maxscoredonor from nbdonor.score saving its index in the array nbdonor

22:              get maxscoreacceptor from nbacceptor.score saving its index in the array nbacceptor

23:              if maxscoredonor > maxscoreacceptor then

24:                 shift the end part of the exoni on the start part of the exoni+ <dig> with a displacement that depends on the coordinate in nbdonor which has the maximum score

25:            end if

26:            if maxscoredonor < maxscoreacceptor then

27:               shift the start part of the exoni+ <dig> on the end part of the exoni with a displacement that depends on the coordinate in nbacceptor which has the maximum score

28:            end if

29:            if maxscoredonor = maxscoreacceptor then

30:              get occdonor from nbdonor.occ using the saved index of the max donor score in the array nbdonor

31:              get occacceptor from nbacceptor.occ using the saved index of the max acceptor score in the array nbacceptor

32:              if occdonor > occacceptor then

33:                shift the end part of the exoni on the start part of the exoni+ <dig> with a displacement that depends on the coordinate in nbdonor which has the maximum score

34:              end if

35:              if occdonor < occacceptor then

36:                shift the start part of the exoni+1on the end part of the exoni with a displacement that depends on the coordinate in nbacceptor which has the maximum score

37:              end if

38:              if occdonor = occacceptor then

39:                no shifting

40:              end if

41:            end if

42:          end if

43:        end if                              ▷"coord" stands for "coordinate"

44:      end for                                ▷"occ" stands for "occurrence"

45:    end if                                  ▷"nuc" stands for "nucleotides"

46:  end for        ▷"nb" in nbdonor and nbacceptor stands for "neighbourhood"

47: end function

algorithm  <dig> transcript assembly

1:  function assembletranscripts()

2:      generate startlist                          ▷if colj ∈ matgraph = 0

3:      generate endlist                        ▷if rowi ∈ matgraph = 0

4:      for all startnodei ∈ startlist do

5:          create pathlist

6:          add startnodei in pathlist

7:          if startnodei ∈ endlist then

8:            save pathlist

9:          else

10:            for all a ∈ row do

11:                if a =  <dig> then

12:                  add a in pathlist

13:                  recursivepath, pathlist, covermatgraph)

14:                  remove last element of pathlist

15:                end if

16:            end for

17:        end if

18:      end for

19:  end function

20:

21:  function recursivepath

22:      if nodej ∈ endlist then

23:        save pathlist

24:      else

25:        for a ∈ row do

26:          if a =  <dig> then

27:            for index ∈ pathlist-lastindex do

28:              if covermatgraph =  <dig> then

29:                covermatgraph ← 0

30:              end if

31:            end for

32:            add a in pathlist

33:            recursivepath, pathlist, covermatgraph)

34:            remove last element of pathlist

35:          end if

36:        end for

37:      end if

38:  end function

datasets
easycluster <dig> has been tested on two real datasets and simulated reads. as real dataset we used our human benchmark including  <dig> genes spread over almost all human chromosomes and  <dig>  ests. relationships between genes and ests were perfectly known. in addition, we used also the rcda human dataset of  <dig>  ests from chromosome  <dig>  downloadable from http:// <dig> . <dig> /iddrc/chr21/hsa21qgenesoftware.php.

simulated roche  <dig> reads were generated using the 454sim software  <cit>  that allows the production of datasets under the  <dig> error model and different chemistries . for our purpose, we simulated  <dig>  reads with the titanium chemistry from  <dig> human transcripts  mapping on chromosome  <dig>  the final dataset in fastq format was cleaned from adapters and low-quality sequences before any downstream use. the max read length was of  <dig> bp with a modal value in the range between  <dig> bp and  <dig> bp.

tracing the origin of each simulated read, we created the benchmark to calculate accuracy metrics. in order to compare easycluster <dig> performances with those from rcda and the oldest easycluster version working only on spliced reads, we generated a second simulated dataset including only interrupted reads.

real and simulated datasets were mapped against the human genome  by gmap software, using the "-f 2" flag to get the output in gff <dig> format, suitable for easycluster <dig>  and the "-z" flag to produce a second output in compressed format needed for rcda and the oldest easycluster version.

according to gmap results, 46% of all reads appeared spliced, while 51% were unspliced with indeterminate orientation and 1% showed multiple mappings . remaining reads  were discarded by gmap since too short for reliable alignments.

all datasets as well as clustering results are available at http:// <dig> . <dig> /ernesto/easycluster2/easycluster <dig> datasets results.zip.

clustering software
rcda program was downloaded from http:// <dig> . <dig> /iddrc/chr21/hsa21qgenesoftware.php and run using default options as indicated in the provided documentation. wcd program, version  <dig> . <dig>  was obtained from the following google code page http://code.google.com/p/wcdest/ and run using options -l  <dig> -t  <dig> -h  <dig> as recommended for  <dig> reads. the previous easycluster version was downloaded from http:// <dig> . <dig> /ernesto/easycluster1/ and launched using default parameters.

in easycluster <dig> we set minimum read identity to 90% and minimum read coverage to 80%.

comparative evaluation of easycluster
evaluation on benchmark and simulated datasets has been conducted calculating sensitivity and jaccard index for each program outcome. sensitivity is defined as tptp+fn  and gives us an indication of the proportion of true ests that has been correctly placed in the correct reference clusters. the jaccard index instead is defined as tptp+fn+fp  and measures the similarity between predicted and reference clusters. type i and type ii error rates have been calculated according to wang et al.  <cit> . for each program outcome we calculated also the specificity that in combination with sensitivity, can provide a more concrete idea of clustering accuracy. all metrics were obtained using a custom python script  <cit> .

implementation
easycluster is implemented in java programming language and, thus, platform independent.

RESULTS
general features of easycluster2
the easycluster <dig> algorithm has been completely rebuilt and redesigned implementing new and unique features to improve the clustering process and facilitate the analysis to researchers without advanced skills in bioinformatics. the main easy-cluster <dig> procedure is depicted in figure  <dig> and 1described below point by point.

gff <dig> parsing and first clustering
in contrast with the previous version, easycluster <dig> accepts as input alignment files in thestandard gff <dig> format and parse them in memory exploiting java classes of a custom library. along the parsing, read alignments are classified in unique  and mixed . in addition, reads are further divided into spliced  and unspliced .

after the file traversing and read classification, unique and spliced sequences are grouped according to their 'exon' features leading to the creation of appropriated and dedicated data structures. initial clusters are finally generated using overlapping genomic coordinates. the sorting of all read alignment coordinates is performed in advance to speed up the clustering procedure.

second clustering and refinement
initial clusters, defined also pseudo-clusters, are then improved using the biological criterion of splice site sharing and, thus, only reads with at least one splice site in common are maintained in the same grouping . since the alignment of spliced reads onto the reference may not be optimal in regions surrounding splice sites, we introduce a refinement strategy based on an ad-hoc re-alignment procedure using the classical smith-waterman  <cit>  algorithm.

from a computational point of view, for each cluster, we check the shift of a read substring  considering all splicing sites as annotated in the cluster. in particular, the algorithm verifies a potential correspondence for all couples of donor  and acceptor  sites of each read ; in other words, it checks if a specific coordinate of each read exon under analysis is already present in the cluster. this check is performed in a region of  <dig> nucleotides surrounding the splicing site,  <dig> upstream and  <dig> downstream, respectively. in case of a correspondence, the smith-waterman algorithm is used to verify the quality of the alignment onto the corresponding genomic region. the two exons under investigation are cut according to smith-waterman results and ready to be shifted to the previous or next exon as shown in figure 2b.

inclusion of unspliced and mixed reads
unspliced reads are prominent in transcriptome sequencing experiments carried out by roche  <dig> machines. for this reason, we implemented in easycluster <dig> a specific procedure to include unspliced reads. in practice, these reads, for which the orientation is indeterminate, are included in already generated clusters if completely comprised in exonic regions. alternatively, smith-waterman is applied to facilitate their allocation. indeed, several unspliced reads may be treated as spliced reads due to misalignments of exon-exon junctions near the ends. all unspliced reads not included in existent groupings, are released as independent clusters.

mixed reads, instead, mapping on multiple genome locations, are optionally inserted in pre-constituted clusters according to a membership coefficient, calculated by the following formula:

 mc=nestmapsstotsscluster 

where totsscluster is the number of splice sites in the examined cluster and nestmapss is the number of examined cluster reads that have the same mixed read splice sites. mixed reads are assigned to the cluster with the highest membership coefficient.

cluster merging
easycluster <dig> implements now a procedure to merge adjacent clusters based on overlapping coordinates and strand orientation. in addition, if known annotations are available, they are exploited to link and merge groupings sharing splice sites, overlap of coordinates and strand orientation, improving the clusters correctness.

transcript assembly
as a novelty, easycluster <dig> is able to assembly clustered reads in full-length transcripts using a graph-based algorithm  <cit> . the main procedure is accomplished by solving the inclusion and/or extension between pairwise reads, verifying the sharing of splice sites . indeed, given an ordered pair of reads, we may have at least three scenarios:

 <dig> inclusion, if both reads share all splice sites and the size of the second read is smaller than the size of the first one;

 <dig> extension, if both reads share splice sites and the size of the second reads is greater than the size of the first one;

 <dig> no relationship, if both reads have discordant splice sites.

according to above rules, easycluster <dig> builds a directed acyclic graph and performs transcript assembly .

alternative splicing
the prediction of alternative splicing is a basic step once full-transcripts have been generated per each cluster. although many programs tend to predict alternative splicing events defining a reference transcript and then valuating differences in the pattern of splice sites, easycluster <dig> takes a different approach. indeed, it implements the astalavista  <cit>  program in which splice site inconsistencies and, thus, alternative splicing events are detected by looking at genomic coordinates without any reference transcript. this is an optimal solution in the case of gene annotations are not well known and no reference transcripts can be defined unambiguously.

assessment of easycluster <dig> performance
easycluster <dig> accuracy was initially checked on our standard benchmark dataset comprising  <dig> human genes spread over almost all human chromosomes and  <dig>  ests   <cit> . this benchmark also includes cases of overlapping and nested genes and the relationship between each gene locus and corresponding ests of origin is perfectly known. in this limited dataset, easycluster <dig> correctly predicted all  <dig> clusters outperforming the previous easy-cluster implementation in which only  <dig> were exactly detected  <cit> .

we also tested our software on a second human dataset including  <dig>  transcripts from chromosome  <dig>  this dataset was used to compare the performance of a recently released program named rcda with the first version of easycluster  <cit> . rcda predicted  <dig> clusters while easycluster produced  <dig> groupings in  <dig> min. in contrast, easycluster <dig> generated  <dig> clusters compatibles with current annotations in ucsc in less than  <dig> min using default parameter or less than  <dig> min activating the exon refinement on a laptop computer. full-length transcripts were reconstructed in minutes and appeared consistent with refseq annotations included in the dataset. the consistency was estimated looking at shared introns since upstream and downstream transcript regions may differ.

finally we assessed the performance of easycluster <dig> using a dataset of human reads simulated according to the roche  <dig> error model and titanium chemistry. simulated reads were generated using known human chromosome  <dig> refseq annotations from the ucsc genome browser. the overall performance was evaluated in terms of sensitivity, specificity and jaccard index . in addition, we generated also a dataset including only spliced reads to compare results to those from rcda and the oldest release of easycluster. both datasets were also used to assess the read clustering by the novel wcd program that does not take into account the human genome assembly.

in case of rcda, the previous easycluster release and easycluster <dig>  simulated reads were aligned onto the reference human genome  using gmap software  <cit> .

main results on both datasets are reported in table  <dig>  when only spliced reads are taken into account, easycluster <dig> outperforms other programs in terms of sensitivity and specificity. very low values of type i  and type ii  errors have also been registered for easycluster <dig>  concerning the full dataset including spliced as well as unspliced reads, easycluster <dig> performs better than wcd, even though this comparison is a bit biased because wcd is an ab initio clustering tool and, thus, does not require any genomic information during the grouping of reads. using the full dataset, we registered a high type i error for easycluster <dig> , meaning that several clusters should be grouped together. this is an expected behaviour for roche  <dig> datasets in which the relatively low throughput  prevents the complete coverage of expressed genomic loci. in contrast, type ii error for easycluster <dig> is very low suggesting that only a few reads are incorrectly assigned to the right cluster.

roche  <dig> tends to produce many unspliced reads  that are generally discarded during the genome-based clustering. easycluster <dig> provides now the opportunity to employ all categories  of reads from a  <dig> experiment and this feature represents the most desirable scenario for a researcher.

as shown in table  <dig> , easycluster <dig> type i error sensibly decreases providing known annotations. indeed, gene annotations are extremely useful to link compatible clusters in terms of overlapping coordinates or splice sites sharing, improving the overall clustering procedure.

discussion
while dna microarray data are used to identify genes which could be considered prognostic markers  <cit> , to predict protein interactions  <cit>  and to discover molecular pattern  <cit> , ests are essential for gene discovery, gene mapping, genome annotation, snp discovery, alternative splicing detection and rna editing prediction.

ests are essential for gene discovery, gene mapping, genome annotation, single nucleotide polymorphism  discovery, alternative splicing detection and rna editing prediction. with the advent of next generation sequencing technologies, huge amount of est-like sequences can be produced at relatively low cost, enabling more detailed transcriptomic as well as genomic investigations. although several programs have been developed to analyse short reads from complete transcriptomes  <cit> , very few tools are available to handle long reads produced by sequencers as the roche  <dig> or pacbio. thanks to the titanium chemistry, the roche  <dig> sequencer is able to generate reads longer than  <dig> bp  that are in the same range of ests produced by the standard sanger methodology. although roche  <dig> has not a very high-throughput, generating up to one million reads per run, the analysis of resulting data is yet a challenging task. indeed, at least the 50% of transcriptomic reads by roche  <dig> experiments are unspliced and not strand oriented. therefore, after the mapping onto the corresponding reference genome, they have an indeterminate orientation.

existing programs to cluster est-like sequences using genome alignments, as easycluster or rcda, tends to exclude unspliced reads, leaving precious biological information. on the other hand, clustering programs based on est sequences only, as wcd, can employ all reads even though resulting clusters are quite questionable. in absence of additional genomic evidence, similarity-based methods suffer from notable limitations. indeed, ests/reads from paralogous genes or from nested and overlapping genes may not be correctly clustered. few years ago, we developed easycluster, a genome-based est clustering tool able to employ est to genome alignments to reconstruct reliable gene-oriented clusters. although it appeared more accurate than state of the art software, easycluster cannot handle long reads from next generation sequencing technologies and benefit from biological evidence of unspliced reads  <cit> . for this reason we developed easycluster <dig>  <cit>  in which the algorithm implemented in easycluster has been completely redesigned to take into account an increased number of reads and dedicated procedures to improve the clustering process including also unspliced and mixed reads. since easycluster <dig> employs progressive read alignments onto the reference genome, potential errors in regions surrounding splice sites may alter the quality of subsequent clusters. to solve this issue, easycluster <dig> implements an ad hoc procedure to refine alignments near splice sites using dynamic programming.

to demonstrate the reliability of easycluster <dig> we compared our software with two recently released programs to cluster ests, rcda  <cit>  based on est to genome alignments and wcd  <cit> , an improved similarity-based tool. in order to make unbiased the comparison, we generated simulated roche  <dig> reads in which the relationship between reads and genomic locus of origin is perfectly known. limiting the analyses to spliced reads, easycluster <dig> resulted more accurate than rcda and wcd in terms of sensitivity and jaccard index . when all reads were taken into account, easycluster <dig> outperformed wcd . very interestingly we obtained a very low type ii error due to mis-joining, meaning that only a reduced fraction of reads was allocated to wrong clusters. in absence of gene annotations, we registered a high type i error due to mis-separation because many genomic loci appeared not completely covered by reads leaving to more than one expected cluster. however, this type of error can be mitigated including additional biological evidence  or reliable annotations .

as a novelty, easycluster <dig> can assemble cluster of reads in full-length transcripts and predict alternative splicing events thanks to the embedded astalavista tool.

on the whole, easycluster <dig> is a novel tool ready to handle long reads from next generation sequencing, providing reliable clusters that can be used as strong evidence sources to improve gene-finding procedures or explore complex transcriptomes as well as post-transcriptional events herein as alternative splicing and rna editing. in addition, genome-based clusters can be employed for gene expression studies or identify tissue specific transcript variants.

CONCLUSIONS
easycluster <dig> is a reimplementation of easycluster software devoted to the generation of gene-oriented clusters by massive transcriptome reads. our software is written in java language and implements different novelties including a procedure to mitigate mapping errors at splice sites and an ad hoc solution to assemble full-length transcripts per cluster. in addition, easycluster <dig> can now predict alternative splicing events thanks to the embedded astalavista module.

given the explosion of next generation sequencing and the concomitant increment of read lengths, we think that a tool as easycluster <dig> may be extremely useful for large-scale transcriptome experiments from  <dig> roche or pacbio sequencers enabling complex genomic analyses to researchers not fully skilled in bioinformatics. indeed, results demonstrate the high accuracy of easycluster <dig> in producing effective clusters as well as reliable full-length transcripts.

as future plans, we are working to extend easycluster <dig> to datasets from the illumina platform in order to take into account paired-end reads and huge amount of reads. in addition, we are also planning to include in easycluster <dig> a procedure to accept in input alignments in the standard sam/bam format  <cit> .

availability and requirements
project name: easycluster2

project home page: https://code.google.com/p/easycluster2

operating system: platform independent

programming language: java

license: apache license  <dig> 

restrictions: none

competing interests
the authors declare that they have no competing interests.

authors' contributions
ep and gp conceived the study. ep and vb supervised the development. ep, vb, np, eig and fs designed the software. np, eig and fs developed the software. ep, vb, np, eig and fs drafted the manuscript. ds tested the software on real and simulated dataset. all authors read and approved the final manuscript.

