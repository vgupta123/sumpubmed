BACKGROUND
polymerase chain reaction, or pcr  <cit> , is a ubiquitous technique which amplifies a specific region of dna, so that enough copies of that region is available to be adequately tested, sequenced or manipulated in other fashions. in order to use pcr, one must know the exact sequences which lie on either side of the dna region of interest. these sequences are used to design two synthetic dna oligonucleotides, or primers, one complementary to each strand of the dna double-helix and lying on opposite sides of the target region. the primers are typically 20– <dig> nucleotides long.

assuming ∑ = {t, c, a, g} is the dna alphabet  <cit> , a sequence  can be shown as s = x1x <dig> ..xl, where xi ⊆ ∑, xi ≠ Ø and l is the length of s. a sequence is called degenerate if some of its positions have several possible bases  <cit> . for example, in the primer p* = {g}{g}{c,g}{a}{t,c,g}{a} the third position is c or g and the fifth is c, t or g. the iupac illustration of p* will be ggsaba . the degeneracy of a sequence is the number of unique sequence combinations it contains, which can be calculated as d = Πli=1|xi|. for example, d =  <dig> ×  <dig> ×  <dig> ×  <dig> ×  <dig> ×  <dig> =  <dig>  degenerate primers are useful for amplifying several related genomic or cdna sequences, and have been exploited in various applications such as amplifying dna sequences of homologous genes or genes from a particular protein family and analysis of species diversity  <cit> .

traditionally, degenerate primers were designed manually by examining multiple alignments of the target sequences. however, several programs are now available for designing degenerate primers for aligned sequences. codehop  <cit>  and depict  <cit>  are programs for designing degenerate primers for aligned protein sequences in order to identify new members of protein families. for each given multiple sequence alignment, codehop constructs a pair of primers. each primer consists of a degenerate 3' core region, typically with degeneracy of at most  <dig>  and a 5' consensus sequence that stabilizes annealing. it works well for small sets of proteins, taking into account the codon usage of the target genome as well as the desired annealing temperature. however, it is inappropriate for constructing primers with high degeneracy on large sets of long genomic sequences. depict clusters the sequences using a simple similarity score and then designs a pair of primers for each cluster by translating conserved blocks of amino acids into nucleotides.

in order to obtain primers that cover a large number of known genes and thus have a good chance to detect new related ones, one should obviously use highly degenerate primers . on the other hand, in order to reduce the probability of amplifying unrelated sequences, the degeneracy must be bounded. this contradictory nature of the degenerate primer design  problem has led to definition of several variants of this problem, all of which are np-complete:

 <dig>  maximum coverage degenerate primer design  tries to find a primer of length l and degeneracy at most dmax that covers a maximum number of strings  of a given input set, each of length l. hyden  <cit> , an algorithm based on a heuristic approach, basically addresses this variant of dpd problem and was first used to design degenerate primers for a set of genomic sequences in order to find new human olfactory receptor genes  <cit> .

 <dig>  minimum degeneracy degenerate primer design  addresses the problem of finding a primer of length l and minimum degeneracy that covers all the input strings, each of which having a length equal to or greater than l.

 <dig>  minimum primers degenerate primer design  is applied when a set of strings of length l is given, and finds a minimum number of primers of length l and degeneracy at most dmax, so that each input string is covered by at least one primer.

mp-dpd has the constraint that all input sequences are of the same length as the primers, which is not the case for most real situations. removing this constraint, i.e. allowing the strings to have arbitrary lengths, results in a more general problem, multiple degenerate primer design   <cit> . mdpd is to find a minimum number of primers of length at least lmin and degeneracy at most dmax, given a set of n strings of various lengths , so that each input string is covered by at least one primer. a currently available algorithm for designing multiple degenerate primers, called pt-mips  <cit> , has been developed in the context of snp genotyping. it uses an iterative beam-search technique to construct progressively a set of primers until all sequences are covered.

in this work, we introduce a new algorithm for solving mdpd problems which consecutively uses an ad hoc pairwise alignment for multiple primer selection – hence called pamps. we will show that pamps performs better than previous algorithms on different sets of input strings, i.e. results in smaller number of primers in a considerably less computation time.

RESULTS
to compare the performance of pamps with pt-mips , different sets of random sequences were generated. each set contained 20– <dig> sequences with similar length, but the lengths of sequences varied among different sets; sequences were of lengths 15– <dig> nucleotides. for each number of sequences and each sequence length three random sets were generated and the results were averaged over each triplet. pt-mips asks the user for "beam size" as well as "pairwise fragment size" . as changing the values of these parameters did not improve the results of pt-mips significantly , we used the default values of pt-mips,  <dig> and  <dig>  for beam size and pairwise fragment size, respectively.

both pamps and pt-mips were used to solve mdpd problem for each of the above mentioned random sets given lmin =  <dig> and dmax =  <dig>  almost always pamps resulted in smaller primer sets. only in few cases both pamps and pt-mips produced primer sets with equal sizes. to compare pamps and pt-mips quantitatively, we defined efficiency of pamps as

  fpamps=mmips−mpampsmmips, 

where mmips and mpamps represent the number of primers designed by pt-mips and pamps, respectively. figure  <dig> illustrates the values of fpamps for different numbers of sequences and different sequence lengths. obviously pamps outperforms pt-mips, especially when smaller sets of sequences or long sequences are used. in most situations, pamps decreases the number of final primers by 30%–35%. pamps outperforms pt-mips for a wide range of primer sizes and maximum degeneracy values .

comparing the run time of pamps and pt-mips shows that pamps is astonishingly faster than pt-mips : solving mdpd problem for  <dig> input sequences of length  <dig> nucleotides is about  <dig> times faster using pamps compared to pt-mips . this allows pamps to be used to design highly degenerate primers for thousands of input sequences each hundreds of nucleotides long. hence, even though the number of designed primers using pamps and pt-mips may converge as the number of input sequences increases, considering computation time strongly encourages using pamps; for an input set of  <dig> random sequences of length  <dig>  pamps needs an average time of  <dig> seconds to complete the computations on a  <dig>  ghz intel® core™  <dig> cpu. we should mention that pt-mips did not yield in any results after three days of running the same job as pamps. based on previous comparisons of pamps and pt-mips, we can estimate that for pt-mips it takes more than nine days to finish a job like this.

pt-mips  <cit>  is previously compared with hyden  <cit> . though hyden is basically designed to solve mc-dpd problems, it can be used iteratively to approximate mdpd problems, i.e. once a primer of length lmin and degeneracy at most dmax is found that covers the maximum number of input sequences, the sequences which are covered by this primer are subtracted from input set and hyden is run again on the remaining sequences. by repeating this procedure, eventually a set of primers is obtained which covers all sequences. since it has been shown that pt-mips outperforms hyden  <cit>  and as pamps outperforms pt-mips, we avoided the direct comparison of pamps and hyden.

the output of pamps is a list of primers, most of which are longer than lmin . therefore, any subsequences of length lmin from each output can be selected to be used for pcr amplification. if the longest possible pcr product is desired, then the very upstream subsequence should be used. however, for most pcr reactions it is important to have primers with similar annealing temperatures if a mixture of primers is used. since different combinations of primers can be chosen, it is possible to select the primers that have similar annealing temperatures. pamps is accompanied by a simple iterative algorithm provided in a separate software that chooses the best combination of primers in order to achieve the minimum variance among primer annealing temperatures. primer annealing temperatures are estimated as  <cit> .

CONCLUSIONS
in this work we presented a new algorithm, called pamps, for solving mdpd problems. pamps exploits an altered pairwise alignment to select the subsequences which may be merged into degenerate primers. pamps was shown to run significantly faster than a previously developed software, pt-mips  <cit>  and also gives better results , reducing the synthesis costs of primers. besides, when the number of mixed primers that are used in a pcr reaction are decreased, the concentration of the reacting primer increases, which usually improves the sensitivity of amplification. pamps, in contrast to previous algorithms, does not restrict the output to the exact primer length that was given; instead, it may result in primers longer than the requested length which allows selecting an appropriate primer in terms of annealing temperature. pamps can be used to design degenerate primers for amplification of genes with uncertain sequences, such as new members of gene families or libraries of antibody variable fragments. an implementation of pamps is provided in the additional file  <dig> 

