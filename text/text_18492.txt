BACKGROUND
with the advance of high-throughput sequencing techniques, it is feasible to study entire transcriptomes through the application of de novo sequence assembly algorithms  <cit> . a popular strategy of transcriptome assembly algorithms is to first obtain a de bruijn graph that contains all branching possibilities  <cit> . an additional step is then performed to construct predicted transcripts from the graph. this strategy is employed by oases  <cit>  and trans-abyss  <cit> , which use output from velvet  <cit>  and abyss  <cit>  respectively to obtain predicted transcripts. one drawback of the approach is that oases can be more memory-intensive than velvet, which limits its application when computational resources are limited. alternatively, trinity  <cit>  uses a different approach of first clustering the data, then constructing an individual de bruijn graph for each cluster that has simple structure.

we observe that it is possible to develop a memory-efficient algorithm to recover alternative splicing information directly from the intermediate de bruijn graph structure that contains all branching possibilities . although many of the simpler components of the de bruijn graph can already represent alternatively spliced variants of individual genes, the graph still contains big tangles that need to be addressed. we develop an algorithm to remove the complicated cycles in the de bruijn graph, and extract acyclic components so that each of them represents a gene and its isoforms in almost all cases. our goal is to preserve the alternative splicing information that is inherent within the reads as much as possible, and report these components as splicing graphs.

we implement the algorithm as a postprocessing module of velvet. we validate our algorithm by simulating the transcriptome assembly of drosophila using its known complete genome under the condition that all gene transcripts have high expression levels, and by performing drosophila transcriptome assembly using publicly available rna-seq libraries. we further employ a de novo expression estimate to simultaneously evaluate the differential expression levels across libraries without requiring any prior knowledge of the genome, which was validated in  <cit> . we have applied our algorithm to perform transcriptome assembly of the non-model blow fly lucilia sericata in  <cit> .

methods
de bruijn graph
given a set of reads and a parameter k, a de bruijn graph is defined by constructing a vertex for each k-mer that appears within the reads. a pair of k-mers are connected by a directed edge if the -suffix of the first k-mer is the same as the -prefix of the second k-mer. it has been observed that the de bruijn graph can be used to implicitly assemble these reads through linking together the same k-mer that appears in different reads  <cit> . since the number of vertices and edges in a de bruijn graph depends on the number of distinct k-mers from the reads rather than the total number of reads, this strategy is very popular among short read assembly algorithms for high-throughput sequencing data  <cit> .

postprocessing algorithm
in order to retain alternative splicing information, heber et al  <cit>  developed an est assembly algorithm that retains all the junctions in the de bruijn graph. by imposing a k-mer coverage cutoff, each component becomes a splicing graph that specifies the alternatively spliced variants of a gene. while this strategy was proved to be successful for est assembly, there are significant challenges in transcriptome assembly from high-throughput sequencing data that are caused by the shorter reads.

we develop a postprocessing algorithm that extracts the de bruijn graph from velvet  <cit>  to construct non-linear splicing graphs that represent the transcriptome. in order to retain as much alternative path information as possible, velvet is applied without using the tour bus algorithm that removes the bubbles in the graph, while still allowing the removal of short tips. each node returned from velvet corresponds to a maximal succession of vertices with no branches.

snps
in order to remove snps that are not related to alternative splicing but will create branches in the graph, we search for the following structure: starting from a node, consider the nodes at the end of all its outgoing edges. if the sequences associated with all these nodes are of the same length with long enough matches and very few mismatches, each of these nodes has exactly one outgoing edge that all go to the same final node, there are no other branches going into or out of any of these nodes and no other branches going into the final node, and the structure does not contain a forward node and the corresponding backward node at the same time, we think of all the mismatches within this split-then-merge structure as snps. we repeat the procedure at the final node to look for successive split-then-merge structures, and merge all the nodes involved into a single node . note that this strategy only merges together obvious snps, and it does not resolve short indels.

strongly connected components
we observe that connected regions within the de bruijn graph that are relatively free of cycles are likely to belong to the same gene. we decompose each connected component into a collection of edge-disjoint strongly connected components, with each strongly connected component being either just a single edge or a maximal subgraph with each vertex reachable from any other vertex. the regions within a strongly connected component that is not just a single edge represent the complicated regions that must contain a cycle, while the remaining regions represent the simpler regions that contain no cycles . this step can be performed by depth-first search with running time that is proportional to the size of the graph  <cit> .

forward-backward tangles
since velvet assembles the forward and the backward strands simultaneously, each gene should be represented by two disjoint components, one on each strand, which do not contain any cycles. although there are no more cycles after removing the strongly connected components that are not just a single edge, it is still possible to have forward-backward tangles in which a forward node and the corresponding backward node reside within the same connected component. these forward-backward tangles can be identified by depth-first search  <cit> .

splicing graphs
we extract all the nodes within the strongly connected components that are not just a single edge and within the forward-backward tangles. we treat each node as an individual assembly that consists only of a single node while ignoring the junction information within these complicated regions. we then remove these nodes and their adjacent edges, and extract the connected components in the remaining graph. each of these connected components does not contain cycles and should mostly represent alternatively spliced variants of one gene. only one of the two possible orientations is retained for each extracted node and each connected component.

junction adjustment
since adjacent vertices in a de bruijn graph share overlapping sequence fragments of length k −  <dig> according to the definition of a de bruijn graph, the location of junctions is imprecise and this representation is hard to interpret. although the overlaps can be eliminated by following the strategy in  <cit>  to remove the first k −  <dig> letters of the sequence in each node, the location of junctions is still imprecise and the beginning part of some of the sequences is missing. to resolve these uncertainties, we start with the non-overlapping strategy employed in  <cit>  and consider two cases: at a split junction in which a path branches in more than one direction, the junction is precise and no change is necessary; at a merge junction in which more than one path meets at a node, we move the maximum number of shared letters in the suffix part of these paths to the meeting node to make the junction precise .

note that there can still be ambiguities due to the presence of repeating patterns across junctions. since the graph no longer contains cycles after the previous processing steps, we recover the first k −  <dig> letters in each starting node with no incoming edges by restoring the removed letters. after these adjustments, we consider each resulting component as a splicing graph that specifies the alternative splicing paths of one gene. note that we only resolve simple cases and do nothing when there are simultaneously a split and a merge at the two ends of an edge. to remove very short assemblies, we retain only the splicing graphs in which all paths from a source to a sink have sequence length above 2k −  <dig> 

de novo expression estimate
in order to evaluate differential expression levels in a non-model organism in which no prior information is available, we employ a measure of number of reads per kilobase of node per million reads   <cit>  that is similar to the statistics used by  <cit>  and  <cit> . since there is no information about exons in a de novo assembly, reads that appear in the assembly are used instead of mapped reads. also, each node in a splicing graph is evaluated instead of each exon, with each read that contains a k-mer within a node contributing to that node. within each node, a rpkm estimate is reported independently for each library within the same assembly. a validation of the de novo rpkm values was given in  <cit>  that shows strong correlations of these values with the ones given by cufflinks  <cit>  on genes without alternative splicing and good correlations on nodes from genes with alternatively splicing.

postprocessing software
a software program implementing our postprocessing algorithm is available at http://faculty.cse.tamu.edu/shsze/postprocess. in order to make the results directly applicable to other software during downstream analysis, we represent each assembly in an annotated fasta format, in which each potentially non-linear structure is represented by a collection of nodes, with connecting edge information and rpkm values for each library embedded within the name of each node.

RESULTS
drosophila melanogaster simulations
to simulate the transcriptome assembly of drosophila, we extracted all gene transcripts from the d. melanogaster genome. for each gene transcript, we randomly pick reads until an average nucleotide coverage of  <dig> is reached while allowing varying percentages of mismatches in the reads, giving  <dig> reads of length  <dig> 

we applied velvet by setting the parameters max_branch_length, max_divergence and max_gap_count to  <dig>  while enabling read_trkg. we performed assemblies over different values of hash length k and cov_cutoff c. we extracted the de bruijn graph from the lastgraph file and applied our postprocessing algorithm. since de novo sequence assembly is performed mostly on non-model organisms and possible function of the assembled sequences is accessed with respect to a closely related organism, we used translated blast search  <cit>  to simulate its usage.

while it is possible to recover 90% of the drosophila genes under ideal conditions when there are no mismatches in the reads  <cit> , table  <dig> shows that the assemblies were still of high quality for  <dig> % mismatches, with more than 73% of genes recovered. table  <dig> shows that the performance for  <dig> % mismatches was much worse, with only about half of the genes recovered. when k is small, the larger number of nodes in the simulated drosophila assemblies can contain more information, although a larger proportion of them were in tangles and they were more likely to be in complicated regions. the extraction of strongly connected components reduced the size of the most complicated region by about half.


k_c
initial nodes denotes the number of nodes that are in the initial assembly. largest tangle denotes the number of nodes of the largest connected component. largest scc denotes the number of nodes of the largest strongly connected component. splicing graphs denotes the number of splicing graphs. max length denotes the length  of the longest path over all splicing graphs. n <dig> denotes the n <dig> value of the length  of the longest path in each graph. >1-node graphs denotes the number of graphs with more than one node. max nodes denotes the maximum number of nodes in these non-linear graphs. avg nodes denotes the average number of nodes in these non-linear graphs. snps denotes the number of snps recovered. total hits denotes the total number of hits from translated blast search of each node to drosophila . unique hits denotes the number of unique hits to different genes. >1-hit graphs denotes the number of splicing graphs that have blast hits to more than one gene. max hits denotes the maximum number of different genes that have blast hits to a splicing graph. time  denotes the computational time in minutes, with the values to the left and to the right of "," indicating the running time of velvet and our postprocessing algorithm respectively. memory  denotes the memory requirement in gigabytes, with the values to the left and to the right of "," indicating the memory requirement of velvet and our postprocessing algorithm respectively.


k_c
when k is small, the larger number of splicing graphs resulted in more complete assemblies, although the sequences were shorter and thus more fragmented. when k is large, the maximum and median  lengths of splicing graphs approached the maximum and median lengths of gene transcripts in the known drosophila genome, which are  <dig> and  <dig> respectively. between  <dig> to 12% of splicing graphs had non-linear structures. these values are a significant portion of the percentage of known drosophila genes that have more than one alternatively spliced variant, which is 27%. a small number of snps were recovered, which may be due to variations in repeats or the inability to separate gene families. 

when compared to the total number of blast hits, the number of unique blast hits to different drosophila genes was not much smaller. when compared to the total number of splicing graphs, only a small number of graphs have blast hits to more than one gene. within these graphs, the maximum number of different genes that have blast hits to a graph was small, thus we have mostly achieved the goal that each splicing graph should represent alternatively spliced variants of only one gene. when the k-mer coverage cutoff c is  <dig>  the number of junctions and some of the splicing graphs were very large. otherwise, the results were similar over different cutoffs for the same value of k. this is due to the consistent high coverage that is guaranteed by the simulation.

drosophila public libraries
to investigate the transcriptome assembly of drosophila under realistic conditions, we obtained reads of length  <dig> from six rna-seq libraries in  <cit>  at the sequence read archive  <cit>  that include the following developmental stages: 2- <dig> hours embryos , third instar larvae , mixed pupae , adult females , and adult males . since sequence quality decreases toward the end of a read, we trimmed each read by removing all positions including and to the right of the first position that has a quality score of less than  <dig>  giving a total of  <dig> reads with average length  <dig>  we compare the performance of our postprocessing algorithm to oases and trans-abyss on machines with  <dig> gb physical memory. since the memory requirement of oases exceeds  <dig> gb when the k-mer length is small, we fix k to  <dig> 

for oases, velvet was applied with hash length k without setting cov_cutoff while enabling read_trkg. oases was then applied on the results from velvet with cov_cutoff c. for trans-abyss, abyss-pe was applied with k-mer size k, mean k-mer coverage threshold c, and minimum number of pairs n= <dig>  trans-abyss was then applied on the results from abyss-pe by utilizing the assembly.py script with the single k-mer length. for our postprocessing algorithm and oases, all reads were treated as single-end reads.


k_c

k_c

k_c
the k-mer length is fixed to  <dig> because oases is only capable of assembling these libraries on machines with  <dig> gb physical memory when k is large. for our postprocessing algorithm, the notations are the same as in table  <dig>  for oases, locus denotes the number of predicted locus, max length denotes the length of the longest predicted transcript, n <dig> denotes the n <dig> value of the longest transcript length in a predicted locus, >1-trans locus denotes the number of predicted locus with more than one transcript, max trans denotes the maximum number of transcripts in a predicted locus, avg trans denotes the average number of transcripts in predicted locus with more than one transcript, total hits denotes the total number of hits from translated blast search of each predicted transcript to drosophila , unique hits denotes the number of unique hits to different genes, >1-hit locus denotes the number of predicted locus that has blast hits to more than one gene, max hits denotes the maximum number of different genes that have blast hits to a predicted locus, time  denotes the computational time in minutes, with the values to the left and to the right of "," indicating the running time of velvet  and oases respectively, and memory  denotes the memory requirement in gigabytes, with the values to the left and to the right of "," indicating the memory requirement of velvet  and oases respectively. for trans-abyss, trans denotes the total number of predicted transcripts, max length denotes the length of the longest predicted transcript, n <dig> denotes the n <dig> value of the length of predicted transcripts, >1-node trans denotes the number of predicted transcripts that are the concatenation of more than one node, max nodes denotes the maximum number of nodes in a predicted transcript, avg nodes denotes the average number of nodes in predicted transcripts with more than one node, total hits denotes the total number of predicted transcripts that have blast hits, unique hits denotes the number of unique hits to different genes, time  denotes the computational time in minutes, with the values to the left and to the right of "," indicating the running time of abyss and trans-abyss respectively, and memory  denotes the memory requirement in gigabytes, with the values to the left and to the right of "," indicating the memory requirement of abyss and trans-abyss respectively.

in order to evaluate the performance with varying k, we also considered a smaller set of four libraries by removing the second replicate from the mixed pupal libraries and replacing the two adult libraries with a single adult library at a different time point , giving a total of  <dig> reads with average length  <dig> after quality trimming. table  <dig>  figure  <dig> and figure  <dig> show that the results had similar characteristics as the ones with six libraries, with better performance when k =  <dig> 

CONCLUSIONS
we have developed a postprocessing algorithm that can recover alternative splicing information directly from de bruijn graphs of rna-seq data. our strategy does not require prior genomic knowledge and supports the study of differential expression through investigating de novo rpkm values  <cit> . the computational time is linear in the size of the de bruijn graph, and our algorithm takes a few minutes to half-an-hour to complete after results from velvet are available in the test cases . it uses less memory than velvet, while running oases together with velvet without setting cov_cutoff is often more memory-intensive than running velvet with cov_cutoff . our algorithm performs well on simulations with low percentages of mismatches in the reads and generally has higher specificity than oases or trans-abyss. it is most suitable in situations in which a more reliable assembly is desired at the expense of lower sensitivity. our algorithm has been applied to perform transcriptome assembly of the non-model blow fly lucilia sericata in  <cit> , which allows comparison of its transcriptome to the closely related model organism drosophila through translated blast search, investigation of alternative splicing and differential expression among various developmental stages, and identification of transposable elements.

competing interests
the authors declare that they have no competing interests.

authors' contributions
amt and s-hs designed the computational work, analyzed the data and wrote the paper. s-hs did the simulation experiments. all authors read and approved the final manuscript.

