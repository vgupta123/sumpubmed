BACKGROUND
the advent of high-throughput next generation sequencing  technologies has greatly accelerated the pace of disease gene discoveries and has revolutionised the diagnosis and management of human genetic diseases and cancer  <cit> . being able to reconstruct the genetic make-up of an individual and accurately predict the effect of pathogenic genetic variants is essential for genetic counselling and making informed decisions regarding medical treatment. the age of personalised genomic medicine is upon us. new bioinformatics tools are being developed at a very rapid pace to analyse such datasets and to cope with the constant generation of new types of "omic" data  <cit> .

software quality assurance becomes especially critical if bioinformatics tools are to be used in a translational medical setting, such as analysis and interpretation of whole exome sequencing  or whole genome sequencing  data. we must ensure that only validated algorithms are used, and that they are implemented correctly in the analysis pipeline. more importantly, the computed results must satisfy the general expectation of their intended users. recently it has been shown that the concordance of multiple widely used variant-calling pipelines is very low   <cit> . a similarly disturbing level of disagreement is also observed when using different variant annotation programs to annotate genetic variants even when the same transcript definition is used  <cit> . considering there is only one ground truth, the high level of discrepancy is troubling, and is telling us that even the most popular bioinformatics tools to date can generate results with a non-negligible false positive or false negative rate. false positives and false negatives are both potentially a huge issue. although false positives can easily be distinguished from true positives through external validation, such as sanger sequencing, it is almost impossible to systematically distinguish false negatives from the vast number of true negatives.

previous work on scientific software evaluation has shown that numerical disagreement between programs of scientific computation grows at around the rate of 1% in average absolute difference per  <dig> lines of implemented code and that the nature of this disagreement is non-random  <cit> . most recent scientific studies, especially in the area of bioinformatics and computational biology, deal with large and complex datasets and complicated algorithms. this complexity has made the replication of published findings difficult to pursue. in addition, not all users understand fully the intended usage and limitations of a scientific program  <cit> . errors or limitations of the computer code utilised could go undetected with possible negative effects on future research  <cit> . therefore, there has been an emerging issue of scientific peer-review of computer code in order to minimise errors or limitations that would prevent other researchers from replicating published findings  <cit> . most importantly, there have been numerous published papers that attempt to train scientists to adopt best practices for scientific computing  <cit> .

software testing is defined as the process of actively identifying potential faults in a computer program  <cit> . this process can be used for two purposes: to ensure the program is correctly implemented against the specification , and to ensure the correct specification is used against the desired user requirement . many software testing strategies have been developed, most of them are widely used in industry with varying effectiveness  <cit> .

performing testing systematically and automatically on bioinformatics programs is not as trivial as one would have imagined. it is often difficult, if not impossible, to define a gold standard mechanism to decide if the output of the target program is correct, given any possible input. this mechanism is referred to as an oracle in the software testing field. if a test oracle exists, we can apply a large number and variety of test cases to test a program since the correctness of the output can be verified using the oracle. without a tangible oracle, the choice of test cases is greatly limited to those special test cases where the expected outputs are known or there exists a way to easily verify the correctness of the testing results. the problem is that the bioinformatics tools used in genomic medicine applications often lack an oracle, which greatly limits our ability to perform testing systematically and automatically. currently most software developers test their programs using a small number of simulated test cases, or compare their programs with other existing programs that are expected to give the same results  <cit> . both approaches are effectively an attempt to approximate a gold standard for testing. nonetheless, there are clear shortcomings to both approaches. simulation data may not truly reflect the characteristics of real data, and it is unclear what the best way is to determine ground truth if multiple programs give different results. in this manuscript, we demonstrate how we can systematically generate and check the correctness of many test cases without the need of a gold standard. our strategy relies on a software testing technique called metamorphic testing   <cit> . this approach alleviates the oracle problem by using some problem domain-specific properties, namely metamorphic relations , to verify the testing outputs. the central idea is that although it is impossible to directly test the correctness of any given test case, it is easy to verify the relationships of the output generated by multiple executions of a program. in other words, mt tests for properties that users expect of a correct program.

we have previously utilised mt to test a range of bioinformatics and machine learning programs  <cit> . our work represented a significant step towards software reliability in bioinformatics. in this work we aim to extend our contribution in this field by applying mt to three commonly used ngs short-read alignment programs that have been used widely by the international academic community: bwa  <cit> , bowtie  <cit>  and bowtie <dig>  <cit> . our goal is not to present another comparison of short read alignment programs -- this has been previously studied extensively  <cit> . this paper is a case study on how we can adapt a state-of-the-art software testing technique  to systematically test several user expectations, which is useful for verifying and validating several widely used bioinformatics programs. we develop a fully automated software testing tool that can be used to systematically assess the expected behaviour of these programs. we also investigated the potential effect on variant calling if the alignment algorithms fail to satisfy some of the user expectations. this work serves as a case study for demonstrating the application of an intuitive testing framework for systematic verification and validation of bioinformatics software.

methods
metamorphic testing
the design of our mt tool is shown in figure  <dig>  short sequence reads  are aligned to the hg <dig> reference genome using three different sequence alignment tools: bwa   <cit> , bowtie   <cit>  and bowtie <dig>   <cit> . the original "source" input, which can be based on simulated or real data, is modified by one or multiple mrs. here we propose nine mrs based on expected properties of the software . after the application of each mr on the input to generate a modified "follow-up" input, the program is executed again, and the output is tested against the expected relationship between the output of the source and follow-up input, as specified in the mrs. in other words, a mr serves two purposes:  generation of additional test cases by modifying the source input, and  checking the relationship between the outputs produced by the execution of the "source" and "follow-up" test cases. it should be noted that in general many follow-up test cases can be derived from a single source test case input based on one mr. in this study, we restrict our analysis to one source and one follow-up test case for each run of mt. the expected results vary according to each mr but can indicate whether failure is detected. failures can imply various possibilities ranging from a deviation of the design of the software and user expectation  to errors in the software implementation .

the mt tool is implemented as a unix shell script. the source code and documentation of the script is available at https://sourceforge.net/projects/mr-test/. manipulation of the resulting output bam files is performed with samtools   <cit> .

metamorphic relations
we designed the following set of mrs that aim to capture the expected behaviour of every short-read alignment software. it should be noted that the mrs were not designed based on the algorithm or implementation of a specific sequence aligner, but based on user expectations of the intended behaviour of a good sequence aligner. the description here is for a paired-end sequencing dataset, but it can be easily applied to single-end datasets too. we denote the reads of the two ends as read <dig> and read <dig> 

mr1: random permutation of reads. the reads in the fastq files are reshuffled. the permutation is the same for read <dig> and read <dig> reads. we expect the output mapping to be the same as the original output.

mr2: reverse complement of reads. both read <dig> and read <dig> are reverse complemented and their corresponding quality values are reversed to match the nucleotide bases. their order in the algorithm input is reversed. we expect the output mapping to be the same.

mr3: addition of reads. the input reads in the fastq files  are duplicated. we expect the output of all original reads to map to the same locations with the additional reads mapping to the same locations as their duplicates.

mr4: removal of reads. half of the reads in the input fastq files  are removed. we expect the output mapping of the non-removed reads to remain at the same locations. the resulting sequencing coverage should be half of the original mapping.

mr5: extension of reads. after initial mapping, each read is extended by  <dig> bp to the 3' or 5' end of the read, with high quality score, based on the reference genome sequence. we expect the output mapping to remain the same.

mr6: unmapped reads. after initial mapping, only the unmapped reads are selected and remapped against the reference genome. we expect that none of the reads will be mapped.

mr7: mapped reads. after initial mapping, only the mapped reads are selected and remapped against the reference genome. we expect that all of the reads will be mapped. for paired-end reads only the properly paired reads are remapped.

mr8: quality score increase of reads. after initial mapping, the quality score for all mapped sequences is increased. we expect the output mapping to remain the same.

mr9: correction of errors or mismatches in the mapped reads. after initial mapping, the mapped reads are selected and any mismatch or error is corrected in the reads. we expect the output mapping to remain the same.

simulated data
metamorphic testing properties can be applied to any sample, since there is no need for a gold standard. to demonstrate its utility on a range of input test cases, we apply mt on both simulated and real datasets. in terms of simulated data, we used simngs and simlibrary  to simulate ngs short-read datasets based on the human reference genome  of varying number of reads  in order to assess the effect of the total number of reads in our ability to detect limitations in the alignment software.

hapmap data
one of the main advantages of mt is that we can test real data instead of only simulated data. we chose to apply mt to one widely studied hapmap sample that has been exome sequenced using illumina hiseq  <dig> as part of the  <dig> genomes project  <cit> . fasta files with run id srr <dig>  were downloaded from the  <dig> genomes ftp site . the sequencing was paired-end with  <dig> , <dig> read <dig> and read <dig> sequences. in addition, we downloaded a single-end dataset of  <dig>  reads. this sequencing run was from hapmap individual na <dig>  a male unaffected sample from  <dig> genomes ceph . since the metamorphic properties require extensive manipulation of the fastq files, we chose this run as a representative example of a sequenced exome without having a very large file size that would limit our analysis.

variant calling using gatk
in order to assess the downstream effects of violating several key mrs  during sequence alignment on downstream genetic variant calling, we ran a commonly used variant calling pipeline on a hapmap dataset. after bwa, genome analysis toolkit   was employed for variant calling  <cit> . since our mrs do not apply any filtering on the bam  files, the analysis was repeated after considering only the uniquely mapped reads.

RESULTS
limitations of short-read alignment software
we tested the performance of three widely used short-read alignment tools  on simulated sequencing runs of varying coverage . table  <dig> shows the mr results for the three tools  respectively. we additionally applied the same mrs to an exome sequencing run of hapmap sample na <dig> for both paired and single end datasets. table  <dig> shows the results  after applying  <dig> mrs for the paired and single end data respectively. failure  indicates difference between the resulting alignments. this difference could be due to only a few or multiple reads mapping differently after the application of mt.

f .

f .

we found that the expected behaviour that is encoded by mr <dig>  and mr <dig>  does not hold for bwa for either simulated or real data  but passed our tests for both bowtie and bowtie <dig>  similarly, properties mr <dig>  and mr <dig> , although they hold for bowtie and bowtie <dig>  they fail for bwa for simulated paired-end data that are above some sequencing coverage . metamorphic relations mr <dig>  and mr <dig>  fail for all three algorithms and input data whereas on the other hand mr <dig>  is never violated. finally, we found that mr <dig>  fails for bowtie and bowtie <dig> but not for bwa and mr <dig>  fails for bwa and bowtie <dig> only when applied on the real sequencing run .

following our "black-box" testing, we attempted to explain the above results by investigating the nature of failure. we concluded that mr <dig>  and mr <dig>  although they could be desirable, they are not necessary properties for a short-read alignment program and indicate a slightly different specification than what we, as testers, assumed. the algorithms expect the paired reads to be in a specific direction to map properly and by reverse complementing them, this structure is lost. additionally, the extension of reads by 20bp before remapping, could extend reads with mismatches and errors, resulting in favoring alternative mapping locations.

we then investigated the properties that systematically fail during bwa testing but not for bowtie and bowtie <dig>  downstream analysis of the bam files, revealed that the differences in mapping occur mostly for reads that are assigned to the lowest mapping quality or are not uniquely mapped in the genome. by further examining the implementation of bwa we found that in the case of non-uniquely mapped reads, the algorithm is set to report one alignment randomly chosen for each read. this selection is not entirely random, as we found out, since for the same fastq file a repeated execution would always produce the same results. the seed for the random number generator is fixed so the random numbers chosen are always the same. this means that in the case where the reads in the input sequence files are at a different position in the file - as it happens after random reshuffling of the reads , after addition or removal of reads  or after selecting only the mapped reads  - the reported alignment for each non-uniquely mapped read will be different. additionally, we found that suppressing the reads that can be aligned to multiple locations did not solve the problem as these reads can be difficult to detect in the bam file, an issue that we address specifically in the next section. we should note that for low coverage sequencing, this issue might not be always detected as we found out by our simulation runs.

the reason that bowtie and bowtie <dig> do not suffer from this problem is because the pseudo-random number generator is re-initialised for every read, and the seed used to initialise it is a function of the read name, nucleotide string, quality string, and the value specified with a specific parameter "-seed". therefore the randomly chosen alignments for reporting will always be the same for every read pair irrespectively of where it is located in the input file. on the other hand, since this implementation uses the quality score, this explains why mr <dig>  fails for bowtie and bowtie <dig> but not for bwa. again, the non-uniquely mapped reads reported differ, hence the resulting mapping will be different. we should additionally note that the bowtie and bowtie <dig> implementation uses backtrack to find the alignment, from left to right, and if there are equally good bases, the choice will be random. so when the number of bases are changed, this selection will be changed too, which is another reason why mr <dig>  always fails.

finally, mr <dig>  is the only property that gave different results between bowtie and bowtie <dig>  we found this property is largely dependent on the input data. when simulated data are used, then there is no fault detected. this is expected, since the error structure in the simulated data is pre-determined and correction of the mismatches in the mapped reads can only improve the mapping. on the other hand, real data can suffer from many sources of bias and a correction of a mismatch can result in mapping of a read to an entirely different location of the genome. additionally, the implementation first checks the number of mismatches to determine the best alignment taking into account the sum of quality score. when these mismatches are fixed, there might be additional alignments that are of equal equality and the number of alignments can change.

effect of mrs in downstream analysis
in order to investigate the effect of these properties in downstream wgs or wes analysis, we ran a commonly used pipeline that involves bwa alignment followed by using genome analysis toolkit  for variant calling  <cit> . we ran this pipeline for the exome sequenced sample na <dig>  since our mrs do not apply any filtering on the bam  files, the analysis was repeated after considering only the uniquely mapped reads. we found that prior to any filtering, the number of variants called is different when we use the original bam file, and the resulting bam files after mr <dig>  mr <dig> or mr <dig> .

we subsequently filtered non-uniquely mapped reads and repeated the variant calling step. we found that there is still discordance between the numbers of variant calls made . these reads were filtered by mapping quality of  <dig> as well as reads with an indicated tag of aligning to more than one position . we found that higher quality threshold is needed to achieve concordance between the results and the specified tags are not sufficient to capture all of the non-uniquely mapped reads .

implication on genomic medicine
multiple studies have assessed the performance of these and other mapping algorithms  <cit>  but we were able to do this without the need of an oracle or the direct comparison of the methods. instead of requiring a mechanism to verify whether an individual test output is correct, the mt technique verifies whether a pair of test outputs conform to a set of domain specific properties, and thus greatly increases the number and variety of test cases that can be applied. using mt, we detected limitations of bwa, bowtie and bowtie <dig> by demonstrating violations of several user expectations, encoded in the form of metamorphic relations. although some of these relations are not necessary properties of short-read alignment software, they are important for software validation and software analysis. we detected violations in some mrs that could be characterised as necessary and thus revealing limitations in the implementation of these tools, despite being quite minor. the problems associated with these minor limitations in sequence alignment may be overcome by applying strict quality control filtering in variant calling. nonetheless, we do believe that it is important to test whether such widely used programs have limitations when we analyse a range of sequencing datasets, as it has also been shown in previous studies  <cit> . since one of the major advantages of mt is that it can greatly increase the number of test cases, we can imagine it is possible to extend this framework to automatically and systematically generate many artificial "positive controls" and "negative controls" that can be embedded within each fastq file, and be checked for correctness.

CONCLUSIONS
this work illustrates the importance of testing to verify and validate bioinformatics software. systematic testing can reveal program faults and outcomes that are unexpected and undetected by the user. such errors or limitations can have tremendous effects in bioinformatics and in scientific computing in general, affecting downstream research or clinical decisions. we proposed a metamorphic testing framework for bioinformatics software testing, and demonstrate its utility by testing three widely used sequence aligners.

availability of supporting data
the source code and documentation of the mt tool are available at https://sourceforge.net/projects/mr-test/

competing interests
the authors declare that they have no competing interests.

authors' contributions
jwkh conceived this study. eg and jwkh designed the study and wrote the paper. shp implemented the software. eg and shp carried out the analysis. dth contributed critical software for this project.

