BACKGROUND
assigning biological functions to uncharacterized/un-annotated proteins is one of the major challenges in post-genomics due to the importance of proteins in various biological processes and the high cost of biological experiments  <cit> . on the other hand, new technologies in biology have generated various high-throughput protein-protein interaction  datasets. meanwhile, function annotation schemes which give functional descriptions/definitions of protein functions also have been well developed, such as the function catalogue   <cit>  and the gene ontology   <cit> . the research in protein interactions in living cells  <cit>  shows that proteins interact with each other, rather than working alone, to perform their functions in various biological processes. therefore, with the available protein interaction datasets and function annotation schemes, it is possible and feasible to use computational methods to predict functions for un-annotated proteins from protein interactions  <cit> .

the past decade has seen a rapid development of computational methods for predicting protein functions from ppi datasets. to predict functions computationally, protein interactions in a ppi dataset are usually modelled as an undirected acyclic network. the nodes in the network represent unique proteins and the edges represent the interactions between proteins  <cit> . with this network model of protein interactions, various approaches have been proposed to predict functions of un-annotated proteins from the available information in the network and other related resources such as gene microarray profiles and the go. in this paper, we focus our discussion on the prediction methods that are based on the protein and protein function similarities. the early neighbour counting method proposed by schwikowski et al.  <cit>  annotated an un-annotated protein with the functions that occurred most frequently among its neighbour proteins. this method could be considered as a simple similarity-based prediction method as it simply assigned similarity  <dig>  to two proteins that have an interaction, or  <dig> if these two proteins have no interaction. therefore the function scores that were used to predict functions were based on the function frequencies in the neighbour. hishigaki et al.  <cit>  improved schwikowski's method by using the chi-square statistics instead of frequency as a scoring function. brun et al.  <cit>  improved the neighbour counting method by using a measure in graph theory to assign weights to the edges of a ppi network, and then used the weights as the similarities when predicting functions. in this method, the similarity was not  <dig> or  <dig> only anymore, it was within the range  <cit>  instead. samanta et al.  <cit>  intended to improve the protein similarity definition by using a new distance metric and clustering techniques to compute the distance between two proteins. chua et al.  <cit>  extended brun's and samanta's ideas by including indirect neighbour proteins when predicting functions of an un-annotated protein. in recent years, more and more research turned to predicting protein functions semantically by combining the inter-relationships of function annotation terms in a scheme such as go with the topological structure information in the ppi network. the inter-relationships are usually represented as functional similarities between annotation terms in the annotation scheme. to predict protein functions semantically, various methods were proposed to calculate functional similarities between annotation terms  <cit> . for instance, resink  <cit>  used the concept of information content to calculate the semantic similarity between two go terms. jiang et al.  <cit>  and lin  <cit>  improved resink's method by scaling the similarity to a fixed range. with the protein and protein function similarities, some methods were proposed to incorporate these similarities into the prediction, such as the k-nearest neighbour  based methods in  <cit> .

the current approaches can predict functions effectively to some extent for some but not all cases. in addition to the factors such as incompleteness and noisy data of the ppi datasets, whether a computational algorithm can more reasonably reflect the nature of protein interactions will determine the quality of prediction. in fact the existing approaches, whether they are semantic or not, are based on an assumption that the functions to be predicted for an un-annotated protein are determined by the functions of annotated proteins in the dataset. that means the prediction is mono-directed from annotated proteins to un-annotated ones, and once the functions of un-annotated proteins are predicted, the prediction is finished . this assumption, however, only reflects one aspect of protein interactions. as a matter of fact, in real biological processes, proteins have high mobility and have dynamic interplay that produces a framework which is ever-changing but overall stable  <cit> . proteins exchange their biological signals and share functions in a dynamic, rather than a static and mono-directed, circumstance. in other words, this dynamic feature of protein interactions should be reflected in function prediction procedures. the existing approaches, unfortunately, do not incorporate this dynamic feature into prediction procedures, and therefore do not validate whether the interactions between annotated and un-annotated proteins have achieved a stable state after the prediction is made.

considering the above issues, in this paper, we propose an innovative approach to predict protein functions iteratively. the iterative prediction method simulates the dynamic process of protein interactions in terms of protein and function similarities when predicting functions. meanwhile, in our algorithm the local and global semantic influence of the available protein functions in the dataset is also taken into account, which more reasonably counts the contribution of available functions to the prediction results. the iterative prediction starts with assigning initial predicted functions to the un-annotated protein, and then calculates the initial similarities between the un-annotated protein and its neighbour proteins. with these initial similarities, a knn-based prediction method is applied to get the new predicted functions for the un-annotated protein. replacing the initial/old predicted functions of the un-annotated protein, the new predicted functions are then used to recalculate the similarities between the un-annotated protein and its neighbour proteins for the next round of prediction. this prediction process is repeated until the similarities between the un-annotated protein and its neighbour proteins reach a stable state, which represents a dynamic stable status among the protein interactions in terms of similarities. to guarantee the prediction being conducted iteratively, a similarity between proteins must be properly defined. this is also one of our contributions in this paper.

the paper is organized as follows. in section "methods", we present the iterative prediction algorithm in detail. in section "results", we provide the evaluation results of our algorithm and the comparison results with the methods that are similar to our method. we discuss the concerns and issues that are related to our algorithm in section "discussion". we finally conclude our work in section "conclusions" and discuss some future work about iterative approach improvement.

methods
the idea of our prediction algorithm is to iteratively count the contribution of the available functions in the neighbours of the un-annotated protein to the final determination of predicted functions. the contribution of a function to the prediction is primarily dependent on the number of neighbour proteins that have the function and the similarities between the un-annotated protein and these neighbour proteins. in our algorithm, we also consider the similarities between the functions in the neighbour, as well as the global and local influence of the functions, in the prediction. the details of this iterative prediction algorithm are presented as follows. it can be seen that the base of our algorithm is the definitions of protein similarity and protein function similarity. therefore, we firstly define these similarities, and then give the prediction algorithm.

suppose the un-annotated protein is p, we denote the neighbour proteins of p as a set n. the neighbour proteins of a protein p are those that have direct and/or indirect interactions with p in the ppi network. in this paper, we only select those proteins that have direct interactions with p as the neighbour proteins of p. we also denote the functions of a protein p' as a set f, and the functions of all the neighbour proteins of p as another set fn=∪p′∈nf. we use the go terms  <cit>  to annotate all the protein functions in our work.

now we give the definitions of protein similarity and protein function similarity. for any two proteins p and p', suppose the size of the set f is m ), and the size of the set f is n. the similarity between two proteins p and p' is defined as

  sim=1max∑f∈f∑f′∈fδf,f′ 

where δf,f' is an indicator function, i.e. if f and f' are the same, its value is  <dig>  otherwise, it is  <dig> 

for any two functions f and f', they can be represented as two vectors f→ and f→′ whose element values indicate the occurrences of the go notation terms that annotate the functions. if the number of terms/notations in go is t, the dimension of each function vector f→ is then t. since the go is represented as a directed acyclic graph in which a go term may have multiple parent go terms, we call all parent terms of a go term the ancestors of the term. if a function is annotated by a go term, it is also annotated by the ancestors of the go term. therefore, the vector element values at the index positions that correspond to these ancestors are set to  <dig>  otherwise set to  <dig>  for example, suppose we have five go terms for functional annotation , the function f is annotated by the fourth term whose ancestors are the second and third terms, and another function f' is annotated by the fifth term whose ancestors are the third and fourth terms, then these two functions f and f' can be represented as two vectors f→= and f→′= respectively.

the similarity between two functions f and f' is then defined as

  fsim=f→⋅f→′∕||f→||⋅||f→′|| 

where f→⋅f→′ is the dot production of two vectors and ||f→|| is the norm of the vector f→. it can be seen from the above definition that the similarity between two functions is within the range  <dig> ≤ f sim  ≤  <dig>  for the above two function vectors f→= and f→′= for instance, f→⋅f→′= <dig> ||f→||=||f→′||= <dig> and the similarity between these two function is f sim  = 2/ <dig> 

with the above protein and protein function similarities, the score of the un-annotated protein p being annotated by a function f ∈ fn, i.e. the contribution of function f to the final prediction results, is defined as:

  score= ∑p′∈n 

where n is the number of all proteins in the dataset and nf' is the number of proteins in the dataset that have the function f'. it can be seen from the equation  that the value of f sim  refers to the local impact of available functions within the local domain n on the prediction results, while the value lognnf′ reflects the global impact of available functions on the prediction results. intuitively, if a function f' is common to almost all proteins, i.e. almost all proteins in the dataset have the function f', then the importance as well as influence of f' decreases, otherwise it will increase.

the iterative function prediction is conducted based on the equation . in fact, for each available function f ∈ fn, its contribution to the final prediction results is calculated by the score defined in . therefore, all the functions in fn can be ordered by their scores from the highest to the lowest, and then the first k functions with the k highest scores are selected as the predicted functions of the un-annotated protein p. the value of k is determined empirically or by the prediction requirements. in this paper, we select k as the average number of functions each protein has in the dataset. with the predicted functions of the un-annotated protein p, the similarities between the un-annotated protein p and its neighbour proteins, i.e. sim  in , as well as the function scores are recalculated. with the recalculated scores, all the available functions in fn are re-ordered and a new prediction is made. this procedure is repeated until the similarities between the un-annotated protein p and its neighbour proteins achieve a stable state.

to start the above iterative prediction procedure, we need to assign initial functions to the un-annotated protein p, so that the similarities between the un-annotated protein p and its neighbour proteins in  can be calculated. the selection of initial functions for the un-annotated protein p is determined by the initial function scores calculated by the equation  but with the similarity sim  =  <dig> for any p' ∈ n, i.e. for each function f ∈ fn, its initial score is

  score= ∑p′∈n∑p′∈n 

we set the threshold for initial function selection as follows:

  ε=1size)∑f∈fnscore 

where size ) is the number of functions in the set fn. the functions whose scores calculated by  are over the threshold  are selected as the initial predicted functions of the un-annotated protein p.

it is observed from the above iterative prediction algorithm that the similarity definition of two proteins sim  is the key to conducting the function prediction iteratively. if the protein similarity is defined in other ways rather than from protein functions, the prediction algorithm based on  is just a normal weighted knn algorithm and the prediction cannot be conducted iteratively. so the prediction does not reflect the dynamic features of protein interactions, and it is just a one-off process. what makes our algorithm different from existing algorithms is that our protein similarity sim  of two proteins p,p' is defined from their functions. with this similarity definition, the prediction algorithm based on  can go through an iterative process to predict functions until the similarities achieve a stable state. in other words, the prediction algorithm with our protein similarity definition reflects the dynamic features of protein interactions.

RESULTS
to evaluate the effectiveness of our iterative prediction algorithm, as well as to compare our method with other related methods, we used a real s. cerevisiae protein-protein interaction  dataset derived from the biogrid site  to build a protein interaction network for computational experiments. this dataset contained  <dig>  interactions. to reduce the influence of noise data, we removed from the dataset the duplicated interactions, self interactions and all proteins that do not have go annotation information. the filtered dataset for the experiments then contained  <dig>  proteins,  <dig>  go terms and  <dig>  interactions. the go terms  <cit>  and go annotation dataset  <cit>  used in the experiments were downloaded from http://www.geneontology.org/. we only used the biological process ontology and the go annotations of s. cerevisiae in our experiments.

usually, the quality of a prediction algorithm is evaluated by its precision, recall and f-value, which are defined as follows:

  precision=npna,recall=npnr,f-value=2×precision×recallprecision+recall, 

where np is the number of correctly predicted functions for a given protein p, na is the number of all predicted functions for protein p, nr is the number of real functions of protein p. for these evaluation metrics, np is usually the number of predicted functions that exactly match the real functions. however, the function annotations of proteins have their specific features in the context of an annotation scheme such as the go. it is known that the go terms are organized in a hierarchical structure with the nodes representing the go terms and the edges representing ancestor-child relationships. if a protein p is annotated by a node, it is also annotated by all ancestor nodes of that node. the ancestors of a node mean the more general function categories in biology. in other words, if two functions share some ancestors in the go structure, even if they are not exactly the same, they are still similar to some extent at higher levels of functional categories. therefore in our evaluations, in addition to evaluating how many functions we can predict that exactly match the real functions, we also evaluated to which extent the predicted functions are similar to the real functions over the function ancestor terms in go. for this purpose, we adapted the evaluation method in  <cit>  with our function similarity for algorithm evaluations. actually, for a protein, suppose its real functional annotations are {fo <dig>  fo <dig>  fo <dig> ..., fon}, and the predicted functional annotations are {fp <dig>  fp <dig>  fp <dig>  ..., fpm}. the success of the prediction for a real function foi  is defined as:

 recallsuccess=maxjfsim 

and the success of a predicted function fpj  is defined as:

 precisionsuccess=maxifsim 

the measures of new recall and precision are defined as follows:

  recall=∑irecallsucess∑ifsim,precision=∑jprecisionsucess∑jfsim 

the new f-value is defined as before but with the above new recall and precision definitions. these new recall and precision measures do make sense in biology because although two proteins interact with each other, they do not necessarily have the exact same functions, but they might be in more general function categories . therefore, the above new measures of recall and precision are more reasonable when assessing prediction quality in real biological applications.

since our iterative algorithm is based on the cosine similarity between two function vectors, we named our algorithm the cosine iterative algorithm . due to the lack of existing similar iterative prediction algorithms, in our evaluation, we compared our cia with two algorithms that were also based on the knn method. one is neighbour counting   <cit>  which predicted functions in the same way as the initial function prediction in our algorithm, but without iterations. another one is the iterative neighbour counting  algorithm. the details of inc algorithm are as follows. we intended to evaluate whether the iterative approach  produced better prediction results than the non-iterative approach , and whether the cosine similarity based iterative algorithm  was better than the neighbour counting based iterative algorithm .

with the inc algorithm, the score of a function f ∈ fn being assigned to the un-annotated protein p is calculated as follows:

 score= ∑p′∈n 

where the function if,p' is defined as follow

 if,p′=1f∈f0f∉f 

the initial score is calculated as follows:

 score= ∑p′∈nif,p′f∈fn. 

the initial function selection for kicking off the iterative function prediction, as well as the iterative prediction procedure, is similar to our algorithm described above.

in our previous work  <cit> , we have already compared the inc algorithm with another iterative algorithm that was based on lin's similarity  <cit>  of protein functions, i.e. the if,p' in the above inc algorithm was replaced by the lin's similarities between functions. our previous evaluation results showed that the inc algorithm outperformed the lin's similarity-based iteration algorithm in terms of precision, recall and f-value when predicting protein functions from different protein interaction datasets. therefore in this paper, we focused on the comparison of cia algorithm with the inc algorithm with respect to the iterative prediction quality.

figures  <dig>   <dig> and  <dig> give the experimental results of the algorithms cia, inc and nc regarding the recall, precision and f-value evaluations respectively. we chose five functions that had the first five highest scores as the prediction results in the evaluation, as the average number of functions each protein had in the dataset was around five. the evaluation was conducted on randomly selected test datasets with different sizes, ranging from  <dig> to  <dig>  it was observed from the experimental results that iterative algorithms, cia and inc, outperformed the non-iterative algorithm nc. for the iterative algorithms, the cia algorithm performed better than the inc algorithm in terms of precision, recall and f-value. meanwhile, the cia algorithm was stable across the datasets, especially the large datasets.

to further evaluate the effectiveness of our algorithm, we conducted ten-fold cross-validation experiments. the original protein dataset was randomly divided into ten parts in the experiments. for each round of validation, one part was treated as a testing dataset and the remaining nine parts were treated as training datasets. the evaluation results for the three algorithms in terms of precision-recall are shown in figures  <dig> and  <dig> respectively, where figure  <dig> used the original definitions of precision and recall  and figure  <dig> used the new definitions of precision and recall . the results demonstrated that the overall performance of our iterative prediction algorithm cia was better than the other algorithms for both original and new definitions of precision and recall.

we also conducted cross-validation experiments on the protein interaction networks inferred by affinity-ms and two-hybrid assays in the original biogrid database. the evaluation results for the three algorithms in terms of precision-recall are shown in figures  <dig> and  <dig> respectively. the results also demonstrated that our algorithm cia outperformed the other algorithms.

to demonstrate the effectiveness of our iterative approach, in table  <dig> we provide some randomly selected sample prediction results from our iterative algorithm and the nc algorithm. it can be clearly seen from table  <dig> that for most of the proteins, the iterative algorithm predicted an increasing number of correct functions when compared with the non-iterative algorithm.

note: x stands for a not-predicted function. these sample results show that the iterative approach predicted more correct functions than the non-iterative approach. for instance, the nc algorithm predicted only one correct function for protein ygr285c, while the iterative algorithm predicted two correct functions; the nc algorithms failed in predicting any correct functions for protein ypr180w, however one function was correctly predicted by the iterative algorithm.

discussion
in this section, we discuss the concerns and issues related to our algorithm. the first concern is about the convergence of our iterative prediction algorithm. as stated in the section "methods", the iterative prediction is based on iteratively updating the function scores calculated by equation . it can be seen from equation  that the score of a function f is determined by two factors, one is the influence of the function f, i.e. ∑f′∈ffsim× lognnf′, another one is the similarity between the un-annotated protein p and its neighbour proteins, i.e. sim . for a given function f ∈ fn, its influence is fixed and will not be changed with the iterations. therefore, the convergence of the algorithm depends on whether the similarities sim , where p' ∈ n, will be stable after finite iterations. in fact, according to equation , the similarity between two proteins depends on the functions they possess. once their functions, especially the functions of the un-annotated protein p, are fixed, their similarity is fixed or stable. from the iterative algorithm, it can be seen that the final predicted functions should be those that have the highest influence and are highly similar to the functions of those proteins that are highly similar to the un-annotated protein p. however, those functions with an average influence but are highly similar to the functions of those proteins that are highly similar to the un-annotated protein p, or those functions with a higher influence but are on average similar to the functions of those proteins that are highly similar to the un-annotated protein p, are also the candidates of predicted functions. the initial function selection of the iteration algorithm only selects the most frequent functions that have the higher influence, without considering the impact of the protein similarity on the prediction results. after the first round of iteration, those functions are selected that have the highest influence and are highly similar to the functions of those proteins that are highly similar to the un-annotated protein p. as indicated above, since the neighbour of the protein p and the influence of the selected functions are fixed, the functions with the highest scores after the first round of iteration will still keep the highest scores in other iterations once they are assigned to the protein p, because the highest scored functions and protein similarities endorse each other in the iterations. therefore, the second round of iteration is to select those candidate functions that have the second highest scores, and so on. that means the highest scores from the previous iteration will not be changed in the next iteration. since the number of predicted functions is finite, after finite iterations  the similarities between the un-annotated protein p and its neighbour proteins will not be changed any more, i.e. be stable. therefore, the iterative algorithm is convergent. our experiments also demonstrated that usually after two or three iterations, the predicted functions are stable.

another concern about the iterative algorithm is whether the prediction results are sensitive to the initial function selection and the value of parameter k which determines the number of predicted functions. as analyzed above, the algorithm predicts functions by iteratively adjusting the similarities between the un-annotated protein and its neighbour proteins, and calculating the function scores. this iterative process has no specific constraints on the selection of initial functions, provided the candidate functions for iterations are selected as many as possible. theoretically, we can select all available functions within the neighbour of the un-annotated protein as the initial functions for iterations. in our algorithm, we select initial functions according to their influence. this selection method is based on our prediction algorithm and an assumption that functions with higher influence are more likely to be the candidates of predicted functions. therefore, this initial function selection method concentrates on those most likely candidate functions and reduces the computational cost. our observation from the experiments demonstrated the effectiveness and efficiency of this initial function selection method, as we did not see significant differences between the prediction results produced from the method that selects all available functions in the neighbour as the initial functions and the prediction results produced from our initial function selection method. we believe that other existing prediction algorithms can also be used to select initial functions for our algorithm. regarding the value of parameter k in the prediction, it is obvious that its value has impact on the prediction precision and recall, as well as the f-value. ideally, this parameter value should be determined objectively. we tried to determine this value to be the number of functions whose scores were above the average score, or by ranking the function scores first and then determining the value of k to be the number of functions whose scores did not decrease sharply  between two adjacent functions in the ranking list. our experiments showed that the current method of determining the value of k, i.e. the value of k is the average number of functions each protein has in the neighbour, achieved the best prediction results compared with other methods we tried. whether there are better methods for determining the value of k is an issue we will address in the future research.

CONCLUSIONS
this paper proposed a novel iterative approach trying to incorporate dynamic features of protein interactions into the protein function prediction. the iterative prediction algorithm also takes into account the local and global semantic influence of available functions within the protein interaction dataset on the prediction results. therefore our approach is more likely to reflect the real biological nature between proteins when predicting functions. we adapted new evaluation metrics accordingly to evaluate the prediction quality of our algorithm and other similar algorithms. the evaluation results demonstrated that in most cases, the iterative approach outperformed non-iterative ones with higher prediction precisions and recalls. the prediction results also showed the feasibility and effectiveness of the proposed iterative approach. since the iterations of the prediction algorithm occur within the neighbour of the un-annotated protein only, our iterative prediction algorithm can be scaled to other larger protein databases. it is concluded that the functions of an un-annotated proteins are mainly determined by the functions within the local domain  of the un-annotated protein, and those functions that are highly similar to all functions in the local domain and rare within the whole dataset are more likely to be the predicted functions of the un-annotated protein.

as we noticed, in our algorithm the prediction is based on the neighbour proteins of the un-annotated protein and their available information. in this paper, we only select those proteins that directly interact with the un-annotated protein as the neighbours. this neighbour selection method might lead to the genuine functions of the un-annotated protein being excluded from the final predicted functions. further research is needed to select neighbours more reasonably to improve the prediction quality while reducing the impact of noise data. another issue that comes to our notice is that in our algorithm we use a simple method to calculate the similarity of two proteins from their functions. although this similarity calculation method significantly reduces the computational cost, it might not be able to precisely reflect the real similarity between proteins. certain aggregation methods that make use of different data sources could be used to derive a more precise and reasonable protein similarity, and in turn, improve the prediction quality.

authors' contributions
xc participated in the study of prediction algorithms, carried out experiments and result analyses, and drafted the manuscript. jh conceived of and coordinated the study, carried out the study of prediction algorithms, participated in experimental result analyses, revised and finalized the manuscript. all authors read and approved the final manuscript.
