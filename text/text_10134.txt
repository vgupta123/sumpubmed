BACKGROUND
ests have been prevalent in genomic research since the first large scale est project in  <dig>  <cit> . there are many est projects that study the gene content of genome, tissue, or condition-specific transcripts . in october  <dig>   <dig> life sciences released the gs  <dig> pyrosequencer that generates over  <dig>  reads per run with an average length of  <dig> bases  <cit> . in january  <dig>  they released the gs flx that generates over  <dig>  reads with length between 200– <dig>  table  <dig> shows the growth of the number of ests in genbank in relation to their length. many of the short sequences released after  <dig> have been generated by the gs  <dig> or gs flx  <dig> . with the release of the titanium  <dig> in october  <dig>  which produces reads of length  <dig>  <cit> , we can expect to see the prevalence of  <dig> ests of length 400+ grow quickly.

a the gs  <dig>  <dig> was released in october  <dig> with read lengths less than  <dig> 

b the gs flx  <dig> was released in january  <dig> with read lengths between 200– <dig> 

besides the  <dig> sequencer, the following are also next-generation sequencers that generate high-throughput short reads: illumina genome analyzer  <cit>  developed by solexa , applied biosystems solid sequencing  <cit> , and helicos gss sequencing  <cit> . the  <dig> sequencer comes with the newbler assembler, and there are multiple assembly packages tested for the illumina system  <cit> . however, these are all tested on small genomes, chromosomes or bacs, which will have much shallower coverage compared to est contigs.

many current est projects have generated  <dig> data and either used traditional est assembly approaches  or aligned the ests to a related genome or assembled transcripts . laboratories are now transitioning between the traditional sanger ests and new  <dig> ests. for example, our laboratory has a full-length cdna project using sanger 5' and 3' ests, and three other projects that have a mix of  <dig> and sanger ests. for our sanger projects, we developed a software package called pave  that utilizes mate-pair information. with the release of the  <dig> sequencer, we extended pave to work for the increased depth of the  <dig> est data sets.

the ests generated by sanger versus the  <dig> sequencer differ in number and length. the current sanger ests have an average length of around  <dig> good bases, but the number of ests that are sequenced is generally low. the cdna sample must first be cloned into a vector  to produce a cdna library and then individual clones are isolated from the library and sequenced, which results in a few thousand clones being sequenced. for example, most maize libraries in genbank have between  <dig> and  <dig>  ests. the  <dig> gs flx sequencer can generate over  <dig>  good ests per project, but at an average length of only  <dig> trimmed bases. the new  <dig> gs flx titanium is capable of generating over a million reads of  <dig> bases with reduced error  <cit> . this technology currently does not produce identifiable cdna mate-pairs.

sanger sequencing can produce mate-pairs where it is known which ests are mates based on their name. if the clone is full length, the 5' end will start at the beginning of the transcript, otherwise it can start anywhere within the original mrna sequence. it is now relatively inexpensive to generate both the 3' and 5' reads of a clone, as the library only needs to be prepped once. to date no software exists that takes full advantage of mate-pair information in order to produce better contigs. cap <dig>  <cit>  uses mate-pair information to build contigs but does not require that they be in the same contig. phrap  <cit>  uses mate-pair information to flag potential chimeric clones by inserting the chimeric mate into a contig. clustering programs, such as stack  <cit>  and pace  <cit> , will use mate-pair information to join clusters, but these may be broken into multiple contigs when assembled by cap <dig> or phrap. by contrast, pave requires mate-pairs to be in the same contig. it does not allow mate-pairs to be split across contigs, and if none of the ests in the 5' and 3' sub-contigs overlap, they are joined by n's. pave has been used to assemble multiple projects including  <dig>  maize ests from genbank  <cit> .

the advent of  <dig> sequences presents new challenges to assembly. the increased depth of the  <dig> data sets can cause cap <dig> and other assembly programs to run out of memory. moreover, assembling large contigs  is time-consuming. to address both problems, ests contained in another may be removed, such as performed by plantgdb  <cit> . pave removes  many of the ests that are contained in another  during assembly; after assembly, the buried ests are placed in their parents' respective contigs in order to retain the expression level.

there are quite a few packages for the pipeline processing that est data requires . for example, est2uni  <cit>  is a pipeline that trims and cleans ests using external programs such as lucy  <cit> , assembles the ests with cap <dig> or tgicl  <cit> , and has annotation capabilities. we find that ests generated from different technologies and laboratories require different trimming and cleaning processes, so these functions are not part of the pave software package. however, pave includes a data management system in order to allow assembling many libraries together while retaining the information about each library. the pave system contains a java program called jpave that allows easy verification and display of assemblies in the pave mysql database. the system supports annotation by uniprot  <cit>  match, gc content, orfs, r statistic  <cit>  and comparison of contigs. the assembly software, data management software, and jpave viewer are freely available along with a user's guide  <cit> .

implementation
the pave system is written in perl, the jpave assembly viewer is written in java, and the data is stored in a mysql database. the inputs to pave are standard fasta formatted sequence and optional quality files, which have been trimmed and cleaned.

pave assembly
as shown in figure  <dig>  the pave algorithm has a clique  step, followed by one or more transitive closure  steps. the pave algorithm uses megablast  <cit>  for similarity results and cap <dig>  <cit>  for assembly, with the following set of rules:  mate-pairs must be in a contig together. if the mate-pairs assemble into two different contigs, the two sub-contigs are treated as a single contig.  contigs are incrementally built prioritized on bit scores and number of ests. once a set of ests are in a contig together, they will never be split apart though they may be merged with others.  cap <dig> is only given sets of ests for assembly where the matched regions are correctly overlapping. parameters governing these rules are provided by the user in a configuration file .

guiding the system are the ok_olap and ok_ctg functions, which contain rules for acceptance or rejection of megablast and cap <dig> output, respectively. ok_olap returns true if the sequences sx and sy have a minimum overlap of m, a minimum identity of d%, and a maximum overhang of h. the small amount of overhang allowed by h is necessary on the end of the overlapping portion to allow for poorly trimmed sequence. the parameters mi, di and hi are set by the user in a configuration file . the ok_ctg function analyzes the results of cap <dig> to determine whether to accept or reject the contig. there are three sets of rules that have been designed by us based on inspection of contigs using the jpave graphical interface, and will be discussed in the section on heuristics.

the clique step creates seed contigs from the file of est-against-est comparison results, as follows:  compute mate-pair cliques where each mate-pair must pass ok_olap with every other mate-pair in the clique. each clique is assembled and if the cap <dig> results pass ok_ctg, it is retained as a seed contig.  compute singleton cliques where each singleton must pass ok_olap with every other singleton in the clique. each clique is assembled and if the cap <dig> results pass the ok_ctg function, it is retained as a seed contig.  each remaining mate-pair is made into a contig, where the mates are joined if they pass ok_olap.  each remaining singleton is made into a contig. the purpose of assembling cliques is that the existence of a set of mate-pairs  that all mutually overlap creates a strong contig and it reduces the time of the next step. this step produces the initial contig consensus sequences .

the tc step computes the set of tcs from the file of ccs-against-ccs comparison results. each tc is a connected graph where each node is a contig, an edge exists between each two contigs that pass ok_olap, and the edge is weighted by the bit-score. the nodes of a given tc are incrementally assembled together where the order is based on bit score and the number of ests. if a pair assembles correctly according to ok_ctg, the two nodes are collapsed into one. the tcs are assembled in parallel, i.e. each tc is assigned to a separate compute node for incremental assembly. the parallelism is implemented with the standard unix fork function to take advantage of multiple processors.

the tc step is executed n times using the values , i =  <dig> to n+ <dig>  where the n corresponding parameters are provided in the configuration file. for sanger ests, we typically use two iterations, which merges over-split contigs; this approach of using a second assembly has been used by others, e.g. plantgdb  <cit> . for  <dig> reads, we use up to eight iterations in order to allow for incremental burying, i.e. to prevent very large contigs from being assembled.

two sub-contigs are not joined by n's until after assembly, at which point the orientation of the two sub-contigs needs to be computed. this is computed by a majority rule on the orientation and forward/reverse information of the ests.

heuristics
the ok_ctg function evaluates the output of cap <dig> and accepts it if it results in one contig and rejects it if it results in more than two contigs . if it results in two contigs, there must be more than one mate-pair bridging the two sub-contigs and all orientations must be consistent. these two rules are relaxed on the last iteration of assembling tcs in order to allow for the more common exceptions:  two small sub-contigs may be bridged by one mate-pair.  the sub-contigs may have mixed orientation, for example, both ends of the last mate-pair shown in figure  <dig> assembled into the 3' contig. the heuristics try to determine if two-subcontigs are from the same transcript by using the counts of the 5', 3', un-complemented and complemented ests. these heuristics can never be  <dig> percent correct as the possibilities are endless, but are better than not joining the contigs or blindly joining them all .

a chimeric clone may have one half of the mate-pair belong in one contig and the other half in another contig. by forcing mate-pairs to be in contigs together, a chimeric clone will generally be in a contig of its own. the advantage is that it reduces chimeric multi-clone contigs resulting from chimeric clones. the disadvantage is that it may cause redundant contigs, as one half of the single mate-pair contig may align perfectly to another contig.

burying clones
to substantially decrease usage of computer time and space, ests are buried both before and during the assembly process, i.e. if est b is contained in est a, it can be "buried" in the "parent" est a and removed from assembly. ests may be buried prior to assembly when one est is contained in another based on the blast coordinates; the amount of mismatches allowed is a user-supplied parameter. during assembly, additional ests are buried if one is contained within another based on cap <dig> coordinates, even though there may be mismatches between the buried and parent ests. for mate-pairs, both mates must be contained in the same parent clone in order to be buried. buried ests are recorded in a file and when the pave algorithm completes and the contigs are loaded into the database, the buried clones are assigned the same contig as the parent.

the algorithm for burying ests  ensures that the remaining unburied ests are sufficient to provide a good coverage of the contig. briefly, the algorithm builds a containment tree and then performs a breadth-first traversal of the tree, retaining all top-level ests plus a number of ests from the next-highest levels based on configuration parameters. the breadth-first search serves to distribute the retained ests evenly across the contig. after retaining a sufficient number for good coverage, the rest of the ests in the tree are buried. for burial during assembly, the unburied ests are re-cap'ed, and if they fail to assemble together, the attempt to bury the clones is rejected. since this re-cap takes time, the burial is only attempted if there are at least y  ests in a contig and at least ×  ests can be buried.

a post-processing routine reassembles the contigs that have buried ests using all ests in the contig, primarily in order to provide accurate coordinates for the buried clones. the re-cap occasionally fails due to too many ests or due to the mismatches from the cap <dig> buried ests; in these cases, the ests are positioned under their parent clone and shown in red.

the pave system
as we have multiple pave projects, each with many est libraries, it was advantageous to create an organized data management system as part of pave. this is done with a set of configuration files and a rigid directory structure, where there is a directory for libraries and another for assembly projects. by separating the libraries from the assemblies, different projects can be created with overlapping sets of libraries. the package provides four programs:  the loadlibrary.pl script loads one or more libraries of ests and metadata  into the mysql database.  the runpave.pl script assembles the ests and enters the results into the database.  the capburied.pl script runs cap <dig> on all the contigs with buried ests in order to assign correct coordinates.  the jpave program provides some annotation and an interactive display.

after assembling the contigs, the runpave.pl script computes the r statistic  <cit> , which identifies differentially expressed genes across the libraries. it also finds the longest clone  per contig, and marks contigs that are suspect based on having excessive mixed orientation or more than two stacks of ests. the jpave program's annotation module can be run to compute gc content, orfs, snps, ccs against uniprot comparison, and css against css .

the jpave program can be run as either as a standalone program or a web applet. the initial window shows all pave projects, where any number can be selected for viewing . as shown in figure  <dig>  jpave uses a biomart  <cit>  style query to allow easy complex queries on the annotation. individual contigs can be displayed graphically or as base-pair sequences. by default, the buried ests are not displayed, which can save considerable time when displaying the contig; the number of buried ests is indicated next to each parent est. the alignment of two ccss can be viewed by nucleotide and amino acid similarity. in the standalone version, ests can be selected to assemble with cap <dig> or phrap using user-specified parameters.

RESULTS
three sets of results are provided:  maize sanger ests with mate-pairs,  trichome  <dig> ests,  a comparison of pave to cap <dig> and tgicl with a benchmark set of sanger mate-pair ests. the pave parameters used for each assembly are provided in additional file  <dig>  the sanger and benchmark assemblies can be viewed from the pave site  <cit> .

assembly of sanger ests
the maize ests were downloaded from genbank, then filtered to remove the ests less than  <dig> bases in length or submitted earlier than  <dig>  the resulting  <dig>  ests had an average length of  <dig> bases and median of  <dig> bases. unfortunately, there is no field in the genbank record that explicitly identifies a 3' and 5' est as mate-pairs, but the ests from our maize full length cdna project  <cit>  are named such that the mate-pairs are identified. all ests were entered into the pave database along with their library information, where there were  <dig> libraries with over  <dig> clones . table  <dig> shows the results from assembling the ests. a significant metric is the  <dig>  contigs joined by n's, where two contigs have been joined into one based on mate-pair information; most of these would have been reported as two contigs using other assembly programs. likewise most of the  <dig>  single mate-pair contigs would have been reported as singletons.

a does not include singletons.

b no mismatches were allowed for the initial blast bury for the sanger, whereas one mismatch was allowed for the  <dig> 

c the initial self-blast of the maize and trichomes ests took  <dig> cpu hours  <dig> cpu hours on a super-computer, respectively, which is not included in the time.

this maize sanger assembly was executed on a system with two dual-core amd opteron  <dig> ghz processors and 12g ram. though the execution time is  <dig>  days, very little human time is required to run the assembly. that is, the dataset does not have to be broken up, assembled separately and then merged, as would be necessary with programs that cannot handle datasets of this size. for example, the largest data set we can assemble on this machine with tgicl is  <dig>  ests.

assembly of  <dig> ests
our  <dig> data set is  <dig>  ests from the stems of solanum arcanum  from the solanum trichome project  <cit> . the average length of the cleaned ests is  <dig> bases and the median is  <dig> bases. the results are shown in table  <dig>  the largest contig is  <dig>  ests with a  <dig> bases consensus sequence; with the narrow depth, the ability to bury all but  <dig> of ests greatly speeds up assembly and display. in fact, it would not assemble without burying as cap <dig> runs out of memory when assembling all  <dig>  ests.

this trichome  <dig> assembly was executed on a system with four dual-core intel xeon  <dig>  ghz processors and 14g ram, which took almost as long as the much larger maize assembly, even though it was run on a faster machine. this is due to the number of deep contigs as illustrated in figure  <dig>  which shows the jpave listing of the top  <dig> contigs; in contrast, the largest maize contig is  <dig> ests.

comparisons with other programs
we compared pave to tgicl and cap <dig> for two reasons. first, the majority of est papers use one of these two programs . second, all three assemblers use cap <dig> for alignment, so that the comparison specifically addresses the effectiveness of using mate-pair information as a strict constraint, rather than variables in the alignment algorithm. to compare the assemblies, a set of benchmark contigs were created that contained  <dig>  mate-pairs  which aligned to  <dig> of the kome rice fl-cdnas  <cit>  .

the benchmark ests were assembled with the three programs and the results were tested against the benchmark contigs to determine the number of split  and merged  contigs. a contig pair  was counted as merged if a pair of ests in an assembled contig were in different benchmark contigs b <dig> and b <dig>  a contig pair  was counted as a split contig if a pair of ests in a benchmark contig were in different assembled contigs a <dig> and a <dig>  table  <dig> shows the numbers of split and merged contigs in addition to the number of split mate-pairs, singletons and contigs.

a does not include singletons.

b pave and tgicl used  <dig> processors, whereas cap <dig> is not parallelized so used one processor.

c  <dig> contigs are joined by n's where  <dig> of them are single-mate pair contigs.

as these are well-aligned ests, there are few merged contigs. most of the split contigs for tgicl and cap <dig> are due to mate-pairs that do not overlap, that is,  <dig> pave contigs were joined by n's of which  <dig> are single mate-pairs. for example, figure  <dig> shows two contigs joined by n's, which is a split contig in the cap <dig> and tgicl assemblies. these split contigs account for many of the extra contigs in the tgicl and cap <dig> assemblies, an excess which often causes the number of tentative genes to be over-estimated.

as they all use cap <dig> with identical parameters for alignment, the consensus sequences are very similar, with the average identity of each contig consensus sequence to the original fl-cdna being over 99%. however,  <dig> tgicl consensus sequences and  <dig> cap <dig> consensus sequences did not align well to their corresponding fl-cdna due to bad joins which are avoided in pave by using mate-pair information; for example, see figure  <dig> 

CONCLUSIONS
since ests came into widespread use, the typical approach to assembling them has been to cluster the ests and assemble with cap <dig> or phrap. most projects used cap <dig> alone or tgicl for assembly, where tgicl clusters with a version of megablast and then assembles with cap <dig> . there are quite a few programs written specifically to cluster ests, but only miraest  <cit>  was specifically written to assemble ests ; note, cap <dig> and phrap were written for genome assembly. in comparison, there are many assemblers developed for whole genome sequencing based on sanger reads, and a number of assemblers have emerged for illumina reads.

as shown in our results, improved assemblies can be computed if both the 3' and 5' reads are used; this is similar to the improvements in assembly that are obtained when paired reads are used in whole genome assembly  <cit> , and has also been shown for the illumina paired short-reads  <cit> . in the early generation of the 3' and 5' sanger ests, the mate-pair information could not be trusted, but for many years now, that has no longer been the case as laboratory tracking systems have improved. though the use of sanger sequencing for ests will probably decline, the historical data still has considerable value. as shown in table  <dig> there are hundreds of thousands of sanger ests available that should continue to be a valuable resource for years to come, and those with mate-pair information can take advantage of the pave assembler.

though pave assembles the  <dig> ests with acceptable results, the new short read assemblers that are based on prefix trees and extensions  or de buijin graphs  could provide better results when there is a lot of error or repeats. we are currently working on modifying pave so that it can use the results of various assemblies to take advantage of these custom assemblers and integrate the results with the pave mate-pair assemblies of sanger reads.

the jpave assembly viewer provides an excellent way to evaluate contigs. we have assembled a large variety of libraries with different characteristics, and the occasional oddly-aligning contigs often cannot be explained nor anticipated. having a versatile query and display program such as jpave is essential to understanding the wide range of problems that can occur with est assembly. moreover, it allows the biologist to diagnose the problems that occur with their specific libraries. for example, by assembling ests without the heuristics and then viewing them in jpave, the biologist can inspect the amount of chimerism and 3' slippage.

the pave system is created for large projects with multiple libraries. this allows comparing across libraries for differentially expressed genes, which will become more relevant with the large number of ests generated by the next-generation sequencing machines. the pave system also has a web interface , which allows extensive querying ability on the libraries . the web interface is not part of the distribution but is available upon request . the software, jpave viewer and user's guide are available from our pave website  <cit> , where the user's guide comes with a demonstration dataset.

availability and requirements
◦ project name: pave

◦ project home page: 

◦ operating system: unix/linux

◦ programming languages: perl and java

◦ other requirements: java  <dig>  or higher, mysql

◦ license: gnu public license

◦ any restriction to use by non-academics: none.

abbreviations
est: expressed sequence tags; gs: genome sequencer; bac: bacterial artificial chromosome; kome: knowledge-based oryza molecular biological encyclopedia; orf: open reading frame; snps: single nucleotide polymorphism; tc: transitive closure 

authors' contributions
cs conceived the study and wrote the majority of the paper, with aid from all the other authors. ej and mb provided most of the development work with aid from cs and ad. ad prepared the maize and trichome data sets.

supplementary material
additional file 1
list of est papers. a partial list of est papers published since  <dig>  with sections:  <dig>  est assembly software.  <dig>  est pre-processing, pipeline and viewing software.  <dig>  est annotation.  <dig>  est analysis for one for one or more libraries.  <dig>  related papers.  <dig>  typical references in est papers.

click here for file

 additional file 2
parameters and log files. the parameters and content the of log files for the maize, trichomes and benchmark assemblies.

click here for file

 additional file 3
benchmark contigs. a description of the steps and parameters used to create the benchmark contigs.

click here for file

 acknowledgements
we thank james hatfield and karl haller for their original work on pave. we thank david gang, josh udall, guo-liang wang and yeisoo yu for feedback on the contigs and interface; david gang and william nelson for their input on the manuscript; and a special thanks to william nelson for his testing of the final pave system and the example of bad joins shown in figure  <dig>  the work was funded in part by the national science foundation  <cit> .
