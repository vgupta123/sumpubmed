BACKGROUND
a huge number of protein coding sequences have been generated by genome sequencing projects. in contrast, there is a much slower increase in the number of known three-dimensional  protein structures. determination of a protein's 3d structure is a formidable challenge if there is no sequence similarity to proteins of known structure and thus protein structure prediction remains a core problem within computational biology.

computational prediction of protein structure has achieved significant successes  <cit> . focusing on the fold prediction problem of immediate interest to this paper, one computational method known as the taxonomic approach  <cit> , presumes the number of folds is restricted and focuses on structural predictions in the context of a particular classification of 3d folds. proteins are in a common fold if they share the same major secondary structures in the same arrangement and the same topological connections  <cit> . in the taxonomic method for protein fold classification, there are several fold discriminatory data sources or groups of attributes available such as amino acid composition, predicted secondary structure, and selected structural and physicochemical properties of the constituent amino acids. previous methods for integrating these heterogeneous data sources include simply merging them together or combining trained classifiers over individual data sources  <cit> . however, how to integrate fold discriminatory data sources systematically and efficiently, without resorting to ad hoc ensemble learning, still remains a challenging problem.

kernel methods  <cit>  have been successfully used for data fusion in biological applications. kernel matrices encode the similarity between data objects within a given input space and these data objects can include graphs and sequence strings in addition to real-valued or integer data. thus the problem of data integration is transformed into the problem of learning the most appropriate combination of candidate kernel matrices, representing these heterogeneous data sources. the typical framework is to learn a linear combination of candidate kernels. this is often termed multiple kernel learning  in machine learning, and non-parametric group lasso in statistics. recent trends in kernel learning are usually based on the margin maximization criterion used by support vector machines  or variants  <cit> . the popularity of svm margin-based kernel learning stems from its efficient optimization formulations  <cit>  and sound theoretical foundation  <cit> . other data integration methods include the cosso estimate for additive models  <cit> , kernel discriminant analysis  <cit> , multi-label multiple kernel learning  <cit>  and bayesian probabilistic models  <cit> . these methods, in general, can combine multiple data sources to enhance biological inference  <cit>  and provide insights into the significance of the different data sources used.

following a different approach, in this paper we propose an alternative criterion for kernel matrix learning and data integration, which we will call mkldiv. specifically, we propose an information-theoretic approach to learn a linear combination of kernel matrices, encoding information from different data sources, through the use of a kullback-leibler divergence  <cit>  between two zero-mean gaussian distributions defined by the input matrix and output matrix. the potential advantage of this approach is that, by choosing different output matrices, the method can be easily extended to different learning tasks, such as multi-class classification and multi-task learning. these are common tasks in biological data analysis.

to illustrate the method, we will focus on learning a linear combination of candidate kernel matrices  using the kl-divergence criterion with a main application to the protein fold prediction problem. there are two different formulations based on the relative position of the input kernel matrix and the output kernel matrix in the kl-divergence objective. for the first formulation, although this approach involves a matrix determinant term which is not convex in general, we elegantly reformulate the learning task as a difference of convex problem, which can be efficiently solved by a sequence of convex optimizations. hence we refer to it as mkldiv-dc. the second kl-divergence formulation for kernel integration, called mkldiv-conv, is convex and can be solved by a projected gradient descent algorithm. experimental results show that these formulations lead to state-of-the-art prediction performance. in particular, mkldiv-dc outperforms the best reported performance on the important task of protein fold recognition, for the benchmark dataset used.

methods
in the following we first revisit kernel learning approaches based on svms  <cit>  and kernel discriminant analysis  <cit> . then, we introduce our novel information-theoretic approach for data integration based on a kl-divergence criterion. finally we discuss how to solve the optimization task efficiently. for brevity, we use the conventional notation ℕn = { <dig>   <dig>  ..., n} for any n ∈ ℕ.

background and related work
kernel methods are extensively used for biological data analysis. a symmetric function k : x × x → ℝ is called a kernel function if it is positive semi-definite, by which we mean that, for any n ∈ ℕ and {xi ∈ x: i ∈ ℕn}, the gram matrix  is positive semi-definite. according to  <cit> , its corresponding reproducing kernel hilbert space , usually denoted by ℋk, can be defined to be the completion of the linear span of the set of functions {kx := k: x ∈ x} with inner product satisfying, for any x ∈ x and g ∈ ℋk, the reproducing property ⟨kx, g⟩k = g. by mercer's theorem, there exists a high dimensional  hilbert feature space ℱ with inner product ⟨·, ·⟩ℱ and a feature map ϕ: x → ℱ such that k = ⟨ϕ , ϕ ⟩ℱ, ∀ x, t ∈ x. intuitively, the kernel function k implicitly maps the data space x into a high dimensional space ℱ, see  <cit>  for more details.

within the context of protein fold recognition, we have m different fold discriminatory data sources where samples across each data source can be represented by  for ℓ ∈ ℕm and the outputs are denoted by y = {yi : i ∈ ℕn}. for kernel methods, for any ℓ ∈ ℕm, each ℓ-th data source can be encoded into a candidate kernel matrix denoted by . depending on the different data sources used, the candidate kernel function kℓ should be specified a priori by the practitioner. the composite kernel matrix is given by  where {λℓ: ℓ ∈ ℕm} are real-valued kernel weights and typically they are restricted to be non-negative. in this context, the problem of data integration is consequently reduced to the problem of learning a convex combination of candidate kernel matrices: more precisely learning the kernel weights λ. different optimization criteria over the candidate kernels arise from the particular kernel learning algorithm used. cristianini et al.  <cit>  proposed a kernel learning approach which uses the cosine of the angle between the two bi-dimensional vectors kλ and ky representing the gram matrices. this is achieved by maximizing the kernel alignment:  

the above kernel learning formulation can be solved by a semi-definite programming  approach . however, an sdp formulation is computationally intensive.

another widely used criterion for kernel learning is based on the margin concept in svms and variants. denoting the simplex set as Δ = {λ = : }, lanckriet et al  <cit>  proposed the following formulation for kernel learning:   

where 1n is a column vector of all ones, c is a trade-off parameter, and t =  denotes the binary outputs with ti ∈ { <dig>  -1} being the class label for i-th instance. this task was reformulated as a quadratically constrained quadratic programming  problem and later improved by sonnenburg et al.  <cit>  who reformulated it as a semi-infinite linear programming  task. moreover, it was pointed out in  <cit>  that this is equivalent to the following sparse l1-regularization formulation:   

the l1-regularization term  encourages the sparsity  <cit>  of rkhs-norm terms, and thus indicates the relative importance of data sources. it was shown in  <cit>  that the standard l2-regularization  is equivalent to the use of uniformly weighted kernel weights λ, i.e.  for any ℓ ∈ ℕm. recently, ye et al.  <cit>  proposed an appealing kernel learning approach based on regularized kernel discriminant analysis. this can similarly be shown to be equivalent to a sparse l1-regularization formulation with a least square loss, see appendix  <dig> for more details.

information-theoretic data integration
in this paper we adopt a novel information-theoretic approach to learn the kernel combinatorial weights. the main idea is to quantify the similarity between kλ and ky through a kullback-leibler  divergence or relative entropy term  <cit> . this approach is based on noting that these kernel matrices encode the similarity of data objects within their respective input and label data spaces. furthermore, there is a simple bijection between the set of distance measures in these data spaces and the set of zero-mean multivariate gaussian distributions  <cit> . using this bijection, the difference between two distance measures, parameterized by kλ and ky, can be quantified by the relative entropy or kullback-leibler  divergence between the corresponding multivariate gaussians. matching kernel matrices kλ and ky can therefore be realized by minimizing a kl divergence between these distributions and we will exploit this approach below in the context of multiple kernel learning.

kernel matrices are generally positive semi-definite and thus can be regarded as the covariance matrices of gaussian distributions. as described in  <cit> , the kullback-leibler  divergence  between a gaussian distribution  with the output covariance matrix ky and a gaussian distribution  with the input kernel covariance matrix kx is:   

where, for any square matrix b, the notation tr denotes its trace. the a priori choice of the output matrix ky will be discussed later. though kl ||) is non-convex w.r.t. kx, it has a unique minimum at kx = ky if ky is positive definite, suggesting that minimizing the above kl-divergence encourages kx to approach ky. if the input kernel matrix kx is represented by a linear combination of m candidate kernel matrices, i.e. , the above kl-divergence based kernel learning is reduced to the following formulation:   

where in denotes the n × n identity matrix and σ >  <dig> is a supplemented small parameter to avoid the singularity of kλ.

since the kl-divergence is not symmetric with respect to ky and kλ, another alternative approach to matching kernel matrices is given by   

where parameter σ >  <dig> is added to avoid the singularity of ky. if there is no positive semi-definiteness restriction over kℓ, this formulation is a well-known convex maximum-determinant problem  <cit>  which is a more general formulation than semi-definite programming , its implementation is computationally intensive, and thus cannot be extended to large-scale problems according to  <cit> . however, formulation  has a special structure here: λℓ is non-negative and all candidate kernel matrices are positive semi-definite. hence, we can solve this problem by a simple projected gradient descent method, see below for more details.

the kl-divergence criterion for kernel integration was also successfully used in  <cit>  which formulated the problem of supervised network inference as a kernel matrix completion problem. in terms of information geometry  <cit> , formulation  corresponds to finding the m-projection of ky over an e-flat submanifold. the convex problem  can be regarded as finding the e-projection of ky over a m-flat submanifold. in  <cit> , formulation  was developed for learning an optimal linear combination of diffusion kernels for biological networks. a gradient-based method was employed in  <cit>  to learn a proper linear combination of diffusion kernels. this optimization method largely relies on the special property of all candidate diffusion kernel matrices enjoying the same eigenvectors and the gradient-based learning method could be a problem if we deal with general kernel matrices. in the next section, we propose to solve the general kernel learning formulation  using a difference of convex optimization method.

the formulation  also has a close relation with gaussian process regression  <cit> . a gaussian process f can be fully specified by giving the covariance matrix for any finite set of zero-mean random variables f = {f: i ∈ ℕm}. the relation between the inputs x = {xi : i ∈ ℕn} and outputs y = {yi : i ∈ ℕm} is realized by the latent variable f as follows:  

where in denotes the n × n identity matrix and the latent random variable f = )) is distributed as a gaussian process prior. the gaussian process prior can be fully specified by a kernel k with a random covariance matrix  associated with random samples x = {xi: i ∈ ℕn}. specifically, it can be written as f|x ~. we assume a uniform distribution over λ, i.e. a dirichlet prior distribution  with α <dig> =  <dig>  if we let ky = yy⊤ in the objective function of formulation , then one can easily check that, up to a constant term, the objective function in formulation  is the negative of the log likelihood of gaussian process regression, and maximizing the log likelihood is equivalent to the minimization problem .

optimization formulation
we now turn our attention to optimization approaches for the kl-divergence based kernel learning formulations  and . in particular, we show that formulation  can be approached by a projected gradient descent method and  can be solved by a difference of convex algorithm   <cit>  which, for linear constraint conditions, reduces to the special case of a concave convex procedure   <cit> . to this end, let   

and   

theorem  <dig> let functions g and f be defined by  and . then, both f and g are convex with respect to λ ∈ Δ. moreover, problem  is convex and problem  is a difference of convex problem, i.e.   

proof it suffices to prove the convexity of f and g. to this end, from  <cit>  we observe that functions – log |c| and tr are convex with respect to positive semi-definite matrices c. hence, f and g are convex with respect to λ ∈ Δ. this completes the proof of the theorem.

for simplicity we refer to the kl-divergence kernel learning formulation  as mkldiv-dc since it is a difference of convex problem and refer to formulation  as mkldiv-conv since it is a convex problem.

projected gradient descent method for mkldiv-conv
we propose a projected gradient descent  method to solve problem . the idea of this method is to alternately implement a gradient descent and then a projection to the feasible domain, see e.g.  <cit> . recall the derivative of the log determinant,  

with a little abuse of notation, we also denote by    the objective function of problem . consequently, its gradient is given by   

then, at iteration step t the gradient descent step is realized by  

where η >  <dig> is a prescribed step size. the projection of β to the feasible domain Δ can be written as the following quadratic programming problem   

the theoretical convergence rate of the projected gradient descent method is generally of complexity  where t is the iteration number and l is the lipschitz constant of the gradient function defined by , see e.g.  <cit> . here, the lipschitz constant l is bounded by the largest eigenvalue of the hessian  of the objective function defined, for any i, j ∈ ℕm, by  

since ℒ is convex, the hessian ℋ is positive semi-definite and thus   

where ||·||fro denotes the frobenious norm of a matrix. hence, the projected gradient descent algorithm could take longer time to become convergent if the value of σ is very small.

difference of convex algorithm for mkldiv-dc
by theorem  <dig>  problem  is a difference of convex problem. we propose to solve this problem by a concave convex procedure   <cit> . this procedure iteratively solves the following convex problem:   

where, for any j ∈ ℕm, the derivative of the log determinant is given by equation . before we continue the main discussion, let us first note an interesting property of cccp. by the definition of λ, we know that  

since g is convex, we have that  

consequently,   

which means that the objective value ℒ) monotonically decreases with each iteration. consequently, we can use the relative change of the objective function as a stopping criterion. local convergence of the dca algorithm is proven in  <cit>  . tao and an  <cit>  state that the dca often converges to the global solution. overall, the dc programming approach to mkldiv-dc can be summarized as follows.

• given a stopping threshold ε

• initialize λ, e.g.  for any ℓ ∈ ℕm

• given the solution λ at step t, for step t +  <dig>  first compute ▽g) by equation . then, compute solution λ of convex subproblem .

• stop until the relative change  where ε is a stopping threshold

silp formulation for the convex subproblem 
we now turn to the solution of the convex subproblem . to see this, first decompose the output matrix ky into the form ky = aa⊤, e.g. by eigen-decomposition. here, a is an n × r matrix with r = rank which always exists since ky is positive semi-definite. hence, by introducing an auxiliary matrix α ∈ ℝn × r, we observe, for any positive definite matrix c, that  

applying the above equality with , up to a constant, equation  is equivalent to the augmented problem:  

equivalently, by the min-max theorem    

to solve the subproblem , we can formulate it as a quadratically constrained quadratic programming  problem as in  <cit> . here we formulate the problem in  as a semi-infinite linear programming  problem  <cit>  since silp usually has better scalability compared to qcqp. to see this, let , and . then, letting , we can rewrite  as a silp problem:   

in , there are an infinite number of constraints , indicative of a semi-infinite linear programming  problem. the silp task can be solved by an iterative column generation algorithm  which is guaranteed to converge to a global optimum. a brief description of the column generation method is illustrated in appedix  <dig> 

alternatively we could apply the projected gradient descent  method in the above subsection directly to the convex subproblem . however, the gradient function of its objective function involves the matrix . in analogy to the argument of inequality , the lipschitz constant of the gradient of the objective function in  is very large when the value of σ is very small, and thus the projected gradient descent algorithm could take longer to become convergent. hence, this could make the overall dc programming unacceptable slow. in contrast, in the silp formulation  we introduce the auxiliary variables α to avoid the matrix . in addition, the gradient descent algorithm generally needs to determine the step size η according to the value of σ, see also discussion in the experimental section.

prior choice of the output kernel matrix
the choice of the output kernel matrix ky will depend on the problem considered. we first consider a multi-class classification for the specific task of protein fold recognition. in this case, we preprocess the output labels using a one-against-all strategy. in particular, for a c-class classification we recast the outputs y = {yi : i ∈ ℕn} as  such that yip =  <dig> if xi is in class p and otherwise - <dig>  hence the outputs are represented by an n × c indicator matrix y = i, p whose p-th column vector is denoted by yp. then, taking ky = yy⊤, formulation  can be extended to the joint optimization problem   

and formulation  can be written as   

for the protein fold recognition and yeast protein function prediction projects discussed below, we choose ky = yy⊤ as stated.

in general, though, ky might encode a known structural relationship between labels. for example, in supervised gene or protein network inference  the output information corresponds to an adjacency  matrix a where aij =  <dig> means there is an interaction between gene or protein pair  of an organism, otherwise aij =  <dig>  in this case, the output kernel matrix ky can potentially be chosen as the graph laplacian defined as l = diag - a, where  <dig> is the vector of all ones. it can also be formulated as a diffusion kernel  <cit>  defined by , where hyper-parameter β >  <dig>  other potential choices of ky can be found in  <cit>  for multi-labeled datasets.

RESULTS
we mainly evaluate mkldiv methods  on protein fold recognition, and then consider an extension to the problem of yeast protein function prediction. in these tasks we first compute the kernel weights by mkldiv and then feed these into a one-against-all multi-class svm to make predictions. the trade-off parameter in the multi-class svm is adjusted by 3-fold cross validation over the training dataset. for all experiments with mkldiv-dc, we choose σ = 10- <dig> and for mkldiv-conv, we tune σ = {10- <dig>  ..., 10-1} using cross validation. in both methods, we use a stopping criterion of ε = 10- <dig> and initialize the kernel weight λ by setting  for any ℓ ∈ ℕm where m is the number of candidate kernel matrices.

synthetic data
we first validated the proposed mkldiv algorithms on a simple three-class dataset illustrated in subfigure  of figure  <dig>  as in  <cit> , we use a gaussian kernel with unit variance, a polynomial kernel of order two and a linear kernel. in this case we demonstrate the effect of our approaches on combining kernel matrices derived from a single data source. subfigures  and  of figure  <dig> illustrate the kernel weights learned by mkldiv-dc and mkldiv-conv. in particular, mkldiv-dc successfully picked up the gaussian kernel as the most dominant kernel, which is more reasonable than mkldiv-conv. subfigures  and  of figure  <dig> show the relative change of objective function values versus iteration, i.e. ) - ℒ))/ℒ), of mkldiv-dc and mkldiv-conv. we can see that the dc algorithm of mkldiv-dc converges quickly to a local minimum while the projected gradient descent algorithm converges a little slower to a global minimum. however, mkldiv-dc needs more time per iteration than mkldiv-conv since mkldiv-dc needs to solve the subproblem  at each iteration. as mentioned before, the subproblem  can be solved by either semi-infinite linear programming  or a projected gradient descent  method. to see their convergence, in subfigure  of figure  <dig> we plot the relative changes of the objective function in subproblem  when  for ℓ ∈ ℕm. we can see from subfigure  that the pgd approach converges faster in the beginning but stalls at a higher precision and the silp method converges faster at higher precision.

protein fold recognition
next we evaluated mkldiv on a well-known protein fold prediction dataset  <cit> . this benchmark dataset  has  <dig> scop fold classes with  <dig> proteins for training and  <dig> for testing. this dataset was originally proposed by ding and dubchak  <cit>  and it has  <dig> samples for training and  <dig> for testing. there is less than 35% sequence identity between any two proteins in the training and test set. we follow shen and chou  <cit>  who proposed to exclude two proteins from the training and test datasets due to a lack of sequence information. we compare our mkldiv methods with kernel learning based on one-against-all multiclass svm using the simplemkl software package  <cit> , kernel learning for regularized discriminant analysis   <cit> http://www.public.asu.edu/~jye02/software/dkl/ and a probabilistic bayesian model for kernel learning   <cit> . the trade-off parameters in simplemkl and mkl-rkda were also adjusted by 3-fold cross validation on the training set.

description of the fold discriminatory data sources
as listed in table  <dig>  there are a total of  <dig> different fold discriminatory data sources available: amino acid composition , predicted secondary structure , hydrophobicity , polarity , van der waals volume , polarizability , pseaa λ =  <dig> , pseaa λ =  <dig> , pseaa λ =  <dig> , pseaa λ =  <dig> , sw with blosum <dig>  and sw with pam <dig> . the first six data sources were originally from  <cit> . four data sources using different dimensions of pseudo-amino acid composition  were introduced in  <cit>  to replace the amino-acid composition. the last two data sources used in  <cit>  are derived from a pairwise kernel  <cit>  for local sequence alignment based on smith-waterman scores.

the results of vbkc are cited from  <cit> . the results not employed there are denoted by '-'. the best result for each kernel learning method is marked in bold.

as in  <cit> , we employ linear kernels  for sw <dig> and sw <dig> and second order polynomial kernels for the other data sources. ding and dubchak  <cit>  conducted an extensive study on the use of various multi-class variants of standard svms and neural network classifiers. for these authors the best test set accuracy  was 56%, and the most informative among their six data sources  were amino-acid composition , the predicted secondary structure  and hydrophobicity . shen and chou  <cit>  introduced four additional pseaa data sources to replace the amino acid composition  and raised test performance to  <dig> %. the latter authors used an ad hoc ensemble learning approach involving a combination of multi-class k nearest neighbor classifiers individually trained on each data source. recently, test performance was greatly improved by damoulas and girolami  <cit>  using a bayesian multi-class multi-kernel algorithm. they reported a best test accuracy of 70% on a single run.

performance with individual and all data sources
we ran mkldiv-dc, mkldiv-conv, simplemkl and mkl-rkda on the overall set of  <dig> data sources, also evaluating performance on a uniformly weighted  composite kernel in addition to individual performance on each separate data source. in table  <dig> we report the test set accuracy on each individual data source. the performance of mkldiv-dc and mkldiv-conv inclusive of all data sources achieves a test set accuracy of  <dig> % and  <dig> % respectively, consistently outperforming all individual performances and the uniformly weighted composite kernel . moreover, individual performance for mkldiv-dc, simplemkl and mkl-rkda indicates that the most informative data sources are local sequence alignments  and the amino acid composition . the performance with individual data sources for mkldiv-dc, mkldiv-conv, and simplemkl are almost the same since, for a fixed kernel, they use the same one-against-all multi-class svm.

from table  <dig>  performances of mkldiv-dc and mkldiv-conv with all the available data sources achieve test set accuracies of  <dig> % and  <dig> %, both of which outperform the state-of-art performance 70% on a single run reported in  <cit>  and other kernel learning methods including simplemkl  and mkl-rkda . the performance of the uniformly weighted kernel is  <dig> % which is better than the performance  <dig> % of simplemkl. this indicates that sparse l1-regularization does not necessarily yield better performance. the kernel weights λ of mkldiv-dc, simplemkl, and mkl-rkda are shown in subfigures ,  and  of figure  <dig> which indicates that amino acid composition , predicted secondary structure , hypdrophobicity , and the last two data sources sw <dig> and sw <dig> are the most informative data sources, and the remaining data sources of h, p, v, and pseaa are less informative. as depicted in the subfigure  of figure  <dig>  mkldiv-dc and mkldiv-conv include some less informative data sources such as p, z, l <dig>  l <dig>  l <dig>  l <dig> etc., with small  kernel weights. in contrast, as shown in  and  of figure  <dig>  simplemkl and mkl-rkda completely discard these less informative data sources. however, as shown in  and  of figure  <dig>  simplemkl and mkl-rkda achieve poorer performance, less than 70%, while mkldiv-dc achieves  <dig> % and mkldiv-conv achieves  <dig> %. this suggests that mkldiv-dc provides a more reasonable balance over the entire set of data sources. this observation also suggests that achieving a sparsity among kernel weights does not necessarily guarantee good generalization performance since some available data sources may be weakly informative but may still carry some useful additional information.

performance with sequential addition of data sources
as mentioned above, the kernel weights learned by mkldiv on all the data sources can provide useful insights into the significance of informative data sources. hence, we further investigated the effect of sequentially adding data sources based on information from learned kernel weights in tables  <dig> and  <dig>  without loss of generality, we take the kernel weights learned by mkldiv-dc as an example.

the result of bayesian kernel learning model  is cited from  <cit> . the results not employed there are denoted by '-'. the term inside the parenthesis is the cpu running time . the best test set accuracy of each kernel learning method is marked in bold.

test set accuracy of sequentially adding fold discriminatory data sources  according to the ranking of kernel weights obtained by mkldiv-dc over all data sources. the results of the bayesian kernel learning method were not employed in  <cit> , hence we do not list in the table. the term inside the parenthesis is the cpu running time . the best test set accuracy of each kernel learning method is marked in bold.

we first report in table  <dig> the effect of sequentially adding the sources in the order which was used in  <cit>  and  <cit>  and mkldiv-dc and mkldiv-conv consistently outperform the competitive kernel learning methods vbkc, simplemkl, mkl-rkda and the best performing svm combination methodology stated in  <cit> . as suggested by the kernel weights of mkldiv-dc in the subfigure  of figure  <dig>  the sequence alignment based data source sw <dig> is most informative, then s, then sw <dig> and so on. hence, in table  <dig> we further report the effect of sequentially adding data sources in this rank order. as shown in table  <dig>  there is a significant improvement over sw1sw <dig> in mkldiv-dc when we sequentially add the data sources of amino acid composition  and predicted secondary structure . the performance of mkldiv-dc keeps increasing until we include cshpz, giving the best performance of  <dig> %. although according to  <cit> , the pseaa data sources are believed to contain more information than the conventional amino acid composition. the same behaviour appears for mkldiv-conv. however, the mkldiv-dc performance degenerates if we continue to add pseaa composition data sources and the same behaviour appears for mkldiv-conv. similar observations were made by  <cit>  which suggests that pseaa measurements may carry non-complementary information with the conventional amino acid compositions.

with regard to the best performance of mkldiv-dc with the feature set sw1sw2cshpz, we display the corresponding kernel weights in figure  <dig>  we can see in figure  <dig> that simplemkl and mkl-rkda almost eliminate the informative feature set hpz while mkldiv-dc and mkldiv-conv include them into the composite kernel. the sparse l1-regularization of simplemkl and mkl-rkda accounts for the sparse weights of simplemkl and mkl-rkda.

comparison of running time
to investigate the run-time efficiency of mkldiv on protein fold recognition dataset, we list their cpu time in tables  <dig> and  <dig>  the running time  is the term inside the parenthesis. the silp approach for mkl-rkda is very efficient while simplemkl takes a bit longer. the reason could be that mkl-rkda essentially used the least-square loss for multi-class classification in contrast to the one-against-all svm used in simplemkl. generally, more time is required to run the interior method for one-against-all svm than directly computing the solution of the least-square regression. the projected gradient descent method for mkldiv-conv is also slower than mkl-rkda. it is to be expected that mkldiv-conv converges faster than mkldiv-dc since the dc algorithm for mkldiv-dc is non-convex and it needs to solve the subproblem  in each iteration of cccp. nevertheless, the price we paid in running time for mkldiv-dc is worthwhile given its significantly better performance on the protein fold prediction problem.

sensitivity against parameter σ
the initial purpose of introducing σ is to avoid the singularity of the input kernel matrix or the output kernel matrix. however, in practice we found that, in the convex formulation mkldiv-conv, values of σ have a great influence on performance for protein fold recognition. hence, when we ran mkldiv-conv, we always did cross validation over the training set to select the parameter σ. to see how sensitive the test set accuracy is with respect to σ, in figure  <dig> we depicted the test set accuracy versus values of σ. in figure  <dig> we can observe that the test set accuracy of mkldiv-dc is relatively stable for small values of σ's. however, this is not the case for mkldiv-conv and generally suggests that the parameter σ has a great impact on performance of mkldiv-conv. this could be because the output kernel matrix ky = yy⊤ is of low rank  and thus adding a small matrix σin in the formulation mkldiv-conv could dramatically change the information of the output kernel matrix. in contrast, we can reasonably assume the input kernel matrices are non-singular or not of low rank and the effect of adding a small matrix σin in the formulation mkldiv-dc can be ignored.

extension of investigation to yeast protein classification
we next extend our investigation of mkldiv-dc and mkldiv-conv on a yeast membrane protein classification problem  <cit> . this binary classification task has  <dig> examples derived from the mips comprehensive yeast genome database  . there are eight kernel matrices http://noble.gs.washington.edu/proj/sdp-svm/. the first three kernels  are respectively designed to measure the similarity of protein sequences using blast, smith-waterman pairwise sequence comparison algorithms and a generalization of pairwise comparison method derived from hidden markov models. the fourth sequence-based kernel matrix  incorporates information about hydrophobicity which is known to be useful in identifying membrane proteins, computed by fast fourier transform. the fifth and sixth kernel matrices  are respectively derived from linear and diffusion kernels based on protein-protein interaction information. the seventh kernel matrix  is a gaussian kernel encoding gene expression data. finally, we added a noise kernel matrix kran generated by first generating random numbers and then using a linear kernel.

the performance of mkldiv-dc and mkldiv-conv is evaluated by  <dig> random partitions of the data into a training and test set in a proportion of 4:  <dig>  we report the receiver operating characteristic  score, which measures the overall quality of the ranking induced by the classifier, rather than the quality of a single point in that ranking. the first subfigure of figure  <dig> shows the performance with individual kernels and the performance of mkldiv-dc , mkldiv-conv , and the uniformly weighted kernel . specifically, mkldiv-dc yields a roc score of  <dig>  ±  <dig>  which is competitive with the result in  <cit> . mkldiv-conv, however, achieved a roc score of  <dig>  ±  <dig>  which is worse than mkldiv-dc. the performance of mkldiv-dc is also slightly better than the performance of the uniformly weighted kernel  <dig>  ±  <dig>  excluding the noise kernel and  <dig>  ±  <dig>  including the noise kernel. we also plot the kernel weights on  and  of figure  <dig>  as expected, in mkldiv-dc the blast kernel  derived from the protein sequence similarity comparison is very informative which is consistent with  <cit> . the derived kernel weights also show that the interaction-based diffusion kernel is more informative than the expression kernel, which is consistent with  <cit> . also, it is interesting to note that mkldiv-dc shows that the noise kernel  is least informative. this is indicated by its individual roc score: a roc score around  <dig>  corresponds to random ranking. the kernel weights of mkldiv-conv indicate that the diffusion kernel  is the most important data source, and also suggest that pfam and fft are almost non-informative regardless of their good individual performances. for the kernel weights, mkldiv-dc is more reasonable than mkldiv-conv since mkldiv-dc is more consistent with the individual data source's performance and mkldiv-dc outperforms mkldiv-conv using all data sources.

CONCLUSIONS
in this paper we developed a novel information-theoretic approach to learning a linear combination of kernel matrices based on the kl-divergence  <cit> , especially focused on the protein fold recognition problem. based on the different position of the input kernel matrix and the output kernel matrix in the kl-divergence objective, there are two formulations. the first one is a difference of convex  problem termed mkldiv-dc and the second formulation is a convex formulation called mkldiv-conv. the sparse formulation for kernel learning based on discriminant analysis  <cit>  was also established. our proposed methods are able to achieve state-of-the-art performance on the scop pdb-40d benchmark dataset for protein fold recognition problem. in particular, mkldiv-dc further improves the fold discrimination accuracy to  <dig> % which is a more than 5% improvement over a competitive bayesian probabilistic approach  <cit> , svm margin-based kernel learning methods  <cit> , and the kernel learning based on discriminant analysis  <cit> . we further extended the investigation to the problem of yeast protein function prediction.

generally, it is difficult to determine which criterion is better for multiple kernel combination since this problem is highly data-dependent. for the information-theoretic approaches mkldiv-dc and mkldiv-conv, although mkldiv-dc is not convex and its dc algorithm tends to find a local minima, in practice we would recommend mkldiv-dc for the following reasons. firstly, as mentioned above mkldiv-dc has a close relation with the kernel matrix completion problem using information geometry  <cit>  and the maximization of the log likelihood of gaussian process regression  <cit> , which partly explains the success of mkldiv-dc. secondly, we empirically observed that mkldiv-dc outperforms mkldiv-conv in protein fold recognition and yeast protein function prediction. finally, as we showed in figure  <dig>  the performance of mkldiv-conv is quite sensitive to the parameter σ and the choice of σ remains a challenging problem. mkldiv-dc is relatively stable with respect to small values of σ and we can fix σ to be a very small number e.g. σ = 10- <dig>  in future, we are planning to empirically compare performance with other existing kernel integration formulations on various datasets, and discuss convergence properties of the dc algorithm for mkldiv-dc based on the theoretical results of  <cit> .

authors' contributions
yy and cc conceived the project. yy proposed and implemented the method, drafted the manuscript. kh joined the project and participated in the design of the study. all authors read and improved the manuscript.

appendix
appendix  <dig> – column generation method for silp
here we briefly describe the column generation method  for silp  to solve the subproblem , i.e.   

where , and s <dig> = -2tr. the basic idea is to compute the optimum  by linear programming for a restricted subset of constraints, and update the constraint subset based on the obtained suboptimal . more precisely, given restricted constraints {αp : p =  <dig>  ..., p}, first we find the intermediate solution  by the following linear programming optimization with p linear constraints   

this problem is often called the restricted master problem. then, we find the next constraint with the maximum violation for the given intermediate solution , i.e.   

if the optimizer α * of the above equation satisfies  then the current intermediate solution  is optimal for the optimization . otherwise α* should be added to the restriction set. we repeat the above iteration until convergence which is guaranteed to be globally optimal, see e.g.  <cit> . in a similar fashion to the convergence criterion in  <cit> , the algorithm stops when  

for instance, the threshold ε is usually chosen to be  <dig> × 10- <dig> 

appendix  <dig> – sparse formulation of kernel learning based on discriminant analysis
in this appendix we show that kernel learning for regularized discriminant analysis  <cit>  is closely related to sparse regularization. to see this, consider the following algorithm  

using the fact  <cit>  that min , the above equation is identical to   

the equivalence between the above algorithm and rkda kernel learning becomes clear if we formulate its dual problem as follows:

theorem  <dig> let , in be the identity matrix and 1n be an n-dimensional column vector of all ones. define , and for any i ∈ ℕn. then, the dual problem of algorithm  can be written as  

where .

proof: taking the minimization of b first, algorithm  yields . then, algorithm  can be further rewritten as   

here, for any ℓ and i,  which can be further represented by . then, letting  for any i and solving the standard lagrangian formulation of  with lagrangian variables α yields  

now, replacing αi by μαi and letting  completes the argument. □

let n- and n+ denote the number of samples in class + <dig> and - <dig>  if we redefine the class indicator output y, for any i ∈ ℕn by yi =  if xi is in class + <dig> otherwise -, then the class indicator output  reduces to the vector a defined in  <cit>  for binary classification, i.e.  

now we turn our attention to multiclass classification. to this end, consider  

using the above argument for binary classification it is easy to check its dual problem is as follows   

where . let nc denote the number of samples in class c. if we redefine the class indicator matrix y, for any i ∈ ℕn and c ∈ ℕc by  if yi = c, otherwise , then the class indicator matrix  reduces to the matrix h defined in  <cit>  for multi-class classification, i.e.  

now we can see that the dual problem of algorithm  is exactly the same as the formulation  in  <cit> ) of rkda kernel learning.

