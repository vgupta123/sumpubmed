BACKGROUND
protein structure prediction is a difficult problem for several reasons. the forces that determine structure are not fully understood, at least quantitatively  <cit> . while there is a good qualitative understanding of these forces, there is still no accurate way to calculate the free energy gained by the burial of hydrophobic atoms away from solvent. nor can we accurately model the highly variable dielectric constant in the interior of a protein. in addition, to correctly predict the conformation of a protein we must first represent it in a computer, and any computational representation of that protein must significantly simplify its components and their interactions. any change to one part of a protein we are trying to model may affect many other parts of that model.

the first descriptions of protein structure at atomic detail were given by pauling, corey and branson in  <dig>  <cit> . only secondary structures were described, however, and not all of them have been observed in nature. nevertheless, it was an extraordinary achievement. the first three-dimensional protein fold described was the structure of myoglobin, solved by kendrew, et al., in  <dig>  <cit> .

difficulties using these descriptions to predict protein structure soon became apparent. in the late 1960s, it was noted that the number of possible conformations of a typical polypeptide chain is so large that it must have a pathway in the course of protein folding, the so-called "levinthal paradox  <cit> ."

protein structure can be viewed in a hierarchical manner, where oligomers are made up of polypeptide chains, which are made up of amino acids, which are made up of atoms. it may be considered conceptually to be determined hierarchically as well, with primary structure  determining secondary and tertiary structure. since each possible main chain conformation can have an astronomically large number of possible combinations of amino acid side chain arrangements, one approach to tackle the problem in a hierarchical way is by modeling a manageable number of the most likely main chain conformations before addressing the problem of amino acid side chains. in the initial stages, coarse-grained functions using highly simplified representations of amino acids are employed to quickly evaluate a large number of proposed main chain conformations  <cit> . only a small fraction of these structures are selected for more detailed assessment. if the low-resolution functions used to select that small fraction are unable to discriminate near-native main chains from incorrect ones, then a successful prediction is effectively impossible using this approach.

it is therefore necessary to sample all possible main chain conformations in such a way as to ensure that near-native structures will be among those evaluated. as a practical consideration, it is also important to model the smallest number of main chain conformations needed to ensure that conformations good enough to be considered successful predictions  are among those sampled. just as important, one must be able to evaluate the sampled conformations in reasonable computing time.

in this work, we address the problem of rapid and accurate evaluation of sampled conformations. to do this we use sets of "decoys"--non- and near-native conformations of a given protein sequence that have been proposed in the course of protein structure prediction or generated by making alterations to a native structure. the goal is to be able to discriminate the native and near-native conformations from the non-native ones. further, we focus on the problem of quickly and accurately assessing proposed main chain conformations, ignoring side chains.

types of functions
there are two categories of functions that are applied to protein structures to evaluate their likelihood of being correct: physics-based functions  <cit>  and knowledge-based functions  <cit> . physics-based functions attempt to model the actual physics that determine the behavior of proteins. knowledge-based functions are derived from statistical profiles taken from sets of known protein structures. to create these profiles, some representation of a protein or its constituent parts is chosen, then the known structures in the set are categorized according to the chosen representation. functions derived from this profile allow any protein conformation to be evaluated according to how closely it corresponds to the profile.

when examining main chains only, no individual amino acid can be considered to be in any particular side chain conformation. since this undetermined state does not correspond to any physical entity, knowledge-based functions must be used to evaluate it. these functions take a number of forms. one common approach is to measure the separations between all pairs of residues and apply the function to all of them that fall below a given cutoff distance  <cit> . these separations are typically between cα atoms, cβ atoms or presumed centers of mass for each residue. these so-called "contact" potentials depend on the identities of both residues. they typically make use of a pairwise matrix of interaction values that may or may not be adjusted for the distance between residues.

since the early development of coarse-grained contact potentials, progress has been steady. while the interaction representations have remained similar, the discrimination power of the matrices has been improved. some innovations have included quasi-chemical treatments  <cit> , hydrophobic energies  <cit>  and more sophisticated statistical treatments  <cit> . still, even developers of these potentials have acknowledged their insufficiency for protein structure prediction by themselves  <cit> . more recent work has demonstrated further difficulties with statistical potentials based on preferential interactions  <cit> .

amino acid interaction potentials have begun to include the relative orientations of pairs of residues as well. buchete, straub and thirumalai calculated a five-dimensional potential with a local coordinate system generated around the main chain cα and side chain cβ and cγ atoms  <cit> . mukherjeee, bhimalapuram and bagchi developed their potential around a single ellipsoidal representation of the side chain  <cit> . makino and itoh achieved excellent discrimination of native structures from decoys with a six-term orientation-dependent potential  <cit> . rykunov and fiser made use of a "shuffled reference state" to improve the performance of their orientation-dependent potential  <cit> .

we continue this trend of using additional geometric information in the consideration of residue-residue interactions and present a new coarse-grained function for evaluating protein main chain conformations by scoring interactions between amino acids within a single polypeptide chain, using only the positions of main chain n, cα and c atoms. all pairwise residue-residue interactions are actually considered to be two interactions: one from the perspective of each residue. all other residues within a specified cutoff distance are considered to be potential interaction partners, although we do exclude from scoring some number of immediate neighbors in the chain. we use a large pre-calculated database of interaction potentials for quick scoring.

scoring is carried out by locating all interaction partners for any given residue within a local cartesian coordinate system defined by that residue's main chain n, cα and c atoms. this local coordinate system is divided into cubic 1Å bins, and every interaction partner is assigned to a bin. the score for any interaction is based on the likelihood of observing a particular residue at those locally-defined coordinates, given the type of the residue for which the coordinate system is constructed and the type of the interaction partner observed. this scoring function we have named loco . it yields state of the art performance with a speed and simplicity that is unmatched by any other function at its level.

methods
overview
the fundamental idea behind loco scoring is that characteristic shapes of amino acids lead to characteristic geometric relationships between interacting residues in a native structure. the interior of a properly folded protein is tightly packed. main chain atoms typically form a rigid planar structure between cα atoms, and steric considerations generally confine the side chain atom positions into one of a number of rotamers. these restrictions on the overall shapes that amino acids generally indicate that there are a limited number of ways they will typically fit well together, both spatially and energetically.

the relationships we exploit are relative positions in three-dimensional space. most coarse-grained potentials have relied simply on distances between cα atoms, cβ atoms or centers of mass  <cit> . by using additional dimensions to characterize residue-residue interactions, our method is more specific about which interactions are favorable and which are not. since it has more dimensions, it requires a considerably larger and more detailed set of parameter tables than have generally been used, which is not a limitation it once was due to ever-increasing storage and memory.

loco methodology
loco scoring takes place within a local coordinate system defined by the main chain n, cα and c atoms of the residue being scored  for any given amino acid. the cα is at the origin of this coordinate system. the n coordinates define the y-axis, and position of the main chain c atom defines the x- and z-axes. a different coordinate system is generated for each residue. we refer to the amino acid at the origin as the "observing" residue and all nearby residues eligible to interact with the observing residue as "partner" residues.

to score an interaction using loco, the cα atom of each partner residue is located within a particular 1Å cubic bin of the coordinate system of the observing residue . the partner residue is then assigned a score based on the likelihood of its being observed in that bin, given the types of both residues. the total score for any given observing residue is the sum of all the scores for its partners, and the score for the protein is the sum of all residue scores when every residue has been treated as an observing residue.

the individual interaction scores are derived from statistics that have been obtained from a large set of non-homologous protein domains. here is the formula:

 s = ∑i=1n1∑j=1n2 - lnjobsjexp 

where s is the total score for all pairwise residue-residue interactions, and i and j are the observing and interacting residues, respectively. this is equivalent to the boltzmann equation  <cit> , where the quantity jobs is the number of times a residue of type i has observed a residue of type j in the training set at bin coordinates x, y and z in its local coordinate system. the reference state, jexp is the number of times a residue of type j would be expected to be observed at those coordinates. n <dig> represents all amino acids in the polypeptide chain; n <dig> represents only those residues that are eligible to be interaction partners for i.

we define the reference state jexp to be the mean number of observations of all residue types at bin coordinates xyz, which is the total number of observations at those coordinates for any residue types i and j divided by the total number of possible ij combinations, totaling  <dig> . this mean includes zero-count cases. since we cannot take the logarithm of zero, bins with no observed counts are assigned a penalty equal to a some multiple of the worst-scoring bin for any observed ij interaction.

the value of this zero-count penalty affects the accuracy of scoring, as do eligibility criteria for partner residues. varying the cutoff distance for eligible partners affects performance. since the cα- cα separations across peptide bonds are effectively fixed and the number of well-populated Φ and Ψ angles fairly restricted, we did not score immediate sequence neighbors of the observing residue.

the values of these three parameters--the interaction cutoff distance, the number of neighboring residues to exclude from scoring and the size of the zero-count penalty--were chosen using a training group of decoy structures before the final version was evaluated on an independent group of decoy sets.

function training
training of the loco function took place in two separate stages: generation of the scoring database and optimization of its parameters. each database was generated by assigning a probability-based score to every possible state of the system using a large set of known protein structures that are held to be representative of correct structures. we presume that this set, although not complete, captures enough information about residue-residue interactions to be of predictive value. parameter optimization involved finding the version of the function with the best-performing set of values  for the three interaction parameters described above.

all observed counts for the generation of all versions of the loco scoring databases were taken from the astral  <dig>  set  <cit>  of  <dig> non-homologous protein domains. as noted above, we also used a "training group" of  <dig> decoy sets to find an optimal set of function parameters. all structures in both the training group and the testing group that were part of the astral set were removed before the potentials used to score each group were generated.

when optimizing our function parameters, we followed a process of tenfold cross-validation to ensure that even within the training group no function was evaluated on a group of decoy sets that had been used to select it. interatomic cutoff distances of 8Å -20Å were tested in 2Å increments. from  <dig> to  <dig> chain neighbors on both the n- and c-terminal sides of the observing residue were not scored. we established a baseline zero-count penalty equal to the worst score calculated for each pair of residue types, then tested penalties equal to  <dig>   <dig> or  <dig> times the baseline. this gave us a total of  <dig> different versions of the loco scoring function.

the training group was divided into ten randomly selected subsets--six containing  <dig> decoy sets and four containing  <dig>  ten different groupings of nine of these subsets were scored using all  <dig> versions of the loco function, and the average cα rmsd between the native and the best-scoring non-native structure was calculated for each version. the version of loco with the lowest average cα rmsd across all nine subsets was used to score the remaining subset. the loco version selected was the one with the lowest overall average cα rmsd among all ten remaining subsets.

this tenfold cross-validation procedure was carried out ten separate times to ensure that the outcome was not dependent on a particular random selection of the subsets. in every case the best performance was achieved with a cutoff distance of 14Å, with only a single residue on either side of each residue excluded from scoring and with a zero-count penalty equal to  <dig> times the worst observed score for each particular combination of amino acid types. this version of the loco scoring database was used for our final performance testing.

decoy sets for evaluation of scoring functions
the purpose of protein main chain scoring functions is to discriminate near-native from non-native conformations. "decoy" structures representing a mix of near- and non-native conformations for a particular amino acid sequence, commonly generated in the course of protein structure prediction, are often used to evaluate them. such sets typically include the native structure.

we decided to follow the model of makino and itoh  <cit> , to optimize parameters before we could test the scoring performance of loco. we used the same  <dig> decoy sets from the "decoys r us" database http://dd.compbio.washington.edu/ <cit> , the 62-protein "rosetta" set from david baker's group http://depts.washington.edu/bakerpg/decoys/rosetta_decoys_62proteins.tgz, and the "moulder" set ftp://salilab.org/decoys/ <cit>  from andrej sali's group. these are among the most widely used decoy sets in the field. we divided these  <dig> decoy sets into the same two groups, a  <dig> set group for function optimization  and a  <dig> set group for performance evaluation .

since we are pursuing main chain structure discrimination only, all side chain atoms except cβs were removed from the decoys. although cβ atoms are not part of the main chain, their positions do not change  as side chain conformations do, so they can be included in an initial search for main chain conformations. cβ atoms are not used in loco scoring, but are used by some of the other functions in our comparisons.

function comparisons
performance of the loco potential was tested against a total of  <dig> other published functions for main chain evaluation. twenty-six of these functions are from the jernigan lab's knowledge-based potential server: http://gor.bb.iastate.edu/potential/, representing some of the widely used contact potentials of the last  <dig> years. also among the  <dig> are  <dig> more recently-developed functions from the jernigan group--the four-body and general-four-body  <cit> , and the short-range  <cit> --that are not simple contact potentials.

the remaining  <dig> contact potentials are identified here with the same codes used on the jernigan server: qa, qm, qp  <cit> , hlpl, mjpl  <cit> , skoa, skob, sjkg  <cit> , mj <dig>  mj2h, mj <dig>  mj3h  <cit> , ts  <cit> , bt  <cit> , bfkv  <cit> , td  <cit> , tel, tes  <cit> , ro  <cit> , ms  <cit> , gks  <cit> , vd  <cit> , bl  <cit> , and msbm  <cit> .

three more modern potentials are considered as well. the program prosa  <dig> is from the group of manfred sippl  <cit>  and is available from the center of applied molecular engineering: http://www.came.sbg.ac.at/. two recently developed functions that explicitly take the relative orientations of interacting residues into account are dfmac, by makino and itoh  <cit> , and rf_cb_srs_od, by rykunov and fiser  <cit> . executables of both are available from their authors.

the functions from the jernigan group server encompass a wide variety of approaches: the oldest  was published in  <dig>  and the newest  in  <dig>  some are simple contact potentials that assign a score to all pairs or residues found within a given cutoff distance of one another. other functions in the set assign distance-dependent scores to pairs within the cutoff distance. not all functions are purely knowledge-based: several use techniques such as quasi-chemical approximation or attempt to calculate hydrophobic energies. some of the publications represented note the insufficiency of contact potentials alone for protein structure prediction.

prosa  <dig> generates three scores for every residue: a pair score, a surface score and a combined score. scores used for comparison are the sum of all individual residue combined scores, which outperformed both the individual pair and surface terms. the potentials used were the "prosa <dig> pair-cb" and "prosa <dig> surf-cb" included with the distribution.

the dfmac function is a linear combination of six separate weighted pseudo-energy potentials involving pairwise cα separations, relative orientations of pseudo cα→ cβ vectors, main chain-to-main chain pseudo-hydrogen bonding, Φ/Ψ angle pairings between residues, individual residue ω angles, and the number of other cα atoms surrounding each cα atom. these six potentials have sixteen independent parameters that were "tuned" on the same group of  <dig> decoy sets that we used for our parameter training. once the most favorable set of those sixteen parameters was selected for that training group, the weights of all six components of the function were similarly optimized before the function was tested on the same  <dig> decoy set testing group we have used here.

the rf_cb_srs_od function groups residue-residue interactions into three categories: residues facing in the same direction, residue facing toward each other and residues facing away from each other. "facing" in this context refers to the direction of each amino acid's cα→ cβ vector. a "shuffled" reference state is created by randomizing the sequence position of all residues in the protein.

performance measures
we use five performance measures for native structure recognition: ranknat, rmsdbest, znat, ccnat and fenat. eight measures--rb <dig>  rb <dig>  rmsddecoy, zdecoy, ccdecoy, fedecoy, log and log--are used for decoy discrimination. ranknat is the score rank of the native structure among all decoys. rmsdbest is the cα rmsd of the best-scoring structure, including the native. znat is the z-score of the score of the native structure relative to all other scores  in that decoy set. ccnat is the pearson's correlation coefficient between score and cα rmsd for all structures in the set, including the native. fenat is the fraction enrichment among all decoys  after scoring. the fraction enrichment is defined as the fraction of the top 10% of our structures by cα rmsd that are found among the top 10% by score. we express the fraction enrichment as a percentage for clarity.

rb <dig> is the cα rmsd ranking among decoys only  of our best-scoring structure. rb <dig> is the lowest cα rmsd rank among the  <dig> best-scoring structures from the decoy set . rmsddecoy is the cα rmsd of the best-scoring structure, excluding the native. zdecoy is the z-score of the score of the lowest-rmsd decoy relative to all other scores  in that decoy set. ccdecoy is the correlation coefficient between score and cα rmsd for all structures in the set, excluding the native. fedecoy is the fraction enrichment among all decoys  after scoring. the measures log and log are the common logarithms of the probabilities of selecting the rb <dig> and rb <dig> structures. these probabilities are simply the values of rb <dig> and rb <dig> divided by the total number of decoy structures in the set .

RESULTS
native recognition vs. decoy discrimination
the performance measures we use fall into two categories: native recognition and decoy discrimination. native recognition is the ability to recognize the native structure from among all decoys in the set. decoy discrimination is the ability to pick out one or more near-native structures within the set. a good scoring function should be able to pick out the native, at a minimum. however, the likelihood of reproducing a completely correct structure in the course of sampling different conformations is quite low. for practical use, a good scoring function must be able to distinguish near-natives from non-native structures.

training and testing group comparison
we used separate groups of decoy sets for optimizing the variable parameters of loco and for testing its performance against other functions. a comparison of loco scores achieved with training and testing groups is in tables  <dig> and  <dig>  table  <dig> shows the differences between these groups in native structure recognition. table  <dig> shows these differences for decoy discrimination. roughly comparable results were achieved with both groups, though the test group did yield somewhat better results across the board.

comparison of loco performance for native structure recognition on both the training and testing groups of decoy sets is shown. results are roughly comparable, though the testing group did somewhat better across the board. natives, rmsd < 2Å and rmsd < 5Å refer to the number of times the best-scoring structure in a particular group is either the native structure  or within 2Å or 5Å cα rmsd from the native structure, respectively. all other measures are averages over every decoy set in the group. definitions of measures used are provided in the performance measures subsection at the end of methods. in summary, lower scores are better for ranknat and rmsdbest; higher scores are better for all the other measures..

comparison of loco performance for decoy discrimination on both the training and testing groups of decoy sets is shown. again, results are roughly comparable, though the testing group did somewhat better overall. all measures are averages over every decoy set in the group. definitions of measures used are provided in the performance measures subsection at the end of methods. in summary, lower scores are better for rb <dig>  rb <dig>  rmsddecoy, log and log; higher scores are better for zdecoy, ccdecoy and fedecoy.

we consider decoys that are less than 5Å cα rmsd from the native to be "near native" structures and decoys that are less than 2Å to be "very near native." we include the numbers of near native and very near native structures found with our "native recognition" measure in table  <dig>  for the training group, the best-scoring structure in each set was very near native for  <dig> of  <dig> decoy sets  and near native for  <dig> sets . for the test group, the best-scoring structures were very near native in  <dig> of  <dig> cases  and near native for  <dig> of  <dig> sets . the average cα rmsd  of the best-scoring structures from all of the training group was  <dig> Å. for the test group it was  <dig> Å, a difference of less than  <dig> Å. all performance measures, with the exception of numbers of near native and very near native structures, are explained in performance measures at the end of methods.

differences between training and testing groups were smaller for decoy discrimination. the difference between the average cα rmsd  for the best-scoring non-native structure was less than  <dig> Å between the groups. it is perhaps not surprising that these measures were so close, since that was the metric for which the training group was optimized. again, test group measures were somewhat better but not largely so, with the exception of rb <dig>  indicating that loco was significantly more able to place one of the ten nearest-native structures among its ten top-scoring decoys.

main chain function performance
native recognition performance is demonstrated in table  <dig>  the performance of the top four functions, loco, dfmac, rf_cb_srs_od and prosa  <dig>  is superior to that of the remaining potentials. loco outperforms every function except dfmac. however, the relatively larger differences between loco and dfmac in ranknat and znat may partly be due to the inclusion of an ω-angle component in dfmac, which is of limited practical utility .

native structure recognition performance comparison among scoring functions. all reported measures are averages over the  <dig> decoy sets in the final testing group. lower scores are better for ranknat and rmsdbest. higher ones are better for znat, ccnat and fenat. loco outperforms all other functions except dfmac in every measure. all metrics are defined in performance measures at the end of methods.

decoy discrimination is shown in table  <dig>  again, loco and dfmac were the top two functions in most measures. loco had the best rb <dig>  rmsddecoy and log. it was slightly lower than dfmac in zdecoy, ccdecoy and fedecoy, and it was slightly higher than prosa  <dig> in log.

comparison of decoy discrimination performance among all tested functions is shown. all reported measures are averages over the  <dig> decoy sets in the final testing group. lower scores are better for rb <dig>  rb <dig>  rmsddecoy, log and log. higher scores are better for zdecoy, ccdecoy and fedecoy. loco outperforms all other functions in rb <dig>  rmsddecoy, and log. it is slightly higher than prosa  <dig> in log and slightly lower than prosa  <dig> in fedecoy. zdecoy, ccdecoy and fedecoy for loco are all slightly lower than for dfmac. loco outperforms the remaining  <dig> functions in every measure except rb <dig>  all metrics are defined in performance measures at the end of methods.

all-atom function comparison
to get a sense of how our main chain-only function compares to available all-atom functions, we tested four widely-used potentials that work with all heavy atom coordinates on the same final testing group of decoys we have used throughout. the potentials chosen were rapdf  <cit> , ddfire  <cit> , dope  <cit>  and rf_ha_srs  <cit> . these functions require that all side chain atoms be included and their positions determined in every structure to be scored.

loco performance compared to these four potentials for native structure recognition is shown in table  <dig>  while performance for decoy discrimination is shown in table  <dig>  the performance of loco was quite comparable to these higher-resolution functions. loco outperformed all four in ranknat, rb <dig> and log. it placed no worse than third  in every performance metric except rb <dig> 

loco native recognition performance is compared to that of four widely-used all-atom potentials. all reported measures are averages over the  <dig> decoy sets in the final testing group. loco performance is comparable to the others, placing 1st, 2nd, 3rd, 3rd and 3rd in ranknat, rmsdbest, znat, ccnat and fenat, respectively. taking the sum of all rankings among these five potentials, loco places 3rd overall. all metrics are defined in performance measures at the end of methods.

decoy discrimination performance for loco is compared to that of four widely-used all-atom potentials. all reported measures are averages over the  <dig> decoy sets in the final testing group. loco outperforms all others at rb <dig> and log. loco is beaten by all four at rb <dig>  loco places 2nd among all potentials at rmsddecoy, zdecoy and ccdecoy. it places 3rd in fedecoy and log. when the sum of all rankings among these five potentials is considered, loco places 2nd overall. all metrics are defined in performance measures at the end of methods.

speed
loco is extremely fast, particularly compared to other functions that are based on explicit distance calculations and table lookups. scoring for loco was carried out on an apple imac with a  <dig>  ghz intel core  <dig> duo processor with  <dig> gb of memory. the function was written in c++ and compiled using gnu g++  <dig> .

the average total processing time for a single structure in the final testing group was  <dig>  milliseconds. this time includes reading the structure from the hard disk drive, loading it into the program, determining all relevant interactions, scoring the structure and clearing it from memory. the average time for interaction determination and scoring only was  <dig>  ms. the numbers of residues per structure in the final testing group varied from  <dig> to  <dig>  so the standard deviations for total processing time and interaction determination and scoring time were relatively large:  <dig>  ms  and  <dig>  ms , respectively.

on a "per residue" basis the times were more consistent. the average total processing time per residue was  <dig>  ms with a standard deviation of  <dig>  ms . the average interaction determination and scoring time per residue was  <dig>  ms with a standard deviation of  <dig>  ms .

the time taken by loco to score the entire final testing set of  <dig>  structures, including reading the scoring databases, input structures, and writing the output score files is ~ <dig> minutes. we were unable to determine the amount of time needed by dfmac or any of the server functions to score the entire final testing group, but prosa  <dig> takes ~ <dig> minutes and rf_cb_srs_od takes  <dig> minutes.

in contrast an all atom scoring function, rapdf  <cit> , pioneered by our group takes several seconds on average to score a structure from scratch as described above, and about one second for interaction determination and scoring only. the backbone only version of this function is about ten fold faster but still takes about  <dig> ms per structure. thus a very rough comparison indicates that loco is approximately two orders of magnitude faster compared to traditional distance bin based potentials of mean force.

statistical significance
to assess the statistical significance of differences between potentials in the distribution of ranks, we performed pairwise one-tailed wilcoxon tests on all tested functions. we used rb <dig>  the cα rmsd rank  of the best-scoring decoy structure as our tested distribution. we felt that this was the closest suitable metric to rmsddecoy, the one on which the loco potential was parameterized. we also believe that it best encompasses our primary goal of picking out the nearest native decoy structures. results of this test are in figure  <dig> 

our null hypothesis was that neither function performed better in the the distributions of these ranks, and our alternative hypothesis was that the function in the leftmost column of figure  <dig> had a distribution of ranks that were lower than that of the function in the column across the top, showing that the functions in the left column performed better. the wilcoxon test was used because the rank distributions being compared are far from normal.

the large number of red values in the top four rows  show that loco, dfmac, rf_cb_srs_od and prosa  <dig> have statistically significant differences in rank distribution from most of the other  <dig> functions, based on the hypothesis that their distributions are lower. these p-values represent the likelihood that the better rankings for the functions on the left could have come about by chance. the ranks for loco were better than all other functions, since all p-values were <  <dig> . however, these rank distributions vs. dfmac, rf_cb_srs_od and prosa  <dig> were not below the statistical significance threshold of  <dig> .

discussion
relative importance of performance measures
the primary goal of a main chain-only scoring function is to identify proposed main chain conformations that are reasonably likely to be close enough to the native structure to be kept for more detailed evaluation. a large number of possible main chains are typically tried, and the likelihood that any of them will be exactly the same as the native is very small. for this reason, we believe that good performance in decoy discrimination is more important than good performance in native structure recognition.

we also consider rb <dig>  rb <dig>  rmsddecoy, log and log to be more important to the goal of selecting a relatively small number of near native decoys than zdecoy, ccdecoy and fedecoy. rb <dig> and rb <dig> inform whether or not the very best-scoring decoys are among the very closest to the native. rmsddecoy tells how close to correct the best-scoring decoy is. log and log gives us measures of how meaningful the rb <dig> and rb <dig> values are.

other metrics, while still valuable, are less directly related to the goal of finding near native structures. zdecoy measures how far from the mean score our best decoy is, but what matters most is whether we can identify it. ccdecoy reveals the correspondence between score and rmsd across the entire set, but this correspondence is of little importance for poor decoys that will be rejected. fedecoy assesses performance with the top 10% of decoys, but at the initial main chain evaluation stage, we are likely to be keeping far fewer than 10% of the main chain conformations we examine.

loco vs. dfmac
loco outperformed all other functions in rb <dig>  rmsddecoy, and log, three of the five measures most important for finding near native decoys. it was only slightly higher than prosa  <dig> at log. its rb <dig> was higher than many of the other functions, but since any initial main chain search will keep more than one structure for further evaluation, loco's lowest rb <dig> should be considered more relevant. at native structure recognition, loco's performance was just behind that of dfmac in all categories, although it was still substantially better than the remaining  <dig> functions.

while we consider the performance of loco and dfmac to be roughly comparable, we believe that loco has clear practical advantages over dfmac. dfmac is a weighted composite of six separate functions that require the creation of pseudo-n, -o, -h and - cβ atoms for every residue as well as the calculation of at least five angles between vectors for every residue-residue interaction and three dihedral angles for every residue. these angle calculations are computationally expensive and must be repeated for every new main chain conformation.

loco, on the other hand, was designed to be extremely fast. every residue-residue interaction requires only a single lookup from the potential database. the initial cα→ cα vector between any two residues being scored undergoes a single matrix rotation into the local coordinate system of the observing residue, where it is then binned and the score for the interaction is looked up. the initial generation of the rotation matrix that defines the local coordinate system does require several computationally expensive square root and trigonometric operations per residue, but all translations and rotations of the main chain after that require only simple arithmetic floating-point operations, including rotating the coordinate system.

dfmac was also finely tuned to its training set, with sixteen independent parameters and five weights optimized to give the best possible performance. these training procedures were carried out with rigor to ensure that no structure was scored using parameters that had been trained on it, but all decoy sets used for training had been generated using the same methods employed to create the decoy sets in the testing group.  <dig> of the  <dig> decoy sets in the final testing group had as their native structures proteins that appeared in the training group as part of decoy sets generated by alternate methods. in  <dig> of those  <dig> sets the native was correctly identified by dfmac. it is unclear to us that the values of those parameters and weights used by dfmac will be optimal for the prediction of protein structures more generally.

loco, on the other hand, is largely insensitive to changes in its parameters. we compared the best, worst and average values for each individual performance measure across all  <dig> loco parameter sets with the performance of dfmac, prosa  <dig>  and rf_cb_srs_od. we also compared them with the best, worst and average values for all  <dig> functions from the jernigan lab server.

tables  <dig> and  <dig> indicate that the differences in performance between loco parameter sets were not large. for native recognition , the average value for loco across all  <dig> parameter sets in any of the five performance measures were still better than for any potential other than dfmac. the worst loco value was better than the best value for any of the jernigan server potentials in  <dig> out of  <dig> cases, and the worst loco ccnat of  <dig>  was only  <dig>  lower than the best jernigan server ccnat of  <dig> .

best, worst and average performance for loco across all  <dig> parameter sets tested is compared with the chosen loco parameter set, the three best-performing of the other potentials, and the best, worst and average performance of all  <dig> remaining potentials from the jernigan lab server. all best, worst, and average values are for each individual performance measure; no single set contained all those values. all reported measures are averages over the  <dig> decoy sets in the final testing group. all metrics are defined in performance measures at the end of methods. in summary, lower scores are better for ranknat and rmsdbest. higher ones are better for znat, ccnat and fenat. the average performance across all  <dig> versions of loco surpassed that every other function except dfmac. even at its worst, performance for loco exceeded that of all jernigan server functions for every measure except ccnat.

best, worst and average performance for loco across all  <dig> parameter sets tested is compared with the chosen loco parameter set, the three best-performing of the other potentials, and the best, worst and average performance of all  <dig> remaining potentials from the jernigan lab server. all best, worst, and average values are for each individual performance measure; no single set contained all those values. all reported measures are averages over the  <dig> decoy sets in the final testing group. lower scores are better for rb <dig>  rb <dig>  rmsddecoy, log and log. higher scores are better for zdecoy, ccdecoy and fedecoy. the average performance for loco among all  <dig> parameter sets exceeds all other functions except dfmac in rmsddecoy and log. the loco average betters all other functions except dfmac and prosa  <dig> in log. all metrics are defined in performance measures at the end of methods.

for decoy discrimination , the best value for loco across all parameter sets was better than any other function for all performance measures, with the exception of zdecoy and ccdecoy for dfmac. the average value for loco across all sets was better than the best values from the jernigan server potentials for  <dig> out of  <dig> measures. it was also better than rf_cb_srs_od for  <dig> of  <dig> measures, with a slightly worse zdecoy.

omega angles
the dfmac function includes an ω angle term. the ω is the main chain dihedral angle between the cα→c vector of one residue and the cα→n vector of the following residue. in an experimentally determined structure these angles are typically clustered around 180° because of the partially double-bonded character of most cα→c→n→ cα groups. there are usually a few places within any main chain where the planarity of this system is broken to make energetically favorable interactions elsewhere, but the great majority of native ω angles are within 15° to either side of a planar 180° separation.

it is unlikely that any initial main chain conformational search would include variations of the ω angle, since that would introduce unnecessary degrees of freedom to achieve only slight differences in the overall structure. an ω angle function can, however, be quite effective at distinguishing native main chain geometry from that of computer-generated decoys. this is because these variations are often more characteristic of the method used to generate the decoys than of structural correctness.

to demonstrate this point, we created a very simple ω angle discrimination function. it calculates the standard deviation of all individual ω angles for any main chain that are within 15° of 180° apart. the score for each main chain is the magnitude of the difference  between its own standard deviation and the mean of all the standard deviations in the decoy set.

for purposes of illustration only, we have included this function in tables  <dig> and  <dig> and have compared it to the performance of loco and of dfmac both with and without the ω angle score component. for native recognition , our ω-only function is able to recognize native structures  very nearly as well as dfmac without an ω angle component. the znat of the ω-only function is more than twice as great as either version of dfmac. its rmsdbest is better than every function tested except loco, dfmac and prosa  <dig>  and it is within  <dig> Å of prosa  <dig> 

native recognition performance comparison among loco, our ω-only function and dfmac both with and without its ω component is shown. all reported measures are averages over the  <dig> decoy sets in the final testing group. lower scores are better for ranknat and rmsdbest. higher ones are better for znat, ccnat and fenat. the ω-only function is able to pick out native structures quite well, but when it fails, its choices are essentially random. in the two measures for which the ω-only function does poorly , dfmac performance improves when its ω component is removed. all metrics are defined in performance measures at the end of methods.

comparison of decoy discrimination performance comparison among loco, our ω-only function and dfmac, both with and without its ω component, is shown. all reported measures are averages over the  <dig> decoy sets in the final testing group. lower scores are better for rb <dig>  rb <dig>  rmsddecoy, log and log. higher scores are better for zdecoy, ccdecoy and fedecoy. performance for our ω-only function is approximately the same as if its choices had been made at random. with the exception of ccdecoy  dfmac performance improves across the board with the ω component removed. all metrics are defined in performance measures at the end of methods.

for dfmac, znat improves noticeably and ranknat improves significantly with the inclusion of the ω angle component while rmsdbest and fenat decline slightly. this mirrors the very good scores of the ω-only function for ranknat and znat and its relatively poor performance at fenat. the slight decline in rmsdbest for dfmac when the ω angle component is included must be considered an artifact of the tenfold cross-validation used when weighting the various dfmac components. this is because that performance measure was the one being optimized and because the ω angle component was assigned a positive weight.

with native structures removed , the decoys selected by our ω-only function are effectively random. dfmac performance improves slightly across the board without the ω component. this suggests that using ω angles improves some performance measures of native structure recognition but degrades decoy discrimination.

loco applications
loco potentials combine speed, accuracy and ease of implementation. they should be of use in a variety of structure prediction tasks, including both template based  and template free  modeling. we anticipate that they will be accurate enough to allow for improved main chain-only refinement of template based models before they are treated at the all-atom level.

we expect that our potentials will be useful for protein design applications as well. currently successful sequence search algorithms must evaluate structures at an all-atom level  <cit> . this means that they cannot fully sample the sequence space but must rely on more restricted search techniques, such as a monte carlo method  <cit> . a sufficiently accurate main chain-only potential function should allow the entire sequence space to be searched, treating design as a combinatorial optimization problem, much like choosing side chain conformations.

with its speed and accuracy, loco is a good candidate for such an application. the stablest possible sequence for a given main chain is the global minimum energy conformation . a low-resolution function like loco would be unlikely to arrive at the gmec, but it would not need to. the loco-designed sequence would only need to be stable enough for the desired application. even if the loco-designed sequence was not stable enough to be used, it should provide a good starting point for further refinement using all-atom methods.

future directions
while these potentials have been developed for and with complete polypeptide chains, there may well be value in developing individual potentials for secondary structure elements and loops. such potentials may be able to aid in the recognition of helices and sheets within sequences for which no homolog is known, and loop-specific functions may aid in faster and more accurate modeling of the most challenging aspect of protein structure prediction. as noted above, we hope that loco will allow for a broader search of protein sequence space in design applications.

the idea behind loco scoring should also work for low-resolution screening of docked protein-protein complexes. currently, initial-stage docking programs are dominated by grid-based algorithms  <cit>  that rely on fast-fourier-transforms  to provide the speed necessary to sample all possible docked conformations in a reasonable amount of time, which may be improved by a loco type potential for docking.

CONCLUSIONS
we present a novel scoring function, "loco," for evaluating protein main chain conformations. our method considers relative positioning in all three dimensions and examines every interaction from the perspective of both partners, in contrast with every other function it was tested against. a number of recently-developed potentials have achieved improved performance over more traditional contact potentials by considering the relative orientations of two interacting residues.

loco provides an unprecedented combination of speed and accuracy. once an interaction has been characterized by the identities of the participating residues and their relative positions, a single lookup gives the score for that particular interaction. this function has many potential uses in the field of protein structure prediction, and since a local coordinate system can be generated for any chiral group of atoms, there are many possible ways the fundamental concept could be applied.

competing interests
the authors declare that they have no competing interests.

authors' contributions
sm conceived the function, wrote the software, carried out all function training and decoy testing and drafted the manuscript. rs supervised the research, edited the manuscript, and provided intellectual mentorship. all authors read and approved the final manuscript.

