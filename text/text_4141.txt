BACKGROUND
this paper is devoted to distance measures for leaf-labelled trees on free leafset. a leaf-labelled tree is a data structure which is a special type of a tree where only leaves  nodes are labelled. this data structure is used in bioinformatics for modelling of evolution history of genes and species and also in linguistics for modelling of languages evolution history. many domain specific problems occur and need to be solved with help of tree postprocessing techniques such as distance measures, consensus trees, clustering. distance measures play the most important role as they are very often the start point for more complicated techniques. one of such problem is a problem of competing evolutionary hypothesis. in the process of phylogenetic tree reconstruction, different candidate trees may be obtained, the researches have to determine the true tree of life.

many existing techniques are designed for trees built of the same leafset which is very limiting. here we focus on techniques that do not require trees to contain the same set of leaves. previously we introduced the simple z-restriction approach  <cit>  and more sophisticated frequent subsplit approach  <cit> . here we introduce the tree edit distance designed for leaf labelled trees on free leafset, which occurs to be a metric. it is presented together with tree edit consensus tree notion and some new results for frequent subsplit based dissimilarity measures approach. for the purpose of experimental testing we follow and extend methodology presented in  <cit> . we use the popular robinson-foulds  <cit>  and mast  <cit>  based distances as the reference measures. the experiments yield very promising results.

methods
basic notions
here we provide the basic notions and the description of some basic operation on leaf labelled trees which were chosen as the basic operation for new tree edit distance measure. some derived notions are also presented here.

leaf-labelled tree is a tree with labels assigned to its leaves. unrooted leaf-labelled trees are very often represented as a set of splits  <cit> .

definition  the split  a|b , corresponding to an edge e is a pair of leafsets a and b, which originated from splitting tree t into two disconnected trees, whilst removing an edge e from a tree t, a ∪ b = l. if |a| =  <dig> or |b| =  <dig>  the split is trivial.

in this paper, we will refer to the leafset of a given split s as l. the set of splits corresponding to each edge builds a unique representation of a given tree. we will refer to the set of splits for a given tree as s. we will use s ∈ s, or s ∈ t to denote that split s occurs in tree t.

definition 

the contraction of a tree t is obtained by removing a chosen internal edge from tree t and identifying adjacent nodes of the contracted edge.

because split corresponds to edge , so a contraction may be realised by removing a split from a splitset that represents the given tree. figure  <dig> illustrates a contraction operation, and the splitsets are as follows:

t  <dig> : a|bcde, b|acde, c|abde, d|abce, e|abcd, ab|cde, abe|cd

t  <dig> : a|bcde, b|acde, c|abde, d|abce, e|abcd, ab|cde

t <dig> is called a refinement of t <dig>  however t <dig> is also a subtree of t <dig> , therefore we will say that t <dig> is c-subtree of t <dig> 

definition  a c-subtree of tree t is a subtree where only a contraction operation has been used to construct the c-subtree from its supertree t.

definition  pruning is the operation of removing a chosen leaf from a tree, and afterwards removing the nodes of degree two . the pruning operation can be illustrated on a set of splits as the process of removing leaves from splits, and then removing duplicate splits and not-valid splits, which corresponds to forced contraction.

t <dig> : a|bcde, b|acde, c|abde, d|abce, e|abcd, ab|cde, abe|cd

t <dig> : a|bce, b|ace, c|abe,- |abce, e|abc, ab|ce, abe|c

t <dig> : a|bce, b|ace, c|abe, e|abc, ab|ce

t <dig> is called an induced subtree of t <dig>  however here we will call it a p-subtree.

definition  a p-subtree ps of a tree t is a subtree where only a pruning operation is allowed to construct the subtree ps from its supertree t.

definition  a z-restricted tree tz  of a tree t on leafset z, is a p-subtree of t where all leaves not in z were pruned. in this paper we use both tz and t|z notations, the second one is more popular and clearer, however it sometimes conflicts with the split notation.

definition   <cit>  splits s <dig> and s <dig> are restrictedly equal on leafset z if their z-restricted versions on leafset z are equal.   

in  <cit>  we have introduced the subsplit term which is used for the distance and consensus methods discussed later in this paper.

definition   <cit>  split s <dig> is a subsplit of s <dig> and s <dig> is a supersplit of s <dig> iff s <dig> is restrictedly equal to s <dig> on the leafset of s <dig>  and the leafset of s <dig> is a subset of the leafset of s <dig>    

this can be presented alternatively as:   

common information extraction techniques
definition   <cit>  the strict consensus tree is defined in terms of splits. the strict consensus tree is a tree constructed of all splits common to all trees in a given pro le of trees. figure  <dig> presents two trees together with their strict consensus tree.

splits from t1: a|bcdef, b|acdef, c|abdef, d|abcef, e|abcdf, f|abcde, ab|cdef, abc|def, abcd|ef

splits from t2: a|bcdef, b|acdef, c|abdef, d|abcef, e|abcdf, f|abcde, ab|cdef, abc|def, abce|fd

the common splits of these trees, which build the strict consensus tree, are as follows: a|bcdef, b|acdef, c|abdef, d|abcef, e|abcdf, f|abcde, ab|cdef, abc|def.

because the concept of a consensus tree is very strict, for many trees, a consensus tree can easily become a star . in order to deal with this problem, many variations of consensus trees have been proposed, among others, a majority rule consensus tree.

definition  the majority rule consensus tree is built from splits that occur in the majority of trees.

definition   <cit>  for a given pro le of leaf-labelled trees t <dig> .... tn, the agreement subtree is a tree for which ta = t1|x··· = tn|x for given x, where x ⊆ l. the maximum agreement subtree is an agreement subtree with a maximum number of leaves  <cit> .

an example of a mast can be seen in figure  <dig>  in figure  <dig>  t <dig> and t <dig> are the input trees, the leaf d is removed from both trees resulting in t1' and t2' respectively. finally the leaf h needs to be removed to achieve an identical tree tm, which is a maximum agreement subtree of t <dig> and t <dig> 

several versions of the mast problem exist like rmast, which considers only rooted trees, or umast for general unrooted trees.

a mast problem without any restrictions is generally np-hard  <cit> . however when the degree of one input trees is limited, then the algorithm is polynomial  <cit> . also, when the number of trees is limited to two, then the algorithm is also polynomial.

distance measures
robinson - fould distance  <cit>  originated from phylogenetic analysis. it is defined as the difference between the number of all splits and the number of splits shared by compared trees. as it was proposed for phylogenetic trees, it is defined for leaf-labelled trees with the same leafset. the r-f distance between two trees t <dig> and t <dig> with a set of splits s <dig> and s <dig>  respectively, is as follows:   

for example, in figure 4:

dr - f  = 2

the tree edit distance  <cit> ,  <cit>  between t <dig> and t <dig> is defined as the minimal cost of editing operations needed to insert a node, delete a node and relabel a node that transforms t <dig> to t <dig>  it is based on the concept of edit distance for strings. tree edit distance was defined for node-labelled and edge-labelled trees. the distance has nice features, it is intuitive, it does not require that compared trees have the same set of leaves. however for trees with leaves which are only labelled, it cannot be used directly. some artificial internal node labelling is required to use it for such trees, which makes it less intuitive. this distance has not been popular for leaf-labelled/phylogenetic trees. however, in our opinion the idea of edit distance, can be applied to leaf-labelled trees, provided that the editing operations that are selected are natural for them. such an approach can lead to better distance measures for leaf-labelled trees than existing measures. such an approach will be presented later in this paper.

the mast distance between trees t <dig> and t <dig> is the number of leaves that need to be removed to obtain the maximum agreement subtree.

for the trees from figure  <dig>  dmast =  <dig> 

representative splitset and derived similarity measure
here, we recall the basis of our representative splitset approach, which is the foundation for a new consensus technique and new similarity measure, applicable to trees where the leafset may vary without discarding any information. for the detailed information see  <cit> .

notion of representative splitset
definition  frequent subsplit s with support minsup in a profile of trees is a split that is a subsplit of at least one split in at least minsup of trees. the minsup parameter is called the minimal support. it may be an absolute value which denotes the minimum number of trees in which the split is supposed to be found . it can also be given as a relative value, where it is a minimal percentage of the trees in which the split is supposed to be found.

consider the trees shown in figure  <dig>  which are represented as follows:

t <dig> : cd|abefghi, bcd|aefghi, abcd|efghi, hi|abcdefg, ghi|abcdef, fghi|abcde plus trivial splits

t <dig> : bc|adefghj, abc|defghj, abcd|efghj, hj|abcdefg, ghj|abcdef, fghj|abcde plus trivial splits

according to our approach, we count the number of trees in which the split occurs , rather than counting the number of splits, of which it is a subsplit. for example, in figure 6: abcd|efgh has the support 2/ <dig> , because it occurs in both trees: in the first one as a subsplit of abcd|efghi, and in the second one as a subsplit of abcd|efghj. the argument for counting trees rather than splits is that there may be some subsplits that occur frequently as subsplits of many splits, but only in one tree. such trees are considered uninteresting.

definition  representative splitset - a set that contains maximal frequent subsplits s, i.e. such that there is no other frequent subsplit sx that is also a supersplit of s.

definition  the strict representative splitset sfs is a representative splitset with minsup = 100%. more formally, sfs can be represented as follows:   

where   

definition  the majority-rule representative splitset is a representative splitset with minsup = 50%.

frequent splitset interpretation
it is clear that, from the splits of fs, we cannot directly construct one tree because the splits in general have different leafsets.

the full reasoning about frequent interpretation was provided in  <cit> . here we just recall the conclusions which were derived from the split compatibility definition and use the fact that from a compatible set of splits a tree can be built:

conclusion 1: for each distinct leafset z from frequent splitset  with a support greater than 50%, a tree can be built. the tree is built on z-restricted versions of those splits from fs having a leafset as a superset of z. therefore the frequent splitset  can be represented as a set of trees. in particular, it affects the strict and majority-rule frequent splitset.

conclusion 2: each split from the frequent splitset discussed above will occur in at least one tree, in a restricted form.

conclusion 3: conclusions  <dig> and  <dig> are also true for a tree based on the intersection of all the distinct leafsets from the frequent split-set.

conclusion 4: the set of trees resulting from the frequent splitset will also contain a consensus tree, provided that the input dataset of trees was built on the same leafset.

for example, as the strict-frequent splitset of trees from figure  <dig> contains splits built on two distinct leafsets: abcdefg and abcefg the intersection of these leafsets is equal to the second leafset. therefore, this strict-frequent splitset will be illustrated by two trees as shown in figure  <dig> 

strict-frequent-set: abcd|efgh, gh|abcdef, fgh|abcde, bc|aefgh, h|abcdefg a|bcdefgh, b|acdefgh, c|abdefgh, d|abcefgh, e|abcdfgh, f|abcdegh, g|abcedfh

for a more difficult example, let us look at trees t <dig> and t <dig> from figure 8: here, we have three distinct leafsets: {abcde f gh} {abce f gh} {abcde f g} and the intersection: {abce f g}. therefore as a visualisation we present four trees on these leafsets, as shown in figure  <dig> 

fs-based dissimilarity measure
basing on frequent subsplit notion we defined a dissimilarity measure between two trees   <cit> . it is not only applicable to trees with different leafsets but also gives more intuitive results for trees with the same leafset:   

where sfs is a strict-frequent splitset and is the modified sum of both splitsets, which means that, if for splits s <dig> ∈ s <dig>  s <dig> ∈ s <dig> , s <dig> is a supersplit of s <dig>  only the supersplit  is included in the result. formally, it can be represented as follows:   

such a measure determines the dissimilarity on the basis of how many subsplits they share in common. let us compare this measure to the most popular: r-f distance. consider the example from figure 10:

sfs = trivial + ab|cd, sfs = trivial, sfs = trivial

drf  =  <dig>  d =  <dig> - 6/ <dig> = 4/9

drf  =  <dig>  d =  <dig> -5/ <dig> = 5/9

it is clear that the r-f distance states that t <dig> and t <dig> are both as dissimilar as t <dig> and t <dig> whilst our measure arrives at a different result, which is an intuitive result since both t <dig> and t <dig> share a common non-trivial subsplit ab|cd. for trees on a different leafset, the r-f distance does not work at all whilst our measure does.

the main drawback of this measure is that it is not a metric, however it achieves very good statistical characteristics and clustering results as described in the results section. in this paper the method was compared to r-f, mast and edit distance in the series of experiments.

tree edit distance and tree edit consensus for leaf-labelled trees
tree edit distance for leaf-labelled trees
in the following sections we define a new distance and consensus notion based on editing operations on leaf-labelled trees. we choose contraction and pruning as editing operations for leaf-labelled trees. if tree t <dig> is a subtree of t <dig>  where both pruning and contraction operations are allowed, then we call it a pc-subtree or edit subtree. an example of transforming tree t <dig> into t <dig> using editing operations is shown in fig.  <dig> 

definition  an edit script s for leaf-labelled trees t <dig> and t <dig> is the pair of subscripts s and s which are sequences of editing operations including contraction and pruning, which can be applied to the selected input trees t <dig> and t <dig> to unify them. s = s ∪ s. the subscripts s, ) are uni-directed which means that by using s, we can modify t <dig> to obtain the tree that is a unification of t <dig> and t <dig>  but not necessarily in the opposite direction.

definition  the cost of an edit script cost is the sum of the defined costs of editing operations: contraction and pruning where cost = costc if e is a contraction and cost = costp if e is a pruning operation. forced contractions may be counted or not, depending on application.

definition 

having defined positive value costs for contraction and pruning operation, the tree edit distance for leaf-labelled trees t <dig> and t <dig> is the minimal cost edit script d = mincost, where forced contractions are counted as normal contractions. note that in order to keep the resulting tree as leaf-labelled tree only contractions that correspond to non-trivial split are performed, unless it is a forced contraction - than trivial split may also be contracted to remove split with duplicate representation. in this paper, we focus on the edit distance which counts forced contractions. thanks to this property, we can prove that it is a true metric.

however, there is also an interesting variant of the edit distance where a forced-contraction is ignored. the metric property of such a variant is yet to be verified, the measure will also be considered in experiments due to its interesting features.

definition  having defined positive value costs for contraction and pruning operation, the no forced contraction disimilarity measure for leaf-labelled trees t <dig> and t <dig> is the minimal cost edit script d = mincost, where forced contractions are ignored.

tree edit distance versus r-f distance and mast
as mentioned earlier, comparing distance measures is not a trivial task. here, we provide a subjective opinion about why this measure is better than others, however an objective statistical comparison will be provided in the results section.

the r-f and mast distances have some drawbacks which have emerged from the fact that the r-f distance may use only contraction operations and mast uses only pruning operations and forced contractions. there are of course some cases when all three distances perform equally well, as in the example of figure  <dig>  where for trees t <dig> and t <dig>  the r-f distance =  <dig>  mast =  <dig>  edit distance =  <dig> 

r-f distance drawbacks
1) the first drawback of the r-f distance is that it is totally useless for leaf-labelled trees on a free leafset. for example, figure  <dig> shows two trees on a different leafset . the r-f distance is undefined here. it can be seen that the removal of one leaf and the internal edge is sufficient to make the two trees identical. in this case, both the mast and edit distance can be used as mast can be extended to support a free leafset, and the edit distance is naturally suitable for a free leafset. mast and edit distances will provide different values: mast distance =  <dig>  edit distance =  <dig>  these differences will be discussed in the following section.

2) the second drawback of the r-f distance is that even if the trees are on the same leafset, one noisy leaf may cause the trees to be considered totally different . removal of one leaf may significantly reduce the distance between trees. such a situation is illustrated in figure  <dig>  trees t <dig> and t <dig> look totally different, in terms of the r-f distance, because of leaf d, thus all non-trivial splits must be removed  in order to make them identical. r-f distance =  <dig>  however, removing only leaf d would result in trees differing by only  <dig> splits! therefore, the mast distance equals  <dig> and the edit distance equals  <dig> 

mast distance drawbacks
1) the first drawback of the mast distance occurs when the trees are similar except for one internal edge as in figure  <dig>  in this case, the mast distance would equal  <dig> as it requires the removal of at least  <dig> leaves in order to make the trees identical. however, both the r-f and edit distances may just remove one edge, thus the r-f distance would equal  <dig> and the edit distance would equal  <dig> 

2) the second drawback is that mast counts only the leaves that are removed from both input trees. if it is allowed to also count leaves that are present in only one tree in order to support a different leafset, then the distance will ignore some subtle changes. for example, in figure  <dig>  the distance between t <dig> and t <dig> is identical as in the example with t <dig> and mast, which is obviously incorrect. the solution to this problem would be to count the leaf twice if it is removed from both trees and count it once if is removed from one tree. this solution would not however fix another problem: mast completely ignores forced contractions. therefore, some subtle differences may again be missed. for example the mast distance between t <dig> in figure  <dig> and t <dig> in figure  <dig> is the same as between t <dig> from figure  <dig> and t <dig> from figure  <dig>  which is again incorrect. in this case, the mast distance would be equal to  <dig>  but the edit distance equals  <dig> and  <dig> respectively.

edit distance advantage
in the previous sections, we showed the drawbacks of rf and mast distances and showed that the edit distance is better because:

• it can be used for trees on a free leafset

• it can distinguish differences where the mast distance cannot as it can use both contraction and pruning.

let us compare the values of these distances. the edit distance is easily compared to the r-f distance, provided the same cost of contraction is used to count both distances. the only difference between them is that the r-f distance cannot use pruning. however, it is impossible to compare the values directly to mast as this distance is not well defined if the leaf is removed from one tree only, and the cost of forced contractions is ignored. therefore, in order to compare the values, we will use the r-f distance  and instead of mast, we will count the cost of each pruning operation and forced contraction . some distance values are presented in table  <dig> 

these results show that, in some situations, pruning operations are better at unifying trees, sometimes contractions are, and sometimes neither performs well. however, there are cases when using both of them is better. to sum up below, there are some cases when one editing operation is better than another: pruning is better: when the trees are not on the same leafset, then pruning is necessary  the trees may be on the same leafset but they contain some noisy leaf . contraction is better: when two significantly large sub-trees are connected directly on one tree, but connected with an additional edge on the second tree . both operations seem to be equally good when the trees are on the same leafset, there is no noisy data, and the degrees of the nodes are relatively small. because there are some cases when one operation is better than the other, a distance based on both operations shall be better than one based on only one operation. a distance constructed in this way will choose the most appropriate editing operations. for example, consider figure  <dig>  the c-distance equals  <dig> , p-distance  equals  <dig>  pc-distance  equals  <dig> 

cost manipulation
the difference between the edit distance and other distances is visible especially when the cost of operations is not the same. although in some cases both operations can be equally good, one may prefer for example contraction over pruning in some cases. the motivation can be for example the need to have as many leaves as possible in the tree edit consensus. therefore, our distance uses the costs of editing operations. for example, consider the trees t <dig> and t <dig> in figure  <dig>  and assume that the pruning cost equals  <dig> and the contraction cost equals  <dig>  for these trees, if only the pruning operation is used, then the p-distance equals  <dig> , if only a contraction is used then the r-f-distance equals  <dig> , however if the edit distance is used then the distance is equal to  <dig> . the edit script is also illustrated, with its semi-products . if we assume the following costs:  <dig> for prunning and  <dig> for contraction, then the edit distance would consist of contraction operations only, and the distance would be equal to  <dig> 

tree edit distance metric proof
in order to show that our measure is a true metric, the following conditions shall be proved:

• d =  <dig> ⇔ t <dig> = t2

• d = d

• d + d ≥ d

the first two conditions are met by definition: the minimal edit script that unifies t <dig> and t <dig> contains no operations, therefore the distance is equal to  <dig>  on the other hand, if two different trees t <dig> and t <dig> may be unified only by applying some editing operations, and because cost must be positive-valued, then the distance for different trees cannot have the value  <dig> 

as the definition states that the distance is the minimal cost of unifying two trees, by applying the editing operations either to t <dig> or t <dig>  it is therefore symmetric by definition.

the third condition is slightly more complicated and requires more explanation:

lemma : having the edit scripts corresponding to distances d and d, we can unify trees t <dig> and t <dig> using the same operations as on both scripts .

proof:

lets denote:

• tpcx the tree edit consensus  of trees t <dig> and t <dig> 

• tpcy the tree edit consensus  of trees t <dig> and t <dig> 

• sx <dig> = tpcx - the edit subscript that transforms t <dig> to tpcx

• sx <dig> = tpcx - the edit subscript that transforms t <dig> to tpcx

• sy <dig> = tpcy - the edit subscript that transforms t <dig> to tpcy

• sy <dig> = tpcy - the edit subscript that transforms t <dig> to tpcy

the mentioned artefacts are presented in figure  <dig> 

because s1) = s2), which will be shown in the next section, we have:

sx2) = sy2) and sx <dig> = sy <dig>  because sy <dig> = tpcy and sx <dig> = tpcx

therefore, there exists some tree tpcz, such that sx <dig> = tpcz and sy <dig> = tpcz , which can be obtained from t <dig> and t <dig> with at most the same number of operations as unifying t <dig> with t <dig> and t <dig> with t <dig> 

theorem: the tree edit distance for leaf-labelled trees meets the third metric condition.

proof: due to lemma, presented earlier, there exists an edit script s that can unify trees t <dig> and t <dig> at the same cost  than the sum of: d + d

cost) <= d + d

and because

d <= cost)

therefore:

d <= d + d

edit subscript order
in this section we show that for a given edit subscript , changing the order of operations in it will not change the resulting tree. therefore, it will also not increase the costs. in order to show this, we need to show that if edit script consists of operations: p <dig> ..., pn and c <dig> ..., cm then the changing order of operations does not change the result.

let us assume that a tree is represented with two sets e - a set of internal edges referring by non-trivial splits and l - a set of leaves. let us consider edit script es that transforms t <dig> represented with e <dig>  l <dig> to tree t <dig> represented with e <dig>  l <dig> and e <dig> ⊆ e <dig> and l <dig> ⊆ l <dig>  assume for a moment that we will not handle forced contractions. under such assumption the edit operations: contraction and pruning operate on a different set of items - edges and leaves respectively. therefore position of contraction operation, with relation to pruning operation in edit script  does not affect the result. additionally, from the set theory - the order of items removal from a set is irrelevant - therefore position of contraction operation with relation to other contraction operation in edit script is irrelevant. the same holds for pruning. this leads directly to conclusion that the order of operations in edit script does not affect the final result.

one may notice that pruning also removes some edges, but only trivial ones, which are not considered in edit distance and may be removed at any time. one may also notice that pruning changes the bipartition representation of all non-trivial splits. it is also not a problem, as the total number of edges is not affected. although we use split representation very often, here the number of edges is important .

as it was presented earlier in this paper, pruning may occasionally introduce forced contraction . it does not, however, break the assumption that operations work on different sets and are independent of each other.

let us represent pruning p as the pair of operations p' that removes leaf only as assumed earlier and fc that performs forced contraction. so each time pruning p occurs in edit script it is replaced with either p' if there is no forced contraction to perform or p', fc. operation fc may be treated as regular contraction operation, with the only difference that it is inserted by pruning. it can also be easily shown that if we change the order from p', fc to fc, p' the result remains the same as the pruning operation does not trigger forced contraction if the appropriate edge was removed earlier in edit script.

the last thing that we mention is the edge matching. forced contraction removes the edge, which is a duplicate of another edge with respect to their split representation. for example e <dig> = ab|cde and e <dig> = abe|cd will be consider duplicates if leaf e is pruned. it may be therefore problematic which edge e <dig> or e <dig> is in fact removed from set of edges. therefore if the forced contraction is to be done then we shall treat it as the unification of duplicate edges. that means operations c and c can be used exchangeably within the edit script, as the edges are unified sooner or later.

algorithm for counting edit distance of leaf-labelled trees
the naive algorithm for this problem can be illustrated as follows:      

where ds is the distance for trees on the same leafset, t <dig> - s denotes tree t <dig> with removed split s, Δ stands for symmetric difference and k indicates the number of forced contractions that needed to be performed. to keep metric property costfc is equal to costc. in the equation the following part: costp * |lΔl|+k * costfc is in fact the cost of unification of leafset for both trees. the algorithm is therefore exponential with respect to the number of leaves and the number of splits. we modify algorithm on the basis of two observations. the first one is that the order of editing operations is irrelevant therefore the algorithm can try prunning operations before it tries contractions. the second one is that the edit distance will never remove the splits that occur in both trees , which can be easily proved, only differing splits  are considered. after modifications algorithm presents as follows ).   

the algorithm can also be presented with pseudocode as follows:

function edit_distance {

d <dig> = l - l ;

d <dig> = l - l ;

t1'=prune ;

t2'=prune ;

//after above operations l = = l

cost = *cost_p+ cost_c * +how_many_fc)

      + edit_distance_the_same_leafset;

return cost;

}

function edit_distance_the_same_leafset{

   mincost = r-f-distance * cost_c;

   l = l; // l = = l

   for each leaf in l

      t1'=prune;

      t2'=prune;

      cost_all_fc = cost_c * + how_many_fc);

      costt = edit_distance_the_same_leafset

         + 2*cost_p + cost_all_fc;

      if  mincost=costt;

   end for

return mincost;

}

function how_many_fc { return |s| - |s| +k)

// k parameter is used to prevent counting trivial split contration directly

// associated with leaf removal

function prune  - prunes all leaves from set l from tree t <dig> and

performs forced contractions.

this algorithm is now exponential with respect to the number of leaves. it is possible that this can also be improved so that it has the same complexity as mast for two trees , but further investigations are required. for the purpose of this paper, we used a dynamic programming algorithm, where partial results are stored in memory and re-used if necessary. it turns out that the algorithm was required to only count a small part of all possible combinations which also gives grounds for optimism that a better algorithm will be found.

let us look on a few steps of naive algorithm for trees t <dig> and t <dig> from figure 12

t1:gh|abcdef, fgh|abcde, efgh|abcd, aefgh|bcd, abefgh|cd

t2:f g|abcdeh, dfg|abceh, dfgh|abce, defgh|abc, adefgh|bc

trees are built on the same leafset so we may directly calculate ds equation. dr-f  =  <dig>  let us remove some leaves : let us remove a, we obtain:

t1':gh|bcdef, fgh|bcde, efgh|bcd, , befgh|cd

t2':fg|bcdeh, dfg|bceh, dfgh|bce, defgh|bc, 

plus the trivial splits

curly braces denote splits that will be force-contracted.

dr-f  =  <dig>  cost of pruning:  <dig>  and cost of forced contractions:  <dig> total cost in this path:  <dig>  so the result is worse than dr-f , and the prunning additional leaves will also not improve the result.

so let us remove d instead of a

t1':gh|abcef, f gh|abce, efgh|abc, aefgh|bc, 

t2':, fg|abceh, fgh|abce, efgh|abc, aefgh|bc

dr-f  =  <dig>  cost of pruning:  <dig>  and cost of forced contractions:  <dig> total cost in this path:  <dig>  so the result is better than dr-f  we may continue with pruning of another leaf to see if we can improve the result more, so we remove g

t1":, fh|abce, efh|abc, aefh|bc

t2":, fh|abce, efh|abc, aefh|bc

dr-f  =  <dig>  cost of pruning:  <dig>  and cost of forced contractions:  <dig>  cost calculated from previous

step:  <dig>  so the total cost is equal to  <dig> thus we received a worse result. we will not continue with pruning of other leaves as it will not lead to better result.

therefore the best cost is  <dig>  and the edit script contains two subscripts:

from t1: p, fc, c

from t2: p, fc, c

tree edit consensus tree
similarly, we may define a new consensus method on the basis of editing operations called the tree edit consensus tree. the tree edit consensus tree is the maximal  common subtree of the input trees, obtained by contraction and pruning operations and is defined as follows:

definition  having defined the positive value costs of contraction and pruning operations, the tree edit consensus for leaf-labelled trees t <dig> ... tn is the minimal cost edit script that unifies these trees. for trees t <dig> and t <dig> in figure  <dig> the tree edit consensus tree is tree tc = t1" = t2" similar to mast, the tree edit consensus tree is not unique. the experimental assessment of this method was done in phd thesis  <cit>  and will not be recalled here.

tree edit consensus algorithm
similar to the edit distance, based on the fact that, if a prunning operation is used it must be used on all input trees and the fact that contraction is performed only for splits that do not occur in all input trees. the naive, dynamic programming algorithm which counts the score of the tree edit consenus may be defined as follows:      

where , sct stands for strict consensus tree, tec is the tree edit consensus k is the number of forced contractions that needed to be performed and costfc is equal to costc

the tree edit consensus tree may be obtained by recording prunning operations used along the optimum path. recorded prunnings must be applied to input trees, and afterwards all unmaching edges must be contracted .

quality of similarity measures
the quality of similarity measures is not obvious to estimate. the best possible method would be a method based on external criteria i.e. based on expert knowledge. in biological applications, it could be a comparison of the consensus tree with the true phylogenetic tree. the true tree however is something that is not known. we agree with the opinion presented in  <cit>  that similarity measures are especially difficult to score as they are very subjective about what is similar and what is not. such a subjective approach to score the distance requires that someone arbitrarily selects the best distance matrix. this matrix is to be compared with the distance matrix achieved with a given similarity measure. a more objective method would be to prove that a given measure is best in some particular applications or may be used to solve some particular problems, like for example the identification of the ancestral paralog position in the paralog families mentioned in  <cit> .

the methods that can be applied to measure the quality of distance measures and consensus techniques can be roughly divided into:

• qualitative methods which try to de ne properties that the given consensus method or similarity measure must meet as in  <cit> 

• quantitative methods which try to measure the quality of consensus or similarity methods such as  <cit> . they are often based on some assumptions due to the lack of verified domain knowledge

• statistical methods which display the statistical properties of the given method to help an expert score the method instead of scoring it automatically, because the quality of a metric may depend on the application.

in an axiomatic approach, the most common requirement for the similarity measure is that it meets metric properties, or at least pseudo-metric ones.

the quantitative approach is not very suitable for distance measures due to lack of objective criteria. even if we are supplied with biological data which contain groups of trees and may count for example the proportion of inner-group distances to between-group distances, such an approach is not very trustworthy. this is because we see the effect of the distance measure on selected sets, which may be different for different parts of the tree-space. we also ignore some potential properties of distance, for example that the distance metric may be better for some topologies of trees but worse for others and this observation could give hints on where to use it and where not. simply put, the quality of a metric may depend on the application.

except for proving the metric properties of some distances, we choose the statistical approach as described in  <cit>  and perform two kinds of experiment:

• analysis of distance probability distribution

• analysis of distance dynamics with respect to number of changes in trees.

in the first approach, we count the distance for a large number of randomly generated unrooted trees according to different distributions and examine the distribution of probability. the details of random generation of rooted trees can be found in  <cit> ) - this method can be adaptable for unrooted trees.

p = k). we try to determine:

• whether the distance distribution has any regularities, follows any known distribution, which proves that the distance does not work in a random fashion

• whether the distance is well enough discriminative , whether the discrimination property is equally strong for similar and different trees.

the other approach is to mutate the random tree with different mutation operations and see how the distance changes.

more details about the experiments will be provided in the results section.

RESULTS
in this section, an experimental evaluation of the proposed methods is presented. for the purpose of experiments, we use the randomly generated trees with different distributions and we evaluate the statistical properties of the similarity measures as described previously in this paper. from our propositions, we decided to evaluate the tree edit distance, no forced contraction similarity measure called nfc here and the fs-based similarity measure.

for comparison with existing distance measures we have chosen the r-f and mast distances. r-f is one of most popular and computionally efficient distances, mast and r-f are in a way foundations of the edit measures presented in this paper. we decided not to normalise the values of distances because sometimes normalisation is not obvious . normalisation is not necessary in the first experiment as we study the distribution rather than absolute values. in the second experiment, the lack of normalisation does not prevent us observing dynamics, it only forbids the spotting of the crossing points of distances. the approach of normalising with the maximum observed value, as used in literature, in our opinion distorts the results, because if the real maximum value is not achieved then the graph is distorted. the only modifications are made with the fs dissimilarity measure, i.e. values are scaled and biased in order to be compared with other distances on the same chart.

in this experiment, trees with  <dig> leaves are presented, however tests were also performed with trees with up to  <dig> leaves for unconstrained trees and  <dig> leaves for binary trees, with similar results being obtained.

distribution of distance probability
for this test,  <dig> pairs of trees with  <dig> leaves were generated and the distribution of probability p = k) was examined under different tree generation models, as mentioned previously in this paper. as the edit distance and its version with no penalty for forced contraction are parametrizable, various pruning and contraction operations costs were used. in the following experiments, the edit distance with cost of contraction equal to x, and cost of pruning equal to y is denoted by e, the version with no cost for forced contraction is denoted by nfc.

unrooted binary leaf-labelled trees on the same leafset
first consider figure  <dig> which shows the r-f, mast and edit distances with the cost of pruning and contraction equal to  <dig>  it appears that all of these distances on this dataset took only  <dig> unique values each. among them only  <dig> frequent enough to be visible on the figure. this leads to the conclusion that they are not very discriminative, as the total number of unrooted binary trees with  <dig> leaves is ≈  <dig>  the edit distance and r-f distance behave identically here, the number of occurrences of particular distance value increases asymptotically with the value, which means that these distances are good only for similar trees. on the other hand, mast is also not very discriminative but it is more reminescent of the normal distribution.

the distances e and e are significantly different, especially e which is compared to mast and r-f in figure  <dig>  the e distribution is similar in shape to mast so it can be used both for similar and distant trees, however it has a wider range of values  as compared to  <dig> for mast.)

conclusion the first conclusion is that by modifying the costs of the edit distance, we can achieve a measure with very well-behaving properties: very discriminative and suitable both for similar and dissimilar trees. moreover, the similarity of the edit, r-f and mast distributions shows that the distance is not accidental.

the fs similarity measure is the hardest to interpret , it also has a wide range of values  so it is discriminative, however the shape of the distribution is very irregular. however, if we merge the low peaks with neighbouring high peaks, we achieve something similar to the r-f distance, i.e increasing with increasing distance value. so the conclusion is that it is discriminative but works better for similar trees than for distant trees. it is worth remembering that this measure is not metric for sure, therefore this may affect its properties.

unrooted unconstrained leaf-labelled trees on the same leafset
this distribution leads to similar observations and conclusions. the e, e, nfc, nfc, nfc distributions are similar or identical . e and r-f are again similar, however the distribution does not rise asymptotically with increasing distance value figure  <dig>  both e  and fs  look better than mast and f-s as they take more values e -  <dig>  fs -  <dig> versus r-f -  <dig> and mast -  <dig>  which make them more discriminative.

unrooted leaf-labelled trees on a free leafset
in this experiment trees with at most  <dig> leaves were generated. both binary and unconstrained versions will be discussed together as the differences are only with the r-f distance. characteristics of r-f distribution in this experiment does not recall typical r-f distribution. the main reason is that it is unsuitable for comparing trees with different leafsets as it will always return the maximum value, which will also be dependent on the number of leaves of the trees. therefore the distribution reflects the conditional probability of selecting two trees with the same leafset and trees with different leafsets  of figure  <dig>  and figure  <dig> . as for the other distances, both e and fs behave similarly, having a wide range of values, while e is more regular . both e  and fs  look better than mast and f-s as they take more values e -  <dig>  fs -  <dig> versus r-f -  <dig> and mast -  <dig>  which make them more discriminative.

conclusion : to summarise the key points of this experiment:

• the r-f distance is not very discriminative for binary trees, it is also weak for distant trees. it is not suitable for trees with different leafsets.

• the mast distance is good for the same and different leafset, and is good both for distant and similar trees, however it is only weakly discriminative.

• the edit distance, with the variant where cost of contraction =  <dig> and pruning =  <dig>  looks very promising as it has a wide range of values and is equally good for distant and similar trees.

• the fs dissimilarity measure is similar to the edit distance, but it does not have a very regular distribution.

• nfc here behaves like e i.e. it is equivalent to r-f for the same leafset and equivalent to mast for different leafsets, which is good. however it is still only very weakly discriminative.

dynamics of distances
for this test, one tree is randomly generated and then the second tree is obtained with k mutation operations. here, we observe the dynamics of distance changes with respect to number and type of mutations. due to the nature of most of the examined distances i.e. edit distance, no forced contraction similarity measure, mast and r-f, we use the following types of mutation:

• contraction - we randomly remove a selected split

• pruning - we randomly remove a selected leaf

• nearest non-brother interchange .

nearest non-brother interchange  is a modification of the nni operation  <cit> . we choose the nearest leaves that are not brothers and interchange the leaves as shown on figure  <dig>  the motivation for such a type of mutation is that we wanted to achieve such a modification of a tree that both pruning and contraction can be used to level the changes made by the operation. direct use of both c and p in the mutation process leads to a situation where the number of leaves changes and therefore the r-f distance is hard to be compared to. the nnbi operation can be levelled with either one contraction or one pruning operation if the cousins are  <dig> edges away from each other. the resulting input trees are of the same leafset so the r-f distance can also be taken in the experiments which is exactly what we wanted to achieve. for the trees shown in figure  <dig>  it is possible to either prune leaf f  from both trees or contract splits ef|abcd and ed|abcf to make the trees identical.

to analyse the results, let us see the distances counted with respect to the contraction operation . all distances have similar linear dynamics and might have been simply scaled to behave identically on these data. it can be seen that all distances that have a cost of contraction equal to  <dig>  are identical. nfc was not identical but very similar, so it is illustrated with the same line. those distances with a cost of c =  <dig> and nfc scale the most naturally as the distance is simply equal to the number of mutations, the distance is directly proportional to the number of mutations with k =  <dig>  increasing the cost of contraction makes the edit distances increase quickly.

for a pruning mutation, the situation looks very similar  i.e. all distances would have identical values if scaled, however a few things should be pointed out. the r-f distance here gets smaller with increasing number of p operations. this is because it does not work for trees with different leafsets, in such a case it returns the maximum possible value, which is lower for a smaller leafset, and this is exactly what is illustrated in the figure. another point is that while the r-f was the distance best scaled for contractions, mast is the distance best scaled for pruning. this is natural because r-f uses contraction while mast uses pruning. so if we consider not just pruning nor just contraction, but wish to use both, then the distances do not have the same dynamics. what is seen here is that nfc scales best for both contraction and pruning. this can be visualised better when we see the reaction of distances on contraction and pruning on the same chart. in figure  <dig>  we can see the reaction of r-f, mast and nfc with respect to contraction, pruning, and nearest non-brother interchange . we can see that only the nfc dynamics are similar irrespective of the type of mutation used.

CONCLUSIONS
in this paper we have proposed new technique for measuring distance between leaf labelled trees on free leafset, and provided its evaluations with respect to frequent subsplit based method and other measures. the tree edit distance was proven to be a metric and has the advantage of using different costs for contraction and pruning, therefore their properties can be tuned depending on the needs of the user. it is difficult to pick the best distance measure as they all have different interesting properties and may be used in different applications. two of the presented methods carry the most interesting properties. e is very discriminative  and has a very regular distance distribution which is similar to a normal distribution in its shape and is good both for similar and non-similar trees. nfc on the other hand is proportional or nearly proportional to the number of mutation operations used, irrespective of their type. all of these distances have a great advantage in that they can take different costs of contraction and pruning, therefore their properties can be tuned depending on the needs of the user. future works will be dedicated to discovering more efficient algorithm for tree edit distance and deep experimental evaluation of tree edit consensus method for leaf-labelled trees on the same leafset.

authors' contributions
jk conceived the study, kw coordinated and supervised the study. all authors read and approved the final manuscript.
