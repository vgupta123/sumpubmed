BACKGROUND
rnaexinv is a user friendly computer tool that extends the inverse rna folding problem to include physical attributes. before elaborating on the inverse problem, one should begin by mentioning the classical rna folding problem that aims to predict the secondary structure of a given rna sequence. software packages are nowadays available that contain rna thermodynamic parameters  <cit>  and predict the secondary structure from sequence by energy minimization. the inverse rna folding problem was introduced in  <cit>  and as its name suggests, it aims to design a sequence that folds into a given rna secondary structure. a brute force approach that searches all the possible sequences is not a viable option because the number of sequences grows exponentially as κn, where κ is the number of letters in the alphabet  and n is the length of the sequence  <cit> . therefore, starting from rnainverse that is available in the vienna rna package  <cit> , various other methods  <cit>  that do not compute the whole solution space were developed for the inverse rna folding problem. it should be noted that both rnainverse  <cit>  and info-rna  <cit>  contain a p-mode option, where the objective function is including the probability that the target structure forms, thus considering thermodynamic stability. recently, inspired by the physical aspects of rna secondary structure  <cit> , an extended inverse rna folding problem was suggested  <cit> , which adds several non-structural constraints to the desired output in conjunction such as thermodynamic stability and mutational robustness. this extension may help incorporate some important properties of natural rnas to the design problem. for example, in recent years, several developed methodologies that were meant to address rna secondary structure mutational analysis  mention the potential importance of mutational stability to rna design.

here we describe the software implementation of a new method for the extended inverse rna problem. unlike the method in  <cit>  that utilizes parallel evolutionary computation and is relatively expensive, the method described here is closer in type to  <cit>  and significantly reduces the computation time relative to  <cit> . it comprises two phases, the first of which is to identify a good initial candidate whose folding closely resembles that of the desired structure. the second phase is a simulated annealing heuristic with a four-nucleotide look ahead local search function. the first step in our method is essentially rnainverse from the vienna rna package to obtain a good, initial sequence whose folding approximates that of the desired structure. then the rnainverse result is used as the starting sequence in the local search for the desired sequence of the extended problem. search goals are defined not only by the desired structure, but also by the thermodynamic stability and mutational robustness parameters. the end result is a sequence with a greater number of natural qualities than exhibited by a random sequence with the desired structure. the method employed is described in more detail in the next section.

implementation
method
we now elaborate in more detail on the various stages that the method consists of, starting from the first. for our requirements, using rnainverse with a random start point is preferable over more "fixed" inverse rna folding strategies such as info-rna  <cit> . in a diversion from the rnainverse approach, which uses a random start point, info-rna has a deterministic first stage and only a stochastic local search  <cit>  during the second stage. a random start point is preferable in our specific case since it will produce different start sequences for our extended search rather than a fixed starting point, which could cause all the starting points to resemble each other.

starting with the sequence that was generated by rnainverse from the vienna rna package with a random start point, we search for local optima using iterative mutating. neighboring sequences are assessed according to an objective function that takes into account all the parameters: structure, thermodynamic stability, and mutational robustness. the combined objective function is given by  

where the neutrality is a number between  <dig> and  <dig>  dg is the minimum free energy in kcal/mol, and distances are calculated using rnadistance in the vienna rna package .

the above objective function, as can be noticed in the third term, minimizes the distance between the desired shape and the mfe shape of the input. the distance is that as defined by tree edit distance over the shapiro representation  <cit>   that provides the relaxation of the fine grain graph distance to a shape distance. the thermodynamic stability assessment distance is calculated here as the absolute value of the difference between the desired dg and the mfe dg of the input . the mutational robustness is evaluated by the neutrality. it is calculated as the absolute value of the difference between the observed neutrality of the input and the desired neutrality. finally, in order to balance the result from being completely dominated by the shape consideration in the third term, a fourth term was added that minimizes the base-pair distance between the desired structure and the mfe structure of the input. each one of the constraints receives its own weight as written in the formula above, and these weights can be further manipulated to emphasize various aspects of the minimization. given the weights that have currently been fixed, we performed sensitivity analysis to determine the effect of different contributions by varying the input values and then examining how rnaexinv responds to these changes. obviously, each run of rnaexinv produces a different answer because of the stochastic method employed. however, when changing each input value starting from a slight modification and continuing in an increasing manner, we have noticed that in addition to the expected change in the designed sequence, the output produced faithfully obeyed each time the constraints imposed. the shape remained exactly the same in all cases, having a high valued weight in the formula above, while the mutational robustness  and thermodynamic stability  were slightly changed from their desired values, by no more than 5% at most in the worst case. for brevity, avoiding redundancy, these results are not shown because as expected all input modifications produce a different sequence with a different predicted secondary structure, but the three constraints are fulfilled convincingly as a consequence of changing the input values each time.

rnaexinv utilizes a simulated annealing strategy to obtain the local minima, similar to the adaptive walk  <cit>  and stochastic local search  <cit>  strategies. adaptive walk tests all the single-point mutation neighbors and takes the neighbor that has a better objective function to the next minimization step. adaptive walk, however, has the tendency the get "stuck" in a local minimum if a sequence is best among its neighbors, although that minimum may not be the best solution even in that vicinity. another widely applied strategy is stochastic local search. it combats the susceptibility of adaptive walk to getting stuck in a shallow local minimum by employing a constant probability to adapt a new sequence even if that sequence has a worse objective function result. as such, the stochastic local search strategy is able to escape shallow local minima. simulated annealing also has a probability to adapt sequences with worse objective function results but that probability diminishes over the course of the minimization, and instead of looking only at the nearest neighbors a look ahead is now used to sample the vicinity of the sequence . furthermore, to obtain a good sampling of the objective function landscape in consecutive runs, as mentioned before a random starting point is preferred over a static starting point to avoid repeatedly "falling into" the same local minimum.

to incorporate the physical measures listed above as constraints in the inverse rna folding problem, the problem must first be relaxed from secondary structure to shape, as our previous simulations showed that such constraints can yield no solution  <cit> . thus, instead of the rna secondary structure, we used the simplified coarse-grained representation  <cit>  as its shape. this is a convenient choice provided by the routine 'b2shapiro' in the vienna rna package. as a consequence, the inverse rna folding problem becomes a reconstruction problem, given an rna shape and physical attributes as constraints, to construct desired sequences. this will be demonstrated in the next section. the justification for relaxing the inverse rna folding problem from that of an rna secondary structure to an rna shape emanates from the fact that if in the designed sequences there are a few more or less nucleotides in stems/loops but nevertheless these motif elements remain the same as in the initial input, such sequences are interesting to examine as candidate solutions to the design problem. an obvious advantage is in cases where there is a functional motif that should be strictly retained in the design procedure but further away from it there are non-functional motifs. in the non-functional motifs, an addition of one more or less nucleotide at the expense of another can well be justified if the overall designed sequence exhibits favourable properties in terms of stability and robustness.

availability
the package can be downloaded from http://www.cs.bgu.ac.il/~rnaexinv. after downloading, extract the file with the command:

> tar xvzf rnaexinvgui.tar.gz

more details on how to run the program are contained in the readme.html file that can be easily accessed from http://www.cs.bgu.ac.il/~rnaexinv.

the package content
 <dig>  rnaexinv - performs rnainverse to obtain a good initial sequence whose folding approximates the desired structure, followed by a simulated annealing heuristic with a four-nucleotide look ahead local search function to construct the desired output sequence for the extended inverse rna folding problem. the rnaexinv routine predicts the secondary structure of rna sequences using vienna's rnafold.

 <dig>  java code - creates a "friendly" interface for the user. receives as input an rna secondary structure and relevant parameters for thermodynamic stability and mutational robustness, runs "rnaexinv", and generates the output that contains the designed sequences.

 <dig>  rnafold - predicts minimum energy secondary structures and base pairing probabilities. the rnafold program is taken from the vienna rna package.

 <dig>  rnaplot - draws the secondary structure of the rna, given a sequence and the dot-bracket representation of the secondary structure.

preparation and compilation
rnaexinv is currently available on a linux platform. therefore, all preparations and compilations should be performed on a linux platform with java and "gnu cc" compiler installed. rnaexinv has all its components already compiled and may be used without any compilations, but it has some components written in c that in some architectures may not work. in such a case, the vienna rna package should be downloaded from the web at http://www.tbi.univie.ac.at/~ivo/rna/ and compiled. after the compilation finishes, files: "rnaplot" and "rnafold" should be copied from vienna rna to the "rnaexinvgui\bin" directory. all files that are already in this directory should be overwritten. in order to compile rnaexinv, please go to the rnaexinvgui\rnaexinv directory and run the make command. copy the created rnaexinv executable to the rnaexinvgui\bin directory.

make sure that all files in the "rnaexinvgui\bin" directory are in an executable mode. if not, change their mode by typing the command: > chmod  <dig> file_name, where file_name is each file from the \bin directory.

RESULTS
the input to the rnaexinv tool as shown in figure  <dig> is simply an rna secondary structure and two additional parameter values for thermodynamic stability  and mutational robustness . subsequently, after pressing the "start" button, the rnaexinv program is executed several times and for each a designed sequence is constructed by the method described above. basically, rnaexinv takes the structure, minimum free energy and neutrality values and constructs the rna sequence that adheres to the three constraints most tightly . furthermore, the local search parameters can be customized to fit the particular needs of the run. there are three parameters inside the program that can be fine tuned in order to improve the local search fitness for a particular run:

1) the number of minimization steps . increasing the number of steps will definitely increase cpu time but might increase the goodness of the results until a point when it will stride in the same local minimum.

2) the maximum distance of the look ahead . increasing it will increase cpu time but might help the local search overcome shallow local minima.

3) trying to tie the ends of the structure together .

setting each parameter can influence the accuracy of rnaexinv result and the time to complete the run. each user needs to balance the cpu time dedicated for each run and the number of repetitive runs. on the one hand, without enough cpu time for each run, the runs will not exploit their full potential. on the other hand, with too much cpu time for each run, the time will be wasted running in circles around the same minimum instead of starting from a different point to better examine the landscape.

the output of rnaexinv is demonstrated in figures  <dig> and  <dig>  figure  <dig> illustrates the main window containing a list of designed sequences that are generated by multiple runs of the rnaexinv program. the scores on the right indicate the tree-edit distance between the predicted secondary structure of the designed sequence and that of the input. next, the user can interactively view essential information by clicking on each of the designed sequences. figure  <dig> is an illustration of the window provided for a particular designed sequence. relevant secondary structure and accompanied information consists of a graphical drawing for both the given initial structure and the predicted secondary structure of the designed sequence, along with its computed minimum free energy and neutrality values.

we compared our suggested extension with the standard  inverse rna folding problem, in particular against rnainverse  <cit> , without loss of generality . the comparison depicted in figure  <dig> was performed for an mir- <dig> example test case taken from  <cit> , after it was verified in  <cit>  by taking a collection of mirnas from the microrna registry  <cit>  that mirna precursors are significantly more thermodynamically stable and mutationally robust than random rnas. therefore, even though from an initial inspection of the structure drawings in figure  <dig> it may appear that the rnainverse result is in better agreement to the wild-type than the rnaexinv result, it should be noted that the values of the thermodynamic stability and mutational robustness of mir- <dig> are not taken into account when designing sequences with rnainverse. in contrast, the sequences designed using rnaexinv possess highly similar values of thermodynamic stability and mutational robustness to that of the wild-type, potentially overweighing the better structural similarity achieved with rnainverse for at least some problem specific applications . as for the computational effort, rnainverse and info-rna are considerably more efficient than rnaexinv, which is expected because the latter solves a much more demanding problem from the computational perspective. on a standard pc, the example in figure  <dig> took  <dig>  seconds using both rnainverse and info-rna, while it took  <dig> seconds for rnaexinv to calculate its result. however, the notable advantage of our more efficient method described and implemented here over the method proposed in  <cit>  is that we managed to compute the extended inverse rna folding in minutes on a standalone pc, for sequences in the length order of about  <dig> nt, instead of days on a parallel platform as previously attempted in  <cit> . finally, in addition to the mirna example shown in figure  <dig>  the p5abc subdomain example described in  <cit>  was taken and for the relevant stochastic methods, the averages and standard deviations of the mutational robustness and thermodynamic stability were calculated over  <dig> runs. the results are reported in tables  <dig> & <dig>  they provide further evidence for the benefit of rnaexinv when target  values for mutational robustness and thermodynamic stability are given.

reported values of averages and standard deviations over  <dig> runs with the methods compared, for mutational robustness  and thermodynamic stability , performed on the mir- <dig> example shown in figure  <dig> 

reported values of averages and standard deviations over  <dig> runs with the methods compared, for mutational robustness  and thermodynamic stability , performed on the p5abc subdomain example described in  <cit> .

CONCLUSIONS
in examining its biological relevance, rnaexinv can be used for designing sequences that adhere to the extended inverse rna folding problem suggested in  <cit> , but in practical cpu time. the implementation described here that is closer in type to previous related work for inverse rna folding  <cit>  is significantly more efficient than the parallel evolutionary computation implemented in  <cit> . from the illustrated example we can conclude that rnaexinv is able to design sequences that will not be taken into account by currently available programs for solving the inverse rna folding problem, yet they will contain better features in terms thermodynamic stability and mutational robustness  to mimic favorable properties of natural rna sequences. rnaexinv successfully runs in concert with the vienna rna package that can be downloaded from http://www.tbi.univie.ac.at/~ivo/rna and is freely available for download in http://www.cs.bgu.ac.il/~rnaexinv.

availability and requirements
project name: rnaexinv

project home page: http://www.cs.bgu.ac.il/~rnaexinv

operating system: web access: not applicable, stand-alone: linux

programming language: c, java

other requirements: stand alone:java  <dig> . <dig> or higher, gnu c compiler

license: none

any restrictions to use by non-academics: none

competing interests
the authors declare that they have no competing interests.

authors' contributions
db and aa conceived the study, coordinated and participated in software design and drafted the manuscript. ac worked on software design, carried out development and implementation, and participated in drafting the manuscript. all authors read and approved the final manuscript.

