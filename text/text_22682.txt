BACKGROUND
current next-generation sequencing  technologies have provided biologists with an unprecedented scale of genomic data that require analysis  <cit> . instead of reporting a single expression value for each transcript in array-based profiling technologies, ngs technologies can reveal the read count variation within a transcript at the base level. such a base-level read coverage provides further insights for analyzing alternative mrna splicing, single-nucleotide polymorphism , novel transcript discovery, etc  <cit> .

constructing a base-level read coverage requires alignment of numerous reads on the reference genome. read alignments are difficult to interpret by human. many ngs viewers, such as artemis  <cit> , savant  <cit> , tablet  <cit>  and integrative genomics viewer   <cit> , have been developed to visualize read alignments into friendly graphic profiles. some of these ngs viewers can depict a base-level read coverage but only in a small scale; while some of them provide a genome-wide read coverage but not at the base level. to our best knowledge, none of existing ngs viewers can timely visualize a genome-wide base-level read coverage in an interactive environment. the considerable data scale and computational complexity pose a challenge to develop such tools.

to address this challenge, this study proposes an efficient visualization pipeline for ngs data and implements a lightweight read coverage viewer, light-rcv, with the proposed pipeline. the pipeline consists of four featured designs on the path from read alignments to the final visualized read coverage. the four designs are critical to immediate visualization  of a base-level read coverage. light-rcv was implemented as an offline program with web technology. most researchers prefer not to upload their ngs data to a remote server. an offline program fulfills this requirement. on the other hand, web technology was chosen because it is suitable for embedding in other web-based ngs tools and is familiar to most biologists. other offline ngs tools also can embed light-rcv on top of a native browser component, which is supported by major programming languages such as the webbrowser class in c#, c++, f# and vb, the webview class in java , the webview class  and the uiwebview class  in objective-c.

RESULTS
this section introduces the interface of light-rcv and reports the results of a performance evaluation. finally, the results of a case study are presented.

user interface
to see the read coverage of a specific genomic range, the first step is to choose a compiled ngs data with the sample control ). the package of light-rcv attaches a compiled sample, demo-yeast, for users who have no ngs data at hand to experience light-rcv. the second step is to specify a genomic range either by a coordinate range  or by a gene name ). this alternative is decided by the range by control ). in practice, users need not to actually change the range by control, which changes accordingly whenever users change the coordinate or gene control. light-rcv provides many facilities to make controls behave naturally. for example, the coordinate start and end are automatically switched when the start is larger than the end. genes can be specified by a gene symbol, name and alias. while typing, users can see the full gene names that fit the current input and select the desired one, namely "auto completion." after the genomic range is selected, clicking the view button ) brings the read coverage ) in that range. this can also be done by pressing the enter key in keyboard. clicking the export button ) saves the current view to an image file.

light-rcv shows three read coverages: total for reads aligned to both positive and negative strands in each position; positive strand for reads aligned to the positive strand; negative strand for reads aligned to the negative strand. below the three read coverages is a bar chart for the mismatch rate  of each position ), which is useful for detecting snps. the four tracks of information  can be shown/hidden by the legends ). below the four tracks is an annotation track ). when mouse hovers over a position, more detailed information are shown ). note that the composition information is shown when the viewing range is smaller than about  <dig> bps . zooming in can be done by simply dragging in the chart or by the navigation bar ). the latter provides intuitive navigational operations .

finally, users can click the settings button ) to show the controls for the compilation stage ). to compile an ngs experiment, one has to specify four data: i) sample id for identification, which would be shown in the sample control ); ii) sam file, which contains the alignments of ngs reads on a reference genome; iii) reference file, which is a fasta file containing the sequence of the reference genome; iv) gtf file, which contains gene coordinates and annotations. the gtf file is optional but is required for many controls such as figure  <dig> and . in light-rcv, specifying a gtf file is recommended. after specifying the data, clicking the compile button starts the compilation stage. the status is shown in the status control and the sample id is shown in the sample control after the compilation succeeds.

performance evaluation
this subsection compares the response time of light-rcv and three popular offline ngs viewers. table  <dig> shows the results, where values in parentheses indicate that the corresponding ngs viewer did not display a base-level read coverage. savant and igv do not display read coverages for genomic regions larger than  <dig> kilo base pairs  and  <dig> kb, respectively. tablet shows only summarized read coverages in which the read counts of  <dig> genomic positions are averaged to a value. these settings/limitations were designed for short response time and good user experience . light-rcv, on the other hand, aimed to achieve a shorter response time without these limitations.

1time required by the compilation stage of light-rcv. other ngs viewers did not have this stage. 2time required when the user chooses an ngs data in viewers. 3time required when the user specifies a genomic region, which is critical to user experience. *the viewer does not show read coverage at these region.

time is measured in seconds. values in parentheses indicate that the corresponding ngs viewer did not display a base-level read coverage. tablet shows a summarized read coverage in which the read counts of  <dig> genomic positions are averaged to a value.

the first two sections in table  <dig>  stand for the time required to prepare an ngs data. the preparation time of light-rcv was longer than those of other ngs viewers, which is reasonable because light-rcv moves as many computations as possible to this stage. notably, the preparation of light-rcv is conducted only once for an ngs experiment, while other ngs viewers have a startup delay of three to ten seconds whenever users load an ngs experiment. in addition to the startup time, the ux of an ngs viewer relies more on the response time of each genomic range change, which corresponds to "per visualization of a genomic region" in table  <dig>  the response time of light-rcv was less than half second  <cit>  regardless of the genomic range. strictly speaking, the read coverage in a large genomic range was not at the base level because of the limitation of screen resolution. light-rcv smartly detected the screen width and returned only necessary data points. in this regard, screen width is a factor of the response time of light-rcv. the numbers in table  <dig> were measured in a 1920x <dig> screen, which is a rather big screen in contemporary personal computers. the ux studies have shown that the response is considered immediate when the delay is shorter than half second. namely, users feel immediate response after specifying a genomic region in light-rcv. this immediate response time is shorter than those of igv and tablet in a genomic region smaller than a kilo base pairs  and that of savant on a genomic region smaller than  <dig> kb.

the efficiency of the entire process of converting the raw data to the final visualized read coverage can be estimated by amortizing the preparation time to each genomic position . the amortized time of a  <dig> kb region in light-rcv was  <dig> s , which is faster than the compared ngs viewers. this explains that the long preparation time of light-rcv was due to computation arrangement but not performance deficiency. table  <dig> shows that light-rcv consumed the same scale of memory of other ngs viewers, which reveals that the speed of light-rcv did not require the cost of a large cache. the efficient read coverage construction algorithm is the key to the amortized time. furthermore, the two-stage architecture and the design of the internal format  enabled an immediate response time.

the memory unit is megabyte . 1size of the genomic region to be visualized. values in parentheses indicate that the corresponding ngs viewer did not display a base-level read coverage, where tablet shows summarized profiles in which the read counts of  <dig> genomic positions are averaged to a value. *the viewer does not show read coverage at these regions.

1one point of tablet read coverage curve represents  <dig> bps. 2savant and igv do not show read coverage when the viewing range is greater than  <dig> kb and  <dig> kb, respectively. 3savant and igv claimed to have multi-resolution model for all data types according to their documents. however, they did not clearly indicated that read coverage is included. multi-resolution model is not visible to users. instead, this technique is used to expedite visualization at all scales of viewing ranges. the time comparison under different viewing ranges in table  <dig> provides a performance evaluation of the multi-resolution model. this model is a key to achieve both base-level read and whole chromosome read coverage in light-rcv. however, the reasons why savant and igv limited the viewing range of read coverage are unknown. 4embeddable is also not visible to regular users but is useful for developers.

case study
this subsection demonstrates a practical usage flow to show the importance of visualizing read coverage. this case was provided by our collaborative research group, which has used light-rcv for several months to analyze ngs data.

the operator began the workflow from a read coverage at the whole chromosome level . at this level, one might be attracted by the most sharp peaks . however, these peaks are easily identifiable by almost all analysis tools. in practical analyses, on the other hand, the operator was interested in less obvious peaks  and analyzed them individually. in this case study, the area of the solid green circle was chosen.

after zooming into the ~2m area , the operator identified a peak with a read count higher than  <dig> . the operator further zoomed into the peak. in this ~47k area , the transcript annotations were shown. the operator got three clear read coverage peaks  and had some transcript candidates  according to the annotation track below the read coverage. cuffdiff  <cit> , one of the most widely used software for calculating gene expression from ngs data, incorrectly assigned these reads to gene nop <dig> since the read coverage peaks were consistent with some exons  of nop <dig>  with the aid of the visualized read coverage, the operator quickly determined that the read count of nop <dig> was a false positive. many ngs viewers provide automatic analysis. however, for cases that need visualized read coverage, short response time is more important than comprehensive analyses.

the operator then zoomed into the right two peaks  and obtained a ~1k area, figure 2d. at this level, the operator can see the shape of the read coverage. the irregular shape of the right transcript  attracted the operator.

finally, the journey ended at a  <dig> bps area , which reveals two facts. first, the boundaries of the read coverage peak were several bases smaller than those of the transcript rf <dig> . this reveals that the quality of the read alignments  was relatively low at the ends of the transcripts. second, there is a shorter transcript, snord <dig>  that overlaps with rf <dig> . the read coverage curve in figure 2e has a clear decrease near the green circle, which is perfectly matched with the boundary of snord <dig>  this reveals the difficulty of automatically assigning read counts in areas with overlapped transcript annotations. manual determination with the aid of a visualized read coverage, is a compromise solution for this problem at present.

in this case study, transcript rf <dig>  and snord <dig> are basically the same transcript after the operator queried other databases such as ensembl  <cit> . therefore, this can be easily solved by the operator or, in another words, these is no need to solve. however, if the overlapped transcripts are different, the operator must conduct further analyses. the further analyses are various  and beyond the scope of this study.

in summary, light-rcv provides a convenient tool for warning operators about these issues. the above workflow heavily relies on manual efforts. most members of our collaborative research group agreed that the immediate response time of light-rcv was critical for everyday analyses.

CONCLUSIONS
this study proposed four designs on visualizing read counts of each genomic position. this efficient visualization pipeline was implemented as a lightweight read coverage viewer, light-rcv, which aims at timely visualizing genome-wide base-level read coverages in an interactive environment. it achieved immediate response time and outstanding amortized time.

