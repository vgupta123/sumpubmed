BACKGROUND
in the case of homozygous genotypes, such as maize or many other inbreeding crop species, haplotypes can be directly drawn from comparison of the amplified genomic sequence at a given locus between different individuals  <cit> . difficulties arise if homozygous genotypes are not available, for example, in non-inbred, tetraploid potato  <cit> . in such cases, it is necessary to determine the haplotype phase from unphased snp  data. there are several approaches for inferring haplotypes, based on  statistical methods, such as the em algorithm and gibbs sampling or  the parsimony principle  <cit> . these approaches have, however, been developed for biallelic and diploid species. there is currently no software available for haplotype identification in more complex polyploids  <cit> . in the case of autotetraploids  <cit> , one has to tackle more phase-unknown alleles than in diploids, which results in a combinatorial explosion of possible haplotypes.

in this study, we aimed at the development and evaluation of a generalised approach for calculating haplo-types in polyploid species using the parsimony principle. the goal of haplotype inference is to find a set of haplotypes explaining every genotype present in a given unphased population. the parsimony principle can be used to find the smallest set of haplotypes, such that each genotype in the population can be explained by a ploidy-specific number of haplotypes from the set of haplotypes. the objective of minimising the number of haplotypes explaining a snp data set is called haplotype inference by pure parsimony   <cit>  and was shown to be np-hard  <cit> . lynce and marques-silva recently formulated the problem as an instance of the boolean satisfiability problem, called sat  <cit> , that can be solved orders of magnitude faster than the existing ilp  formulation  <cit> . unfortunately, the sat formulation is also restricted to unphased biallelic snp data of diploid species. here, we present a generalisation for polyploids of the sat approach developed by lynce and marques-silva  <cit> . this generalisation resulted in the development of the satlotyper software tool. we tested and evaluated satlotyper with simulated and experimental data sets of unphased snp sites from a specific potato locus. snp data were obtained from different populations of tetraploid individuals. for a subset of individuals, we compared the computed haplotypes with experimental haplotypes identified by amplicon cloning and sequencing  <cit> .

implementation
first, basic terms are defined and the basic problem is formulated. then, the sat model for biallelic polyploids is presented. this is followed by the extension of the model to polyploid and polyallelic snp sites. after that, constraints are given for breaking symmetries in haplotypes and genotypes. constraints are also formulated for alternative most parsimonious sets of explaining haplotypes as well as for alternative inferences of genotypes. a bootstrapping procedure for scoring haplotypes and a method for optimising alternative genotype inferences based on these scores is presented. afterwards, lower and upper bounds of the most parsimonious explanation are mentioned and the definition of a norm for comparing genotypes is given. finally, the realisation of satlotyper is considered.

basic definitions
the genome of every higher developed species, whether animal, plant or fungus, is based on a species-dependent number of homologous sets of chromosomes. the number of sets ranges from at least one set as it is found in yeast, which is a haploid species, followed by two sets in human  to much bigger numbers like four sets  in some varieties of the potato  or six homologous sets  in wheat . the strawberry  can even have eight sets . chromosomes are sequences over the nucleotide alphabet, where the position of a specific nucleotide on the chromosome is called site or locus .

single nucleotide polymorphism or snp is a dna sequence variation, occurring when a single nucleotide is altered  <cit> . thus, a site in a population of a species is a snp site if at least a second sort of nucleotide occurs at this site at least once.

an allele is a different form of some segment of a chromosome, such as a second sort of nucleotide at a snp site. here, we focus on snp sites. a snp site that contains two different alleles is called biallelic, a snp site that contains three different alleles is called triallelic and a snp site that contains four different alleles is called tetraallelic.

a haplotype is the genetic constitution of a sequence of nucleotides  <cit> . the underlying data that forms a haplotype can be the full dna sequence in the region, or more commonly the snp sites in that region  <cit> . polyploid organisms contain two or more homologous haplotypes.

a genotype describes the conflated data of a set of homologous haplotypes. in other words, an explanation for a genotype is a ploidy-specific number of homologous haplotypes. an unphased genotype is a genotype for which no set of explaining haplotypes is defined. there are, however, many possible sets of haplotypes explaining one given unphased genotype. a phased genotype is a genotype for which at least one set of explaining haplotypes is defined. if for a given site all explaining haplotypes have the same value, then the genotype is said to be homozygous at that side. otherwise the genotype is said to be heterozygous at that side.

problem formulation
a snp site of an individual is a string over the nucleotide alphabet Σ = {a, c, g, t} with size determined by the ploidy of the considered species. a sequence of such snp sites defines a genotype, with the number of snp sites as the length of the genotype. let n denote the number of individuals in the sample, m be the number of snp sites, and p be the ploidy of the considered species. furthermore, a specific genotype is denoted by gi, with  <dig> ≤ i ≤ n, and for a specific site j, with  <dig> ≤ j ≤ m, in gi we use gi, j. finally, let gi,jl with  <dig> ≤ l ≤ p, denote the lth state at site j in genotype i. given a set g of n genotypes, each of length m, the haplotype inference problem is that of finding a set h of not necessarily distinct haplotypes. furthermore, for each genotype gi ∈ g there is at least one set of p haplotypes {h <dig>  ..., hp} ∈ h such that gi is explained by {h <dig>  ... hp}. the values of nucleotides are determined by the number of different alleles at the corresponding snp site: for a biallelic snp site the values are { <dig>  1}, for a triallelic snp site the values are { <dig>   <dig>  2}, while for a tetraallelic snp site the values are { <dig>   <dig>   <dig>  3}. thus, a specific haplotype hk is a string over the alphabet { <dig>   <dig>   <dig>  3}, with  <dig> ≤ k ≤ |h|.

polyploid genotypes are represented by sequences of m vectors, where the vectors encode the snp sites of the given individual. the vectors are of size p and contain alphabetically sorted elements of the alphabet defined by the corresponding snp site . for instance, a tetraallelic snp site of a tetraploid individual  which is homozygous is encoded as a vector , ,  or  depending on the allele found at the given site of the individual. a tetraallelic snp site of a tetraploid individual at which two alleles occur twice is encoded as a vector , , , ,  or  .

in this table all possible allele compositions for snp sites in a tetraploid species are given. at tetraallelic snp sites homozygous, biallelic, triallelic and tetraallelic individuals are possible. in contrast, at triallelic snp sites only homozygous, biallelic and triallelic individuals are possible. additionally, encodings that contain a fourth allele are not possible anymore. the number of possible allele compositions at biallelic snp sites decreases analogously.

note that the presented encodings hold only for tetraploid species. in general, the number of possible encodings increases exponentially with increasing ploidy. the increase is driven by all possible partitions of the ploidy using four summands for a tetraallelic individual, three summands for a triallelic individual and two summands for a biallelic individual. for instance, there are  <dig> different partitions for a biallelic site of a tetraploid individual:  <dig> +  <dig> =  <dig> and  <dig> +  <dig> =  <dig>  then there are 2! =  <dig> different encodings for the first partition and 2!2! =  <dig> different encodings for the second partition. this makes  <dig> different encodings in total if this snp site is biallelic . if the snp site is triallelic, the number of encodings is multiplied by the number of two alleles chosen from three possible alleles: 3· =  <dig> . if the snp site is tetraallelic, the number of encodings is multiplied by the number of two alleles chosen from four possible alleles: 3· =  <dig> .

a tetraallelic snp site of a tetraploid individual at which two alleles occur once and a third occurs twice is encoded as a vector , ,  or  . finally, there is only one possible encoding for a tetraallelic snp site of a tetraploid individual at which all four alleles occur: . triallelic and biallelic snp sites are encoded accordingly as presented in table  <dig>  then, explanation of a genotype is defined as: if p haplotypes explain an unphased genotype gi, the p haplotypes and the unphased genotype gi show the same allele composition at each snp site .

one of the approaches to the haplotype inference problem is called haplotype inference by pure parsimony  <cit> . a solution to this problem minimises the total number of distinct haplotypes used. the sat-based formulation of the hipp models whether there is a set h of r distinct haplotypes, with r = |h| haplotypes, such that each genotype gi ∈ g is explained by p haplotypes in h. the sat-based algorithm considers increasing sizes for h, from a lower bound lb to an upper bound ub  <cit> . trivial lower and upper bounds are, respectively,  <dig> and pn. the algorithm terminates for a size of h for which there are r = |h| haplotypes such that every genotype in g is explained by p haplotypes in h. the smallest r for which such a set h exists is a most parsimonious set of explaining haplotypes.

all variables of the boolean satisfiability problem are two-valued. depending on the truth assignment, a boolean formula is either true or false. then, sat consists of the determination if an assignment to a given boolean formula in conjunctive normal form  exists such that the formula evaluates to true, or the proof that such an assignment does not exist. solving sat is np-complete  <cit> . the boolean satisfiability problem for hipp, however, can efficiently be solved  <cit>  by sat solvers such as minisat  <cit> , miraxt  <cit>  or sat4j  <cit> . this may be explained by a unknown hidden structure in the genotype data, which makes the problem easier to solve.

sat model for biallelic polyploids
the first sat formulation for hipp was introduced in  <cit>  and the presented constraints were implemented in the software ships  <cit> . unfortunately, this approach is restricted to diploid and biallelic species. here, we extend the formulation of constraints from  <cit>  to polyploid biallelic populations of genotypes. in a tetraploid, biallelic population of genotypes, the possible alleles are modeled by  <dig> or  <dig> respectively , gi,j <dig> =  <dig>  gi,j <dig> =  <dig>  gi,j <dig> =  <dig> and gi,j <dig> = 1). furthermore, the haplotypes can be modeled such that hk, j ∈ { <dig>  1}, where hk, j denotes the jth site of haplotype k. a haplotype hk can then be viewed as a binary word hk, <dig> ... hk, m of length m over the alphabet { <dig>  1}.

for a given value of r, the model considers r haplotypes and aims at finding p haplotypes  with each genotype gi. as a result, for each genotype gi, the model uses selector variables for selecting which haplotypes are used for explaining gi. since the genotype is to be explained by p haplotypes, the model uses p sets of r selector variables, sk,il. hence, genotype gi is explained by haplotypes hk <dig> ...,hkp,if sk <dig> i1= <dig> ...,skp,ip= <dig> 

if the sum of the elements of binary vector gi, j equals  <dig>  then gi,jl =  <dig>  with  <dig> ≤ l ≤ p. then the model requires that the following is satisfied:

  , 

where  <dig> ≤ k ≤ r and  <dig> ≤ l ≤ p. hence, if haplotype k is selected for explaining genotype i, by at least one of the p representatives, then the value of haplotype k at site j must be  <dig>  if the sum of the elements of binary vector gi, j equals p, then gi,jl =  <dig>  with  <dig> ≤ l ≤ p. then the model requires that the following is satisfied:

  , 

where  <dig> ≤ k ≤ r and  <dig> ≤ l ≤ p. hence, if haplotype k is selected for explaining genotype i, by at least one of the p representatives, then the value of haplotype k at site j must be  <dig> 

otherwise, if the sum of the elements of binary vector gi, j does not equal  <dig> nor p, one requires that the haplotypes explaining genotype gi show the corresponding number of 1s and 0s at site j. this is achieved by creating p variables gi,j <dig> ...,gi,jp where gi,jl ∈ { <dig>  1}, which represent the possible arrangements of 1s and 0s at site j. in the diploid situation, the model requires two clauses in cnf:

  ∧. 

formula  <dig> evaluates to true iff one of the possible allele arrangements of a heterozygous and diploid snp site is assigned to the boolean variables. thus, the formula is equivalent to the enumeration of all possible allele arrangements at the given snp site, where an arrangement is given as conjunction of literals and all arrangements are connected by disjunctions :

  ∨. 

for p >  <dig> it is also straightforward to formulate the corresponding constraints in a disjunctive normal form  by enumerating all allele arrangements analogously to formula  <dig>  each formula in dnf can be transformed into an equivalent formula in cnf  <cit> . as a result, for the case where gi, j is a heterozygous snp site, then the model requires that the following is satisfied:

  ∧, 

where  <dig> ≤ k ≤ r and  <dig> ≤ l ≤ p. for each i and l, it is necessary that exactly one haplotype is used, and so exactly one selector variable be assigned value  <dig>  for  <dig> ≤ l ≤ p, this can be captured with cardinality constraints:

  . 

these sums can be formulated in cnf by the utilization of an additional variables dk,il which corresponds to the boolean state if a haplotype was already selected. the model requires that the following is satisfied:

  d <dig> il⇔s <dig> il¬dk,il∨¬sk+ <dig> il2≤k≤r−1dk+ <dig> il⇔1≤k≤r−1dr,il= <dig>  

where  <dig> ≤ l ≤ p. figure  <dig> illustrates how the variables are used for explaining unphased genotypes.

efficient method for obtaining the model for biallelic polyploids
for the case p >  <dig>  it is straightforward to formulate the constraints for the gi,jl variables from heterozygous snp sites in dnf by enumerating all allele arrangements. each formula in dnf can be transformed into an equivalent formula in cnf using tseitin's transformation  <cit> . however, the enumeration of all arrangements is of exponential complexity. our objective here is to find an equivalent representation of enumeration of arrangements. this representation is to be in cnf and to allow formulation in polynomial time. combinatorial problems as described above can also be represented by sums. for instance, for an individual from a tetraploid species with two  <dig> and two  <dig> alleles at a biallelic snp site, all six allele arrangements are determined if the sum of the elements of a binary vector that represents the allele composition is constrained to 2: , , , ,  and .

in the following, we combine simple logical circuits, such as half adders and full adders to derive general summation constraints which can be formulated in polynomial time. the usage of one full adder allows the summation of two bits where a full adder consists of two half adders. formula  <dig> gives constraints for a half adder, where a and b are two bits which have to be summed, c is the resulting carry over and shalf the resulting sum. based on a half adder the constraints for a full adder can be derived as given in formula  <dig>  variable sfull is the complete sum of the two bits a and b, where the variable c <dig> is the resulting carry over. variable c <dig> represents an additional bit that is added to the sum of a and b. thus, the total sum of a, b and c <dig> is at least  <dig> and at most  <dig>  the first bit of the result is stored in sfull and the second bit in c <dig> 

  ⇔c¬∨¬)⇔shalf 

  ∨)⇔c2∧)⇔sfull 

the c <dig> carry over of a first full adder may be connected with the c <dig> carry over of a second full adder. analogously, the c <dig> carry over of the second full adder may be connected with a third full adder and so on. if w full adders are connected in this way, the result represents a ripple carry adder that is able to sum up two w bit words. to describe the necessary w carry overs, the model requires that the following is satisfied:

  ∨)⇔ct+ <dig>  

where t =  <dig>  ..., w -  <dig>  analogously, to describe the necessary w full adders, the model requires that the following is satisfied:

  ∧)⇔sfullt, 

where t =  <dig>  ..., w. the number of necessary bits is at most w = ⌊log <dig> p⌋ +  <dig> if the binary vector which is summed up has length p. thus, p +  <dig> different a vectors and p different b, c and sfull vectors are needed. furthermore, the sfulll,t variables are replaced by the al+ <dig>  t variables such that only the ap+ <dig>  t vector is left for constraining the sum, where  <dig> ≤ l ≤ p and  <dig> ≤ t ≤ w. it follows that summing can be represented as shown in figure  <dig> 

a simplification is achieved if vector cl, <dig>  where  <dig> ≤ l ≤ p,  contains the possible allele arrangements  <cit>  and the a vectors store the accumulation of the sum. in this situation, all b variables can be set to zero. the constraints of carry overs reduce to:

   ⇔ cl, t+ <dig>  

where  <dig> ≤ l ≤ p. additionally, if sfulll,t variables are replaced by al+ <dig>  t variables, the sums reduce to:

   ∧ ) ⇔ al+ <dig>  t, 

where  <dig> ≤ l ≤ p. reformulating the constraints from formula  <dig> into cnf yields the following for the carry overs:

  ∧∧. 

by reformulating the constraints from formula  <dig> into cnf, we obtain the following expression for the sums:

  ∧∧∧. 

for each individual and snp site in a biallelic population, variables corresponding to a and c need to be defined. let variables ai,jl,t, with  <dig> ≤ l ≤ p +  <dig> and  <dig> ≤ t ≤ w, denote the accumulation of the sum.

additionally, let variables ci,jl,t, with  <dig> ≤ l ≤ p and  <dig> ≤ t ≤ w, stand for the carry overs. for a snp site j from genotype i, summing constraints can easily be obtained by replacing the ci,jl, <dig> variables with the gi,jl variables  <cit> , with  <dig> ≤ l ≤ p. finally, the ai,jp+ <dig> t variables, with  <dig> ≤ t ≤ w, are constrained to the binary representation of the required sum.

extension to sat model for polyallelic polyploids
in this and the following sections we use notation 2y to mean the yth bit of the binary encoded number x. furthermore, we use a function b to substitute variables:

  b={aif b=1¬a,otherwise. 

dependent on the input, function  <dig> defines if the substituted variable is negated.

the gi,jl variables are insufficient for describing arrangements of more than two alleles at a snp site. the representation of, for instance, three different states needs at least two bits. we define oj as the number of different alleles from all individuals at snp site j of a population of genotypes. if oj >  <dig>  the representation of the snp site is extended to wj = ⌈log <dig> oj⌉ binary columns. thus, gi,jl is split to gi,jl, <dig> ...,gi,jl,wj. each allele is encoded by its corresponding binary number. for instance, the four alleles  <dig>   <dig>   <dig> and  <dig> at a tetraallelic snp site are encoded as  <dig>   <dig>   <dig> and  <dig>  respectively. the haplotypes are then extended analogously, such that hk,j∈{ <dig> }wj denotes the jth site of haplotype k.

for generalisation to polyallelic snp sites, the formulation of binary sums can be reused. let zi,juj be the number of allele uj at a specific snp site j in unphased genotype i, where  <dig> ≤ uj ≤ oj. the value of oj can be greater than p but ∑uj=1ojzi,juj=p. for a set of nucleotide sequences, it holds that oj ≤  <dig> 

for each individual and snp site, oj vectors vi, j of length p are defined. variable vi,jl,uj is set to  <dig> if allele uj is represented at position l by its corresponding binary number:

  12)∧b22)∧⋮b2wj))⇔vi,jl,uj, 

where  <dig> ≤ l ≤ p and  <dig> ≤ uj ≤ oj. it is necessary to formulate the sums ∑l=1pvi,jl,uj which must equal zi,juj, as described in the previous sections such that each allele at snp site j occurs zi,juj times in genotype i.

an example is shown in figure  <dig>  generally, at a given snp site of an individual, there can be at most p different alleles, even if the number of alleles in the population at this site is oj > p. thus, only the constraints for p sums have to be given.

in variables vi,jl,uj, with  <dig> ≤ l ≤ p, the arrangements of allele uj are represented, where allele uj is encoded as  <dig> and all other alleles are encoded as 0s. in contrast, the gi,jl,tj variables, with  <dig> ≤ l ≤ p and  <dig> ≤ tj ≤ wj, represent the arrangements of all alleles at the given snp site. it is still necessary that the correct haplotypes hk <dig> ...,hkp are chosen to explain the alleles at gi, j. then the model requires that the following is satisfied:

  ∧, 

where  <dig> ≤ tj ≤ wj,  <dig> ≤ k ≤ r and  <dig> ≤ l ≤ p.

the final  number of haplotypes is denoted by rf and the maximal number of alleles, which is found at a snp site of the considered population, is denoted by omax. then, if p log <dig> p ≤ rf log <dig> omax, the number of variables  and constraints in the proposed model is, respectively, o and o . the complexity for the variables and constraints decreases to o and o if the nucleotide alphabet is considered.

the complexity of the presented model is listed below. variable rf is the final value of r. the maximal number of alleles, which is found at a snp site of the considered population, is denoted by omax. the number of variables is o. if p log <dig> p ≤ rf log <dig> omax, the number of constraints is o.

constraints for breaking symmetries in haplotypes
it is important to note that the model proposed above is not practical for most existing problem instances, even with the most efficient sat solvers  <cit> . this problem, however, can be solved by breaking symmetries to prune the search space. as described in  <cit> , symmetries in explaining haplotypes can be broken by sorting the haplotypes lexicographically. a strict lexicographic ordering can be achieved by the formulation of constraints that become true if h <dig> is strictly smaller than h <dig>  h <dig> is strictly smaller than h <dig>  and so on. if the ordering is not strict it is not guaranteed that all explaining haplotypes are pairwise distinct.

for the ordering, hk, j is compared with hk+ <dig>  j, where  <dig> ≤ k ≤ r -  <dig> and  <dig> ≤ j ≤ m. additionally, new variables ek, j have to be introduced, which record the value of hk, j <hk+ <dig>  j. then, the model requires that the following is satisfied:

  ⇔ek,m∧∨ek,j+1)⇔ek,j∧ek,1= <dig>  

where  <dig> ≤ j ≤ m +  <dig>  if an ek, j becomes true because the constraint hk, j <hk+ <dig>  j is satisfied, it is not necessary to compare hk, j' to hk+ <dig>  j', where j' <j. we must, however, ensure that hk, j' ≤ hk+ <dig>  j', where j' > j. then, the model requires that the following is satisfied:

  , 

where  <dig> ≤ j ≤ m. if an assignment can be found such that all clauses in formulas  <dig> –  <dig> are true, where  <dig> ≤ k ≤ r -  <dig>  the haplotypes are in lexicographical order.

constraints for breaking symmetries in genotypes
haplotypes that infer a genotype can be lexicographically ordered in a way similar to the set of r explaining haplotypes  <cit> . the lth haplotype inferring an unphased genotype i is marked by a binary variable sk,il. the sum ∑k=0rsk,il is constrained to equal  <dig> so that exactly one haplotype is selected for explaining the lth row of gi. in contrast to the most parsimonious set of explaining haplotypes, the selection variables have to be ordered non-strict lexicographically since homozygous genotypes can not be explained by sets of pairwise distinct haplotypes.

as a result, the p selection vectors of each genotype gi can be ordered lexicographically by constraining the vectors by si1≤si2≤…≤sip−1≤sip <cit> . for this purpose, the constraints of ordering the haplotypes are reused and slightly changed. new variables fk,il have to be introduced, which record the value of sk,il<sk,il+ <dig>  then, the model requires that the following is satisfied:

  ⇔fr,il∧∨fk+ <dig> il)⇔fk,il, 

where  <dig> ≤ k ≤ r +  <dig>  if an fk,il becomes true because the constraint sk,il<sk,il+ <dig> is satisfied, it is not necessary to compare sk′,il to sk′,il+ <dig>  where k' <k. we must, however, ensure that sk′,il≤sk′,il+ <dig>  where k' > k. then, the model requires that the following is satisfied:

  , 

where  <dig> ≤ k ≤ r. because it is almost the formulation of a strict lexicographic order, except that the variable f <dig> il does not have to be true, it has to be relaxed to become a non-strict order. this can be done by formulating the constraints for either vector sil is strict smaller than vector sil+ <dig> or both vectors are equal.

finally, the model requires that the following is satisfied:

  ∨f <dig> il, 

where  <dig> ≤ k ≤ r. if an assignment can be found for which all clauses in formulas  <dig> –  <dig> are true, where  <dig> ≤ l ≤ p -  <dig>  the selection variables of genotype gi are in non-strict lexicographic order.

constraints for alternative most parsimonious sets of haplotypes
there can be several most parsimonious sets of haplotypes which differ slightly and yet can explain the unphased genotype data. call hk,ji the set of previously found binary assignments to hk, j, where  <dig> ≤ i ≤ nalt and nalt is the number of previously found inferences. constraints for alternative most parsimonious sets of haplotypes can be easily formulated by the exclusion of previously found sets. then, the model requires that the following is satisfied:

  ¬∧b∧⋮b), 

where  <dig> ≤ k ≤ r and  <dig> ≤ i ≤ nalt. application of de morgan's laws to formula  <dig> results in formula 25:

  ∨¬b∨⋮¬b), 

a nice feature of constraining alternative haplotype inferences is that formula  <dig> is automatically in cnf.

constraints for alternative genotype inferences
given p explaining haplotypes, there can also be alternative inferences of genotypes. constraints of alternative genotype inferences are given similarly to the constraints of alternative haplotype inferences. call sk,il,j the set of previously found binary assignments to the selection variables sk,il of genotype i, where  <dig> ≤ j ≤ malt and malt is the number of previously found inferences. now consider only one previously found assignment to the selection variables of genotype i with sk <dig> i,i1= <dig> ...,skp,i,ip= <dig>  since it is sufficient to constrain selection variables to  <dig>  which were set to  <dig> in a previously computed inference, the already found explanations of all unphased genotypes are excluded by:

  ¬. 

application of de morgan's laws to formula  <dig> results in formula 27:

  . 

formula  <dig> is in cnf and no reformulation is necessary. such clauses have to be given for each previously found genotype inference j.

for constraining alternative genotype inferences, it is very important that genotype symmetries are broken as shown in section "constraints for breaking symmetries in genotypes". if symmetries are not broken, and if an assignment to the sk,il variables is excluded for a given unphased genotype gi, the sat solver can still report an assignment that represents a permutation of the excluded assignment. for instance, vector sil <dig> with length r is exchanged by vector sil <dig> with length r.

note that the number of alternative genotype inferences is equal to or greater than the number of alternative most parsimonious sets of haplotypes, since each alternative set of haplotypes defines at least one inference of genotypes. as a result, we do not calculate complete alternative genotype inferences in this study. instead, we introduce an optimisation method for genotypes, based on explaining haplotypes and bootstrapping .

bootstrapping
all possible minimal inferences are treated equally by the sat approach. it is unlikely that the first haplotype inference found is the most probable one under the assumed model and given data. it is also unlikely that the first haplotype inference is the inference with fewest differences compared to the real data. the question which haplotype inference should be taken for further analysis remains. there must be one or more inferences which are supported better by the input data. to introduce a quality measurement of the haplotypes and alternative inferences which have been calculated, a bootstrapping procedure is introduced as follows. bootstrapping is widely used  for estimating properties of an estimator. those properties are measured when sampling from an approximate distribution. one standard choice for an approximate distribution is the empirical distribution of the observed data. to use the bootstrap to assess the uncertainty of estimates of the phased genotypes, the data should be a series of independently sampled points. here, we assume that haplotypes are drawn independently from a most parsimonious set of explaining haplotypes which is the base of the population of genotypes. thus, the independently drawn haplotypes satisfy the independence assumptions of the bootstrap method.

from a set g of n given unphased genotypes, a new set of n unphased genotypes g′ is sampled by replacement . sampled sets g′ are inferred as described before, and each haplotype occurring in the inferences of the genotypes is added to a list. if a haplotype does not appear in the list, the haplotype and the number of its occurrences in the phased genotypes  are added to the list. otherwise, the former count of the haplotype in the list is increased by that number. for one g′, this procedure is defined as one bootstrap replicate. thus, the count of a haplotype, which is equivalent to a frequency, reflects its support by the input data and is defined as the haplotype's score. the process is repeated, and after a given number of bootstrap replicates, the corresponding counts of each haplotype occurring in the genotypes of an alternative haplotype inference are summed up. this sum is used to score the alternative haplotype inferences. the inference with the greatest score is assumed to be the one with the greatest support from the input data given the parsimony criterion.

optimisation of genotypes
based on computed alternative most parsimonious sets of haplotypes and bootstrapping scores, an optimisation of the phased genotypes can be computed . for each most parsimonious set of haplotypes the algorithm therefore computes all alternative inferences of each unphased genotype, independent of the others. as mentioned above, this method only works if symmetries in genotypes are broken . this procedure results in a list of alternative phased genotypes for each original unphased genotype. using the bootstrapping approach, each computed genotype is scored by the sum of the bootstrapping scores of its contained haplotypes. alternatively, without bootstrapping, the frequencies of the haplotypes in the phased genotypes of all computed alternative inferences can be used similar to bootstrapping counts. finally, from the alternative inference list of each genotype the highest scored genotype is selected in order to replace the former genotype in the inference. this forms a new inference of the original data with equal or better scoring.

the number of all alternative genotype inferences for a given most parsimonious set of haplotypes is the product of the alternative inferences of each genotype. moreover, the product of the number of alternative genotype inferences from each alternative most parsimonious set of haplotypes is the number of all valid most parsimonious hipps.

calculation of lower and upper bounds
in contrast to integer linear programming formulations of hipp  <cit> , the sat approach is not able to optimise a target function directly. thus, each possible number of explaining haplotypes has to be tested incrementally starting with r =  <dig>  methods for the computation of lower and upper bounds  <cit>  can be applied to avoid the iteration until a most parsimonious solution is found. furthermore, a lower bound can be used for reducing the size of the model  <cit> . genotypes which only can be explained by distinct sets of haplotypes are called incompatible. incompatible genotypes can be used for deriving a lower bound such that the size of the model can be reduced by eliminating s variables and corresponding clauses.

in the existing version of satlotyper, the computation of lower and upper bounds is not implemented. it was found empirically that, if the approach is able to find a most parsimonious set of haplotypes in reasonable time, it is also able to prove the unsatisfiability of smaller sets of haplotypes in reasonable time. nevertheless, it is not clear how large the increase in solvable instances would be if a calculation of lower and upper bounds were used in haplotype inference of polyploids. the computation of upper and lower bounds according to  <cit>  may be added to satlotyper in future versions.

comparing inferences with real data
to define a standard for the measurement of an inference of haplotypes and corresponding genotypes, we sum up the differences between genotypes from inference and corresponding genotypes from real data. the number of differences is defined as the distance d between both sets.

call gi = hk <dig> ...,hkp the inference of an unphased genotype by the sat approach and g′i={h′k′ <dig> ...,h′k′p} the real data for instance from simulation. every haplotype hk in the inference has a counterpart h′k′ in the real data set. the distance is defined recursively as shown in formula  <dig> and formula  <dig>  where dham is the hamming distance between hk and h'k'.

  d={ <dig> if g={}∨g′={}h∈g∧∀h′∈g′:dham+dotherwise 

  d = min ) 

the complexity of calculating d is exponential but for small p this is still possible.

software realisation
satlotyper is implemented in java and realises the constraints described above. additionally, there are some obvious improvements included in the program, such as converting the vi,jl,uj vectors, with  <dig> ≤ l ≤ p, to the corresponding boolean inverse if min = p - q, where q is the number of 1s. another improvement is the enumeration of constraints for a snp site such that instead of oj only oj -  <dig> sums have to be given if oj ≤ p.

the sat approach that we generalised  <cit>  can not optimise a target function directly . therefore, the sat formulation of an assumed number of explaining haplotypes has to be tested for satisfiability by the sat solver. if it fails, the number of explaining haplotypes is incremented and then tested again. this is repeated until the sat solver reports satisfiability. for unphased genotypes, given in csv format, the program generates corresponding constraints and writes the resulting formula in cnf format to the file system. next, the binary of the corresponding sat solver is executed with the newly generated cnf file as input. after successful termination of the solver, satlotyper reads, analyses and reports the output of the solver in xml format .

satlotyper is able to execute different sat solvers and was tested with minisat  <cit> , miraxt  <cit>   and sat4j  <cit>  but can be easily adapted to other solvers accepting standard cnf file format. access to single boolean variables is realised by a hash which contains corresponding matrices. this object allows indexing by means of the corresponding keyword, for instance "haplotype", for a given type of variable.

RESULTS
the following results were computed on a laptop with  <dig> mb ram and amd turion™  <dig> x <dig> mobile technology tl- <dig> . the operation system was a linux system ), kernel version  <dig> .18-5-amd <dig>  minisat  <dig>  was used for solving sat.

development of satlotyper
the presented generalisation of the original sat approach  <cit>  led to the development of satlotyper, which can infer polyploid and polyallelic input. the satlotyper algorithm is able to handle incomplete data sets where snp sites are partly missing, without bringing in unjustified assumptions. for instance, snp sites are missing when genotypes are heterozygous for alleles with indels  that may result in an interruption of analysable sequence data. unknown sites are marked "n". with the sat approach, no assumptions are made for individuals that contain snp sites with no information available, i.e. the formulation of constraints for the corresponding individual and snp site is omitted. if the formulation of constraints for a site is omitted, the sat solver uses a set of haplotypes inferred from other unphased genotypes, provided that these haplotypes are compatible with the known sites of the unphased genotype containing missing information. the choice of haplotypes for explaining such a genotype is independent of the alleles that the explaining haplotypes show at the site with missing information.

testing satlotyper on simulated data
in order to test satlotypers performance, we simulated haplotypes comprising six snp sites for ten tetraploid, biallelic populations with  <dig> individuals each. for every population, six simulated haplotypes were used as a pool for further simulation. these six different haplotypes of one population were sampled uniformly to generate a population of tetraploid individuals. the alleles of these haplotypes were also sampled uniformly. the simulation resulted in ten data sets of  <dig> individuals each.

in order to simulate noise in the simulated data sets, data changes were introduced by conversion of a randomly chosen nucleotide of a randomly chosen individual at a randomly chosen snp site to the other allele at the same site. all manipulated snp sites were marked and no longer changed. if, however, a change has to be introduced and the random procedure selects an already manipulated individual and site, the noise-procedure is repeated until the needed change is introduced. homozygous snp sites were excluded from change on the assumption that these sites are correctly analysed in real data sets. moreover, heterozygous snp sites were not changed to homozygous sites. thus, x% of noise means exactly x% of changed snp sites in the data set. the ten simulated data sets were modified by noise, where noise was increased from 0% to 10% in steps of 1% resulting in  <dig> different data sets. four types of analysis were performed with the simulated data sets . these four methods are referred to as method 1– <dig> and are computed as follows.

the different features of satlotyper are listed below. for the different results see also figure  <dig>  figure  <dig> and figure  <dig>  alt. expl. hap., computation of alternative most parsimonious sets of explaining haplotypes.

method 1: for each data set exactly one haplotype inference was calculated.

method 2: for each data set up to  <dig> alternative most parsimonious sets of explaining haplotypes and the corresponding haplotype inferences were calculated. additionally, bootstrapping was performed based on the calculated haplotypes by generation of  <dig> bootstrapping replicates. phased genotypes were then scored by the sum of the scores of their constituent haplotypes, and these values were summed up to score complete haplotype inferences . the best scored haplotype inference was selected without further optimisation with regard to genotype inference.

method 3: the analysis described in method  <dig> was further refined by an optimisation with regard to genotype inference performed for each alternative most parsimonious set of haplotypes . 

method 4: the first haplotype inference was used to optimise the genotype inference. for this purpose, the haplotypes were scored by their frequency in all genotypes of the first haplotype inference. next, optimisation of the genotypes was carried out as described.

the phased genotypes resulting from all four types of analysis were compared with the corresponding original simulated data set. we first tested whether the original sets of haplotypes, which were used for generating the simulations, could be identified by method  <dig>  method  <dig> and method  <dig>  method  <dig> was left out since different scorings of one haplotype inference do not affect the inferred most parsimonious set of haplotypes. without added noise, the six original haplotypes could be identified by all three methods. with the addition of noise it was not possible to identify all six original haplotypes in all data sets using the first haplotype inference . for three different data sets, this method found fewer than the six original haplotypes . in contrast, all six original haplotypes were correctly inferred by the analyses with bootstrapping  and the analyses with bootstrapping and optimisation . for all types of analysis, the phased genotypes resulting from each analysis were compared with the original simulated data sets by computing the minimal hamming distances between an inferred genotype and the corresponding original genotype without noise from the simulation. the minimal hamming distance was computed as given in section "implementation". based on the minimal hamming distance, the correctness for all four types of analysis was calculated as follows:

  100⋅600−minimal hamming distance600−600⋅100−1⋅noise%, 

where  <dig> is the number of snp sites in the simulation. the denominator in formula  <dig> is motivated by the minimal possible number of incorrectly inferred nucleotides compared to the simulated data without noise . this value is dependent on the noise used and is subtracted from the number of snp sites in the data set such that the denominator represents the maximal possible number of correctly inferable nucleotides. the number of correctly inferred nucleotides calculated by the sat approach is given by the numerator. the mean correctness of the ten different data sets was plotted against the noise .

without noise, all methods gave predictions close to 100% correctness. with noise added the results of the four analysis methods showed an increasing correctness to the original data in the following order: method  <dig> < method  <dig> < method  <dig> < method  <dig>  this means that method  <dig>  which is the method with bootstrapping and genotype optimisation, gave the best results for all values of noise. the comparison between method  <dig> and method  <dig> demonstrated that the application of bootstrapping in order to select the highest scored haplotype inference  gives better results than the method without bootstrapping . the distributions of nucleotide distances  from method  <dig> and method  <dig> for a given amount of noise were compared by the kruskal-wallis test with a significance level of 5%. all p-values except for the 0%-noise case were below  <dig> , and consequently the null hypothesis of both distributions being the same was rejected. although the distributions of nucleotide distances from method  <dig> and method  <dig> were not significantly different, the mean values of the distances of method  <dig> were always smaller than those of method  <dig> 

performance of satlotyper with unphased snp data from tetraploid potato genotypes
the performance of satlotyper was tested using unphased snp data from the locus ba213c14t <dig> of solanum tuberosum. locus ba213c14t <dig> corresponds to the sequenced t7-end of the bac  clone ba213c <dig> and is located on potato chromosome v between the markers gp <dig> and gp <dig> near the r <dig> gene for resistance to late blight  <cit>  . this intergenic sequence region is characterised by high sequence variability. the ba213c14t <dig> sequence also includes snp sites associated with resistance against the parasitic root cyst nematode globodera pallida  <cit> .

as input to satlotyper, two sets of unphased snp data of ba213c14t <dig> were generated from  <dig> heterozygous tetraploid potato individuals from two different breeders:  <dig> individuals from breeder  <dig> and  <dig> individuals from breeder  <dig>  the locus was amplified from genomic dna of the  <dig> individuals and the snp allele dosage  was estimated for twelve biallelic snp markers based on the sequence trace files . the resulting unphased snp data were used as input for a satlotyper analysis, where only one haplotype inference was calculated . the number of snp sites was varied from two to twelve and the running times were determined. in figure  <dig> the log of running time is plotted against the number of snp sites analysed for the two different data sets . even for twelve snp sites, the running time was less than  <dig> seconds for both data sets. figure  <dig> demonstrates that the computational complexity grows exponentially with linear increase of the number of snp sites.

comparison of satlotyper results with experimentally determined haplotypes
in order to evaluate satlotyper further, we compared computed haplotypes with experimentally determined haplotypes at the ba213c14t <dig> locus using a subset of nineteen heterozygous tetraploid individuals out of the two populations described above. we identified the haplotypes for twelve snp sites both computationally and experimentally. the sequence of the ba213c14t <dig> locus and the snp sites analysed are shown in figure  <dig> 

computational haplotype inference
the unphased snp data from the nineteen individuals were used as input for the computational haplotype inference with satlotyper analysis . up to  <dig> alternative most parsimonious sets of haplotypes and the corresponding haplotype inferences were calculated. on the basis of the calculated haplotypes bootstrapping was performed  in order to score the alternative haplotype inferences. the haplotype inference with the highest score was selected. satlotyper identified  <dig> alternative most parsimonious sets of haplotypes for this data set with a minimal number of twelve explaining haplotypes. additional file  <dig>  gives the input data, the bootstrapping results for all haplotypes and the different scored haplotype inferences which are in order of score. for each alternative haplotype inference the first corresponding genotype inference is given. in figure  <dig>  the twelve haplotypes obtained from the haplotype inference with the highest bootstrapping score are listed, together with the experimentally determined haplotypes. in addition, an optimisation with regard to genotype inference was performed for all alternative haplotype inferences .

experimental haplotype inference
the inference of haplotypes by satlotyper from experimental snp data requires the scoring of the snp allele dosage  in pcr amplicons derived from partially heterozygous individuals. preferential amplification of one allele versus the other may occur at heterozygous loci, resulting in erroneous scores of the allele dosage  <cit> , which leads to the calculation of erroneous haplotypes by satlotyper. even with a low percentage of erroneous scores of allele dosage per single snp site, the combination of errors from several snp sites can lead to an inflated number of haplotypes that do not exist. to verify haplotype models computed by satlotyper from experimental snp data, which are not error free, we performed an independent experimental haplotyping. the number and dosage of haplotypes present at a specific locus in a given individual can be experimentally determined by cloning and sequencing a sufficient number of pcr fragments generated from genomic dna of that individual at that specific locus. the number of different haplotypes is inferred from the number of consensus sequence variants found in the clone sample, and the haplotype dosage is inferred from the frequency of each consensus sequence variant in the clone sample.

for the subset of nineteen individuals, the haplotypes at the ba213c14t <dig> locus with respect to the twelve snp sites were determined experimentally  by the sequencing of at least twenty-four cloned amplicons from each of the nineteen individuals. the number of sequenced clones per tetraploid individual was raised from sixteen, as proposed by simko  <cit> , to twenty-four per individual, in order to accept as real only haplotypes that could be detected at least twice. this was necessary owing to the possible sequence errors introduced by pcr and sanger sequencing. in total,  <dig> amplicon derived clones were sequenced, which revealed ten distinct haplotypes present in the population of nineteen individuals . on the basis of the haplotypes observed and the frequency of each haplotype sequence per tetraploid individual, the most likely genotype for each individual was determined . the genotype models also allowed determination of haplotype frequencies in the subset of nineteen individuals. chi-square statistics revealed significant deviation of the observed frequency distribution of haplotype sequences from the numbers expected based on the genotype model in five individuals. haplotypes h <dig>  h <dig> and h <dig> with a frequency of 84% altogether were the most abundant ones . the other seven haplotypes had a frequency of less than 5% each. interestingly, haplotype h <dig> present in individual s <dig> shared high similarity  with the sequence of bac clone pgec472p <dig> originated from the wild potato species solanum demissum  <cit> . this indicated that haplotype h <dig> corresponds to an introgression from solanum demissum containing the r <dig> resistance gene  <cit> .

experimental haplotypes for potato locus ba213c14t <dig> resulting from the analysis of nineteen tetraploid individuals . snp sites 139– <dig> . values for allele frequency of each haplotype within the nineteen genotypes are based on the model for the most probable genotypes  with a maximum of seventy-six possible alleles in this sub-population . hapl., haplotype. fr., frequency.

for nineteen individuals, the number of clones obtained per individual for each of the ten haplotypes  and the resulting genotype model are shown. for each genotype model, the goodness of fit  and the p-values for the deviation of the number of observed clones from the expectation based on the genotype model are calculated. genotype models which do not significantly deviate from the observed haplotype distribution are shown in bold . it is assumed that haplotype frequencies deviate χ <dig> distributed from the genotype model, with # of different alleles - <dig> degrees of freedom. in the first row of table  <dig>  the χ2-value is calculated as follows: 1242+42+42)= <dig> . the p-value represents the probability of obtaining haplotype frequencies at least as extreme as the observed ones, given that the genotype model  is true.

comparison of computed and experimental haplotype and genotype models
from the nineteen individuals analysed, nine haplotypes were identified by both methods . the only experimental haplotype not detected computationally was haplotype h <dig> . h <dig> was identified only in individual s <dig>  in only two out of twenty-four analysed clones . haplotype h <dig> did not occur in any of the  <dig> alternative computed inferences , which leads to the conclusion that the unphased data do not support haplotype  <dig> in the most parsimonious set of explaining haplotypes. three haplotypes were identified computationally but not experimentally. this may result from imperfect input data, for example, from erroneous assignment of snp allele dosage, which leads to the creation of additional "non real" haplotypes by satlotyper, which are needed to satisfy the input data. alternatively, the experimental haplotype inference may have missed rare but real haplotypes owing to underrepresentation of the sequence in the cloned amplicons.

the high concordance between the experimental results and the prediction is shown in figure  <dig>  here, the bootstrapping score is compared with the experimentally determined frequency of the nine common haplotypes.

for the nineteen genotypes, we also compared the computed genotype inferences with the experimental ones . the minimal hamming distance between a predicted genotype and the corresponding experimentally determined genotype was computed as described in section "implementation". for every genotype the correctness was derived from the hamming distance as follows:

  100⋅48−minimal hamming distance <dig>  

formula  <dig> is motivated analogously to formula  <dig>  except that the amount of noise is not known. as a result, the denominator represents the total number of nucleotides. as shown in figure  <dig>  we obtained for 80% of the genotypes a correctness of at least 90% when compared with the experimental data. for two individuals  the predicted and experimental haplotypes were exactly the same. for twelve of the nineteen individuals at least three of the four predicted haplotypes were confirmed by the experimental data . the additional optimisation with regard to genotype inference according to method  <dig> did not result in a further improvement of the hamming distance and correctness between predicted and experimental phased genotypes for the nineteen individuals analysed.

discussion
existing approaches for inferring haplotypes from unphased snp data are only applicable to biallelic and diploid species. this study therefore aimed at the development of an approach for calculating haplotypes in heterozygous polyploid species. generalising the approach from  <cit> , a java based program was developed which formulates hipp for the boolean satisfiability problem. instead of giving the constraints for combinatorial sub problems explicitly, satlotyper generates constraints for summing such that the complexity decreases from exponential to polynomial for polyploid and polyallelic data sets. other methods for summing based on the sat approach have been described  <cit> , which are possibly easier to solve by the sat solver so that a future version of satlotyper will be further optimised. satlotyper is able to handle missing snp information by omitting constraints for such sites so that no unjustified assumptions about nucleotide frequencies have to be made.

for a given data set of unphased genotypes, it is possible by means of satlotyper to calculate the first most parsimonious set of explaining haplotypes and corresponding phased genotypes . one drawback of the parsimony approach is the sparsity of statistical information. a bootstrapping procedure can therefore be used to score haplotype inferences, in case there is more than one possible haplotype inference . since unphased genotypes can also have alternative inferences, it is possible to optimise the phased genotypes in respect to a most parsimonious set of haplotypes and the corresponding bootstrapping scores . it is also possible to score the haplotypes without bootstrapping simply by their frequencies in the phased genotypes, which can be used for selecting the best haplotype inference in the case of alternative inferences and for performing an optimisation with regard to alternative genotype inferences .

in this study, satlotyper was tested and evaluated with simulated and experimental data sets of unphased snp sites from tetraploid individuals. the different satlotyper methods were compared with the simulated data . prior to analysis, noise from 0% to 10% was added to the data, to account for erroneous snp scores in the input data.

without noise all methods were able to predict the correct set of haplotypes which were used in the simulation . compared with the original simulation, the haplotype compositions of the phased genotypes were close to the composition of the simulated genotypes . with noise added, method  <dig> using bootstrapping and optimisation gave the best results . it is likely that the relatively small difference between method  <dig> with bootstrapping and method  <dig> without bootstrapping  can be explained by the simulation. because the haplotypes are uniformly distributed, it is very likely that – even in case of noise – all original haplotypes are present in the first found haplotype inference. thus, an analysis of different distributions of haplotypes in populations is still missing. in the case of real data we would expect a larger difference between the applications of method  <dig> and method  <dig> 

the results obtained when method  <dig>  was applied suggest that for some purposes it could be sufficient simply to score the haplotypes corresponding to their frequencies in the phased genotypes for optimising genotype inference. this suggests that data sets that are time consuming to infer can be optimized by method  <dig> such that also time consuming bootstrapping can be omitted.

satlotyper was also applied to an experimental data set of twelve unphased snp markers, which were scored by sequencing of the amplicons of a  <dig> bp-region at potato locus ba213c14t <dig>  as we have verified only one locus so far, it is not possible to make a firm conclusion how representative the data set of the ba213c14t <dig> locus is. some variation is expected between different loci with respect to the quality of an amplicon  <cit>  for direct sequencing and whether the amplicon is representative for the genotype at the amplified locus. the performance of the approach was much higher with the experimental data than with simulated data. nevertheless, the running time increased exponentially with the linearly increasing number of snp sites .

in addition to performance, the quality of the prediction was evaluated by comparison of predicted haplotypes with experimental haplotypes that were determined by amplicon cloning and sequencing  <cit> . unfortunately, the experimental validation of haplotypes is time consuming and expensive. thus, only a subset of nineteen heterozygous unphased individuals was available for the direct comparison. furthermore, it has to be taken into account that the evaluation of predicted haplotypes based on comparison with experimentally determined haplotypes is slightly restricted by the fact that the experimental haplotypes are not error-free. in this study, new insights were gained in the experimental set-up for haplotype inference in autotetraploid species by molecular cloning and sequencing of amplicons. in several cases, the observed frequency of amplicon sequences deviated from the expected frequency . one reason could be a difference in the g/c-content of the alleles resulting in altered performances of the pcr-reaction  <cit> .

even slight differences in the initial pcr cycles are enhanced further on in the downstream reactions. this first comparison of computed with experimental haplotypes gave promising results: nine of the ten experimental haplotypes were also identified by satlotyper prediction out of the sub-population of nineteen individuals . with respect to the phased genotypes, the satlotyper analysis achieved a correctness of at least 90%  compared with the experimental result . with the exception of method  <dig>  all satlotyper methods gave similar results with this data set.

CONCLUSIONS
the study demonstrates that hipp can efficiently be solved for data sets of unphased snp sites from heterozygous polyploids by a generalisation of the sat approach from  <cit> . our results are encouraging for the future application and further development of satlotyper. existing or newly generated unphased snp data can be analysed by satlotyper to infer haplotypes. haplotype information can be used instead of individual snp sites in association mapping that exploits the biodiversity in existing cultivars and breeding lines  <cit> . compared with methods based on individual snp sites, the haplotype mapping method significantly improves the power and robustness of gene mapping techniques  <cit>  as there are fewer haplotypes than snp sites  <cit> .

availability and requirements
satlotyper was developed in the scope of gabi  projects and can be downloaded from the satlotyper project page  <cit>  of gabipd, the gabi primary database  <cit> . the software is distributed as a java jar file and requires java runtime environment  <dig> . <dig> or higher. for the user's convenience, the downloadable archive contains statically linked versions of minisat  <cit>  and miraxt  <cit> . the software is accessed from command line. under unix like systems the program runs out of the box with minisat  <cit> , miraxt  <cit>  and the sat4j solver  <cit> . users with microsoft® windows are restricted on running the sat4j solver. satlotyper is freeware for scientific use and is distributed under the satlotyper licence, which is also included in the downloadable package.

authors' contributions
jn developed and implemented satlotyper, performed all computational haplotype inferences and wrote most of the paper together with bk. gg performed the experimental haplotyping and participated in writing. rb contributed to the design and the implementation of satlotyper. sd and cg initiated the prediction of haplotypes for potato and provided ideas. ua generated the snp data and initially supervised the experimental part of the study together with cg, who also provided ideas for the development of satlotyper and participated in writing. js initiated the development of satlotyper based on the sat approach, he supervised and co-ordinated with bk the computational part of the study. bk also compared the results of computational and experimental haplotypings and co-ordinated the study. all authors read, edited and approved the final manuscript.

supplementary material
additional file 1
computational haplotype inference – xml output of satlotyper. the xml output of satlotyper is based on the treelike structure of the result. the root of the tree is marked by the <result> tag. the next level in the tree consists of the original input data , the scored haplotype  list derived by bootstrapping  and the calculated alternative inferences of the unphased input data . the haplotypings branch contains at least one inference of the original input data  with the corresponding most parsimonious set of haplotypes  and phased genotypes  as subelements where a genotype  contains the ploidy-specific number of inferred haplotypes.

click here for file

 additional file 2
experimental methods. this file describes the experimental methods used for  the generation of unphased snp data from tetraploid potato individuals and  the analysis of haplotype inference by amplicon cloning and sequencing.

click here for file

 acknowledgements
we are very grateful to the potato breeding companies saka-ragis, windeby, germany, and böhm-nordkartoffel agrarproduktion, ebstorf, germany, who kindly provided the analysed potato individuals. we thank prof. knut reinert, axel nagel, zoran nikoloski, liam childs and stefanie hartmann for helpful discussions. this study was supported by grants from the german federal ministry of education and research , by the max-planck-society and the former rzpd.
