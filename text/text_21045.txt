BACKGROUND
repeated sequences, often organized as extended tandem arrays, abound in biology, and computational approaches have been critical for the identification and analysis of such sequence elements from genomic data. tandem repeats  are formally defined as two identical copies of finite non-empty words with no intervening characters  <cit> . since biological sequences evolve naturally by mutation, both by base substitutions and insertions/deletions , a biological tr is defined as two or more sufficiently similar biological words lacking intervening characters, where sufficiency is arbitrarily defined. the work described in this paper focuses exclusively on non-evolutionary trs , each of which has three important properties: consensus sequence, a word representing the tr pattern, period, the number of characters in the consensus sequence, and copy number, the number of words in the entire tr domain.

bioinformatics studies of trs have primarily focused on dna. dna trs are traditionally classified on the basis of increasing period into microsatellites, minisatellites, and large-scale duplications. in some human tr loci, copy number changes are associated with triplet-repeat expansion diseases that include huntington's disease and fragile x syndrome  <cit> . because genomic tr loci are often highly polymorphic, even expanding and contracting from generation to generation, dna trs have forensic and biomedical applications, and may play important roles in genome evolution  <cit> .

nucleotide repeats occurring in protein coding genes can result in protein sequences containing repetitive elements. though less studied than dna repeats, peptide repeats are likewise known to be widespread in nature  <cit> . peptide trs impart a modular architecture to proteins and are found in important structural proteins such as animal collagens and keratins, insect and spider silks, plant cell wall extensins, and the proteins that form adhesive plaques and byssal threads of bivalve mussels  <cit> . tr domains are also found in other modular proteins, including prion proteins, ice nucleation and antifreeze proteins, fg-rich proteins in nuclear pore complexes, surface antigens of microbial pathogens and parasites, histones, and zinc-finger transcription factors.  <cit> . peptide trs may provide an evolutionary shortcut for the modular construction of new proteins through recombination and copy number adjustment  <cit> . to understand both the evolutionary diversity and functional significance of protein trs, facile methods for the a priori identification and analysis of trs from protein sequence databases will be critical.

numerous bioinformatics tools have been developed for de novo repeat detection in dna and protein sequences. one class of tools utilizes sequence self-alignment   <cit> . importantly, ssa approaches allow for the substitutions and indels in repeat sequences that often arise in biology. because protein repeat detection tools that use ssa  detect all repeated sequences, not only trs, these algorithms may incorrectly characterize tr domains as non-trs. with Ω time complexity , ssa algorithms are less than ideal for long protein sequences and repeat-detection in large multi-genome datasets. an alternative strategy implemented for a priori peptide repeats detection is based on a sliding window  approach  <cit> . in general, sw algorithms are simple to implement, but do not readily accommodate indels and are thus likely to miss many degenerate trs. the Ω time complexity of sw algorithms used to detect repeats of all periods also renders this strategy inappropriate for analysis of long sequences.

an efficient heuristic employed for detecting dna trs in whole genome data relies on seed extension   <cit> . seed extension algorithms have Ω time complexity for repeat detection, and depending on implementation, can approximate o time complexity, making them fast enough for analyses of large sequence databases. furthermore, since se allows for both indels and substitutions, this method is very appropriate for repeat finding applications in naturally evolving biological sequences.

to complement and improve upon current software tools for peptide repeat detection, we implemented a se algorithm to explicitly locate exact and degenerate  trs of all periods in protein sequences. this new tool, called xstream for variable  sequence tandem repeats extraction and architecture modeling, was designed to efficiently mine large genomic datasets for trs of any period, to effectively characterize degenerate tr domains, and to produce concise tr output. important features of xstream include novel heuristics that achieve 1) practical running time without period limitations, 2) effective reduction of tr output redundancy, 3) merging of discontinuous degenerate tr domains, 4) identification of nested tr architectures, and 5) tr domain clustering. though developed specifically for analyzing tr protein sequences, xstream works equally well to extract tr patterns in dna sequences, or for that matter, trs in any ascii string of characters. the practical utility of xstream is demonstrated through testing and validation using publicly available genome sequence data.

implementation
the xstream program implements a se approach that includes heuristics to efficiently and effectively detect exact and degenerate trs of any period from large input sequence datasets. the program utilizes two important strategies in addition to se to achieve practical running times without period limitations: a user-modifiable sequence alignment method called gap-restricted dynamic programming , and a new long-period tr filter . in addition, xstream applies several strategies, including the use of irreducible repeats, to effectively combat the redundancy in tr detection inherent in biological tr sequences. other novel features incorporated into xstream include merging of degenerate tr domains and modeling of nested tr architectures. xstream provides non-redundant output of trs meeting a suite of user-defined criteria for attributes such as minimum and maximum period, minimum copy number, minimum domain length, minimum % input sequence coverage, and maximum character mismatch.

algorithm
the primary functionalities of xstream, as shown in figure  <dig>  can be divided into five high level stages: pre-processing, tr detection, tr characterization, post-processing, and output. for a technical description of the algorithm, presented within the same organizational context, refer to the appendix section.

pre-processing
for processing by xstream, input sequences must be in fasta format. valid sequences are sent to the seed detection module. xstream searches the input sequence for short exact substring repeats, or seeds, of two or three sizes, depending on the input length . seed pairs are used to provide starting points and potential periods for tr detection. the use of seeds allows xstream to rapidly identify putative trs. for every adjacent pair of matching seeds, xstream records both the sequence distance between them and the sequence index of the leftmost seed. each distance is a potential tr period.

tr detection
following seed detection, xstream attempts to extend each seed pair. two sequence iterators move downstream from each seed in a parallel manner, returning characters for comparison. running totals of character match and mismatch are kept. we define i as the amount of character matching required between two tandemly arranged words in order for them to be designated a tr. for example, if i is set to  <dig> , then at least 80% of the aligned characters among two words at a given period must be identical. seed extension always stops when for any seed pair, the iterator for the leftmost seed collides with the rightmost seed. if at any point during the procedure, the character mismatch count divided by the current potential period exceeds or equals  <dig> - i, seed extension is aborted, thereby reducing running time. similarly, seed extension is prematurely terminated if the match count becomes sufficiently high. to include indels during seed extension, we use a novel heuristic, which is presented in the appendix section.

each candidate tr resulting from successful seed extension is subjected to further expansion using the same basic mechanism as seed extension. xstream examines sequence space both downstream and upstream of the current candidate domain using increments equal to the tr period. potential repeat copies are evaluated by comparing new sequence space with the reference repeat, which is the leftmost repeat resulting from the initial seed extension. if indels are allowed and if domain expansion using seed extension fails to agree with i, we invoke a second strategy. the second approach, termed grdp , can more accurately perform a subsequence pairwise comparison at the expense of slightly increased running time. a novel feature of our implementation is the user's ability to limit the maximum width of the dynamic programming  matrix , resulting in θ time and space complexities for global pairwise alignments.

following domain expansion, we instantiate a procedure called maximality. employing a user-adjustable scoring scheme, maximality finds the longest stretch of characters both downstream and upstream that can legitimately be added to each candidate tr. this procedure is invoked because trs in nature do not always occur in integer copy numbers and xstream's tr domain expansion method is limited to integer copies.

finally, xstream masks input sequence space corresponding to each maximally extended candidate tr. sequence masking prevents further seed extensions in sequence regions that constitute tr domains, thus functioning to prevent output redundancy as well as reduce running time. for details of sequence masking, refer to redundancy elimination i as well as two-stage tr detection in the appendix.

tr characterization
to further refine each candidate tr, xstream segments every tr domain into its component copies. parsing can be accomplished by a trivial subdivision of the tr domain using the current period, an optimal subdivision using wrap-around dynamic programming , or a heuristic subdivision using grdp. for details about implementation and when each method is invoked, refer to the appendix section.

following tr parsing, each tr undergoes a multiple alignment of its copies. a procedure identical in concept to star alignment is used when indels are allowed. because practical running time is emphasized in our implementation, pairwise sequence comparisons during star alignment may be computed in a non-optimal manner using grdp.

following multiple alignment of each tr, a consensus sequence is computed. each consensus is democratically derived using the majority rule. in addition, xstream computes an error associated with the consensus – the lower the error, the stronger the agreement between the consensus and its represented domain. we define i as the minimum allowable matching between the consensus and the aligned tr for the tr to be reported to the user. for example, if i equals  <dig> , then the consensus error cannot exceed  <dig>  or 20% disagreement.

next, xstream inspects the edges of each aligned tr domain  for accordance with the consensus. if either edge mismatches with the consensus, that edge is truncated. since all trs must have at least  <dig> copies, edge trimming is not performed on tr domains with tr copy number =  <dig> 

occasionally, because of matching considerations, tr domains are identified with periods that are reducible. therefore, the last step of tr characterization functions to reduce overestimated tr periods .

post-processing
xstream attempts to merge sufficiently similar trs that either overlap in the input sequence or are in close enough proximity to one another. to compute sufficient similarity, xstream invokes the concept of cyclical permutations, which enables effective consensus sequence comparison . as a result, xstream can identify tr domains with large regions of indels and/or substitutions that, without merging, would be reported as separate trs. this procedure is thus important for detecting rapidly evolving tr sequences.

following merging, xstream invokes a series of finalizing functions called finishing touches, which serve to fine-tune the characterization of each tr domain as well as remove trs that are insufficiently fit for output. tr characterization refinement involves rerunning maximality, redoing multiple alignment, rerunning reducibility, and looking for nested trs . after additional characterization, finishing touches removes trs with unacceptable amounts of overlap . finally, remaining trs are tested for agreement with user-defined filtration criteria.

all trs that satisfy the output criteria are sent to the consensus comparison  module. cc clusters trs on the basis of consensus similarity. by ordering trs by consensus sequence homology in the output, xstream reduces output redundancy while facilitating the identification of tr families from the input dataset. related trs may reflect structural or functional homology of their corresponding protein sequences. the current implementation of cc only compares trs of equal period.

output
xstream automatically generates html files in a format similar to the output from tandem repeats finder   <cit> . html output  <dig> contains a tr summary table and list of tr information, including sequence positions, period, and copy number. the range of sequence positions for each tr is hyperlinked to html output  <dig>  which displays tr multiple alignments and consensus sequences. in the case of a multiple sequence input, xstream generates html output  <dig>  which reports a list of all input sequences containing reported trs. an additional output option is a colored tr schematic, in png or html format, that represents the modular architectures of tr-containing sequences. the main user-definable output parameters of xstream are presented in table  <dig>  a list of all user-defined parameters can be found on the xstream webserver  <cit> .

shown in this table are seven important user-adjustable parameters used by xstream. these parameters function to limit the extent of tr degeneracy as well as to restrict the tr period and copy number of reported trs. default parameter values were empirically chosen to preferentially identify and model long degenerate repeat regions rather than shorter repetitive regions with higher sequence identity . we acknowledge that alternative architectures may exist for some complex repetitive domains. by including these and additional modifiable parameters, xstream provides considerable user control over tr degeneracy and output filtration.

RESULTS
xstream was coded using java standard edition  <dig> . to evaluate our implementation, we demonstrated and validated key features of xstream using a variety of input datasets. first, a run time analysis shows the practicality of xstream for tr detection in whole genomic sequence data. second, multiple sequence alignments, merging, and nesting are demonstrated using anecdotal output examples. third, the ability of xstream to detect protein tr domains is validated using published results from five protozoan parasite genomes. finally, we present schematic diagrams illustrating the utility of xstream for graphically depicting modular architectures of tr proteins. in all cases, default parameter values were used unless stated otherwise . all tests and data collection were carried out using a windows xp pc with a 64-bit amd athlon dual core  <dig>  ghz processor and  <dig> gb ram.

a principle attribute of xstream is practical running time for large sequence datasets. to measure how running time varies with differing input sequence lengths and parameter values, we used xstream to analyze dna sequences. we chose dna over protein sequences simply because dna sequences cover a substantially larger range of sequence lengths than proteins, thus enabling a more accurate assessment of running time. xstream was run on dna sequences ranging from  <dig>  mbp to  <dig> mbp, either with gaps  or without gaps . for these analyses, sequences were examined in two sets. shorter sequences, <  <dig> mbp, were processed with minimum tr domain length mind =  <dig> and minimum period minp =  <dig>  and no period restrictions. for longer sequences, we used mind =  <dig> and minp =  <dig>  and due to memory limitations, maximum period was set to  <dig> kbp. in addition, for periods  <dig> –  <dig> we used a divide-and-conquer approach  with fragment length =  <dig> mbp. as shown in table  <dig>  running time increased approximately linearly with increasing sequence length for all dna sequences with or without gaps . next, the effect of increasing dataset size on running time was examined by analyzing four swiss-prot datasets ranging in size from  <dig>  to  <dig>  non-redundant protein sequences, and setting mind =  <dig> and minp =  <dig>  as expected, since xstream processes each protein sequence individually, running time scaled linearly , as indicated in table  <dig>  a running time of less than  <dig>   <dig> min for the detection of degenerate trs  from the swiss-prot  <dig>  dataset clearly demonstrates the practicality of xstream for multi-genome data mining.

running times for the analysis of different input sequence datasets are shown, with the gap parameter g =  <dig>  or g =  <dig>  the following dna sequences were downloaded from ncbi: s. cerevisiae chromosomes i , viii , and xii , h. sapiens chromosomes x  and xxi , chromosome i contig , and the β t-cell receptor locus , r. norvegicus chromosome xvi , m. musculus chromosome i , and the m. magneticum amb- <dig>  genome. sequences at the top  were run with mind =  <dig>  minp =  <dig>  and all possible maximum periods. longer dna sequences  were run with mind =  <dig>  minp =  <dig>  and  maximum period =  <dig> kbp; divide-and-conquer  was used for periods <  <dig> . for each longest period found, the copy number is shown in parentheses. these data show a linear relationship between running time and increasing input sequence length . running times for analysis of  <dig> swiss-prot datasets, using mind =  <dig> and minp =  <dig>  shown at the bottom, including the number of trs detected  and the number of tr-containing proteins found . xstream running time scaled linearly with increasing swiss-prot dataset size .

in addition to efficient tr detection, other important capabilities of xstream are demonstrated with the data shown in figures  <dig>   <dig>   <dig> and table  <dig>  a multiple alignment of a degenerate tr domain found in the c. elegans hypothetical protein ce <dig> is presented in figure  <dig>  shown above the alignment are the standard numerical properties reported by xstream for each tr domain: sequence position, period, copy number, and consensus error. each alignment is additionally described by a consensus sequence  and a consensus error string .

anecdotal examples of very high copy number and very long period dna trs from chromosome i of a. thaliana and chromosome iii of c. elegans are shown.

the tr example shown in figure  <dig> also highlights the utility of the merging feature of xstream when applied to overlapping domains with different periods. without merging, this tr domain would be reported as several distinct tr fragments. the merging of two non-overlapping tr domains from an a. thaliana hypothetical protein  is illustrated in figure  <dig>  this example illustrates the utility of incorporating a highly degenerate intervening sequence to define a larger tr domain that, without merging, would have been divided into two discontinuous regions . as in proteins, dna trs may also contain extensive degeneracy. the high copy number tr domains shown in table  <dig> represent additional successful applications of xstream's merging feature. taken together, the merging of overlapping tr regions allows xstream to successfully model the architectures of tr domains that have accumulated extensive substitution and/or indel mutations, or that have arisen through convergent evolutionary mechanisms.

in addition to extensive degeneracy, trs may have very long periods and nested architectures. xstream implements a novel long-period filtering procedure  to find trs with periods ≥ <dig>  the utility of this method is demonstrated by some of the dna examples in table  <dig> and by the long-period a. thaliana dna repeats in table  <dig>  xstream also incorporates a strategy to find and describe nested tr architectures, represented by the regular expression , with n denoting the number of tandem copies of substring x. an example of tr nesting that shows two levels of nesting is presented in figure  <dig>  included in the figure is a block diagram illustrating the hierarchical patterning that epitomizes nested trs. taken together, these merging, long-period filtration, and nesting features make xstream a useful tool for detection and architecture modeling of tr domains in both nucleotide and protein sequences.

to validate the utility of xstream for detecting tr-containing proteins, we analyzed the proteomes of five parasite genomes, and compared our output to the tr proteins identified in these same genomes by trf  <cit> . protein sequence datasets for these parasites were downloaded  <cit>  and processed using minp =  <dig>  mind =  <dig> and minimum copy number minc =  <dig>  or  <dig>  these parameter values were chosen to emulate the tr criteria used in  <cit>  to find tr domains in gene sequences of at least ~ <dig> bp. setting mind =  <dig> amino acids for xstream corresponds to a slightly more stringent  <dig> bp minimum. table  <dig> summarizes the trs found by xstream, using minc =  <dig> or minc =  <dig>  and by trf  <cit> . using minc =  <dig>  xstream identified more tr containing proteins in all parasites except t. annulata. in l. infantum, the causative agent of leishmaniasis and the focus of the goto et al. studies  <cit> , xstream found seven tr proteins that they did not identify, while three of the tr proteins found by trf were not detected by xstream. upon closer examination of the three "missed" proteins, each was found to have a tr domain with copy number less than  <dig>  which would not be reported by xstream using minc =  <dig>  when xstream was rerun with minc =  <dig>  all  <dig> of the previously identified l. infantum tr proteins  <cit>  were found, along with  <dig> additional tr containing proteins that are schematically diagrammed in figure  <dig> to illustrate the significant diversity of tr domain architectures within these  <dig> proteins.

numbers in each column represent the number of different tr-containing proteins detected using minp =  <dig> and mind =  <dig> amino acids for xstream, and a minimum score of  <dig> for trf. within the parentheses, the number on the left represents the number of genes identified in  <cit>  that were not identified by xstream and the number on the right represents the number of genes identified by xstream that were not identified by  <cit> . comparison of output on an individual protein basis was only possible for l. infantum as goto et al.  did not report identified proteins for the other parasites.

since tr domains can constitute variable fractions of the parent protein sequence , xstream incorporates the simple concept of tr content, defined as the ratio of the tr domain length to the input sequence length, as an additional metric for comparing modular proteins. use of this metric allows xstream to filter output using any arbitrary level of tr content, a feature that is illustrated using the protein sequence dataset from a. thaliana . the arabidopsis proteome was analyzed using parameter values minp =  <dig> and tr content ≥  <dig> . the relatively small number of proteins with ≥70% tr content resulting from this analysis are schematically depicted in figure  <dig>  this output clearly reveals the modular architectures of two large, well-described a. thaliana protein families  along with that of additional tr proteins.

discussion
the use of a priori computational methods to search genome databases for repetitive elements has revealed an abundance of both dna and peptide repeats in nature, many of which occur in tandemly repeated patterns  <cit> . the detection and analysis of repeated peptide sequences has received considerable attention in recent years, including the recent publication of a large protein repeats database  <cit> . despite the potential importance of such repetitive sequences, the available repeat detection software suffers from both time complexity and output redundancy problems. to address these issues, and to facilitate the detection and modeling of tr structures in general, we developed a new software tool called xstream.

the utility of xstream for efficient and effective detection of degenerate tandem repeats in large input sequence datasets was demonstrated by testing and validation. practical performance was confirmed by showing that xstream running time can scale linearly with both increasing sequence lengths  and increasing dataset sizes . xstream invokes no period limitations and can thus detect trs with very long periods, as illustrated by the ~ <dig> kbp tandem duplication identified in chromosome i of a. thaliana . with the implemented merging heuristic, xstream can also identify tr domains with intermittent regions of high degeneracy, such as the tr from c. elegans chromosome iii with period  <dig> and copy number > <dig> , and the proline/glycine-rich protein from c. elegans shown in figure  <dig>  in addition, by searching for nested tr structures, xstream detects trs within trs , a useful feature for gaining insights into the evolution of complex tr architectures.

output redundancy is a problem inherent in repeat detection that has often been ignored. for example, using a sw approach, katti et al.  <cit>  searched swiss-prot  <dig> for trs with periods between  <dig> and  <dig>  and compiled the trips database of trs and their corresponding protein sequence identifiers . in many cases, trs with different periods were reported that occupy the same protein sequence space. the output of another repeat finding tool  <cit>  also demonstrates the importance of redundancy removal. the protrepeatsdb tool  was designed for comparing repeated peptides from many organisms. though aware of redundancy problems, the strategy implemented by kalita et al. falls short of providing concise repeat output in numerous cases. for example, protrepeatsdb reported  <dig> and  <dig> distinct perfect peptide repeats in the ubq <dig> and ubq <dig> polyubiquitin sequences from a. thaliana, respectively. unexpectedly, the canonical period  <dig> trs known to characterize polyubiquitins were absent. such highly redundant outputs illustrate the importance of the redundancy removal tactics incorporated into xstream. by invoking several strategies , including the use of irreducible tr periods  <cit> , xstream produces non-redundant tr output. analysis of the a. thaliana proteome by xstream, for example, reports the ubq <dig> and ubq <dig> sequences only once, with an irreducible, period  <dig> tr covering virtually the entire protein sequences.

the recent analysis of five protozoan parasite genomes using trf  <cit>  provided a reasonable reference for testing xstream on genome-scale datasets. using mind =  <dig> to mimic the tr domain criterion used by goto et al, xstream detected significantly more tr proteins from all parasite genomes, including all  <dig> of the previously identified l. infantum tr proteins  <cit> . further analysis of these  <dig> tr protein domains revealed that the tr domains identified by both algorithms were comparable in size .

CONCLUSIONS
by testing xstream on a variety of sequence data, we demonstrated the utility of this new genome data-mining tool for identifying trs with diverse periods and domain sizes, varied levels of degeneracy, and complex architectures. these capabilities should facilitate potentially significant applications. for example, trs present in parasitic pathogens are known to elicit important immunological responses that may provide antigenic protection . new computational approaches for detecting tr proteins might thus be useful for identifying novel protein antigens useful for diagnostics and vaccine development  <cit> . secondly, since tr domains are characteristic of modular structural proteins, use of xstream may lead to the in silico discovery of phylogenetically diverse proteins with novel biomaterials and biomimetic applications.

availability and requirements
project name: xstream

project home page and availability: 

operating system: platform independent

programming language: java

any restrictions to use by non-academics: yes, contact author jbc for details

list of abbreviations used
tr, tandem repeat; trf, tandem repeats finder  <cit> ; dp, dynamic programming; grdp, gap-restricted dynamic programming; ssa, sequence self-alignment; sw, sliding window; se, seed extension; wdp, wrap-around dynamic programming; cc, consensus comparison; et, edge trimming; cw, comparison wobble; minp, minimum period; minc, minimum copy number; mind, minimum tr domain length; hps, heuristic partitioning strategy

competing interests
the author declares that there are no competing interests.

authors' contributions
amn conceived of, designed, implemented, tested, and validated xstream, and wrote the manuscript. jbc conceived of, tested, and validated xstream, and wrote the manuscript. both authors approved the final manuscript.

appendix
preliminary notations
• s = input sequence, which takes values from alphabet {a,c,g,t} for nucleotide sequences and alphabet {a,c,d,e,f,g,h,i,k,l,m,n,p,q,r,s,t,v,w,y} for proteins

· |s| = length of s

· s = the character at index j in s with j ≥ 0

· s = the subsequence in s from index i to index j inclusively

• xi = tr domain i

· |xi| = length of entire tr domain xi

· xi = repeat copy j in xi with j ≥ 0

· |xi| = length of copy j

· |xi| = size of array xi

· xis = lowest index of xi; starting position in s

· xie = highest index of xi; ending position in s

· xise = index range 

· ei = copy number  of xi

· ci = consensus sequence of xi

· pi = period of xi = period of ci

· cei = consensus error of xi =

- without gaps: # of mismatching characters to consensus/total # of characters in aligned xi

- with gaps: see consensus building

· ii = indel error of xi = # of gaps in aligned xi/total # of characters in aligned xi

· ri = referential repeat copy of xi: used during tr domain expansion and maximality

• {x} = {x <dig>  x <dig> ..., xn} = set of all identified tr domains

pre-processing
to find repeats of various periods in any fasta-formatted input sequence s, xstream looks, by default, for exact repetitions  of lengths  <dig> and  <dig>  length  <dig> is also used if |s| ≥  <dig>  seed lengths are user-adjustable. xstream records the distance between each pair of adjacent seeds, |p - q|, where the lowest index in s of each seed in the pair is represented by p and q respectively, and p <q. all seed positions and distances between adjacent seeds are stored and accessed using a hash table. in addition, xstream records in an integer array m, the hashcodes and sequence indices for all seeds of minimum length l, where l =  <dig> by default. for instance, a seed of length l starting in position  <dig> in s would have its hashcode stored in m <cit> . the utility of m is explained shortly.

tr detection
seed extension
xstream traverses the distance list in order of increasing distance, and for each set of identical distances, moves down s in order of increasing indices. for a given seed pair, let p, q be defined the same as previously and let x, y be the starting positions of two sequence iterators, where x = p + l, y = q + l. further, let d = |p - q|, p* = p + d -  <dig>  and q* = q + d + ε -  <dig> where  <dig> ≤ ε ≤ g  and q* < |s|. because the seeds of each matching pair are of length l, x and y iterate through s in the regions s and s. note that in the case l =  <dig>  the minimum copy number is  <dig> for all periods except periods  <dig> and  <dig>  which cannot have copy number less than  <dig> and  <dig>  respectively. we now refer to array m, which was constructed during seed detection. to bypass individual character comparison, m is interrogated for matching hashcodes. if m = m and  = p* and  ≤ q*, x and y are incremented by l , and a match of l characters is recorded. by comparing hashcodes instead of substrings and by allowing jumping in blocks of l characters, usage of m can decrease xstream running time. if m = m and x ≤ p* < , a match of length min) is recorded, and se terminates. if m ≠ m and g =  <dig>  xstream compares the character pair in s at s and s. whether or not s = s, if  ≤ p* and  = q*, x and y are incremented by  <dig>  and xstream returns to hashcode comparison using m.

if the case arises where m ≠ m and g >  <dig>  a novel procedure termed "comparison wobble"  is invoked. cw allows for efficient approximation of indels using array m and parameter g. this procedure is one-sided, in that it fixes x and allows for variations in y, denoted by y*. we place the following restrictions on y*:

i) |y* - y| ≤ g

ii) y* < |s|

iii) if y* <y, then  ≤ l and  <d. we enforce this constraint to avoid comparing subsequences at the same pair of positions in s more than once.

iv) y* > Ω, where Ω = highest index in s with matching character from the current seed extension – e.g. if last match was m <cit> , then Ω =  <dig> + l - 1; if last match was s <cit> , then Ω =  <dig>  this rule prohibits matching redundancy.

if ∃y* such that m = m, xstream records a match of min), increments x by l, sets y ← , and if x ≤ p*, returns to standard se . because y ← , it is possible that y moves beyond q + d -  <dig>  hence the need for ε. in addition, if a match is found when y* <y , the mismatch record is adjusted to take into account any currently matching characters that were initially found to be non-matching. if m ≠ m, xstream transitions to single character comparison using s, and then if space permits, returns to standard comparison using m. an example of seed extension with cw is shown in figure  <dig> 

tr domain expansion
seed extension operates on seed pairs, and therefore, if successful, only yields putative trs of copy number  <dig>  to further extend each potential tr xi, xstream implements two procedures, although the second one is used only if g >  <dig>  first, x is reset to p. in this way the copy in xi with the lowest index serves as the character comparison reference repeat ri. the value given to q depends upon whether xstream is attempting to extend xi downstream or upstream of xi's current sequence region. if downstream, q is incremented by d. if upstream, q is initially set to p - d, and decremented by d thereafter. the first method for domain expansion is exactly the same as seed extension except x = p, y = q, and the evaluated regions in s are s and s, where  <dig> ≤ q ≤ . if this procedure is successful, the new copy is added to xi. if unsuccessful and if g >  <dig>  xstream invokes the second procedure, which uses grdp  on the same regions in s. grdp is better, albeit slower, than cw at identifying indel regions. upon completion of grdp, the number of matching characters in the alignment is determined and if that number is high enough, the new copy is added to xi. following success by either expansion method, q is updated and domain expansion is performed again. if i is not satisfied, domain expansion ceases, and the current candidate tr domain is sent to the maximality function.

maximality
the maximality procedure makes use of ri, with p remaining equal to the lowest index of ri. this method finds the longest valid prefix and suffix of ri by searching downstream and upstream of xi respectively. a dp sequence alignment scoring scheme is used, with match =  <dig>  mismatch = - <dig>  and gaps = - <dig> . let l = xis, r = xie, left = l - min, and right = r + min). further, let q <dig> = s, q <dig> = s, riq <dig> = s, and riq <dig> = s. since xstream needs to find the character pair that corresponds to the highest score, it reverses the order of characters for both q <dig> and riq <dig> prior to alignment. if g >  <dig>  grdp is used to align q <dig> with riq <dig> and q <dig> with riq <dig>  if g =  <dig>  the sequences are aligned so that the members of each sequence pair overlap 100%. xstream uses the dp scoring scheme regardless of whether grdp is used. the highest scoring indices in q <dig>  q <dig> are denoted q1* and q2* respectively. if, at index q1*, the score exceeds  <dig>  xi is extended upstream by  characters, and if the score for index q2* is greater than  <dig>  xi is extended downstream by  characters.

copy number computation
for a given xi, using the indicator function i :

 •ei=∑∀j ∈xii|≥pi]+i|<pi]⋅ 
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaacqwgfbqrcqwgpbqacqgh9aqpdaaeqbqaaiabbmeajjabbufabjabbyha8jabdifayjabdmgapjabbufabjabdqgaqjabb2fadjabbyha8jabgwmizkabdcfaqjabdmgapjabb2fadjabgucariabbmeajjabbufabjabbyha8jabdifayjabdmgapjabbufabjabdqgaqjabb2fadjabbyha8jabgyda8iabdcfaqjabdmgapjabb2fadjabgwsixlabbicaoiabbyha8jabdifayjabdmgapjabbufabjabdqgaqjabb2fadjabbyha8jabb+caviabdcfaqjabdmgapjabbmcapiabbccagawcbagaeyiaiiiaemoaaomaeeiiaaiaeyici4saemiwaglaemyaakgabeqdcqghris5aaaa@6da2@ 

computing ei in this way demands that ei ≤ |xi|. both gap and masked  characters are not considered during copy number computation. ei is updated whenever xstream changes xis, xie, pi, or xi's multiple alignment.

sequence masking
after each successful seed extension, xstream masks the sequence space corresponding to the newly detected tr domain in order to reduce both running time and repeat redundancy . afterward, the next seed pair, if one exists, is extended.

period offset
if g >  <dig> and comparison wobble is successfully used, then the period pi for a given tr xi may need adjustment. to approximate a better period, pi*, we turn to the offset y* - y for every cw success for a given xi. let so = Σ, for all successful extensions, i.e. xi ≠ ri. then, pi* = pi + , and pi ← pi*. therefore, pi is updated using the average period offset. this function is important for tr domain parsing when g >  <dig>  since pi is used to derive a temporary ci, which is needed for tr domain alignment.

tr characterization
tr domain parsing
in order to best characterize any tr domain xi, its copies are aligned to one another and used to create a consensus sequence ci. we describe our consensus derivation procedure shortly. to align xi, it must be partitioned into its repetitive parts. for the case g =  <dig>  starting from xis, s is cut into as many tandem fragments of length pi as possible. because of maximality, xi's last copy may have length less than pi. multiple alignment of xi is achieved by simply stacking all copies in the order they occur in s. if g >  <dig>  partitioning of xi is much more complex. to preserve practical running time for the case g >  <dig>  we use one of two segmentation tactics. both methods require a putative consensus sequence ci for a given xi. xstream therefore initially partitions xi in the same way as when g =  <dig>  afterward, xi is aligned using a multiple alignment algorithm that we describe shortly. following alignment, a transient ci is derived. we now compare/contrast xstream's two partitioning procedures for the case g >  <dig> 

wdp can optimally parse a tr domain xi in o time given a representative copy of length m , where m = pi and n = |xi|  <cit> . this time complexity is practical up until mn is very large. since xstream has no period limitations, we developed a heuristic partitioning strategy  that uses grdp. when mn >  <dig> , <dig> and m > g, xstream invokes hps; otherwise, wdp is used. our version of wdp requires two passes through the dp matrix and therefore computes  <dig> mn scores, whereas grdp computes < n scores. to ensure that hps makes less dp matrix computations than wdp, we require m > , which is equivalent to m > g since m, g only take integer values.

as mentioned, both partitioning strategies require ci. wdp aligns ci to the domain d = s. afterward, d is cut between every adjacent instance of ci. hps works by first building a concatamer of ci comprised of n copies of ci, where n = |xi|/|ci|. because n may take a non-integer value, the consensus concatamer can have more or fewer copies than an optimal partitioning of xi. after pairwise alignment to d using grdp, |xi| is segmented in the same way as described for wdp.

multiple alignment
xstream employs the star alignment algorithm for multiple sequence alignment. the center sequence is computed using grdp exclusively. we elected to use grdp over standard dp because the number of pairwise alignments that are needed increases as a function of ) <dig> , in which case the last copy is excluded from being a center sequence. because our version of star does not use standard dp, it will not always compute an optimal center sequence. nevertheless, to maximize the practicality of xstream for large dataset analyses, we decided that the order of magnitude performance gain provided by grdp outweighs the possible decrease in multiple alignment quality. since grdp requires input sequences of the same length, we temporarily replicate xi, denoted by xi*, and add the dash character '-' to the rightmost end of all copies of xi* where |xi*| <max until |xi*| = max. we then find the center using xi*. following center sequence determination, the tr multiple alignment is constructed using the conventional star alignment strategy. because practical running time is emphasized in our implementation, pairwise sequence comparisons during star alignment may be computed in a non-optimal manner using grdp.

consensus building
xstream's consensus derivation procedure makes use of the majority rule. that is, for the multiple alignment of a given xi, the majority character in each column of the alignment is selected. if no majority exists, then, by and large, the topmost character is chosen. however, if |xi| =  <dig>  and if within a given column, one character is a gap and the other is a non-gap, the gap character is added to the consensus. if, on the other hand, |xi| >  <dig>  and if within a column, a gap character is tied in number with one or more non-gap characters, the topmost non-gap character is added to the consensus.

to compute the consensus error cei for a given xi, we keep track of four variables:

i) the non-gap counter, denoted ng, tallies every non-gap character that does not match its corresponding consensus character.

ii) the majority gap counter, mg, records the number of gaps in all columns where the majority character is a gap.

iii) a user-modifiable constant, g* , specifies the maximum number of consecutive gaps in an alignment row that can be counted toward cei. for each row of the alignment, we count the number of successive gaps that do not match the consensus until either that number equals g*, a non-gap character is reached, or the consensus contains a gap. we resume counting gaps the next time a gap is encountered in a column where the consensus character is a non-gap. let cg equal the final count.

iv) let tot = total number of characters in the multiple alignment of xi, including gaps.

we set cei = /. the quantity mg is subtracted from tot so that gaps in columns with a gap majority do not decrease cei. further, the addition of cg to the numerator functions to limit the extent to which gaps increase cei. we dampen the role gaps play in cei since they are artificial characters. in addition, we force pi to equal the number of non-gap characters in ci, and therefore, if necessary, pi is updated.

edge trimming
for each xi, edge trimming  moves downstream from xis and upstream from xie, deleting characters that mismatch with ci until the first matching character pair is found from each direction. xi is realigned if truncation is successful from the top-left, since otherwise we would start the alignment with one or more gaps. if et is only successful from the bottom right, no realignment is necessary. in this case, xstream removes both the flagged bottom right portion of the alignment as well as any columns that contain all gaps. if et is a success from either direction, ci is rebuilt. for each xi, et is iteratively invoked until either |xi| =  <dig> or both edges of xi agree with ci.

post-processing
merging
xstream iterates through {x} in order of increasing period. given pi, ∀i ∈ {x}, the following routine is executed:

 define xtra as min·pi), max ∀j ∈ {x}), where by default, σ =  <dig>  xtra dictates the breadth of periods from which to draw trs for merging. the conditions restricting xtra were chosen to avoid messy and insensible tr domain characterizations as well as to maintain practical running time.

 let tr set {b} = xj, ∀j ∈ {x}, where i ≠ j and pi ≤ pj ≤ xtra. set {x} ← . note: from step  to step , we only refer to trs from {b}.

 sort {b} in increasing order of xjs, ∀j ∈ {b}.

 starting with m =  <dig>  we examine xm and xn, ∀m, n ∈ {b}, where n = m + 1

 let q denote the maximum allowable sequence space between two combinable trs, and set q = min·pm. by default, μ <dig> =  <dig> and μ <dig> =  <dig> .

 if |xmse ∩ xnse| ≠ Ø or  <dig> <  ≤ q, compute similarity s of cm and cn using the consensus comparison function .

else go to step .

 if s ≥ i, merge xm and xn.

else go to step .

 if |xmse ∩ xnse| ≠ Ø, perform the following procedure: from step  we obtained the index cnp  corresponding to the best cyclical permutation of cn when aligned to cm. we repartition xn by slicing its alignment vertically at cnp, thus ensuring xn is in phase with xm before consolidation. we then merge xm and xn, forming xmn = . go to step .

 if |xmse ∩ xnse| = Ø, perform the same procedure as in step  with the exception that the sequence space between xm and xn must be incorporated into xmn:

i) let z equal the index in s that corresponds to the character in xn <cit>  that is in the same alignment column as cnp. let sequence k = s.

ii) add xm in its original form to xmn.

iii) tile k in accordance with cm. to do this, cut k into as many consecutive fragments {f} of length pm as possible. start cutting k from the end with the lowest index.

iv) given fi, ∀i ∈ {f} ,

if |fi| = pm, use the consensus comparison module to compute similarity s of fi and cm.

if s <η, where η <i and η = . <dig> by default, replace all characters in fi that do not match to cm with 'x' and add fi to xmn.

else cut fi at the index corresponding to its best cyclical permutation, resulting in fi <dig> and fi <dig> 

if ]| + |fi1|) ≤ , append fi <dig> to xmn's last row.

else fi <dig> becomes a new row in xmn.

regardless of what happens to fi <dig>  since fi <dig> is in phase with cm, fi <dig> becomes a new row in xmn.

else if |fi| <pm, add fi to xmn in the same manner as fi <dig> .

v) following the incorporation of k, add xn to xmn in the same way as in step .

 remove all gap characters from xmn, perform multiple alignment on xmn  and derive consensus. we do not include the 'x' character ) in the calculations of emn, cemn and imn. if xmn meets tr retention criteria, set xm ← xmn and {b} ← {b} - xn.

 if m < |b| -  <dig>  increment m by  and go to step .

else set {x} ← {x} ∪ {b}.

finishing touches
the following tr domain refinement procedures are invoked in the order presented:

 maximality – rerun the maximality function on each xi, but set ri ← ci. we invoke maximality again because using ci as a reference copy may allow for additional expansion of xi.

 realignment – for each tr in {x}, make a copy of xi, denoted xi*, and perform multiple alignment on xi* using ci as the center sequence. ci is not included in the final alignment of xi*. if cei* <cei, we set xi ← xi*.

 reducibility – rerun redundancy elimination procedure ii  on every realigned tr in {x}.

 overlap removal – if allowed by user, send {x} to redundancy elimination algorithm iii .

 nesting – by default, send {x} to nesting procedure .

consensus comparison
for clustering different trs, we compare their consensus sequences. in order to effectively compare consensus sequences we take into account tr phase variation – the same tr can have different starting points, leading to consensus sequences of different phases. more formally, every irreducible xi can occur in pi cyclical permutations, and if a given tr xj has ej ≥  <dig> + /pj, then xj has pj valid consensus sequence phases. therefore, we must evaluate up to pi consensus alignments for every pair of trs with period pi that also satisfies the same copy number condition as xj. for simplification, we treat all trs the same, regardless of copy number. given a pair of trs, xi and xj where pi = pj, xstream fixes ci and aligns as many phases of cj to ci as are needed to establish similarity. if consensus comparison is called from the merging procedure, all phases of cj are aligned to ci to locate the best-aligned cyclical permutation. the leftmost character in the highest scoring phase of cj, denoted by cjp, is used during tr merging. otherwise, only sufficient similarity is needed, and thus xstream may align less than all phases of cj. if g >  <dig>  all gaps are removed from ci, cj prior to alignment. all alignments of ci, cj are computed using grdp. for each alignment, xstream counts the number of matching characters and stores the highest match count so far in n. if n/pi ≤ i, xstream groups xi and xj. the time complexity of comparing ci and cj is o because of pi alignments and o alignment time. for every newly established tr group, the consensus sequence with the lowest index in {x} becomes the group head or referential consensus, and is used for all subsequent comparisons. the time complexity for performing all consensus comparisons of the same period without considering alignment time is o. therefore, the total time complexity of consensus comparison is o.

gap-restricted dynamic programming
a major obstacle to efficient alignment of gapped trs is dynamic programming , which, for global pairwise-sequence alignment, has time complexity o, where n = tr period. because optimal alignment of tr copies may, in some cases, place a temporal burden on the user, we explored heuristic options. we decided to implement a non-optimal variant of pairwise global sequence alignment dp, which we call gap-restricted dp . grdp requires a user-modifiable parameter, g, which governs the maximum number of consecutive gaps that can be used during grdp pairwise alignment. because of g, the maximum traceable width of the dp matrix is held constant for all periods, is equal to 2g +  <dig>  and is symmetrically distributed with respect to the main diagonal. as a result, grdp has space complexity θ and time complexity θ, enabling a 1: <dig> correspondence between increasing period and running time. the following recursion describes grdp:

 score=max⁡{score+gapscore+θscore+gap
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaacqwgzbwccqwgjbwycqwgvbwbcqwgybgccqwglbqzcqggoaakcqwgpbqacqggsaalcqwgqbgacqggpaqkcqgh9aqpcyggtbqbcqgghbqycqgg4baedagabaqaauaabaqadeaaaeaacqwgzbwccqwgjbwycqwgvbwbcqwgybgccqwglbqzcqggoaakcqwgpbqacqghsislcqaixaqmcqggsaalcqwgqbgacqggpaqkcqghrawkcqwgnbwzcqwghbqycqwgwbacaeaacqwgzbwccqwgjbwycqwgvbwbcqwgybgccqwglbqzcqggoaakcqwgpbqacqggsaalcqwgqbgacqghsislcqaixaqmcqggpaqkcqghrawkiigacqwf4oqcaeaacqwgzbwccqwgjbwycqwgvbwbcqwgybgccqwglbqzcqggoaakcqwgpbqacqghrawkcqaixaqmcqggsaalcqwgqbgacqghsislcqaixaqmcqggpaqkcqghrawkcqwgnbwzcqwghbqycqwgwbacaaaacagl7baaaaa@779e@ 

note that depending on g, we place constraints on where each score possibility can be computed. the parameters gap and θ denote gap penalty and match/mismatch values respectively. by default, all dp procedures use values gap = - <dig>  mismatch = - <dig>  and match =  <dig>  an example of grdp alignment is shown in figure  <dig>  also, note that if g =  <dig>  xstream completely disallows gaps, and thus the decision to allow insertions/deletions  is left up to the user. by default, g =  <dig>  in addition, our implementation of grdp requires input sequences of equal length. in cases where input sequences have different lengths, both sequences are made the same length by appending gap characters to the shorter sequence. any columns with two gaps in the resulting pairwise alignment are removed. since standard dp is practical in many situations, several functions of xstream toggle grdp on and off depending on projections of time complexity. grdp is used in four major functions: tr domain expansion, tr parsing, multiple alignment, and consensus comparison.

redundancy elimination
xstream implements three strategies to eliminate two types of tr redundancy – reducible tr periods and tr domain overlap.

i) xstream searches for trs in order of increasing period. as trs are found, their corresponding sequence space is flagged, preventing further searching in processed sequence regions. this tactic combats both kinds of redundancy and reduces running time.

ii) to combat reducible tr periods, xstream is rerun on the consensus sequence of each tr domain from the input sequence.  if the consensus sequence ci of xi contains a tr domain xi that spans ci's entire length, xstream repartitions xi using the consensus of xi, resulting in xi*, whose period is an even multiple of xi's period. xi* is retained and xi erased  if xi* passes the user-adjustable tr filtration criteria.

iii) the following redundancy elimination method, invoked by default, functions to remove tr domain overlap. the user can control the execution and parameters of this method because it may not always be desirable to remove tr domain overlap and because we are convinced that the amount of reasonable overlap among tr domains is an arbitrary matter. we now state the rules that determine whether for a given tr pair xi and xj, xstream deletes one or neither. the rules are enforced in the order they are presented; i.e. rule set  must fail to move to rule set  and so on. let i = |xise ∩ xjse| . by default, α = . <dig>  β = . <dig>  γ = . <dig>  and δ = . <dig> 

i) if  ≤ i ≤ |xi| and |xi| ≤ |xj|

   if |xi| < 

      delete xi

   else if |xi| <  and 

         delete xi

      else if |xi| ≥  and ei <ej

            delete xi

         else delete xj

ii) same as  but swap i and j

iii) if i ≥ )

   if cei ≥ cej and ei ≤ ej

      delete xi

   else delete xj

iv) if i ≥ )

   delete min

two-stage tr detection
as shown in table  <dig>  xstream allows the user to restrict the tr period range. if minp <t and maxp ≥ t, tr detection proceeds in two phases, where phase i examines periods = t, and phase ii examines periods <t. by default, t =  <dig>  this procedure reduces the frequency of inconsistent results. we now describe our reasoning.

as mentioned in redundancy elimination i, trs are identified in order of increasing period and sequence space is masked for every successful seed extension. because of these two facts and because the value of minp can be altered, it is possible to differentially characterize the same tr domain xi, or perhaps miss xi altogether, for the case pi ≥ max. this problem can occur because as xstream moves up the period ladder toward pi, different stretches of sequence space may be removed in and around xi for different values of min. we determined empirically that by first scanning upward from a short period, such as  <dig>  we could greatly mitigate this problem. to illustrate, see figure  <dig> for an example of a tr domain containing many short period trs. without two-stage tr detection, this period  <dig> tr domain would not be reported since most of its sequence space would be masked by its constituent trs.

following completion of phase i, all masked sequence space is reset to unused, thereby allowing shorter period trs to be found independently of longer period trs. redundancy removal strategies ii and iii are invoked later and will remove any redundancy caused by xstream's two-stage tr detection procedure.

long period tr filter
to ensure pragmatic running time for all possible periods, we implemented a heuristic that governs seed extension for periods greater than or equal to  <dig> characters. if |s| ≥  <dig>  during seed detection, an additional hashcode array m* is kept, which stores hashcodes and sequence positions for seeds of maximum length l*, which by default is  <dig>  then, for every pair of seeds with distance ≥  <dig>  xstream initially invokes a filtration step, which jumps across m* a user-defined number of times t and looks for matching hashcodes. this method is identical to seed extension as described earlier, except that s is not used and x is incremented by floor after each hashcode comparison. thus, if g >  <dig>  cw can be invoked. xstream runs standard seed extension and tr domain expansion  on periods ≥  <dig> if and only if t* matches are recorded during the filtering phase, where t* = t/ <dig>  therefore, seed pairs with distances ≥  <dig> are subjected to a quick and preliminary filter, which although imperfect, drastically reduces running time for input sequences on the chromosome size scale. by default, t =  <dig> 

nesting
within each tr consensus sequence, xstream searches for nested trs – trs that occur within trs. this is a novel feature in the domain of protein analysis software and may provide important information about primary sequence architectures and peptide tr evolution. for a given xi, we define a nested tr as a tr present in ci that does not span ci's entire length. since tr degeneracy can complicate identifying nested structures, xstream only looks for nested trs in consensus sequences. our procedure detects nested trs of unlimited nesting depth, with no gaps and no mismatches. this algorithm employs a top-down approach to locating trs, as opposed to the bottom-up method used by xstream. a top-down approach is useful for nested trs because it identifies the longest period tr first, then in a recursive manner, restarts the algorithm within that tr, and continually digs deeper until no more trs can be found. by working off the greedy assumption that the longest period trs are the best candidates for nesting, we avoid issues of tr overlap inherent in the bottom-up strategy. the main drawback to our nesting method is its time complexity, which is o, where n = pi. we therefore restrict this method to trs from {x} with periods ≤  <dig> and only find nested trs with periods ≤  <dig>  we set the minimum nested tr period at  <dig> for proteins and  <dig> for nucleotide sequences. the time complexity is o due to the worst-case scenario of comparing subsequences of all possible sizes in all possible sequence regions.

divide and conquer
xstream implements a user-adjustable divide and conquer procedure to reduce memory consumption. if enabled, the input sequence is segmented into overlapping fragments of length l prior to tr detection. the last fragment of the input sequence may be of length <l. overlapping regions have length l*, which is equivalent to the maximum detectable tr period. after all fragments are processed, the set of identified trs are directed to the merging procedure, which functions to both extend trs across fragment boundaries and consolidate overlapping regions. by default, l =  <dig>  and l* =  <dig> .

