BACKGROUND
rna secondary structure can be predicted accurately from sequence data alone. for example, the predicted secondary structure of ribosomal rna has been essentially confirmed by recent crystal structures; 97–98% of the predicted base pairs are confirmed by experimental structures  <cit> . the trouble is that rrna predictions were refined by experts over twenty years, ultimately utilizing data from about  <dig> small subunit rrna sequences and  <dig> large subunit rrna sequences  <cit> . as there are many rna structures of biological interest  <cit> , it is important to find computational means of accelerating, automating, and improving rna secondary structure prediction  <cit> .

there are two main sources of information for rna secondary structure prediction. the most accurate means of prediction is comparative analysis  <cit> , which uses evolutionary information. homologous rnas tend to conserve a common base-paired secondary structure. important base pairing interactions are conserved by compensatory mutations and compensatory mutations induce detectable pairwise sequence correlations between positions of a multiple alignment of homologous rnas. statistical methods are used to detect co-varying base pairs, ranging from mutual information criteria  <cit>  to more sophisticated phylogenetic models  <cit> . given an accurate multiple alignment, a large number of sequences, and sufficient sequence diversity, comparative analysis alone is sufficient to produce accurate structure predictions  <cit> . the ribosomal rna secondary structure predictions were derived primarily from comparative analysis.

one also has substantial a priori knowledge of how rnas are likely to fold. rna structures favor certain base stacking interactions and loop lengths, as a result of the thermodynamics of a folded structure. a nearest-neighbor model for predicting the free energy of rna secondary structures has been developed  <cit> . given an rna sequence and the thermodynamic model, efficient dynamic programming algorithms exist for finding a minimum free energy secondary structure  <cit> . energy minimization is not as accurate as comparative analysis  <cit> , but unlike comparative analysis, it can be applied to single rna sequences.

a problem of current interest is the prediction of a consensus secondary structure for a small number of structurally homologous rna sequences, i.e. when some evolutionary information is available, but not enough for a pure comparative analysis approach. here one wants to combine evolutionary information and thermodynamic information. this problem now arises frequently because of the availability of comparative genome sequence data. approaches described thus far fall into two classes: the rna sequence alignment is treated as known  <cit> , or the sequences are given unaligned, leading to an even harder problem of simultaneous folding and alignment  <cit> .

here we are interested in the problem of simultaneous folding and alignment , for which an algorithmic solution was described by david sankoff  <cit> . the algorithm is computationally demanding, requiring o and o in space and time respectively for n sequences of length l. consequently, most subsequent work on the problem has focused on the case of pairwise structural alignment, limiting the number of sequences to two .

when applying a consensus structure prediction algorithm, it is necessary to decide what score should be optimized by the algorithm, so that a mathematically optimal structure has the best chance of representing the biologically correct structure. the evolutionary information in comparative sequence analysis is most naturally treated by probabilistic models. single-sequence rna secondary structure predictions are usually scored by thermodynamic models and energy minimization. these two scoring systems do not combine naturally. the earliest practical implementation of a simplified version of the sankoff algorithm was gorodkin's foldalign  <cit>  which simply utilized an ad hoc additive combination of alignment scoring matrices and base pair maximization. it would be advantageous to find a more unified and formally justifiable scoring treatment.

basing the overall objective function purely on thermodynamics seems problematic, because it is hard to see how to express inherently stochastic evolutionary events in terms of free energies. nonetheless, mathews and turner's dynalign program  <cit>  does do this, and performs well: it uses a sankoff algorithm to find an optimal alignment and consensus structure for a pair of rna sequences by optimizing the sum of the two structures' predicted free energies, while using an ad hoc pseudoenergy penalty for indels.

deriving a combined objective function in terms of probability theory seems more straightforward. one can find a consensus structure with maximum posterior probability by finding the structure that maximizes the joint probability of both the sequences and the structure. a fully probabilistic treatment of the simultaneous alignment and folding of two rna sequences has been described using pairwise stochastic context-free grammars  and an algorithm essentially identical to the sankoff algorithm  <cit> .

any practical implementation of the sankoff algorithm must also find a way to reduce its prohibitive computational complexity. gorodkin's original foldalign <cit>  did not permit multi-branch loops, focusing instead on the simpler problem of stem finding. mathews and turner's dynalign implementation assumes a global alignment in order to fix a window of width ℳ
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbamrthrhal1wy0l2yhvtyaehbnfgdovwbhrxajfwnaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabawaaegaeaaakeaaimaacqwfzestaaa@3790@ around the alignment diagonal  <cit> . in other words, a position in sequence x is restricted to align within ± ℳ
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbamrthrhal1wy0l2yhvtyaehbnfgdovwbhrxajfwnaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabawaaegaeaaakeaaimaacqwfzestaaa@3790@ of the same position in sequence y. a recent update to foldalign uses a similar windowing approach, limiting both the alignment width and folding distance <cit> . hofacker precomputes base pairing probability matrices and then attempts to determine an alignment between these matrices <cit> . holmes uses an alternative approach, restricting a pairscfg to searching for the structural alignment among a set of precomputed single sequence secondary structures and a set of precomputed alignments <cit> .

here we describe a practical constrained pairwise global rna structural alignment algorithm using pairscfgs. we first describe a pairscfg description of the structural alignment algorithm which extends our earlier work on scfg design  <cit> . we parameterize and evaluate this full  structural alignment algorithm. we then outline a constrained structural algorithm which assumes knowledge of a few fixed positions, or "pins", within the alignment. we derive high-confidence pins from posterior probabilities in a probabilistic primary sequence alignment. we find that the constrained algorithm greatly improves cpu and memory requirements with minimal impact on alignment and structure prediction accuracy. finally, we compare the performance of our algorithm with the other constrained rna structural alignment implementations: dynalign  <cit> , stemloc  <cit> , foldalign  <cit> , and pmcomp  <cit> .

RESULTS
algorithms
stochastic context-free grammars  are a probabilistic framework for modeling non-pseudoknotted secondary structure of rnas. we assume familiarity with scfgs as described in  <cit>  and  <cit> . scfgs provide a toolkit for designing rna structure prediction and alignment methods. many different scfg designs are possible for describing an rna structural alignment. a good design would be one that captures the informative statistics of rna structural features – base pair stacking correlations, loop length preferences, and so on – with as much biological realism as possible. on the other hand, a good design must also be simple enough that it has a reasonable number of free parameters so it can be trained on known data.

ideally the scfg design should be formally unambiguous with respect to both secondary structure and alignment  <cit> . that is, an scfg alignment algorithm will produce an optimal parse tree π that describes how the grammar aligns and scores the two sequences. there must be a strict one-to-one relationship between parse trees and alignments, as well as parse trees and base-paired secondary structures, in order for the optimal parse tree to be interpretable as an optimal alignment and structure.

we consider one alignment to be a set of aligned residue pairs. any two alignments that yield the same set of aligned residue pairs are considered identical. that is,

a-bd

ef-g

and

ab-d

e-fg

are the same alignment ,. a grammar is alignment-ambiguous if there exists an alignment that can be generated by more than one possible parse tree.

similarly, we consider one secondary structure to be a set of base pairs. any two structures that yield the same set of base pairs are the same structure. a grammar is structurally ambiguous if there exists a secondary structure that can be generated by more than one possible parse tree.

the consequence of using an ambiguous grammar is that the probability of a single alignment or structure may be spread across many parse trees that describe the same set of aligned residues or base pairs, therefore an optimal parse tree could represent a less optimal alignment or structure that merely has fewer alternative parse tree representations. our previous work  <cit>  indicated that this is a significant practical concern. grammar ambiguity is not usually an issue for non-probabilistic scoring systems that simply seek to maximize an arbitrary score.

in our previous work  <cit>  we demonstrated that small simple unambiguous stochastic context-free grammar designs can give reasonably good single sequence rna structure prediction performance. in particular, a grammar such as:

gs     s → as | t | ε

t → ta | apa' | tapa'

p → apa' | n

n → as | ta | tapa'

was found to give good secondary structure performance for a reasonably small number of parameters. the notation t → apa' implies a basepairs with a', '|' denotes 'or' between production rules, and ε is the null string used to represent an ending production. the symbols a is used generically to represent any nucleotide of rna . all  <dig> possible base pairs are permitted, including non-canonical pairs with low probability.

we can extend this grammar to the problem of pairwise structural alignment, the simultaneous sequence alignment and structure prediction of two sequences, simply by making it generate two correlated sequences instead of one. a different grammar from  <cit>   was found to give slightly better single sequence structure prediction performance, but appears to be difficult to extend to an alignment-unambiguous pair grammar.

to handle structural alignment, the scfg is extended to emit a correlated pair of sequences, x and y. as we are interested in identifying shared structure, we first extend base pairing states to the pairwise case, abpa′b′
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaafaqabegabaaabagaemyyaegabagaemoyaigaaiabdcfaqvaabeqaceaaaeaacuwghbqygaqbaaqaaiqbdkgaizaafaaaaaaa@3337@ where the notation implies a basepairs with a' in sequence x and b basepairs with b' in sequence y. this rule effectively captures basepair correlations observed in evolutionarily conserved secondary structures. in unpaired regions, the grammar reverts to an alignment algorithm so we logically replace each unpaired region of the scfg with a typical pairhmm model of alignment <cit> . the resulting pairwise scfg  grammar is:

s→abs|a−lx|−bly|t|εt→tab|rxa−|ry−b|abpa′b′|tabpa′b′lx→abs|a−lx|t|εly→abs|−bly|t|εrx→tab|rxa−|abpa′b′|tabpa′b′ry→tab|ry−b|abpa′b′|tabpa′b′p→abpa′b′|nn→abs|a−lx|−bly|tab|rxa−|ry−b|tabpa′b′
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakqaabeqaaiabdofatjabgkziuwaabeqaceaaaeaacqwghbqyaeaacqwgibgyaagaem4uamlaeiifawxbaeqabiqaaaqaaiabdggahbqaaiabgkhitaaacqwgmbatdawgaawcbagaemieaghabeaakiabcyha8vaabiqaceaaaeaacqghsislaeaacqwgibgyaagaemitaw0aasbaasqaaiabdmha5bqabagccqgg8bafcqwgubavcqgg8bafiigacqwf1oqzaeaacqwgubavcqghsgircqwgubavfaqabegabaaabagaemyyaegabagaemoyaigaaiabcyha8jabdkfasnaabaaaleaacqwg4baeaeqaaoqbaeqabiqaaaqaaiabdggahbqaaiabgkhitaaacqgg8bafcqwgsbgudawgaawcbagaemyeakhabeaakuaabeqaceaaaeaacqghsislaeaacqwgibgyaagaeiifawxbaeqabiqaaaqaaiabdggahbqaaiabdkgaibaacqwgqbaufaqabegabaaabagafmyyaembauaaaeaacuwgibgygaqbaaaacqgg8bafcqwgubavfaqabegabaaabagaemyyaegabagaemoyaigaaiabdcfaqvaabeqaceaaaeaacuwghbqygaqbaaqaaiqbdkgaizaafaaaaaqaaiabdyeamnaabaaaleaacqwg4baeaeqaaogaeyokh4abaeqabiqaaaqaaiabdggahbqaaiabdkgaibaacqwgtbwucqgg8baffaqabegabaaabagaemyyaegabagaeyoei0caaiabdyeamnaabaaaleaacqwg4baeaeqaaogaeiifawnaemivaqlaeiifawnae8xtdugabagaemitaw0aasbaasqaaiabdmha5bqabagccqghsgirfaqabegabaaabagaemyyaegabagaemoyaigaaiabdofatjabcyha8vaabeqaceaaaeaacqghsislaeaacqwgibgyaagaemitaw0aasbaasqaaiabdmha5bqabagccqgg8bafcqwgubavcqgg8bafcqwf1oqzaeaacqwgsbgudawgaawcbagaemieaghabeaakiabgkziukabdsfauvaabeqaceaaaeaacqwghbqyaeaacqwgibgyaagaeiifawnaemouai1aasbaasqaaiabdiha4bqabagcfaqabegabaaabagaemyyaegabagaeyoei0caaiabcyha8vaabeqaceaaaeaacqwghbqyaeaacqwgibgyaagaemiuaavbaeqabiqaaaqaaiqbdggahzaafaaabagafmoyaimbauaaaagaeiifawnaemivaqvbaeqabiqaaaqaaiabdggahbqaaiabdkgaibaacqwgqbaufaqabegabaaabagafmyyaembauaaaeaacuwgibgygaqbaaaaaeaacqwgsbgudawgaawcbagaemyeakhabeaakiabgkziukabdsfauvaabeqaceaaaeaacqwghbqyaeaacqwgibgyaagaeiifawnaemouai1aasbaasqaaiabdmha5bqabagcfaqabegabaaabagaeyoei0cabagaemoyaigaaiabcyha8vaabeqaceaaaeaacqwghbqyaeaacqwgibgyaagaemiuaavbaeqabiqaaaqaaiqbdggahzaafaaabagafmoyaimbauaaaagaeiifawnaemivaqvbaeqabiqaaaqaaiabdggahbqaaiabdkgaibaacqwgqbaufaqabegabaaabagafmyyaembauaaaeaacuwgibgygaqbaaaaaeaacqwgqbaucqghsgirfaqabegabaaabagaemyyaegabagaemoyaigaaiabdcfaqvaabeqaceaaaeaacuwghbqygaqbaaqaaiqbdkgaizaafaaaaiabcyha8jabd6eaobqaaiabd6eaojabgkziuwaabeqaceaaaeaacqwghbqyaeaacqwgibgyaagaem4uamlaeiifawxbaeqabiqaaaqaaiabdggahbqaaiabgkhitaaacqwgmbatdawgaawcbagaemieaghabeaakiabcyha8vaabeqaceaaaeaacqghsislaeaacqwgibgyaagaemitaw0aasbaasqaaiabdmha5bqabagccqgg8bafcqwgubavfaqabegabaaabagaemyyaegabagaemoyaigaaiabcyha8jabdkfasnaabaaaleaacqwg4baeaeqaaoqbaeqabiqaaaqaaiabdggahbqaaiabgkhitaaacqgg8bafcqwgsbgudawgaawcbagaemyeakhabeaakuaabeqaceaaaeaacqghsislaeaacqwgibgyaagaeiifawnaemivaqvbaeqabiqaaaqaaiabdggahbqaaiabdkgaibaacqwgqbaufaqabegabaaabagafmyyaembauaaaeaacuwgibgygaqbaaaaaaaa@1376@

which has eight nonterminals and  <dig> production rules. we postulate that this grammar is both structurally unambiguous and alignment-unambiguous .

this grammar lacks at least two features that are thought to be biologically important in rna folding. it does not have stacking rules; base pair emissions are statistically independent of each other. it also does not have explicit length distributions for hairpin loops, bulge loops, interior loops, and multiloops. all length distributions are modeled in this grammar by rules of the general form s → as, which imply a geometric length distribution. unambiguous scfg designs that capture a more biologically realistic model of rna are more complex, and we have deferred them to future work.

maximum likelihood structure prediction
given a parameterized pairscfg model and two input sequences, we find the maximum likelihood parse tree  by a pairscfg cyk algorithm  <cit> . more formally, given a scfg and the parameters of the model  the cocke-younger-kasami  algorithm finds the optimal parse tree π^
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaaiigacuwfapacgaqcaaaa@2e80@

π^
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaaiigacuwfapacgaqcaaaa@2e80@ = argmaxπ p

for the set of input sequences x. for single sequence scfgs, x = {x} whereas for a pairscfg x = {x, y}. this dynamic programming algorithm works by calculating the likelihood of all partial subsequences of the inputs, starting with zero length sequences and working outward to their full lengths. in general each nonterminal of a grammar requires an additional dynamic programming matrix. for example, the p nonterminal of gs, described by production rules p → apa' | n is computed as:

p=max⁡{p+log⁡pp+log⁡p
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaacqwgqbaucqggoaakcqwgpbqacqggsaalcqwgqbgacqggpaqkcqgh9aqpcyggtbqbcqgghbqycqgg4baedagabeqaauaabaqaceaaaeaacqwgqbaucqggoaakcqwgpbqacqghrawkcqaixaqmcqggsaalcqwgqbgacqghsislcqaixaqmcqggpaqkcqghrawkcyggsbabcqggvbwbcqggnbwzcqwgwbaccqggoaakcqwgqbaucqghsgircqwg4baedawgaawcbagaemyaakgabeaakiabdcfaqjabdiha4naabaaaleaacqwgqbgaaeqaaogaeiykakcabagaemiuaalaeiikagiaemyaakmaeiilawiaemoaaomaeiykakiaey4kasiagiibawmaei4ba8maei4zacmaemicaanaeiikagiaemiuaalaeyokh4qaemota4kaeiykakcaaagaay5eaaaaaa@68cd@

whereas in the pairscfg the p nonterminal, described by production rules p → abpa′b′
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaafaqabegabaaabagaemyyaegabagaemoyaigaaiabdcfaqvaabeqaceaaaeaacuwghbqygaqbaaqaaiqbdkgaizaafaaaaaaa@3337@ | n, is computed as:

p=max⁡{p+log⁡pn+log⁡p
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaacqwgqbaucqggoaakcqwgpbqacqggsaalcqwgqbgacqgg7awocqwgrbwacqggsaalcqwgsbabcqggpaqkcqgh9aqpcyggtbqbcqgghbqycqgg4baedagabeqaauaabaqaceaaaeaacqwgqbaucqggoaakcqwgpbqacqghrawkcqaixaqmcqggsaalcqwgqbgacqghsislcqaixaqmcqgg7awocqwgrbwacqghrawkcqaixaqmcqggsaalcqwgsbabcqghsislcqaixaqmcqggpaqkcqghrawkcyggsbabcqggvbwbcqggnbwzcqwgwbaccqggoaakcqwgqbaucqghsgirfaqabegabaaabagaemieag3aasbaasqaaiabdmgapbqabaaakeaacqwg5bqedawgaawcbagaemyaakgabeaaaagccqwgqbaufaqabegabaaabagaemieag3aasbaasqaaiabdqgaqbqabaaakeaacqwg5bqedawgaawcbagaemoaaogabeaaaagccqggpaqkaeaacqwgobgtcqggoaakcqwgpbqacqggsaalcqwgqbgacqgg7awocqwgrbwacqggsaalcqwgsbabcqggpaqkcqghrawkcyggsbabcqggvbwbcqggnbwzcqwgwbaccqggoaakcqwgqbaucqghsgircqwgobgtcqggpaqkaaaacagl7baaaaa@8086@

from this example, the correspondence between grammar rules and the cyk algorithm should be clear. an example parse tree from the pairscfg is shown in figure  <dig>  this algorithm is o in memory and o in time for two sequences of lengths n and m. as we are focusing on the global alignment of homologous rnas, we assume that the lengths of the two sequences are roughly comparable and the algorithm is o in memory and o in time.

parameterization
given the set of pairscfg production rules above, we need to determine all the necessary probability parameters. as is common for many stochastic models  <cit> , we distinguish transition parameters for the probability of using a production rule from emission parameters that generate any nucleotide from the rule.

we use two types of parameter tying to reduce the number of free parameters in the model. first, we assume that the model should be symmetric, assigning the same probability to x, y and y, x. second, we tie several additional "equivalent" parameters together, as follows.

an untied version of the pairscfg would require  <dig> emission parameters: there are  <dig> rules that generate single nucleotides ,  <dig> aligned nucleotide rules , and  <dig> aligned base pair nucleotide rules . we reduce these to one emission distribution for single  nucleotides, one symmetric  <dig> ×  <dig> matrix for emitting unpaired aligned residues, and one symmetric  <dig> ×  <dig> matrix for aligned base pairs. the tied model has  <dig> emission parameters, of which  <dig> are free.

the untied pairscfg has  <dig> production rules, hence  <dig> transition probabilities. we group transition parameters such that gaps are treated equivalently in x and y by tying together the sets of parameters utilized for "gap open", "gap extend", and "gap closure". for example s→a−lx
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaacqwgtbwucqghsgirfaqabegabaaabagaemyyaegabagaeyoei0caaiabdyeamnaabaaaleaacqwg4baeaeqaaaaa@34d3@ must equal s→−bly
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaacqwgtbwucqghsgirfaqabegabaaabagaeyoei0cabagaemoyaigaaiabdyeamnaabaaaleaacqwg5bqeaeqaaaaa@34d7@ as both rules are used as "gap open" parameters. likewise, the rules of lx are tied to the rules of ly as they both represent "gap extend" and "gap closure" rules. the tied model has  <dig> transition parameters, of which  <dig> are free.

the  <dig> parameters of the pairscfg were then estimated from the frequencies observed in annotated ribosomal rna secondary structures from multiple alignments in the european ribosomal database  <cit> . sequences containing more than 5% ambiguous bases or with less than 40% base pairing are discarded. the resulting data set was then filtered to remove sequences with greater than 80% idenity to avoid overcounting nearly identical alignments. the two resulting multiple sequence alignments contain  <dig> sequences, of which  <dig> are small subunit and  <dig> are large subunit, and a total of  <dig> , <dig> nucleotides. the parse tree for each implicit pairwise structural alignment is determined, and the number of occurrences of each production type is counted. all pairs, excluding self-to-self comparisons, are counted. probabilities are estimated from the counts using a laplace  prior  <cit> .

because the training dataset consisted of many sequences but only two different rna structures , we had some concern that the model might fail to generalize to other, shorter, structural rnas. to address this concern, we compared two models trained on two independent training sets. the first is the aforementioned rrna dataset. the second is composed of all seed rfam v <dig>  families marked as published. each family was filtered at 80% identity and those with fewer than two sequences remaining were subsequently removed. the ssu rfam family was removed to avoid overlap with the rrna training set. the resulting dataset consisted of  <dig> families, a total of  <dig> sequences with an average length of  <dig> nucleotides, and a total of  <dig>  nucleotides.

constrained cyk algorithm
at o memory and o time, the full  pairscfg cyk algorithm is barely practical. on current computers, it becomes unreasonable for rnas of more than about  <dig> nucleotides in length. our heuristic strategy is to constrain the algorithm by a small number of primary sequence alignment pins representing confidently aligned pairs of residues. using pins  to fix portions of the alignment is used by a number of sequence alignment programs to allow very long alignments  <cit> . given a set of pins , the constrained pairscfg cyk algorithm is as follows:

by convention, i, a, and j are indices in x and k, b, and l are indices in y. sequence x is length m and y is length n. the subsequence i...j aligns to k...l. for each nonterminal in the grammar we keep a four dimensional matrix, i, j, k, l. the indices a and b locate the split points in a bifurcation rule. with bifurcation rules, we must consider all possible split points, therefore  <dig> ≤ i <a <j ≤ m and  <dig> ≤ k <b <l ≤ n.

we define a pin qz as a coordinate pair , qz ) where the nucleotide qz  aligns to the nucleotide qz . the ordered set of alignment pins q
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbamrthrhal1wy0l2yhvtyaehbnfgdovwbhrxajfwnaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabawaaegaeaaakeaaimaacqwfqefuaaa@3841@ contains z pins, numbered from the 5' end of sequence x, i.e. z =  <dig> .z. we always define two pins  as boundary conditions: one which comes before the 5' nucleotide of each sequence q <dig> =  and one which follows the 3' nucleotide of each sequence qz = .

we seek to calculate

π^
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaaiigacuwfapacgaqcaaaa@2e80@ = argmaxπ p 

the highest probability parse tree π^
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaaiigacuwfapacgaqcaaaa@2e80@ for the sequences x and y given the set of alignment pins q
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbamrthrhal1wy0l2yhvtyaehbnfgdovwbhrxajfwnaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabawaaegaeaaakeaaimaacqwfqefuaaa@3841@, the pairwise grammar g
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbamrthrhal1wy0l2yhvtyaehbnfgdovwbhrxajfwnaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabawaaegaeaaakeaaimaacqwfge=raaa@382d@, and the parameters of the model Θ. if the pins are "correct" relative to the unconstrained structural alignment, i.e. , qz }) ∈ π^
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaaiigacuwfapacgaqcaaaa@2e80@ = argmaxπ p , then the constrained algorithm is guaranteed to find the same optimal structural alignment π^
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaaiigacuwfapacgaqcaaaa@2e80@ as generated by the unconstrained algorithm.

given q
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbamrthrhal1wy0l2yhvtyaehbnfgdovwbhrxajfwnaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabawaaegaeaaakeaaimaacqwfqefuaaa@3841@, we define a segment s
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbamrthrhal1wy0l2yhvtyaehbnfgdovwbhrxajfwnaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabawaaegaeaaakeaaimaacqwfse=uaaa@3845@ as the range of index k in y which must be considered for a particular i in x. a position i between pins qz and qz+ <dig> has a segment s
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbamrthrhal1wy0l2yhvtyaehbnfgdovwbhrxajfwnaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabawaaegaeaaakeaaimaacqwfse=uaaa@3845@ which implies qz  <k <qz+ <dig> . we refer to edges of the range, in this case qz  and qz+ <dig>  as s
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbamrthrhal1wy0l2yhvtyaehbnfgdovwbhrxajfwnaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabawaaegaeaaakeaaimaacqwfse=uaaa@3845@l  and s
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbamrthrhal1wy0l2yhvtyaehbnfgdovwbhrxajfwnaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabawaaegaeaaakeaaimaacqwfse=uaaa@3845@r  respectively. refer to figure  <dig> panel a for a labeled example. in the absence of constraints, q
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbamrthrhal1wy0l2yhvtyaehbnfgdovwbhrxajfwnaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabawaaegaeaaakeaaimaacqwfqefuaaa@3841@ contains two pins , s
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbamrthrhal1wy0l2yhvtyaehbnfgdovwbhrxajfwnaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabawaaegaeaaakeaaimaacqwfse=uaaa@3845@ is the full n nucleotides of y, and the algorithm computes the full unconstrained structural alignment algorithm.
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbamrthrhal1wy0l2yhvtyaehbnfgdovwbhrxajfwnaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabawaaegaeaaakeaaimaacqwfse=uaaa@3845@l and s
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbamrthrhal1wy0l2yhvtyaehbnfgdovwbhrxajfwnaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabawaaegaeaaakeaaimaacqwfse=uaaa@3845@r for each position in x are labeled. in this notation, j is the potential base pairing partner of i, l is the potential base pairing partner of k, and the subsequence i...j aligns with k...l. the indices a and b are the required for identifying bifurcation points. panel b: the constrained structural alignment algorithm in pseudocode, where m is the length of sequence x, s
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbamrthrhal1wy0l2yhvtyaehbnfgdovwbhrxajfwnaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabawaaegaeaaakeaaimaacqwfse=uaaa@3845@l  is the left edge of the segment containing the position i, and s
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbamrthrhal1wy0l2yhvtyaehbnfgdovwbhrxajfwnaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabawaaegaeaaakeaaimaacqwfse=uaaa@3845@r is the right edge of the segment containing i. the max in the range for l is required to handle the case where i and j share the same segment. the b range must be handled similarly. panel c: the special case where the position under consideration is equivalent to a pin. in this case, we know the location of its alignment partner but must also consider the possibility of insertions in y which may occur before or after this pin.

each constraint provided is an additional pin in q
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbamrthrhal1wy0l2yhvtyaehbnfgdovwbhrxajfwnaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabawaaegaeaaakeaaimaacqwfqefuaaa@3841@ and reduces the range of indices which must be considered. figure  <dig> panel b outlines the constrained structural alignment algorithm in pseudocode. the existence of alignment pins does not restrict the structure prediction  of the first sequence, x. however, for a particular instance of each of these indices, the corresponding range of analogous positions in y  is reduced. if we were using an ungapped alignment approach, a single midpoint pin would reduce the range of indices in y by 1/ <dig>  effectively reducing the memory by 1/ <dig> and the runtime by 1/ <dig> 

when a position of interest i is a pin, the precise alignment partner is known. it might seem that the segment s
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbamrthrhal1wy0l2yhvtyaehbnfgdovwbhrxajfwnaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabawaaegaeaaakeaaimaacqwfse=uaaa@3845@should therefore be one nucleotide, but this is only true in ungapped alignments. in gapped alignments, we must consider that the pin may end or begin a gap. an indel aligns a nucleotide to nothing and in the dynamic programming algorithm one index k progresses while the other i is fixed. consequently, to consider all possible gap states requires s
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbamrthrhal1wy0l2yhvtyaehbnfgdovwbhrxajfwnaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabawaaegaeaaakeaaimaacqwfse=uaaa@3845@) to imply qz- <dig>  <k <qz+ <dig> . in this case the segment s
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbamrthrhal1wy0l2yhvtyaehbnfgdovwbhrxajfwnaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabawaaegaeaaakeaaimaacqwfse=uaaa@3845@ overlaps the segments s
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbamrthrhal1wy0l2yhvtyaehbnfgdovwbhrxajfwnaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabawaaegaeaaakeaaimaacqwfse=uaaa@3845@ and s
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbamrthrhal1wy0l2yhvtyaehbnfgdovwbhrxajfwnaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabawaaegaeaaakeaaimaacqwfse=uaaa@3845@, shown in figure  <dig> panel c. for this reason, a single midpoint pin takes more memory and longer time than the ungapped case.

testing
our work on single sequence grammars indicated that prediction accuracy can vary significantly between rna families  <cit> . the recent benchmark of gardner et. al. utilizes only a set of trna alignments to compare pairwise structural alignment algorithms  <cit> . we desired to extend this test set to multiple rna families, but are limited to small rnas to facilitate comparison to the unconstrained sankoff algorithm. therefore we use as our primary test data  <dig> trna and  <dig> 5s rna sequences in the rfam v <dig>  seed alignments  <cit> . different subsets of these data were generated to examine particular aspects of the pairscfg, as described in results.

we also obtained published test sets from david mathews <cit>  and ian holmes <cit>  to facilitate direct comparison to dynalign and stemloc. the mathews sets consist of trna, srp and 5s rna sequences, where each sequence has a known secondary structure but alignment information is not given. the holmes dataset consists of sequences from rfam v <dig>  seed alignments spanning seven different families. the pairs utilized have published consensus secondary structure and no pair is higher than 60% identical. the set includes  <dig> s <dig> pairs,  <dig> u <dig> pair,  <dig> glms riboswitch pairs,  <dig> purine riboswitch pairs,  <dig> u <dig> pairs,  <dig> ire pairs, and  <dig> 6s rna pairs, for a total of  <dig> pairwise comparisons.

we utilize base pair sensitivity and base pair positive predictive value  as structure prediction accuracy measures  <cit> . we compare the structure predicted by the pairscfg to the structure given in the trusted alignment. we report sensitivity and ppv as cumulative statistics over all possible base pairs  within the testset.

we calculate the alignment identity between the trusted pairwise structural alignment and our predicted alignment, defined as the number of alignment columns correctly determined relative to the trusted  alignment. as with structure comparisons, we compute alignment identity cumulatively over all columns in all alignment pairs.

we determine the standard deviation of all three measures by bootstrapping using  <dig>  samples <cit> .

implementation
parameter estimation  and the cyk algorithm was written for both the pairscfg and its corresponding single sequence grammar gs. the constrained cyk algorithm was implemented for the pairscfg in ansi c. the source code for the package, called consan, is freely available under the gnu general public license  from  <cit> . the training and test data are freely available from the same url.

to determine pins, we utilize ian holmes' dpswalign program, a pairhmm implementation from his dart package v <dig>  <cit> . the program is used with default parameters. two options are utilized, the "-pt" option returns the posterior probability table between any two sequences and the "-oa" option returns the optimal accuracy alignment.

for benchmarking experiments, we use mfold v <dig> . <dig>  clustalw v <dig> , dynalign , and stemloc from the dart software package v <dig>  , rnafold from the viennarna v <dig>  package, the pmcomp.pl script , and foldalign v <dig> . <dig>  dynalign is used with the parameters suggested in  <cit> , stemloc uses the parameters described in  <cit> , pmcomp and foldalign are utilized as described in  <cit> . benchmarks were conducted on a a dual  <dig>  ghz p <dig> linux machine with  <dig>  gb of memory.

pairwise structure prediction improves relative to single sequence
in earlier work  <cit> , we showed that small single sequence grammars similar to gs have only slightly worse performance than standard minimum energy methods. in order to verify that the new gs single-sequence grammar design performs similarly to the previously tested small grammars, we trained it using the rrna training set and compare its performance to mfold for single sequence folding on a test set of  <dig> trna and  <dig> 5s sequence randomly chosen from the rfam v <dig>  seed alignments. as shown in table  <dig>  the gs grammar shows the expected performance lag relative to mfold, a necessary trade-off for a simpler grammar <cit> .

using the pairscfg to compare a sequence to itself  shows that the pairwise grammar performs roughly equivalent to its single sequence counterpart in the absence of alignment information.

as a control experiment to verify that the extension to a pairscfg does not significantly alter single sequence prediction accuracy , we evaluated the pairscfg on "pairwise alignments" of the test sequences to themselves, with the expectation that it should show similar performance to the single sequence grammar gs.

we then tested whether the corresponding pairscfg improved structure prediction accuracy on the same test set, using the unconstrained pairscfg cyk algorithm. we trained the pairscfg on all pairs of the rrna training set. using the same 5s and trna test set, we randomly selected an "informant" sequence from the 5s and trna seed alignments within the 55–80% identity range emphasized by the rrna training set. in evaluation, however, we only consider the ability to predict the original test sequence's structure.

structure prediction accuracy depends on pairwise sequence identity
we expect that the performance of any pairwise structural alignment algorithm will depend on the similarity of the sequence pair. closely related pairs will lack sufficient covariation to differ from single sequence structure prediction. pairs at too great a distance may be difficult to align even when secondary structure information is taken into account.

to test the effects of sequence identity on both structure and alignment performance, we built a series of test sets binned by pairwise identity. the rfam v <dig>  seed alignment sequence pairs for 5s and trna are divided into  <dig> bins, each representing a 5% identity interval for the known structural alignment. within each bin  <dig> sequence pairs are selected at random for both 5s and trna. because sequence pairs were unavailable at the lowest percent identities, the resulting test set contains  <dig> trna pairs between 9% and 99% identical and  <dig> are 5s pairs between 32% and 99% identical.

we then utilize these binned sets to compare the pairwise alignment accuracy of the pairscfg to clustalw, shown in figure 4a. alignment accuracy improves as sequence identity increases, as expected, and the pairscfg is a more robust aligner at lower sequence identities.

we also examined the structure prediction accuracy of the pairscfg over a range of sequence identities. for comparison to mfold and the single sequence grammar gs, we extract all individual sequences and determined the base pair sensitivity on this collective set. these results are shown in figure 4b.

for structure prediction, the accuracy of the pairscfg at low  and high  is not strikingly different than single sequence prediction by mfold or gs. for sequence pairs between  <dig> and 90% identity, the pairscfg improves structure prediction with respect to mfold by about 10% on average for 5s and about 20% for trna.

the unconstrained algorithm is compute-intensive
although the alignment and structure prediction results above are promising, the runtime and memory requirements of the unconstrained pairscfg algorithm are extreme. for two representative trnas, lengths  <dig> and  <dig>  the algorithm requires  <dig> mb of memory and  <dig> seconds. for two representative 5s sequences, lengths  <dig> and  <dig>  the algorithm requires  <dig> mb of memory and  <dig>  seconds.

generating pins for the constrained algorithm
we think we can afford to focus on comparisons within a particular broad range of similarity because comparative genome sequencing has advanced so that there are often many sequence homologs available at different levels of similarity. we usually have some freedom to pick and choose "optimal" homologs for assisting an rna secondary structure prediction.

to obtain a set of pins consistent with a single alignment, and to rank them by reliability, we use a pairhmm to calculate a posterior probability for each aligned pair of residues in a pairwise sequence alignment, using ian holmes' dpswalign program in his dart package, and we calculate an "optimal accuracy" alignment that maximizes the sum of these posteriors  <cit> . in principle, we expect that a 90% posterior probability pair should be correct 90% of the time. to test how well posterior probabilities are actually correlated with correct alignment, using the same test sets as above binned by percent identity, we collected the calculated posterior probability for all aligned residue pairs in all pairwise alignments in each bin, and assessed their correctness relative to the known structural alignment. the result is shown in figure  <dig>  in optimal accuracy alignments, the calculated posterior probabilities predict empirical alignment accuracy reasonably well. 99% of pairs with  <dig>  posteriors are correct, and 93% of pairs with posteriors between . <dig> and  <dig>  are correct.

we then select a subset of "quality" pins from the set of aligned residues in the optimal accuracy alignment. pin selection is a trade-off. with each additional pin, the constrained algorithm will take less memory and time; however, because pins are fixed, an incorrect pin choice cannot be rectified later by the constrained algorithm. additionally, pins that are evenly spaced provide more of a performance gain, as opposed to pins that are tightly clustered. one method of enforcing pin spacing is to define a window around each pin in which no other pins can be selected.

we examined a number of different combinations of posterior probability cutoffs between  <dig>  and  <dig>  and "protection windows" between  <dig> and  <dig> nucleotides using a pin selection strategy which is greedy, always selecting the best available pin given the protection window. regardless of the posterior threshold, with short protection windows  incorrect pins are detected in many pairs, including those with high percent identity . the average compute resource requirements  increase with window length, as this is the primary determinant of the number of pins possible. for example, at a protection window of  <dig> nucleotides, the average number of pins found for the set of 5s pairs containing at least one pin is  <dig>  and the average runtime is approximately  <dig> seconds. increasing the window to  <dig> nucleotides decreases the average pins found to  <dig>  which results in a average runtime of  <dig> seconds. at a particular window length, the posterior probability threshold affects both the number of sequence pairs for which any pin can be found and the ability of the constrained algorithm to reproduce the unconstrained results.

the settings for the posterior threshold and window length parameters trade off compute performance against alignment and structure prediction accuracy. table  <dig> shows, as an example, results of changing the posterior probability threshold on the trna subset of the testset using a fixed window length of  <dig> nucleotides. results for the 5s subset and other window lengths have similar trends . reducing the posterior threshold increases the number of sequence pairs containing at least one pin, and thus increases the number and dissimilarity of sequence pairs that can be aligned in constrained mode. in this experiment, the performance of the constrained algorithm is not statistically different from the unconstrained algorithm for any of the examined posterior cutoffs; however, figure  <dig> indicates that a posterior of  <dig>  is only correct about 75% of the time. therefore  <dig> of every  <dig> pins selected at a  <dig>  threshold would be expected to be incorrect, so it would not be wise to reduce the threshold too far, for fear of introducing incorrect pins. we chose a default pin selection strategy of greedily selecting pins greater than  <dig>  posterior probability with a  <dig> nucleotide protection window. a user might need to reduce the default posterior threshold to align highly dissimilar sequences; we see little reason for a user to alter the protection window parameter.

for higher posterior thresholds, there are fewer sequence pairs in which at least one pin can be identified; the number of sequence pairs that can be pinned and aligned is indicated in the num pairs column, and the percent identity of the most dissimilar pair that can be pinned is indicated in the lowest id column. for the subset of pairs that can be pinned at a given posterior threshold, we evaluate basepair sensitivity  and alignment identity  for full sankoff  alignment and the constrained  alignment. comparing these numbers within each row indicates the performance impact of the constraints. the average and maximum resource requirements  are also shown for each posterior cutoff. the performance gain from pins is primarily determined by the number of pins assigned in a sequence pair. for the subset of sequence pairs that can be pinned at all, the average number of pins is largely a function of the window length and somewhat independent of posterior threshold . the maximum time and memory requirements are typically for a sequence pair in which only a single pin was discovered.

pin number and compute requirements depend on pairwise sequence identity
having decided on this strategy, we next evaluated how many pins are generated for sequences of different levels of identity. the availability of at least one quality pin correlates roughly with the percent identity of the sequence pair. all pairs > 45% identical have at least  <dig> quality pins whereas only  <dig> pairs < 30% identical have  <dig> quality pin apiece. furthermore, 82/ <dig> pairs find the maximum number of pins  permissible given the length of the sequences and a protection window of  <dig> nucleotides. we then asked how many of these selected pins are correct relative to the structural alignment . these results show that above about 50% pairwise identity, we can identify accurate pins.

finally, we compare the constrained pairscfg to the unconstrained pairscfg using the previously described percent identity binned test set. the results are shown in figure  <dig> for both alignment identity and base pair sensitivity, where points are only included on the graph if at least two pairs within the bin have pins meeting our quality criteria. the availability of pins divides roughly into three regions based on percent identity. for low percent identity pairs  only 5/ <dig> pairs have quality pins. at slightly higher percent identities, between  <dig> and 45% identical, pins are found for roughly half of the pairs and the performance of the constrained algorithm is slightly worse than the unconstrained algorithm. for pairs greater than 45% identical, pins are found for all pairs and constrained pairscfg has performance nearly identical to the unconstrained algorithm.

in general, the runtime and memory requirements of the constrained algorithm are dominated by the largest unpinned segment. performance depends on the distribution of the pins and optimal performance is achieved with evenly spaced pins. even a single pin, though, reduces the search space. for two  <dig> mers, the unconstrained algorithm requires  <dig> mb memory and  <dig> seconds to compute a structural alignment. a single central pin reduces this to  <dig> mb and  <dig> seconds.

comparison to other methods
we know of four constrained sankoff implementations, dynalign  <cit> , stemloc  <cit> , pmcomp <cit> , and foldalign  <cit>  which attempt to solve the same pairwise alignment and structure prediction problem as consan does.

dynalign
dynalign is essentially a pairwise extension to the thermodynamic single sequence program rnastructure. dynalign computes an alignment and consensus secondary structure that minimizes the sum of the predicted folding energies of the two individual sequences. it adds an ad hoc pseudoenergy penalty for insertions and deletions, but otherwise does not score the sequence alignment. it constrains the alignment by assuming that it is a global alignment of sequences of similar length, and restricts all aligned residue pairs to have indices differing by no more than a given maximum.

in his most recent paper describing dynalign  <cit> , mathews utilizes four datasets to evaluate its performance. the first contains  <dig> 5s sequences selected for comparison to the earlier dynalign implementation  <cit> . the second contains three pairs of srp sequences to assess performance on longer sequences. the last two are randomly selected sets to assess performance without selection bias, containing  <dig> trna and  <dig> 5s sequences. as provided by mathews, these datasets contain only individual sequences and their secondary structures, not pairwise or multiple alignments, so alignment accuracy could not be assessed on these test sets. when evaluating dynalign, we examine each pair once, excluding self to self comparisons. because the two 5s datasets gave comparable results, we combined their results and report a single 5s metric. using our benchmark procedure dynalign obtains basepair sensitivity measures of  <dig> ±  <dig> on 5s,  <dig> ±  <dig> on srp, and  <dig> ±  <dig> on trna.

we utilize the constrained algorithm with the default pin selection criteria . for 8/ <dig> 5s pairs and 106/ <dig> trna pairs, no pins met our selection criteria and consan falls back to an unconstrained sankoff algorithm. with these criteria, our algorithm obtains sensitivity measures of  <dig> ±  <dig> on 5s,  <dig> ±  <dig> on srp, and  <dig> ±  <dig> on trna. thus, dynalign performs slightly better on 5s rnas, and on the other two sets the methods perform about the same.

stemloc
ian holmes' stemloc is comparable in several respects to our work. stemloc is also based on a pairscfg, though its grammar is quite different from the grammar in consan. holmes' constrained algorithm is based on the general concept of fold and alignment envelopes  <cit> . our pins are essentially a special case of an alignment envelope. stemloc computes a fold envelope from the union of many possible individual foldings of each sequence according to a single sequence scfg, and it computes an alignment envelope from the union of many possible alignments of the two sequences according to a pairhmm. the pairscfg then only considers solutions which are consistent with these precomputed fold and alignment envelopes  <cit> .

holmes' test dataset consists of  <dig> pairs of sequences from rfam seed alignments. he reports a single basepair sensitivity and alignment accuracy value for each pair, using default parameters of  <dig> alignments and  <dig> folds. because stemloc is not scoring symmetric, we examine all pairs, excluding self-to-self. using our benchmark procedure, stemloc obtains  <dig> ±  <dig> sensitivity,  <dig> ±  <dig> ppv and  <dig> ±  <dig> alignment accuracy. using our constrained pairscfg,  we achieve  <dig> ±  <dig> sensitivity,  <dig> ±  <dig> ppv and  <dig> ±  <dig> alignment accuracy on the same dataset. thus the two pairscfg implementations show comparable performance on stemloc's test dataset.

comparisons on our test dataset
we compared the five constrained sankoff implementations on our test set binned by percent identity. we compare each pair only once, with the sequence order being determined randomly. for dynalign, we used the parameters described in  <cit> , excluding two pairs which caused the program to crash. with stemloc, we used the parameters suggested by  <cit> , except when insufficient memory was available. in these cases we stepped down the number of folds  gradually  until we could run the pair. pmcomp is utilized without the fast option, as described by its documentation and as was utilized by gardner <cit> . one pair was excluded, as pmcomp's backtrack fails for the pair. foldalign is utilized as described by gardner <cit>  . for consan, we use the default constrained method when pins are available and the unconstrained algorithm when no pins meet our quality criteria .

despite both using pairscfg approaches, consan appears to produce better alignments and better structures over a wider identity range than stemloc. we can think of at least two hypotheses for this effect. first, because stemloc currently calculates alignment envelopes defined by complete pairwise alignments, its performance might suffer at low percent identities where obtaining any accurate complete primary sequence alignment is difficult, even in a large sample of suboptimal alignments. we may be more robust to this effect by constraining only on a subset of confident pins. second, although the stemloc grammar was said to be both structurally unambiguous and alignment unambiguous, we think it is in fact alignment ambiguous, meaning that multiple parse trees can correspond to the same set of aligned residue pairs. this might have a negative impact on accuracy at low identities, because an ambiguous grammar does not rank suboptimal alignments correctly by their probabilities.

in terms of computational resources, the dynalign algorithm utilizes a banding approach that reduces the algorithm to o in time and o in memory where ℳ
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbamrthrhal1wy0l2yhvtyaehbnfgdovwbhrxajfwnaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabawaaegaeaaakeaaimaacqwfzestaaa@3790@ is the maximum distance <cit>  between any two positions in the alignment. stemloc uses precomputed alignment envelopes and/or fold envelopes to reduce the search space of the structural alignment. the pre-computation steps are o for alignment envelopes and o for fold envelopes in time, and o in memory for both. the final structural alignment phase remains o and o in time and space respectively. pmcomp uses precomputed pair probability matrices, computed in o in time. the structural alignment phase uses a structural banding approach, restricting the difference in the span of matching base pairs to Δ which reduces the computational effort to o in memory and o in time. foldalign uses both alignment banding  and structural banding  to reduce the time complexity to o and the memory complexity to o. our pinned approach calculates its pins in o time and space and the structural alignment remains in general oand o in time and space; in the limit of an alignment where all positions are pins, our constrained algorithm reduces to o in time and o in space.

the resource requirements for a single representative trna and 5s sequence pair for each of the five constrained sankoff implementations and the unconstrained pairscfg sankoff implementation, given as a baseline reference.

the trna sequences are of length  <dig> and  <dig> respectively. the 5s sequences are of length  <dig> and  <dig> respectively. the constrained pairscfg utilizes the pin selection criteria of posteriors >  <dig>  and a protection window of  <dig>   dynalign is compared using the parameters recommended in  <cit>  of ℳ
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbamrthrhal1wy0l2yhvtyaehbnfgdovwbhrxajfwnaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabawaaegaeaaakeaaimaacqwfzestaaa@3790@ =  <dig> and a gap penalty of  <dig>  kcal mol- <dig> gap- <dig>  stemloc is compared using the parameters recommended in  <cit>  which computes  <dig> alignment envelopes  and  <dig> fold envelopes . for pmcomp, the reported time includes both calculating the pair probability  and the subsequent pmcomp.pl phase. the memory reported is the maximum utilized during either phase. with foldalign, the parameters from gardner are utilized . for all programs these are the same parameters utilized to generate the performance reflected in figure  <cit> . these benchmarks were conducted on a dual  <dig>  ghz p <dig> machine with  <dig>  gb memory running the linux  <dig>  kernel.

CONCLUSIONS
stochastic context-free grammars provide a unifying framework for simultaneously scoring of alignment and secondary structure folding, providing a strong formal basis for scoring systems in comparative rna secondary structure applications  <cit> . holmes' stemloc and our consan both use pairscfgs as the basis for an implementation of the sankoff algorithm for pairwise rna structural alignment. the two implementations differ primarily in two respects. first, they use different methods of heuristically constraining the dynamic programming algorithm to make it practical. second, they use different underlying grammar designs.

stemloc's concept of alignment and fold envelopes is a general one, and the concept includes our pins as a special case. as holmes notes  <cit> , there are many ways one could imagine determining the allowed envelope. as implemented, stemloc relies on the union of a finite sample of suboptimal folds and alignments to define its envelopes. our simpler alignment pinning strategy is less general, but it may have certain advantages when the complete alignment cannot be identified reliably even in this union of suboptimals, but parts of it can be reliably pinned.

grammar design issues are of great interest to us. earlier work  <cit>  showed that grammar design can have significant impact on the performance on secondary structure prediction. we developed our pairscfg by extending a small but good single sequence scfg design. we believe that it is important for scfg designs to be structurally and alignment-unambiguous, as we described in the methods. we do not believe the stemloc design is alignment unambiguous, and we think  that consan's somewhat better performance at lower percent identities might be due in part to grammar ambiguity issues.

be that as it may, we do not think that either the stemloc or the consan grammar design will prove to be the best for this problem. both implementations use relatively simple grammars that do not approach the descriptive power of the current thermodynamic rules for rna folding. for example, neither grammar has a model of explicit loop lengths akin to the hairpin, bulge, and interior loop length tables of rna folding thermodynamic rules; nor do they model nearest-neighbor base pair stacking correlations as the energy tables do. between our work and holmes', the demonstration that two different pairscfg implementations can fold rnas as well as the best current thermodynamic approach , despite the fact that our pairscfgs clearly lack a treatment of some more complex statistical features known to be important in rna structure, indicates that it will be promising to explore this direction further, with more biologically realistic grammars.

parameterization of these grammars is also an area of future work. thus far, we have used a single point estimate for our parameters, based on maximum a posteriori training using a mixed ribosomal rna dataset. the most glaring problem with this is that since we are comparing rna sequences of different levels of evolutionary divergence, we would prefer not to use single point estimates, but to instead use a rate-based model that allows our parameters to be conditional on evolutionary time. preliminary data  shows that evolutionary models akin to those described by knudsen and hein  <cit>  improves our performance relative to any point-estimated set of parameters.

authors' contributions
rdd developed the constrained sankoff algorithm, wrote the code, carried out the experiments, and drafted the manuscript. both authors collaborated closely in writing the final version.

appendix
the proposed grammar is both structurally unambiguous and alignment unambiguous. reeder et. al.  <cit>  suggested the following test for ambiguity.

we start from the observation that if a deterministic parser can be generated for a grammar, the grammar must be unambiguous by definition  <cit> . this observation alone is not useful, because the whole point of an rna folding grammar requires it to be formally ambiguous in the sense that any given sequence has many possible structures , not just one; the job of the folding algorithm is to find the optimal structure/parse tree. however, we can separate this necessary kind of ambiguity from the two types of undesired ambiguity . we redefine the grammar terminals such that the grammar emits an annotation of the consensus structural alignment, rather than an aligned sequence pair, such that each possible structural alignment has one and only one annotation string. then, for this alternative representation of the grammar, we show that we can generate a deterministic parser.

for a single sequence, a nested  secondary structure is uniquely described by an annotation of unpaired  and paired  bases. extending this to structural alignment, we must also introduce gap symbols to indicate when an unpaired residue is only present in x  or only present in y . in our grammars, a consensus base pair must be present in both sequences, so gaps may only be placed in unpaired columns. using these symbols, each structural alignment is uniquely described by a single annotation string. figure  <dig> shows an example annotation string.

because the rules of our pairscfg directly map to the symbols  of the annotation alphabet, we can transform our pairscfg grammar into the following annotation grammar:

s → .s | -lx | _ly | t | ε

t → t. | rx- | ry_ | <p > | t <p >

lx → .s | -lx | t | ε

ly → .s | _ly | t | ε

rx → t. | rx- | <p > | t <p >

ry → t. | ry_ | <p > | t <p >

p → <p > | n

n → .s | -lx | _ly | t. | rx- | ry_ | t <p >

now, if a parser can be generated for this annotation grammar, then our pairscfg must be unambiguous. note that a failure to identify a parser would not prove that the grammar is ambiguous, but rather that no conclusion can be made with respect to the grammar's ambiguity status. the popular yacc and bison parse generators are only capable of handling a subset of context-free grammars and fail to generate a parser for the annotation grammar. a more general parse generator is the msta parse generator of the cocom compiler construction package. the msta parse generator produces a parser for the annotation grammar, which demonstrates that our pairscfg is structurally unambiguous and alignment unambiguous.

