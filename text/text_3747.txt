BACKGROUND
the identification of peptide sequences from spectra is a computationally expensive and rate limiting task. this expense is due to the fact that the identification process typically involves each measured spectrum being matched against the likely  spectra for each possible peptide ion within a range of mass-to charge ratios. the problem with identification of peptides is confounded as the number of peptides is huge, and the search space increases geometrically with the number of amino acid modifications considered. this paper introduces a highly scalable strategy for overcoming these limitations, which has been purposefully built to take full advantage of a highly distributed computation framework.

the shotgun proteomics workflow has become the most widely used technique for identifying and quantifying proteins present in a biological sample in a high-throughput manner. although many variations exist, the basic approach begins with extracting proteins from sample and digesting the proteins into peptides with a proteolytic enzyme such as trypsin. the peptides are then separated using liquid chromatography and analyzed by mass spectrometry . the mass-to-charge  ratios of the peptide precursor ions are measured and the precursors are fragmented into a series of ions and measured in tandem mass spectrometry  mode. the resulting ms/ms spectra of these peptide ions together with the precursor m/z are searched against a database of possible peptides to determine the best match
 <cit> .

many strategies have been proposed to help with such search techniques. raw, embarrassingly parallel approaches are the most widely used . to increase the speed and scalability of the searching advances in high performance computing hardware have also been used to offload the searching from general to dedicated hardware , and improvements to search algorithms have been implemented
 <cit> . some algorithms have been ported to parallel computing architectures such as mpi . previous parallel implementations generally scale with the number of spectra
 <cit> , however the scalability issues relating to the size of the database being searched are not addressed.

in this paper we introduce hydra, which is designed to scale both in terms of the number of spectra and the size of the search database. hydra makes use of hadoop
 <cit> , which is a common and well supported framework for handling distributed computation. the hadoop framework handles the management of a cluster of generic machines. it handles the details of taking a set of two tasks: map and reduce
 <cit>   and creating the instances required to handle a given data set. tasks are sent by the framework to specific machines and output is collected by the framework to the next task. the framework handles details such as failure and retry, generation of a distributed data system and storage and access to temporary results.

using hadoop for mass spectrometry based searching has been suggested before
 <cit> , where an existing mpi search engine  was wrapped to work with hadoop. however, such mpi based code does not use critical features of the mapreduce algorithm . the algorithm introduced in this paper is a complete bottom-up rewrite of the x!tandem code, and has been designed to take full advantage of map-reduce. within hydra, we implement the k-score
 <cit> , which is one of the pluggable scoring algorithms packaged with the trans-proteomic pipeline
 <cit>  distribution of x!tandem. the k-score is an implementation of the comet scoring function, which produces a dot product of matched peak intensities after spectrum normalization
 <cit> . the k-score normalization and scoring routines account for noise and unmatched peaks within the input spectra.

the advantages of the approach introduced in this paper are: scalability, as hadoop has been shown to be able to handle massive data sets in the petabyte range, and has been used to undertake complex search and analysis operations on datasets of this size. this means, as is shown in this paper, that such a framework is highly suited for the growing data sets that are becomingly searched against when undertaking ms/ms analyses; flexibility, as the system can be used on a variety of commodity hardware configurations, including running across heterogeneous machines where the performance scales with additional hardware, and can be used within cloud environments  that support hadoop; and reliability, as hadoop provides the necessary libraries to handle the critical issues of task distribution, monitoring and failure recovery .

in this paper we present the design for decomposition of mass spectrometry search into a collection of map/reduce tasks, and show an implementation of our proteomic search engine hydra. hydra is specifically designed from the ground up to work within the mapreduce algorithm. by comparison to x!tandem we show where and how the system scales, and discuss the advantages of our approach. the software is made publicly available under an open source license.

implementation
the strategy advocated in this paper for ensuring scalable searches of mass spectrometry data is one that uses distributed parallel processing. this type of solution has become popular over the last five years as it allows for scalability using commodity hardware, and so both reduces the hardware and software development costs traditionally associated with high performance computing. this style of architecture allows for the development of parallel solutions across clusters of heterogeneous hardware.

with highly distributed frameworks, the times required for execution scale inversely with the number of processors allocated and directly with the size of the data set. these frameworks are most efficient with large data sets, as there is always an overhead with initial setup. these frameworks coupled with mapreduce based designs provide a means to partition the analysis tasks effectively.

hydra was designed to specifically take full advantage of the mapreduce architecture and native capabilities. the mapreduce algorithm parallelizes the performance of a number of problems. computation is performed in two phases. the first phase, called the mapper, receives data in parallel at a series of nodes, and then emits data as a series of key-value pairs. the unit of data received and emitted is application dependent. in our case the first mapper receives information representing a single spectrum and emits the same.

the reducers handle the key value pairs emitted by the mappers. the framework processes and sorts the data emitted by the mappers in order to offer the following guarantees: 1) all values associated with a specific key will be handled in a specific reduce task. 2) any keys reaching a specific reducer will be received in sorted order. each reducer may emit a collection of key-value pairs stored in a collection of files which is the same size as the number of reducers. the algorithms that are discussed in this paper take specific advantage of these features and are described in detail below. as with many other mapreduce based applications, our approach consists of a series of steps  which are described in further detail below.

we use the hadoop framework, which is the de facto open-source implementation of the mapreduce architecture supported by apache and available on a number of machines. our code is single threaded and uses the hadoop framework to achieve parallelism in separate nodes on a cluster. one important feature of the approach is to precompute all candidate peptide sequences including any mass modifications and to group them by m/z. this allows each sequence and its corresponding spectrum to be generated only once.

our implementation divides proteomic search into two tasks: generation of a peptide database and the subsequent scoring of a collection of spectra against the database. this separation allows the set of peptides with appropriate modifications to be generated in advance of searches and, as long as the set of proteins and modifications remains unchanged, to be reused in multiple searches. in addition, as discussed below, knowledge of the number of peptide ions to be scored allows tuning to control memory requirements.

generation of the peptide database
the peptide database is written to answer a single query: given a specific m/z ratio return a list of all peptides and modified peptides to score having that m/z. the task of generating peptides has two parts - the first finds a list of all unique peptides in a protein database after applying a specified digestive enzyme  and a collection of modifications. the second element is to generate groups of peptides with a specified m/z ratio and store them.

our mapreduce implementation  has the following steps: for every protein, the mapper generates all peptides and uses the sequence  as a key and an id of the protein as a value. every key delivered to the reducer represents a unique sequence  and the list of values represents the proteins containing the sequence. the reducer emits the sequence as the value with the m/z ratio as a key.

the next reducer receives all sequences scored at a specific m/z ratio and stores them for later analyses. also generated is a list of m/z values and the corresponding number of scored sequences.

scoring spectra
the algorithm for scoring spectra uses three mapreduce jobs . the first job sends spectra to be scored against a set of peptide ions having a theoretical m/z ratio within the specified tolerance of the measured one. the second job combines all scoring of a specific spectrum, choosing the best scoring peptides. the third job combines the scoring of all spectra into a single output file.

these algorithms score spectra against a range of m/z values within a specific delta of the precursor m/z ratio. our implementation assigns candidate peptides to a specific m/z group . spectra are assigned to score against a set of groups close to the precursor ion m/z. every group is scored on a separate reducer. when the number of peptides in a group exceeds a known limit, the group is split and scored on multiple machines. for each spectrum the top scoring peptides in the group, as well as scoring statistics are gathered as an object, serialized as xml and written with the scan id as the key.

the second mapreduce job gathers the scoring for each spectrum and collates the results. peptide-spectrum matches  from all groups are combined into a single list sorted by score. again, the top scoring peptides and overall statistics are packed into a single object and serialized as xml with the scan id being the key.

the consolidation task receives these overall score objects for each scan. the data is reformatted into the standard x!tandem output and written to a single file. following the completion of the consolidation task, the output of the consolidator stage, a file in x!tandem format is copied from the cluster to the user’s machine.

RESULTS
the program was tested against larger searches to validate scalability and the ability to handle large search spaces. we ran the program against three databases: a large non-redundant  sample , a subset with half the original nr data and one with a quarter the original set. sample data sets ranged from  <dig> to  <dig>  spectra. we used a cluster with  <dig> nodes with  <dig> cores/node, and each node had a terabyte disk. all nodes were in the same rack connected with standard ethernet.

to generate the original database, we used ncbi's non-redundant list of protein sequences for building the database of peptides. this file contains all available protein sequences for all organisms that differ at least with one amino acid residue
 <cit> . the smaller databases were generated by selecting subsets of the larger database. for searching against the human proteome, the  <dig> february uniprot reference proteome  was used
 <cit> .

the scalability problems with proteomics searching come down to three factors. the first factor is the size of the peptide database: the number and size of the proteins considered; whether tryptic only or semitryptic peptides are searched; and the number of modifications and missed cleavages. secondly the size of the experiment, which is the number of spectra scored. the third factor is the number of computer resources that can be made available. our algorithm is designed to be optimized to scale for all the three factors. so that there are no limits on the number of searched peptides, the number of scored spectra, and the number of compute nodes that can be used. adding proteins or spectra will increase execution time for a given set of resources, but it does not prevent the algorithm from arriving at a solution.

the performance of hydra scales with the product of the number of spectra and the number of peptides considered . every time a measured spectrum is scored against a peptide, a dot product is computed. the number of dot products is a reasonable way to measure the complexity of a search, and depends on the number of spectra scored and the number of scored peptides close enough to the precursor m/z. hydra performed  <dig> billion peptide scorings in approximately  <dig> minutes. for benchmarking we used: a dedicated  <dig> core linux server, for x!tandem; and a  <dig> node hadoop/linux cluster with  <dig> cores per node , was used for hydra. the longest task  took approximately  <dig> minutes on the cluster, while it took almost  <dig> days using x!tandem on a  <dig> core local machine. a smaller task  which took  <dig> minutes on the cluster took  <dig> hours on a single four core machine . because the peptide database is reusable in multiple searches we build the database in a separate job .
 <dig> are:  <dig>   <dig>   <dig>  the pride xml files containing spectra were downloaded from the pride website and were opened in the pride inspector
 <cit> . the mgf export functionality of pride inspector was used to generate the mgf files used in the searches, with only human tissue samples or cell lines being used to generate the mass spectra.

example of comparison of run time for different complexities of search using the standard x!tandem implementation and hydra. the scans columns gives the number of spectra searched against, the nodes column is the number of resources used , the database name is the species database used, the database proteins is the number of proteins in the database, the dot product is the number of actual calculations. the times show that hydra, unlike x!tandem, is able to scale nearly linearly with the size of the problem. however, due to the startup costs associated with hydra it is not suited for small searches. the pride accession numbers for the spectra used were  <dig> and  <dig> 

hydra and x!tandem do differ in the data that they generate, as x!tandem returns a single peptide, and hydra returns a list of the top likely peptides. when comparing the outputs of x!tandem to hydra with artificial spectra they are greater than  <dig> % identical in terms of the best peptide found. when running the system on experimental data there are differences due to algorithmic details , which means that they are 75% identical in terms of the top peptide and score matching, and 95% of the time they both return peptides with similar scores. it is interesting to note that x!tandem itself does not always generate exactly the same results, possible due to race conditions in the code base. because we can afford to do a slightly wider search, hydra can find peptides the x!tandem does not .

CONCLUSIONS
scalability of search operations in mass spectrometry is a critical concern. the size of proteome databases continues to grow especially as more modifications, post-translational changes, isotopic labeling and semi-and non-tryptic peptides are searched. isotopic labeling and modifications geometrically expand the search space of peptide masses. the wider availability of faster mass spectrometers and the common practice of scoring data with multiple search algorithms are having huge effects on the computational requirements for such operations. the software discussed in this paper is designed to have few limits on scalability.

search is inherently a parallel operation and algorithms already exist that have been adapted to work in parallel. in this paper we present the use of a distributed framework to develop a new generation of search algorithms, as these frameworks lend themselves conveniently to sequence-spectra matching. the advantage of using such a framework is that much of the infrastructure of managing parallel jobs is built into the framework. hadoop has been demonstrated to scale up to thousands of processors. the details of handling a cluster, distributing work, gathering results and, critically for large systems, handling failure and retry are built into the framework.

the genomics field has already demonstrated the power of using cloud or high distributed frameworks for computational intensive tasks
 <cit> . as the computational burden in tandem mass spectrometry proteomics based searching is large and increasing, exploration into the use of such distributed frameworks is necessary. this increase in search space is going to continue to be a rate limiting step, and this paper discusses one strategy which can be used to overcome these limitations.

availability
the full source code, documentation and test code is available at
http://code.google.com/p/hydra-proteomics/.

competing interests
the authors declare that they have no competing interests.

authors’ contributions
jb, sl and sk conceived of the project. sl designed and implemented the work. ed, mh rm and ac helped in the design, and provided expert input. hh, sl and ac helped with testing and results generation. all authors read and approved the final manuscript.

