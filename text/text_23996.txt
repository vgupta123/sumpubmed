BACKGROUND
with the widespread availability of data sets of genome and protein sequences, methods for analyzing the sequences to extract biologically salient information have emerged as powerful techniques in computational bioinformatics  <cit> . in this arena, comparative sequence analysis has proven extremely powerful, whereby sequence segments across different genomes are examined for similarities. segments identified as similar represent evolutionarily conserved homologs and are deemed to be biologically significant due to their apparent preservation across the genomes. the postulated significance can then be tested with experiments, which can also help establish functional correlates. because the biological experiments are time-consuming and expensive, the comparative analysis serves to improve efficiency by "pre-filtering" the relatively large genome to determine relatively smaller segments over which the experimental effort may be concentrated. the effectiveness of this pre-filtering step is, of course, determined by its accuracy in correctly identifying meaningful homologs and by the computational efficiency of the algorithmic implementations.

in the identification of homologous segments of genomes, sequence-alignment has been the primary workhorse since it can be directly deployed on readily available sequence data. commonly used methods assign a score to an alignment of a pair of sequences based on nucleotide matches/mis-matches and gaps in the alignment. the similarity score for a pair of genome segments is then computed as the maximum value of this score over all potential alignments, which serves as an alignment-based measure of homology. through algorithmic innovations , computationally-efficient methods have been developed for sequence-alignment that can be effectively deployed over large genomes  <cit> , the computational speed-up, however, does not ameliorate a limitation of these methods in that they rely on pure sequence-alignment whereas biological function is actually determined largely by structure, which is not necessarily in one-to-one correspondence with sequence. structurally conserved biomolecular elements with differing sequences directly illustrate this problem. the divergence between structural and sequence homology is particularly true of non-coding rnas , where it is commonly believed that secondary structure, i.e. the sum of the canonical base pairs, is more conserved than the nucleotide sequence  <cit> . as a ncrna sequence evolves, compensating changes occur that allow the sequence to drift without affecting the secondary structure. compensating base pair changes by which secondary structure is conserved, but sequence is not, are therefore used to identify the conserved structure  <cit> .

given the strong correlation between structure and function observed in biological systems, it is more meaningful to explore homologies based on structure rather than sequence alone. in general, the determination of structural homology scores, i.e. a structural similarity measure for the most "similar"  3-d structure corresponding to genomic/proteomic sequence segments is a challenging problem. in the case of ncrna, however, the problem may be rendered tractable, i.e. polynomial time complexity, by focusing one's attention on secondary structure. sankoff  <cit>  first proposed a dynamic programming approach to this problem that addresses a large class of secondary structures . furthermore, he also illustrated how the approach can be extended to include a composite score that accounts for both sequence and structure similarity while retaining the polynomial complexity.

though polynomial in complexity, sankoff's proposed algorithm in its original form is still too computationally demanding for deployment on long sequences, such as 16s or 23s rrna, in the near future  for two sequences of length n). a simplified version of the algorithm, dynalign, implemented by mathews et al.  <cit>  constitutes one of the practical computational realizations. the method uses a heuristic to improve computational efficiency by restricting the number of possibilities examined in each dynamic programming step. however, its computational burden remains significant and no analytic guidance is available on the selection of parameter values for the heuristic simplification.

in this paper, this limitation is addressed by developing a principled mechanism for significantly improving the computational efficiency of dynalign. the motivation for our technique arose from the "a posteriori" probability decoding methods developed for error correction in electrical communication systems in the early 1970s  <cit> . these have seen a recent re-resurgence of research interest due to the development of turbo codes  <cit>  and re-discovery of low-density parity check codes  <cit>  that now constitute active areas of research and development in electrical communication systems. an adoption of the a posteriori probability methodology allows us to determine the confidence in local accuracy of sequence alignment in a computationally efficient fashion using a hidden markov model  <cit> . these probabilistic estimates of confidence in local alignment accuracy are utilized in order to define constraint windows for limiting the choices in the dynamic programming step in dynalign. intuitively, this process can be understood as follows: in regions with strong confidence in the alignment accuracy, the possibilities explored in the dynamic programming steps are severely restricted to options mandated by the corresponding alignment and in regions with low confidence in the alignment a wider range of possibilities are allowed in the dynamic programming steps. the method is superior to the prior heuristic of restricting the number of possibilities to an arbitrary fixed number at each step since the restrictions are based on confidence estimates in the sequence alignment and therefore cuts computation where it is not required  and does not restrict it when it is in fact required . the resulting method provides a very significant decrease in the time required for dynalign computations while simultaneously increasing  the accuracy of estimating the common secondary structure between two homologous rna sequences.

it is worth noting that even though the present effort focuses entirely on dynalign, the methodology is more general. the computed alignment constraints can be utilized with other packages for joint sequence alignment and structure prediction that permit their use for computational simplification, e.g. as "alignment envelopes" in stemloc  <cit> .

the rest of the paper is organized as follows. section  <dig> provides background on the problem of rna structure prediction and references to current related work in this area. the proposed methodology for determining alignment constraints based on nucleotide alignment posterior probabilities is summarized in section  <dig>  results evaluating the performance of the proposed method and comparisons with other techniques are presented in section  <dig>  section  <dig> summarizes the main findings of the paper. details of our algorithmic methodology are included in section  <dig> 

 <dig> overview of rna secondary structure prediction methods
rna structure is hierarchical  <cit> . the primary structure comprises a linear chain of nucleotides joined together by covalent phosphodiester bonds. this is identified by the ordered sequence of nitrogenous bases that determine the four types of individual nucleotides: adenine , guanine , cytosine , and uracil . this primary structure is determined by "sequencing" and is the starting point of most computational methods for structure estimation. the nucleotides within a chain interact through the formation of hydrogen bonds between the pairs a – u, g – c, and g – u. the set of these base pairings is referred to as the secondary structure. tertiary structure includes structural contacts arising from additional interactions on top of secondary structure. these define the three-dimensional structure of the rna. quaternary structure is the interaction with other molecules, such as with proteins or other strands of rna. secondary structure contacts are stronger  <cit>  and form faster  <cit>  than tertiary structure contacts, therefore secondary structure can be largely determined without knowledge of tertiary structure.

comparative sequence analysis can be used to accurately determine the secondary structure of functional rnas for which there are a large number of known homologs  <cit> . the secondary structure is the common structure to all homologs, as determined by an alignment of the structures. over 97% of base pairs predicted for ribosomal rna in this manner were subsequently found in high resolution crystal structures  <cit> .

there has been a long-standing interest in the prediction of secondary structure for a single sequence and free energy minimization methods are currently the most accurate and popular. using dynamic programming algorithms, the lowest free energy structure is determined according to a set of nearest neighbor parameters that predict conformational stability  <cit> . these parameters were empirically derived to fit stabilities determined by optical melting experiments on small model systems  <cit> . the accuracy of free energy minimization has been benchmarked as high as 73% for predicting known base pairs for a diverse set of sequences as long as  <dig> nucleotides with structures determined by comparative analysis  <cit> , for different sequences, including longer sequences, the average accuracy is lower  <cit> . the use of dynamic programming algorithms to predict low free energy structures has been recently reviewed  <cit> .

a recently introduced alternative to free energy minimization is the determination of the most probable structure using a stochastic context-free grammar   <cit> . the transition probabilities for the scfg are trained on sets of sequences with known structure. an scfg has been reported that is nearly as accurate as structure prediction as free energy minimization  <cit> .

to improve the accuracy of structure prediction, a number of methods have been developed that determine a secondary structure common to two or more sequences. these methods have the advantage of including comparative data, and, in general, they fall into three classes. the first class takes a fixed sequence alignment as input. a second class predicts structures for each sequence and then sorts through the structures to find those common to all sequences. the third class finds the structure common to two or three sequences by simultaneously aligning the sequences and finding the most likely structure. in general, the third class is the most rigorous and accurate, but also the most time-consuming. a number of these methods have been reviewed  <cit> .

algorithms that find the secondary structure common to the multiple, unaligned sequences are either genetic  <cit>  or dynamic programming algorithms. the dynamic programming approaches trace their lineage to the theoretical paper by sankoff  <cit> , which provides for a computational complexity of o in time and o in memory where n is the length of the smaller of the two sequences. a number of different implementations of the sankoff algorithm have been developed to find the secondary structure common to two sequences. each of these implementations restricts the search space to make the program runtime feasible. the first, foldalign  <cit> , maximized an empirical score and originally did not allow multibranch loops to improve runtime. foldalign was later revised to allow multibranch loops and use a subset of the free energy nearest neighbor parameters  <cit> . the revised foldalign restricts the alignment space to reduce runtime. two scfg-based programs are available, stemloc package  <cit>  and consan  <cit> . to reduce runtime, stemloc introduced the concept of fold and alignment envelopes that restrict, respectively, the search space for possible base pairs and possible nucleotide alignments. in the structure domain, the set of allowed base pairs for each sequence are those found by the prediction of set of probable structures for each single sequence. for the alignment domain, the allowed nucleotide alignments are those found in the "n most probable" sequence alignments for some choice of n. in a recent similar advance  <cit> , consan improves its runtime by using highly probable nucleotide alignments as "pins" at which the exact alignment is constrained. highly probable nucleotide alignments, exceeding a specified threshold, are forced to occur in the simultaneous prediction of the alignment and common sequence.

dynalign  <cit>  is an implementation of the sankoff algorithm that predicts the lowest free energy structure common to two sequences. to make the calculation time tractable, a restriction of the alignment domain was introduced  <cit> . in the most recent publication  <cit> , for nucleotide i from sequence one to align to k from sequence two, the following constraint must be met:

  |i×n2n1−k|≤m 

where m is a user-specified parameter, n <dig> is the length of sequence one, and n <dig> is the length of sequence two. this restriction on maximum insertion length imposes a heuristic constraint on possible alignments. this implies a constraint on the maximum insertion length, which is reasonable for homologous sequences  <cit> . equation  corresponds to a restricted search interval in the 2nd sequence for alignment of ith nucleotide in the 1st sequence. the restriction reduces the computation burden since m can typically be chosen much smaller than the shorter sequence length n. the computations are more tractable with m parameter heuristic: o in time and o in memory  and o in time and memory, respectively, without the m parameter) where m is the measure of maximum permissible insertion length and n is length of shorter sequence. dynalign also restricts the set of allowed base pairs for each sequence to those found in low free energy structures by single sequence secondary structure prediction  <cit> .

in this paper, a new method for estimating alignment constraints is proposed and incorporated in dynalign. instead of using the most probable sequence alignments the method utilizes the a posteriori probabilities for nucleotide alignments in order to establish the alignment constraints. this method makes dynalign more robust by eliminating the need for the m parameter above.

 <dig> alignment constraints from posterior probabilities
the m parameter mediates a trade-off between the computation and accuracy. a smaller value of the parameter is desirable in order to reduce the computation time to practically useful values. on the other hand, a small value can be overly-restrictive and thereby reduce the accuracy of the structure and alignment prediction from dynalign. thus, an 'educated guess' for the m parameter is vital to the accuracy of secondary structure prediction. the value of m has hitherto been empirically determined and found to vary over different rna families. the lack of an analytical methodology for determining the m parameter has been a limitation for dynalign. in addition, a large m parameter is typically required for longer sequences since they typically can have longer insertions. this tends to make the computation time for dynalign with the m parameter particularly onerous for longer sequences.

in this paper, a new principled methodology is proposed for the introduction of alignment constraints in dynalign. instead of the heuristic m parameter, alignment constraints are determined through a probabilistic analysis. for this purpose, the alignment between homologous sequences is modeled by a hidden markov model . using the model, the posterior probability p is determined, which denotes the probability that nucleotide position n <dig> in the first sequence x <dig> is co-incident with nucleotide position n <dig> in the second sequence x <dig>  given that the sequences are produced by the model. two nucleotide positions  are said to be co-incident if they are either aligned, or if one nucleotide position  occurs in an insertion in that sequence that begins at a nucleotide position aligned with the second nucleotide position . formally, a nucleotide position i from the first sequence and nucleotide position j from the second sequence are said to form a co-incident pair  if: a) nucleotide positions i and j are aligned, or b) nucleotide position i occurs in an insertion in the first sequence and nucleotide position j in the second sequence aligns with nucleotide position i_ from the first sequence, where i_ denotes the largest position index less than i in the first sequence that aligns with a nucleotide position from the second sequence, or c) nucleotide position j occurs in an insertion in the second sequence and nucleotide position i in the first sequence aligns with nucleotide position j_ from the second sequence, where j_ denotes the largest position index less than j in the second sequence that aligns with a nucleotide position from the first sequence. as an example, consider the alignment shown in figure  <dig>  the co-incident nucleotide position pairs for this alignment are: , , , , , . figure  <dig> illustrates the map of co-incident positions in the alignment of figure  <dig> in a planar matrix of blocks, where the nucleotide position n <dig> for the first sequence indexes the abscissa of the block and the nucleotide position n <dig> indexes the ordinate of the block. in this graphical matrix representation, co-incident positions indicated above are depicted in figure  <dig> as black blocks  or cross-hatched blocks . figure  <dig> illustrates that for any alignment the set of co-incident positions defines an unbroken path from the lower corner of the matrix to the upper corner of the matrix . in the dynamic programming step in dynalign, at any given point, the sequence alignment component of the iteration searches over positions of the matrix that are adjacent to the current location . for an alignment to be allowable, constraints specified in dynalign  must allow all the co-incident position pairs corresponding to the alignment.

now, if p is small, correspondingly it is rather improbable that the nucleotide position n <dig> in the first sequence x <dig> will be co-incident with nucleotide n <dig> in the second sequence x <dig>  this suggests that alignments  may be constrained by excluding highly improbable alignments as indicated by extremely low values of the posterior co-incidence probability. correspondingly, an alignment constraint may be defined by thresholding the posterior co-incidence probability with a suitably low threshold pthresh. formally, an alignment constraint set is defined as

  c = { | p > pthresh} 

where c denotes the alignment constraint set. elements of c represent nucleotide position pairs that may co-incide between the sequences and elements outside of c are nucleotide alignment position pairs whose co-incidences are disallowed.

the posterior probabilities of co-incidence between nucleotide positions are efficiently computed using the hmm forward-backward algorithm. the process is schematically illustrated in figure  <dig>  the posterior probability is computed in terms of forward and backward variables as

  p=∑mαmβmp 

where the sum is over the three possible states for nucleotide co-incidence, i.e., m = aln, ins <dig>  ins <dig>  the forward variable αm represents the probability that the subsequences x11n <dig> and x21n <dig> of the first and second sequence, respectively, are produced and the nucleotide positions n <dig> and n <dig> are in the state m, and the backward variable βm represents the probability that subsequences x1n1+1n <dig> and x2n2+1n <dig> are observed given that the n1th and n2th nucleotide positions are in state m. details of the model and the computation of posterior probabilities are provided in section  <dig> 

the choice of the threshold pthresh in eqn  represents a trade-off between computation and the accuracy of the alignment constraint . a smaller pthresh offers higher confidence that all actual alignments will lie within the corresponding constraint sets but also requires more computation due to the increased choices and region of computation in the dynalign phase. a high value of this threshold, on the other hand, results in more a stringent alignment constraint set and thereby reduced computation requirements. however, there is a higher probability that actual alignments will not lie within the constraint set, whereby the prediction accuracy for dynalign is  reduced .

suitable hmm parameter and threshold values are required in order to determine effective constraint sets. in order to have parameters that accurately capture statistical characteristics, sequence pairs are grouped into bins based on the percentage of nucleotides that are identical in the optimal  alignment and the parameter and threshold values are established for each bin. this ensures that the diverse range of statistical variation observed in sequence pairs is divided up into clusters where the parameters for each cluster better represent the statistics of sequence pairs in the cluster than would be feasible with a single global model. this process is analogous to binning employed in previously published work  <cit> , details of the binning and parameter estimation can be found in section  <dig> 

a sample alignment constraint set obtained for two trna sequences, x <dig> and x <dig>  is shown in figure  <dig>  where the constraint set is also compared against the actual  alignment from rfam database  <cit>  and the constraints implied by eqn.  for a value of m =  <dig>  in figure  <dig>  the true alignment in black clearly indicates an insertion run in the second sequence. it is also clear that the probabilistic alignment constraint set includes the true alignment . a comparison of figs.  <dig> and  <dig> is also instructive: while the m parameter constraint allows a uniform band of nucleotide alignments about the "diagonal" line, the probabilistic alignment constraints are adaptive to the confidence in the alignment and provide tighter constraint in regions where this confidence is high and a looser constraint where this confidence is low . finally, figure  <dig>  illustrates the difference between the probabilistic and the m-parameter constraint sets. the significantly larger light gray area in comparison to the dark gray area in this figure illustrate the computational savings of this method in comparison to the m-parameter constraint.

 <dig> 
RESULTS
three sets of experiments are performed: 1) experiments for verifying accuracy of probabilistic alignment constraints, 2) experiments for determining structural prediction accuracy, and 3) experiments for comparing the computation and memory requirements. the latter two sets of experiments also compare performance of dynalign with the new constraint proposed here against the previous version of the dynalign  and against other secondary structure prediction methods. the parameters for the algorithms and software version numbers used are summarized in section  <dig> .

 <dig>  accuracy of probabilistic alignment constraints
the experiments for accuracy of probabilistic alignment constraints are performed over 5s rna and trna alignments in the rfam database  <cit> . the accuracy is determined by how probabilistic alignment constraint performs with respect to actual annotated alignment in rfam database. sensitivity and specificity of alignment constraint will be used to report accuracy of probabilistic alignment constraint and compare it with the m parameter alignment constraint. sensitivity for alignment constraint accuracy is defined as:

  sensitivity=ntpntp+nfn 

where ntp is number of true positive predictions corresponding to number of alignment positions which are in actual  alignment and within the alignment constraint set. nfn is number of false negative predictions corresponding to number of alignment positions which are outside alignment constraint set but are in the annotated alignment. sensitivity is therefore the fraction of known alignment positions that are allowed in the alignment constraint set.

specificity for alignment constraint accuracy is similarly defined as:

  specificity=ntnntn+nfp 

where ntn is number of true negative predictions  corresponding to alignment positions which are outside the probabilistic alignment constraints. nfpis number of false positive predictions corresponding to alignment positions which are alignment constraint but are not annotated as aligned in rfam. specificity, therefore, is the fraction of alignments known to not occur that are not allowed in the alignment constraint set.

since the alignment constraint serves as a "pre-filter" in dynalign, a high sensitivity is desirable even at the cost of some degradation in specificity . in order to better distinguish between high specificity values, the fraction of nucleotide alignment positions missed are computed and tabulated in table  <dig> far the proposed probabilistic alignment constraints and the m parameter constraints, used with m =  <dig>  <cit> . the values in table  <dig> indicate that the proposed method for determining alignment constraints offers very high sensitivity and performs significantly better than the m constraint that was previously employed. at the same time, the proposed method also has better average specificity than the m parameter. note also that the hand curated alignments in the rfam database include some nucleotide position alignments that are obtained using considerations that are exogenous to sequence nucleotide similarity, e.g. by structural alignments. this, in part, limits the sensitivity that may be obtained using most methods based on sequence nucleotide similarity alone .

for the m constraint a value of m =  <dig> is chosen is chosen as established in  <cit> . new constraint refers to the probabilistic alignment constraint proposed in this paper.

 <dig>  accuracy of structural prediction
an evaluation of the structural prediction accuracy obtained with the proposed constraints is important in order to establish that the constraints are not overly stringent. for this purpose, an archive containing  <dig> 5s rnas  <cit>  and  <dig> trnas  <cit>  with known secondary structures is utilized. three methods for secondary structure prediction are compared over  <dig> randomly selected 5s rna and  <dig> randomly selected trna sequence pairs from this archive: a) dynalign with probabilistic alignment constraints, b) dynalign with m constraint with m =  <dig> and c) single sequence structure prediction  <cit> .

structural prediction accuracy for each of the methods is quantified in terms of sensitivity and positive predictive value . sensitivity is defined as the fraction of canonical pairings in the known  structure that are correctly predicted and ppv is defined as the fraction of predicted base pairings that are in agreement with the known structure. in both cases, a single nucleotide shift on any one side is allowed. detailed definitions of the sensitivity and ppv can be found in the methods part in section  <dig> .

the average values of ppv and sensitivity for the three methods are listed in tables  <dig> and  <dig> for the trnas and 5s rnas, respectively. the tables for the trna dataset include two columns indicated by + and - that correspond, respectively, to versions of the algorithms that do or do not utilize available knowledge of modified nucleotides that cannot accommodate the canonical a-form helix. for the results in the + columns, these nucleotides are forced single-stranded to improve structure prediction  <cit>  whereas the information is not utilized for the results in the – column. from the tabulated numbers it is clear that dynalign with the proposed probabilistic alignment constraint is improved compared to the previously used m constraints. both dynalign methods outperform single structure prediction.

column with '+' refers to dynalign making use of structural constraints where modified nucleotides that cannot accommodate the canonical a-form helix are forced single-stranded  <cit> .

 <dig>  computation and memory requirements
in order to compare the computational and memory requirements for dynalign with the proposed probabilistic alignment constraints against the prior m-parameter heuristic, these requirements were estimated by sampling  <dig> trna and 5s rna sequence pairs each at random from the rfam database and recording the cpu time and memory usage. an opteron  <dig>  machine with  <dig> gb of ram using fedora core running linux core  <dig> and gcc compiler were utilized for these experiments. for the m parameter constraint a value of m =  <dig> was used throughout as established in the most recent publication on dynalign  <cit> .

minimum, maximum, and average cpu times per dynalign execution  are reported in table  <dig>  the cpu time in these tables is as reported by linux and it refers to time in seconds that the  process occupies the cpu excluding dispatches and input/output wait times. the major benefit of the proposed methodology is immediately apparent from the numerical figures in this table. on average, the incorporation of the probabilistic constraints reduces the cpu time by a factor of approximately  <dig> for the 5s rna experiments, where the average sequence length was  <dig>  nucleotides. for the trna experiments, where the average sequence length was much shorter , the method requires almost the same computation time as the previous version of dynalign . in fact, the computational time requirement for this case favors the m-parameter dynalign by a small amount. this is the result of computational optimizations that have been incorporated in dynalign due to which the computation is now significantly faster than prior versions. as a result of this speed-up, for smaller sequences, the overhead of computing the alignment envelope for the new method and of performing the resulting dynamic memory allocations is no longer negligible in comparison to the overall run time, whereas in the m constraint, these are pre-determined.

a dual-core amd opteron®- <dig>  <dig>  ghz system with  <dig> gbytes of main memory running linux fedora core  <dig> was utilized for the timing experiments.

the significance of these timing gains is even greater when taken in conjunction with the results in the preceding sections that indicate that the improvement is not at the cost of prediction accuracy. furthermore, it is worth noting that the speed-up factor is larger for the longer 5s rna sequences. since these require significantly more time than the shorter trna sequences the overall impact of the speed-up is very significant and in fact increases the length of sequences on which dynalign can be deployed.

the memory requirements for the two methods are compared in table  <dig>  where the minimum, maximum, and average memory  required for the  <dig> sequence pairs each of trnas and 5s rnas are indicated. memory requirements are as reported in the size entry of linux ps command after all requisite dynamic allocations are done. this number corresponds to approximate value of virtual memory usage of the  process. the tabulated numbers indicate that the proposed method also offers a memory advantage. as might be anticipated, the advantage is relatively minor for short sequence lengths  but quite significant for longer sequences . the savings for longer sequences are particularly attractive since often memory is a limitation that restricts the length of sequences for which dynalign may be utilized.

 <dig>  benchmarking against other structure prediction methods
for benchmarking purposes, the implementation of the new principled alignment constraint  and the previous dynalign banding constraint   <cit>  were also compared against three other dynamic programming algorithms. the three other programs are foldalign  <cit> , which uses a free energy-based scoring function, and stemloc  <cit>  and consan  <cit> , which use scfg models. each program was run using default parameters. our interest is both in the accuracy of the methods and in their use of resources, cpu time and memory.

tables  <dig> and  <dig> show the accuracy of structure prediction for the methods with trna  <cit>  and 5s rrna  <cit> , respectively. in each case,  <dig> pairs of sequences were randomly chosen from a database of sequences with known structure. these tables also show the comparison of the programs that find the structure common to two sequences to the accuracy of single sequence secondary structure prediction. sensitivity and positive predictive value  are both scored  <cit> , where sensitivity is the fraction of known pairs correctly predicted and positive predictive value is the fraction of predicted pairs in the known structure. results are stratified by percent similarity of the two sequences and the final column summarizes the results over all values of sequence pair similarities.

results are summarized for sequence similarity values ranging from 20% through 100% in steps of 20% and for the overall data set . dynalign new constraint refers to dynalign with probabilistic alignment constraints proposed here. software version numbers and parameters for the algorithms are described in section  <dig> .

results are summarized for sequence similarity values ranging from 20% through 100% in steps of 20% and for the overall data set . dynalign new constraint refers to dynalign with probabilistic alignment constraints proposed here. software version numbers and parameters for the algorithms are described in section  <dig> .

for determining computation and memory resource requirements, calculations were performed using one core on a dual opteron  <dig>  machine with  <dig> gb of ram under fedora core linux with the gcc compiler.

a dual-core amd opteron®- <dig>  <dig>  ghz system with  <dig> gbytes of main memory running linux fedora core  <dig> was utilized for the timing experiments.

a dual-core amd opteron®- <dig>  <dig>  ghz system with  <dig> gbytes of main memory running linux fedora core  <dig> was utilized for the timing experiments.

 <dig> discussion
in this paper, a novel technique is presented for reducing the alignment search space for finding the common secondary structure and alignment for two rna sequences. the allowed nucleotide alignments are those determined to be reasonable  as determined by a forward-backward calculation using a hidden markov model . this new method provides a significant improvement in rigor and speed as compared to previous versions of dynalign, in which the user was required to empirically choose a parameter that set a band of allowed alignments  <cit> . the hmm is significantly more flexible in the application of constraints because the allowed region is narrow where the alignment is well-defined by sequence conservation alone, but also wide when the alignment is poorly defined.

other pairwise implementations of the sankoff algorithm have also explored alignment constraints to speed execution time. for stemloc, holmes introduced the alignment "envelope," which is the set of allowed nucleotide alignments as determined by the union of "n-best alignments," i.e. only nucleotide position alignments occurring in the n most likelihood sequence alignments  <cit> . this has the disadvantage that regions of the nucleotide alignment can be poorly resolved and therefore not well sampled with n alignments. for consan, dowell and eddy use a forward-backward hmm to determine nucleotide alignments of high probability, called "pins"  <cit> . in consan, these high probability nucleotide alignments are forced to occur. this approach has the drawback that there are no constraints between pins and, for sequence pairs with low identity, it is possible that no pins will be found.

the present manuscript describes the combination of the proposed method for determining alignment constraints with dynalign. the technique, however, is general and would apply to other implementations of the sankoff algorithm, including consan  <cit> , foldalign  <cit> , pmcomp  <cit> , and stemloc  <cit> . two pairwise calculations of alignment constraints could also be used to accelerate x-dynalign, a program that finds the common structure and alignment for three homologous sequences  <cit> . aside from the improved speed of dynalign for determining secondary structure, this new method will have a significant impact in the discovery of non-coding rna  sequences in genome scans. two papers have reported the use of algorithms that can find the secondary structure common to two unaligned sequences as generic rna gene finders  <cit> . these programs have high sensitivity for ncrnas, especially for regions of genome alignment that have low pairwise identity. the principal drawback is that they are slow compared to programs that find ncrnas by scanning fixed, predetermined alignments  <cit> . the method used here to accelerate dynalign mitigates some of the computational cost and will allow faster scanning of genomes for novel ncrnas. the success of the methodology also suggests that iterative methods based on a posteriori probability estimates that have been extremely successful in communication systems  <cit>  may offer parallels in biological problems involving sequence and structure similarity  <cit> .

since the method adaptively computes alignment constraints for each pair of input sequences, its complexity varies depending on the input sequence pair. in practice, the computational complexity will depend on the extent of sequence conservation between the two homologous sequences. in the worst case, it can require as much computation as the full unrestricted sankoff algorithm, viz. o in computation and o in memory. in the best case, where the alignment constraint actually corresponds to a single alignment, i.e. a band of width m =  <dig>  the complexity reduces to o in computation and o in memory. from the computational perspective, the best case scenario is encountered for the case of identical sequences with sufficient nucleotide diversity . in this case, however, comparative analysis offers little benefit for the overall problem of joint structure prediction. the worst case scenario is rare for homologous sequences.

finally, note that the alignment constraint constitutes only one element  that determine the structural prediction accuracy. the accuracy depends also on the thermodynamic scoring model and on the "fold constraints" utilized in the computation. in particular, experimental results for some of the situations in which the proposed method fails demonstrate that the thermodynamic model actually predicts a lower free energy for the structure determined by dynalign  than for the true structure.

 <dig> 
CONCLUSIONS
a new procedure is proposed for establishing alignment constraints in joint alignment and secondary structure prediction problems for rna sequences. the proposed technique when integrated in dynalign eliminates the need for manual parameter selection and provides significant computational savings  while simultaneously providing a small improvement in the structural prediction accuracy. the revised version of dynalign can be downloaded, either as source code or as part of the rnastructure package for microsoft windows  <cit> .

 <dig> methods
a hidden markov model  formulation is utilized in order to estimate a posteriori symbol-to-symbol alignment probabilities. hmms have been previously used in sequence analysis  <cit> , in speech recognition  <cit> , and in error correction coding  <cit> .

 <dig> . <dig> notation
individual output sequences are denoted by lowercase boldface letters specifically x <dig> and x <dig> for the case of two sequences. specific nucleotides or subsequences selected from a sequence are indicated by prescripts: xn <dig> denotes the n1th nucleotide of the 1st sequence and xn1n <dig> denotes the subsequence of nucleotides from index n <dig> to n <dig> in sequence x. an alignment between the two sequences is specified by a sequence of states from the set

  m = {aln, ins <dig>  ins2} 

these states define an alignment by relating nucleotide positions between the two sequences as illustrated by means of an example in figure  <dig>  the aln state represents aligned nucleotide positions, where each of the two sequences has a nucleotide . an ins <dig> state represents an insertion of the first sequence, where there is a nucleotide in the first sequence x <dig> but no corresponding nucleotide in the second sequence x <dig>  in figure  <dig> this is denoted by pairing the nucleotide in sequence x <dig> with the null or gap symbol ⊓. similarly, the ins <dig> state represents the complementary situation of an insertion in the second sequence. the letter m  will denote a specific state, i.e., an element of the set m.

a nucleotide position n <dig> from the first sequence is said to be co-incident with a nucleotide position n <dig> from the second sequence if either of the following three conditions hold:

 <dig>  n <dig> and n <dig> are aligned.

 <dig>  n <dig> occurs in an "insertion run" in the first sequence that began at a nucleotide position aligned with position n <dig> in the second sequence. formally, this may be described as follows: the nucleotide at position n <dig> is an insertion in the first sequence and nucleotide position n′ <dig> from sequence  <dig> is aligned with nucleotide position n <dig> from sequence  <dig>  where n′ <dig> denotes the largest nucleotide position index in sequence  <dig> under n <dig> that is aligned .

 <dig>  n <dig> occurs in an "insertion run" in the second sequence that began at a nucleotide position aligned with position n <dig> in the first sequence, i.e., the nucleotide at position n <dig> is an insertion in the first sequence and nucleotide position n′ <dig> from sequence  <dig> is aligned with nucleotide position n <dig> from sequence  <dig>  where n′ <dig> denotes the largest nucleotide position index in sequence  <dig> under n <dig> that is aligned .

 <dig>  hidden markov model for homologous sequences
the hmm models the relation between two homologous nucleotide sequences, x <dig> and x <dig> by a two-stage probabilistic model. the first stage comprises the sequence of states that represents the alignment and the second stage models the nucleotides in the sequences. specifically, the sequence of states in the first stage of the model are assumed to constitute a time-invariant .

markov process. this three-state markov process can be represented in terms of the state transition diagram illustrated in figure  <dig> and is characterized by the state transition probabilities {τ}m <dig> m2∈m where τ ≡ prepresents the probability that the next state is m <dig> given that the current state is m <dig>  in each stage, the hmm emits an ordered symbol pair from the alphabet set {a, c, g, u, ⊓}. the chronological progression of the first elements of the emitted ordered pair constitute the first sequence and the second elements make up the second sequence. as indicated before, the ⊓ represents a null symbol or a gap where no nucleotide is emitted in the sequence. the emission probabilities for all possible ordered pairs, for each of the states, characterize the second stage of the model. the probability that the symbol pair  is emitted in state m is denoted by γm. each state of the alignment markov process allows emission of only a subset of the total set of ordered symbol pairs. ordered symbol pairs emitted in the aligned states can only be nucleotide pairs , those emitted in the ins <dig> state can only be of the type  where x is a nucleotide, and those emitted in the ins <dig> state can only be of the type  where x is a nucleotide. a gap pair  is a disallowed output in any state. disallowed outputs are readily handled in the model by requiring that the corresponding emission probabilities are zero. observe that the aln state can output ordered pairs which are mismatched . as a final remark on the model, note that the alignment states are in fact hidden and unobservable since only the sequences are observed.

the hmm parameters consist of the state transition probabilities for the first stage markov process and the emission probabilities for the second stage. the model is useful because with appropriately chosen parameters it captures observed statistics of homologous sequences. for instance, in homologous sequences, aligned base pairs are more likely to have matching rather than differing nucleotides. higher probabilities for emission of these matching nucleotide pairs in the aln state allow for this statistical behavior to be modeled. similarly, gaps in homologous sequences tend to occur in long runs rather than as single nucleotide insertions; a characteristic that the hmm can represent through a high probability of self transitions for the states in figure  <dig>  thus the hmm provides a suitable model for homologous sequences.

the hmm formulation is advantageous because it can provide answers to several meaningful questions in a computationally tractable and efficient manner. for instance, given any two sequences one can determine the most probable alignment between them  and the corresponding probability that sequences are related by the model. if this probability is high , one may infer that the sequences are likely to be homologs. this method is in fact utilized for sequence alignment and computing probabilistic similarity scores. however, as indicated in section  <dig> for ncrna sequence similarity alone is a poor metric for homology, particularly in regions with poor sequence similarity . therefore, instead of determining the best alignment and the corresponding probability, the proposed method computes the posterior probability of each nucleotide position in one sequence being aligned with each nucleotide position in the other sequence. subsequently, we can use these posterior probability estimates in order to restrict the search space for dynalign and improve its computational efficiency. specifically, as described in section  <dig>  an alignment constraint is computed by thresholding posterior alignment probabilities of nucleotide positions of two sequences. the estimation of these posterior alignment probabilities using the hmm is described next.

 <dig>  posterior probabilities for pairwise sequence alignment
the posterior probability p in  denotes the probability that nucleotide position n <dig> in the first sequence x <dig> is co-incident with nucleotide position n <dig> in the second sequence x <dig>  given that the hmm emits the two sequences. conceptually, this probability may be determined by computing the probability of each possible alignment between the two sequences and summing up the probabilities for the alignments for which the n1th position of x <dig> is co-incident with the n2th position of x <dig> to obtain the desired posterior probability . the process, however, would require computation and memory that are exponential in the sequence lengths and is infeasible for practical sequence lengths of interest. using the hmm forward-backward algorithm, which constitutes a dynamic programming approach for the problem, these probabilities may be computed in a computationally efficient manner. the forward-backward algorithm provides a set of efficient recursions using which the posterior probabilities can be determined. for the general hmm setting, these recursions may be found in  <cit> . the specific situation of pairwise alignment hmms will be considered here.

 <dig> . <dig> trellis representation of the hidden markov process
in order to present the forward-backward recursions, it is convenient to represent the hmm in the form of a three-dimensional trellis of nodes {}, where the first two coordinates correspond to the sequence indices and the third corresponds to the hidden state variable. an alignment between two sequences can be represented in the form of a feasible path in the trellis . a sample trellis is shown in figure  <dig>  which depicts the nucleotide sequences and alignment path corresponding to the example of figure  <dig> 

the transitions between the trellis nodes represent the  markov process for the alignment. the process can be thought of as evolving in "time" by transitioning from a current node position  in the trellis to the next node  and emitting a pair of symbols . in this process , the transition probabilities  are determined by the current state and the emission probabilities  are determined by the next state. furthermore, the next node  is determined by the current node  and the next state m as follows:

  n1={n′1if m=ins2n′1+1otherwise 

and

  n2={n′2if m=ins1n′2+1otherwise. 

these constraints reflect the state dependent constraints on emitted symbol pairs that were outlined earlier and restrict the allowable paths for the process within the trellis. only  edges  →  between adjacent  nodes in the trellis that satisfy the above constraint are allowed or feasible transitions between trellis nodes. the allowed or feasible paths are then a sequence of feasible edges such that the end node of each edge is identical to the beginning node of the next edge. a section of the trellis illustrating the feasible paths corresponding to a specific node is shown in figure  <dig> 

 <dig> . <dig> forward-backward algorithm for posterior probability computation
from bayes' rule, the posterior probability in  may be written as

  p=pp 

where p represents the joint probability that nucleotide n <dig> of sequence  <dig> is co-incident with nucleotide n <dig> of sequence  <dig> and the sequences x <dig> and x <dig> are emitted . the computation of this joint probability is expressed in terms of recursions involving a forward-variable and a backward-variable . in order to define these variables, denote by sm the event that the state is m at the point when n <dig> nucleotides corresponding to the first sequence and n <dig> nucleotides corresponding to the second sequence have been emitted. equivalently, this is the event that the path of the hmm process through the trellis visits the trellis node .

the forward-variable is then defined as the joint probability

  αm=p,x11n <dig> x21n2), 

i.e., the probability that the subsequence x11n <dig> of n <dig> nucleotides is emitted in the first sequence, the subsequence x21n <dig> of n <dig> nucleotides is emitted in the second sequence, and the state  is to m. the backward variable is defined as the conditional probability

  βm=p), 

i.e., the probability that subsequences x1n1+1n <dig> and x2n2+1n <dig> are observed given that state is m when n <dig> and n <dig> nucleotides have been emitted in the first and second sequence, respectively. here n <dig> and n <dig> represent the lengths of sequences x <dig> and x <dig>  respectively.

from the markov property of the hidden alignment process, the joint probability in  can be written as

  p = αalnβaln 

the forward variable can be computed recursively by noting that each node in the trellis has three distinct incoming feasible edges corresponding to the three possible values for the immediately previous state . hence, the forward variable is obtained as

  αm=∑m′∈mp,n′2),sm,x11n <dig> x21n2) 

where in accordance with  and ,

  n′1={n1if m=ins2n1−1otherwise 

and

  n′2={n2if m=ins1n2−1otherwise 

now using the hmm state transition probabilities and the symbol emission probabilities defined in section  <dig> , it can be seen that the forward variable expression in , yields the recursion formula,

  αaln=∑m∈mτγalnp,x11n1− <dig> x21n2−1)=∑m∈mτγalnαmαins1=∑m∈mτγins1p,x11n1− <dig> x21n2)=∑m∈mτγins1αmαins2=∑m∈mτγins2p,x11n <dig> x21n2−1)=∑m∈mτγins2αm 

following a similar procedure, recursions for the backward variable are obtained:

  βm=τγins1p)+τγalnp)+τγins2p)=τγins1βins1+τγalnβaln+τγins2βins <dig> 

the joint probability that the sequences are emitted in the denominator of  can also be obtained from the forward variable as,

  p≡p=∑m∈mαm 

using  and  in equation  the posterior probability of co-incidence of two nucleotides can be obtained as,

  p∑m∈mαmβm∑m∈mαm 

 <dig> . <dig> boundary conditions
boundary conditions are required to initiate the recursions in equations  and . the forward variable recurses on the previous states and backward algorithm recurses on next states. as a result forward variable needs a boundary condition at the starting symbol pairs and backward algorithm needs the boundary condition at the ending pairs. since the method is employed over ncrnas rather than arbitrarily chosen rna segments, special dummy symbol pairs are introduced at the beginning, i.e., nucleotide positions  and at the end, viz, nucleotide positions .

the beginning state is then specified by:

  αm={1m=aln0otherwise 

similarly the end state is specified by:

  βm={1m=aln0otherwise 

 <dig>  probabilistic alignment constraint computation
as indicated in section  <dig> the alignment constraints are computed by utilizing a threshold on the posterior probability of co-incidence. this process can be summarized as follows:

 <dig>  using the boundary condition  and the recursions , calculate the forward variable αm over 3d trellis  ∈  ×  × m).

 <dig>  using the boundary condition  and the recursions , calculate backward variable βm over same trellis.

 <dig>  calculate probability p of emission of the observed sequences using .

 <dig>  using , compute the alignment posterior probability p, for all possible nucleotide alignment positions, i.e. for  ∈  × .

 <dig>  determine a statistical confidence threshold pthresh such that pair-wise alignments with a probability of lower than pthresh may be considered improbable and therefore excluded .

 <dig>  determine the constraint set c of allowable nucleotide position alignments between the sequences by thresholding the posterior probability at the chosen statistical confidence level pthresh, i.e.

  c = { | p > pthresh} 

note that  is identical to equation  in section  <dig> 

the constraints on alignment are then imposed a priori in dynalign by considering  only the pair-wise alignment positions in c.

 <dig>  model parameter and threshold estimation
seed alignments from the rfam database  <cit> , are utilized to estimate hmm parameters and thresholds required for the determination of alignment constraint sets. the process uses multiple sequence alignments for the  <dig> rna families: 5s rna, archaeal rnasep, bacterial rnasep classa, bacterial rnasep classb, bacterial srp, eukaryotic srp, group <dig> catalytic intron, group <dig> catalytic intron, nuclear rnasep, and trna. within each family the set of sequences available are randomized and half are utilized in the training process for determining the hmm parameters and the other half are used for testing and for establishing threshold probability values as will be described subsequently. the rfam database includes multiple alignments and in order to obtain pairwise alignments, all possible  pairwise sequence alignments implied by the multiple alignments of member sequences within a family are used.

in order to allow the model to better represent observed statistics, sequence pairs are grouped into a number of "bins" and hmm parameters are estimated for each bin. bins are established based on estimates of percent nucleotide-identity – an approach that has been commonly used for several probabilistic models  <cit> . a brief description of the process follows. first, a "universal" set of hmm parameters is obtained by utilizing all alignments in the training set . using this universal set of parameters, for any sequence pair, a maximum-likelihood  alignment is performed which is then utilized to compute the percentage nucleotide-identity, i.e., the percentage of positions in the ml alignment that are aligned and have matching nucleotides. the seed alignments in the training set are then utilized to estimate the hmm model parameters, i.e., the state-transition and emission probabilities, for sequence pairs with percent nucleotide identities corresponding to the bins : < 30%,  <dig> – 40%, <dig> – 50%, <dig> – 60%,  <dig> – 70%,  <dig> – 80%,  <dig> – 90%, and  <dig> – 100%. once the hmm parameters are known, for any pair of sequences, first using the ml alignment with the universal model, the percent nucleotide identity is computed which is then used to identify the corresponding bin for the hmm parameters. using these parameters, the posterior probability of nucleotide co-incidence may be calculated as described in section  <dig> .

once the hmm parameters are established, suitable values of probability thresholds ), are determined by empirically evaluating the performance of the alignment constraint set over test sequences . since nucleotide alignments outside the alignment constraint set are disallowed, it is desirable that as few as possible of the true nucleotide alignment positions are outside the constraint sets. figure  <dig> shows a plot of the fraction of missed alignment position pairs as a function of the  threshold pthresh for the  <dig> different bins indicated above . figure  <dig> illustrates the fraction of missed alignments, i.e., alignments for which even one nucleotide alignment position is outside the corresponding constraint set. using figure  <dig>  values of the threshold probability  were determined for each of the  <dig> bins that ensured that less than one in  <dig>  alignment positions were missed, i.e., the empirical probability of missing an alignment position was less than 10- <dig>  these threshold values were then utilized in subsequent experiments to determine alignment constraints for dynalign.

 <dig>  scoring structure predictions
the accuracy in correctly predicting canonical base pairings is utilized for the purpose of scoring the performance of the structural prediction methods. the performance is quantified using sensitivity, i.e., the fraction of canonical pairings in the known  structure that are correctly predicted by the method and the positive predictive value , which is defined as the fraction of predicted base pairings that are in agreement with the known structure. in both cases, a "slippage" of one nucleotide on one side of the base pairing is allowed. thus a base pairing i - j in the known structure is considered correctly predicted  if the predicted structure contains a base pairing in one of the  <dig> positions: i - j,  - j, i - . likewise, a base pairing i - j in the predicted structure is considered correctly predicted  if the known structure contains a base pairing in one of the  <dig> positions: i - j,  - j, i - .

thus,

  sensitivity=nckntk 

where nck is the number of base pairings in the known  structure that are correctly  predicted as per the above definition, and ntk is the total  number of base pairings in the known structure.

similarly,

  ppv=ncpntp 

where ncp is the number of base pairings in the predicted  structure that are correct  as per the above definition, and ntp is the total  number of base pairings in the predicted structure.

the motivation for allowing the one nt slippage is twofold: firstly, the slippage of one nt does not typically change the predicted topology of the secondary structure, which is much more significant than the exact pairing predicted. secondly, the "correct" pairings are obtained using experiments and comparative sequence analysis, which also have uncertainty due to dynamics of base pairings and limited resolution of the methods. the scoring methodology based on the one nt slippage has also been used in prior published literature  <cit> . the scoring method adopted yields values of sensitivity and ppv roughly 2–3% higher than when an exact match criterion is used for scoring, where a base pairing i - j in the known structure is deemed correctly predicted for the purpose of sensitivity computation if and only if the exact base pairing i - j is also predicted . for completeness, sensitivity and ppv values obtained with the exact match constraints for scoring are included as tables  <dig> and  <dig> 

results are summarized for sequence similarity values ranging from 20% through 100% in steps of 20% and for the overall data set . dynalign new constraint refers to dynalign with probabilistic alignment constraints proposed here. software version numbers and parameters for the algorithms are described in section  <dig> .

results are summarized for sequence similarity values ranging from 20% through 100% in steps of 20% and for the overall data set . dynalign new constraint refers to dynalign with probabilistic alignment constraints proposed here. software version numbers and parameters for the algorithms are described in section  <dig> .

 <dig>  parameters for dynalign and other programs used for benchmarking
for all the experiments, dynalign is run with constraints on folding where base pairs whose minimum free energy structure is above 70% of minimum free energy structure as determined by single sequence secondary structure prediction are not allowed to pair  <cit> . this is the default setting and is used in both dynalign with m constraints and dynalign with probabilistic alignment constraints. in addition, dynalign with the m constraint uses m =  <dig> as explained in  <cit> . only the minimum free energy structures were predicted, i.e. suboptimal foldings are not generated. the thermodynamic parameters used in both versions of dynalign are those compiled in references  <cit> . dynalign with m constraint used all parameters identical to the ones for the new method with the exception of the alignment constraint, which was replaced instead by the banded constraint implied by m and defined in equation .

for the purposes of benchmarking, the new proposed method was compared against single structure prediction  <cit>  and four other pairwise structural prediction methods: dynalign with the previous m constraint  <cit> , stemloc  <cit> , consan  <cit> , and foldalign  <cit> . these programs were utilized in their default configuration. a summary description of these methods and the runtime options utilized in the benchmarking experiments follows:

• stemloc: stemloc  <cit> is a pairwise structural alignment prediction program based on stochastic context-free grammars. it uses "fold" and "alignment" envelopes to reduce computation and memory. the benchmarking experiments utilized stemloc version  <dig> b in global alignment mode  with  <dig> best alignments  and  <dig>  best folds.

• consan: consan  <cit>  is a pair-scfg for making pairwise structural alignment. it utilizes the concept of "pins", i.e. nucleotide positions that are constrained to be aligned, in order to constrain the alignment space and thereby limit computation and memory. pins are selected based on posterior probabilities of alignment. the benchmarking was performed using consan version  <dig> . the training required for consan was performed over the dataset of lsu and ssu rnas included with the package . the resulting model file "mixed <dig> mod" is used for consan runs . the '-s' option is used for suppressing all messages to standard output except the structural information that consan predicts.

• foldalign: foldalign  <cit> is free energy minimization based sankoff implementation for local structural alignment of multiple sequences. the benchmarks were computed using foldalign version  <dig> . <dig> in global alignment mode  since the input consisted of homologous trna or 5s rna pairs.

• single prediction: the single sequence prediction method is based on thermodynamic free energy minimization  <cit> . our implementation utilized the version included in the current version of rna structure and dynalign  <cit> .

dynalign and the single sequence prediction method can utilize knowledge of modified nucleotides that cannot accommodate the canonical a-form helix . these are forced single-stranded in the structural prediction and the knowledge therefore improves the overall prediction  <cit> . the trna database includes knowledge of modified nucleotides whereas the 5s rna database does not include any knowledge of modified nucleotides. since the other methods benchmarked do not utilize knowledge of modified nucleotides, for the benchmarking results of section  <dig> , the knowledge of modified nucleotides was not utilized for the dynalign and single sequence predictions. results in section  <dig> list the performance both with and without the use of this knowledge in prediction.

computation times for all the methods are determined by using the time command under linux. memory requirements for the programs are as reported in the size entry of linux ps command. for the dynalign methods the memory usage is estimated after all requisite dynamic allocations are done. for other programs, the memory usage is estimated at exactly half of the run time for each sequence pair, except for sequences with computation times over  <dig> seconds, for which the memory usage is evaluated at  <dig> seconds.

authors' contributions
g.s. proposed the use of a posteriori probability estimates for the purpose of determining alignment constraints. all three authors worked together on the conceptual development of the technique. a.o.h. implemented the proposed algorithm and conducted the experiments for obtaining the reported results. in this effort he was guided and supervised by g.s. and d.h.m. d.h.m. also provided assistance in the integration of the software with existing dynalign code. the three authors collectively wrote, edited, and revised the manuscript. significant connections to related work in the biological and bioinformatics literature were recognized by d.h.m. and in electrical communications literature by g.s., respectively. all authors read and approved the final manuscript.

 <dig> appendix
 <dig>  note that the set of aligned positions alone  does not satisfy this requirement.

 <dig>  the actual search is 4-dimensional, which can be thought of as combination of a two-dimensional search over possible alignments between the sequences along with a two-dimensional search over  folds for the sequences.

 <dig>  the prediction accuracy for dynalign also depends on the thermodynamic model employed for scoring secondary structures and hence the dependence on the alignment constraint is indirect.

 <dig>  a reasonably high value of specificity is also advantageous because it reduces computation time and memory.

 <dig>  the assumption of time invariance may be dropped if necessary. it is adopted for notational simplicity.

 <dig>  some of the details of the trellis representation are a matter of convention and there exist other valid conventions that may be adopted instead.

 <dig>  in computational biology literature, the terms forward matrix and backward matrix are alternately used for the forward and backward variables.

 <dig>  note that random nucleotide sequences of the same length can be expected to have a sequence similarity of 25%.

