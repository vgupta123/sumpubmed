BACKGROUND
the first step in a resequencing study is to map reads from a sample genome onto a reference, accounting for sample variance and sequencing error. an accurate and sensitive approach is to use smith-waterman
 <cit>  alignment; however, this is computationally infeasible for mapping to nearly any genome. instead, methods have been created using heuristics and data structures that are appropriate for rapid mapping of the type of read considered. for example, reads produced by sanger sequencing that are highly accurate and nearly  <dig> bases long are successfully mapped using hash-based methods such as megablast
 <cit> , cross_match , and blat
 <cit> . these methods are too inefficient to map read sets from next generation sequencing  instruments by illumina  and life technologies , since they contain hundreds of millions of short reads. instead, methods such as bowtie, bwa, and soap <dig> are used
 <cit> . these are based on querying the burrows-wheeler transform full-text minute-space index 
 <cit>  of a genome. they are able to rapidly align reads when there is little variation between the read and the genome.

sequencing methods based on single molecule sequencing  also produce large datasets that have high computational demands for mapping. sms datasets do not have the length limitations of ngs or sanger sequencing, but have a higher number of errors, and the errors are primarily insertions and deletions rather than substitutions. thus, mapping methods created for ngs sequencing do not extend well to sms reads. a recent study using the pacbiors platform
 <cit>  included a large number of reads over  <dig> kilobases long. as reads become longer, the computational problem begins to resemble the whole genome alignment  problems that were examined when multiple mammalian genomes were sequenced
 <cit> . the problem arises of how to align long  reads with moderate divergence from the genome  at the speed and sensitivity that ngs alignment methods operate.

many alignment methods in similar application areas share related algorithmic approaches or data structures that are tailored to optimize the particular targeted application. the relationship between many existing alignment methods
 <cit>  is qualitatively illustrated in figure
 <dig>  we present an approach, basic local alignment via successive refinement , which maps reads using coarse alignment methods developed during wga studies, while speeding up these methods by using the advanced data structures employed in many ngs mapping studies.

advances in isolation and detection of single molecules and reactions have enabled sms methods
 <cit> . these sms methods monitor processes in real time. the pacbiors instrument produces reads by detecting which fluorescently labeled nucleotides are incorporated into a dna chain as a template sequence is replicated by dna polymerase. other sms methods have been proposed using detection of cleaved bases that pass through a protein nanopore
 <cit> , and identifying bases that have translocated through a nanopore fabricated in a graphene membrane
 <cit> . in the case of the pacbiors sequencing, a missing or weak signal of nucleotide incorporation results in a deleted base, and nucleotides that give fluorescence signal without being incorporated lead to insertions.

we propose aligning sms reads with high indel rates to genomes as follows. first, find clusters of short exact matches between the read and the genome using either a suffix array or bwt-fm index
 <cit> . then, perform a more detailed alignment of the regions where reads are matched to assign the alignment. to investigate the feasibility of doing this in the human genome, we need to determine two metrics:  the number of matches of minimal length expected to exist between a read and the genome at a given sequencing accuracy and read length, and  the number of false positive clusters the read is expected to have elsewhere in the genome. if the chances of finding a match between the read and the genome are low, or if there are many regions a read may map to incorrectly with high identity, our proposed approach would not be feasible. for a particular read length and accuracy, we present a method to determine the probability that the read contains a sufficient number of anchors to map; this method is based on counting integer compositions. we next examine the repeat structure of the human genome to determine how difficult it is to map to due to the repetitive nature of the genome. rather than defining repeat content as the amount of sequence sharing high percent identity, we measure a different similarity metric on the human genome, the anchor similarity, where sequence similarity is measured as the number of shared anchors between the two sequences from the genome. we find that there are both a high number of expected matches between the read and the genome, and few false positive clusters of matches of the same size elsewhere in the genome, indicating that the proposed approach is feasible for mapping reads to the human genome.

we implemented our method in a program called blasr , which combines the data structures used in short read mapping with alignment methods used in whole genome alignment. a bwt-fm index or suffix array of a genome is queried to generate short exact matches that are clustered and give approximate coordinates in the genome for where a read should align. a rough alignment is generated using sparse dynamic programming on a set of short exact matches in the read to the region it maps to, and a final detailed alignment is generated using dynamic programming within an area guided by the sparse dynamic programming alignment.

RESULTS
our results are broken down into two sections; in the first, we examine characteristics of pacbiors reads, and present theory on how these sequences contain matches that may be used to anchor alignments to the genome. in the next, we present a practical comparison of alignment methods on pacbiors sequences.

mapping feasibility
our strategy to map sms reads is to locate a relatively small number of candidate intervals where the read may map and then use detailed pairwise alignments to determine the best candidate. the candidate intervals may be found by locating all exact matches between the read and the genome, and then finding dense clusters of exact matches  in spans of similar length and the same  order and orientation in both the genome and read, as described in detail in methods. the feasibility of the method depends on the balance of having enough anchors to detect the correct interval to align a read to, vs. having so many anchors that clustering takes a prohibitive amount of time.

one approach to limiting the number of anchors is to limit to a set of anchors of low multiplicity in the genome; this is commonly done by using longer anchors. when the sequencing error rate is ρper position, without positional bias, the average length of an exact match is
1ρ− <dig> bases. for ρ =  <dig> , the average length is
1ρ−1≈ <dig> . every word of length  <dig> occurs on average over  <dig> million times in the human genome, far too many times to be suitable as an anchor for rapid alignment. fortunately, the condition that a sequencing error occurs precisely every ⌊1/ρ⌋ bases is worst-case, and is exceedingly rare: for a sequence of length l with roughly e = ρl sequencing errors, this only happens with probability on the order of
1/le. rather than focusing on the average case, it is more informative to consider the distribution of runs of error-free sequences; for a uniform distribution of errors across a read, this is a geometric distribution. to look at the empirical distribution of error-free sequences, a sample of reads from escherichia coli sequenced by a pacbiors was aligned back to the reference. the resulting distribution of spans of error-free sequences is shown in figure
 <dig>  and closely follows the geometric distribution for over 95% of the data.

we may model sms sequencing as a process that generates a series of error-free words with a geometric length distribution, each separated by a single erroneous base. with this model, it is possible to determine how many words must be sequenced until there is a high probability that a word of length k or greater  has been sequenced. denoting the length of a word as w , pr{w = k} = kρ, and pr{w ≥ k} = k, where k≥ <dig>  in order to have a probability of 1 − εthat a word of length k or greater is sequenced without error, t words must be sequenced, where
t=loglogk). the waiting length is the corresponding number of bases for t words, each followed by one incorrect base. the waiting length is 

 t1+∑i=1k−1ipr=t1+∑i=1k−1iiρk)=t1ρ−kk1−k. 

the waiting lengths for words of size  <dig>   <dig>  and  <dig> are shown for ε =  <dig>  and varying ρin figure
 <dig>  we refer to error-free sequences of length k or greater as anchors.

other alignment methods such as gapped blast
 <cit>  and blat
 <cit>  have shown that it is useful to initiate alignments at pairs of anchors. the waiting lengths may be used to compute the length of read required to be certain of having at least n anchors. instead of using waiting lengths, it is possible to directly compute the probability of sequencing a certain number of anchors when the error rate is known. we do this with a model that approximates all errors as point mutations on a scan across a template. given a fixed template length l, a minimal anchor length k, a number of errors m, and a number of anchors n, define numconfigurations as the number ways to distribute the positions of m errors when reading from the template such that there are at least n maximal substrings of length ≥ k not interrupted by error. in appendix  <dig>  we compute this using generating functions, allowing us to apply the result across the read lengths and error profiles found in sms sequencing. weese et al.
 <cit>  considered a similar problem for short reads and low error rates, and set bounds for filtering alignment hits in a q-gram based mapping method by using a dynamic programming approach.

assuming all permutations of errors are equally likely,
numconfigurations/lm gives the probability of sequencing at least n anchors. we computed this probability for the parameters l =  <dig>  and k =  <dig>   <dig>  and  <dig>  to study the number of anchors to use for mapping. the results are shown in figure
 <dig> for m =  <dig>   <dig>   <dig>  and  <dig>  corresponding to read accuracies of 80%, 85%, 90%, and 95%. at an accuracy of 85%, nearly all configurations have at least  <dig> anchors of length at least  <dig>  this indicates that with minimum anchor size k =  <dig>  one would would expect to find at least  <dig> anchors at the correctly mapped interval in the genome.

when a read is sampled from a repeat in the genome, there are likely to be many dense clusters of anchors mapping the read across the genome. assuming the repeat is divergent, it is necessary to perform a detailed alignment  to all intervals containing dense clusters of anchors in order to distinguish the correct mapping location from other repeats. for copies of a repeat such as alu or line in the human genome, the computational demands are too prohibitive to align the read against all instances of the repeat. on the other hand, if only a limited number of mapped locations are aligned in detail, the chance of finding the correct location is small. the similarity of repeats in a genome is typically defined by percent identity from a pairwise alignment of the two sequences
 <cit> . however, sequences that have a high percent similarity may not share many long stretches of exact matches, which is how they are compared when using anchor-based mapping. to characterize repeats with respect to anchor-based mapping, we introduce an alternative metric: the anchor similarity of two sequences is the maximum number of fixed-length, non-overlapping, ordered anchors, shared between two sequences, with certain constraints on anchor spacing. if the anchor similarity is s, we also say the two sequences are s-similar, and ≥s-similar when two sequences have anchor similarity that is at least s. using fixed-length anchors simplifies the presentation, although the blasr method uses variable length anchors. anchor similarity requires two parameters: k, the minimum anchor size; and δ, the indel rate, which may change the spacing between anchors. the constraints reflect the spacing one would expect between anchors of a read with indel errors and a genome. for example, consider a sequence that contains anchors at coordinates a and b, matching anchors at coordinates a′ and b′in another sequence. if the ratio of the gaps between anchors is bounded by
1−δ≤b−ab′−a′≤1+δ , then a and b may be included in the count for the anchor similarity of the two sequences. further details on computing anchor similarity are given in the additional file
1: text s <dig>  section  <dig> .

to characterize the repetitiveness by anchor similarity of sequences in the human genome, we took a sample of  <dig> million random intervals of length l= <dig> kb in the genome, and computed anchor similarity of each interval with all other intervals up to length l =  <dig>  in the rest of genome. we used anchors of lengths  <dig>   <dig>  and  <dig>  for each interval and anchor length, a histogram is generated for the number of times ≥s-similar intervals are found in the genome. a hypothetical sample sequence with k =  <dig> may have  <dig> thousand ≥1-similar intervals in the genome; one thousand ≥2-similar intervals; one hundred ≥3-similar sequences; ten ≥4-similar sequences; and one ≥5-similar sequence. this results in one million histograms . to summarize these, we examined the cumulative distribution of values of all histograms for ≥ <dig>  ≥ <dig>  ≥ <dig>  and ≥20-similar sequences, as shown in figure
 <dig> 

we compared the distribution of values of anchor similarity from the human genome with values of
numconfigurations/lm to see how the mapability of sequences compares to the expected distributions of matching anchors. reads from intervals of a genome that have low anchor-similarity to the rest of the genome are likely to have few spurious matching clusters and are thus likely to be uniquely mapped. conversely, a read sampled from an interval that has high anchor-similarity with many other intervals likely has many clusters of matches to the genome. figure
 <dig> shows an estimate of the number of intervals that must be searched when using anchor-based seeding to gain a certain degree of sensitivity of finding the true match. for example, when requiring only one or more matches of length  <dig> to find an interval, 22% of the sequences have up to  <dig> matching intervals in the genome . if instead  <dig> or more matches were required in order to find an interval, 97% of the regions of the regions sampled have up to  <dig> matching intervals in the genome . the combination of the values of
numconfigurations/lm and intuition for the feasibility of mapping sequences at various error rates in the human genome. from figure
 <dig>  for reads sequenced at 85% accuracy, it is very likely there are least  <dig> anchors of there are least  <dig> anchors of length  <dig> or greater in any read. the green points in c show the number of matching intervals when using a similar set of parameters: at least  <dig> anchors of length  <dig>  importantly, 95% of the samples match uniquely in the genome.

to gauge the mapability of sequences to various genomes, we simulated reads from escherichia coli, arabidopsis thaliana, and human, for read lengths that vary from  <dig> to  <dig> bases, and error rates from 20% down to 0%. we mapped them back to their reference genomes with blasr  for all three plots. reads were simulated with base accuracies 1−ρ = 80%, 85%, … , 100%. in the fraction ρof positions that are erroneous, we simulated 10% substitutions, 62% insertions, and 28% deletions. missing values have no mismapped reads.

as shown in figure
4b, a read with a 15% error rate has a 97% chance of having  <dig> anchors of length  <dig> or more. the anchor similarity corresponding to these reads uses parameters δ =  <dig> ,l =  <dig>  and k =  <dig>  and is shown by the red curve in figure
5a. over 90% of the sampled intervals only have one location with at least  <dig> anchors of length  <dig>  indicating they map uniquely under this repeat under this repeat metric. the other two genomes, e. coli, and a. thaliana, are shown for

mapping benchmarks
we generated three datasets for evaluating mapping speed and accuracy of different aligners on sms reads . for all e. coli datasets, reads were aligned to the genome of an isolate of the o104:h <dig> strain . the source reads are available at
http://bix.ucsd.edu/projects/blasr. performance was measured additionally with both blat and the bwa-sw aligners
 <cit> . bwa-sw was the first mapping method written that used both the bwt-fm index used in short read mapping and methods that allow mapping long reads with indel error. this method is very compact , and very sensitive to mapping reads with indel error, as compared to other existing methods. other methods that were tested either did not run or produced insufficient results. this may be expected, as these methods are highly optimized for other types of data that is either short read or whole genome sequences. of the programs that did not run, soap <dig> and lagan crashed, while bowtie did not accept the read input due to read length, and the mapping sensitivity was low on reads truncated to the maximum allowed length. the mosaik , mummer, and razers methods did execute, however the first two could only align to one chromosome of the human genome at a time due to space limitations, and were orders of magnitude slower than either blasr or bwa-sw while finding very few hits. finally, the razers method was only tested on e. coli reads, and found few hits across all tested parameters. because of the low mapping sensitivity, these methods were excluded from benchmarking results. the blat method is included as a reference for comparison to methods optimized for mapping sanger sequences, though it is slower and less sensitive than both blasr and bwa-sw.

the e. coli-pacbiors dataset contains  <dig>  reads comprising  <dig>  m bases after filtering, with lengths and error rate shown in figure
 <dig> . the reads contain  <dig> % insertion,  <dig> % deletion, and  <dig> % substitution error, though the details are sensitive to alignment penalty summary of the mapping statistics from each of the three programs is shown in table
 <dig>  all programs were executed on a single core of a  <dig>  ghz xeon processor. the parameters used for each program are given in additional file
2: table s <dig> 

each method was used to align 48× coverage of reads from e. coli o104:h <dig>  blasr-sa uses a suffix array index of the genome, while blasr-bwt uses a bwt-fm index of the genome.

to test the sensitivity and specificity of mapping, reads were simulated using an empirical model  based on the measurement of error rates from reads aligned to e. coli. the results are shown in table
 <dig>  the methods are largely in agreement on the reads that are correctly mapped, as well as in the number of bases from every read, and blasr is marginally faster. the slight differences in mapping statistics between blasr-sa and blasr-bwt are due to implementation differences in the order anchors are generated: using a suffix array, sequences are searched left to right, but for a bwt-fm index, sequences are searched right to left. one difference between blasr and bwa-sw is that bwa-sw often produces several short alignments of possibly overlapping substrings of a read rather than one contiguous alignment. we consider the number of bases mapped by bwa-sw as the sum of uniquely mapped bases from each read. usually this does not affect mapping and consensus quality, but occasionally there are subsequences from reads that are incorrectly mapped while the rest of the read is mapped correctly.

reads are simulated from e. coli and h. sapiens with length and accuracy parameters modeled from real reads from e. coli. skipped reads are either marked as filtered in the sam output, or missing from the output.

in addition to the information encoding the alignment, blasr produces a mapping quality value for every alignment. this value represents the phred scale probability that the coordinates the read is aligned to in the genome are incorrect, similar to the mapping quality values produced by maq
 <cit> . to test mapping quality values, we created three datasets of 10m simulated reads sampled from the genome with fixed read lengths of one, two, and three kilobases each. errors were added to the reads using the empirical read simulator . for each mapped read, we classified it as correctly and incorrectly mapped, allowing a measurement of accuracy of mapping quality value. the frequency of computed mapping quality values are shown in figure
8a. the mapping quality values are largely binary, owing to the fact most reads contain sequences that align uniquely to the genome. the empirical mapping quality values are shown in figure
8b.

CONCLUSIONS
methods to produce reads through single molecule sequencing were mostly theoretical a decade ago and are now produced in high throughput on an industrial platform. the different characteristics of the sequences produced by sms relative to next generation sequencing , require new computational techniques to be efficiently analyzed. here, we addressed the problem of mapping sms reads to a reference genome by first examining the feasibility of mapping sms reads, and then by benchmarking our new alignment method on reads produced by the pacbiors instrument. the source code is available under the bsd license at
https://github.com/pacificbiosciences/blasr and is the default alignment method available to all running the pacbiors.

there are many emerging problems for processing sms sequences. as the length of the reads produced by sms increases, the computational problem resembles whole genome alignment more than the read mapping problem. this increases the need to have methods that accurately detect structural rearrangements covered by single reads. furthermore, with the inevitable exponential increase in sequencing throughput, the current methods will not be sufficient to align sms reads without a large amount of time or computational resources, and further algorithmic improvements will be necessary. we did not address the issue of using multiple sequence alignment to produce a consensus sequence or variant calls. it has been shown that the additional information one may gain by observing the signal from single-molecule events in real time may indicate dna modifications such as methylation
 <cit> . thus, methods that produce consensus calls from sms sequences may reveal more information about the sample sequence if this extra information is used. we aim to address many of these problem in subsequent iterations of the blasr method.

