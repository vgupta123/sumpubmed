BACKGROUND
duplicate reads are one of the most problematic artifacts generated during polymerase chain reaction amplification. ideally, duplicates should have identical nucleotide sequences. however, due to sequencing errors, they may end up to be nearly-identical  <cit> . duplicates can affect the accuracy of some analyses on ngs data. removal of these artifacts can be an essential pre-processing step, in particular on applications based on resequencing. for instance, in snp calling, errors introduced in early amplification steps are shared by pcr duplicates, making very difficult to distinguish between repeated  errors and real snps  <cit> . duplicate removal is also a mandatory step to detect cnvs using read-depth  based methods  <cit> . these methods assume that the rd in a genomic region depends on the copy number of that region. as a consequence, duplicates need to be detected and removed to avoid incorrect read count. duplicates can also affect the accuracy of de-novo sequencing. during scaffolding, paired-end reads are mapped on contigs with the aim to rank their order. in this phase, two contigs are considered connected depending on the number of read pairs that link them . hence, pcr duplicates may result in false-positive connections between contigs.

duplicate sequences can be natural or artificial. ideally, only artificial duplicates should be removed, while natural ones should be retained. unfortunately, natural and artificial duplicate sequences are indistinguishable. this is the reason why a fraction of reads labeled as duplicates may in fact be generated from distinct molecules, yielding a loss of natural reads. however, this situation occurs typically during the analysis of single-end reads. in fact, as for paired-end reads, the probability of finding independent molecules identical at both ends being very low  <cit> .

removal tools proposed in the literature implement methods that focus either on alignment-based or on alignment-free strategies. alignment-based tools assume that duplicate reads will be mapped to the same position on a reference genome. these tools analyze the alignments obtained by running an embedded procedure  with the goal of finding reads with identical mapping coordinates. these reads are analyzed and those that meet predefined quality constraints are classified as duplicates. the performance of these tools is affected by the alignment constraints and by the accuracy of the aligner. moreover, it should be pointed out that these tools cannot be used in absence of a complete reference genome.

picard markduplicates  <cit> , samtools rmdup  <cit> , and seal  <cit>  are tools that implement an alignment-based strategy. picard markduplicates identifies duplicates by analyzing the alignments generated by a third-party aligner. as for paired-end reads, it finds the 5’ coordinates and mapping orientations of each read pair. all pairs with identical coordinates and orientations are analyzed and those having the highest sum of base qualities are classified as duplicates. it also removes duplicates from single-end libraries. similarly, the rmdup function of samtools analyzes alignments obtained with a third-party tool to remove duplicates from both single- and paired-end reads. however, differently from picard markduplicates, rmdup is not able to remove interchromosomal duplicate reads. seal provides a distributed version of bwa  <cit>  to perform the alignment and removes duplicates according to the same criteria employed by picard markduplicates.

alignment-free tools detect duplicates by comparing read sequences. in particular, those reads characterized by a similarity score higher than a given threshold are classified as duplicates. notably, tools that comply with this strategy are not affected by the bias introduced by a short-read mapping tool and can also be used in absence of a complete reference genome. unfortunately, they may be computationally onerous, as each sequence of the dataset must be compared to all other sequences in the dataset. this is the reason why heuristics are defined and adopted to deal with the computational challenge.

fastx-toolkit collapser  <cit> , fastuniq  <cit> , fulcrum  <cit>  and cd-hit  are all examples of tools that implement an alignment-free strategy. fastx-toolkit collapser is able to identify and remove identical sequences from single-end reads. conversely, fastuniq has been designed to remove identical duplicates from paired-end reads. removal is performed executing three steps in pipeline. initially, all paired reads are loaded into memory. then, read pairs are sorted according to their nucleotide sequences. finally, duplicates are identified by comparing the adjacent read pairs in the sorted list. fulcrum is able to identify identical and nearly-identical duplicates from both single- and paired-end reads. it identifies as potential duplicates those reads with an identical prefix of the nucleotide sequences. potential duplicate reads are binned in different files, whose maximum size is user-defined. read sequences within each file are compared to identify duplicates. cd-hit provides two different tools to remove duplicates from single- and paired-end reads generated with  <dig> or illumina platform. cd-hit- <dig> analyzes libraries generated with  <dig> to identify duplicates that are either exactly identical or meet the following criteria: a) reads must be aligned at 5’-ends; b) for sequences of different length, a shorter read must be fully aligned with the longer one  and they have less than user-defined percentage of indels and substitutions. cd-hit-dup removes duplicates from illumina libraries analyzing the prefix of the read sequences. read sequences with identical prefix are considered duplicated. for paired-end reads, prefixes at both ends are checked. features of the listed tools are summarized in table  <dig> 
the second column indicates the implemented strategy. the third column reports whether the corresponding tool support single- and/or paired-end read libraries. the fourth column reports the sequencing platforms supported. the fifth column reports whether the corresponding tool is able to remove only identical or nearly-identical duplicates




recently, we proposed a new alignment-free method aimed at removing duplicate reads using graphics processing units   <cit>  generated with an illumina platform. in particular, we implemented a prefix-suffix comparison algorithm which takes into account the per-base error rates generate with illumina. the method consists of two phases, which have been massively parallelized on gpu. initially, potential duplicate sequences are clustered according to their prefix. then, the suffixes of the sequences in each cluster are compared to detect and remove duplicates.

although the method can be efficiently used to remove both identical and nearly-identical duplicates, there are some constraints and limitations that need to be overcome. in particular, it does not allow to detect potential duplicates on prefixes longer than  <dig> bases, does not support paired-end read libraries, and imposes a constraint on the maximum size of the clusters.

in this work we present gpu-dupremoval  a new implementation of our method devised to overcome these limitations. in particular, i) cluster reads without constraints on the maximum length of the prefixes are now allowed, ii) support for both single- and paired-end read libraries is provided, and iii) larger clusters of potential duplicates  can now be processed.

implementation
before going into relevant details of the proposed algorithm, let us give a short introduction to gpus.

graphics processing units
gpus are hardware accelerators that are increasingly used to deal with different computationally intensive bioinformatics algorithms . from an architectural perspective, the main difference between traditional cpus and gpus is related to the number of available cores. indeed, the former are devices composed of few cores, with lots of cache memory able to handle a few software threads at a time. conversely, the latter are devices equipped with hundreds of cores able to handle thousands of threads simultaneously, so that a very high level of parallelism can be reached.

the intensive use of gpus over the last years has yielded a significant increases in the performance of several applications. however, it should be noted that only algorithms based on the simd paradigm can be effectively parallelized on gpus. cpus and gpus should be considered as complementary for different types of processing. cpus are optimized for flow control and low memory latency, whereas gpus are optimized for data parallel computations. in this context, the gpu computing model uses cpus and gpus in a heterogeneous co-processing computing model. computationally-intensive parts of an algorithm based on the simd paradigm can be accelerated by gpus, whereas cpu is used to control the gpu execution while processing other parts of the algorithms not suitable for the gpu.

as for gpu programming, cuda   <cit>  and opencl   <cit>  offer two different interfaces for gpu programming. it is worth pointing out that opencl is an open standard that can be used to program cpus, gpus and other devices from different vendors whereas cuda is specific to nvidia gpus.

the algorithm
analysis of short-read datasets generated with illumina highlighted a very low rate of indel errors  while the number of occurrences of wrong bases increases with the base position  <cit> . therefore, it is possible to deduce that:  the majority of duplicates will differ on few base substitutions;  most of identical and nearly-identical duplicates are in fact characterized by an identical prefix. starting from these considerations, we devised a method aimed at comparing only potential duplicate reads  without taking into account indels in sequence comparisons.

initially, potentially duplicated sequences are clustered together . then, for each cluster, the first sequence is taken as a seed and its suffix is compared with those of the other sequences that fall in the selected cluster. sequences that are identical or very similar to the seed are classified as duplicates. duplicates are condensed in a new sequence and are removed from the cluster . then, the process is iterated for the remaining sequences in the cluster , until the cluster is empty or contains only one read sequence.
fig.  <dig> clustering. reads with an identical prefix of k nucleotides are considered potential duplicate reads. image from  <cit>  used under the terms of the creative commons attribution license 


fig.  <dig> comparison. the first read of each cluster is taken as a seed and its suffix is compared with that of the other sequences in the cluster. sequences that differ from the seed for a number of mismatches lower than a user-defined threshold are considered duplicates of the seed. each set of duplicates is removed from the cluster and are represented with a consensus sequence. the process is iterated until the cluster is empty. image from  <cit>  used under the terms of the creative commons attribution license 




clustering is performed by sorting the prefixes of the read sequences with our gpu-based cuda-quicksort  <cit> . as cuda-quicksort sorts numerical values, it is necessary to encode the prefixes of the read sequences. to this end, we devised the encoding with the aim to represent as many nucleotides as possible with a numeric value. in as doing, read sequence prefixes are subject to a dual numeric encoding. initially, prefixes are represented with a base- <dig> encoding by replacing each nucleotide with a numerical value ranging from  <dig> to  <dig> . representing items with  <dig> bit unsigned long long int data type allows to encode and sort prefixes of up to  <dig> nucleotides. a longer prefix would exceed the limit for this type of data. it is possible to overcome this constraint using a different numerical base for representing prefixes. in particular, converting to base- <dig> the prefixes encoded using a base- <dig> encoding, it is possible to represent a number consisting of up  <dig> digits with a  <dig> bit unsigned long long int .
fig.  <dig> enconding. prefixes are subjected to a dual encoding. initially, the nucleotides in a prefix are encoded with a numerical value from  <dig> to  <dig> . then, these numerical representations are encoded using base- <dig>  finally, sorting is performed for clustering. in the figure, prefixes of length k= <dig> are represented. image from  <cit>  used under the terms of the creative commons attribution license 




for the sake of completeness, it should be pointed out that regarding the problem addressed in this work, quick-sort is more effective than other sorting algorithms, including radix-sort. with k number of digits in a key and n number of keys, the computational complexity of comparison-based radix-sort is o, whereas the complexity of quick-sort is o). hence, quick-sort outperforms radix-sort in the event that k>l
o
g, and viceversa. the performance of cuda-quicksort has been compared with thrust radix sort  <cit> , a cutting-edge algorithm running on gpus. the comparative assessment has been made in the task of sorting items with long keys -characterized by  <dig> digits . experiments, performed ensuring a uniform distribution on benchmark datasets , show that cuda-quicksort outperforms thrust radix sort with a speed-up ranging from  <dig> x to  <dig> x, depending on the dataset at hand  <cit> .

despite the fact that longer sequences  can be processed, the latter encoding is still restrictive. as the quality of illumina reads decreases with the position that a base has in the sequence being processed, more likely sequencing errors are localized towards the 3’ end of a read rather than in proximity of to the 5’ end. in gpu-dupremoval, two sequences are classified as nearly identical if they fulfill a given constraint on the maximum number of allowed mismatches. in doing so, a mismatch is always considered a sequencing error, irrespective of the position  that a base has in a read. this processing policy gives rise to a fraction of natural nearly-identical sequences that may be erroneously classified as artificial duplicates. an approach to reduce the number of false positives in the process of duplicate identification is to limit the analysis of mismatches where is more likely sequencing errors are localized, choosing the prefix length according to the resulting quality scores obtained across all bases on the dataset. this length must be chosen to permit the selection of all bases whose average quality score is higher than a given threshold.

after that reads have been clustered, their suffixes are compared. basically, a base-per-base comparison of the nucleotides of the suffix of the seed with those of the other reads in a cluster should be performed in this phase. this approach might require a very high number of comparisons. let n be the length of the suffixes, and let m be the minimum number of mismatches allowed to consider two sequences as not duplicated. in the best case, two sequences can be classified as not duplicated after m comparisons. in the worst case n comparisons must be performed. we implemented a different strategy aimed at reducing the number of comparisons. initially, suffixes are split into fixed-length chunks. each subsequence representative of a chunk is subjected to the same dual numeric encoding used to represent the prefixes for clustering. then, for each cluster, the numerical difference between the i-th chunk of the seed and the related chunk of the other suffixes in a cluster is calculated . the order of magnitude of this difference provides information about the position of the leftmost different nucleotides. then, subsequences are cut at the mismatch position. the rightmost parts of the mismatch position are maintained and the process is re-iterated. in the worst case, this approach is able to classify two sequences as not duplicated after m comparisons.
fig.  <dig> suffixes. suffixes  are analyzed in chunks. each chunk is subject to the dual encoding used for prefixes . the overall number of mismatches if obtained summing the partial number of mismatches obtained for each chunk. image from  <cit>  used under the terms of the creative commons attribution license 




suffix comparison has been massively parallelized on gpu. in particular, the chunks representatives of the reads in a cluster are loaded into the gpu memory and compared in parallel with the chunk of the seed. it should be noted that also the size of the clusters affects the overall computing time. in fact, depending on both the size of a cluster and the percentage of duplicates in it, a very high number of comparisons among sequences could be performed. in our method, very large clusters are split into smaller ones of fixed size with the aim of reducing the number of comparisons. in a similar manner, in fulcrum, potential duplicates are binned in file of user-defined maximum size. on one hand this heuristic guarantees a reasonable computing time. however, on the other hand, it may affect the accuracy of the analysis. therefore, in our view, resorting to this heuristic appears not appropriate. in the following, we describe the changes implemented in gpu-dupremoval to cope with the constraints on the prefix length and the maximum size of a cluster, and to support paired-end reads.

prefix length
the proposed clustering strategy resulted be very effective. its computing time depends on the size of the dataset, whereas it does not depend on the prefixes length. moreover, cuda-quicksort is able to cluster datasets of millions of reads very quickly. it should be pointed out that cuda-quicksort resulted be the faster implementation of the sorting algorithm on gpus. in particular, it was up to  <dig> times faster than the cdp-quicksort released by nvidia.

starting from these considerations, we devised a multi-step clustering strategy based on the existing one. for prefix length of up to  <dig> nucleotides clustering does not differ from the previous version of the tool. the approach differs when longer prefixes must be analyzed. initially, prefixes are split into chunks of  <dig> nucleotides. obviously, depending on the length of the prefixes, the last chunk might be shorter than  <dig> nucleotides. each prefix is subjected to the dual numerical encoding previously described. then, cuda-quicksort is used to sort reads according to two different criteria. the first sorting  is obtained according to the first chunk of prefixes. it represents the partial sorting of the reads that will be iteratively updated to build the final sorting. the second sorting  is obtained according to the second chunk of the prefixes. this sorting is used to update the first one in such a way that it becomes a sorting representative of both chunks. basically, b is used to update the ordering of the reads in the clusters generated according to a. to this end, an array is initialized to store the new sorting . the array will be partitioned taking into account the clusters generated with a. then, according to b, the reads of each cluster are copied in the new array. each read is copied in the first free position of the partition related to its belonging cluster generated with a . after that all reads in a cluster generated with b have been copied into the new array, both the number of clusters and their size is updated. a cluster is split into two clusters each time that its related partition in the new array is only partially written. at the end of the process, a is replaced by c. then, the process is re-iterated with the following chunks .
fig.  <dig> multi-step clustering. to simplify the graphical representation, we assume that the multi-step clustering is enabled for prefixes longer than  <dig> nucleotides. in this example  <dig> reads are clustered analyzing prefixes of  <dig> nucleotides. a initially, the prefixes are split into two chunks of  <dig> nucleotides. in the figure, the nucleotides of the first chunk are represented in blue, and those of the second chunk are represented in red. the clustering consists of three steps. b reads are clustered by sorting them according to the first chunk of the prefixes . clustering generates  <dig> clusters of different size . reads clustered together are represented with the same background color. subsequently, reads are clustered by sorting them according to the second chunk of the prefixes . this clustering generates  <dig> clusters unrelated from those of the previous clustering . c a new array is initialized and partitioned according to the size of the clusters of a. the sequences of each cluster in b are copied in the new array in the partition associated to their belonging cluster in a. each read is copied into the first free position of the partition. the process is represented in the c box. each row reported therein represents the process of copying the reads of a cluster in c. on the left it is shown where the reads are copied, whereas on the right it is shown how clusters are split after each iteration. initially, the reads r
 <dig> and r
 <dig> of c
b <dig> are copied in the new array. r
 <dig> belongs to c
a <dig> in a and r
 <dig> belongs to c
a <dig> in a. being the first reads to be analyzed, they are copied in the first position related to its cluster in a. cluster c
a <dig> and c
a <dig> are partially filled after this step. this implies that the reads in these clusters are not identical, according to the second chunk of their prefix. in fact, r
 <dig> and r
 <dig> have not been clustered together with r
 <dig> in b. similarly, r
 <dig> has not been clustered together with r
 <dig> in b. therefore, the clusters are split . cluster c
a <dig> is split into two clusters. a cluster contains r
 <dig> and the other cluster  is empty. similarly, c
a <dig> is split into two clusters of size  <dig>  the process is iterated  until all clusters in b have been analyzed. the final sorting generates  <dig> clusters




it might seem that the described algorithm implements a radix sort. however, there are considerably differences between the two algorithms. radix-sort is a non-comparative sorting algorithm that performs a digit-by-digit sorting on keys. in the proposed multi-step clustering strategy, gpu-dupremoval uses cuda-quicksort to perform  a comparison-based sorting of numbers , representative of sub-sequences of the available reads. furthermore, let us recall that two variants of the radix-sort  exist, able to process keys from the less to the most significant digit  and from the most to the less significant digit . the apparent resemblance of multi-step clustering algorithm with radix-sort in fact applies more to lsd/rs than to msd/rs. however, only msd/rs could be used to address the problem at hand as, unlike lsd/rs, msd/rs dispatches all digits with identical value into a specific bucket and recursively repeats the same operation with all buckets, until sorting is complete. notably, keys that occur in a bucket are sorted independently from those in other buckets. conversely, in the proposed approach, sorting is performed by analyzing all sequences at each step.

this multi-step clustering strategy has been used to optimize also the removal of identical duplicate reads. in the first implementation the same approach was used to remove identical and nearly-identical reads. however, identical reads can be removed more easily than nearly-identical ones. in particular, identical reads can be identified by clustering the reads by their entire sequences. in gpu-dupremoval identical duplicates are automatically removed by clustering reads according to their entire sequences. it should be pointed-out that the multi-step clustering is not used to remove identical duplicates when gpu-dupremoval is run to remove both identical and nearly-identical read sequences. it is solely used when gpu-dupremoval is used to remove identical reads.

maximum size of a cluster
as previously described, in the first implementation of our method large clusters are automatically split into smaller. on one hand, analyzing small clusters may improve the performance in terms of computing time; on the other hand, it may worsen the performance in terms of accuracy. the smaller the cluster is, the faster the processing is, as fewer comparisons are required. unfortunately, duplicates separated during the splitting will be not identified.

the problem has been addressed in gpu-dupremoval, which is able to analyze large clusters without the need for splitting them. originally, only a level of parallelism was implemented. at each iteration, the first read in each cluster  is compared with the other reads in the cluster. depending on both the size of a cluster and on the percentage of duplicates, this approach may require many iterations. let n be the size of the cluster, when each read is uniquely represented in the cluster , n- <dig> iterations must be performed. this computational challenge can be efficiently addressed by adding a second level of parallelism aimed at comparing multiple seeds of a cluster in a single iteration. in the current implementation, at each iteration the possibility to compare in parallel multiple seeds of a cluster is assessed. it should be pointed out that depending on the size of the dataset at hand, an iteration might require one or more kernel launches. notably, gpu-dupremoval applies different strategies, depending on the number of kernel launches required to analyze the dataset. initially, gpu-dupremoval determines the thread block size, the number of thread blocks and the gpu memory required to analyze the given dataset and to compare the read chunks that occur in each cluster with a single seed. as long as more than one kernel launch is required in an iteration, gpu-dupremoval compares reads that occur in a cluster with a single seed. conversely, when a single kernel launch is made in an iteration, gpu-dupremoval checks the feasibility of comparing multiple seeds in parallel. the upper limit of seeds that can be compared in parallel for each cluster  is determined according to the constraints on the maximum number of blocks that can be created per kernel launch and on the memory of the device. at each iteration, up to n seeds are compared in parallel for each cluster. the upper limit for the seeds that can be compared in parallel will increase with a decrease of the read sequences to be analyzed. as the number of reads decreases at each iteration, the value of n is re-calculated after each kernel launch. in so doing, when multiple seeds are analyzed in parallel, a read is compared with two or more seeds in the same iteration, and, depending on the results of comparisons, it may be classified as duplicated of two or more seeds. in these cases, the read will be considered as duplicated of the first seed.

supporting paired-end reads
gpu-dupremoval has been devised to support both single- and paired-end reads. it should be noted that duplicates from paired-end reads can be removed similarly to that concerning single-end reads. in fact, paired-end reads with an identical prefix at both ends can be considered as potential duplicates. hence, potential duplicates can be identified by clustering reads according to the prefixes that occur at both ends. to this end, gpu-dupremoval builds a new sequence representative of both reads for each pair in the dataset. each sequence is build by merging separately prefixes and suffixes, as shown in fig.  <dig>  subsequently, these sequences are analyzed according to the same method used for single-end reads. finally, after that duplicates have been removed, sequences are demerged . it should be pointed out, that this strategy to support paired-end reads is well suited to the current implementation of the algorithm that gives a viable solution to the issue concerning the maximum length of prefixes. the limitation on the length of the prefixes of the previous implementation would negatively affect the capability of removing duplicates from paired-end reads.
fig.  <dig> merging paired-end reads. paired-end reads with identical prefix at both ends can be considered potential duplicates. the same clustering strategy used to identify potential duplicates in single-end reads can also be used for paired-end reads. in this case, paired-end reads need to be merged as represented in the figure. a sequence representative of a pair is obtained by merging the prefixes and the suffixes of both forward and reverse read. with n the length of the read sequence and p length of the prefixes, the new sequence consists of 2·n nucleotides and is represented by a prefix of 2·p nucleotides


fig.  <dig> de-merging paired-end reads. after that duplicates have been removed, sequences are demerged to generate both forward and reverse reads




RESULTS
experiments have been designed to assess the performances of gpu-dupremoval to remove identical and nearly-identical duplicates from single- and paired-end read libraries, with both synthetic and real life data. in this section, we first introduce experiments on synthetic data, which are mainly aimed at assessing the reliability of gpu-dupremoval. experimental results obtained on real data are reported afterwards.


performance evaluation on synthetic data


synthetic libraries have been generated with the sherman simulator  <cit> . it should be pointed out in advance that sherman does not permit to set the percentage of duplicates in a library. initially, we used sherman to generate a library consisting of  <dig> thousands of  <dig> bp single-end reads. subsequently, synthetic reads have been processed to generate  <dig> thousands of  <dig> bp duplicate reads. duplicates consist of identical duplicates , duplicates generated by simulating a  <dig> % of sequencing error , and duplicates generated by simulating a sequencing error ranging between  <dig> and  <dig> % . similarly, we generated a library consisting of  <dig> millions of  <dig> bp paired-end reads. in this case, the sequencing error has been uniformly simulated on both ends. as for both single- and paired-end reads, duplicates have been generated by simulating sequencing errors using an error rate curve that follows an exponential decay model, with the aim of mimicking real data.

as for the single-end library, gpu-dupremoval has been compared with fastx-toolkit collapser, cd-hit-dup, and fulcrum. experiments have been defined to assess the reliability of the tool to identify and remove duplicates according to the sequencing errors injected therein. results reported in table  <dig> show the percentage of reads removed from each tool when used to identify duplicates according to a sequencing error ranging from  <dig> to  <dig> %. apart from cd-hit-dup, the other tools work properly and have been able to identify all duplicates. similar behavior has been observed for paired-end reads . in this case, gpu-dupremoval has been compared with fastuniq, cd-hit-dup, and fulcrum. it should be pointed out that both fastx toolkit collapser and fastuniq does not support removal of nearly-identical reads.
clustering for gpu-dupremoval and fulcrum has been performed analyzing prefixes of  <dig> bases when used to remove nearly-identical duplicates. as for identical duplicates clustering has been performed on the entire length of the reads for both tools. it should be pointed out that gpu-dupremoval automatically clusters the reads according to their length when used to remove identical duplicates. tool settings: i) gpu-dupremoval -g  <dig> -d  <dig>  and -g  <dig> -p  <dig> -d <nb_of_mismatches > ; ii) cd-hit-dup -u  <dig> -c <nb_of_mismatches >; iii) fulcrum -b <prefix_length > -s -t s  and -q  <dig> -s -t s -c <nb_mismatches >. <nb_of_mismatches >: the allowed number of mismatches. it has been set to  <dig>   <dig>   <dig>   <dig> for the different experiments. <prefix_length > was set to  <dig> for identical duplicates and to  <dig> for nearly-identical duplicates. fastx-toolkit collapser does not require any parameter apart those aimed at specifying the input and the output files


tool settings: i) gpu-dupremoval -g  <dig> -d  <dig>  and -g  <dig> -p  <dig> -d <nb_of_mismatches > ; ii) cd-hit-dup -u  <dig> -c <nb_of_mismatches >; iii) fulcrum -b <prefix_length > -s -t p  and -q  <dig> -s -t p -c <nb_mismatches >. as for fulcrum, <prefix_length > was set to  <dig> for identical duplicates and to  <dig> for nearly-identical duplicates. fastuniq does not require specific parameters apart from those aimed at specifying input and output files





performance evaluation on real data


to assess the performance of gpu-dupremoval on real data, we used it to remove duplicates of two libraries generated with the illumina platform; i.e., library srr <dig> consisting of  <dig> millions of  <dig> bp single-end reads, and library srr <dig> consisting of  <dig> millions of  <dig> bp paired-end reads. experiments have been carried-out to identify and remove identical and nearly-identical duplicates with up to  <dig> and  <dig> mismatches.

experiments described hereinafter have been carried out on a  <dig> cores intel xeon cpu e5- <dig>  <dig>  ghz with  <dig> gb of ram. an nvidia  tesla k20c card with  <dig>  ghz clock rate and equipped with  <dig>  gb of global memory has been used to execute gpu-dupremoval.

experiments have been designed with the goal of providing a rigorous comparison among the tools. in this context, it should be pointed out that fulcrum considers as any those bases with a quality score under a user defined-threshold. being not supported by the other tools, this option has been disabled as it can affect the percentage of duplicates removed. moreover, differently from the other tools, fulcrum parallelizes the computation on multiple cpu cores. therefore, to provide a rigorous comparison in terms of computing time with gpu-dupremoval, fulcrum has been run parallelized on all available cpu cores.

identical parameters have been used to perform the clustering in both gpu-dupremoval and fulcrum. clustering has been performed according to different lengths of the prefixes with the aim to show how this parameter affects the removal of duplicates. as for nearly-identical duplicates, clustering has been performed by analyzing prefixes of 25/35/45/ <dig> bases for srr <dig> and prefixes of 10/ <dig> bases for srr <dig>  as for identical duplicates, gpu-dupremoval automatically clusters the reads by their entire nucleotide sequences. the same constraint has been used in fulcrum to remove identical duplicates.
table  <dig> performance comparison on the srr <dig> library among gpu-dupremoval, fastx toolkit collapser, cd-hit-dup, and fulcrum

gpu-dupremoval 1
gpu-dupremoval 2
as for gpu-dupremoval the table reports the results for both the current  and the first implementation  of the algorithm. the library consists of  <dig> . <dig> of  <dig> bp single-end reads generated with illumina platform. the first column reports the name of the tool. the second column reports the prefix length used for clustering the reads for gpu-dupremoval and fulcrum. the third column reports the constraint on the allowed number of mismatches. the fourth column reports the percentage of reads that have been removed. the fifth and sixth column report the computing time and the peak of memory required to perform the experiment. tool settings: i) gpu-dupremoval 1
-g  <dig> -d  <dig>  and -g  <dig> -p <prefix_length > -d <nb_mismatches > ; ii) gpu-dupremoval 2
-g  <dig> -p  <dig> -d <nb_mismatches >; iii) cd-hit-dup -u  <dig> -c <nb_of_mismatches >; iv) fulcrum -b <prefix_length > -s -t s  and -q  <dig> -n  <dig> -s -t s -c <nb_mismatches >. <prefix_length > was set to  <dig> for identical duplicates and to 25/35/45/ <dig> for nearly-identical duplicates. no parameter is required for fastx toolkit collapser




we deem that this slight discrepancy on the percentage of sequences removed by gpu-dupremoval and fulcrum depends on the different strategies implemented to compare the reads in a cluster. in fulcrum, initially, a list of groups of strongly similar reads is initialized using the first read of each cluster . subsequently, each read in a cluster is compared to r and if considered similar to r it is added to the group and a new consensus sequence r is calculated and used for the following comparison. unlike, gpu-dupremoval does not compare the reads in a cluster with a consensus sequences. in gpu-dupremoval duplicates are detected by comparing each read in a cluster to all other sequences in the cluster.

results show how the prefix length used for clustering can affect the percentage of removed reads. analysis of results show that the percentage of sequences classified as duplicates decreases with increasing the prefix length. for instance, with a prefix of  <dig> bases the percentage of nearly-identical sequences with up to 1/ <dig> mismatches removed by gpu-dupremoval decreased of  <dig> / <dig>  % with respect to the percentage obtained using a prefix of  <dig> bases. similar results have been obtained by fulcrum.

performance in terms of computing time shows that gpu-dupremoval is the fastest tool. it resulted to be  <dig> x faster than fastx toolkit collapser in removing identical duplicates, whereas it resulted to be up to  <dig> x/ <dig> x/ <dig> x faster than cd-hit-dup and up to  <dig> x/ <dig> x/ <dig> x faster than fulcrum to remove duplicates with up to 0/1/ <dig> mismatches.

as for memory consumption, fulcrum outperforms the other tools, the worst being cd-hit-dup, which requires a notable high amount of memory. experiments show that the memory required increases with the allowed number of mismatches. in particular, cd-hit-dup required  <dig>  gb of memory to remove identical duplicates and  <dig> / <dig>  gb of memory to remove duplicates with up to 1/ <dig> mismatches. as for gpu-dupremoval, the amount of memory required depends on both the size of the dataset and the type of duplicates removed, whereas it is unrelated from the number of differences allowed among duplicates. to perform the experiments, gpu-dupremoval required  <dig>  gb to remove identical duplicates and  <dig> / <dig> / <dig> / <dig>  gb to remove nearly-identical sequences clustering the reads with a prefix length of 25/35/45/ <dig> bases.

experiments have also been performed to compare the performance of the current implementation of gpu-dupremoval with that obtained with the previous release. experiments with the first release of the algorithm has been performed clustering the reads with a prefix length of  <dig> bases. as for identical duplicates, both releases of the tool have been able to remove the same percentage of identical duplicates. however, due to the multi-clustering strategy the current release of the tool resulted to be  <dig> x faster than the previous implementation. as for nearly-identical reads both versions of the tool exhibit comparable performance in terms of computing time and memory consumption. however, the current version of the tool, which is able to analyze large clusters without heuristics, has been able to remove a slightly higher percentage of duplicates.

similar results are reported in table  <dig> for srr <dig> library. as for identical duplicates, all tools removed the same amount of reads . gpu-dupremoval and fulcrum show almost identical results. gpu-dupremoval removed  <dig> / <dig>  % of duplicates with up to  <dig> mismatch clustering the reads with a prefix length of 10/ <dig> bp, whereas fulcrum removed always  <dig>  % of duplicates. as for nearly-identical duplicates with up to  <dig> mismatches gpu-dupremoval removed  <dig> / <dig>  % of duplicates clustering the reads with a prefix length of 10/ <dig> bases, whereas fulcrum removed  <dig> / <dig>  % of duplicates. as for cd-hit-dup, it removed  <dig> / <dig>  % of duplicates with up to 1/ <dig> mismatches.
the first column reports the name of the tool. the second column reports the prefix length used for clustering the reads for gpu-dupremoval and fulcrum. the third column reports the constraint on the allowed number of mismatches. the fourth column reports the percentage of reads that have been removed. the fifth and sixth column report the computing time and the peak of memory required to perform the experiment. tool settings: i) gpu-dupremoval -g  <dig> -d  <dig>  and -g  <dig> -p <prefix_length > -d <nb_of_mismatches > ; ii) cd-hit-dup -u  <dig> -c <nb_of_mismatches >; iii) fulcrum -b <prefix_length > -s -t p  and -q  <dig> -n  <dig> -s -t p -c <nb_mismatches >. <prefix_length > was set to  <dig> for identical duplicates and to 10/ <dig> for nearly-identical duplicates




as for computing time, the performance of gpu-dupremoval to remove identical reads are similar with those obtained by cd-hit-dup and fastuniq, whereas it resulted to be  <dig> x faster than fulcrum. as for nearly-identical duplicates gpu-dupremoval resulted be up to  <dig> x/ <dig> x faster than cd-hit-dup, and up to  <dig> x/ <dig> x faster than fulcrum to remove duplicates with up to 1/ <dig> mismatches.

as for memory consumption, a behavior similar to the one observed on the srr <dig> library has been observed. in particular, fulcrum outperforms all remaining tools, requiring in the worst case  <dig>  gb of memory, whereas cd-hit-dup required  <dig> / <dig> / <dig>  gb of memory to remove duplicates with up to 0/1/ <dig> mismatches. as for gpu-dupremoval, it required  <dig>  gb of memory to remove identical duplicates, and  <dig> / <dig>  gb to remove nearly-identical ones by clustering the reads with a prefix of 10/ <dig> bases.

CONCLUSIONS
in this work we presented gpu-dupremoval, a tool aimed at removing identical and nearly-identical duplicates from sequencing libraries generated with illumina platforms. gpu-dupremoval implements an alignment-free strategy and exploits the computational power of modern gpus to remove duplicates from both single- and paired-end libraries.

experimental results show that gpu-dupremoval is very effective at removing duplicate reads, as it outperforms almost all analyzed tools. in terms of ability to identify and remove duplicates, its performance are comparable with that of fulcrum. however, it resulted to be very faster than fulcrum, especially at removing duplicates from paired-end reads.

the current implementation of gpu-dupremoval overcomes almost all limitations highlighted with respect to its first implementation. currently, the constraint on maximum size of the sequencing library still holds. as highlighted in the previous work, sorting requires all prefixes to be loaded into the memory of the gpu device. therefore, the maximum size of the library that can be analyzed depends on the memory of the gpu card used.

availability and requirements

project name: gpu-dupremoval project home page:
http://www.itb.cnr.it/web/bioinformatics/gpu-dupremoval
operating system: linuxprogramming language: cuda cother requirements: nvidia gpu card with compute capability ≥  <dig> license: free for academic useany restrictions to use by non-academics: license needed

abbreviations
cudacompute unified device architecture

gpugraphics processing units

ngsnext generation sequencing

