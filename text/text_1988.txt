BACKGROUND
a wide range of rna molecules can form specific secondary structures by folding their primary sequences. rna secondary structures play important roles in cellular processes, such as regulating gene expressions and producing non-coding transcriptional products  <cit> . the secondary structures of many non-coding rnas , like the cloverleaf structure of trna and the hairpin structure of microrna precursor , have been evolutionarily conserved instead of the primary sequences  <cit> .

in recent years, several computational methods have been reported to find these conserved secondary structures, as well as common local structural motifs in pair-wise or multiple sequences. the programs qrna  <cit> , ddbrna  <cit>  and msari  <cit>  were developed, one after another, to detect functional ncrnas with conserved structures. washietl et al. implemented program rnaz  <cit> , which led to a mapping of thousands of conserved structural and functional rna in the human genome  <cit> . in addition, the local structures or structural motifs of rna molecules were even more important in rna function study. macke et al. defined specific types of rna motif and developed rnamotif to search the structural elements  <cit> . the program erpin was based on the secondary structure profile and used the rna sequence alignment with secondary structure information for motif definition and identification  <cit> . hoechsmann et al. utilized tree alignment and forest alignment to implement local similarity comparison in rna secondary structures  <cit> . the vienna rna package was probably a comprehensive rna secondary structure prediction and comparison tool  <cit> , and rnalfold was designed to predict locally stable rna structures in single genome  <cit> . havgaard and co-workers focused on detecting the common local structures between two rna sequences with low sequence similarity  <cit> . a similar procedure rnaprofile was used for detecting conserved structural motifs in unaligned rna sequences  <cit> . recently, liu et al. reported rsmatch for aligning rna secondary structures and motif detection  <cit> , which used a tree model to organize the structure components. for a comprehensive comparison, freyhult et al. assessed the effectiveness of  <dig> methods that can perform rna homology search. the result showed that most of them have low accuracy  <cit> .

we now face a challenging task: given a rna sequence with secondary structure, how to find structural homologs in a large genome database effectively. to deal with this task, klein and eddy developed a pair-wise alignment algorithm rsearch  <cit>  based on the profile stochastic context-free grammar. rsearch used the base pair and single nucleotide substitution matrix ribosum to find optimal structural alignments between a rna sequence and a sequence database. it succeeded in searching in archaeals, yeast and arabidopsis thaliana databases. however, the time complexity of the algorithm is o, where n is the length of the database sequence and m is the length of the query sequence. rsearch is very slow on a personal computer   <cit> . subsequently, weinberg and ruzzo used a rigorous filter to eliminate the sequences that provably could not be annotated as homologs of known ncrna gene family in the genome database  <cit> . then, they achieved a fast search when annotating the new members of known ncrnas in the genome. using a similar strategy, bafna and zhang invented fastr  <cit> , which was faster than rsearch by dividing the search into two steps. firstly, fastr filtered a large proportion of the database according to the analysis of the structural element and sequence information of the query rna, and then, the searching was run on the remaining of the database. the query time of fastr drastically decreased due to a smaller search database produced by the filtering process. however, since fastr must filter the database for each specific query, it was actually an invalid comparison without considering the large overhead required to perform the filtering step. moreover, fastr also lost sensitivity due to the filtering  <cit> .

in this paper we focus our attention on finding structural similarities for a structured query rna in a large database efficiently and quickly and propose an algorithm rscan to do the job. these conserved structural similarities are possible functional homologs of the query rna. rscan is developed upon the basis of ssaha  <cit>  and the smith-waterman  <cit>  algorithms. rscan carries out the search in two steps. firstly, it builds a hash table for a database. it then searches structural similarities with the hash table for a query in the database. since the hash table is generated only once for searching any query in a given database, this can drastically reduce the time required to perform a search. six ncrna datasets were used as a test-case to make a comparison between rscan and rsearch, and the results were encouraging. moreover, rscan and rsearch obtained a close identification rate when searching for a trna and an rrna query in a randomized genome. rscan took only  <dig> seconds  versus  <dig>  s with rsearch for trna. rrna yielded  <dig> s with rscan versus  <dig>  s with rsearch. the experiment of searching structural similarities for a pre-mirna in human chromosome  <dig> took less than  <dig> minutes. rscan makes a good searching tool when queried database is large.

RESULTS
pre-processing and definitions
we illustrate the preprocessing of a query and a database with a simple example. the query sequence is shown in part a of figure  <dig>  the secondary structure of the query sequence is predicted using rnafold  <cit> . in the predicted secondary structure, there are only two statuses for each nucleotide, paired or unpaired, indicated by the symbols "" , and "." . the symbol sequence composing of "" and "." is defined as the "structural query", shown in line  <dig> of figure 1a. the example database contains only three sequences, which are shown in part b of figure  <dig>  the secondary structures of the sequences are also predicted using rnafold  <cit> . the set of all symbol sequences of secondary structures is defined as the "structural database", which are shadow parts of figure 1b.

search algorithm of rscan
rscan directly searches optimal structural alignments between a structural query and a structural database. rscan is based on ssaha algorithm  <cit> , which utilizes the hashing algorithm to perform a fast search for large genome databases, and the smith-waterman algorithm  <cit> , which is a basic local alignment algorithm.

construct the hash table for a structural database
rscan breaks the symbol sequences in a structural database into consecutive k-tuples of k contiguous symbols and stores the positions of each occurrence of k-tuple using the hash table. figure  <dig> shows the hash table of the example structural database in the case of k =  <dig> 

search the structural query
each k-tuple occurring in the structural query has corresponding entries in the hash table. the example structural query in the case of k =  <dig> is shown in figure  <dig>  using the same strategy with ssaha, rscan sorts these entries to obtain contiguous matching symbols over a given threshold, which is called the "match-core". the smith-waterman algorithm is then used to obtain an optimal structural alignment between the structural query and the structural database along two sides of the match-core.

scoring function
rscan uses a binary match\unmatch score function to calculate the score of each alignment. the penalty values of the match, unmatch and the insertion\deletion gap  can be adjusted on demand. in this paper, penalty values are set as: match =  <dig>  unmatch = - <dig>  indel = - <dig> 

alignment output
rscan searches for the structural query within the structural database and reports significant structural alignments according to the user's requirements. figure  <dig> shows the results for the example. it should be emphasized that the query does not have sequence similarity with the sequences in the database, which is calculated using blastclust  <cit>  with parameters s =  <dig>  l =  <dig> , w =  <dig> 

the output reports three structural alignment hits. the first hit is an accurate alignment between the structural query and the structural s <dig>  which just contains two mismatches and two indels in whole alignment. hit  <dig> is also a good structural alignment though more indels occur and the lengths of the query  and the hit s <dig>  are different, shown in figure  <dig>  in hit  <dig>  rscan only finds a local structural alignment between the query and s <dig>  two parameters, "alignment_ratio" and "identity", should be introduced more carefully. using hit  <dig> as an example, the number of the aligned symbols of the query is  <dig> and the length of the query is  <dig>  so the parameter "alignment_ratio" is 100% . and there are  <dig> matches in the aligned symbols of the query, so "identity" is  <dig> % . users can set the thresholds for "alignment_ratio" and "identity", and rscan only reports the alignments which are greater than the thresholds. in following experiments, we set thresholds for finding significant global alignments.

the rscan procedure is shown in figure  <dig>  the difference between ssaha and rscan is that ssaha processes the genomic sequence itself, whereas rscan processes the symbol sequence.

comparisons between rscan and three other methods: blast, rsearch and rsmatch
several sets of data were used to evaluate the performance of rscan. the datasets were six ncrna families, one trna, two rrna and three rnase p families, from rfam  <cit> , whose member sequences were filtered using proper steps, for example, eliminating the sequences with high sequence similarity . for each filtered dataset, one member was used as the query and the other members were treated to build the database. rscan and rsearch performed the searches on these datasets and compared the accuracy and the speed.

first of all, it should be emphasized that blast can not find sequence homologies between the query and the sequences in the datasets because of the filtering step . by comparison, rscan and rsearch recognized numerous significant structural similarities for the query. this indicates rscan is more sensitive than blast for structural alignment.

for each dataset, in table  <dig>  rscan found the most of true structural similarities for a structural query. on rf <dig>  the identification rate was 100% and on other families, the identification rates were from 58% to 83%. rsearch achieved better identification rates than rscan on these datasets. it recognized all true similarities on four families and achieved the identify rates of 85% on rf <dig> and 82% on rf <dig>  respectively. however, rscan could detect more alignments when tuning the parameters. rscan found  <dig> trna hits and the identification rate is 74% for the query under "identity ≥ 90% and alignment_ratio ≥ 95%". when the parameters were set as "identity ≥ 85% and alignment_ratio ≥ 90%", rscan found  <dig> true trna similarities, and the identification rate rose to 85%. moreover, on rf <dig> dataset, rscan recognized  <dig> hits when the parameter k set as "k = 7". if "k = 5", rscan detected all twenty-four true similarities. properly tuning thresholds for rscan parameters was depending on the demands. our experiments sought for highly significant structural similarity for the query, so the thresholds were strict. all detailed parameters of each test were provided in the supplementary materials.

 <dig> the size of database is the total nucleotides of each database. nt: nucleotides.

 <dig> tp: true positive; fn: false negative.

 <dig> h/m/s: hour/minute/second.

the last column of table  <dig> listed the computing times of rscan and rsearch on six datasets. rscan was remarkably faster than rsearch. rscan only took  <dig> seconds  and  <dig> s for searching a structural query in the structural rf <dig> and rf <dig> databases, respectively. in contrast, rsearch ran  <dig> s and  <dig>  s for the same structural searches. on the three ribozyme families, rsearch needed 6~ <dig> hours to finish the searches, but rscan took only  <dig> seconds to  <dig> minutes to do so. for searching rf <dig> dataset, the most time consuming case, rsearch ran more than  <dig> hours, whereas rscan ran less than  <dig> minutes. in this case, the identification rate 82% of rsearch was  <dig>  times higher than that of rscan, but the computing time of rsearch was  <dig> times than that of rscan.

the time complexity of rsearch is o, where n is the length of the database sequence and m is the length of the query sequence  <cit> . it will be very slow when m or n is large. comparatively, rscan transfers the complicated similarity search problem of rna secondary structure into a sequence alignment problem between a structural query and a structural database. so, the time complexity of rscan is o, which is identical to the sequence alignment algorithms.

we also tested another rna-specific search method, rsmatch  <cit> . it only found  <dig> accurate trna alignments on trna dataset and missed all hits on other five datasets .

finally, in the experiments rscan showed higher sensitivity than blast and rsmatch. although rscan may loss some sensitivity compared with rsearch, it is greatly faster than rsearch. actually, some real-life tasks do not need to retrieve all hits for a query. for example, an unknown query is asked if it belongs to a known ncrna families. we can run a structural similarity search on the entire rfam database. rscan will give a quick answer with sufficient sensitivity.

however, it should be noted that only those examples, whose predicted structures were satisfied the filtering criteria , were used in the tests shown in table  <dig>  for example, when the dataset was constructed, part of trnas without typical cloverleaf structure were filtered. rscan was unable to accurately search a trna with two stem-loops in the database composed of trnas with three stem-loops. we therefore needed to study the impact of the accuracy of structure prediction.

for instants, there were totally  <dig> records of trna family in rfam seed data. according to the loop number  of each trna's predicted secondary structure, these trnas were classified as four groups. for each group, we used one trna as the query and other trnas to build database. rscan performed structural aligning on each group. there were  <dig>  trnas that were predicted as the cloverleaf structures. rscan achieved 66% accuracy on the group with  <dig> loops. but the corresponding accuracy on entire trna family was only  <dig> % . this showed that rscan was greatly limited by the accuracy of structure prediction. we will have more discussion about it later. for a real-life searching task, there are two determinants: one is the accuracy of structure prediction and the other is the performance of rscan. in this paper, we are only able to deal with the latter.

comparison between rscan and rsearch on a randomized genome
a randomized genome was created through shuffling a whole a. pernix genome while preserving di-nucleotide frequency. trnas or rrnas were then inserted in the randomized genome. rscan and rsearch searched the trna or rrna query in the randomized genome to evaluate the false positive and the false negative.

when searching trnas, rsearch found  <dig> hits, including  <dig> true trnas and  <dig> false hits, shown in table  <dig>  rscan detected  <dig> hits; among them  <dig> were true positive. when searching rrnas,  <dig> of  <dig> hits detected by rsearch were true rrnas, whereas  <dig> of  <dig> hits recognized by rscan were true. in the aspect of the computing time, rsearch ran  <dig>  s and  <dig>  s for searching the trna and the rrna in the randomized genome on a pc. in comparison, rscan only took  <dig> s and  <dig> s for searching the structural trna in the  <dig> nt structural database and the structural rrna in the  <dig> nt structural database, respectively. these illustrate that rscan achieves similar sensitivity as rsearch does, but only takes a fraction, less than ten percent, of the computation time of rsearch for the randomized genome search.

 <dig> the trna sequences and rrna sequences are inserted in the randomized genomes.

 <dig> tp: true positive; fn: false negative; fp: false positive.

 <dig> thash: the time required by building the hash table; tsearch: the time required by searching.

the time used by rscan is composed of two parts: the time spent in building the hash table  and in searching , like ssaha  <cit> . thash is inconsequential since the hash table is generated only once for a given database. the last two columns of table  <dig> list thash and tsearch in this experiment. it should be noted that rsearch searches the sequence database directly, but rscan searches a processed structural database, and this pre-processing step takes additional time. the times for generating the  <dig> nt and  <dig> nt structural database were  <dig> s and  <dig> s, respectively. fortunately, the pre-processing to generate the structural database takes only once.

there another algorithm fastr, which is similar to rscan, comprises of two steps  <cit> . fastr performs the search on a filtered database, which is only a small proportion of a given genome. however, the search time is genome specific and depends on the efficiency of the filtering step in each query. since fastr must filter the genome every time for each specific query, the search time should include the time spent on the filter step, which is in the range of hundreds of seconds for filtering the a. pernix genome  <cit> . by comparison, the computation time of rscan consists of thash and tsearch. thash is related to the database and is taken only once. once the hash table is generated, it can be used for searching any query. tsearch is linear to the size of the database and the length of the query. so, rscan is a more efficient search strategy.

on the other hand, the experiments in table  <dig> also reveal the limitation of rscan's application on the genome. a window with pre-chosen width probably leads to great changes of trnas' or rrnas' predicted secondary structures. this is the main reason why rscan missed several trnas or rrnas. when applying to native a. pernix genome, rscan displayed a bad performance for finding trnas or rrnas. the reason is that it is difficult to give a proper window width for a genome. at the same time, it is impractical to build a huge structural database using windows with different widths. a promising solution is using rnalfold  <cit>  to find stable structures or significant local structural motifs in a genome, and then using rscan to align the queries.

performance analysis of rscan with different parameters
in rscan parameter k creates k contiguous symbols " and ".") and it affects the search speed. table  <dig> shows the results of searching rrna query in the randomized genome with different k. it can be seen that the tsearch is approximately an inverse function of the parameter k.

 <dig> this match-core is  <dig> times of k here and other match-cores are  <dig> times of corresponding k.

although a greater k reduces the search time, a large value k should not be selected solely upon this criterion. the combination of parameter k and parameter "match-core" determines the alignment, which directly affects the hit sensitivity. for example, in table  <dig>  when k is  <dig> and "match-core" is  <dig> times k, a candidate alignment is required to have at least  <dig> contiguous matching symbols; and then, this candidate is scored using the local alignment algorithm to obtain the final alignment. with k or match-core increasing, the candidates that satisfy the threshold of the match-core are decreasing. rscan found few alignments when the match-core is  <dig>  so, the parameters should be properly selected to balance between the speed and the alignment sensitivity.

in addition, the hash table can be generated in advance, and used for searching any query. this is important and efficient when the database is large. parameter k determines the storage size of the hash table. the storage contains two parts: hash keys and values. values are the positions of occurrences of k-tuples in the structural database and the keys point to these values. with k increases, the storage requirement of the hash table decreases. in table  <dig>  for the  <dig> nt structural database, when k was  <dig>   <dig> or  <dig>  the size of the hash table was  <dig>  mb,  <dig>  mb or  <dig>  mb, respectively.

1thash contains the times required by building the hash table and writing the hash table into the hard disk.

2tsearch contains the times required by reading the hash table generated in advance into the computer memory and searching.

it should be noted that the computation time in table  <dig>  the case that the hash table was generated in advance, and the computation time in table  <dig>  the case that the hash table was not generated in advance, are slightly different. tsearch in table  <dig> was slightly less than tsearch in table  <dig>  the reason is that the number of keys in the hash table was reduced; there is a compression step in the former case that rids of the keys that refers to null values. searches are carried out on all keys loaded in memory for the latter case, which implies a time waste on key comparisons during hash lookup for invalid entries. and the additional time spent on reading the hash table pre-built into memory is neglectable.

realization of a fast search on human chromosome
our original motivation for developing rscan is to realize a fast similarity search for the structured rnas in a large genome using a pc. the difficulties arise from the limitations of the storage and speed of pc. here, four pre-mirnas and human chromosome  <dig> were used as an example to show how to apply rscan to search a large genome database. the hash table of the structural database of chr <dig> genome sequence that was divided by a  <dig> nt slide window was generated in advance and k was set to be  <dig> or  <dig> while the match-core was  <dig> times of k. rscan took less than  <dig> minutes on a pc for searching each pre-mirna in chr <dig>  shown in table  <dig>  in all cases, rscan quickly found the query mirna-self and its structural similarities, which can be further evaluate if they are mirna candidates based on the characteristics of the mirna. but these structural similarities did not contain other known mirnas. if we set more loose parameters, k was  <dig> and the match core was  <dig> times of k, the query "hsa-mir-155" would align all other three mirnas. of course, this would spend more time and find thousands of structural similarities.

 <dig> known: number of the known mirnas matched by hits.

in addition, we used the member of the let- <dig> family, "has-let-7a-2", which is located in human chromosome  <dig> and has 88% sequence similarity with the "has-let-7c" located in chr <dig>  as a query to search its structural similarities in chr <dig>  parameters k was set to  <dig> and the match core was  <dig> times of k, rscan found seven similarities, including his homology mirna "has-let-7c", and spent about a thousand seconds.

in real-life applications, an additional step could be considered for reducing the storage of large genome. we may use rnalfold  <cit>  to find the stable structures or significant local structural motifs in the genome, which are then used to build the structural database. rscan could get more significant structural alignments on this filtered structural database. to sum up, this experiment shows that rscan is competent in the real-life applications of searching structural similarities for structural rnas in large genome.

real-life application for validating the unknown rna sequence
given an unknown query, to determine if it belongs to known ncrna families, we can run a structural similarity search on entire ncrna database, like rfam, by rscan. suppose that the ab <dig> /15036- <dig>  which is the trna query mentioned in previous experiments, is the unknown query. rscan can use the parameters with very strict thresholds to quickly search similar structures of the query in rfam seed structural database . rscan only ran  <dig> seconds to report  <dig> significant alignments when the match-core was  <dig> . and  <dig> out of  <dig> hits were the members of trna family. so, the query will be validated as the trna family. it can be clearly seen that rscan provides the user with a quick understanding of the query. moreover, rscan can perform subtler searches using relaxed the match-core, like  <dig>  however this would take more time and would get more trna hits. table  <dig> lists rscan's search results for the six ncrna queries mentioned in previous experiments. the user can choose strict or loose rscan parameters for balancing the computation time and more alignment results.

 <dig> mc: match-core; id: identity; ar: alignment ratio.

 <dig> st: number of same type of ncrna with the query; f5: number of same type ncrna in first  <dig> hits.

we then employed a larger sample of query sequences. table  <dig> shows that ten ncrna queries, selected randomly from the entire rfam seed database, and the above six rna families were just excluding. rscan searched structural similarities for them in the rfam seed database and most queries were recognized. unfortunately the rf00009/af <dig> /1- <dig> and rf00436/al <dig> /16205- <dig> were missed. for rf00009/af <dig> /1- <dig>  this might be relative to the low stability of the query's predicted secondary structure. for rf00436/al <dig> /16205- <dig>  it was too short and formed only one short stem-loop. this simple and general secondary structure aligned numerous false positive hits. generally, according to "mp" and "ql" columns in table  <dig>  rscan had a good performance on the query with unstable structure or the short query such as rf00181/al <dig> /131508- <dig> or rf00480/ay <dig> /1517- <dig>  consequently, rscan is competent for the task of searching structural rna in rfam.

 <dig> mc: match-core; id: identity ≥ %; ar: alignment ratio ≥ %.

 <dig> st: number of same type of ncrna with the query; f5: number of same type ncrna in first  <dig> hits.

 <dig> mp: p-value of minimum free energy of queries' predicted secondary structures.

 <dig> ql: length of query.

in this real-life application, rscan is very convenient for the researchers who might produce or obtain numerous transcripts by biological experiments and would want to know if some of them have similar structures with known ncrna and also to deduce their possible functions. according to table  <dig> and  <dig>  if an unknown sequence is perfectly aligned an ncrna, it can be assigned as the same type. now, we are building rscan as a web server for supporting more ncrna structural databases from experimental and computational databases, like rnadb, noncode, fantom <dig>  etc.

discussion
rscan is a fast and sensitive algorithm for searching rna secondary structure similarity and it is valuable for real-life applications. rscan begins the process by converting the sequence database into a structural database. rscan can then search a structural query on the structural database to obtain the optimal structural alignments. to increase search efficiency, rscan employs a hash table to store k-tuples of the structural database. consequent searches identify all possible match-cores based on the hash table, and score candidate alignments derived from the match-cores to obtain optimal alignments. it should be emphasized that the structural database and the corresponding hash tables are all generated only once and this drastically reduces the search time.

when a database is for a single genome, rscan slides along the genome sequence with a window of predetermined length to segment sequences. the structural database is then created from the predicted secondary structures of these segmented sequences. in traditional methods, a query is only aligned with the sub-sequences of the genome; these sub-sequences are generally less than the maximum length  <cit> . so, using rscan to transform the genome into a structural database is sensible. however, a pc cannot afford the huge storage required for building a structural database with all lengths. in our example, we used a  <dig> nt window, which slides along the both strands of chromosome  <dig> stepped every  <dig> nt, to build the structural database. notice that this sliding window multiplies the genome data six times and it is helpful to prevent the searching from loss of sensitivity. considering the substantial memory usage of the hash table using structural database to reduce memory requirement becomes markedly relevant. in further application, an additional step may be considered for reducing the storage and improving search performance. we may use rnalfold  <cit>  to find the stable structures or significant local structural motifs in the genome, which are then used to build the structural database. rscan could perform more efficiently on this filtered structural database and the structural alignments could be more significant.

as highlighted by klein and eddy, three areas demand additional analysis: the score matrix, the precise secondary structure of the query sequence, and the speed  <cit> . since the score matrix is independent of the alignment algorithm, rscan is not involved in refining the score matrix. rscan only uses the simplest match\unmatch score function. in terms of the query sequence, rscan utilizes known or predicted secondary structures, much like the strategy used by rsearch. in most cases, the correct secondary structures of a sequence are difficult to obtain  <cit> . in order to acquire a good secondary structure, all possible folds of the sequence are considered in sankoff's algorithm  <cit> . however, the optimal energy structure may not necessarily be the correct structure. in such a case considering all possible folds will substantially be slower than many other methods. some of the methods use various constraints to reduce the required folds to predict secondary structures  <cit> . rscan employs rnafold to predict the secondary structures of queries and segmented sequences. this means that only a certain secondary structure of a sequence is considered. this implies that the efficiency of rscan greatly depends on the accuracy of the secondary structure prediction algorithm. improving the score matrix and secondary structure prediction will be considered in our future work, and updates in these areas can be modularly integrated into rscan. in addition, rscan does not evaluate the statistical significance, the p-value, for each alignment. the p-value is generally calculated based on the size of the database and the composition of the sequences in the database  <cit> . since secondary structures in the structural database are generated via prediction, the composition of the structural symbols is not sufficiently credible for a statistical evaluation. finally, rscan focuses on improving search speed, especially on search of large-scale databases. essentially, rscan transfers the complicated similarity search problem of rna secondary structure into a sequence alignment issue between a structural query and a structural database. so, the time complexity of rscan is o, identical to that of the sequence alignment algorithms. rscan successfully realizes a quick search of similar secondary structures for the structured rnas in large databases. in the future, our aim is to build an online rscan server for the applications used by biology and bioinformatics researchers.

CONCLUSIONS
rscan can find structural similarities for structured query rnas in large databases efficiently and quickly. it is a preferable choice for real-life application of structural alignment.

