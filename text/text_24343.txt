BACKGROUND
the design of re-usable software components into libraries has proved to be useful to the rapid development of bioinformatics applications, as witnesses the success of the ever growing open source libraries known as the bio{*} projects. these libraries cover many fields of bioinformatics, but rarely offer tools for intensive calculus, as required for phylogenetic analyses for instance. such computer-expensive applications are usually written in c, a compiled low-level language. programming time-consuming tasks often requires the implementation of specific algorithms optimized for each particular problem. however, despite these specifities, there are some common points , and developers will appreciate to use modules pre-programmed in a flexible manner.

the use of the c++ language combines both the computer efficiency of the c language and the convenience of a object-oriented  approach. we present bio++, a set of c++ libraries dedicated to sequence analysis, molecular evolution and population genetics. other libraries taking these advantages of c++ have been developed, including the libsequence library  <cit>  for population genetics analysis , pdblib for manipulating tridimensional structures  <cit>  or libcov  <cit>  for protein phylogenetics and molecular evolution. the bioinformatics template library  <cit>  also provides algorithms for manipulating and analysing three dimensional structures, using a generic programming approach.

implementation
we did a collaborative effort to design a hierarchy of useful classes for the rapid development of efficient applications in the fields of sequence analysis, phylogenetics, molecular evolution and population genetics. these libraries combine tools for data handling and numerical calculations, providing an easy-to-use, powerful and general development environment. the three main objectives of bio++ are  to speed up the implementation of a new method in order to test it,  to make easier the development of robust applications for distribution and  to provide a high level programming language for biologists.

library design
we used object-oriented programming paradigms to develop bio++. we defined for each class an abstract basal class that contains a number of purely virtual functions . such a basal class is called an interface and can be seen has a kind of contract that a class must follow in order to be used by other methods. such a contract only specifies what an object is at least able to do, and not how it does it. most classes in bio++ are derived from interfaces, and some common instanciations are proposed for each interface. the user may, however, write its own implementation of a given method, and still remain compatible with the rest of the library. for instance, one may easily design a new alphabet to handle a new kind of sequences, or write a new substitution model and perform likelihood calculation without writing any likelihood computation function. conversely, one may implement a new likelihood computation algorithm without re-developping substitution model classes. several interfaces and abstract classes  linked by inheritance specify different levels of specialization. depending on their objectives and programming level, users might simply use fully-specified objects, re-implement specific methods, or even design new classes.

the sequence container hierarchy is a representative example of the class hierarchies defined in bio++ . the sequencecontainer basal interface only specifies that sequences can be accessed by their name. the orderedsequencecontainer has the additional requirement that sequences can be accessed by index, which is generally the case, even if ordering has no biological meaning. the sitecontainer interface requires that sequences have the same length  and hence may also be accessed by site . several implementations are proposed: in the vectorsequencecontainer class, data are stored as a vector of sequences. each sequence can hence be accessed in o. if there are n sequences, they are hence accessed in o. the alignedsequencecontainer is derived from the vectorsequencecontainer class, and adds site access. since data are stored as sequences, the access time for a site is in o and the complete set of l sites is acessed in o. the vectorsitecontainer proposes an alternative implementation by storing sequences as sites instead of sequence objects. the sequence access is hence achieved in o, and the site access in o. all methods working on containers only deal with the sequencecontainer or the orderedsequencecontainer interface, whith no assumption about the implementation. the execution time, however, may vary depending on the implementation used.

development is facilitated by the use of the code documentation generated by the doxygen program  <cit> . full class documentation can be consulted online or downloaded in navigable html format. a short tutorial is also available.

library content
we split bio++ classes into five libraries: three main biological libraries  and two utility libraries , see table  <dig> for there content and dependencies:

• the utils library contains core classes and utilitary functions;

• the numcalc library contains classes for numerical calculus, including several optimization tools, random number generators, probability distributions and statistical functions;

• the seqlib library is dedicated to sequence analysis: sequence storage and manipulation, input/output toward several file formats, alphabet translation, etc.

• the phyllib library deals with phylogenetic trees: markov models, likelihood calculation, etc. the library is more focused on molecular evolution  than pure phylogenetic reconstruction, although several topology reconstruction methods are implemented  search for maximum likelihood  and parsimony scores);

• the popgenlib library is dedicated to population genetics, with particular sequence and codominant markers storage. methods are provided for polymorphism analysis, population divergence estimation and neutrality tests.

RESULTS
const proteicalphabet * alphabet = new proteicalphabet();

this object specifies the type of sequence the program will use. the alphabet object family contains classes for nucleic alphabets , proteins or codons . a dataset is then readed from a phylip sequence file. a sequence reader is created using

phylip * seqreader = new phylip;

other file formats for reading and writing are supported, including the commonly used fasta and clustal. sequences are then read and stored in a container:

sitecontainer * sites = seqreader->read;

since sequences are aligned, they are actually stored in a sitecontainer object . line  <dig> to  <dig> display on screen some properties of the container, namely the number of sequences and sites. in this example we need to restrict our analysis to sites without any gap, so at line  <dig> a new container called "completesites" is created from the former:

sitecontainer * completesites = sitecontainertools: :getsiteswithoutgaps;

several {*}tools classes providing utilitary functions are available. for instance, the sitecontainertools class contains static functions that work on sitecontainer objects.

a jtt proteic substitutionmodel object is created  <cit> :

substitutionmodel * model = new jtt92;

here again, several commonly used models are available. we also use a discrete gamma rate across sites distribution with  <dig> rate classes and a shape parameter of  <dig>   <cit> :

discretedistribution * ratedist = new gammadiscretedistribution;

this model is used first to estimate the distance matrix from the data. a distanceestimation object is then created, by giving the model and data as parameters:

distanceestimation distestimation;

distancematrix * matrix = distestimation.getmatrix();

distances will be estimated using a maximum likelihood  procedure. the numcalc library provides an object-oriented implementation of several general optimization procedures . for phylogenetic optimization, specific optimizers are also available. the program then computes a neighbor-joining tree  <cit> . a neighbor joining object is instantiated and the resulting tree stored in a variable:

neighborjoining nj;

tree<node> * tree = nj.gettree();

this variable is passed to a treelikelihood object, together with the data set, model and rate distribution. an additional parameter tells the object to display a few informations. the drhomogeneoustreelikelihood object is for homogeneous models, with rate across sites variations.

discreteratesacrosssitestreelikelihood * likfunction = new drhomogeneoustreelikelihood;

several treelikelihood implementations are available. the drhomogeneoustreelikelihood object uses one 'view' by neighbor node for each node, i.e. three views by node in case of bifurcating trees  <cit> . this implementation saves computational time during nni-mediated topology search, and is also more convenient to compute branch-lengths derivatives. an alternative implementation is proposed: homogeneoustreelikelihood, and others could be easily added if required. for parameter optimization, we used a utilitary function from the optimizationtools class. this function automatically instanciates the appropriate optimizer object. it receives as argument a pointer toward the likelihood function, a tolerance number and a maximum number of function evaluations. two optional log-files are provided to monitor the optimization process , and the last parameter specifies the verbose level:

optimizationtools:: optimizenumericalparameters;

finally, the optimized tree is writen to a file named output. dnd in newick file format:

newick newick;

newick.write;

this program creates three files: two for the ml tree estimation and one for the final tree.

CONCLUSIONS
bio++ is a mature project which has been used in previous works like molecular coevolution analysis  <cit>  or codon analysis  <cit> . however it is an active project still receiving new methods and improvements.

development snapshots may be accessed by anonymous cvs on the library website. the website also provides on-line documentation of classes, tutorial and several code examples. several programs have been developped with the bio++ libraries, including bppml for ml likelihood tree estimation and bppsg for sequence generation by simulation under different kinds of models. any contribution will be welcome, as specific functions or as additional libraries compatible with the present ones.

availability and requirements
c++ libraries are not organized in a tree-like hierarchy as java packages or perl modules. they are bundled in a non-nested way, and may be compiled in two flavours, either static or shared . dynamic libraries are loaded during the program execution and hence can be shared by several applications, while static libraries are hard-coded into the executable, which no longer requires the library to be installed.

each bio++ library is complient with the gnu standards and uses the autotools suite for compilation and installation. bio++ can hence be built with these gnu tools on any unix-like system. alternatively, sources can be imported and compiled in any c++ development environment . it has been successfully installed on linux, macos x and windows using the cygwin port and mingw. bio++ is distributed freely under the cecill public license . it is available from its website at .

authors' contributions
jd developped the utils, numcalc, seqlib and phyllib libraries and drafted the manuscript. sga developped the popgenlib library, provided algorithms for the numcalc library and helped with the gnu configuration tools. eb developped tools for the popgenlib library. sg <dig> provided tools for the popgenlib and seqlib libraries. vr helped in the development of the phyllib library. ng participated in the design of the library. kb suppervised the whole project. sg <dig>  vr, ng and kb helped to draft the manuscript. all authors read and approved the final manuscript.

supplementary material
additional file 1
sources and data files of the example as a zipped archive.

click here for file

 acknowledgements
jd would like to thank tal pupko for providing help with c++ in the early development of this project. some code in the numcalc library have been adapted from the semphy library  <cit> , ziheng yang's paml package  <cit>  and the c++ port of the java matrix  package . this work was supported by french ministére de la recherche aci impbio.

figures and tables
 linkage desequilibrium, neutrality tests and recombination.
