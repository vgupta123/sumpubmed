BACKGROUND
the dramatic drop in the expense of genome sequencing has two somewhat contradictory effects on the study of gene order. on one hand it greatly increases the range of organisms available for genomic analysis, including comparative studies and phylogenomics. on the other hand, however, it encourages the final release of the genomes in unfinished  form, since the cost of finishing has not decreased at nearly the same rate as the cost of random sequencing  <cit> . the use of draft genomes makes many analyses and interpretations tentative and prone to error, and leads to particular problems in the comparative study of gene order. many algorithms for studying genome rearrangement require whole genome data, i.e., complete representations of each chromosome in terms of gene order, conserved segment order, or some other marker order, in order to calculate the rearrangement distance d between two genomes. items whose chromosomal location is unknown cannot be part of the input. this puts the many draft genomes outside the scope of currently available comparison technology, even though these data may be suitable to other goals of genomics.

strategy
to overcome these hindrances to the exploitation of much of the genome sequence data produced now and in the future, we have undertaken a program of adapting genome rearrangement methodology to partially sequenced and incompletely assembled genomes. the idea is to use comparative information algorithmically to improve the assembly of a draft genome, including the ordering of scaffolds on the chromosomes and the insertion of unsequenced genes in scaffold gaps, while simultaneously using the improved assemblies in comparison of gene order and inference of genome rearrangement. in earlier studies on papaya carica papaya  <cit>  and drosophila  <cit> , we investigated the case when one or both of the genomes being compared are given only in contig form. though we did manage to find appropriate genomic data in contig form to test our methods in these studies, most sequencing projects are able to order some or all of the contigs, with intervening gaps, in scaffolds, which contain more information than unordered sets of contigs. in the next section, we model how contigs are organized into scaffolds in the two current approaches to sequencing. we then formalize scaffolded genome comparison, where one of the genomes is known only in scaffold form, as a combinatorial optimization problem for inserting missing genes in the scaffold gaps in such a way as to minimize the rearrangement distance. we devise an exact polynomial-time solution for this problem. we then assess how this algorithm performs on simulated data and apply it to compare the scaffolded genome of castor bean ricinus communis to the fully sequenced genome of grapevine vitis vinifera. in the process, we discover how to estimate what proportion of the missing genes are simply unsequenced or unidentified, and what proportion are actually absent from the genome.

although using comparative evidence has long been commonplace in predicting gene location and indeed is one of the original motivations for model organism genomics, we believe this to be the first effort to predict the locations of large numbers of genes simultaneously using combinatorial optimization, while detecting and taking account of genome rearrangements.

partial sequencing scenarios
by contig we understand a completely sequenced fragment of a chromosome. this is assembled through identifying significantly overlapping reads of sequencing reactions. by scaffold we mean a set of ordered contigs  separated by unsequenced dna which may be of known or unknown length. an anchored scaffold or contig is one whose location on the chromosome is known, thanks to any one of a number of different types of evidence.

in an idealized completely sequenced and gene-identified genome, complete gene orders would be known for each chromosome . when genome sequencing is not supplemented by finishing techniques, however, three different types of incomplete gene order data can result. when a strategy such as shotgun sequencing of unordered clones is employed, we have only isolated contigs constructed from overlapping reads, which would contain no internal gaps but could be relatively short assemblies .

contigs-only assemblies could also involve much longer sequence fragments produced by complete, polished, sequencing of bacs or other chromosome fragments, which are not yet numerous enough to have been assembled into full chromosomes. when paired ends reads with unsequenced inserts are included with shorter complete reads, some of the contigs may then be ordered into scaffolds, with unsequenced gaps intervening between successive contigs, as in figure 1c. finally, detailed physical maps may be available to anchor all scaffolds to precise chromosomal locations, so that the scaffolds for a given chromosome become, in effect, a single scaffold or pseudomolecule .

in practice, sequencing projects may use both bac and shotgun methods as well as sequence obtained by other means. not all bacs are necessarily anchored and some contigs produced by shotgun methods may be anchored. nevertheless, from our viewpoint, the three abstractions represented in figure 1b), 1c) and 1d) capture the essential distinctions between contig and scaffold and between anchored and unanchored.

genomic distance
the rearrangement distance or genomic distance d is a metric counting the number of rearrangement operations necessary to transform one signed multichromosomal gene order g <dig> into another g <dig>  in the simplest case, we require that the two genomes both contain the same n genes, with no duplicate genes. the positive or negative sign associated with a gene indicates its reading direction . to calculate d efficiently, we use the breakpoint graph of g <dig> and g <dig> as follows and as illustrated in figure  <dig> 

in a first step, each gene g with a positive sign is replaced by its tail and head vertices in the order gt, gh; for -g we would put gh, gt. each pair of successive genes in the gene order defines an adjacency, namely the pair of vertices that are adjacent in the vertex order thus induced. for example, if i, j -k are three neighbouring genes on a chromosome then the unordered pairs {ih, jt} and {jh, kh} are the two adjacencies they define. there are two special vertices called telomeres for each linear chromosome, namely the first vertex from the first gene and the second vertex from the last gene.

we convert all the telomeres in genome g <dig> and g <dig> into adjacencies with new vertices all labelled t <dig> or t <dig>  respectively. we define a blue edge connecting the vertices in each adjacency in g <dig> and a red edge for each adjacency in g <dig> .

in the next step in figure  <dig>  we start constructing the breakpoint graph by identifying  each vertex in g <dig> with the identically labelled vertex in g <dig>  in the last step depicted in figure  <dig>  we make a cycle of any path ending in two t <dig> or two t <dig> vertices, connecting them by a red or blue edge, respectively, while for a path ending in a t <dig> and a t <dig> , we collapse them to form one t vertex.

each vertex is now incident to exactly one blue and one red edge. this bicoloured graph decomposes uniquely into κ' alternating cycles. if n' is the number of blue edges   

and the optimizing rearrangements are rapidly recovered by operations on the graph  <cit> .

in the methods section below, we will refer to tesler's  <cit>  mathematically equivalent formulation of the breakpoint graph, where the final step in figure  <dig>  turning paths into cycles, is not carried out. instead, there are only κ ≤ κ' cycles and a certain number π of the paths, namely those with at least one t <dig> endpoint, are called good paths. then   

where χ <dig> is the number of chromosomes in g <dig>  although the breakpoint graphs, and d, are equivalent in the two formulations, tesler does not call d "genomic distance". this difference is due to our inclusion of transpositions of chromosomal segments in the repertoire of rearrangements permitted in calculating d, together with the inversions, reciprocal translocations, chromosome fusions and fissions allowed by tesler.

methods
there are two different aspects of the comparison of a completely assembled genome g <dig> with a genome in scaffold form g <dig>  one is scaffold filling, which predicts where in g <dig> to locate potential genes that have not been identified in the sequence but are present in g <dig>  the second is contig fusion, which suggests how to piece g <dig> contigs together to form chromosomes. in figure  <dig>  only scaffold filling is necessary for scenario  and only contig fusion is required for scenario . scenario  requires both.

we have shown how to handle the contig fusion problem in previous publications on papaya  <cit>  and on drosophila  <cit> , and this will be reviewed in a separate section below. in the present paper we design and analyze an efficient exact algorithm for scaffold filling that simultaneously carries out contig fusion. we use this algorithm to analyze real and simulated data.

filling in scaffolds
when g <dig> is only partially sequenced, and is missing some orthologs with g <dig>  and  in figure 1), we cannot complete the breakpoint graph since the red edges cannot be drawn to the two vertices corresponding to each missing gene, though these vertices are present in the graph and are incident to blue edges. at the same time, although we can draw a red edge between the last gene in one contig of a scaffold and the first gene in the next contig, we know that in reality there may be genes in the unsequenced gap between the contigs, and that once these genes are identified, the red edge will have to be "cut" and replaced by two or more gene vertices and two or more other red edges.

statement of the combinatorial optimization problem
g <dig> consists of χ chromosomes, each of which is an ordered set of signed genes.

a contig in g <dig> is an ordered set of one or more signed genes, each orthologous to a gene in g <dig>  a scaffold in g <dig> is an ordered set of contigs. then g <dig> consists of a number of scaffolds, each of which is an ordered set of genes interrupted occasionally by a gap.

then with reference to figure  <dig> and , the problem becomes: find an assignment of the missing genes to the gaps in the scaffolds or at the ends of the scaffolds of g <dig>  thus transforming the scaffolds into contigs, such that the resulting set of contigs  is at a minimum rearrangement distance from g <dig> 

implicit in our definitions is that between every pair of successive contigs in a scaffold is a gap large enough to contain genes. where this is not the case, we can simply create a larger contig by disregarding the gap and concatenating the contigs on either side. we also disregard contigs without genes, so that they too may be subsumed in a gap. note these are basically terminological conventions, rather than restrictions on the data.

a polynomial-time algorithm
the exact, linear-time, algorithm we have devised completes the breakpoint graph, only partially determined by g <dig> and by the scaffolds of g <dig>  by means of insertions of missing genes into the gaps of g <dig> 

terminology
we have hitherto used the term path only to refer to alternating-colour sequences of edges connecting some of the bivalent vertices in the breakpoint graph, with telomeres at either end, that are eventually turned into cycles by joining or collapsing these two telomeres. in what follows, however, a path more generally may be any such connected set of edges, with or without telomeres, and may consist of only one  edge. paths with two telomeres will be called complete paths.

a free end is a vertex in the graph that has no incident red edges, only a blue one.

thus when we say that that g <dig> and the scaffolds of g <dig> partially determine a breakpoint graph, we mean that there are paths not ending in two t vertices, but in at least one free end.

a half path is a path ending in one telomere and one free end. a pseudopath is a structure consisting of two half paths where the two telomeres are deemed to be adjacent, though not by means of a red or blue edge. pseudopaths will sometimes be treated as if they were paths, with the two free ends being the free ends from the two constituent half paths.

initially, a cuttable edge is a red edge drawn between vertices of two successive genes in a scaffold that are not in the same contig, i.e., there is an unsequenced gap between the genes. subsequently, if a red edge is disrupted during gene insertion, new red edges are created as will be specified in the algorithm presented below.

a bundle is a subset of the paths in the breakpoint graph of g <dig> and g <dig>  each bundle is associated with one or more of the missing genes. the vertices corresponding to each missing gene, its free ends, must be in the same bundle and must be endpoints of two paths, or the two ends of one path. an open bundle contains at least one cuttable edge; a closed one has no cuttable edges. as the breakpoint graph is completed by the algorithm, the bundles also change.

a sketch of the algorithm
we have divided the algorithm into three parts. the first, the main algorithm fillscaffolds, constructs the partial breakpoint graph determined by g <dig> and the scaffolds of g <dig>  and then partitions the paths in this graph  among a number of bundles, some open and some closed. initially, a bundle can contain either zero or two telomeres. if they are present, the half-paths, which are the two paths ending in telomeres, are linked together to become a pseudopath.

although the missing genes represented by the free ends in an open bundle will eventually be inserted in an optimal way by manipulating cuttable edges, this is not possible within closed bundles. fillscaffolds thus calls the second algorithm combinebundles, which subsumes all closed bundles within open ones, as in figure  <dig>  thus creating larger open bundles, including some which contain more than two telomeres. this is done in such a way as to minimize the eventual genomic distance between g <dig> and . this step requires interchanging the half paths of the pseudopaths in the two bundles being combined, through changes in telomere adjacencies, to maximize the number of good paths according to the tesler formulation in equation .

finally, fillscaffolds calls completebundle, which makes the connections between the free ends and the cuttable edges within each of the open bundles.

the output of the algorithm includes cycles, each containing at most one pair of "adjacent" telomeres, which become the two endpoints of a complete path within the breakpoint graph.

after presenting the algorithm, we state and prove a theorem establishing its correctness:

algorithm fillscaffolds
input: a fully sequenced and assembled  genome g <dig>  and a genome g <dig> made up of scaffolds containing some of the genes in g <dig> and gaps.

output: a completed form of g <dig>  denoted  where the missing genes from g <dig> are inserted into the gaps in such a way as to minimize , and the associated breakpoint graph.

 <dig>  construct the breakpoint graph based on genome g <dig>  and g <dig> , including cuttable red edges between consecutive genes in g <dig> scaffolds separated by a gap. we include t <dig> vertices at the telomeres of g <dig> chromosomes and t <dig> vertices at the end of g <dig> scaffolds. we do not complete the third step of figure  <dig>  so the graph may contain cycles, complete paths and other paths.

 <dig>  we construct the initial bundles as follows. we choose any free end not already in any bundle as the seed of a new bundle. then if a path containing free end gt is in a bundle b, then we also include the path with gh as a free end, and vice versa.

 <dig>  there can be zero or two t vertices in an initial bundle. if there are two, we consider the two half paths as if they were one path where the two t are adjacent, even though there is no red or blue edge connecting them.

 <dig>  we use combinebundles to remove all the closed bundles by merging them with open bundles, or with complete paths or cycles with cuttable edges, resulting in larger open bundles. we do this in such a way as to minimize .

 <dig>  complete each bundle, using completebundle.

algorithm combinebundles
input: the set of open and closed bundles as well as the set s of complete paths and cycles with cuttable edges.

output: a set of open bundles, and a subset s' of the complete paths and cycles. the open bundles contain all the vertices in the input bundles plus those vertices in s\s', the paths and cycles not included in s'.

 <dig>  while there is a closed bundle with a t1t <dig> adjacency and a open bundle, or complete path with a cuttable edge, with a t2t <dig> adjacency, combine them by switching the adjacencies between t vertices, i.e., by exchanging two half-paths. this results in a larger open bundle and also increases the number of good complete paths by one.

 <dig>  while there is a closed bundle with a t2t <dig> adjacency and a open bundle, or complete path with a cuttable edge, with a t1t <dig> adjacency, combine them by switching adjacencies. this results in a larger open bundle and also increases the number of good complete paths by one.

 <dig>  while there is a closed bundle with a t2t <dig> adjacency and closed bundle with a t1t <dig> adjacency, combine them by switching adjacencies. this results in a larger closed bundle and increases the number of good complete paths by one. the closed bundle eventually has to be combined with an open bundle or cycle or complete path.

 <dig>  while there is a closed bundle with a tt adjacency and a open one with a tt adjacency, combine them by switching adjacencies. to maintain the number of good paths, if the adjacencies are t1t <dig> , and , then after the switching the adjacencies they should be  and .

 <dig>  while there is a closed bundle, combine it with an open bundle or cycle or complete path by adding a pair of cuttable edges, as in figure 4:

i. find two free ends gh and gt in the closed bundle.

ii. choose a cuttable edge kl in some open bundle, or path or cycle.

iii. replace kl by two cuttable edges kgh and and gtl.

algorithm completebundle
input: a good bundle.

output: a number of cycles.

while there remain paths in the bundle as in figure 5

 <dig>  choose a path containing a cuttable edge kl, with endpoint gt, where l is not on the subpath between k and gt.

 <dig>  find the path with endpoint gh, possibly the same path.

 <dig>  replace kl by kgt and ghl, which are red cuttable edges. this results in a cycle containing kgt and a path containing ghl, unless gt and gh are on the same path, in which case the operation produces two cycles.

proving the algorithm
after the first three steps of fillscaffolds, suppose we have constructed γ open bundles with r <dig>  ⋯, rγ paths, β closed bundles not containing t vertices with q <dig>  ⋯, qβ paths, and δ - β closed bundles containing t vertices with qβ +  <dig>  ⋯, qδ paths. let ϵ =  <dig> unless δ - β >  <dig> but there are no open bundles containing t vertices nor any complete paths with cuttable edges, in which case ϵ =  <dig>  suppose there were κ* cycles and p* complete paths in the original breakpoint graph of g <dig> and g <dig> 

theorem: there are   

cycles and complete paths in the final breakpoint graph constructed by fillscaffolds. moreover, not only is the number of cycles κ maximal over all ways of inserting the missing genes, but so is the number of good complete paths π ≤ p. thus the algorithm also implicitly produces the value of d.

proof: we first show that in completing an open bundle with r paths, we obtain r +  <dig> cycles. later, we will show that each of these cycles has at most two t vertices.

consider the case r =  <dig>  figure  <dig> shows that completing this bundle in the optimal way creates two cycles. it also shows that for r >  <dig>  we obtain a open r - 1-bundle plus one cycle. thus, completing an open bundle with r paths produces a total of r + <dig> cycles.

it is thus never advantageous to draw a pair of red edges between two open bundles with r and s edges, since this cannot create a cycle, only a bundle with r + s -  <dig> edges. when completed this will only give r + s cycles instead of the r + s +  <dig> if we had completed them separately.

on the other hand, to be processed toward completion, it is necessary for a each closed bundle to be combined with either an open bundle, or a cycle or a complete path with a cuttable edges, since a closed bundle has no cuttable edges by itself. the optimum ways to do this are illustrated in figs.  <dig> and  <dig>  in the former case, where both bundles have t vertices, switching adjacencies allows a closed bundle with r paths to contribute r paths to the open bundle, and eventually to be responsible for r cycles. if one of the bundles has no t vertices, on the other hand, the closed bundle can contribute only r -  <dig> of its r paths in combining with the open bundle .

now the numbers of open bundles, closed bundles with t vertices, closed bundles without t are fixed at the outset, and we can also find out if there are open bundles with t  or not at the initial stage. counting the number of cycles given by each type we arrive at the first claim of the theorem. since each combination and completion is done optimally in the algorithm, the result for κ is best possible. so is π, through the operations minimizing the number of t2t <dig> edges in combinebundles.

it remains to show that the cycles output by the algorithm have no t vertices, i.e., are the kind of cycles appearing in the breakpoint graph in the second to last stage of the construction of figure  <dig>  or exactly two adjacent t, i.e., are the kind of complete paths  appearing breakpoint graphs. otherwise, the values of κ and π that we obtain in this theorem would not be those required for equation .

to prove this, we refer to figure  <dig>  which integrates aspects of figure  <dig>   <dig> and  <dig>  the case by case analysis illustrated there shows that if there are more than one tt adjacency in a path, these adjacencies will necessarily be incorporated at most one at a time into cycles. cycles without tt adjacencies are also cycles in the breakpoint graph between g <dig> and the augmented genome  and the cycles with tt adjacencies become complete paths, either good or bad, in this breakpoint graph. this completes the proof.

the construction of the optimal breakpoint graph by fillscaffolds inserts the missing orthologs in the scaffold gaps and at the ends of scaffolds in a way that minimizes the number of rearrangements intervening between g <dig> and the optimal g <dig> thus constructed. once the optimal breakpoint graph is known, these rearrangements can be recovered rapidly by standard manipulations on the graph  <cit> , as mentioned in our discussion of equation . the construction of breakpoint graphs is of linear complexity, and this extends to the identification of bundles and their manipulations in fillscaffolds. this includes the placement of missing genes. the recovery of minimizing rearrangements can be implemented in subquadratic time  <cit> .

contig fusion
the algorithm in the preceding section fills in the gaps between the scaffold whenever this is justified, so that by our definitions, the scaffolds become contigs. for unanchored scaffolds, as they are filled in by our algorithm described above, they are also being assembled into chromosomes. in doing this, our method based on the breakpoint graph treats the incorporation of each scaffold/contig as if it were a chromosomal fusion operation.

we previously found  <cit>  through simulations that for ordinary genomes, i.e., complete gene orders, if there are τ rearrangements, but the genomic distance algorithm infers d rearrangements, then the expectation   

an estimate of τ is   

where λ <dig> and λ <dig> are parameters that depend on how the rearrangements are generated.

when one of the genomes consists of unanchored contigs , we have to correct the output of the genomic distance algorithm ds before using  to take into account the number of "fusions" necessary to optimally piece together the contigs into chromosomes. the corrected distance is   

where α is a decreasing function of the number of rearrangements τ, approximately paralleling the derivative of d, namely .

missing genes: absent or just unsequenced?
we will use g <dig> and g <dig> here to refer to the genomes that are the source of the gene order data. by definition in our method, unsequenced genes must be located in gaps between the contigs or at the ends of scaffolds. we assume any genes within contigs have been identified. however, many or even most genes that are in g <dig> but have no ortholog in the g <dig> data may actually be absent from the latter genome either because over time they have been deleted from g <dig> , or because they were acquired by g <dig> but not by g <dig> since the two lineages diverged.

the scaffold filling algorithm is designed to enhance sequence assembly, and cannot distinguish one type of missing gene from another. indeed, where gene models are available from cdna or est data, we could simply discard the missing genes from g <dig> that are not reflected in the set of gene models for g <dig>  in general, however, we do not have this information, and the best we can hope for is to be able to estimate quantitatively how many of the missing genes are present in the genome, but unsequenced.

let  represent the genome g <dig> with all the genes missing from g <dig> deleted. the remaining genes are ordered in the chromosomes in the same way as in g <dig> . one way to estimate the proportions of the two types of missing genes is to compare the genomic distance , where only the genes in common in the data from the two genomes are considered, with the distance  after g <dig> is augmented to  by the scaffold-filling procedure. as detailed below, we have found in extensive simulations that if all unsequenced genes were originally located in regions that are gaps after the  sequencing and assembly are finished, the distances  and  are identical, or almost so, over a wide range of genome sizes, rearrangement distances and missing gene sets. if on the other hand, many of the missing genes are in reality absent from the g <dig> genome, a major proportion of these, approximately equal to the coverage of the genome sequencing, will have been in syntenic contexts in g <dig> that are in contigs in g <dig>  thus forcing these genes to be in gaps, as the scaffold-filling algorithm does, will tend to increase the rearrangement distance . then if m is the number of missing genes   

is a measure of how the proportion of missing genes are not actually in the g <dig> genome.

the value of d' depends on how much the contigs are already rearranged in the independent evolution of the two genomes. if the contigs are highly rearranged compared to g <dig> , then there is no necessary increase in d' when the missing gene is forced into a gap. but if the syntenic context of a missing gene is intact in a contig, then forcing this gene into a gap remote from this context will necessarily increase d'.

our strategy for evaluating this dependence requires us to manipulate the overall degree of syntenic context conservation while keeping d fixed. in the simulations in the results section below, we accomplish this by using fixed length inversions. by generating the genomic divergence with very short inversions, we require more inversions to attain the same inferred d, but we also guarantee the existence of a good number of conserved segments  and allow d' to increase. by fixing the inversion length at successively higher values, the scope of each inversion becomes longer and it is less likely a conserved segment will remain undisrupted, and d' will tend not to increase.

RESULTS
in this section we apply the scaffold filling and contig fusion methods by comparing the draft genome of ricinus communis with the more complete genome of vitis vinifera. we will do this in three stages. first we will give a brief description of the phylogenetic relationship of these two angiosperms and a preliminary bioinformatic comparison of their genome sequences. this will give us  <dig>  presumptive orthologous genes in the two genomes, plus  <dig> genes vitis genes which are not in the ricinus data, either because they are in the unsequenced parts of the genome, or because they have simply been deleted from, or never acquired in, the ricinus lineage. we call these missing genes. we calculate statistics about how the missing genes are distributed in vitis, as singletons, pairs, triples or longer runs. we also calculate for ricinus the distribution of the number of genes per contig and per scaffold, the number of contigs per scaffold and the total numbers of contigs and scaffolds.

in the second stage, we use these distributions to simulate random pairs of genomes having the same characteristics as the ricinus-vitis data set. we model the number and distribution of missing genes as being due to three types of process:

• the evolutionary divergence of gene complement between the two species,

• the variability of conserved segment size as chromosome inversions disrupt gene order over time, and

• the distribution of contig and scaffold sizes produced during the sequencing project.

the simulations enable us to predict how these factors affect the results of scaffold filling.

finally, in the third step, we apply our scaffold-filling algorithm and contig fusion analysis to the ricinus-vitis data and interpret the results in the light of missing gene models we elaborate and the simulations we carry out.

the castor bean genome
sequenced by the sanger method to a depth of 4×, the castor bean genome exemplifies the kind of final product that we can increasingly expect of draft genome sequencing projects, with a large number of scaffolds  not anchored to any chromosome.  almost all of the genes, however, are found on a smaller number  of the larger scaffolds . to illustrate our method, we wish to pick a completely sequenced genome with which to compare ricinus, one from a not too distantly related angiosperm species, so that it is likely to share a large majority of its gene complement and gene order with ricinus. more distant relatives might also work, but divergent gene complement and decreasing synteny would lead to more ambiguous and less reliable results. moreover, there is another, more stringent, condition. on the two lineages from their common ancestor leading to the two genomes, there should be no whole genome duplication  event. though we know how to compare gene orders of such former tetraploids with diploids that diverged before the wgd  <cit> , in the first instance we would like to avoid such complexities in testing our new procedure. this eliminates arabidopsis, oriza, populus and medicago among the high-quality genome sequences available. it also eliminates the closely related hevea brasiliensis  genome, in the same family  as ricinus, for which the draft sequence has been announced, but which is a recent tetraploid or, more accurately, an amphidiploid  <cit> , p.  <dig> 

fortunately, there seems to be no wgd in the lineages leading to vitis vinifera and ricinus since their last common ancestor, and so we can use vitis as g <dig> in our method and ricinus as g <dig>  although burleigh et al.  <cit>  have suggested that there have been one or more wgd events in the rosid clade rooted after the divergence of vitis vinifera, in the lineage leading the euphorbiaceae family, which contains ricinus, the evidence presented in that paper, namely a large number of gene families originating in the early period, is not at all statistically significant, may be a methodological artifact as acknowledged by the authors, and, pace reference  <cit> , is uncorroborated in the literature . in addition, though a relatively recent wgd has been proposed for vitis  <cit> , this suggestion has not met with general acceptance  <cit>  either. thus we may provisionally treat the vitis-ricinus relationship as being uninterrupted by wgd. finally, there is evidence that vitis gene order has evolved relatively slowly, e.g., reference  <cit> .

we extracted scaffold, contig and gene level data on ricinus communis from genbank as well as chromosomal gene order data on vitis vinifera. of the  <dig>  vitis genes,  <dig>  showed up as best reciprocal hits , using blastp and a 1e- <dig> threshold to compare the proteins, among the  <dig>  possible protein genes suggested by the ricinus sequence. we discarded the rest of the ricinus gene models.

key statistics are given in table  <dig>  to the  <dig> missing orthologs we add  <dig> genes that were found on ricinus scaffolds with no other genes, i.e., since they contribute no gene order information, so that a total of  <dig> genes are to be placed relative to the ricinus gaps. the remaining  <dig>  of the  <dig>  ricinus orthologs were organized into  <dig>  scaffolds each with two or more genes, i.e., containing at least some order information. the scaffolds also contained a total of  <dig> gaps. note that our algorithm automatically places additional gaps at the two ends of each scaffold, so that we need not worry separately about placing genes between the scaffolds.

genes per
the distance , where only the orders of the  <dig>  genes in both g <dig> and the scaffolds of g <dig> are considered, is  <dig>  the distance , which compares g <dig> to the augmented version of g <dig>  namely , after the scaffold-filling procedure has been applied, so that the orders of all  <dig>  genes are considered, is  <dig> 

simulations
we simulated pairs of genomes with number of genes n =  <dig>   <dig>  the first, g <dig>  simply has the genes evenly distributed among the  <dig> chromosomes. blocks totalling  <dig> genes, distributed as in table  <dig>  to be eventually deleted in forming g <dig>  were chosen at random along the genome, constrained only from overlapping or even touching. at first these genes were only marked, but not deleted. for a range of values of τ, we applied τ random rearrangements to g <dig> and then deleted the marked genes. we assumed that rearrangements are preponderantly inversions , a common tendency in gene order evolution, and we chose the two breakpoints for each rearrangement randomly along the chromosome.

all deletions create gaps
each deletion event created a gap between two contigs. in addition random contig breaks were inserted to make sure that the number of contigs totaled  <dig>  as in the ricinus data in table  <dig>  adjacent contigs were then assembled randomly into scaffolds in such a way as to produce the same distribution of contigs per scaffold as in table  <dig>  single-gene scaffolds were identified and removed from the lists of scaffolds and contigs and transferred to the list of missing genes, as in the ricinus analysis.

applying the fillscaffolds algorithm to these data, for τ =  <dig>   <dig> ⋯, <dig>  twenty runs for each τ, demonstrated that under the model where missing genes are entirely due to incomplete sequencing, the distance ) was exactly the same as  in 90% of the runs, and  <dig> rearrangements more costly  in the remaining cases. thus we can conclude that fillscaffolds generally inserts the  <dig> missing genes  at virtually no cost, in terms of genomic distance. this holds over a wide range of genomic distances. it also holds for a range of models of rearrangement; for example, if instead of the two breakpoints being randomly chosen over the chromosome, we restrict inversions to involve only a small number of genes, the difference between pre- and post-scaffold-filling is less than  <dig> %.

we note that the simulations, including the use of our implementation of the fillscaffolds algorithm, took on the order of a minute each on a macbook pro with  <dig>  ghz processor speed.

some deletions do not create gaps
how can we model the subset of missing genes that are not those unsequenced genes in g <dig> that cause gaps between the contigs, but genes that are not in the g <dig> genome at all? to do this, we delete some proportion of the genes marked at the beginning of the simulation as before, but do not create a gaps between contigs at the deletion point. insofar as the syntenic context of the absent g <dig> gene is conserved in a g <dig> contig, this should cause an increase in  over , due to the rearrangement cost of moving the gene from its original context to a gap. it will not tend to cause an increase if the syntenic context in g <dig> has already been rearranged in g <dig>  e.g., if the absent gene is at the breakpoint of an inversion or translocation. because this effect involves the interaction of synteny conservation and rate of non-gap-creating deletions, we set up simulations as described in the missing genes: absent or just unsequenced? section above, varying both of these processes. we carried out simulations with from 60% to 100% non-gap-creating deletions and with fixed-length inversions from  <dig> to  <dig> genes long. each of the  <dig> simulation conditions  is represented by the average of  <dig> simulation trials.

the simulations show that the value of d' increases with greater conserved synteny, and with higher proportions of non-gap-creating deletions. this is depicted in two ways in figures  <dig> and  <dig>  of particular interest will be the case of d' =  <dig>  indicated by the dashed line in both graphs. this case corresponds to the ricinus-vitis comparison as reported in the results on ricinus section below.

distances
we compare the relationship between the inferred number of rearrangements, corrected for the number of scaffolds in g <dig>  and the actual number of random rearrangements τ used in simulating this genome. before the deletion of the genes from the gaps and the creation of the scaffolds, i.e., when the genomes contain  <dig>  orthologs, equation  closely predicts the observed distances. this is illustrated in figure  <dig>  which is based on the average of  <dig> simulated trials per data point.

after the deletions of  <dig> genes representing those absent from g <dig>  as well as the variable number  genes in single-gene scaffolds, following scaffold creation in the "all deletions create gaps" model, the observed distance is less than that predicted by equation , especially when the simulated rearrangements become numerous. this is also illustrated in figure  <dig>  the observed distance  is corrected  for the  <dig> chromosomal fusions necessary to assemble the contigs  into  <dig> chromosomes, using  in equation , but the inferred distance is smaller than predicted even without this correction.

these results indicate that estimating τ using equation , e.g., for the purposes of distance-based phylogeny, is likely to underestimate this genomic distance to some extent.

results on ricinus
our algorithm found a distance of  <dig> operations between vitis and the reconstructed ricinus genome, corrected for fusions to  <dig> by subtracting  <dig> fusion operations.

in previous work  <cit>  we estimated the distance between populus and vitis, which should represent the same divergence time, given that populus and ricinus presumably shared a common ancestor since the divergence of the vitis lineage. we also estimated  <cit>  the distance between populus and carica papaya, which should represent a divergence time smaller than vitis - ricinus. making these comparisons  is reasonable, although the populus rearrangements occurred after a wgd event.

a: contains corrections to distance due to scaffold fusions. b: populus comparisons include rearrangements during the re-diploidization of the ancestral tetraploid. c: some missing homologs in the ricinus comparisons are simply not sequenced, while in the other comparisons, missing homologs are virtually all absent from the genome.

when all the data are taken into account, and each distance normalized by the number of genes in the comparison, the vitis - ricinus distance is comparable to the populus - carica one, and both are greater than populus - vitis. this slight disproportion between vitis - ricinus and vitis - populus is attributable, in unknown proportions, to

• the use of a method more refined than brh, namely orthomcl  <cit> , to identify populus - vitis orthologs. for vitis - ricinus we used brh without any validation by chromosomal context or by gene ontology.

• generation time difference in different lineages, as argued in  <cit> .

• the proportion of non-gap-creating deletions, which is a function of the divergence in gene complement.

only the first of these is directly amenable to computational improvements, without further biological input.

the key result in table  <dig> is the rate of correct placement of the missing orthologs. some 63% percent of the orthologs were inserted without any increase in rearrangement distance. this is comparable to the 57% - 64% in the previous studies, even though the latter each benefited from evidence from two syntenic contexts rather the single vitis contexts used for orthologs placement in ricinus. with reference to figures  <dig> and  <dig>  it suggests that around 75% of missing genes are not attributable to incomplete sequencing, but rather to divergent gene complement in the two genomes. table  <dig> and figure  <dig> and  <dig> are also compatible with the fact that almost all the missing genes in the populus comparisons are attributable to divergent gene complement.

CONCLUSIONS
one methodological difficulty inherent in our comparison of ricinus and vitis is that of ortholog identification. brh, which we used, is the simplest approach to this problem, using only sequence similarities, but there are many others available such as orthomcl  <cit> , inparanoid  <cit>  and msoar  <cit> , which can also make use of local order and gene ontology information.

aside from improvements in orthology identification, which is a major roadblock to all gene order reconstruction problems, not only the scaffold assembly problem discussed here, there are a number of immediate possibilities to extending our technique. one is to take into account gap sizes on the scaffolds and gene sizes for the orthologs. as it is our reconstruction does not limit how many genes of whatever size can go into a gap.

a second, associated, problem would be to allow overlapping scaffolds, in cases where the paired ends data might not be resolved enough to preclude this configuration. we have already done this to some extent, in treating the single-gene scaffolds in the same way as missing genes. these small scaffolds are thus being inserted into the gaps in other scaffolds. allowing more general overlapping might complicate the algorithm, but in practice this could be a rare occurrence.

in the present work, we have assumed g <dig> to be fully sequenced and g <dig> to be in scaffolds. this is reasonable even though there are some gaps in the vitis genome; there are not likely to be a large proportion of genes that remain unsequenced as there are in ricinus. in other contexts, however, it might be desirable to expand our theoretical and practical considerations to allow both genomes to be in scaffold form. here it may be necessary to insert missing orthologs in both directions, from g <dig> to g <dig> as well as from g <dig> to g <dig> 

we have devoted much effort to differentiating between unsequenced genes and genes that are truly absent from the genome. our goal here has been to predict the location of those genes that are missing because of incomplete sequencing or unsuccessful gene identification, not those genes that are absent because they have been deleted from ricinus over time or acquired by vitis since the divergence of the two lineages. yet the latter class of genes are forced into our ricinus reconstruction, because we have no a priori way of knowing they are actually absent from ricinus. our procedure would work equally well if instead of using all the missing vitis genes, we used only those for which we had unigene, est, rna sequence or other cdna evidence of their existence in ricinus. we could then apply our algorithm to reconstruct the ricinus gene order based on that of a reduced version of vitis where all the genes with no ricinus ortholog would be deleted at the outset from the vitis gene order.

we discussed the case of bac sequencing where the scaffolds are anchored on chromosomes so that there is no issue of optimal scaffold fusion. gaps can still occur between bacs, and even inside bac sequence assemblies, depending on the strategies and policies of the sequencers. here our algorithm would require no modification to do a rearrangement analysis and ortholog insertion.

there are many occurrences of non-uniqueness in rearrangement inference and ortholog insertion in applying methods such as ours. this precludes a straightforward comparison of  with the pre-deletion simulated genome to validate the method. however, non-uniqueness can sometimes be partially resolved by examining elements in common from many optimal solutions.

it bodes well for future use of this methodology that our algorithm was efficient enough to solve the problem with over  <dig>  genes in less than a minute of computing time on a laptop computer, putting virtually all genomes within range of this technology.

availability
the program implementing scaffold filling is included in this paper as additional file  <dig> 

authors' contributions
am, cz and ds formulated the problem, devised and proved the algorithms, carried out the data analysis and simulations, and wrote the paper. qz constructed the scaffold data base. vaa and sr provided motivation and help in formulating the problem, suggested the genomes to analyze and helped interpret the results and write the paper. all authors read and approved the final manuscript.

supplementary material
additional file 1
contains the java code for the fillscaffolds algorithm, including class files and sample input data, as well as user instructions and a list of environments in which the program has been tested.

click here for file

 acknowledgements
research supported in part by a discovery grant to ds from the natural sciences and engineering research council of canada  and a postdoctoral fellowship to cz from the same agency. ds holds the canada research chair in mathematical genomics.
