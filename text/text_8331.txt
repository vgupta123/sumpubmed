BACKGROUND
deep sequencing of mrna using next-generation sequencing technologies  offers novel opportunities to profile and quantify whole transcriptomes. the nucleotide-level resolution of rna-seq experiments provides new insights for researchers into the complexity of alternative splicing and isoform expression  <cit> . one major challenge in rna-seq is the identification  of the origin of each sequenced read, i.e. which part of which transcript it corresponds to. as this requires the alignment of a huge number  of relatively short sequence reads against reference sequences, such as e.g. a genome or transcriptome, a number of specialized alignment algorithms have been developed. here, algorithms based on the fm-index - a compressed, searchable suffix array-like structure  <cit>  - have been most successful due to their reduced time and memory requirements. the most widely used of these algorithms is bowtie  <cit> .

the complex structure of a spliced transcriptome compared to the genome limits the applicability of simple alignment-based approaches for rna-seq experiments. while an alignment against the genome can successfully map reads from an unspliced region of the transcriptome, such as individual exons or introns, reads from spliced regions are missed. to some degree, this problem can be addressed by an alignment against a known transcriptome or a database containing exons and all possible junctions between these exons  <cit> . however, in the first case, the sensitivity of this approach depends strongly on the completeness of the annotated transcriptome and novel splice junctions will be missed. in the second case, the number and complexity of potential junction reads increases dramatically with increasing read length resulting in forbiddingly large databases.

as a consequence, a large number of more sophisticated bioinformatics approaches have been developed for the identification of junction reads. one of the first tools was tophat  <cit>  which is able to discover splice sites without the use of a transcriptomic annotation. in a first phase, reads are aligned to a reference genome using bowtie and the mapped reads are then assembled to so-called islands. subsequently, potential splice sites are annotated based on canonical splice signals and reads spanning these splice sites are identified. in contrast, two more recently published methods, rum  <cit>  and rnaseqr  <cit> , start with read alignments to both the reference transcriptome and genome. novel splice junctions are then identified by aligning unmapped reads to the genome using blat  <cit>  which determines gapped local alignments. a gapped alignment only becomes feasible here because it is applied to the much smaller number of unaligned reads.

thus, all of these approaches rely heavily on additional information such as canonical splice sites or reference transcriptome annotations. a more sophisticated approach which is independent of the availability of such additional information is mapsplice  <cit> . the general idea of mapsplice is that it first generates candidate alignments for each read based on alignments of short fragments of the read against the genome. splice junctions are then predicted based on all candidate alignments for different reads containing the respective splice site. thus, in contrast to previous approaches mapsplice takes into account the context of a splice site, i.e. how many reads support the predicted splice site.

while this approach is interesting, there are still a few limitations. first, the context of other read mappings is taken only into account for potential splice sites. for reads mapping to an unspliced region, the context is ignored. second, only spliced read alignments are considered but not unspliced reads within this range. in particular, unspliced reads ending or starting at the potential splice junction might lend additional support to the splice site. third, for each fragment only the alignments with the minimum number of mismatches is considered ignoring the possibility that the alignment to the correct origin may have more mismatches due to sequencing errors. finally, although non-unique alignments are outputted by mapsplice, no effort is made to resolve them. while some downstream analysis methods have been developed which can deal with this uncertainty , often these multi-maps are simply discarded and, thus, lost for the analysis.

in this article, we present a novel method  which extends the idea of using the context of other read alignments for identifying the correct position for each read. this method is more general than mapsplice as it uses the context not only for splice junctions but also non-spliced read alignments and always uses both spliced and unspliced read alignments. the general idea of the approach is not to assign each read to the position where it can be aligned with the fewest mismatches, but to the position where it fits best in the context with its surrounding and all other reads. for this purpose, we allow a high degree of ambiguity during the mapping stage which is eventually resolved in the final mapping. thus, contextmap is robust against biases caused by sequencing errors and may also be used for correction of sequencing errors.

contextmap can be used in stand-alone and incremental mode. the incremental mode starts with an initial alignment of a mapping method of choice and refines this initial mapping. in the stand-alone mode, it obtains this initial mapping by first aligning the reads to the genome, the transcriptome or both. in the implementation we present here, contextmap uses as initial context the unique mapping identified by mapsplice or tophat. evaluation on simulated reads for human and mouse showed a significant improvement in mapping quality of the contextmap refinements compared to both mapsplice and tophat. this highlights the importance of using the read context for obtaining the final mapping.

methods
outline
the central concept of contextmap is a context of reads. a context is a set of reads which all originate from the same expressed stretch of the genome. in general, such a context corresponds to an individual gene but may also correspond to a few overlapping or closely located genes. at any step of contextmap, only reads within the same context will be considered for assigning a position to the read within the specific context considered. at least initially, however, reads may be assigned to different contexts and in this case are assigned a position for each context. this ambiguous assignment of reads to contexts is eventually resolved in the final step of contextmap.

contextmap then consists of the following three steps :  the definition of initial contexts using a preliminary mapping of reads;  the extension of the preliminary mapping by re-aligning reads within their respective contexts;  the resolution of ambiguous mappings both within and between contexts to obtain a final unique mapping. here, the advantage of using contexts is that we can allow a much larger degree of ambiguity during the second step, as ambiguities are limited to individual contexts and not the whole genome and the contexts allow us to resolve the ambiguities successfully. in the following, the individual steps are explained in more detail.

identification of contexts
the initial step of contextmap requires the definition of contexts, i.e. the definition of reads from the same expressed region of the genome . here, the preliminary context does not have to be fully correct as it only roughly defines putatively expressed regions. in particular, the precise alignment of the reads is of lesser importance, as reads will be realigned in a subsequent step to identify a larger number of candidate alignments.

there are several ways in which a context can be identified. the solution we implemented for this study is to use the alignment of other mapping algorithms such as mapsplice or tophat which we aim to improve upon. in this case, all unique mappings determined by the used method are included. alternatively, contextmap can identify contexts itself by an initial alignment of reads to the genome using the forward and backward approach described in the following section. potential splice junction reads are then identified by searching for easily detectable  splits. instead of an alignment to the genome, an alignment to the transcriptome may also be used to identify the initial mapping.

the contexts are then defined based on the genomic distance between aligned reads. reads with a maximum distance of dmin between start or end positions are collected into the same context. accordingly, the minimum distance between contexts is dmin. note that contexts may contain regions without mapped reads larger than dmin if these regions are contained within the spliced part of a read, i.e. an intron. the distance threshold can be adjusted if smaller or larger contexts are desired. in this study, dmin was set to  <dig> kb. alternatively, gene annotations may be used to define contexts, which then limits the mapping to known genes.

extension of candidate mappings
the first part of this step is a re-alignment of previously unmapped or non-uniquely mapped reads to each context . in the following, alignents containing no splice site are denoted as full, whereas alignments to splice sites are denoted as split alignments/reads. in this step, all full and split alignments fulfilling a maximum mismatch criterion are generated using bowtie in the following way. for each context, both a forward and backward bowtie index is created. using these indices, reads are then aligned to the contexts both in forward direction starting from the read start and in reverse direction starting from the read end. for both alignments a seed of 40% of the read  is used allowing a maximum number of  <dig> mismatch in the seed region. again, these are parameters which can be adjusted by the user depending on read length and expected error rates. forward and backward alignments are then combined if the maximum number of mismatches in the alignment does not exceed the predefined threshold.

these alignments as well as the initial alignments provide a set of potential splice sites for each context. each splice site is characterized by two sequence positions  such that any read covering the splice site will first align on the genome upstream of and up to s <dig> and then continue to align at s <dig> and downstream of this position. using the potential splice sites for each context, additional alignments are generated in the following way . for reads which have a full alignment crossing either s <dig> or s <dig> for a splice site, any alignment respecting the splice site and fulfilling the maximum mismatch criterion is generated. the same is done for partial read alignments in which the read could be aligned except for a small fragment at the start or the end, but the fragment was to small to obtain a meaningful alignment. as the number of potential splice sites suggested by alignments of other reads is limited, all of these splice sites can be tested whether they allow an alignment of the unaligned fragment fulfilling the maximum mismatch criterion.

resolution of ambiguities
redundancy filtering
having generated a large number of ambiguous mappings for each read and context which respect the maximum mismatch criterion, the next step is then to resolve the ambiguities within each context before addressing the ambiguities between contexts . to not unnecessarily bias this step by reads which will be later removed anyway as they are assigned to a different context, we use an additional parameter which specifies the maximum mismatch difierence  for a read in any context to the best-matching context. for this purpose, we calculate for each read and each context the minimum number of mismatches in any of the candidate alignments. if the best match of a read in a context c requires >δmm mismatches more than in the best-matching context, the read is removed from c.

to further simplify the resolution process, full and split mappings with either the same start or end position are merged for this step. the final configuration for these reads  is then determined at the end of this step. in addition, we identify the best supported splice site among any pair of overlapping splice sites . two splice sites  and  are overlapping if |s <dig> - s21| < read length and |s <dig> - s22| < read length. the idea behind this approach is to eliminate splice sites which are too close to each other and, thus, make no biological sense or are suggested by alternative split alignments of the same read. for this purpose, we calculate the number of supporting reads  for each splice site and the corresponding mismatch cost and check which of the splice sites has a known splice signal. in the following, let ni be the number of reads with i mismatches supporting the splice site and m the maximum number of mismatches allowed. furthermore, λ =  <dig> if the splice site contains a known splice signal and λ =  <dig> otherwise. the evidence score is then calculated as

  evidence=λ⋅∑i=0m <dig> i⋅ni, 

thus, the score is the weighted sum of the number of reads with the weight decreasing exponentially with the number of mismatches. for each set of pairwise overlapping splice sites, the one with the largest evidence score is then chosen.

calculation of read coverage scores
to obtain the unique mapping of each read within each context, we calculate a coverage score for this read in the following way . first we calculate for each position the number of reads mapping to this position . if there are ambiguous mappings for a read, it is counted for all positions in any of the ambiguous mappings. we then define  <dig> regions within and around the mapped read. region  <dig> contains the positions the read is aligned to. region  <dig> contains all positions  <dig> bp either upstream of the read start or downstream of the read end. region  <dig> corresponds to the positions >  <dig> but ≤  <dig> bp from read start or end and, finally, region  <dig> to positions >  <dig> but ≤  <dig> bp from read start or end. the score for each region, scorei, is then defined as the maximum cm within the corresponding region i. region sizes and numbers may be adjusted depending on the user needs.

finally, the coverage of a read is calculated as

  coverage=∑i=1424-i⋅lnscorei. 

this calculation involves three aspects. first, the definition of regions for which the maximum cm is calculated allows to take into account reads mapping very far from the actual read alignment without assigning too much weight to distant reads. the larger the region, the less weight is given to reads falling in this region. second, the individual region scores are additionally weighted depending on the distance from the actual read alignment. reads overlapping the alignment region have the largest weight and each region has a weight twice as high as the next more distant region. finally, instead of the actual read counts logarithms of the counts are used, reflecting their order of magnitude. in this way, this coverage definition is related to the geometric mean of the scores which is less biased by large outliers than the arithmetic mean.

priority queue and ambiguity graph
the ambiguous reads are then put into a priority queue sorted by the difference in coverage score between the best and second-best ambiguous mapping . furthermore, a graph structure is created for each context in which each ambiguous read is connected with the positions in this context to which it maps . thus, the ambiguity graph provides the information on which coverage scores have to be updated if a read is assigned to a unique position.

we then iteratively remove the entry with the highest score from the queue, i.e. the entry for which the ambiguity resolution is the most straightforward. subsequently, we update the coverage scores based on the dependencies identified by the graph structure and then update the keys in the queue. finally, when the queue is empty, all ambiguous reads have been assigned a unique location within the respective context. for a speed-up, the costly coverage updates were omitted in this study and ambiguities are resolved only based on the highest  coverage score.

in the last part of this step, the assignment for the merged full and split mappings with either same read start or end is resolved. for this purpose, coverage scores are again calculated but this time only for the positions which are differently mapped by the alignment and the positions upstream of the read starts, in case of differential start points, or downstream of the read end, in case of differential end points. the alignment with the largest coverage is then chosen.

to resolve the between-context ambiguities, we basically perform the same steps as for each individual context by calculating coverage scores for each context and using a priority queue based on the coverage differences and a global dependency graph between reads and contexts. finally, resolved read mappings are outputted if the relevant region suggests a real expression. currently, we predict reads with at least  <dig> other reads mapped in a region within  <dig> bp up- or downstream of the read. these are again user-defined thresholds.

RESULTS
simulation of rna-seq data sets
all approaches were evaluated on simulated human  and mouse  reads. for the human reads a  <dig> bp single end rna-seq data set was generated with the flux simulator  <cit> . since flux was too slow for simulating reads for the whole human genome we restricted the simulation to chromosome  <dig> and obtained a final set of  <dig>   <dig> reads. we then randomly introduced sequencing errors into this original read set to obtain two data sets with 1% and 2% uniformly distributed errors, respectively . since sequencing quality generally deteriorates towards the end of the read, we also simulated reads with error probability increasing along the read length . in this case, the overall error rate was again fixed at 1% or 2%, respectively, but the position of the error in a read was drawn from a polynomial distribution with cumulative distribution function fx=1l3x <dig>  where l is the read length.

for the mouse read data, we used an evaluation set published by grant et al. in the rum algorithm  <cit> , restricted to reads mapping to ensembl transcripts. it contains  <dig> , <dig> single end  <dig> bp reads. in the original rum simulation model, two types of errors were simulated: random base and tail errors. base errors were uniformly distributed across the whole read and tail errors only in the tail of a random fraction of the reads. for our purposes, we used the first test set with a base error of  <dig> % and no additional tail error. the second test set with an additional tail error of 50% in the last  <dig> bases of 25% of reads was not used. in this case, trimming of reads by the last  <dig> bases would always result in a significantly improved performance. to test the performance for higher error rates, we also introduced sequencing errors in the mouse data set to obtain two sets with uniformly distributed 1% and 2% error rate, respectively.

the objective behind using two different error rates each for each data set was to have both a relatively easy data set with few sequencing errors as well as a more challenging set with a larger error rate. in the first case, we expect little reduction of the performance due to error rates. in the second case, a large influence is expected.

baseline mapping algorithms
to show that our approach is able to further improve the results of widely used mapping and junction discovery tools, we applied contextmap to mappings which were produced with mapsplice and tophat. both of them are popular programs that are able to map rna-seq reads to a reference genome without using a transcriptome annotation. tophat mappings were obtained allowing at most  <dig> mismatches per segment and read. for mapsplice we used default parameter settings except for the spliced mismatch parameter. for this we used  <dig> as otherwise mapsplice performed poorly for the data sets with a larger error rate. contextmap was then applied both on the tophat and mapsplice mappings.

read mapping accuracy
to evaluate the accuracy of a mapping, we calculated the accuracy of read mapping, i.e. the fraction of reads aligned to the correct positions. this was done separately for reads which were simulated as complete reads as well as for reads spanning a splice junction. a uniquely mapped read is counted as an exact true positive  if it was mapped correctly at every base. in case a read was either an exact match or at least the start or the end position on the genome was correctly predicted, we counted it as a relaxed true positive. reads not  mapped or mapped to wrong positions were treated as false negatives . accuracy was then calculated as

  accuracy=tptp+fn. 

evaluation results are shown in tables  <dig> and  <dig> for the human and mouse data sets, respectively. as expected, all approaches performed best for complete read mappings and performance deteriorated considerably for the junction read mappings. however, if also we include the cases in which at least either the start or the end position of the read was predicted correctly, we see that in many cases at least part of the read could be mapped correctly.

accuracy of read mapping is reported for the two human data sets with 1% and 2% error rate, respectively. here, contextmap <dig> denotes the refinement of tophat initial mappings by contextmap, contextmap <dig> the refinement of mapsplice initial mappings.

accuracy of read mapping is reported for the two mouse data sets with 1% and 2% error rate, respectively. notation is the same as in table  <dig> 

our results clearly show that for both mapsplice and tophat, contextmap could improve significantly upon the predictive performance of the original mapping. in almost all cases, both variants of contextmap outperformed both mapsplice and tophat and in all cases at least one variant performed best. interestingly, although mapsplice performed significantly worse than tophat on the human data sets, contextmap on mapsplice outperformed contextmap on tophat for the complete reads on the 1% error rate set by a small margin and was only worse by a similar small margin on the 2% error rate set. this was particularly impressive as in these cases mapsplice was >  <dig> percentage points worse than tophat on the complete reads. although mapsplice is usually a good mapping algorithm, we found that determining the optimal parameter settings for data sets with high error rates is rather difficult. in this case, contextmap provides a useful alternative to parameter tuning as predictions can be refined considerably even if the parameter settings for mapsplice are not optimal.

to analyze whether alignment accuracy depended on read coverage, genes were partitioned into four approximately equal-sized groups based on the average number of reads per base. for each group, accuracy values were then calculated separately. this analysis showed that performance for complete reads without splice sites was mostly independent of read coverage . in contrast, for junction reads, accuracy depended strongly on read coverage . generally, the higher the coverage was for a gene, the higher was the accuracy of the corresponding read alignments. thus, read coverage is important for the identification of  splice junctions, likely due to the much larger number of possible alignments, but not for alignment of reads originating from unspliced transcript regions. nevertheless the relative ranking of the evaluated mapping approaches was generally only little influenced by read coverage. interestingly, on the mouse 2% error data set , contextmap on mapsplice only outperformed contextmap on tophat for splice junctions in genes with highest read coverage. since these genes contribute the largest set of reads to the overall read set, they mostly determined overall accuracy values and, accordingly, overall performance of contextmap on mapsplice was also superior.

interestingly, we found that alignment accuracy for both complete and junction reads depended little on the distribution of errors along the reads. alignment accuracy on the human data set was almost identical no matter whether we used uniform or polynomial error distributions along the read length. the only method that suffered consistently from a non-uniform error distribution was tophat with a decrease of around  <dig> percentage points for both types of reads on the 2% error data set with polynomial error distribution. remarkably, however, accuracy of contextmap on tophat mappings was not reduced for the complete reads on this set despite the reduced quality of the initial mapping. only accuracy for junction reads suffered but still was significantly higher than for tophat and mapsplice, respectively.

finally, we evaluated parameter sensitivity of contextmap by running it with different seed lengths  and different minimum expression values for contexts  on the human data sets. for both tophat and mapsplice original mappings, we generally observed only minimal variation in accuracy with standard deviations of <  <dig>  and <  <dig>  percentage points for the seed  and minimum expression value parameters, respectively. the largest variation was observed on junction reads for the seed length parameter with a standard deviation of  <dig> - <dig>  percentage points. remarkably, alignment accuracy was actually increased by using shorter seed lengths due to a larger number of junction reads correctly aligned. unfortunately, it also resulted in a slight increase in the number of junction reads aligned incorrectly instead of not at all as in the case of longer seed lengths.

runtime
contextmap increases the accuracy considerably compared to the baseline mapping programs. however, this comes at the cost of additional runtime as it requires running both the baseline mapping algorithms for the initial mapping as well as contaxtmap for mapping refinements. table  <dig> lists the runtime required for each step on  <dig> cores of identical machines with  <dig> g ram. here, several observations can be made. first, runtime of mapsplice was reduced by a factor of more than 50% compared to tophat. unfortunately, this reduced runtime also came at the cost of a significantly reduced accuracy. second, the additional runtime required by contextmap was very similar no matter which of the initial mappings was used. as a consequence, the relative runtime overhead created by contextmap was much smaller for tophat than for mapsplice. however, as the accuracy of mapsplice deteriorated considerably for the 2% error data sets, the additional runtime required by contextmap payed off in a tremendous increase of accuracy in these cases. finally, the combination of mapsplice with contextmap required only little extra runtime compared to tophat alone  but outperformed tophat substantially with the only exception of junction reads for the human 2% error rate set.

elapsed user times in minutes on the evaluated data sets is shown for each program. every method was run using  <dig> cores on identical machines with  <dig> gb ram. here, runtime for contextmap <dig> and contextmap <dig> is the time required for the refinement step of contextmap on the initial mappings provided by tophat and mapsplice, respectively. it does not include the time required to obtain the initial mappings.

CONCLUSIONS
in this article, we presented a novel approach for the mapping of sequencing reads from rna-seq experiments. in contrast to previous approaches, contextmap fully exploits the information on the context of a read, i.e. reads mapping in the vicinity of a read considered. accordingly, contextmap consists of three steps. first, the contexts are determined based on a preliminary mapping. second, reads unmapped in the first step are aligned to the context and existing alignments are extended based on potential splice sites suggested by other alignments. in this step, all alignments satisfying the maximum mismatch criterion are taken into account for each context. finally, the best alignment for each read is determined first for each context and then the optimal context is determined for each read.

by addressing the problem of finding the best position for each gene separately for each context, the problem size is reduced considerably. this allows evaluating a much larger number of possible alignments and accordingly positions for each read within each context. thus, instead of considering the context only for the prediction of splice sites as done by mapsplice, we can take it into account for both complete and junction reads.

although contextmap can also be applied to preliminary mappings from genome or transcriptome alignments, one major application is the refinement of mappings provided by other mapping algorithms such as tophat and mapsplice. based on the analysis on simulated rna-seq experiments for human and mouse, we could show that our refinement using contextmap could improve considerably upon the accuracy of both tophat and mapsplice predictions. in most cases, refinements of either mappings by contextmap outperformed both original mappings. thus, even if large fractions of reads are already correctly mapped by both approaches, mapping quality can still be improved for a substantial number of reads by evaluating the support of alternative mappings in the context of all other reads. furthermore, if finding the optimal parameter setting is difficult as for mapsplice on the 2% error data sets, contextmap provides a useful alternative as it obtains high accuracy even if the original mapping quality was relatively low.

competing interests
the authors declare that they have no competing interests.

authors' contributions
ccf and rz designed the study and participated in analyzing the results. gc and tb designed contextmap and evaluated its performance. gc implemented the contextmap prototype. ccf drafted the manuscript. all authors were involved in revising the manuscript and read and approved the final version.

