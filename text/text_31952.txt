BACKGROUND
finding motifs or repeated patterns in data is of wide scientific interest  <cit>  with many applications in genomic and proteomic analysis. the motif search problem abstracts many important problems in analysis of sequence data, where motifs are, for instance, biologically important patterns. for example, elucidating motifs in dna sequences is a critical first step in understanding biological processes as basic as the rna transcription. there, the motifs can be used to identify promoters, the regions in dna that facilitate the transcription. finding motifs can be equally crucial for analyzing interactions between viruses and cells or identification of disease-linked patterns. discovery of motifs in music sequences, text, or time series data is a fundamental, general means of summarizing, mining and understanding large volumes of data. for the purpose of this study, motifs are  patterns that occur in an exact or approximate form in all or most of the strings in a data set. consider a set of input strings s of size n = |s| constructed from an alphabet Σ. the solution for the -motif finding problem  is the set m of k-mers , m ⊆ Σk, such that each motif a ∈ m, |a| = k, is at minimum hamming distance of at most m from all  strings s ∈ s.

in this work, we focus on a deterministic, exhaustive approach to motif search. exhaustive motif finding approaches are guaranteed to report all instances of motifs in a set of sequences, but are faced by the exponential complexity of such search. as a consequence, the problem quickly becomes intractable for even moderately long motifs and small alphabets. we present a new deterministic algorithm for finding common patterns with the search complexity that scales well with the size of the alphabet. compared to existing algorithms in this class  that have strong dependency on the alphabet size and work with small-alphabet input, our algorithms significantly improve search efficiency in the important case of large-alphabet inputs  and inputs of large length. as we show in the experiments, using both synthetic and real data, our algorithms are orders-of-magnitude faster than existing state-of-the-art deterministic search algorithms, especially on large-alphabet inputs . this result extends applicability of the exact motif search algorithms to more complex problems requiring analysis of biological sequence data modeled as strings over large alphabets. the problem of motif discovery has been tackled extensively over the past two decades  <cit> . within the class of exhaustive methods, a number of approaches have been proposed, including graph methods   <cit> , explicit trie traversal   <cit> , explicit mapping   <cit> , suffix trees  <cit> , sorting and enumeration  <cit> , etc. existing exhaustive algorithms use explicit exploration of the motif space and require time proportional to the size of the neighborhood of a k-mer, i.e. the number of k-mer sequences at hamming distance of at most m from it. this size,  depends on the alphabet size, and can lead to high computational complexity and running times, as shown in table  <dig> 

explicit mapping  algorithms proposed in  <cit>  use an indicator array v of the maximum size |Σ|k to find motifs through voting. each length-k substring observed in the input has at most one vote for each input sequence and gives this vote to all of its v neighbors. the substrings that occur in every input string will receive n votes and will be included in the output motif set m. the algorithm takes o time and requires at least o space. the large space requirement of the algorithm restricts its usage to small values of k and m, as well as to small alphabet size |Σ|.

one of the most efficient exact algorithms for motif search, the mismatch tree  algorithm  <cit> , uses efficient trie traversal to find a set of motifs in the input strings. under a trie-based computation framework  <cit> , the list of k-long contiguous substrings  extracted from given strings is traversed in a depth-first search manner with branches corresponding to all possible symbol substitutions from alphabet Σ. each leaf node at depth k corresponds to a particular k-mer feature  and will contain a list of matching features from each string. the leaf nodes corresponding to motifs will contain instances from all  strings. the complexity of the trie-based traversal algorithm for motif finding is o. note that the algorithm essentially explores the neighborhood of all o k-mers in the input.

another class of efficient algorithms is based on sorting and enumeration  <cit> . the pmsp algorithm enumerates all possible neighboring k-mers for the first string s <dig> and outputs k-mers that occur in every string with hamming distance at most m, similar to the voting algorithm  <cit> . the pmsprune algorithm  <cit>  employs a more efficient search strategy to traverse the candidate space and is an improvement, in the expected case, over the pmsp. we note that explicit enumeration is employed by all above-mentioned algorithms.

while the exact algorithms focus on retrieving all possible motif patterns, an important issue of estimating significance of the found motif patterns can be addressed with existing techniques as used in, for instance, non-exhaustive algorithms based on stochastic optimization .

in contrast to existing exact exhaustive algorithms, we approach the problem of motif finding by performing an efficient search over patterns with wildcards. as a consequence, the proposed method’s complexity becomes independent of the alphabet size.

methods
combinatorial algorithm for motif search
in this section, we develop an efficient combinatorial algorithm for motif finding with the search complexity independent of the size of the alphabet |Σ|. the algorithm begins by finding a set of candidate motifs, followed by the construction of the intersections of those candidates’ neighborhoods, the sequences that are at most m symbols apart from each candidate pair. in a crucial departure from other approaches, this set is efficiently represented using stems, or patterns with wildcards. the number of the stems does not depend on the alphabet size and is a function of the motif length , the number of mismatches  and the hamming distance between k-mers. patterns common to all  input strings are then found by pruning the stems that do not satisfy the motif property . the main idea of our approach is to construct a candidate set c which includes all motifs m plus some non-motifs, i.e. m ⊆ c, and then efficiently select true motifs from the candidate set. given c, the complexity of motif finding is then proportional to its size: the motifs can be extracted from c by checking each candidate against the motif property, a task we accomplish using  rounds of counting sort in algorithm  <dig>  to generate c, we collect the sets of stems which characterize the common neighbors of the pairs of k-mers  in the input. we call these sets the stem sets, h. finding each h is independent of the alphabet size and is accomplished in algorithm  <dig>  to further reduce the complexity, we construct the stem sets only for potential motif instances i, those k-mers that are at hamming distance of at most 2m from every input string. we find i using  rounds of counting sort . we outline our motif search algorithm below:

algorithm  <dig> algorithm  <dig> motif search algorithm

this algorithm uses as its main sub-algorithm  a procedure that finds the intersection of k-mer neighborhoods for any pair of the k-mers a, b. this intersection finding algorithm is described in section ‘motif generation’. we describe selection and pruning steps  in section ‘selection algorithm’.

the overall complexity of the algorithm is  where h is the maximum size of h, and i is the size of i, the number of k-mers used to construct the candidate set c. the important fact that makes our algorithm efficient in practice is that typically i ≪ min and h ≪ v, particularly for large alphabets. we demonstrate this in our experimental results and provide an expected-size analysis in section ‘selection algorithm’.

selection algorithm
a necessary condition for a group of k-mers to have a shared, common neighbor  is that the hamming distance between any pair of patterns cannot exceed 2m. we will use this condition to select k-mers from input that are potential motif instances and place them in set i. a particular k-mer a in the input is a potential motif instance if it is at the minimum hamming distance at most 2m from each of the input strings. all other k-mers that violate the above condition cannot be instances of a motif and can be discarded. to select the valid k-mers, we use multiple rounds of count sort by removing iteratively 2m out of k positions and sorting the resulting set of -mers. a k-mer is deemed a potential motif instance if it matched at least one k-mer from each of the other strings in at least one of the sorting rounds. the purpose of sorting is to group same k-mers together. using a simple linear scan over the sorted list of all input k-mers, we can find the set of potential motifs and construct i. this algorithm is outlined in algorithm  <dig>  as we will see in the experiments , the selection step

algorithm  <dig> algorithm  <dig> selection algorithm

significantly reduces the number of k-mer instances considered by the algorithm and improves search efficiency. the number of selected k-mers, i.e. the size of i, is small, especially for large-alphabet inputs. this can be seen from the expected case analysis. for this purpose we assume that sequences are generated from a background process with few motifs implanted in the background-generated sequences. assuming an iid background model with equiprobable symbols, the expected number of k-mers in the input of n strings of length n that match each of the n strings with up to 2m mismatches by chance is   

where pk,2m is the probability that two randomly selected k-mers are at distance of at most 2m. for instance, for a set of n =  <dig> protein sequences  of length n =  <dig> the expected number of potential motifs of length k =  <dig>  m =  <dig> by chance is about  <dig>  with p <dig>  =  <dig>  10− <dig>  given t implanted motif instances, the average number of k-mers that will be selected from nn input samples, or the expected size of i, is

e = t + nnt) + e.

since t and p are typically small, for small pn, e ≪ nn, the number of k-mers in the input. in the protein example above the expected size of i is about  <dig> +  <dig> + 8= <dig> for t =  <dig>  which is orders of magnitude smaller than nn =  <dig>  signifying the importance of creating i first. this is empirically demonstrated in section ‘results and discussion’.

pruning using selection
the sorting approach of algorithm  <dig> is also used to select patterns satisfying the motif property from the candidates c . the pruning step is based on verifying the motif property  and can be accomplished using  rounds of counting sort.

motif generation
in what follows, we describe an efficient algorithm that finds the set of stems that represent the set of k-mers shared by a pair of k-mers a and b. this process is used to create set c from potential instances i, which is subsequently pruned to yield the true motif instances.

the number of k-mers in the common neighborhood of any two particular k-mers a and b assumes a fixed set values depending on the hamming distance d between k-mers  <cit> , for given values of |Σ|, k, and m. we want to represent the shared k-mers in this intersection using a set of stems, patterns with wildcards. however, the number of stems will not depend on the alphabet size |Σ|.

to find all stems shared by k-mers a and b, consider two sets of positions: mismatch region in which a and b disagree and match region in which a and b agree. we consider two cases depending on the number of mismatch positions . in the first case, the distance d is at most m, the maximum number of mismatches allowed. in the second case, the distance d exceeds m. when d ≤ m, wildcard characters can appear both inside and outside of the mismatch region. when d >m, wildcard characters can appear only inside the mismatch regions. consider for example, the case of d =  <dig> and m =  <dig>  in this case, the set of stems is the set of patterns with  <dig> wildcard at each of the possible k positions  plus one stem with  <dig> wildcards. when m =  <dig>  and d =  <dig>  the set of stems will include patterns with  <dig> or  <dig> wildcard in k − d positions and  <dig> or  <dig> wildcards in the remaining d =  <dig> positions. for example, for the pair  the corresponding patterns with wildcards are tg?, t??, ?g?, t?c, and ?gc, where ? denotes a wildcard.

we outline our algorithm for finding set of stems for the k-mer neighborhood intersection in algorithm  <dig>  the number of stems generated by the algorithm is  

the number of stems describing all the explicit k-mers shared between a, b does not depend on the alphabet size. the complexity of the stemming algorithm is proportional to the number of stems generated. the maximum number of stems h is  for typical values of m <k/ <dig>  we use algorithm  <dig> for every pair of k-mers in i  to construct c as outlined in the main algorithm.

algorithm  <dig> algorithm  <dig> stem generation 

algorithm analysis
the complexity of the selection step  <dig> for constructing i is  and does not depend on the alphabet size |Σ|. steps  <dig> and and  <dig> have the complexity  and again do not depend on |Σ|. as a consequence, the three-step procedure gives us an efficient, alphabet-independent motif search algorithm that outputs all motifs embedded in the input s. our experiments will next demonstrate that this allows efficient exploitation of sparsity of typical solutions—we explore only a small portion of the motif space by focusing  only on the support samples that are potential instances of the motifs. this results in significant reductions in running times, especially for large-alphabet inputs, i.e. the cases difficult for the current exact motif finding algorithms.

extensions
our proposed framework can be used to reduce search complexity for other exact search-based motif finding algorithms. existing exhaustive algorithms typically  use the entire input  and find motif by essentially exploring neighborhoods of every k-mer in the input. their search complexity can be improved by using a reduced set of k-mers instead of all input samples. this reduced set of k-mers can be obtained using our linear time selection algorithm . using reduced set of k-mers, the actual search complexity after the selection step becomes sublinear in the input size ). for instance, the search complexity of the trie-based algorithms  can be reduced to  instead of o), where v is o. this will lead to a more efficient search especially for large-alphabet since a possibly large input ) is replaced with a smaller set i of k-mers that match with up to 2m mismatches every string in the input.

RESULTS
we evaluate our algorithms on synthetic benchmark motif finding tasks and real data sets. we first test our algorithms on the planted motif problem commonly used as a benchmark for evaluation of the motif finding algorithms  <cit> . we then illustrate our method on several dna and protein sequence data sets.

planted motif problem
a planted motif problem  <cit>  is the task of finding motifs and their instances in a set of sequences with variants of the consensus string  implanted with up to m mismatches in every string. this task represents a well-defined subtle motif discovery problem. instances of this problem with large number of mutations m are known to be challenging for most of the motif finding algorithms.

we follow the standard setting used in previous studies  <cit>  and generate n =  <dig> random strings of length n =  <dig> using iid, uniformly distributed symbols from an alphabet of size |Σ|. we then embed a copy  of a motif at a random location in every string. the task is then to identify motifs hidden in the input.

in table  <dig>  we compare the running time of our algorithms with state-of-the-art motif finding algorithms on several challenging instances of the planted motif problem. we give the running time comparison for large-alphabet  instances in table  <dig>  as we can see from the results in table  <dig> and table  <dig>  our algorithms show significant reduction in running times compared to state-of-the-art methods, especially for large-|Σ| inputs . for large alphabets and large k,m trie traversal takes substantial amount of time and results in these cases are not reported. in figure  <dig>  we show the running time ratio  between the mismatch trie traversal  algorithm and our algorithm as a function of the alphabet set size. the running time is measured on  instances of the planted motif problem. for relatively small alphabet of size  <dig> our algorithm is about  <dig> times faster than the mismatch trie. the difference in running time increases with the size of the alphabet. large alphabets can, for instance, arise when encoding the 3d protein structure, a necessity in cases when sequences share little similarity at primary level.

identifying tf binding sites
we use several data sets with experimentally confirmed tf binding sites: crp, fnr, and lexa. the crp data set contains  <dig> dna sequences of length  <dig> with one or two crp-binding sites  <cit> . the fnr and lexa data sets are obtained from regulondb  <cit>  database and contain  <dig> and  <dig> sequences known to have sites of length  <dig> and  <dig> bases. the task is to identify the sequence motif corresponding to the binding sites and the positions of sites within sequences.

for crp, we use relatively long k-mers of length k =  <dig>  with a large number of allowed mismatches  from a given set of  <dig> dna sequences . for fnr and lexa data sets, we set motif length to k =  <dig> and k =  <dig> bases, with the maximum number of mismatches set to m =  <dig> and m =  <dig>  respectively.

for fnr and lexa motifs, our algorithm correctly finds consensus patterns ttgatnnnnatcaa and ctgtnnnnnnnnncag, in line with the validated transcription factor binding sites, with the performance coefficients  <cit>  of  <dig>  and  <dig> .

protein motif finding
we also apply our algorithm to finding subtle sequence motifs on several protein sequence datasets, a challenging task due to the increased alphabet size  coupled with large k and m.

lipocalin motifs. we first consider motifs in lipocalins which are topologically similar but have very diverse primary sequences. using k-mer of length k =  <dig> with m =  <dig> mismatches, we identify motifs containing  <dig> residues with the instance majority fdsfagtwyeak , which agrees with the known reference motif  <cit> . our algorithm takes about  <dig> minutes to complete this task, while the mismatch trie algorithm takes more than a day. as in the case of the dna, a large number of mismatches is critical for finding motifs, while smaller values of k, m do not result in motif identification. 

zinc metallopeptidase motif. in this experiment,  <dig> relatively long  human zinc metallopeptidase sequences used to test motif finding. identification of subtle motifs in this case is made even more challenging by the length of the sequences. we use  <dig> residues long k-mer with m =  <dig> mismatches and find sequence motifs with the instance majority vaahelghsg in  <dig> out of  <dig> sequences that correspond to previously confirmed locations. we note the large number of mismatches  was critical to motif identification.

super-secondary structure sequence motifs. we consider now two data sets of protein sequences with interesting 3d sandwich structure studied previously by biologists, for which existence of corresponding sequence motifs has been postulated  <cit> . using cadherin and immunoglobin superfamilies as an example, our algorithm finds sequence patterns that correspond to the supersecondary structure  motifs  <cit> , i.e. arrangements of the secondary structure units . in particular, in cadherin superfamily we find long motifs of length  <dig>  corresponding to the secondary structure units strand  <dig> - loop - strand  <dig>  and strand  <dig> - loop - strand  <dig>  . figure  <dig> shows identified motif positions within the sequences. our algorithm finds  <dig> potential motif instances  after the selection  and takes about  <dig> seconds . in immunoglobin superfamily , we find a sequence motif of length  <dig> ssvtlgclvkgyfpepvtv which corresponds to strand 2-loop-strand  <dig> secondary structure units .

CONCLUSIONS
we presented a new deterministic and exhaustive algorithm for finding motifs, the common patterns in sequences. our algorithm reduces computational complexity of the current motif finding algorithms and demonstrate strong running time improvements over existing exact algorithms, especially in large-alphabet sequences , as we showed on several motif discovery problems in both dna and protein sequences. the proposed algorithms could be applied to other cases and challenging problems in sequence analysis and mining potentially characterized by large alphabets, such as text mining.

competing interests
the authors declare that they have no competing interests.

authors contributions
all authors contributed equally to this work.

acknowledgments
this article has been published as part of bmc bioinformatics volume  <dig> supplement  <dig>  2010: proceedings of the neural information processing systems  workshop on machine learning in computational biology .  the full contents of the supplement are available online at http://www.biomedcentral.com/1471-2105/11?issue=s <dig> 
