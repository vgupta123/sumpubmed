BACKGROUND
using the link structure of a network to gain insight into the function of its nodes is a ubiquitous technique in biological, social, and computer networks  <cit> . for example, kleinberg used the link structure of the internet to give each node a hub and an authority index  <cit> , and brin and page utilized the structure of the web, rather than its content, to rank web pages  <cit> . of particular interest is the identification of network communities, also in the context of the internet  <cit> , and social and biological networks  <cit> . communities are especially relevant in protein-protein interaction  networks because they often represent protein complexes or other modules with related function.

there are several ways to define a community in a network. one definition is to say that a community is a group of highly interconnected nodes. finding large cliques in a graph, which are subsets of nodes that are completely connected, is a well-studied problem. it is computationally infeasible for large networks: finding the size of the largest clique in a graph is np-complete  <cit> , and approximating it is hard as well  <cit> . thus many heuristic methods have been developed, which look for defective cliques , or more generally dense components.

in the context of biological networks, bu et al. use spectral analysis of the adjacency matrix of a graph to find nodes in cliquish components  <cit> . they apply this technique to yeast ppi networks to identify imperfect cliques, in order to predict the functions of the unknown proteins that they contain. in addition to using spectral approaches, a simpler strategy for finding defective cliques is to first enumerate maximal cliques using an exact  solution, and then combine them if they have significant overlap  <cit> .

a different way to characterize a community is to look at it as a cluster: a group of nodes that are highly interconnected among themselves, but sparsely connected to the rest of the network. the quality of a cluster can be measured by the ratio of the number of its outgoing edges to the sum of the degrees of its nodes, known as conductance  <cit> . for example, a cluster has a conductance of  <dig> if it is disconnected from the rest of the network, and  <dig> if there are no edges within the cluster.

in order to find clusters in a network, we can use two kinds of algorithms that differ in whether or not they consider the entire graph. a global clustering algorithm seeks to partition the entire graph into clusters, while a local clustering algorithm only considers a small part of the graph close to a given vertex. much effort has been devoted to using global partitioning algorithms on protein networks  <cit> , but the same cannot be said about local techniques. local algorithms have an obvious advantage because they are often faster. in addition, they may be more useful if the user is only interested in a certain neighborhood of the network. even though a local algorithm uses less information, it can utilize a local view of the graph to find a quality cluster  <cit> .

contribution
the objective of this work is to develop a tool  for finding high-quality communities near a queried protein in a ppi network. here we measure the quality of a community by its conductance, and the functional coherence of its proteins. we expect clusters of interacting proteins to be functional modules, yet this may not always be the case. therefore, we need to validate the biological significance of the found communities. to evaluate functional coherence, we consider how functionally related the proteins inside the cluster are to each other, and to the other proteins in the network. in order to determine the functional distance between a pair of proteins, we use a measure derived from annotation based on biological literature  <cit> .

the local protein community finder uses a recently developed local clustering algorithm called nibble  <cit> , and its extension pagerank-nibble  <cit> . both of them start from a single vertex, and look for a cluster of good conductance in its neighborhood. to our knowledge, our study is the first application of non-heuristic local clustering algorithms to protein networks. we compare nibble and pagerank-nibble to metis, a popular and effective graph partitioning algorithm  <cit> , and a common spectral clustering implementation  <cit> . metis partitions the entire network into mutually disjoint balanced clusters, keeping the edge cut, which is the set of edges with endpoints in different clusters, as small as possible. the intuition behind spectral clustering is described in  <cit> , and metis works better than commonly used spectral clustering methods in terms of the size of the resulting edge cut  <cit> . we show that among the algorithms considered, nibble and pagerank-nibble find better clusters in terms of conductance and functional coherence, making our tool useful for finding interesting communities close to a queried protein.

methods
preliminaries
we model a protein network as an undirected, unweighted graph where the nodes are the proteins, and two nodes are connected by an edge if the corresponding proteins are annotated as interacting with each other.

graph representation
formally, a graph is given by a set of vertices v and a set of edges e. the degree of a node u ∈ v, denoted by d, is the number of edges adjacent to u. a graph is often represented by its adjacency matrix. the adjacency matrix of a graph g =  is defined by  

random walks
we can learn a lot about the structure of a graph by taking a random walk on it. a random walk is a process where at each step we move from some node to one of its neighbors. the transition probabilities are given by edge weights, so in the case of an unweighted network the probability of transitioning from u to any adjacent node is 1/d. thus the transition probability matrix  is the normalized adjacency matrix where each row sums to one:  

here the d matrix is the degree matrix, which is a diagonal matrix given by  

in a random walk it is useful to consider a probability distribution vector p over all the nodes in the graph. here p is a row vector, where p is the probability that the walk is at node u, and ∑u ∈ v p =  <dig>  because we transition between nodes with probabilities given by w, if pt is the probability distribution vector at time t, then pt+ <dig> = ptw.

if we modify the random walk to reset at each step with nonzero probability α, it will have a unique steady-state probability distribution. this steady-state distribution, which is known as a pagerank vector, is useful because it tells us how much time we will spend at each vertex in a very long random walk on the graph. for starting vector s, and reset probability α, the pagerank vector prα  is the unique solution of the linear system  

the s vector specifies the probability distribution for where the walk transitions when it resets. the original pagerank algorithm used a uniform unit vector for s  <cit> . pagerank with non-uniform starting vectors is known as personalized pagerank, and has been used in context-sensitive search on the web  <cit> .

partitioning
a common problem in graph theory is to partition the vertices of a graph into clusters while minimizing the number of intercluster edges. a matrix often used for this purpose is the graph laplacian. the laplacian matrix of an undirected graph g =   is defined as follows:  

in other words, lg = dg - ag. the eigenvectors of lg reveal some structure of the graph  <cit> , and are often used by spectral graph partitioning algorithms.

conductance
conductance measures proportion of outgoing edges of a set of nodes in the graph. given a graph g = , and a subset of vertices s ∈ v, let us call the edge boundary of s the collection of edges with one point in s and the other outside of s:  

let us also define the volume of s to be the sum of the degrees of its nodes:  

the conductance of s is then defined as the ratio of the size of its edge boundary to the volume of the smaller side of the partition:  

the lower the conductance, the better the cluster. notice that a cluster can have low conductance without being dense. using the minimum of vol and vol() in the definition disregards vacuous clusters .

nibble
nibble, the local clustering algorithm of spielman and teng  <cit> , works by looking for a cluster of low conductance among the most popular destinations of a short random walk from the starting vertex. the algorithm starts with a probability distribution vector p that has all of its probability in the starting vertex, and at every iteration updates p by setting pt = pt-1w, where w is the lazy random walk transition probability matrix. a lazy random walk is a modified random walk where the probability of remaining at each vertex is 1/2; it is used to ensure that the walk reaches a steady state. after each iteration of the random walk, nibble checks the probability distribution vector for a cluster of low conductance by performing a "sweep" of p.

a sweep is a technique for producing a partition  from a probability distribution vector. the vertices are ordered by degree-normalized probability, and the conductance of the first j vertices in the order is computed, where j ranges from  <dig> to the number of non-zero entries in the vector , returning the set with lowest conductance. more precisely, let v <dig> ..., vn be an ordering of  vertices of p such that p/d ≥ p/d. consider a collection of sweep sets  = {v <dig> ..., vj}. let Φ  be the smallest conductance of any of these sets,  

the algorithm finds Φ  by sorting the entries of p by degree normalized probability, and then computing the conductance of each sweep set to find the minimum. the degree of each vertex v, denoted by d, is proportional to the amount of probability that v has in the stationary distribution of the random walk. therefore the sweep sets contain vertices that have significantly more probability in p than they do in the stationary distribution, meaning that they are visited more often in a walk from the starting node than they are at steady-state.

in order to bound the runtime of the algorithm, nibble only looks at a small part of the graph close to the starting vertex by using a truncation operation on the probability distribution vector. given a parameter ϵ, after each iteration of the random walk, we set p =  <dig> for every v such that p ≤ ϵ d. nibble takes as input the number of iterations that it performs, as well as ϵ, and returns the sweep set of smallest conductance over all iterations.

deviating from the algorithm presented in  <cit> , we also implement a constrained version of nibble, which always reports a cluster containing the starting vertex. here when we perform a sweep of the probability distribution vector, we always put the starting vertex s first in the order , no matter how much probability there is at that vertex. therefore, constrained-nibble only considers sweep sets that include the starting vertex. similarly, nibble can also be modified to only consider sweep sets of a certain size, which is useful when we wish to find a cluster in a specified size range.

pagerank-nibble
pagerank-nibble  <cit>  is similar to nibble in that it looks for a cluster containing the closest vertices to the starting node. however, instead of using an evolving probability distribution of a random walk from starting node s, pagerank-nibble uses a personalized pagerank vector that gives the stationary distribution of a random walk that always returns to s when it resets. once the personalized pagerank vector is computed, the same sweep technique described in the previous section is used to return the cluster of lowest conductance among its sweep sets.

in addition, to bound the amount of time necessary to compute the pagerank vector and perform a sweep, the algorithm uses an approximation of it. the approximation algorithm computes an ϵ-approximate pagerank vector by conducting a random walk that only considers vertices v that have more than ϵ d probability in them. the resulting pagerank vector has few non-zero entries, and the amount of error in it for any subset of vertices s is less than ϵ·vol.

pagerank-nibble uses the same sweep technique to find a partition, so it can also be constrained to only consider sweep sets of a certain size, if we wish to find a cluster in a specified size range. unlike nibble, pagerank-nibble always reports a cluster containing the starting vertex because the starting vertex has the most degree normalized probability in the computed pagerank vector. for calculations of pagerank, α  is typically chosen to be  <dig> . however, we find that using a lower value of α  gives us clusters of lower conductance.

metis
metis is a global graph partitioning algorithm that outperforms other state-of-the-art methods  <cit> . it takes the number of clusters  as an argument, and maps each vertex to one of k balanced clusters, minimizing the size of the edge cut, which is the set of edges with endpoints in different clusters. metis is a multilevel algorithm, which coarsens the graph to perform the partitioning, and then improves it as the graph is rebuilt. there are two variations of metis algorithms for partitioning graphs: kmetis and pmetis. we try both, and decide to use pmetis because it gives us clusters of lower conductance. pmetis works by recursively bisecting the graph, it is slower but returns clusters that are more balanced in size. the partitions reported by pmetis are almost all of exactly the same size, so to get clusters of a certain size we simply set k accordingly. because pmetis is a global algorithm, we partition the entire graph once, and for starting vertex s return the cluster containing s.

spectral clustering
we use a common spectral clustering implementation, taking the first d eigenvectors of the laplacian matrix of the graph , to put each vertex in a d-dimensional space. we then use k-means clustering to partition the vertices into k clusters, again choosing k to get clusters of the desired size. however, the sizes of the found clusters vary greatly, so we also use a variation where we simply return the k closest vertices to the starting vertex in the spectral embedding space. once again, if we partition the entire graph, we return the cluster that contains the starting vertex.

measuring functional distance
in order to assess the functional coherence of the found clusters, we use functional distances from yu et al.  <cit> . these values are derived using the gene ontology  process classification scheme, where functional-distance is the number of gene pairs that share all of the least common ancestors of a and b in the classification hierarchy. a low functional distance score means that two proteins are more functionally related, because there are few protein pairs that have the same functional relationship.

the functional distance measure of yu et al., which the authors refer to as the "total ancestry measure for go," has the obvious advantage that it considers all known functions of a pair of proteins, allowing for a great degree of precision in assessing functional similarity. moreover, unlike other methods that derive distances from the go classification scheme, this method is very resilient to rough functional descriptions, because it still assigns low distances to pairs of proteins that only share very broad terms, as long as there are few other protein pairs that share all of those terms.

functional distances from  <cit>  can be quite large, yet differences in scores at the low end are more significant than differences at the high end, which is why we take the logarithm in our calculations:  

calculating functional coherence
to determine the functional coherence of community c in a protein network represented by a graph g = , we compute an absolute and a relative functional coherence score. the absolute functional coherence of a community is the difference between the average functional distance of two proteins in the network and the average pairwise functional distance of proteins in the community:  

the relative functional coherence of a community also takes into account how functionally related the proteins inside the community are to the other proteins in the network, and is defined as the difference in average functional distance of intercommunity and intracommunity protein pairs:  

correlating conductance and functional coherence
to determine whether communities with better conductance are more likely to be functionally coherent, we choose groups of proteins from each network, rank these groups by conductance, absolute, and relative functional coherence, and compute the correlation between the ranks using the pearson correlation coefficient  <cit> . how to choose the protein groups for this experiment is non-trivial. they cannot be selected by taking random subsets of nodes in each network, which will most certainly produce disconnected groups with bad conductance and functional coherence. furthermore, they cannot be selected by using algorithms that minimize conductance, which will produce groups with strong bias towards low conductance. a better way to choose these groups is to first randomly select a vertex, and then choose k -  <dig> of its nearest neighbors, breaking ties in distance randomly. such "random" protein groups will be connected in the network, with reasonable and variable conductance and coherence values. the size of each group is randomly chosen in the range  <dig> ≤ k ≤  <dig>  because we expect biologically relevant communities to be in this size range.

the protein networks
the protein interaction data that we use in our study is from biogrid  <cit> , version  <dig> . <dig>  updated june  <dig>   <dig>  biogrid lists interacting protein pairs, and for each pair gives the experimental method used to observe the interaction, as well as the source that submitted it. in our study we use several yeast protein-protein interaction  networks formed from interactions detected by different methods.

two of the networks, where protein interactions are detected from bait-and-prey type experiments are affinity capture-western , and affinity capture-ms . these networks tend to be much more cliquish and contain dense components, which is due to the nature of the experiment used to detect the interactions. a single protein  is used to pull in a set of other proteins , and an interaction is predicted either between the bait and each prey , or between every protein in the group   <cit> . we also use two-hybrid data in our study. two-hybrid methods detect binary interactions, therefore ppi networks based on two-hybrid data tend to be less dense and cliquish than ones derived from affinity capture experiments.

in addition to using a network formed from the union of all two-hybrid interactions listed in biogrid , we also consider a subset of this data submitted by  <cit>  . this network is sparser, but is believed to be of higher quality.

RESULTS
the local protein community finder, accessible at http://xialab.bu.edu/resources/lpcf, allows the user to find local communities in any protein network available from biogrid  <cit> , which is specified by an organism and a set of interaction types. in addition to entering the starting vertex, one can also select the desired cluster size, and whether the reported cluster must contain the starting vertex . our tool uses the nibble and pagerank-nibble algorithms described in methods, and returns the cluster of lower conductance. the program takes only a few seconds to run, and generates an image of the returned cluster, as well as annotation of the found proteins . in addition, the found community can be displayed in visant, a popular protein interaction viewer  <cit> . if the user would like to use a network that is not from biogrid, the generic local community finder can be used instead, available at http://xialab.bu.edu/resources/lcf, where one can upload any undirected network in edge-list format. the local community finder also supports weighted networks, as the user can  specify a weight for each edge. the application is also available as a command-line program  at http://xialab.bu.edu/resources/lcf/commandline.

a biological example
first we provide a concrete example where using our tool reveals a biologically meaningful community, while a different commonly used approach does not produce a functionally coherent group. we use our tool to query the local community of yeast protein get <dig> in the network from  <cit> , which returns a group of  <dig> proteins. to investigate the functions of these proteins, we use the go term finder  <cit>  to look for gene ontology biological process terms that are significantly enriched in this group . get <dig> is a subunit of the get complex, which is involved in golgi to er trafficking and insertion of proteins into the er membrane  <cit> . we find that the local community of get <dig> contains many proteins with similar functions. the community is significantly enriched for relevant gene ontology process categories such as protein localization , cellular protein localization , intracellular protein transport , and establishment of localization in cell . on the other hand, when we simply take the  <dig> nearest neighbors of get <dig> in the protein network , we get a group of proteins that are not significantly enriched for any of these categories. thus here it is clear that considering the local community of a protein in a ppi network is much more meaningful than simply looking at its immediate interaction partners.

performance validation
nibble and pagerank-nibble have theoretic performance guarantees  <cit> , but their effectiveness has not been tested in practice. in order to justify our choice of partitioning algorithms, we compare the performance of nibble and pagerank-nibble to two other algorithms commonly used for this purpose: metis and spectral clustering. we use two variations of spectral clustering: one that uses k-means clustering in the spectral embedding space and reports the cluster containing the starting vertex, and another that simply returns the closest neighbors of the starting vertex in the spectral embedding space . to determine whether partitioning a protein interaction network is an effective approach to finding functionally coherent communities, we also compare with a simple nearest neighbor heuristic. given a starting vertex, nearest neighbor returns the k nearest neighbors in the graph, ties broken randomly. of course, we do not expect this heuristic to return clusters of low conductance, but we do expect it to find functionally coherent groups, because nodes that are connected in a ppi network tend to be much more functionally related  <cit> .

comparing the algorithms
to compare the performance of the algorithms, we run all of them from the same set of nodes in each ppi network described in methods, and record the conductance and absolute/relative functional coherence of the found clusters. we then average the statistics of every algorithm in each network, and report the standard error to see if the differences are statistically significant. moreover, we compare the algorithms when they search for clusters of varying size for the following reasons:

• functional coherence is sensitive to cluster size , therefore we need to control the size of the reported clusters for a rigorous comparison.

• this gives a more thorough performance comparison because it is possible that different algorithms are better at finding clusters of different size.

thus we compare all methods when they search for small , medium  and large  clusters. we consider this size range because we expect biologically relevant functional groups to be of roughly this size . setting the parameters of each algorithm to only report clusters in a specified size range is straightforward: for k-nearest neighbor methods we simply set k accordingly; we restrict the local clustering algorithms to only consider sweep sets of a certain size ; and we vary the desired number of clusters when using the global partitioning algorithms, which gives us clusters in the right size range if the partition is balanced.

comparing performance in terms of conductance
from figure  <dig> we also see that the local clustering algorithms outperform the global ones, which may seem surprising at first. however, a global partitioning algorithm assigns every node to a cluster in order to minimize the edge cut over all clusters in the graph. it is not clear why the same algorithm should be best at minimizing the edge cut for a single cluster in a given neighborhood. the local algorithms, on the other hand, use a view of the graph relative to the starting node, which is specific to each vertex, to find the partition. the intuition for why nibble works well is that if we take a node inside a cluster of low conductance, and start a random walk from that node, most of the probability will stay inside the cluster because there are proportionally few outgoing edges . therefore, most of the nodes in the cluster will have a lot of probability in them, and will be in one of the sweep sets  considered by nibble. even though pagerank-nibble does not perform quite as well on all of our data, its theoretic performance guarantee is better than that of nibble  <cit> , and we believe that it can be especially useful for other networks.

comparing performance in terms of functional coherence
in addition to finding good clusters, we would also like our tool to find biologically relevant protein communities. in order to see whether algorithms that minimize conductance are useful for finding functionally coherent groups, we select a large number of protein groups from each network and calculate their conductance and absolute/relative functional coherence, to see if there is any correlation between them . the results are presented in figure  <dig>  we see significant correlation between conductance and both functional coherence measures in all four networks. moreover, for each network we also compute the average functional distance of interacting and non-interacting proteins . as we expect, in all of our networks interacting proteins are more functionally related. these findings lead us to think that methods that minimize conductance should do well in terms of finding functionally coherent groups in protein networks.

however, we do not expect to see as large a difference in performance between the algorithms used by our tool and other methods in terms of functional coherence of the found communities. there are several reasons for this:

• our functional coherence calculations depend on the quality of the gene ontology annotations from which the pairwise functional distances are derived.

• the protein networks that we use are noisy, and contain false positive and false negative interactions.

• we should not expect methods designed to minimize conductance to perform equally well when their performance is assessed using other, albeit related, measures.

still, we expect our local partitioning algorithms to find communities with high functional coherence, giving more evidence that the communities reported by our tool are biologically relevant.

because our methods minimize conductance, which is a relative measure of edge density, it is more appropriate to evaluate them using a relative measure of functional coherence. relative functional coherence also takes into account how functionally related the proteins inside the cluster are to the other proteins in the network, and reports the difference in the average functional distance of intercommunity and intracommunity protein pairs. thus methods that find clusters of low conductance, which are sets of nodes that are better connected among themselves than they are with the rest of the network, should do well in terms of this functional coherence measure. figure  <dig> shows that this is indeed the case, as there is a greater contrast in performance between local partitioning algorithms and other methods in terms of relative functional coherence of the found communities. as before, our algorithms significantly outperform other methods when searching for small communities, and the quality of communities found by all algorithms decreases for larger clusters. once again, the expected coherence of a random subset of proteins in the network is  <dig>  which is also confirmed in our computational experiments. moreover, when we perform the same rewiring test, the coherence of the found communities is again approximately  <dig>  showing that our results are indeed significant.

CONCLUSIONS
using conductance to measure the quality of a cluster is especially useful in ppi networks because of the low sampling rate of protein interaction data. the extremely low sampling rate  presents a problem for any computational method based on ppi network topology. however, undersampling is not likely to affect the conductance of a cluster, because the proportion of outgoing edges is likely to stay the same. thus if a good cluster exists in the true ppi network, it will also exist in the undersampled network, and will be found by our tool if it is looking in the right neighborhood. on the other hand, algorithms that use absolute criteria in looking for a community  will work poorly on ppi data unless these criteria are carefully chosen.

our results also make an important point about whether it makes sense to use a local partitioning algorithm when it is feasible to use a global one. a local partitioning algorithm only looks at a part of the graph, which gives it an obvious advantage when the graph is very large. however, not much is said about the quality of partitions that a local algorithm finds, compared to a global method. it is easy to think that since a local algorithm only sees a part of the graph, it must always do worse. however, here we show that this is not the case, as the two local partitioning algorithms outperform the global ones. additionally, the concept of local clustering is quite natural, as often we care about a community local to a part of the graph, rather than how all the nodes cluster. this may be especially true in biology, where researchers typically work on specific proteins of interest.

finally, we address the biological relevance of communities found in ppi networks. our results show that by locally partitioning a protein network we can find communities whose proteins are functionally related to each other, and less related to the other proteins in the network.

authors' contributions
kv, sht, and yx conceived and designed the experiments. kv performed the experiments and analyzed the data. kv, sht, and yx drafted and edited the manuscript.

