BACKGROUND
systems for the recognition of biomedical named entities have traditionally worked on a 'first-best' approach, where all of the entities recognised have equal status, and precision and recall are given roughly equal importance. this does not reflect that fact that precision is of greater importance for some applications, and recall is the key for others. furthermore, knowing the confidence  with which the system has assigned the named entities is likely to be useful in a range of different applications.

named entities of relevance to biomedical science include not only genes and proteins but also other chemical substances which can be of interest as drugs, metabolites, nutrients, enzyme cofactors, experimental reagents and in many other roles . we have recently investigated the issue of chemical named entities  <cit> , by compiling a set of manual annotation guidelines, demonstrating 93% interannotator agreement and manually annotating a set of  <dig> chemistry papers. in this paper we demonstrate a named entity recogniser that assigns a confidence score to each named entity, allowing it to be tuned for high precision or recall.

our review of the methods of chemical named entity recognition showed a consistent theme: the use of character-based n-grams to identify chemical names via their constituent substrings  <cit> . this can be a powerful technique, due to systematic and semisystematic chemical names and additional conventions in drug names. however this technique does not cover all aspects of chemical nomenclature.

much current named entity work uses approaches which combine the structured prediction abilities of hmms and their derivatives with techniques which enable the use of large, diverse feature sets such as maximum entropy . maximum entropy markov models,   <cit>  provide a relatively simple framework for this. memms do have a theoretical weakness, namely the "label bias" problem  <cit> , which has been addressed with the development of conditional random fields . crfs are now a mainstay of the field, being used in a high proportion of entries in the latest biocreative evaluation  <cit> . however, despite the label bias problem, memms still attract interest due to practical advantages such as shorter training cycles.

the standard strategy for encoding named-entity recognition in hmms and similar systems is via bio coding . in this scheme, the text is tokenised, and each token is encoded as o , b  or i . where more than one named entity type exists, the b and i codes can be extended with an entity type. for example, in "dissolved in ethyl acetate." the named entity information can be represented thus: dissolved_o in_o ethyl_b-cm acetate_i-cm ._o.

the framework of hmms and their successors offers three modes of operation; first-best, n-best and confidence-based. in first-best ner, the viterbi algorithm is used to identify a single sequence of labels for the target sentence. in n-best operation, the n best sequences for the sentence are identified, along with their probabilities, for example by coupling the viterbi algorithm with a* search. in confidence-based operation, potential entities  are identified directly, without directly seeking a single optimal labelling for the entire sentence. this is done by examining the probability of the label transitions within the entity, and the forward and backward probabilities at the start and end of the entity. this mode has been termed the constrained forward-backward algorithm  <cit> . where a single unambiguous non-overlapping labelling is required, it can be obtained, for example, by identifying cases where the entities overlap, and discarding those with lower probabilities. note that the set of entities selected in this manner is not guaranteed to be optimal; however, more advanced decoding procedures exist that do guarantee an optimal selection.

confidence-based extraction has two main advantages. first, it enables the balance between precision and recall to be controlled by varying the probability threshold. second, confidence-based ner avoids over-commitment in systems where it is used as a preprocessor, since multiple overlapping options can be used as input to later components.

the optimum balance between recall and precision depends on the application of the ner and on the other components in the system. high precision is useful in search even when recall is low when there is a large degree of redundancy in the information in the original documents. high precision ner may also be useful in contexts such as the extraction of seed terms for clustering algorithms. balanced precision/recall is often appropriate for search, although in principle it is desirable to be able to shift the balance if there are too many/too few results. balanced precision/recall is also generally assumed for use in strictly pipelined systems, when a single set of consistent ner results is to be passed on to subsequent processing. contexts where high recall is appropriate include those where a search is being carried out where there is little redundancy  or where the ner system is being used with other components which can filter the results.

one use of our ner system is within a language processing architecture  <cit>  that systematically allows for ambiguity by treating the input/output of each component as a lattice . this system exploits relatively deep parsing, which is not fully robust to ner errors but which can exploit complex syntactic information to select between candidate ner results. ner preprocessing is especially important in the context of chemistry terms which utilise punctuation characters  since failure to identify these will lead to tokenisation errors in the parser. such errors frequently cause complete parse failure, or highly inaccurate analyses. in our approach, the ner results contribute edges to a lattice which can  be treated as tokens by the parser. the ner results may compete with analyses provided by the main parser lexicon. in this context, some ner errors are unimportant: e.g., the parser is not sensitive to all the distinctions between types of named entity. in other cases, the parser will filter the ner results. hence it makes sense to emphasise recall over precision. we also hypothesise that we will be able to incorporate the ner confidence scores as features in the parse ranking model.

an example of the improvements that are available by passing multiple hypotheses from component to component is given by roth and yi  <cit> . in their system, results from named entity classification are used in relation classification. by passing multiple hypotheses between the systems, using integer linear programming to perform global inference, they were able to achieve an improvement in performance for both tasks over a more traditional pipelined system. similarly, finkel et al.  <cit>  were able to improve the results of semantic role labelling and recognising textual entailment systems by using multiple hypotheses from their underlying named entity recognition and pcfg parsing components.

one motivation for our focus on high-recall capable ner is its intended use in the royal society of chemistry's editing workflows for their project prospect system  <cit> , in which chemical named entity recognition is used to produce semantically-enriched journal articles. in this situation, high recall is desirable, as false positives can be removed in two ways; by removing entities where a chemical structure cannot be assigned, and by having them checked by a technical editor. false negatives are harder to correct. a study by alex et al.  <cit>  on the use of nlp components in the curation of biological databases showed a curator preference for high-recall over high-f score ner. they speculate that different curators may have different preferences for precision and recall, and suggest that it would be useful to develop a system which would allow curators to filter information dynamically based on confidence values.

the use of confidence-based recognition has been demonstrated with crfs in the domain of contact details  <cit> , and using hmms in the domain of gene annotation  <cit> . in the latter case, the lingpipe toolkit was used in the biocreative  <dig> evaluation without significant adaptation. although only 54% precision was achieved at 60% recall , the system was capable of  <dig> % recall with 7% precision, and 95% recall with 18% precision, indicating that very high recall could be obtained in this difficult domain.

another potential use of confidence-based ner is the potential to rescore named entities. in this approach, the ner system is run, generating a set of named entities. information obtained about these entities throughout the document  that they occur in can then be used in further classifiers. we are not aware of examples of rescoring being applied to confidence-based ner, but there are precedents using other modes of operations. for example, krishnan and manning  <cit>  describe a system where a first-best crf is used to analyse a corpus, the results of which are then used to generate additional features to use in a second first-best crf. similarly, yoshida and tsujii  <cit>  use an n-best memm to generate multiple analyses for a sentence, and re-rank the analyses based on information extracted from neighbouring sentences. ji and grishman  <cit>  use feedback from coreference resolution, relation extraction and event extraction systems to rescore the output of an n-best hmm chinese name tagger.

therefore, to explore the potential of these techniques, we have produced a chemical ner system that uses a memm for confidence-based extraction of named entities, with an emphasis on the use of character-level n-grams, and a rescoring system.

methods
corpus
previously, we have produced a set of annotation guidelines for chemical named entities, and used them to annotate a set of  <dig> chemistry papers  <cit> . in that study, inter-annotator agreement was tested on  <dig> of these, and found to be 93%. the annotation guidelines specified five classes of named entity, which are detailed in table  <dig>  the annotation was performed on untokenised text. when tokenised with our tokeniser, the corpus was found to contain  <dig> tokens  in total.

                              ch
                              pm
nch = number in chemistry corpus, npm = number in pubmed corpus.

to test the applicability of the method to a different corpus, we retrieved  <dig> pubmed abstracts and titles, and annotated them using the same methods. the abstracts were acquired using the query metabolism  and drug and hasabstract. this produced a diverse set of abstracts spanning a wide range of subject areas, but which contain a higher proportion of relevant terms than pubmed overall.  <dig> out of  <dig> abstracts contained at least one chemical named entity, whereas  <dig> contained at least ten. notably, the ase class was more common in the pubmed corpus than in the chemistry papers, reflecting the importance of enzymes to biological and medical topics. this corpus was found to contain  <dig> tokens  in total.

in the current study, we have left out the named entity type cpr, as it is rare  and causes difficulties with tokenisation. this entity type covers cases such as the " <dig> -" in " <dig> -disubstituted", and as such requires the " <dig> -" to be a separate token or token sequence. however, we have found that recognition of the other four classes is improved if words such as " <dig> -disubstituted" are kept together as single tokens. therefore it makes sense to treat the recognition of cpr as an essentially separate problem – a problem that will not be addressed here.

external resources
chemical names were extracted from the chemical ontology chebi  <cit> , and a standard english word list was taken from/usr/share/dict/wordson a linux system. this dictionary was chosen as it contains inflectional forms of english words. our system does not perform stemming, partly because suffixes are often good cues as to whether a word is chemical or not. a list of chemical element names and symbols was also compiled. to overcome the shortage of entities of type ase, a list of words from enzyme names ending in '-ase' was extracted from the gene ontology  <cit> , and manually sorted into words of type ase, and words not of type ase.

overview of operation
the text is tokenised before processing; this is done using the tokeniser described in our previous work  <cit> , which is adapted to chemical text.

our system uses three groups of classifiers to recognise chemical names. the first classifier – the 'preclassifier' – uses character-level n-grams to estimate the probabilities of whether tokens are chemical or not. the output of this classification is combined with information from the suffix of the word, and is used to provide features for the memm.

the second group of classifiers constitute the memm proper. named entities are represented using a bio-encoding, and methods analogous to other confidence-based taggers  <cit>  are used to estimate the conditional probability of tag sequences corresponding to named entities. the result of this is a list of potential named entities, with start positions, end positions, types and probabilities, where all of the probabilities are above a threshold value. a small set of hand-written filtering rules is used to remove obvious absurdities, such as named entities ending in the word "the", and simple violations of the annotation guidelines, such as named entities of type ase that contain whitespace. these filtering rules make very little difference at recall values up to about 80% – however, we have found that they are useful for improving precision at very high recall.

the third group of classifiers – one per entity type – implement a rescoring system. after all of the potential entities from a document have been generated, a set of features is generated for each entity. these features are derived from the probabilities of other entities that share the same text string as the entity, from probabilities of potential synonyms found via acronym matching and other processes, and most importantly, from the pre-rescoring probability of the entities themselves.

overview of training
a form of training conceptually similar to cross-validation is used to train the three layers of classifiers. to train the overall system, the set of documents used for training is split into three parts. two thirds are used to train a memm, which is then used to generate training data for the rescorer using the held-out last third. this process is repeated another two times, holding out a different third of the training data each time. finally, the rescorer is trained using all of the training data generated by this procedure, and the final version of the memm is generated using all of the training data. this procedure ensures that both the memm and the rescorer are able to make use of all of the training data, and also that the rescorer is trained to work with the output of a memm that has not been trained on the documents that it is to rescore.

a similar procedure is used when training the memm itself. the available set of documents to use as training data is divided into half. one half is used to train the preclassifier and build its associated dictionaries, which are then used to generate features for the memm on the other half of the data. the roles of each half are then reversed, and the same process is applied. finally, the memm is trained using all of the generated features, and a new preclassifier is trained using all of the available training data. it should be noted that the dictionaries extracted during the training of the preclassifier are also used directly in the memm.

the character n-gram based preclassifier
during the training of the preclassifier, sets of tokens are extracted from the hand-annotated training data. a heuristic is used to classify these into 'word tokens' – those that contain two consecutive lowercase letters, and 'nonword tokens' – those that do not . the n-gram analysis is only performed upon 'word tokens'. this is a simple heuristic that excludes many irrelevant tokens from consideration, but it does not aim to be comprehensive.

the token sets that are compiled are chemical word tokens , nonchemical word tokens , chemical nonword tokens, nonchemical nonword tokens and ambiguous tokens – those that occur both inside and outside of named entities. a few other minor sets are collected to deal with tokens related to such proper noun-containing entities as 'diels-alder reaction'.

some of this data is combined with external dictionaries to train the preclassifier, which uses markov models of chemical names and nonchemical words, using 4-grams of characters and modified kneser-ney smoothing, as described in  <cit> . in our experience with various n-gram techniques, using 5-grams and higher offers only a slight advantage at best and is counter-productive at worst. the set of 'chemical word tokens' is used as a set of positive examples, along with tokens extracted from chebi, a list of element names and symbols, and the ase tokens extracted from the go. the negative examples used are the extracted 'nonchemical word tokens', the non-ase tokens from the go and tokens taken from the english dictionary – except for those that were listed as positive examples. this gets around the problem that the english dictionary contains the names of all of the elements and a number of simple compounds such as 'ethanol'.

during operation, n-gram analysis is used to calculate a score for each word token, of the form:

 ln) - ln) 

if this score is above zero, the preclassifier classifies the token as chemical and gives it a tentative type, based on its suffix. this can be considered to be a "first draft" of its named entity type. for example tokens ending in "-ation" are given the type rn, whereas those ending in "-ene" are given type cm.

the memm
the memm is a first-order memm, in that it has a separate maximum-entropy model for each possible preceeding tag. no information about the tag sequence was included directly in the feature set. we use the opennlp maxent toolkit  <cit>  for maximum-entropy classification.

the feature set for the memm is divided into three types of features; type  <dig> , type  <dig>  and type  <dig> . an example type  <dig> feature would be 4g=ceti, indicating that the 4-gram ceti had been found in the token. an example type  <dig> feature would be c-1:w=in, indicating that the previous token was 'in'. an example bigram constructed from type  <dig> features would be bg:0:1:ct=cj_w=acid, indicating that the preclassifier had classified the token as being of type cj, and having a score above zero, and that the next token was 'acid'.

type  <dig> features include  <dig>   <dig>   <dig> and 4-grams of characters found within the token, whether the token appeared in any of the word lists, and features to represent the probability and type given by the preclassifier for that token. type  <dig> features include the token itself with any terminal letter 's' removed, the token converted to lowercase , and a three-character suffix taken from the token. the token itself was usually used as a type  <dig> feature, unless it was short , or had been found to be an ambiguous token during preclassifier training, in which case it was type  <dig> . other type  <dig> features include a word shape feature, and tentative type of the token if the preclassifier had classed it as chemical.

a few other features were used to cover a few special cases, and were found to yield a slight improvement during development.

after generating the features, the least informative features are removed by discarding all of those with a g less than or equal to  <dig> , where

  

this was found during development to have only a very small beneficial effect on the performance of the classifier, but it did make training faster and produced smaller models. this largely removed rare features which were only found on a few non-chemical tokens.

the rescorer
the rescoring system works by constructing four maximum entropy classifiers, one for each entity type. the output of these classifiers is a probability of whether or not a potential named entity really is a correct named entity of the respective class. the generation of features is done on a per-document basis.

the key features in the rescorer represent the probability of the potential entity as estimated by the memm. the raw probability p is converted to the logit score

 l = ln - ln 

this mirrors the way probabilities are represented within maximum entropy  classifiers. if l is positive, int * 50) instances of the feature conf+ are generated, and a corresponding technique is used if l is negative. we found that  <dig>  was a good threshold by experimentation on development data: papers annotated during trial runs of the annotation process. before generating further features, it is necessary to find entities that are 'blocked' – entities that overlap with other entities of higher confidence. for example, consider "ethyl acetate", which might give rise to the named entity "ethyl acetate" with 98% confidence, and also "ethyl" with 1% confidence and "acetate" with 1% confidence. in this case, "ethyl" and "acetate" would be blocked by "ethyl acetate".

further features are generated by collecting together all of the unblocked potential entities of a type that share the same string, calculating the maximum and average probability, and calculating the difference between the p and those quantities. it is important to consider only unblocked entities here, as doing this without regards for blocking causes problems. in a document containing both "ethyl acetate" and "ethyl group", it would be detrimental to allow the low confidence for the "ethyl" in "ethyl acetate" to lower the confidence of the "ethyl" in "ethyl group".

some acronym and abbreviation handling is also performed. the system looks for named entities that are surrounded by brackets. for each of these, a list of features is generated that is then given to every other entity of the same string. if there is a potential entity to the left of the bracketed potential abbreviation, then features are generated to represent the probability of that potential entity, and how well the string form of that entity matches the potential abbreviation. if no potential entity is found to match with, then features are generated to represent how well the potential abbreviation matches the tokens to the left of it. by this method, the rescorer can gather information about whether a potential abbreviation stands for a named entity, something other than a named entity – or whether it is not an abbreviation at all, and use that information to help score all occurrences of that abbreviation in the document.

RESULTS
the systems were evaluated by 3-fold cross-validation methodology, whereby the data was split into three equal folds . for each fold, the system was trained on the other two folds and then used to generate a list of putative named entities on that fold. the putative named entities generated in this fashion were then pooled into a single list.

in this list, the start position, end position, type and confidence score of each putative named entity was recorded. this list was sorted in order of confidence – most confident first – and each entity was classified as a true positive or a false positive according to whether an exact match  could be found in the annotated corpus. also, the number of entities in the annotated corpus was recorded.

precision/recall curves were plotted from these lists by selecting the first n elements, and calculating precision and recall taking all of the elements in this sublist as true or false positives, and all the entities in the corpus that were not in the sublist as false negatives. the value of n was gradually increased, recording the scores at each point. the mean average precision  was calcuated as the average of precisions computed after each true positive in turn . this value is approximately equal to the area under the precision/recall curve. we also consider some single-point values: the precision at a threshold that sets the recall to 90%, the recall at a threshold that sets the precision to 95%, and the precision, recall and f at a threshold of  <dig> . the results of this evaluation on the corpus of chemistry papers are shown in figure  <dig> and table  <dig>  the full system achieves  <dig> % recall at 95% precision and  <dig> % precision at 90% recall. at a confidence threshold of  <dig> , the system achieves  <dig> % precision and  <dig> % recall . also shown are the results of successively eliminating parts of the system. "no rescorer" removes the rescorer. in "no preclassifier", the preclassifier is disabled , and all of the dictionaries extracted during the training of the preclassifier are also disabled. finally, in "no n-grams", the 1-, 2-, 3- and 4-grams used directly by the memm are also disabled, showing the results of using a system where no character-level n-grams are used at all. these modifications apply successively – for example, in the "no n-grams" case the rescorer and preclassifier are also disabled. these results validate the the cascade of classifiers, and underline the importance of character-level n-grams in chemical ner.

we also show comparisons to an hmm-based approach, based on lingpipe  <dig> . <dig>  <cit> . this is essentially the same system as we described in  <cit> , but operating in a confidence-based mode. the hmms used make use of character-level n-grams, but do not allow the use of the rich feature set used by the memm. the line "customised lingpipe hmm" shows the system using the custom tokenisation and chebi-derived dictionary used in the memm system, whereas the "pure lingpipe hmm" shows the system used with the default tokeniser and no external dictionaries. in the region where precision is roughly equal to recall , the fact that the memm-based system outperforms an hmm is no surprise. however, it is gratifying that a clear advantage can be seen throughout the whole recall range studied , indicating that the training processes for the memm are not excessively attuned to the first-best decision boundary. this increased accuracy comes at a price in the speed of development, training and execution.

it is notable that we were not able to achieve extremes of recall at tolerable levels of precision using any of the systems, whereas it was possible for lingpipe to achieve  <dig> % recall at 7% precision in the biocreative  <dig> evaluation. there are a number of reasons for this. the first is that the tokeniser used in all systems apart from the "pure lingpipe hmm" system tries in general to make as few token boundaries as possible; this leads to some cases where the boundaries of the entities to be recognised in the test paper occur in the middle of tokens, thus making those entities unrecognisable whatever the threshold. other factors that may have had an influence include the quantity of training data, differences between chemical and gene names, and the fact that the sentences used in biocreative were selected using a classifier to control the rate at which gene names occurred in that corpus.  <cit> 

in some cases the system gives "spikes" of lowered precision at very low recall, indicating that it can occasionally be overconfident, and assign very high confidence scores to incorrect named entities. neither corpus contains enough data for the results to reach a plateau – using additional training data is likely to give improvements in performance.

the "no overlaps" line in figure  <dig> shows the effect of removing "blocked" named entities  prior to rescoring. this simulates a situation where an unambiguous inline annotation is required – for example a situation where a paper is displayed with the named entities being highlighted. this condition makes little difference at low to medium recall, but it sets an effective maximum recall of 90%. the remaining 10% of cases presumably consist of situations where the recogniser is finding an entity in the right part of the text, but making boundary or type errors.

CONCLUSIONS
we have demonstrated that memms can be adapted to recognise chemical named entities, and that the balance between precision and recall can be tuned effectively, at least in the range of  <dig> – 95% recall. the memm system is available as part of the oscar <dig> chemical named entity recognition system  <cit> .

competing interests
the authors declare that they have no competing interests.

authors' contributions
ac conceived the original idea and supervised all steps of the work. pc wrote the software, annotated the pubmed abstracts, performed the experiments and analysed the results. both authors wrote the manuscript and approved the final version.

