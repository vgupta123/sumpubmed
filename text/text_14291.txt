BACKGROUND
the objective of most gene-expression measurements is to assess the expression levels of  genes in one or several cell populations. typically, mrna abundances are measured, although techniques for measuring protein-levels also exist. the microarray technique  <cit>  provides a way to measure mrna transcripts for a large number of genes simultaneously, typically in the order of  <dig> –  <dig> or more. microarrays have well defined immobilized regions, which each consists of clones or synthesized sequences of dna specific to a unique gene. we refer to these  regions or spots as probes  <cit> . a cocktail of cdna created from the rna extract from the cell population in study is then, for a few hours, hybridized to the dna on the microarray after which excess cdna is washed off. the result is that each region of the microarray contains a certain amount of hybridized dna unique to the corresponding gene. by first labeling the cdna strands in the sample cocktail with a radioactive or a fluorescent probe, the amount of hybridized dna can be measured utilizing radioactive sensitive film or a color-sensitive scanner, respectively.

by measuring the gene expression for a specific gene, we try to assess how active that gene is . because it is hard to identify an absolute scale to measure on, often, but also for various other reasons, a reference is used to obtain a relative scale. as even genes from the same sample are not directly comparable to each other, each gene gets its own reference, which is typically the same gene from a reference sample. with this approach, we can obtain gene-expression ratios for every gene, which for instance can be used to test the hypothesis if a gene  is differentially expressed or not . this is the core idea behind the two-channel microarray technology, in which the test and the reference cdna cocktails are hybridized simultaneously and in a competitive way to the same array. the same idea has been adopted by single-channel hybridization technologies where the comparison instead is done numerically in the data analysis step. even if gene-by-gene references are used, the measurements are not perfect and they are likely to contain systematic errors, which possibly vary from measurement to measurement, and the obtained gene-expression ratios may still be biased and not comparable to each other. what we ultimately would like to do is to measure all control and all reference samples under identical conditions. the aforementioned two-color microarray technology tries, in some sense, to do this by measuring the control/reference pairs for each gene in one hybridization .

in this paper, we present an affine model that explains many of the systematic effects frequently observed when gene-expression levels from two  samples are compared. the main contributors to such systematic effects are offsets in the individual channel signals, which give non-linear systematic effects in ratios. we will not provide an error model, but only a deterministic model. the main reason for this is that an error-free model makes it easier to understand the impact that channel offsets have on the downstream analysis regardless of gene-expression technology used. this is especially of interest as these are often implicitly assumed to be small and of no effect, which we believe is a too strong assumption. the impact of channel offsets is much larger that the noise, which is why we allow us to assume zero noise in the discussion. although some error models have been suggested for microarray data  <cit> , we believe research beyond this article is required before we can understand and correctly model the various error sources introduced in the microarray process.

the outline of this paper is as follows. in the model section, a general model that incorporates all steps of any gene-expression technology is given. by dissecting the generic model and focusing more on the microarray technologies, an affine model is introduced. here is also the widely adopted and accepted log-ratio log-intensity transform under affine transformations formalized. the results section consists of three main parts. in the first, we show how the affine transform introduces intensity and fold-change dependent biases in the log-ratios. in the second part, we revisit common normalization methods, to which dye-swap and background correction may also be counted, and discuss them using the affine model. in the third and concluding part, we suggest a novel and multi-purpose robust normalization method to back-transform data to the linear  space. we end the paper with a discussion section where we give similarities to other normalization methods followed by a conclusions section. details on calculations and the data set used are given in the methods appendix.

RESULTS
general model
consider an experiment with genes i =  <dig> ..., i from rna extracts c =  <dig> ..., c. for example, in oligonucleotide microarrays each slide measures the gene-expression levels of exactly one rna extract whereas for a two-color microarrays each slide measures two rna extracts, one in each channel. from now on, we refer to the rna extracts or replicates of such as channels. let xc,i be the true gene-expression level of gene i in channel c and let yc, i be the corresponding observed gene-expression level. the relationship between the observed and the true expression levels can be written as

yc,i = fc + εc,i     

where fc is a channel specific measurement function, which includes all steps in the gene-expression acquisition process. most generally, we have that e  =  <dig> and v  = σc,i2
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaaiigacqwfdpwcdaqhaawcbagaem4yammaeiilawiaemyaakgabagaegomaidaaaaa@331f@, where the variance can take any form. importantly, the properties of εc are not well understood and depends on platform used, but also which part of the process that is studied. for this reason and because of the many interesting effects that the affine transformation  generates by itself, we conduct this study under the assumption of noise-free data. relationship  may be specified for subsets of genes or probes, e.g. print tip  <cit> , microtiter plate or clone library  <cit>  groups. spatial dependencies may also be modeled. however, to simplify the discussion that follows, we avoid such details.

since inference is ideally based on xc,i, the inverse of fc has to be identified, something that, in theory, is possible if it is strictly increasing. violation of this constraint has been observed in, for instance, two-color microarray data. this can be due to too high concentrations of fluorophores, which sometimes quenches the signal so much that the signal decreases when the concentration increases  <cit> . extreme saturation in the scanner, which is commonly observed when the pmt gain is set too high, results in censored signals, which in turn prevents a unique inverse of the measurement function to be found. this paper does not discuss saturation further, because we believe that saturation can and should be avoided.

dissection of the overall measurement function
formally, each step in the microarray process can be seen as a function that takes a set of input objects and outputs another set of objects. the sequential nature of the process makes it possible to think of the measurement function fc as a composite function ; fc = fc,s ◦ fc,s- <dig> ◦ ⋯ ◦ fc, <dig>  where s is the number of steps in the process. for instance, and of course simplified, it could be that fc, <dig> models the extraction of the rna from the cell, fc, <dig> models the reverse transcription of rna into cdna and so on. some of these submeasurement functions are shared by several channels and others are channel specific or even gene specific. moreover, there may be joining subfunctions too, e.g. the hybridization of labeled cdna sequences to the probes on the array. in this paper, measurement functions of different channels are treated independently.

a first-order taylor series expansion of an arbitrary measurement function fc, has the form

fc = ac + bcxc,i + rc, ∀c,i.     

from the above dissection of a measurement functions, it is easy to argue that some of the subfunctions may introduce offset  and that there for this reason ought to be an offset in fc . for instance, the offset terms may be due to non-uniformity of the reverse transcription, the labeling  <cit>  or the hybridization, due to dark noise in the pmt  <cit>  or laser scatter light in the scanner, background noise, non-uniformity of the scanned glass slide  <cit> , or threshold effects etc. in  <cit>  it is shown how various background estimates based on different image analysis methods may introduce bias. similarly, we have shown that different scanners may introduce bias  <cit> .

the affine measurement function
in order to focus on the effects of ac and bc, but also because it results in the simplest parametric measurement function possible, we assume rc in  to be small. the affine measurement function is

fc = ac + bcxc,i, ∀c,i,     

with unique inverse

xc,i=fc−1=yc,i−acbc, ∀c,i,     
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaacqwg4baedawgaawcbagaem4yammaeiilawiaemyaakgabeaakiabg2da9iabdagamnaadaaaleaacqwgjbwyaeaacqghsislcqaixaqmaagccqggoaakcqwg5bqedawgaawcbagaem4yammaeiilawiaemyaakgabeaakiabcmcapiabg2da9maalaaabagaemyeak3aasbaasqaaiabdogajjabcycasiabdmgapbqabagccqghsislcqwghbqydawgaawcbagaem4yamgabeaaaoqaaiabdkgainaabaaaleaacqwgjbwyaeqaaaaakiabcycasiabbccagiabgcgiiiabdogajjabcycasiabdmgapjabcycasiaaxmaacawljawaaewaaeaacqai0aanaiaawicacaglpaaaaaa@5614@

where ac is the overall offset  and bc>  <dig> is the overall scale factor in channel c. the ac parameters are commonly positive, but under certain circumstances, for instance, as demonstrated later, when two different measuring techniques are compared, the effective offset may be negative. modeling microarray data by an affine transform is not novel  <cit> , but the reasons for it might have been different in those papers.

the log-ratio log-intensity transform
in two-color but also in oligonucleotide microarray experiments, it is convenient to do statistical analysis on the log-ratios and the log-intensities  <cit>  of the gene-expression levels in two channels instead of on the expression levels directly. for gene i we have that

mi=log⁡2yr,iyg,i=log⁡2frfg     
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaacqwgnbqtdawgaawcbagaemyaakgabeaakiabg2da9igbcygasjabc+gavjabcegannaabaaaleaacqaiyagmaeqaaowaasaaaeaacqwg5bqedawgaawcbagaemouailaeiilawiaemyaakgabeaaaoqaaiabdmha5naabaaaleaacqwghbwrcqggsaalcqwgpbqaaeqaaaaakiabg2da9igbcygasjabc+gavjabcegannaabaaaleaacqaiyagmaeqaaowaasaaaeaacqwgmbgzdawgaawcbagaemouaifabeaakiabcicaoiabdiha4naabaaaleaacqwgsbgucqggsaalcqwgpbqaaeqaaogaeiykakcabagaemozay2aasbaasqaaiabdeeahbqabagccqggoaakcqwg4baedawgaawcbagaem4rackaeiilawiaemyaakgabeaakiabcmcapaaacawljagaaczcamaabmaabagaegynaudacagloagaayzkaaaaaa@5ccf@

ai=12log⁡2=12log⁡2⋅fg).     
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaafaqadegabaaabagaemyqae0aasbaasqaaiabdmgapbqabagccqgh9aqpdawcaaqaaiabigdaxaqaaiabikdayaaacyggsbabcqggvbwbcqggnbwzdawgaawcbagaegomaidabeaakiabcicaoiabdmha5naabaaaleaacqwgsbgucqggsaalcqwgpbqaaeqaaogaeyyxictaemyeak3aasbaasqaaiabdeeahjabcycasiabdmgapbqabagccqggpaqkaeaacqgh9aqpdawcaaqaaiabigdaxaqaaiabikdayaaacyggsbabcqggvbwbcqggnbwzdawgaawcbagaegomaidabeaakiabcicaoiabdagamnaabaaaleaacqwgsbguaeqaaogaeiikagiaemieag3aasbaasqaaiabdkfasjabcycasiabdmgapbqabagccqggpaqkcqghfly1cqwgmbgzdawgaawcbagaem4raceabeaakiabcicaoiabdiha4naabaaaleaacqwghbwrcqggsaalcqwgpbqaaeqaaogaeiykakiaeiykakiaeiola4caaiaaxmaacawljawaaewaaeaacqai2agnaiaawicacaglpaaaaaa@6968@

for simplicity, we denoted channels  <dig> and  <dig> by r and g, which are mnemonics for the red and the green dyes commonly used in two-color microarray data. a rationale for this bijective transform  is that the main measure of interest, the fold change, is contained in one variable. however, since the transform is based on observed expression levels and not the true ones, m alone does indeed not carry all information about the biological fold change. this can be seen if the true fold change for an arbitrary gene i is considered;

ri = xr,i/xg,i     

where ri >  <dig>  dropping gene index i in  and , m and a can be written as functions of xg and r, i.e. m = gr and a = hr. thus,

m=mr=gr),     
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaacqwgnbqtcqgh9aqpcqwgtbqbdawgaawcbagaemocaihabeaakiabcicaoiabdgeabjabcmcapiabg2da9iabdegannaabaaaleaacqwgybgcaeqaaogaeiikagiaemiaag2aa0baasqaaiabdkhaybqaaiabgkhitiabigdaxaaakiabcicaoiabdgeabjabcmcapiabcmcapiabcycasiaaxmaacawljawaaewaaeaacqai4aaoaiaawicacaglpaaaaaa@468c@

which shows that m is a function of a . hence, and discussed thoroughly below, commonly observed intensity-dependent effects in the log-ratios may contain valuable information, and consequently, applying normalization methods without care may result in loss of information and introduced bias.

log-ratios as a function of log-intensities with affine transformations
under an affine transformation, the relationship between the observed log-ratios and the observed log-intensities for a fixed fold change r, omitting gene index i, is

m=mr=log⁡2r+log⁡2β+log⁡212α+142+rβ22a−12α+142+rβ22a     
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaafaqadegabaaabagaemyta0kaeyypa0jaemyba02aasbaasqaaiabdkhaybqabagccqggoaakcqwgbbqqcqggpaqkcqgh9aqpcyggsbabcqggvbwbcqggnbwzdawgaawcbagaegomaidabeaakiabdkhayjabgucarigbcygasjabc+gavjabcegannaabaaaleaacqaiyagmaeqaaggacogae8nsdigabagaey4kasiagiibawmaei4ba8maei4zac2aasbaasqaaiabikdayaqabagcdawcaaqaamaalaaabagaegymaedabagaegomaidaaiab=f7ahjabcicaoiabdkhayjabcmcapiabgucarmaakaaabawaasaaaeaacqaixaqmaeaacqai0aanaagaei4waslae8xsdemaeiikagiaemocainaeiykakiaeiyxa01aawbaasqabeaacqaiyagmaagccqghrawkcqwgybgccqwfyogycqaiyagmdaahaawcbeqaaiabikdayiabdgeabbaaaeqaaagcbagaeyoei0yaasaaaeaacqaixaqmaeaacqaiyagmaagae8xsdemaeiikagiaemocainaeiykakiaey4kasyaaoaaaeaadawcaaqaaiabigdaxaqaaiabisda0aaacqggbbwwcqwfxoqycqggoaakcqwgybgccqggpaqkcqggdbqxdaahaawcbeqaaiabikdayaaakiabgucariabdkhayjab=j7aijabikdaymaacaaaleqabagaegomaijaemyqaeeaaaqabaaaaaaakiaaxmaacawljawaaewaaeaacqai5aqoaiaawicacaglpaaaaaa@812e@

where α = ar - rβag quantifies how much m depends on a at the given fold change, and β = br/bg is the relative scale factor between the two channels compared. see methods for details. recall that log2r is the variable of interest. the derivative of m with respect to a for a fixed fold change r is

dmda|xr=rxg=−α142+rβ22a.     
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaadaabcaqaamaalaaabagaemizaqmaemyta0eabagaemizaqmaemyqaeeaaagaayjcsdwaasbaasqaaiabdiha4naabaaameaacqwgsbguaeqaasgaeyypa0jaemocainaemieag3aasbaawqaaiabdeeahbqabaaaleqaaogaeiikagiaemyqaekaeiykakiaeyypa0jaeyoei0yaasaaaeaaiigacqwfxoqycqggoaakcqwgybgccqggpaqkaeaadagcaaqaamaalaaabagaegymaedabagaeginaqdaaiabcufabjab=f7ahjabcicaoiabdkhayjabcmcapiabc2fadnaacaaaleqabagaegomaidaaogaey4kasiaemocainae8nsdimaegomaizaawbaasqabeaacqaiyagmcqwgbbqqaaaabeaaaagccqgguaglcawljagaaczcamaabmaabagaegymaejaegimaadacagloagaayzkaaaaaa@5bfe@

consider a fixed r and define α = α. then there are only two parameters in  and  that determine the shape of mr , namely α and β. consequently, when ar, ag ≠  <dig>  m is independent of a if and only if α =  <dig>  that is, when r = /. for this particular value of r, we have that the observed log-ratio is m = log <dig> , which is independent of scale factors. moreover, for log-ratios of non-differential expressions, that is log2r =  <dig>  to be independent of a, it must be true that bgar = brag or, equivalently, br/bg = ar/ag. it is also clear from  that the scale parameters cannot introduce any curvature themselves, but only enhance or decrease curvature introduced by the offset. in addition to this, relative scale different from one shifts the log-ratios up or down. moreover, the size of the effect that the offset terms have on the log-ratios decreases as the intensity increases. at high intensities the only observable effect is that from the relative scale between the two channels. the observed log-ratio for non-differentially expressed genes at high intensity is m∞ ≈ log2β. in the case of a linear transform , α is  zero and m is therefore independent of a for all r. the remaining log-ratio bias is log2β. if ar, ag >  <dig>  the "weakest" observable data point is  = , log2), which is independent of both gene expression and scale parameters. all fold-change curves converge to this point. in the left graph of figure  <dig> the effect of the affine transform a1
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufebsjuyzl2yd9gzlbvynv2caerbwvmckfmbhbqedmvetj2bsbwenfgdovwbhrxajfwnhbqeg0uy0hwztfgdpnwy1aqee0evguee0jxyaibaieydoi=bh8vipeydi8qiw7rqqrffpeea0xe9lq=jc9vqaqpepm0xbbg8faspyrqj0=yi0lxdbba9pge9qqff0dxdhuk9fr=xfr=xfrpiwzqaaeaabigaaiaacaqabeaadaqacqaaaoqaagwaaiab=bq8bnaabaaaleaatcvaufkttlearcwrp9mdh5mbpbiqv92aagqbaiab+fdaxaqabaaaaa@43c0@ = { = ,  = } at different fold changes is depicted. the different curves plotted are the functions m = mr for different fold changes. note the asymmetry in curvature between up and down regulation. from the above discussion we know that the observed log-ratios are independent of the log-intensities for log2r ≈ - <dig>  with value m <dig> ≈ - <dig> . the log-ratio for non-differentially expressed genes at high intensities is m∞ ≈ - <dig> . a real-world example taken from  <cit> , where the same array was scanned four times at various scanner pmt  settings, is shown in the right plot of figure  <dig>  observed within-channel log-ratios mc = log2
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaacqwg5bqedaqhaawcbagaem4yamgabagaeiikagiaemodaynaeiykakcaaaaa@32ca@/yc
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaacqwg5bqedaqhaawcbagaem4yamgabagaeiikagiaem4dacnaeiykakcaaaaa@32cc@) are plotted against the within-channel log-intensities ac = log2
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaacqwg5bqedaqhaawcbagaem4yamgabagaeiikagiaemodaynaeiykakcaaaaa@32ca@yc
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaacqwg5bqedaqhaawcbagaem4yamgabagaeiikagiaem4dacnaeiykakcaaaaa@32cc@) / <dig> for the red channel  where yc
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaacqwg5bqedaqhaawcbagaem4yamgabagaeiikagiaemodaynaeiykakcaaaaa@32ca@ and yc
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaacqwg5bqedaqhaawcbagaem4yamgabagaeiikagiaem4dacnaeiykakcaaaaa@32cc@ are observations at two different scanner pmt settings. in this case it turned out that all scans share the same offset. for more details, see  <cit> . for another example, see figure  <dig> 

bias in the log-ratios
from  we see that the bias in the log-ratios introduced by the affine transform is intensity dependent. this non-linearity can be observed as a propeller shaped graph in figure  <dig>  where the log-ratios under the affine transform a1
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufebsjuyzl2yd9gzlbvynv2caerbwvmckfmbhbqedmvetj2bsbwenfgdovwbhrxajfwnhbqeg0uy0hwztfgdpnwy1aqee0evguee0jxyaibaieydoi=bh8vipeydi8qiw7rqqrffpeea0xe9lq=jc9vqaqpepm0xbbg8faspyrqj0=yi0lxdbba9pge9qqff0dxdhuk9fr=xfr=xfrpiwzqaaeaabigaaiaacaqabeaadaqacqaaaoqaagwaaiab=bq8bnaabaaaleaatcvaufkttlearcwrp9mdh5mbpbiqv92aagqbaiab+fdaxaqabaaaaa@43c0@ are plotted against the true log-ratios at different log-intensity levels. if a regression line is fitted between the affine transformed log-ratios and the true log-ratios, the slope will always be less than one. moreover, this is true for all normalization methods that do not overcompensate for channel offsets. this may explain why some studies show that cdna microarrays tend to compress the absolute log-ratios compared to oligoarrays and qrt-pcr  <cit>  including a recent study  <cit> ; the channel offsets in cdna microarrays are probably larger. when  <cit>  compared cdna microarray log-ratios to northern blot log-ratios for their background correction method they found similar behavior, which emphasizes the close relationship between offset and background estimates. we will return to this later. the same patterns is seen in an m versus m scatter plot for non-normalized versus  normalized data. see right scatter plot in figure  <dig>  to visualize the intensity dependency of the log-ratios, only data points at certain log-intensity levels are plotted. for details on data, see methods.

normalization in general
depending on the design of the microarray experiment, we expect to observe different types of patterns in data. a typical example is where a subset of the genes studied is expected to be non-differentially expressed in a test sample compared to a reference sample. however, it is common that the patterns of the observed expression levels are not in line with the expected patterns of the true expression levels. whenever this happens various strategies can be adopted in order to make the normalized data meet the expectations. normalization of microarray data is about identifying and removing such artifactual variations that are not due to noise or natural variability. an example is the intensity-dependent log-ratio artifact.

in the following section we will, with the affine model in mind, revisit various more or less well known normalization methods that directly or indirectly remove intensity-dependent artifacts. with the gained knowledge, we then propose a generic and robust multi-dimensional normalization method for affine transformed data.

to be more precise in what follows, we will refer to methods that correct for differences in observed and expected data, that is, conform the signals to a standard or a norm, as normalization methods, where normalization has the meaning of conforming to expectations. sometimes calibration data, also known as control data, which contains true relative or absolute expression levels, is available. such data can be used to correct for discrepancies between observed and true expression levels. we refer to methods that use calibration  data points to correct for artifacts as calibration methods. to this category we also count methods that are based on models for which we can find the inverse of the measurement function. for precise definitions, see the introduction of  <cit> . calibration methods are not discussed further in this paper.

typically a normalization method is only capable of estimating α = ar - βag for r =  <dig> in  and not the individual offset terms. this is because the often used assumption that most genes are non-differentially expressed  will only help us identify one fold-change curve, namely log <dig> r =  <dig>  for a normalization method, like most calibration methods, to be able to estimate both ar and ag more constraints are needed and without known data this can only be done based on more assumptions. as more research is needed, we will not elaborate on such additional assumptions in this paper. thus, the rest of this paper will only discuss normalization methods based on the commonly accepted assumption that it is possible to identify a set of genes that can be used to normalize the non-differentially expressed genes.

curve-fit normalization revisited
when  <cit>  first observed the intensity-dependent effects on the log-ratios they suggested a curve-fit normalization method that is often referred to as loess normalization. the simplest version of this assumes that the majority of the genes are non-differentially expressed regardless of expression level and for this reason the log-ratios are expected to be centered around zero for all intensities. under the above assumption, curves estimated using robust local regression methods such as lowess  <cit>  or loess  <cit> , or curves modeled by smoothing splines  <cit>  will be good approximations for the mr =  <dig> function, which then can be subtracted from the observed log-ratios

m ← m - mr= <dig>  = mr  - mr= <dig>      

under an affine transform, mr and mr= <dig>  are as in , but we do not know of a closed form expression for . an example of a curve-fit normalization under the affine transform is depicted in figure  <dig>  note that the asymmetry between up- and down-regulated genes is not corrected for. moreover, if we look at the overlaid  grid in the left graph of figure  <dig>  we find that the curve-fit normalization warps it and removes the otherwise orthogonal relationship between log2xr and log2xg  plane is considered).

perpendicular translation normalization revisited
the perpendicular  normalization method proposed by  <cit>  corrects for differences in the channel offsets. it normalizes log-ratios using a translation transform where a constant, a ∈ ℝ, is added to the signals in one channel and subtracted from the other;

yr,i←ar+brxr,i+a; ∀iyg,i←ag+bgxg,i−a; ∀i.     
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaafaqabegabaaabagaemyeak3aasbaasqaaiabdkfasjabcycasiabdmgapbqabagccqghqgcrcqwghbqydawgaawcbagaemouaifabeaakiabgucariabdkgainaabaaaleaacqwgsbguaeqaaogaemieag3aasbaasqaaiabdkfasjabcycasiabdmgapbqabagccqghrawkcqwghbqycqgg7awocqqggaaicqghaiiicqwgpbqaaeaacqwg5bqedawgaawcbagaem4rackaeiilawiaemyaakgabeaakiabgcziskabdggahnaabaaaleaacqwghbwraeqaaogaey4kasiaemoyai2aasbaasqaaiabdeeahbqabagccqwg4baedawgaawcbagaem4rackaeiilawiaemyaakgabeaakiabgkhitiabdggahjabcuda7iabbccagiabgcgiiiabdmgapjabc6cauaaacawljagaaczcamaabmaabagaegymaejaegomaidacagloagaayzkaaaaaa@62eb@

we refer to this translation normalization transform as the perpendicular translation normalization, because it moves  perpendicular to the xr = xg line. from , we get that the observed log-ratios mr can be made independent of the intensities if and only if

a=rbrag−bgarbg+rbr, r> <dig>      
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaacqwghbqycqgh9aqpdawcaaqaaiabdkhayjabdkgainaabaaaleaacqwgsbguaeqaaogaemyyae2aasbaasqaaiabdeeahbqabagccqghsislcqwgibgydawgaawcbagaem4raceabeaakiabdggahnaabaaaleaacqwgsbguaeqaaagcbagaemoyai2aasbaasqaaiabdeeahbqabagccqghrawkcqwgybgccqwgibgydawgaawcbagaemouaifabeaaaagccqggsaalcqqggaaicqwgybgccqgh+agpcqaiwaamcqgguaglcawljagaaczcamaabmaabagaegymaejaeg4mamdacagloagaayzkaaaaaa@4e2f@

as this is a function of r, it is only for a single fold change at a time this method can make m independent of a. the most common choice is r =  <dig> for which the optimal perpendicular shift is

a=brag−bgarbg+br,     
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaacqwghbqycqgh9aqpdawcaaqaaiabdkgainaabaaaleaacqwgsbguaeqaaogaemyyae2aasbaasqaaiabdeeahbqabagccqghsislcqwgibgydawgaawcbagaem4raceabeaakiabdggahnaabaaaleaacqwgsbguaeqaaagcbagaemoyai2aasbaasqaaiabdeeahbqabagccqghrawkcqwgibgydawgaawcbagaemouaifabeaaaagccqggsaalcawljagaaczcamaabmaabagaegymaejaeginaqdacagloagaayzkaaaaaa@4649@

which is the weighted difference between ar and ag with weights bg/ and br/, respectively. the distance from the r =  <dig> curve to the m =  <dig> curve for the optimal perpendicular shift is log <dig> β. in other words, the perpendicular shift normalization will not remove an overall bias in the log-ratios . the optimal shift for a1
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufebsjuyzl2yd9gzlbvynv2caerbwvmckfmbhbqedmvetj2bsbwenfgdovwbhrxajfwnhbqeg0uy0hwztfgdpnwy1aqee0evguee0jxyaibaieydoi=bh8vipeydi8qiw7rqqrffpeea0xe9lq=jc9vqaqpepm0xbbg8faspyrqj0=yi0lxdbba9pge9qqff0dxdhuk9fr=xfr=xfrpiwzqaaeaabigaaiaacaqabeaadaqacqaaaoqaagwaaiab=bq8bnaabaaaleaatcvaufkttlearcwrp9mdh5mbpbiqv92aagqbaiab+fdaxaqabaaaaa@43c0@ is a =  <dig> with log2β =  <dig> . the result of this normalization is depicted in figure  <dig>  note that mr after normalization is constant for r =  <dig> 

as suggested by  <cit> , one way to find the optimal shift a is to minimize the curvature by minimizing the variation of the log-ratios after applying the shift a. to do this robustly, the median absolute deviation  can be used as a measure of variation;

a^=arg⁡min⁡amad1≤i≤i).     
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaacuwghbqygaqcaiabg2da9igbcggahjabckhayjabcegannaaxababagagiyba0maeiyaakmaeioba4galeaacqwghbqyaeqaaowaacbeaeaacqqgnbqtcqqgbbqqcqqgebarasqaaiabigdaxiabgsmijkabdmgapjabgsmijkabdmeajbqabagccqggoaakcqwgnbqtdawgaawcbagaemyaakgabeaakiabcicaoiabdggahjabcmcapiabcmcapiabc6cauiaaxmaacawljawaaewaaeaacqaixaqmcqai1aqnaiaawicacaglpaaaaaa@5013@

we have found that the variance of a^
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaacuwghbqygaqcaaaa@2e07@ is unnecessarily large.

a problem with the perpendicular translation normalization methods, which is not related to estimator , is that the optimal shift can result in non-positive signals making a huge number of expression ratios invalid. the normalization method discussed next does not have this problem, but on the other hand, it will not work or work badly under certain conditions.

parallel translation normalization revisited
for historical reasons, but also because it contributes to our discussion about background correction, the shift-log method proposed by  <cit>  for stabilizing  the variance of the measured log-ratios is of interest. a side effect of this method is that it can correct for intensity-dependent curvature. it is based on a translation transform where the same constant, a ∈ ℝ, is added to the signals in both channels;

yr,i←ar+brxr,i+a; ∀iyg,i←ag+bgxg,i+a; ∀i.     
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaafaqabegabaaabagaemyeak3aasbaasqaaiabdkfasjabcycasiabdmgapbqabagccqghqgcrcqwghbqydawgaawcbagaemouaifabeaakiabgucariabdkgainaabaaaleaacqwgsbguaeqaaogaemieag3aasbaasqaaiabdkfasjabcycasiabdmgapbqabagccqghrawkcqwghbqycqgg7awocqqggaaicqghaiiicqwgpbqaaeaacqwg5bqedawgaawcbagaem4rackaeiilawiaemyaakgabeaakiabgcziskabdggahnaabaaaleaacqwghbwraeqaaogaey4kasiaemoyai2aasbaasqaaiabdeeahbqabagccqwg4baedawgaawcbagaem4rackaeiilawiaemyaakgabeaakiabgucariabdggahjabcuda7iabbccagiabgcgiiiabdmgapjabc6cauaaacawljagaaczcamaabmaabagaegymaejaegonaydacagloagaayzkaaaaaa@62e8@

because  moves data  parallel to the xr = xg line, it is referred to as the parallel translation normalization. again, as this is a function of r, m can only be made independent of a for one unique r at the time, cf. . for r =  <dig> the optimal parallel shift is

a=brag−bgarbg−br, bg≠br,     
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaacqwghbqycqgh9aqpdawcaaqaaiabdkgainaabaaaleaacqwgsbguaeqaaogaemyyae2aasbaasqaaiabdeeahbqabagccqghsislcqwgibgydawgaawcbagaem4raceabeaakiabdggahnaabaaaleaacqwgsbguaeqaaagcbagaemoyai2aasbaasqaaiabdeeahbqabagccqghsislcqwgibgydawgaawcbagaemouaifabeaaaagccqggsaalcqqggaaicqwgibgydawgaawcbagaem4raceabeaakiabgcmi5kabdkgainaabaaaleaacqwgsbguaeqaaogaeiilawiaaczcaiaaxmaadaqadaqaaiabigdaxiabieda3agaayjkaiaawmcaaaaa@4f12@

which may be estimated as in . for example, for a1
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufebsjuyzl2yd9gzlbvynv2caerbwvmckfmbhbqedmvetj2bsbwenfgdovwbhrxajfwnhbqeg0uy0hwztfgdpnwy1aqee0evguee0jxyaibaieydoi=bh8vipeydi8qiw7rqqrffpeea0xe9lq=jc9vqaqpepm0xbbg8faspyrqj0=yi0lxdbba9pge9qqff0dxdhuk9fr=xfr=xfrpiwzqaaeaabigaaiaacaqabeaadaqacqaaaoqaagwaaiab=bq8bnaabaaaleaatcvaufkttlearcwrp9mdh5mbpbiqv92aagqbaiab+fdaxaqabaaaaa@43c0@ the optimal parallel shift is a =  <dig> with the r =  <dig> curve  <dig>  units below the m =  <dig> line. the result of this normalization is depicted in figure  <dig>  from the above expression, we also see that an optimal value of a can indeed be negative. for example, if  =  and  = , the optimal parallel shift is a = - <dig>  which corresponds to an effective shift of  = . however, it can also result in non-positive signals and therefore undefined log-ratios. for example, with  =  and  = , the optimal parallel shift is a = - <dig>  which corresponds to an effective shift of  = . moreover, from  we see that when the scale parameters are equal there is no solution. this is because in such cases data is moved in parallel to the xr = xg line making it impossible to get closer. as in the case of the perpendicular shift normalization, the distance between the r =  <dig> curve and the m =  <dig> curve is log <dig> β. hence, a parallel shift normalization will not remove an overall bias in the log-ratios either and rescaling is necessary.

single-channel translation normalization
a hybrid of the previous two methods is a normalization method that translates the signals in one of the channels at the time according to

yr,i←ar+brxr,i+a⋅i; ∀iyg,i←ag+bgxg,i−a⋅i; ∀i,     
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbamrthrhal1wy0l2yhvtyaehbnfgdovwbhrxajfwnaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabawaaegaeaaakqaabeqaaiabdmha5naabaaaleaacqwgsbgucqggsaalcqwgpbqaaeqaaogaeyikhwqaemyyae2aasbaasqaaiabdkfasbqabagccqghrawkcqwgibgydawgaawcbagaemouaifabeaakiabdiha4naabaaaleaacqwgsbgucqggsaalcqwgpbqaaeqaaogaey4kasiaemyyaemaeyyxicdefcuasx2uh52cagqbaiab=leajjab=hcaogqaaiab+hcaoiab+fgahjabgwmizkab+bdawiab+lcapiab+tda7iabbccagiabgcgiiiabdmgapbqaaiabdmha5naabaaaleaacqwghbwrcqggsaalcqwgpbqaaeqaaogaeyikhwqaemyyae2aasbaasqaaiabdeeahbqabagccqghrawkcqwgibgydawgaawcbagaem4raceabeaakiabdiha4naabaaaleaacqwghbwrcqggsaalcqwgpbqaaeqaaogaeyoei0iaemyyaemaeyyxictae8xsakkae4hkagiae4xyaemae4hpawjae4hmaajae4xkakiae43oasjaeeiiaaiaeyiaiiiaemyaakmaeiilawiaaczcaiaaxmaadaqadaqaaiabigdaxiabiida4agaayjkaiaawmcaaaaaaa@81e2@

where i
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbamrthrhal1wy0l2yhvtyaehbnfgdovwbhrxajfwnaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabawaaegaeaaakeaaruwrpxgbtfmbzbacfagae8xsakeaaa@3ab6@ is the indicator function and a ∈ ℝ. this will not generate non-positive signals as only positive translations are applied. moreover, because only one channel is shifted an optimal shift will always be found.

rescale normalization
the above translation normalization methods remove curvature for non-differentially by adjusting the offset parameters in α = ar - βag keeping the relative scale β fixed. similarly, if the offset parameters are kept fixed, curvature can be removed by adjusting the relative scale β. in  <cit>  we show that the scanner may introduce scale  insensitive  biases to the channels. thus, by adjusting the pmt settings such that the curvature of the pre-scanned data is as small as possible one minimizes |α| = |ar - βag|. indeed, this strategy may in practice be used by many. however, from above we know that this can equally well be done numerically. it is much more important to adjust the pmt  settings such that the dynamical range of the signals is as large as possible. furthermore, as scanner settings are often adjusted for each array separately, there will be a discrepancy between arrays, which in any case has to be normalized for.

dye-swap normalization revisited
dye-swap normalization, also known as reverse labeling and paired-slides normalization, is a balanced experimental design for two-color microarrays that can be used whenever two technically replicated hybridizations are available. consider an experiment with two sets of cell populations, a and b, for which relative gene expressions, {ri}i, are to be investigated. after cdna is obtained through reverse transcription, the two samples are each split into two identical parts, one which is labeled with a red fluorescent dye and one which is labeled with a green fluorescent dye. the red cdna cocktail from sample a is mixed with the green ditto from sample b and co-hybridized to the dna on the first array. after scanning, expression levels {,fr1)}i
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaacqgg7bwecqggoaakcqwgmbgzdawgaawcbagaem4rac0aasbaawqaaiabigdaxaqabaaaleqaaogaeiikagiaemieag3aasbaasqaaiabdkeacjabcycasiabdmgapbqabagccqggpaqkcqggsaalcqwgmbgzdawgaawcbagaemouai1aasbaawqaaiabigdaxaqabaaaleqaaogaeiikagiaemieag3aasbaasqaaiabdgeabjabcycasiabdmgapbqabagccqggpaqkcqggpaqkcqgg9bqfdawgaawcbagaemyaakgabeaaaaa@48bf@ are observed. the same is done for the remaining red-green pair for which {,fr2)}i
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaacqgg7bwecqggoaakcqwgmbgzdawgaawcbagaem4rac0aasbaawqaaiabikdayaqabaaaleqaaogaeiikagiaemieag3aasbaasqaaiabdgeabjabcycasiabdmgapbqabagccqggpaqkcqggsaalcqwgmbgzdawgaawcbagaemouai1aasbaawqaaiabikdayaqabaaaleqaaogaeiikagiaemieag3aasbaasqaaiabdkeacjabcycasiabdmgapbqabagccqggpaqkcqggpaqkcqgg9bqfdawgaawcbagaemyaakgabeaaaaa@48c3@ are observed. dropping gene index i, the dye-swap normalization suggested by  <cit>  is

m=12=12fg1−log⁡2fr2fg2)=12fr2+log⁡2fg2fg1)=12     
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaafaqadeabbaaaaeaacqwgnbqtcqgh9aqpdawcaaqaaiabigdaxaqaaiabikdayaaacqggoaakcqwgnbqtdawgaawcbagaegymaedabeaakiabgucariabd2eannaabaaaleaacqaiyagmaeqaaogaeiykakcabagaeyypa0zaasaaaeaacqaixaqmaeaacqaiyagmaawaaewaaeaacyggsbabcqggvbwbcqggnbwzdawgaawcbagaegomaidabeaakmaalaaabagaemozay2aasbaasqaaiabdkfasnaabaaameaacqaixaqmaeqaaawcbeaakiabcicaoiabdiha4naabaaaleaacqwgbbqqaeqaaogaeiykakcabagaemozay2aasbaasqaaiabdeeahnaabaaameaacqaixaqmaeqaaawcbeaakiabcicaoiabdiha4naabaaaleaacqwgcbgqaeqaaogaeiykakcaaiabgkhitigbcygasjabc+gavjabcegannaabaaaleaacqaiyagmaeqaaowaasaaaeaacqwgmbgzdawgaawcbagaemouai1aasbaawqaaiabikdayaqabaaaleqaaogaeiikagiaemieag3aasbaasqaaiabdkeacbqabagccqggpaqkaeaacqwgmbgzdawgaawcbagaem4rac0aasbaawqaaiabikdayaqabaaaleqaaogaeiikagiaemieag3aasbaasqaaiabdgeabbqabagccqggpaqkaaaacagloagaayzkaaaabagaeyypa0zaasaaaeaacqaixaqmaeaacqaiyagmaawaaewaaeaacyggsbabcqggvbwbcqggnbwzdawgaawcbagaegomaidabeaakmaalaaabagaemozay2aasbaasqaaiabdkfasnaabaaameaacqaixaqmaeqaaawcbeaakiabcicaoiabdiha4naabaaaleaacqwgbbqqaeqaaogaeiykakcabagaemozay2aasbaasqaaiabdkfasnaabaaameaacqaiyagmaeqaaawcbeaakiabcicaoiabdiha4naabaaaleaacqwgcbgqaeqaaogaeiykakcaaiabgucarigbcygasjabc+gavjabcegannaabaaaleaacqaiyagmaeqaaowaasaaaeaacqwgmbgzdawgaawcbagaem4rac0aasbaawqaaiabikdayaqabaaaleqaaogaeiikagiaemieag3aasbaasqaaiabdgeabbqabagccqggpaqkaeaacqwgmbgzdawgaawcbagaem4rac0aasbaawqaaiabigdaxaqabaaaleqaaogaeiikagiaemieag3aasbaasqaaiabdkeacbqabagccqggpaqkaaaacagloagaayzkaaaabagaeyypa0zaasaaaeaacqaixaqmaeaacqaiyagmaagaeiikagiafmyta0kbauaadawgaawcbagaegymaedabeaakiabgucariqbd2eanzaafawaasbaasqaaiabikdayaqabagccqggpaqkaagaaczcaiaaxmaadaqadaqaaiabigdaxiabimda5agaayjkaiaawmcaaaaa@a938@

and similarly for the log-intensities

a=12=log⁡2fg1)+log⁡2fg2)4=log⁡2fr2)+log⁡2fg1)4= <dig>      
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaafaqadeabbaaaaeaacqwgbbqqcqgh9aqpdawcaaqaaiabigdaxaqaaiabikdayaaacqggoaakcqwgbbqqdawgaawcbagaegymaedabeaakiabgucariabdgeabnaabaaaleaacqaiyagmaeqaaogaeiykakcabagaeyypa0zaasaaaeaacyggsbabcqggvbwbcqggnbwzdawgaawcbagaegomaidabeaakiabcicaoiabdagamnaabaaaleaacqwgsbgudawgaaadbagaegymaedabeaaasqabagccqggoaakcqwg4baedawgaawcbagaemyqaeeabeaakiabcmcapiabdagamnaabaaaleaacqwghbwrdawgaaadbagaegymaedabeaaasqabagccqggoaakcqwg4baedawgaawcbagaemoqaieabeaakiabcmcapiabcmcapiabgucarigbcygasjabc+gavjabcegannaabaaaleaacqaiyagmaeqaaogaeiikagiaemozay2aasbaasqaaiabdkfasnaabaaameaacqaiyagmaeqaaawcbeaakiabcicaoiabdiha4naabaaaleaacqwgcbgqaeqaaogaeiykakiaemozay2aasbaasqaaiabdeeahnaabaaameaacqaiyagmaeqaaawcbeaakiabcicaoiabdiha4naabaaaleaacqwgbbqqaeqaaogaeiykakiaeiykakcabagaeginaqdaaaqaaiabg2da9maalaaabagagiibawmaei4ba8maei4zac2aasbaasqaaiabikdayaqabagccqggoaakcqwgmbgzdawgaawcbagaemouai1aasbaawqaaiabigdaxaqabaaaleqaaogaeiikagiaemieag3aasbaasqaaiabdgeabbqabagccqggpaqkcqwgmbgzdawgaawcbagaemouai1aasbaawqaaiabikdayaqabaaaleqaaogaeiikagiaemieag3aasbaasqaaiabdkeacbqabagccqggpaqkcqggpaqkcqghrawkcyggsbabcqggvbwbcqggnbwzdawgaawcbagaegomaidabeaakiabcicaoiabdagamnaabaaaleaacqwghbwrdawgaaadbagaegomaidabeaaasqabagccqggoaakcqwg4baedawgaawcbagaemyqaeeabeaakiabcmcapiabdagamnaabaaaleaacqwghbwrdawgaaadbagaegymaedabeaaasqabagccqggoaakcqwg4baedawgaawcbagaemoqaieabeaakiabcmcapiabcmcapaqaaiabisda0aaaaeaacqgh9aqpdawcaaqaaiabigdaxaqaaiabikdayaaacqggoaakcuwgbbqqgaqbamaabaaaleaacqaixaqmaeqaaogaey4kasiafmyqaekbauaadawgaawcbagaegomaidabeaakiabcmcapiabc6cauaaacawljagaaczcamaabmaabagaegomaijaegimaadacagloagaayzkaaaaaa@ab27@

thus, the result of a dye-swap can be written as the average of two "virtual" hybridizations  and . moreover, if  the measurement functions are equal for each array, that is, fr1=fr2
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaacqwgmbgzdawgaawcbagaemouai1aasbaawqaaiabigdaxaqabaaaleqaaogaeyypa0jaemozay2aasbaasqaaiabdkfasnaabaaameaacqaiyagmaeqaaawcbeaaaaa@356a@ and fg1=fg2
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaacqwgmbgzdawgaawcbagaem4rac0aasbaawqaaiabigdaxaqabaaaleqaaogaeyypa0jaemozay2aasbaasqaaiabdeeahnaabaaameaacqaiyagmaeqaaawcbeaaaaa@353e@, then the observed ratios will be identical to the true ratios for non-differentially expressed genes. for this to be true for differentially expressed genes we know that they also have to be linear, that is, affine with zero intercept.

several authors  <cit>  have reported that dye-swap normalization does remove curvature, but less successful results have also been reported  <cit> . to better understand the reasons why and when dye-swap normalization works or not, we dissect the measurement functions fc of the four channels c = r <dig>  g <dig>  r <dig>  g <dig> into  where sc models the process of all steps up to the step where the  cdna sample is obtained, tc models the labeling, uc models the following steps including the hybridization, and vc models the scanning etc. as channel r <dig> and g <dig> are from sample a and the other two are from sample b, we know that sr1=sg2=sa
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaacqwgzbwcdawgaawcbagaemouai1aasbaawqaaiabigdaxaqabaaaleqaaogaeyypa0jaem4cam3aasbaasqaaiabdeeahnaabaaameaacqaiyagmaeqaaawcbeaakiabg2da9iabdohaznaabaaaleaacqwgbbqqaeqaaaaa@393e@ and sr2=sg1=sb
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaacqwgzbwcdawgaawcbagaemouai1aasbaawqaaiabikdayaqabaaaleqaaogaeyypa0jaem4cam3aasbaasqaaiabdeeahnaabaaameaacqaixaqmaeqaaawcbeaakiabg2da9iabdohaznaabaaaleaacqwgcbgqaeqaaaaa@3940@. furthermore, if the labeling process is well controlled, we can assume that tr1≈tr2≈tr
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaacqwg0baddawgaawcbagaemouai1aasbaawqaaiabigdaxaqabaaaleqaaogaeyisisraemidaq3aasbaasqaaiabdkfasnaabaaameaacqaiyagmaeqaaawcbeaakiabgiki7kabdsha0naabaaaleaacqwgsbguaeqaaaaa@3ad2@ and tg1≈tg2≈tg
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaacqwg0baddawgaawcbagaem4rac0aasbaawqaaiabigdaxaqabaaaleqaaogaeyisisraemidaq3aasbaasqaaiabdeeahnaabaaameaacqaiyagmaeqaaawcbeaakiabgiki7kabdsha0naabaaaleaacqwghbwraeqaaaaa@3a90@. when channel r <dig> and g <dig> are hybridized to array  <dig> and the other two to array  <dig> we have that ur1≈ug1≈u1
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaacqwg1bqddawgaawcbagaemouai1aasbaawqaaiabigdaxaqabaaaleqaaogaeyisisraemydau3aasbaasqaaiabdeeahnaabaaameaacqaixaqmaeqaaawcbeaakiabgiki7kabdwha1naabaaaleaacqaixaqmaeqaaaaa@3a83@ and ur2≈ug2≈u2
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaacqwg1bqddawgaawcbagaemouai1aasbaawqaaiabikdayaqabaaaleqaaogaeyisisraemydau3aasbaasqaaiabdeeahnaabaaameaacqaiyagmaeqaaawcbeaakiabgiki7kabdwha1naabaaaleaacqaiyagmaeqaaaaa@3a89@. moreover, if the same scanner settings are used for both arrays and everything else is equal, we have that vr1≈vr2≈vr
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaacqwg2bgddawgaawcbagaemouai1aasbaawqaaiabigdaxaqabaaaleqaaogaeyisisraemoday3aasbaasqaaiabdkfasnaabaaameaacqaiyagmaeqaaawcbeaakiabgiki7kabdaha2naabaaaleaacqwgsbguaeqaaaaa@3ade@ and vg1≈vg2≈vg
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaacqwg2bgddawgaawcbagaem4rac0aasbaawqaaiabigdaxaqabaaaleqaaogaeyisisraemoday3aasbaasqaaiabdeeahnaabaaameaacqaiyagmaeqaaawcbeaakiabgiki7kabdaha2naabaaaleaacqwghbwraeqaaaaa@3a9c@. the overall measurement functions for the channels are then approximately

fr1≈vr∘u1∘tr∘safg1≈vg∘u1∘tg∘sbfr2≈vr∘u2∘tr∘sbfg2≈vg∘u2∘tg∘sa.     
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaafaqabeabbaaaaeaacqwgmbgzdawgaawcbagaemouai1aasbaawqaaiabigdaxaqabaaaleqaaogaeyisisraemoday3aasbaasqaaiabdkfasbqabagccqwiyiybcqwg1bqddawgaawcbagaegymaedabeaakiablihivjabdsha0naabaaaleaacqwgsbguaeqaaogaesigi8maem4cam3aasbaasqaaiabdgeabbqabaaakeaacqwgmbgzdawgaawcbagaem4rac0aasbaawqaaiabigdaxaqabaaaleqaaogaeyisisraemoday3aasbaasqaaiabdeeahbqabagccqwiyiybcqwg1bqddawgaawcbagaegymaedabeaakiablihivjabdsha0naabaaaleaacqwghbwraeqaaogaesigi8maem4cam3aasbaasqaaiabdkeacbqabaaakeaacqwgmbgzdawgaawcbagaemouai1aasbaawqaaiabikdayaqabaaaleqaaogaeyisisraemoday3aasbaasqaaiabdkfasbqabagccqwiyiybcqwg1bqddawgaawcbagaegomaidabeaakiablihivjabdsha0naabaaaleaacqwgsbguaeqaaogaesigi8maem4cam3aasbaasqaaiabdkeacbqabaaakeaacqwgmbgzdawgaawcbagaem4rac0aasbaawqaaiabikdayaqabaaaleqaaogaeyisisraemoday3aasbaasqaaiabdeeahbqabagccqwiyiybcqwg1bqddawgaawcbagaegomaidabeaakiablihivjabdsha0naabaaaleaacqwghbwraeqaaogaesigi8maem4cam3aasbaasqaaiabdgeabbqabagccqgguaglaagaaczcaiaaxmaadaqadaqaaiabikdayiabigdaxagaayjkaiaawmcaaaaa@82a8@

for the dye-swap normalization to be efficient, we conclude that we must control the process of extracting the rna etc. to an extent such that we can expect sa ≈ sb. moreover, we must also be able to reproduce hybridizations well enough such that u <dig> ≈ u <dig>  if these requirements are met, data will be self-normalized. turning to the affine model, from  we have, if fr1=fr2
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaacqwgmbgzdawgaawcbagaemouai1aasbaawqaaiabigdaxaqabaaaleqaaogaeyypa0jaemozay2aasbaasqaaiabdkfasnaabaaameaacqaiyagmaeqaaawcbeaaaaa@356a@ and fg1=fg2
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaacqwgmbgzdawgaawcbagaem4rac0aasbaawqaaiabigdaxaqabaaaleqaaogaeyypa0jaemozay2aasbaasqaaiabdeeahnaabaaameaacqaiyagmaeqaaawcbeaaaaa@353e@. that a dye-swap normalization of affine transformation data gives

m′1=log⁡2ar+brxaar+brxb,m′2=log⁡2ag+bgxaag+bgxb,     
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakqaabeqaaiqbd2eanzaafawaasbaasqaaiabigdaxaqabagccqgh9aqpcyggsbabcqggvbwbcqggnbwzdawgaawcbagaegomaidabeaakmaalaaabagaemyyae2aasbaasqaaiabdkfasbqabagccqghrawkcqwgibgydawgaawcbagaemouaifabeaakiabdiha4naabaaaleaacqwgbbqqaeqaaagcbagaemyyae2aasbaasqaaiabdkfasbqabagccqghrawkcqwgibgydawgaawcbagaemouaifabeaakiabdiha4naabaaaleaacqwgcbgqaeqaaaaakiabcycasaqaaiqbd2eanzaafawaasbaasqaaiabikdayaqabagccqgh9aqpcyggsbabcqggvbwbcqggnbwzdawgaawcbagaegomaidabeaakmaalaaabagaemyyae2aasbaasqaaiabdeeahbqabagccqghrawkcqwgibgydawgaawcbagaem4raceabeaakiabdiha4naabaaaleaacqwgbbqqaeqaaagcbagaemyyae2aasbaasqaaiabdeeahbqabagccqghrawkcqwgibgydawgaawcbagaem4raceabeaakiabdiha4naabaaaleaacqwgcbgqaeqaaaaakiabcycasiaaxmaacawljawaaewaaeaacqaiyagmcqaiyagmaiaawicacaglpaaaaaaa@681c@

and similar for a′1
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaacuwgbbqqgaqbamaabaaaleaacqaixaqmaeqaaaaa@2edf@ and a′2
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaacuwgbbqqgaqbamaabaaaleaacqaiyagmaeqaaaaa@2ee1@. for both virtual arrays, the signals in both channels have undergone identical affine transformations. we know from before that identical transformation in both channels does not introduce curvature for the non-differentially expressed genes and that symmetry between up- and down-regulated genes is preserved, cf. perpendicular and parallel shift normalization. if the offsets in any of the two replicated channels are not equal , the dye-swap normalization will not work.

the above discussion assumed that the same cell samples have been replicated. if biological replicates are used, an additional source of variability is introduced. however, as long as it is possible to assume that for most genes xa1≈xa2
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaacqwg4baedawgaawcbagaemyqae0aasbaawqaaiabigdaxaqabaaaleqaaogaeyisisraemieag3aasbaasqaaiabdgeabnaabaaameaacqaiyagmaeqaaawcbeaaaaa@3619@ and xb1≈xb2
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaacqwg4baedawgaawcbagaemoqai0aasbaawqaaiabigdaxaqabaaaleqaaogaeyisisraemieag3aasbaasqaaiabdkeacnaabaaameaacqaiyagmaeqaaawcbeaaaaa@361d@. dye-swap normalization should still perform well.

in  <cit>  we observed that scanners can introduce channel-specific offsets that are stable over time, i.e. ar1=ar2
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaacqwghbqydawgaawcbagaemouai1aasbaawqaaiabigdaxaqabaaaleqaaogaeyypa0jaemyyae2aasbaasqaaiabdkfasnaabaaameaacqaiyagmaeqaaawcbeaaaaa@3556@ and ag1=ag2
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaacqwghbqydawgaawcbagaem4rac0aasbaawqaaiabigdaxaqabaaaleqaaogaeyypa0jaemyyae2aasbaasqaaiabdeeahnaabaaameaacqaiyagmaeqaaawcbeaaaaa@352a@. assume that everything else is perfect, but the pmt is adjusted separately for each array resulting in br1/br2≠br2/br1
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaacqwgibgydawgaawcbagaemouai1aasbaawqaaiabigdaxaqabaaaleqaaogaei4la8iaemoyai2aasbaasqaaiabdkfasnaabaaameaacqaiyagmaeqaaawcbeaakiabgcmi5kabdkgainaabaaaleaacqwgsbgudawgaaadbagaegomaidabeaaasqabagccqggvawlcqwgibgydawgaawcbagaemouai1aasbaawqaaiabigdaxaqabaaaleqaaaaa@3f99@ so that  is not obtained. this may be a reason why dye-swap normalization sometimes fails.

alternative dye-swap normalization
an alternative dye-swap normalization method is to average the observed expression levels before taking the logarithm

m=log⁡2+fg2)/2+fg1)/2=log⁡2fr1+fg2fr2+fg <dig>      
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaafaqadegabaaabagaemyta0kaeyypa0jagiibawmaei4ba8maei4zac2aasbaasqaaiabikdayaqabagcdawcaaqaaiabcicaoiabdagamnaabaaaleaacqwgsbgudawgaaadbagaegymaedabeaaasqabagccqggoaakcqwg4baedawgaawcbagaemyqaeeabeaakiabcmcapiabgucariabdagamnaabaaaleaacqwghbwrdawgaaadbagaegomaidabeaaasqabagccqggoaakcqwg4baedawgaawcbagaemyqaeeabeaakiabcmcapiabcmcapiabc+caviabikdayaqaaiabcicaoiabdagamnaabaaaleaacqwgsbgudawgaaadbagaegomaidabeaaasqabagccqggoaakcqwg4baedawgaawcbagaemoqaieabeaakiabcmcapiabgucariabdagamnaabaaaleaacqwghbwrdawgaaadbagaegymaedabeaaasqabagccqggoaakcqwg4baedawgaawcbagaemoqaieabeaakiabcmcapiabcmcapiabc+caviabikdayaaaaeaacqgh9aqpcyggsbabcqggvbwbcqggnbwzdawgaawcbagaegomaidabeaakmaalaaabagaemozay2aasbaasqaaiabdkfasnaabaaameaacqaixaqmaeqaaawcbeaakiabcicaoiabdiha4naabaaaleaacqwgbbqqaeqaaogaeiykakiaey4kasiaemozay2aasbaasqaaiabdeeahnaabaaameaacqaiyagmaeqaaawcbeaakiabcicaoiabdiha4naabaaaleaacqwgbbqqaeqaaogaeiykakcabagaemozay2aasbaasqaaiabdkfasnaabaaameaacqaiyagmaeqaaawcbeaakiabcicaoiabdiha4naabaaaleaacqwgcbgqaeqaaogaeiykakiaey4kasiaemozay2aasbaasqaaiabdeeahnaabaaameaacqaixaqmaeqaaawcbeaakiabcicaoiabdiha4naabaaaleaacqwgcbgqaeqaaogaeiykakcaaiabcycasaaacawljagaaczcamaabmaabagaegomaijaeg4mamdacagloagaayzkaaaaaa@8cdd@

and analogously for a. this approach uses the arithmetic mean of the observed signals whereas the previous dye-swap method used the geometric mean. to be able to say more about the difference between the two approaches, we turn to the affine transformation for which we have

m=log⁡2a′+b′xaa′+b′xba=log⁡22     
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaafaqadegabaaabagaemyta0kaeyypa0jagiibawmaei4ba8maei4zac2aasbaasqaaiabikdayaqabagcdawcaaqaaiqbdggahzaafagaey4kasiafmoyaimbauaacqwg4baedawgaawcbagaemyqaeeabeaaaoqaaiqbdggahzaafagaey4kasiafmoyaimbauaacqwg4baedawgaawcbagaemoqaieabeaaaaaakeaacqwgbbqqcqgh9aqpdawcaaqaaigbcygasjabc+gavjabcegannaabaaaleaacqaiyagmaeqaaogaeiikagiafmyyaembauaacqghrawkcuwgibgygaqbaiabdiha4naabaaaleaacqwgbbqqaeqaaogaeiykakiaeiikagiafmyyaembauaacqghrawkcuwgibgygaqbaiabdiha4naabaaaleaacqwgcbgqaeqaaogaeiykakcabagaegomaidaaaaacawljagaaczcamaabmaabagaegomaijaeginaqdacagloagaayzkaaaaaa@5de0@

where a' = ar + ag and b' = br + bg. again, we note that the dye-swap method makes the transforms in the resulting two virtual channels equal. comparing the bias in log-intensities between the geometrical and the arithmetical approaches, for the latter we have

a0=log⁡2ar+ag2     
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaacqwgbbqqdawgaawcbagaegimaadabeaakiabg2da9igbcygasjabc+gavjabcegannaabaaaleaacqaiyagmaeqaaowaasaaaeaacqwghbqydawgaawcbagaemouaifabeaakiabgucariabdggahnaabaaaleaacqwghbwraeqaaagcbagaegomaidaaiaaxmaacawljawaaewaaeaacqaiyagmcqai1aqnaiaawicacaglpaaaaaa@4108@

whereas for the former we have

a0=log⁡2arag.     
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaacqwgbbqqdawgaawcbagaegimaadabeaakiabg2da9igbcygasjabc+gavjabcegannaabaaaleaacqaiyagmaeqaaowaaoaaaeaacqwghbqydawgaawcbagaemouaifabeaakiabdggahnaabaaaleaacqwghbwraeqaaaqabagccqgguaglcawljagaaczcamaabmaabagaegomaijaegonaydacagloagaayzkaaaaaa@401a@

because / <dig> ≥ arag
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaadagcaaqaaiabdggahnaabaaaleaacqwgsbguaeqaaogaemyyae2aasbaasqaaiabdeeahbqabaaabeaaaaa@31f8@, we conclude that the log-ratio biases are always larger for arithmetic than geometric dye swap. however, there are other differences too. for instance, if each microarray glass array  introduces the same offset to both channels and this offset is different between arrays, but otherwise everything else is the same, that is, ar2=ar1+a
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaacqwghbqydawgaawcbagaemouai1aasbaawqaaiabikdayaqabaaaleqaaogaeyypa0jaemyyae2aasbaasqaaiabdkfasnaabaaameaacqaixaqmaeqaaawcbeaakiabgucariabdggahbaa@378d@ and ag2=ag1+a
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaacqwghbqydawgaawcbagaem4rac0aasbaawqaaiabikdayaqabaaaleqaaogaeyypa0jaemyyae2aasbaasqaaiabdeeahnaabaaameaacqaixaqmaeqaaawcbeaakiabgucariabdggahbaa@3761@, then geometric dye-swap fails whereas arithmetic dye-swap succeeds to remove curvature.

two-channel quantile normalization
two-channel or in general multi-channel quantile normalization  <cit>  is based on and relies on the assumption that the true gene-expression levels in the two biological samples are approximately equally distributed. if the measurement functions in the two channels, say fr and fg, are different, then the distributions of the measured signals in the two channels are different even if underlying distributions of true expression levels are identical. by estimating the distributions of the two channels and making them equal, for instance to an average distribution, the log-ratios for the non-differentially expressed genes will be unbiased and independent of the intensities. thus, making the density functions of measured data equal for the two channels is the same as making their transformation functions equal, say to frg, which makes m independent of a for non-differentially expressed genes. if frg could be made linear too, this would be true for all fold changes.

for affine transformations, two-channel quantile normalization removes intensity-dependent effects, because the offsets arand ag are identical after normalization. in addition, the constant log-ratio bias log2β is also removed. hence, two-channel quantile normalization can be considered to be both a method that corrects for differences in offset between two channels, but also a method that corrects for biases in the expression ratios. in figure  <dig>  the quantile normalization of a1
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufebsjuyzl2yd9gzlbvynv2caerbwvmckfmbhbqedmvetj2bsbwenfgdovwbhrxajfwnhbqeg0uy0hwztfgdpnwy1aqee0evguee0jxyaibaieydoi=bh8vipeydi8qiw7rqqrffpeea0xe9lq=jc9vqaqpepm0xbbg8faspyrqj0=yi0lxdbba9pge9qqff0dxdhuk9fr=xfr=xfrpiwzqaaeaabigaaiaacaqabeaadaqacqaaaoqaagwaaiab=bq8bnaabaaaleaatcvaufkttlearcwrp9mdh5mbpbiqv92aagqbaiab+fdaxaqabaaaaa@43c0@ transformed data is depicted. the curvature for non-differentially expressed genes is removed.

background subtraction as a normalization method
we have observed that log-ratios of background signals show the same intensity-dependent effects as ditto for foreground signals do, which suggests that background signals undergo the same transformation as foreground signals. an example of this is shown in figure  <dig>  where background and foreground estimates are plotted in the same m versus a scatter plots. a probable reason for this is the existence of scanner biases  <cit> . a widely adopted rationale for background correction is the assumption that the region that defines the spot is contaminated with the same physical noise that can be observed in the surrounding regions. background noise is believed to be due to dust particles, dna contaminated buffers, failed washing during printing or hybridization, cross hybridization etc.  <cit> . this type of background noise is often assumed to add to the foreground signal. thus, in order to obtain true signals, background is subtracted from foreground signal as

yc,i←yc,i−yc,i     
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaacqwg5bqedawgaawcbagaem4yammaeiilawiaemyaakgabeaakiabgcziskabdmha5naadaaaleaacqwgjbwycqggsaalcqwgpbqaaeaacqggoaakcqqgmbgzcqqgnbwzcqggpaqkaagccqghsislcqwg5bqedaqhaawcbagaem4yammaeiilawiaemyaakgabagaeiikagiaeeoyaimaee4zacmaeiykakcaaogaaczcaiaaxmaadaqadaqaaiabikdayiabieda3agaayjkaiaawmcaaaaa@4c9c@

where yc,i
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaacqwg5bqedaqhaawcbagaem4yammaeiilawiaemyaakgabagaeiikagiaeeozaymaee4zacmaeiykakcaaaaa@3638@ is the estimated foreground signal and yc,i
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaacqwg5bqedaqhaawcbagaem4yammaeiilawiaemyaakgabagaeiikagiaeeoyaimaee4zacmaeiykakcaaaaa@3630@ is the estimated background signal for channel c and spot i. under a transformation that is dominated by an affine function at lower intensities , subtracting the background from the foreground will shift the biases toward zero and background subtracted signals will have less curvature in the  plane than non-background subtracted signals . in this sense we can consider background subtraction to be a normalization method. however, just because the log-ratios as a function of the log-intensities become more flat, it does not imply that foreground regions are contaminated by the same noise as in background regions; unnecessary noise may be introduced. instead, it may be that the background estimates from the image analysis happen to be close to a non-image-related offset in the foreground signals. moreover, different image analysis software estimate the background signal differently based on different algorithms such as fixed-size circles, adaptive circles, morphological estimates, and pixel intensity distributions. although comparative studies have been conducted  <cit> , it is still not clear which background estimate is most correct. some methods give higher background estimates than others, which means that they all correct for channel biases by different amounts, which by the way is another argument for why there exist channel offsets. makes use of this is  <cit> , which emphasizes that the true signal can not be negative and uses a bayesian approach to correct for this.

result of a  negative translation
if too much background is subtracted, or a threshold has to be passed before the reverse transcription takes place, one can imagine that ag, ar <  <dig>  negative bias also applies if the observed signals are compared, not to the true signals, but to the signals obtained by another measuring technique that has a larger bias. examples of such comparisons can be two-color microarray data compared to oligonucleotide  data or two-color microarray data compared to qrt-pcr data. negative bias may also be observed when control clones, spike-ins, negative and positive controls etc. are compared to the genes/ests of interest. the effect of a negative translation is depicted in figure  <dig>  the fan-out effect in the fold-change curves for the lower intensities is due to the negative translation. note that this should not be mistaken for the fan-out effect due to decreasing signal-to-noise levels in the same way as lack of a fan-out effect due to a positive offset should not be mistaken for low noise.

robust affine normalization
from the above discussion, it is clear that it is essential to correct for channel offsets when normalizing gene expression data. for two-channel data, we can obtain estimates of ar, ag and β as follows. for non-differentially expressed genes  we have that

yr,i = α + βyg,i; ∀i     

with α = ar - βag and β = br/bg. define y={yi}i=1i
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaaieqacqwf5bqecqgh9aqpcqgg7bwecqwf5bqedawgaawcbagaemyaakgabeaakiabc2ha9naadaaaleaacqwgpbqacqgh9aqpcqaixaqmaeaacqwgjbqsaaaaaa@39d4@ where yi =  and let

q=∑i=1iwidi2     
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaacqwgrbqucqggoaakiigacqwfxoqycqggsaalcqwfyogycqgg7awoieqacqgf5bqecqggpaqkcqgh9aqpdaaewbqaaiabdeha3naabaaaleaacqwgpbqaaeqaaogaemizaq2aasbaasqaaiabdmgapbqabaaabagaemyaakmaeyypa0jaegymaedabagaemysakeaniabgghildgccqggoaakcqwfxoqycqggsaalcqwfyogycqgg7awocqgf5bqedawgaawcbagaemyaakgabeaakiabcmcapmaacaaaleqabagaegomaidaaogaaczcaiaaxmaadaqadaqaaiabikdayiabimda5agaayjkaiaawmcaaaaa@5371@

be our objective function where di >  <dig> is the orthogonal euclidean distance between yi and the line l with intercept α and slope β. the estimates of α and β are then

=arg⁡min⁡q.     
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaacqggoaakiigacuwfxoqygaqcaiabcycasiqb=j7aizaajagaeiykakiaeyypa0jagiyyaemaeiocainaei4zac2aacbeaeaacyggtbqbcqggpbqacqggubgbasqaaiabcicaoiab=f7ahjabcycasiab=j7aijabcmcapaqabagccqwgrbqucqggoaakcqwfxoqycqggsaalcqwfyogycqgg7awoieqacqgf5bqecqggpaqkcqgguaglcawljagaaczcamaabmaabagaeg4mamjaegimaadacagloagaayzkaaaaaa@50e5@

with wi =  <dig> for all observations we obtain standard principal component analysis , which minimizes the orthogonal distances in the l <dig> norm  <cit> . with wi ≠  <dig>   weighted pca , a special case of generalized pca, is obtained  <cit> . with weights wi = 1/ + δ) we can minimize the distances in the l <dig> norm, if we let δ → 0+. the distance di , which equals the sum of squares of the values of all but the first principal component, was first suggested by  <cit> . thus, our choice of weight function down-weigh outliers as defined by  <cit>  in order to obtain a robust estimate of l corresponding to the first principal component. our procedure is related to principal component analysis applied to an m-estimator of the covariance  matrix of data. the main difference is that we use weights w = w = 1/  based on the orthogonal distance di from yi to l whereas for m-estimation one uses weights w = w based on a robustified mahalanobis distance of yi, which is computed from an m-estimator of the covariance matrix of data. m-estimation of location and scatter was first defined by  <cit> , and subsequently applied to principal component analysis by  <cit> . for other more recent papers on robust multivariate analysis, see  <cit>  and the references therein. alternative robust estimators can be obtained by choosing other weight functions w, but we choose to optimize in l <dig>  moreover, if one suspects a non-symmetric distribution of data points around the line, a trimmed version of the weight function may be considered. in practice, the above optimization can be performed by an iterative reweighted principal component analysis  scheme. for iteration l =  <dig> ,..., minimize  using wpca where wi
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaacqwg3bwddaqhaawcbagaemyaakgabagaeiikagiaegymaejaeiykakcaaaaa@324d@ =  <dig> and wi
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaacqwg3bwddaqhaawcbagaemyaakgabagaeiikagiaemibawmaey4kasiaegymaejaeiykakcaaaaa@3490@ = 1/,β;yi) + δ) with δ being a small positive number to avoid infinite weights.

as a last step, in order to get estimates of the four parameters ar, ag, br, and bg from the two parameter estimates α^
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaaiigacuwfxoqygaqcaaaa@2e62@ and β^
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaaiigacuwfyogygaqcaaaa@2e64@, we introduce additional constraints. let yc, = miniyc,i for c = {r, g} and choose

b^g=1b^r=β^     
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakqaabeqaaiqbdkgaizaajawaasbaasqaaiabdeeahbqabagccqgh9aqpcqaixaqmaeaacuwgibgygaqcamaabaaaleaacqwgsbguaeqaaogaeyypa0dccigaf8nsdimbakaacawljagaaczcamaabmaabagaee4mamjaeeymaedacagloagaayzkaaaaaaa@3b74@

a^g=max⁡{ag;ag<yg,∧α^+β^ag<yr,}α^r=α^+β^a^g     
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaafaqabegabaaabagafmyyaembakaadawgaawcbagaem4raceabeaakiabg2da9igbc2gatjabcggahjabciha4jabcuha7jabdggahnaabaaaleaacqwghbwraeqaaogaei4oasjaemyyae2aasbaasqaaiabdeeahbqabagccqgh8aapcqwg5bqedawgaawcbagaem4rackaeiilawiaeiikagiaegymaejaeiykakcabeaakiabgeiizjgaciqb=f7ahzaajagaey4kasiaf8nsdimbakaacqwghbqydawgaawcbagaem4raceabeaakiabgyda8iabdmha5naabaaaleaacqwgsbgucqggsaalcqggoaakcqaixaqmcqggpaqkaeqaaogaeiyfa0habagaf8xsdembakaadawgaawcbagaemouaifabeaakiabg2da9iqb=f7ahzaajagaey4kasiaf8nsdimbakaaiegacugfhbqygaqcamaabaaaleaacqwghbwraeqaaaaakiaaxmaacawljawaaewaaeaacqaizawmcqaiyagmaiaawicacaglpaaaaaa@64a3@

to be the estimates of the bias and the scale parameters in model . constraint  is only correct in the noise-free case. if we allow noise, say

yc,i = ac + bcxc,i + εc,i,     

where e =  <dig> and v = σc,i2
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaaiigacqwfdpwcdaqhaawcbagaem4yammaeiilawiaemyaakgabagaegomaidaaaaa@331f@ for c = {r, g}, it is possible that the bias terms ar and ag are larger than the smallest observed value in the respective channel. this is especially important if the distributions of εc,i for c = {r, g} have heavy negative tails. an alternative, which introduces negative estimates, is to replace yc, in  with yc,  for some order index  such that j -  <dig> non-positive signals are obtained in channel c. choosing an optimal value on j is currently investigated by the authors, but beyond this article. furthermore, it has been observed that the noise in each channel is roughly proportional to the signal strength, that is, σc,i ∝ xc,i. thus, a positive side effect of the above estimation algorithm is that, contrary to have equal weights for all spots , more weight will be given to low-intensity spots compared to high-intensity ones. this makes the method more robust to saturation and other non-linear effects that might occur at high intensities, effects for which classical line fits, which rely on homoscedasticity, would fail. finally, with backward transformation  based on estimates , data is translated and rotated such that it falls around the diagonal line that goes through  and .

to illustrate the affine normalization method we have applied it to six two-color microarray data sets each containing  <dig> spike-in controls designed to have log <dig> r =  at various intensities. see also methods. these controls were not used to estimate the normalization parameters. as shown in figure  <dig>  which is for one of the arrays, there is a small curvature for non-differentially expressed genes  before normalization, a curvature that corresponds to -α^
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaaiigacuwfxoqygaqcaaaa@2e62@ ≈ + <dig> >  <dig>  at log <dig> r =  <dig>  cf. . more importantly, the intensity dependent effect is profound for the log <dig> r = ±  <dig> controls. affine normalization allowing no negative signals removes curvature  for log <dig> r =  <dig>  but not for the log <dig> r = ±  <dig> controls, which indicates equal affine transformation in both channels, cf. right graph of figure  <dig>  if 5% negative signals is allowed, the log-ratios of all controls become roughly independent of intensity, which indicates that the observed signals are proportional to the concentrations of the spike-ins. all six arrays in this study show very similar properties.

generalization to multiple channels and multiple arrays
a multi-dimensional version of the above algorithm can be summarized as follows. say there are n arrays each hybridized with k samples  such that there is in total c = nk channels. let yi = k +  <dig> i,..., ynk,i) be the nk observations for gene i. thus, {yi}i spans an nk-dimensional space. analogously to the above two-dimensional procedure, we can fit a robust line l through data in ℝnk and constrain the estimate of a =  by enforcing that a <yi; ∀i, where < is the component-wise inequality. backward transformation  translates and rotates data such that it lies along the diagonal line. by normalizing all arrays at once, signals from all hybridizations are brought onto the same scale and no further, so called, between-slide scale normalization is needed.

to apply the multi-dimensional normalization, the assumption that most genes are non-differentially expressed for all possible hybridization/channel pairs must be added. for most experimental setups this is not a problem. for instance, in two-channel microarrays experiments it is common to hybridize one test sample and one reference sample, which is selected such that it does not differ too much from the test sample, to the same array. the same reference is then used between arrays . thus, since each test-reference pair is "close" to each other, all test-test pairs should be approximately "close" to each other too. alternatively, all reference channels can be normalized together. then, keeping the reference signals fixed, each test channel is normalized toward the corresponding reference channel.

an implementation of the above algorithm is made available in the r  <cit>  package named aroma  <cit> , which is platform independent. in addition, the methods are available as an r plugin  <cit>  for base  <cit> . a typically call is normalizeaffine, which will normalize all arrays and all channels in the microarray object rg at once. the first parameter that has to be specified in the above algorithm is δ. however, its value is not critical and we have found that for instance δ =  <dig>  works well in general and is therefore the default value. the second parameter to be specified is the number of negative signals allowed after normalization. by default the method allows 5% negative signals, but any fraction  of negative signals can be specified. moreover, the method can be applied to any subsets of genes separately such as print-tip groups, clone groups and spike-ins. finally, support for datapoint weights has been implemented so that the influence each spot has in the estimation procedure can be specified . such weights may for instance be calculated from spot quality measures obtained by image analysis methods.

discussion
if we compare the robust affine normalization method with the perpendicular and the parallel translation normalization methods optimized by minimizing the curvature, we find that there are similarities, because minimizing the curvature is identical to finding estimates of the bias parameters along the line l. assuming a pure affine transformation, there are also similarities to the curve-fit method, which fits approximately the same line  through data. the difference is how data is transformed to meet the assumptions. the affine method translates and rescales data in the original domain whereas the curve-fit method operates in a rotated and log-transformed domain.

moreover, the translation and the curve-fit methods rely on two-dimensional data  and it is not clear how to generalize them to multi-dimensional data, although re-iterative versions such as the cyclic loess  <cit>  and the  contrast based method  <cit>  have been suggested. our affine normalization method is not limited to two-dimensional data, but can be applied to any number of channels, which means that three and four-color microarray data can be normalized as easily as two-color data.

it is interesting to note the close relationship between the quantile and the affine normalization method. in quantile normalization data points are shifted such that the sample densities of both channels are made identical. this results in new measurement functions, which may not be linear , but for which log-ratios for non-differentially expressed genes are zero. the affine normalization method can be though of as a quantile normalization method with special constraints on the underlying densities. an interesting continuation of the affine method and quantile normalization method is to relax the affine constraint by using other parametric or semi-parametric models. one possibility is to add smoothness constraints to the transformation functions using smoothing splines  <cit> .

in previous sections, we did not discuss the variance stabilizing methods suggested by  <cit> , which are based on error models that also contain channel-specific bias terms. thus, those methods do indeed correct for intensity-dependent effects. because they are based on specific error models and target hypothesis testing of non-differentially expressed genes, but also because they stabilize the log-ratio variances, they do not fit well into the above deterministic discussion. in addition, stabilizing the variance introduces bias for differentially expressed genes, which is not useful if absolute expression levels are of interest. however, we do believe that the directions drawn up by their underlying error models are promising.

moreover, in the spirit of  <cit> , it would be interesting to incorporate an empirical bayes component to allow for non-positive signals more naturally.

an interesting study on microarray scanner calibration curves was published while submitting this article  <cit> . from their results on under-estimated log-ratios and propeller-shaped log-ratio versus log-ratio scatter plots, we suspect that they observe nothing but affine transformed signals. it would be of great interest to redo their analysis with affine normalization.

finally, offset and scale parameters in  can be extended to incorporate, say, spatial structures by replacing them with ac and bc where ui =  is the spatial position of spot i.

CONCLUSIONS
we have proposed a robust non-parametric normalization method for affine transformed gene-expression data, which centers and symmetrizes log-ratios at all intensities. symmetric log-ratios are fundamental for statistical tests on non-differentially expressed genes, typically utilizing t-tests or similar. in addition and contrary to other normalization methods , which are exclusively for paired channels, the method applies equally well to multi-array and multi-channel data. we believe that normalization based on affine transformations, such as our proposed iwpca method, is very promising and has the potential of being used for many microarray applications. however, more comparison with other normalization methods is needed to fully understand its advantages and disadvantages.

