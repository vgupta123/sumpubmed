BACKGROUND
with the completion of the human genome project, coordinated effort has made available millions of single nucleotide polymorphisms . these snps represent many of the genetic variants in the human genome and they will greatly facilitate the identification of genetic variants underlying human diseases, the goal of association studies. indeed, under the "common disease – common variant " hypothesis, genome-wide association studies  have achieved numerous successes in the last three years, particularly in genetic mapping in human diseases  <cit> . for example, reproducible associations have been described for many human common conditions and diseases, such as obesity  <cit> , diabetes  <cit> , and rheumatoid arthritis  <cit> . the genetic markers revealed by these studies may provide insights into the underlying molecular pathways, and may lead to novel strategies for disease diagnosis, treatment, and prevention.

in general, there are three different kinds of association studies: case-control, categorical disease outcomes, and quantitative . each association study may deal with only a single snp and multiple snps. it appears that the first two kinds of association studies are much easier than the quantitative ones, and in fact the past successes are all on the first two kinds. for the last kind, most association study methods are regression based, and they become either ineffective  or inefficient  with increasing numbers of snps  <cit> . it is recognized that, despite the many achieved successes, the power of the association study methods are nevertheless still low, and there remain many more important diseases to be studied, particularly quantitative ones.

the major issue in the current technical themes of gwass is the data dimensionality, where the number of samples is far less than the number of genotyped snps. this issue becomes particularly severe when dealing with rare diseases. impacted by linkage disequilibrium , and that the human genome can be partitioned into large blocks with high ld and relatively low recombination , separated by short regions of low ld  <cit> , snp tagging has been proposed to reduce the number of snps to the minimum while retaining as much the genetic variation of the full snp set as possible. however, in practice, tagging is only effective in capturing common variants. a popular and prosperous strategy, suggested by this block-like structure of the human genome, is to use haplotypes to try to capture the correlation structure of snps in regions of little recombination  <cit> . this approach can lead to analyses with significantly reduced degrees of freedom and, more importantly, haplotypes are able to capture the combined effects of tightly linked causal variants.

haplotypes are very expensive to assay. for the vast majority of applications that involve large numbers of samples, only genotype data are available through high-throughput genotyping technologies. one of the potential problems underlying the haplotype-based association study methods is that haplotypes are not observed but rather inferred, and it can be difficult to account for the uncertainty that arises in phase inference when assessing the overall significance of the association. one solution to this problem is to determine the haplotype allele sharing status among all members in the study  <cit> . in particularly, it is expected that the availability of high density snp genotype data can be used to unambiguously determine the haplotype allele sharing.

in this work, we demonstrate that, for pedigree genotype datasets, such haplotype allele sharing can indeed be deterministically, efficiently, and accurately determined, even for very small pedigrees. this confirms that haplotype-based association studies are promising for flexible and interpretable analyses that exploit evolutionary insights.

we determine the haplotype allele sharing status among pedigree members using two distinct parsimonious haplotyping algorithms with different optimization objective functions: one minimizes the total number of crossovers to explain the pedigree genotype data by mendelian inheritance rules; the other minimizes the total number of crossover sites, or equivalently, minimizes the number of maximal zero-recombination chromosomal regions. both haplotyping results give unambiguous haplotype allele sharing status among the members, as well as the shared haplotype alleles, though the phases for each individual might not be completely determined. these shared haplotype alleles can provide additional support for mapping phenotype genes  <cit> , and they may also lead to insights on the factors influencing the dependencies amongst genetic markers, i.e. linkage disequilibrium. such insights may prove essential to understanding genome evolution  <cit>  .

there is a rich and growing literature on haplotype inference, or haplotyping. some works focus on unrelated individuals  <cit> ; research on related individuals include those based on either exact-likelihood computations  <cit> , approximate-likelihood computations  <cit> , or rule-based strategies  <cit> . conceivably, all of these haplotyping algorithms, methods and programs have elements in common and have their own strengths and weaknesses. for example, the likelihood-based methods are in general limited to a small number of markers and small pedigrees, owing to the extensive computations required. additional information and assumptions, such as marker recombination rates and hardy-weinberg equilibrium, are generally required to calculate the likelihood. the rule-based methods are ad hoc but they rely on fewer assumptions and generally run faster than likelihood-based methods. most recently, lin et al. developed a greedy haplotyping algorithm that takes advantage of the high density snp markers  <cit> . this algorithm is incorporated into the i linker program, which determines the haplotype allele sharing among pedigree members. this method will be used in this study. essentially, i linker uses a minimum number of breakpoints to explain the genotype data, in the presence of missing genotypes and genotype errors. then, during the data interpretation process, parental haplotype phases are revised when more members are added, as long as the revision reduces the total number of breakpoints and still explains the genotype data. the substantial simulation study in  <cit>  has previously demonstrated its efficiency, effectiveness, and reliability.

the computational problem of finding an optimal haplotype configuration  for a pedigree genotype dataset is in general np-hard  <cit> . that is, there is unlikely a polynomial time algorithm that guarantees reconstruction of an optimal haplotype configuration for any pedigree genotype dataset. when no recombination events are allowed, the haplotype inference becomes easy. in the absence of missing genotype data, li and jiang  <cit>  proposed a polynomial time exact algorithm for this zero-recombination haplotype configuration  problem, to reconstruct all compatible haplotype configurations without recombination. this algorithm, implemented within pedphase  <cit> , runs in o time, where m is the number of snps under consideration and n is the number of non-founder members in the pedigree. following several major advances  <cit> , liu and jiang  <cit>  recently designed an o time algorithm which generates a particular solution to the zrhc problem and, in o time, it generates a general solution . other works on the zrhc problem include cox et al.  <cit> , haplore by zhang et al.  <cit> , and zrhi by wang et al.  <cit> . it should be mentioned that one immediate application of zrhc is the association studies that involve many tightly linked markers in a small chromosomal region. within such a small region, recombination is an unlikely event and thus it is reasonable to assume that there is no recombination among these markers across the pedigrees studied  <cit> .

in this work, we extend the pedphase zero-recombination haplotyping algorithm to xpedphase to determine all maximal zero-recombination chromosomal regions, as well as their respective haplotype configurations, in one whole genome scan. subsequently, the haplotype allele sharing status among the pedigree members at each maximal zero-recombination chromosomal region can be determined. note that it is infeasible to assume no crossover events for a whole chromosome. one may run the original pedphase multiple times on all possible chromosomal intervals to identify the maximal zero-recombination chromosomal regions. however, this would take a prohibitive amount of time as pedphase runs in cubic time. therefore, our extension xpedphase to determine all maximal zero-recombination chromosomal regions in one whole genome scan is non-trivial. we note that this way of haplotype allele sharing determination differs from that by i linker in that, when a subset of members share a haplotype allele, the haplotype allele is maximally extended to the point where the sharing on the particular chromosomal region changes. in other words, the number of chromosomal regions of the same sharing status is minimized in xpedphase, and so the determined haplotype allele sharing is the most parsimonious. we see this as an advantage over i linker, which only deduces haplotype allele sharing from the greedy haplotyping results. afterwards, the shared haplotype alleles and their sharing information can readily be used in various association studies  <cit> .

RESULTS
breakpoint recovery
in the genotype data simulation process , a simulated parental breakpoint could arise between two consecutive homozygous snp sites and thus it is not possible to be precisely recovered by any computational haplotyping algorithms. in addition, i linker is a greedy program that introduces a breakpoint only if necessary; and xpedphase minimizes the number of zero-recombination chromosomal regions. that is, both programs work in certain most parsimonious ways.

we define the following measures of effectiveness for our haplotype allele sharing status determination process. a simulated breakpoint is classified as recovered if there is an inferred breakpoint  that  is identical to the simulated breakpoint, or  can be "moved" to the simulated breakpoint site  <cit> , i.e., the parental snps in between these two sites are all homozygous. subsequently, the breakpoint recovery precision is defined as the number of simulated breakpoints being recovered  divided by the number of breakpoints generated by i linker or xpedphase . the breakpoint recovery recall is defined as the number of simulated breakpoints being recovered  divided by the number of simulated breakpoints .

for each of the  <dig> distinct pedigrees tested, we used  <dig> sets of real, unrelated, chromosome  <dig> genotype data obtained from genechip human mapping  <dig> k xba  <cit> , as well as  <dig> sets from  <dig> k xba  <cit>  arrays to assign haplotypes for founders, by randomly specifying the paternal and the maternal snp alleles at the heterozygous sites. there were, in total,  <dig> and  <dig>   <dig> snp sites in the  <dig> k and  <dig> k data, respectively. for each set , we simulated  <dig> instances. the breakpoint recovery precision and recall associated with each pedigree are computed as the averages over the  <dig> corresponding instances. these values on the  <dig> k and  <dig> k data are collected in tables  <dig> and  <dig>  respectively, where pedigree n1-n <dig>  has n <dig> members in the first  generation. the overall breakpoint recovery precision and recall by i linker, averaged over  <dig>  <dig> k simulated instances, were <dig> % and  <dig> %, respectively; the corresponding ones by xpedphase were  <dig> % and  <dig> %, respectively. on  <dig>  <dig> k instances, xpedphase were not able to return results for pedigrees 2- <dig> and 2– <dig> ; its overall breakpoint recovery precision and recall, averaged over  <dig>  <dig> k simulated instances, were  <dig> % and  <dig> %, respectively. i linker finished all of the  <dig> k instances, achieving overall breakpoint recovery precision and recall of  <dig> % and  <dig> %, respectively.

breakpoint recovery results: average breakpoint recovery precision and recall by i linker, xpedphase, and block-extension on  <dig> k genotype datasets.

breakpoint recovery results: average breakpoint recovery precision and recall by i linker and xpedphase on  <dig> k genotype datasets.

we also collected the breakpoint recovery results by the block-extension algorithm inside the pedphase package  <cit> . due to the fact that it has a limit on the number of snps, block-extension was ran only on the  <dig> simulated  <dig> k genotype datasets. overall its running time was very similar to i linker, that both programs ran in seconds. its precision and recall are collected in table  <dig>  with the average breakpoint recovery precision  <dig> % and recall  <dig> %. an interesting observation is that the block-extension algorithm always generated about  <dig> times more breakpoints than the simulated ones, which is one of the main causes for low precisions.

haplotype allele sharing recovery
for each simulated pedigree genotype dataset, the simulated mutation region was recorded . we also recorded all the chromosomal regions that are exclusively shared by all the diseased members in the simulated haplotype dataset, before transforming it into the genotype dataset. we call them the simulated shared regions. note that the simulated mutation region is always contained in one of the simulated shared regions. after running i linker and xpedphase, based on the reported haplotype allele sharing, we identify all the chromosomal regions that are shared by all and only diseased members too, which we call the discovered shared regions. if the discovered shared regions contain the simulated mutation region, then the simulated mutation region is recovered.

among the  <dig> simulated  <dig> k genotype datasets, xpedphase missed  <dig> simulated mutation regions,  <dig> of which are among the  <dig> ones missed by i linker. that is, the simulated mutation region recovery accuracies by xpedphase and i linker were  <dig> % and  <dig> %, respectively. the block-extension algorithm missed  <dig> simulated mutation regions, achieving a significantly lower accuracy of  <dig> %. for the  <dig> simulated  <dig> k genotype datasets, xpedphase missed only  <dig> simulated mutation regions; i linker missed  <dig> additional ones but it recovered  <dig> more instances; these gave xpedphase and i linker the simulated mutation region recovery accuracies of  <dig> % and  <dig> %, respectively.

for each simulated dataset, we compared the simulated shared regions and the discovered shared regions, by i linker and xpedphase separately, to determine whether or not each simulated shared region was recovered by checking if they overlap or not. if a simulated shared region was not recovered, then the corresponding discovered region was set to . for the  <dig> simulated  <dig> k genotype datasets, there were  <dig> simulated shared regions in total.  <dig> of them were not recovered by either xpedphase or i linker;  <dig> additional were not recovered by xpedphase and  <dig> additional were not recovered by i linker. we collected the starting snp site and the ending snp site for each of these simulated shared regions  and those for the corresponding discovered shared region  by xpedphase and i linker, respectively, and plotted them in figures  <dig>   <dig>   <dig> and  <dig>  essentially, these plots show the extent to which the discovered shared regions are off the simulated shared regions. the correlation coefficients between the two sets of starting and ending sites of recovered shared regions were  <dig>  and  <dig>  by xpedphase, and  <dig>  and  <dig>  by i linker. on  <dig>  <dig> k datasets that both i linker and xpedphase finished, every shared region was recovered by xpedphase and i linker missed only two. the correlation coefficients were  <dig>  and  <dig>  by xpedphase, and  <dig>  and  <dig>  by i linker, respectively .

discussion
i linker vs. xpedphase: breakpoint recovery
both i linker and xpedphase determine the haplotype allele sharing status among pedigree members through partial haplotyping. that is, i linker repeatedly runs a greedy haplotyping algorithm on the smallest nuclear families in the pedigree, with an objective function designed to minimize the total number of breakpoints. xpedphase, on the other hand, repeatedly searches for the maximal zero-recombination chromosomal regions along the chromosome, and thus minimizes the total number of breakpoint sites. both programs therefore determine the haplotype allele sharing in certain most parsimonious ways.

from our extensive simulation study, we found that xpedphase generated slightly more breakpoints per meiosis than i linker. for example, on average, the number of simulated breakpoints per meiosis  was  <dig> , and the number of breakpoints per meiosis generated by i linker was  <dig> , which is slightly less, likely due to its greedy nature. but the number of breakpoints per meiosis generated by xpedphase was  <dig> , greater than 10% more than simulated. nevertheless, among these  <dig>  breakpoints per meiosis by xpedphase,  <dig>  were actually true positives; while among the  <dig>  breakpoints per meiosis by i linker,  <dig>  were true positives. this explains the slightly higher recalls by xpedphase than i linker – xpedphase introduced a few more breakpoints, of which some were true positives though the others were false positives. also interestingly, for almost all instances, the numbers of breakpoint sites by xpedphase were equal to the numbers of breakpoints by i linker. this fact explains why the correlation coefficients of starting  snp sites between the simulated shared regions and the shared regions discovered by xpedphase and i linker are nearly identical.

mutation region recovery
among the  <dig> simulated  <dig> k genotype datasets, xpedphase missed  <dig> simulated mutation regions and i linker missed  <dig>  they both missed the simulated mutation region on  <dig> datasets.  we carefully examined these  <dig> datasets and found out a common pattern of the simulated mutation regions. these simulated mutation regions were short, containing only  <dig> to  <dig> snps, and the specified diseased haplotype allele was not unique, i.e., when this allele was paternal, there was a maternal allele exactly the same. such a phenomenon is caused by our simulation process, which does not do the checking for uniqueness. the consequence is that, the diseased allele was not exclusively found in diseased members but rather, it was shared among some healthy members. therefore, none of i linker and xpedphase were able to recover it.

snp density
from the simulation study results, one can see that, using higher density snp makers,  <dig> k over  <dig> k in our case, both i linker and xpedphase performed better, in terms of the breakpoint recovery and the haplotype allele sharing recovery. in particular, on  <dig> k genotype datasets, the discovered shared chromosomal regions exclusive to all the diseased members were almost identical to the simulated shared regions, achieving all higher than  <dig>  correlation coefficients. this fact is certainly desirable in the case-control association studies. on the other hand, both i linker and xpedphase also performed very well on  <dig> k genotype datasets. this hints that they can be useful in haplotype-based association studies on species, such as cattle  <cit>  and soybean  <cit> , for which no high but only medium density snp arrays are available.

i linker vs. xpedphase: running time
the zero-recombination haplotyping algorithm inside pedphase runs in o time, where m is the number of snp makers and n is the size of the pedigree. xpedphase thus needs cubic time as well on each maximal zero-recombination chromosomal region. for the pedigrees used in the simulation study, preliminary testing using a zero-recombination segment of more than  <dig> snps caused the program to either crash or run for hours. in the final batch run of the programs to collect results, several restarts were required on simple pedigrees such as 2- <dig> and 2– <dig>  even on  <dig> k instances. program i linker did not have the running time issue, where it always returned a solution within seconds. xpedphase, on the other hand, could not return results on most of the  <dig> k instances for pedigrees 2- <dig> and 2– <dig>  therefore, the collected results for xpedphase on  <dig> k data are only for  <dig> pedigrees.

given that xpedphase, which non-trivially employs the cubic time zero-recombination haplotyping algorithm, could run for hours on small pedigrees, part of our future attention is to implement the linear time algorithm by liu and jiang  <cit> , which does the same zero-recombination haplotyping but was described as difficult to implement. eventually, one might want to design a novel linear time zero-recombination haplotyping algorithm that, similarly in one whole genome scan, determines all maximal zero-recombination chromosomal regions, together with their zero-recombination haplotyping solutions.

choice of i linker or xpedphase
i linker performed better in terms of breakpoint recovery precision, but it had slightly lower recalls than xpedphase. xpedphase seemingly generated more breakpoints, some of which picked up the simulated ones. both i linker and xpedphase have the algorithmic nature to push breakpoints to the end of the chromosome, which is validated from the scatter plots of the starting and ending snp sites of the discovered shared regions versus the simulated ones . also, in terms of shared region recovery, xpedphase did better than i linker, possibly due to the more breakpoints it generated.

i linker accepts datasets containing genotype errors, and it has a step to correct not only those sites violating mendelian inheritance rules but also pairs of unlikely close breakpoints, in terms of their physical distance. in fact, there were instances in which two adjacent breakpoints on a member are less than one million basepairs apart, and i linker smoothed the region by revising the genotype data. this is another reason that i linker missed several very short simulated shared regions. note that pedphase, and consequently xpedphase, does not tolerate any genotype errors, neither missing data.

on each of the  <dig>   <dig> instances, disregarding the snp density, i linker ran in only seconds. the running time of xpedphase varied a lot, from seconds to minutes to hours. given a pedigree, the running time of xpedphase is determined by the length of the chromosomal region under consideration. when the pedigree is not too small, the lengths of zero-recombination chromosomal regions were only tens or hundreds and xpedphase was able to deal with them in seconds to minutes too. for pedigrees 2- <dig> and 2– <dig>  such lengths could be thousands. we had waited for days without the complete results and thus terminated xpedphase. in summary, xpedphase performed slightly better, in particular when we do not want to miss many breakpoints, at the cost of longer running time.

dealing with missing genotype values in i linker
note that pedphase does not tolerate any missing genotype data, neither errors. consequently, xpedphase does not work on datasets with missing data or errors. but i linker deals with missing genotype data, by ignoring them during the haplotyping process and then imputing them using the haplotype inheritance. conceivably, such a way of treating missing genotype data would reduce the haplotyping accuracy. on each of the  <dig> simulated genotype datasets, we manually erased a portion of data points, at  <dig> %, 1%,  <dig> %, 2%,  <dig> % and 3% respectively, and then ran i linker to collect its breakpoint recovery and the mutation region recovery. the breakpoint recovery precision and recall are collected in tables  <dig> and  <dig>  respectively, for  <dig> k and  <dig> k datasets. clearly seen, while precision remained largely the same, the recall dropped a little with increasing missing rates. nevertheless, overall these small percentages of missing genotype data did not affect the breakpoint recovery accuracies much. however, the mutation region recovery by i linker could drop a lot when the snp density is low. for example,  <dig>   <dig>   <dig>   <dig>   <dig>   <dig>   <dig> simulated mutation regions were missed among the  <dig>  <dig> k datasets with 0%,  <dig> %, 1%,  <dig> %, 2%,  <dig> %, and 3% missing data points, respectively; while only  <dig>   <dig>   <dig>   <dig>   <dig>   <dig>   <dig> simulated mutation regions were missed among the  <dig>  <dig> k datasets, respectively.

breakpoint recovery results: average breakpoint recovery precision and recall by i linker at the presence of  <dig> –3% missing genotype data.

breakpoint recovery results: average breakpoint recovery precision and recall by i linker at the presence of  <dig> –3% missing genotype data.

other possible applications
studies have shown that the human genome can be partitioned into large blocks with high ld and relatively low recombination, separated by short regions of low ld  <cit> . the same things are also expected for other species such as cattle and soybean. in the cattle breeding industry, normally small to medium size pedigrees can be easily collected. by running our haplotype allele sharing status determination programs on these pedigrees, we will be able to locate those crossover sites for each pedigree. these results can thus be used to compose the map of crossover sites and thus identify the crossover hotspots along the genome. we expect that our programs will be useful in many genomics selection projects, for example, to provide deterministic haplotype allele sharing and shared haplotype alleles for various quantitative trait locus  identification and quantitative association studies.

methods
haplotype allele sharing by xpedphase
pedphase is a haplotyping program consisting of four algorithms  <cit> . the constraint-finding algorithm first determines whether a pedigree genotype dataset has zero-recombination haplotype configurations and identifies all such configurations if it does. more precisely, the algorithm first identifies all necessary  constraints on the haplotype configurations derived from the mendelian inheritance rules and the zero-recombination assumption, represented as a system of linear equations on binary variables over the cyclic group Ƶ <dig> . it then solves the equations to obtain all consistent haplotype configurations satisfying the constraints, using a simple method based on gaussian elimination. these consistent haplotype configurations are shown to be feasible zero-recombination solutions. the running time for representing and solving the equations is o, where m is the number of snps under consideration and n is the number of non-founder members in the pedigree, and the time for enumerating all configurations is proportional to the number of feasible zero-recombination solutions.

this cubic running time is due to the gaussian elimination procedure that is employed to solve a system of  2n linear equations. when considering one more snp site, the increase in the number of equations is at most 2n. this observation leads to our extension of the pedphase, denoted as xpedphase, for one whole genome scan to determine all maximal zero-recombination chromosomal regions. let m denote the total number of snps on the chromosome under consideration. we first run pedphase on the foremost two snps. if the gaussian elimination procedure reaches no solution, then there is a breakpoint in between these two sites, and we proceed to run pedphase on the second and the third snps. otherwise, generate  2n linear equations by considering the last snp and the next snp which has not been examined. append these new linear equations to the existing reduced system, and continue applying the gaussian elimination procedure. again, if the procedure reaches no solution, then there is a breakpoint in between the last two snp sites, and we proceed to run pedphase on the last snp and the next snp which has not been examined. otherwise, generate  2n linear equations by considering the last snp and the next snp which has not been examined, and so on.

note that in order to output the haplotype configurations for each maximal zero-recombination chromosomal region, we need to save the last set of solutions before we consider a new snp site. xpedphase thus runs in o time, where m denotes the total number of snps. in the haplotype configuration for each maximal zero-recombination chromosomal region, the haplotype alleles of the founders are carefully swapped so that the total number of breakpoints is minimized. for this purpose, we set the rule as that, for each pair of founders, their haplotype alleles on two consecutive maximal zero-recombination chromosomal regions are such that the total number of breakpoints in their children is no more than half the number of their children. on almost all maximal zero-recombination chromosomal regions identified in our extensive simulation experiments, xpedphase returned a unique solution. in the case of multiple solutions, we chose to use the first solution returned from xpedphase, though ideally we would check for the one that results in the minimum number of breakpoints. after the haplotype alleles for each member have been determined, we report the sharing information among all the pedigree members.

haplotype allele sharing by i linker
i linker determines the haplotype allele sharing status for individuals in a pedigree  <cit> . the key component of this program is a rule-based and greedy haplotype inference algorithm that assigns haplotypes to the smallest nuclear families extracted from the pedigree. a smallest nuclear family is either a trio, or one parent and a child. i linker traverses the pedigree in a top-down fashion, and determines haplotypes of family members in sequence. overall, the program tries to use a minimum number of breakpoints to explain the pedigree genotype data. during the genotype data interpretation process, parental haplotype phases can be revised when more members are added, as long as the revision reduces the total number of breakpoints and still explains the genotype data. additionally, i linker has an error correction step that detects unlikely crossover events.

it is worth noting that i linker is the first to emphasize correctly inferring allele sharing status  among pedigree members. this greatly reduces computational complexity, even in the face of large high-density snp genotype datasets. i linker has been extremely successful in both breakpoint recovery and identifying linked regions for case-control association studies  <cit> .

genotype data simulation
in this study, we have implemented a simulation process which generates the haplotypes for a child using the parents' haplotypes according to the χ2-model for crossover events with m =  <dig>  <cit> . using this trio generation process as a basis, genotype datasets for large pedigrees can be simulated for testing our programs. we note that this genotype data generation process slightly differs from what has been done in lin et al.  <cit> , and differs completely from several existing genotype/haplotype data generation programs such as simlink  <cit> , simulate  <cit> , ilink in the fastlink/linkage package  <cit> , slink  <cit> , allegro  <cit> , merlin  <cit> , simla  <cit> , and simped  <cit> . in many of these programs the crossover events are simulated according the probabilities specified for every two adjacent marker sites. in the case of high density snp markers, all these probabilities are tiny .

in our genotype data simulation process, the input to the trio generation process consists of the haplotypes  for both parents, the physical loci for all the snp markers, the genetic map corresponding to the chromosome , and the average numbers of crossovers on the chromosome among the female and male population, respectively.

the children haplotypes are generated through random inheritance of parental alleles after simulating crossover events. the χ2-model assumes that crossover intermediates  are distributed along the four-strand sister chromatid bundle with a rate of  <dig> c events per chromosomal interval, and every c event resolves in either a crossover  or not . furthermore, when a c event resolves in a cx, the next m c events must resolve as co's, followed by another cx event, i.e. the c events resolve in a sequence of ... cxmcxm... the leftmost c event has an equal chance to be one of cxm  <cit> . the simulation process determines the chromosomal intervals by reading, from the genetic map, the physical loci for all the snp markers, and the average numbers of crossovers. it then divides the whole chromosome from head to tail such that the length of each interval  is equal to the genetic distance  required for one crossover. for human chromosome  <dig>  this genetic distance is about  <dig>  morgans for males and  <dig>  morgans for females, respectively. the simulation process assumes no chromatid interference, and the child is simulated to randomly inherit one strand of the four-strand chromatid bundle from each parent.

to generate a pedigree genotype dataset, the simulation process locates the individual both of whose parents' haplotypes are either known or have been simulated, and then generates its haplotypes. it then locates the siblings who have only one parent in the pedigree, where its haplotypes are either known or have been simulated, randomly generates the haplotypes for the other parent, and then generates all the children haplotypes one by one. finally, when all individuals' haplotypes have been simulated, the allele parental information is erased at each snp site, to give the genotype data.

to validate that the haplotype allele sharing status can be correctly recovered by our programs, we simulate the pedigree genotype data for case-control association study. before the simulation process, a mutation region of length in between  <dig> and  <dig> mbps, and containing at least one heterozygous site, is randomly assigned to be close to a snp site in one haplotype of one of the founders. then, during the simulation process, the affected offspring are forced to inherit one of the mutation strands  and the unaffected are forced not to inherit any of the mutation strands. note that when a cx event cuts into the mutation region, then it has to be pushed to the last co event overlapping with the mutation region. that is, the affected offspring should inherit the complete mutation region.

since pedigrees of two or three generations are the most common in our previous experience with human disease association studies and more recent experience in cattle breeding industry, we used  <dig> pedigrees of two or three generations and of size  <dig> to  <dig> in the simulation study for validation purpose, in which the disease status for the members are semi-randomly assigned. for each pedigree, we used  <dig> sets of real unrelated genotype data for the founders; and for each set, we simulated  <dig> genotype datasets. those real unrelated genotype data were obtained from two different snp microarrays, genechip human mapping  <dig> k xba and  <dig> k xba arrays. in total, we have simulated  <dig>  <dig> k and  <dig> k genotype datasets, respectively.

CONCLUSIONS
we have showed that for pedigree genotype datasets, the haplotype allele sharing status among the members can be deterministically, efficiently, and accurately determined, even for very small pedigrees, by two most parsimonious partial haplotyping methods. given its excellent performance in both the breakpoint recovery and the shared region recovery, the program can be useful in many applications including haplotype based association studies.

authors' contributions
gl conceived the overall project. zc and gl detailed the methods. zc, hs, jx, and yw performed all the experiments, and all authors were involved in the result interpretation and discussion. gl drafted, and finalized the manuscript with rg and ps. all authors read and approved the final manuscript.

