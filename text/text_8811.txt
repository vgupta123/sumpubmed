BACKGROUND
researchers are increasingly working with large dna databases. for example, the human genome is approximately  <dig> gigabases. searching these databases has traditionally been done by using web applications to communicate with dedicated servers. as an alternative analysis tool, desktop computers offer richer and more responsive graphical interfaces. desktop software programs are available for displaying and manipulating plasmids and other relatively small dna molecules. such functionality could theoretically be extended to large dna databases, because typical desktop computers now have hard disk capacities of hundreds of gb. however, most bioinformatics applications load all of the relevant dna data into main memory, so the ram capacity of desktop computers remains a limitation. the challenge is to create desktop dna analysis software that accomodates large dna databases while using modest amounts of ram.

a basic requirement for such software is rapid searching of a dna database to find all exact matches for a query sequence. the desired search speeds can only be achieved by indexing the database. one well-characterized indexing strategy is to generate a suffix tree  <cit> . although suffix trees have been used productively for some molecular biology applications, such as aligning whole genomes  <cit> , they consume large amounts of memory, up to  <dig> bytes or more per base. suffix arrays are more compact than suffix trees and can provide similar search capabilities, but they still require 4– <dig> bytes per base  <cit> . these conventional suffix-based search strategies rely on loading the entire index into memory, so they are not currently suitable for desktop analysis of large dna databases. a potential solution to this problem is to generate a compressed suffix array using a burrows-wheeler transform  <cit> . the indexes generated by this method occupy as little as  <dig>  bytes per base, but indexing is slow: generation of a compressed suffix array for the human genome required many hours on a desktop computer  <cit> .

non-suffix-based indexing stategies are currently in more widespread use for dna databases. the ssaha algorithm divides a dna sequence into nonoverlapping k-mers, and stores the position of these k-mers in a hash table  <cit> . a similar indexing method is used by the blat algorithm  <cit> . both ssaha and blat generate relatively small indexes, on the order of  <dig> byte or less per base, and they can be orders of magnitude faster than fasta or blast, which index the query sequence rather than the database  <cit> . ssaha and blat have proven to be powerful for applications such as mapping sequence reads to a genome, or aligning mrna sequences with the corresponding genomic dna sequences. however, ssaha and blat have limitations. unlike suffix-based algorithms, which can identify all matches to any query sequence, ssaha cannot detect a match of fewer than k bases, and requires 2k- <dig> consecutive matching bases to guarantee that a match will be registered. because ssaha sorts the search results, efficient searching is achieved by ignoring the k-mers that occur most frequently in the database. similarly, blat sacrifices completeness for speed.

these various algorithms have been designed with the assumption that the complete index of a dna database will be stored in main memory. such algorithms are inconvenient for desktop applications. an index might be too large to fit within the ram of a personal computer. even if sufficient ram were available, loading an index might be time-consuming. for example, a compressed suffix array of the human genome occupies about  <dig> gb  <cit> , and reading those data from a hard disk into ram would require tens of seconds, an unacceptable delay for users who expect fast access to information. we are developing software that will allow users to open and browse a large dna database as rapidly as they open a plasmid file. the main innovation of our approach is to leave the index on disk, and to retrieve the relevant data selectively during a search.

for general purpose dna analysis software, the database searches need to be comprehensive. applications include searching whole chromosomes to create complete lists of restriction sites or oligonucleotide hybridization sites. we have met this need with an indexing and searching algorithm called mica . the indexes occupy ~ <dig> bytes per base and can be generated quickly. unlike most other algorithms, mica indexes not only the standard nucleotide base characters a, c, g, and t, but also the degenerate base characters b, d, h, k, m, r, s, v, w, y, and n. efficient search procedures identify all matches for a nondegenerate or partially degenerate query of any length. when a file is being searched, only a fraction of the index is loaded into memory. the result is that desktop computers with modest amounts of ram can rapidly open and search large dna databases.

implementation
index structure
indexing a dna sequence can be achieved by scanning the sequence with a window of width k. for a sequence of length l, sliding the window one base at a time yields l - k +  <dig> overlapping k-mers. a mica index uses arrays to store all of the positions for each k-mer in the subject dna sequence. because chromosomal dna molecules can be up to several hundred million bases long, the k-mer position values would normally be represented as 4-byte integers. we reduce this data storage requirement by dividing the sequence into c separate "chunks" of  <dig>   bases, where c = ceiling. the intra-chunk positions of each nondegenerate k-mer are stored as 2-byte integers. the absolute positions of a k-mer within the full dna sequence can then be calculated with the aid of a list specifying the number of instances of the k-mer within each chunk.

in addition to the four nondegenerate base characters, there are  <dig> characters  representing partially degenerate base possibilities, plus one character  that represents any possible base. partially degenerate k-mers must be recognized if the index is to capture all of the information in any dna sequence. it would be wasteful to create an array for all of the different partially degenerate k-mers because most of the array elements would typically be empty. instead, for each partially degenerate k-mer that is actually present in a subject sequence, we use a 4-byte integer to record the absolute position of the k-mer, followed by a k-byte string to record the sequence of the k-mer. this approach is inefficient with regard to data storage, but most dna sequences contain very few partially degenerate k-mers, and the simplicity of the data format facilitates searching. a separate strategy is used for stretches of n's, which are commonly used to indicate undefined portions of a sequence. here s designates the number of "n-stretches" of k or more consecutive n's. mica efficiently indexes n-stretches by recording their starting positions and their lengths.

also stored in the index is the topology of the subject dna molecule . with circular dna molecules, mica finds matching sequences that span the numerically defined origin.

a mica file consists of a sequence segment  followed by an index segment . if a sequence occupies more than  <dig> chunks, then loading of a mica index consists of reading elements a – c of the sequence segment, skipping over the dna sequence, and reading elements e – j of the index segment. the parameters for human chromosome  <dig> were: l =  <dig> , <dig> bases; c =  <dig>  chunks; s =  <dig> n-stretches .

 a single byte is used to specify the sequence segment format.

 the size of the sequence segment is specified by a 4-byte integer.

 a single byte is used to record properties of the sequence, including its topology  and its strandedness .

 the dna sequence is stored as a string of uppercase ascii characters.

 a single byte is used to specify the index segment format.

 the size of the index segment is specified by a 4-byte integer.

 a single byte is used to record the byte order  of the index. if the byte order is opposite to that of the machine being used to run the queries, mica corrects the byte order when processing the index data.

 the chunk counts summary is a list of 4k 4-byte integers representing the total number of times each nondegenerate k-mer appears in the sequence. for the mica index, the 4-base nondegenerate dna alphabet is arranged in the order g, a, t, c. thus, the first nondegenerate k-mer listed is gggg  or gggggg , and the last one listed is cccc  or cccccc . this lexicographical order yields contiguous index reads for k-mers that end in the most common partially degenerate bases: r , y , and w .

 the degenerate k-mer count is a 4-byte integer representing the total number of partially degenerate k-mers in the sequence.

 the n-stretch count s is a 4-byte integer representing the number of separate stretches of k or more consecutive n's.

 the chunk data array is divided into 4k partitions corresponding to the 4k nondegenerate k-mers. each partition contains a list of 2-byte integers representing the number of times the k-mer is present in each of the c chunks, followed by a list of 2-byte integers representing the intra-chunk positions of the k-mer in each of the c chunks. the first partition contains the data for gggg  or gggggg , and the second partition contains the data for ggga  or ggggga , and so on.

 the degenerate data array is a list of the partially degenerate k-mers. each partially degenerate k-mer is represented as a 4-byte integer that marks the absolute position of the k-mer, followed by a k-byte string that encodes the sequence of the k-mer.

 the n-stretch data array consists of s pairs of 4-byte integers that represent the starting positions and lengths of the n-stretches.

choice of k
the main body of a mica index is the chunk data array, which stores the positions of the nondegenerate k-mers . the total number of position values is largely independent of k. however, there are 4k different nondegenerate k-mers, so the chunk data array is divided into 4k partitions. each partition is divided into c sub-partitions that contain the intra-chunk position values. the sizes of these sub-partitions are recorded in a list at the beginning of the partition. as a result, the practical upper limit for k is  <dig>  because for k =  <dig> there would be  <dig>  sub-partitions per chunk, and the lists of sub-partition sizes would occupy more space than the lists of k-mer position values. the practical lower limit for k is  <dig>  because reducing k increases the size of the partitions that must be read from disk, thereby slowing most searches.

index creation
to create a mica index, a subject dna sequence in fasta format  <cit>  is scanned using a window of width k. both uppercase and lowercase characters are recognized. an initial scan fills in the data for index elements e – j . then the appropriate memory for the data arrays  is allocated, and a second scan fills in the positions of the k-mers and n-stretches. these operations are fast, partly because building the index requires no sorting.

if sufficient memory is available, indexing speed is maximized by building the entire index in memory and then writing to disk in a single step. in the case of human chromosome  <dig>  this process requires about  <dig>  gb of ram, an amount that is available on many desktop computers. if memory is limiting, only a subset of the k-mer position values are stored in memory at a given time, and the index is written to disk in multiple steps.

currently, mica embeds a copy of the dna sequence within the file. this sequence consists of uppercase characters in 8-bit ascii format, and therefore occupies l bytes. the original sequence file is then dispensable for searching. for future applications, mica will be integrated with software that automatically generates a suitably formatted dna sequence.

general search strategy
if a dna sequence occupies more than  <dig> chunks , only elements a – c and e – j of the mica file are initially read from disk . these reads are very fast because they involve a small amount of data, just over  <dig> kb for k =  <dig> or just over  <dig> kb for k =  <dig>  during a search, mica uses the data from this first portion of the index to find the relevant position values. for example, to find the positions of a nondegenerate k-mer, an entry in the chunk counts summary  indicates where the relevant position values can be read from the chunk data array . thus, mica selectively reads only the essential data from disk, thereby performing efficient i/o operations and minimizing ram usage.

if a query is shorter than k bases, it is extended to k bases by adding n's, and is then treated as being partially degenerate . if a query is exactly k bases, the search consists of converting the 2-byte intra-chunk position values for that k-mer to 4-byte absolute position values. if a query is longer than k bases, it is decomposed into constituent k-mers, which are examined as follows. the list of intra-chunk position values for the first k-mer is read from the index and converted to absolute position values, thereby creating an initial working list. each value in the working list is then compared with the second k-mer list. the result is a new working list, which indicates where both the first and second k-mers from the query match the subject dna sequence. this new working list is then compared with the next k-mer list, and so on. in this manner, mica progressively trims the initial working list to generate a final list of matches.

with a query longer than k bases, the constituent k-mers are examined in increasing order of their frequency of appearance in the subject dna sequence. for example, a search for the 12-mer aaaaccccgggg using k =  <dig> might involve calculating the positions for cccc, then comparing each cccc position against the list of positions for gggg, then comparing each ccccgggg position against the list of positions for aaaa, which in this case would be the most common of the three 4-mers. this strategy of starting with the rarest k-mer can significantly accelerate searches because some k-mers are found less frequently than others and therefore result in fewer comparisons. in chromosome  <dig>  the most common 4-mer  appears  <dig> times more often than the rarest 4-mer , and the most common 6-mer  appears  <dig> times more often than the rarest 6-mer .

each successive k-mer search is limited to the range of chunks that generated hits for the current working list. in the example above, after the ccccgggg hits have been identified, the search for aaaa is limited to the chunks between the first and last occurrence of ccccgggg. if a working list contains no hits, the search is terminated. this range limitation method can accelerate searches when a query has a small number of matches to the subject sequence.

searching with partially degenerate queries
a partially degenerate query can be expanded by searching for all of the possible matching sequences. for example, the restriction enzyme bsp1286i has the recognition sequence gdgchc, which can potentially match  <dig> nondegenerate sequences  and  <dig> partially degenerate sequences . a search for gdgchc will therefore return matches for all of the  <dig> possible matching 6-mers. alternatively, searches for a partially degenerate query can be restricted to return only literal matches to that character string, so a search for "gdgchc" will return matches only for the single 6-mer gdgchc.

mica scans a partially degenerate query to determine an efficient search strategy that limits the degeneracy of the constituent k-mers. for example, the restriction enzyme baei has the recognition sequence acnnnngtayc, and for k =  <dig> the matches are found by searching for gtay, tayc, and acnn. the mica index is ordered lexicographically, so the k-mer acnn invokes  <dig> contiguous disk reads from the chunk data array, whereas the equivalent k-mers nnac and nacn would invoke non-contiguous reads. because contiguous reads are faster than non-contiguous reads, mica pushes any degeneracy to the end of a k-mer whenever possible.

with a partially degenerate k-mer, the working list must be compared to multiple individual k-mer lists using an intersection algorithm. an obvious approach would be to adapt the method that is used with a single nondegenerate k-mer. in that case, mica finds the intersection of the working list and the next k-mer list using a standard technique: a pointer is assigned to the k-mer list, and for each successive element in the working list, the pointer is advanced until the value in the k-mer list equals or exceeds the value in the working list  <cit> . when there are multiple k-mer lists, a pointer can be assigned to each one, and a working list element can be compared to all of the k-mer lists. however, this method becomes very inefficient if the working list is larger than the individual k-mer lists, because most of the comparisons fail to advance the pointers. mica therefore uses an alternative intersection algorithm for partially degenerate k-mers. a boolean array of  <dig>  elements is used to represent the positions in a chunk. for a given chunk, all of the individual k-mer lists are scanned, and the 2-byte position values are recorded by setting the corresponding boolean elements to true, yielding a boolean array that indicates which positions in the chunk match one of the k-mers. then the intersection is obtained by checking whether each working list element corresponds to a value of true in the boolean array. this method is efficient due to the relatively small number of operations and the sequential nature of the memory accesses.

when a k-mer is very degenerate, a substantial amount of time may be needed to read and process the index data. in such cases, mica switches to an alternate mode that uses the embedded dna sequence. the entire query is compared to dna sequence fragments that overlap each hit in the working list. based on empirical tests, mica was configured to perform this mode switch whenever the amount of index data that would need to be read exceeds 33% of the total dna sequence data. this condition typically arises with extremely degenerate k-mers such as annn  or annnnn . even with a less degenerate k-mer, the alternate mode is used if more data would be read by using the index than by directly examining the dna sequence. thus, at each stage of a search, mica takes advantage of the fastest available option.

memory management during searches
reading data from disk is slow, so the search speed can be maximized by pre-loading the entire file into main memory. mica uses this approach when the sequence occupies up to  <dig> chunks. the corresponding files usually occupy no more than  <dig> mb of ram and can be read from disk in a fraction of a second.

for longer sequences, as described above, mica sacrifices some potential search speed in exchange for rapid index loading and low memory usage. the only parts of the index that are initially read into memory are the elements that describe the structure of the data arrays. during a search, the position values for the relevant k-mers are selectively read from disk. these read operations are usually the rate-limiting step in the search, but they are relatively efficient because of the compact 2-byte indexing format and because all of the positions for each k-mer are stored contiguously. only a small portion of the index is used at a given time, so a typical search requires very little memory.

if a query sequence contains a degenerate or otherwise abundant k-mer, then reading the full list of position values for that k-mer might require more ram than is available. mica deals with this situation by dividing the subject sequence into segments and searching each segment in turn. during the search of a given segment, only the corresponding k-mer position values are read into memory.

RESULTS
mica was coded in c++ and tested on a  <dig> -ghz g <dig> macintosh running os x  with  <dig> gb of ram. as subject data we used the may  <dig> ensembl release of the human genome  <cit> , comprising  <dig>  gigabases in  <dig> files representing the linear chromosomes 1– <dig>  x, and y, plus the circular mitochondrial chromosome. a simple graphical user interface was later constructed using trolltech's qt  <dig> .

indexing performance
for a server application, a large index may be acceptable if sufficient memory is available, and slow indexing is acceptable because the index is created once and then used indefinitely. for a desktop application, smaller indexes are desirable because they occupy less disk space. moreover, versatility is increased if the index can be created and updated rapidly, because this feature facilitates the analysis of new sequences and the modification of existing sequences.

chromosome 1
random sequence
human genome
the sequences of chromosome  <dig> and the  <dig> chromosomes comprising the human genome were obtained from the ensembl database. we also tested a computer-generated random sequence of  <dig> , <dig> bp containing equal proportions of g, a, t, and c. index size refers to index elements e – m of the mica file , and does not include the sequence segment. the creation time for each index includes the time needed to write the index to disk, but does not include the additional time needed to embed a copy of the sequence within the file; this additional embedding time for chromosome  <dig> was  <dig>  sec for k =  <dig> or  <dig>  sec for k =  <dig>  index loading refers to the reading of elements a – c and e – j of an index from disk into memory. for the human genome, the values listed are the sums of the values for the individual chromosomes.

to simulate indexing with limited ram, we instructed mica to index chromosome  <dig> using the procedure that would be followed if only  <dig> mb of ram were available. the indexing time for k =  <dig> was  <dig> sec, which should still be adequate for most applications.

searching performance
the subject sequences were chromosome  <dig> or the entire human genome, and both dna strands were searched. with the entire genome, the relevant index elements for each chromosome were loaded separately into memory for each search, but these loading times  accounted for only a small fraction of the total search times. a series of searches was performed with nondegenerate queries of various lengths and with several partially degenerate queries.

both dna strands were searched using k =  <dig>  results for the 3- to 1000-mer searches are average values obtained by searching with multiple queries. for 3-mers, all  <dig> possible nondegenerate queries were tested by extending each 3-mer to a partially degenerate 4-mer. for 4-mers, all  <dig> possible nondegenerate queries were tested. for 6- and 8-mers,  <dig> randomly chosen nondegenerate queries were tested. in the case of 15- to 1000-mers, each test involved  <dig> nondegenerate queries that were extracted randomly from chromosome  <dig> and checked to confirm that a given query had no more than  <dig> matches in the genome. the alu 30-mer fragment ggccgggcgcggtggctcacgcctgtaatc is a conserved sequence found at the 5' ends of alu repeat elements  <cit> . the three partially degenerate queries are the recognition sequences for the restriction enzymes bsp1286i, bgli, and baei. for chromosome  <dig>  the search times without brackets were obtained after pre-loading only file elements a – c and e – j  into memory, and the faster search times with brackets were obtained after pre-loading the entire file. for the entire genome, the search times include the time needed to load elements a – c and e – j of each file into memory. thus, the data for chromosome  <dig> reflect the time needed to search a file that is already open, whereas the data for the entire genome reflect the time needed to search a set of unopened files. to ensure that the search times without brackets reflect mica performance for newly opened indexes, each search was preceded by a large number of extraneous reads, which flushed the main memory of any prior data from the relevant index.

both dna strands were searched using k =  <dig>  the queries and the procedure were as described in table  <dig>  except that each 3- or 4-mer was extended to a partially degenerate 6-mer.

when the query length is less than k, the search times are relatively long because multiple k-mer lists must be merged. as an example for k =  <dig>  the positions of each 3-mer were found by merging four 4-mer lists, so the 3-mer searches were much slower than the 4-mer searches . for k =  <dig>  the 4-mer searches were much slower than the 6-mer searches, and the 3-mer searches were slower still . multiway merges are naturally suited to parallel processing  <cit> , and we are exploring the possibility of accelerating merges by harnessing the enhanced multithreading capacity of newer desktop computers.

for a given query length, searches are fast if there are very few matches to the query, and somewhat slower if multiple matches are distributed throughout the subject sequence. as a test case of a query with many matches, we used a conserved 30-base fragment of the alu repeat element  <cit> . this alu fragment was found  <dig>  times in chromosome  <dig> and  <dig>  times in the entire genome. the searches for the alu fragment took only slightly longer than the searches for rare 30-mers . thus, mica delivers strong performance even with repeated sequences, which are challenging for some other search algorithms  <cit> .

to test partially degenerate queries, we searched for the recognition sequences of the restriction enzymes bsp1286i , bgli , and baei . in the case of bgli, the search involved generating lists of positions for the 3-mers gcc and ggc, and then finding the intersection of those lists. as described above, 3-mer searches are expensive because of the merges, so mica defers such merges until after the intersection operations. this approach made searching for the bgli recognition sequence about twice as fast as searching for a single 3-mer . the searches for the non-palindromic baei recognition sequence were relatively slow because mica needed to process the data for the 2-mers ac and gt. in general, the most time-consuming searches are those involving k-mers with substantial degeneracy, because multiple individual k-mer lists need to be read from disk and then examined.

effects of varying k
we performed extensive tests with k chosen to be either  <dig> or  <dig>  for k=  <dig> the individual k-mer reads were 16-fold smaller on average than for k =  <dig>  yet the k =  <dig> searches for typical nondegenerate queries were faster by only about five-fold . the reason for this discrepancy is that the k =  <dig> reads are so small that disk seek times become limiting. thus, increasing k to  <dig> would only marginally accelerate searches for typical nondegenerate queries. moreover, a larger value of k would be detrimental with very short queries and with some partially degenerate queries. for example, when searching for the bgli recognition sequence, mica expands the 3-mer gcc to the 4-fold degenerate gccn for k =  <dig>  but expands the same 3-mer to the 64-fold degenerate gccnnn for k =  <dig> or the 256-fold degenerate gccnnnn for k =  <dig>  the best overall compromise for most purposes seems to be k =  <dig> 

in the case of dna molecules such as plasmids for which only a few kb are needed to store the dna sequence, a k =  <dig> index is excessively large because it requires  <dig> kb to record how many times each nondegenerate k-mer is present. by contrast, a k =  <dig> index requires only  <dig>  kb to store this information for a molecule of up to  <dig>  bp. therefore, mica uses k =  <dig> if the dna sequence fits within one chunk, or k =  <dig> if the dna sequence occupies two or more chunks.

effects of memory usage
for the genome-wide searches listed in table  <dig>  the amount of ram used by mica ranged from about  <dig>  mb for a rare 6-mer to  <dig> mb for baei sites. these numbers are small because the searches were performed one chromosome at a time. to determine how memory limitation affects search times, we searched for baei sites in chromosome  <dig> under conditions that simulated different amounts of available ram . the memory check algorithm estimated conservatively that searching all of chromosome  <dig> would require a maximum of  <dig>  mb of ram. as a result, when the available ram dropped below this level, chromosome  <dig> was searched in segments. the search speeds decreased accordingly, but this decrease was not severe until the available ram dropped below about  <dig> mb. thus, even when a database contains large chromosomal sequence files, searching can be performed efficiently using a computer with modest amounts of memory.

because all of the nuclear human chromosomes exceed  <dig> megabase in length, mica does not load the full indexes into memory, but instead loads only the elements that describe the structure of the data arrays. the benefits of this strategy are rapid index loading and low memory usage. the disadvantage is that searches are slower than they would be if the full indexes were pre-loaded into memory. to quantify this effect, we repeated the test searches after pre-loading into memory the full mica file for chromosome  <dig>  the resulting values, listed in brackets in tables  <dig> and  <dig>  show that pre-loading accelerated the searches. this acceleration was dramatic with nondegenerate queries of length k or more. yet the pre-loading operation took approximately  <dig> sec, a prohibitively long time if the goal is to do one or a few quick searches. by avoiding a time-consuming preparatory stage, mica enables users to search large sequences without delay.

immediately after indexing, the entire index is typically available in memory, so this time point is convenient for doing any routine searches. as a model for such a routine search, we indexed chromosome  <dig> using k =  <dig>  and then searched for the recognition sequences of the  <dig> restriction enzymes sold by new england biolabs. this search was fast at just under  <dig> sec.

relation to other approaches
the mica index is hash-based but is actually related to suffix-based indexes. hunt  <cit>  has defined the "suffix sequoia" as a suffix tree derivative in which the entries are truncated at a string length of k. the result is a lexicographically-ordered k-mer array, which resembles the chunk data array in the mica index , except that the suffix sequoia is about twice the size because absolute positions are stored as 4-byte integers. another algorithm that resembles mica is acmes, which creates a hash table of 8-mers and accesses only the relevant hash bins during a search  <cit> . acmes can find exact matches for queries of any length, although the indexes are large because this program was designed to search both sequence and annotation data. thus, a number of researchers have converged on the same general strategy for indexing dna sequences.

despite these similarities, mica has the following unusual features that make it advantageous, especially for desktop applications.

 a mica index occupies only about 2l bytes, and a mammalian genome can be indexed in a few minutes. the previously described indexes that support comprehensive searching are either substantially larger or require much longer to generate.

 rapid searching is accomplished without loading large amounts of data into main memory, because only a small fraction of each index is typically read from disk. even if memory is quite limited, the search operations are still fast.

 because mica indexes 4- to 6-mers, very short queries can be matched quickly. this functionality is particularly useful for finding restriction sites. by comparison, acmes indexes 8-mers and is therefore slower at matching very short queries  <cit> .

 mica can recognize and index all  <dig> characters of the standard dna alphabet. by comparison, degenerate base characters are read as a's by ssaha  <cit>  and are excluded from the index by blat  <cit> . acmes expands degenerate base characters by adding index entries for all of the corresponding nondegenerate 8-mers  <cit> , but this approach has the disadvantage of indexing possible sequences as if they were actually present. with mica, the index precisely captures the information in the original sequence, and the searches find all matches to any nondegenerate or partially degenerate query.

CONCLUSIONS
mica is designed to be a core indexing and search engine. because the underlying approach is very simple, we were able to optimize the algorithms extensively to take advantage of the properties of modern desktop computers  <cit> . the end result meets our goal of enabling users to open and search large dna databases rapidly on computers with limited ram.

in its present form, mica is ideally suited to comprehensive searching for exact matches in a dna database. such a database might represent, e.g., a genome or a collection of plasmid vectors. potential applications include: in silico restriction enzyme digestion, which can be used to type organisms by amplified fragment length polymorphism  analysis or pulsed field gel electrophoresis  <cit> ; "virtual pcr" to predict the specificity of pcr amplification from complex templates  <cit> ; and the automated definition of oligonucleotide-flanked sequence-tagged sites  in genomic sequences  <cit> . we are incorporating mica into desktop software that allows for versatile browsing and manipulation of chromosome-sized dna sequences. for example, a mica-based pcr simulator allows us to simulate a pcr amplification from human genomic dna in 2– <dig> sec.

mica could be extended by adding alignment algorithms for identifying sequences that are similar but not identical to the query. such algorithms have been widely studied and implemented  <cit> , and they can benefit greatly from using an index to find "seeds" for the alignments  <cit> . in addition, mica could easily be modified to operate in server mode. for this purpose, faster searching of large sequences would be achieved by loading the complete indexes into memory, as illustrated in tables  <dig> and  <dig> 

availability and requirements
project name: mica – desktop software for comprehensive searching of dna databases

project home page: mica binaries for macintosh os x  and windows  are available at .

operating systems: macintosh os x  and windows 

programming language: c++

other requirements: none

license: freely available for academic and non-profit use. researchers can request assistance with obtaining the mica source code and integrating it with other software.

any restrictions to use by non-academics: commercial users require a license. for questions regarding commercial uses, please contact the university of chicago's office of technology and intellectual property, uctech, at  702– <dig> or www.uctech.uchicago.edu.

authors' contributions
was generated the code, and bsg guided the project. both authors contributed to the algorithm design.

both authors read and approved the final manuscript.

