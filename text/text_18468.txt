BACKGROUND
while there has been extensive work in both automated gene finding  <cit>  and functional assignment  <cit> , there are only a few automated whole-genome annotation systems available as open source projects  <cit>  and none, of which we are aware, that can be used without significant setup or manual interaction. for annotation pipelines that are commercially available  <cit>  or provided as a service  <cit> , it is difficult to obtain and evaluate information for the methods used. by formally addressing the integration of each component in the annotation process as part of a completely automated, open source project, it may be possible to gain a further understanding of problems facing automated genome annotation as a whole.

the genome reverse compiler is open source software intended for explorative annotation of prokaryotic genomic sequences. its name and philosophy are based on analogy with a high-level programming language compiler. in this analogy, the genome is a program in a certain low-level language that humans cannot understand. given the sequence of any prokaryotic genome, grc produces its corresponding "high-level program" – its annotation. grc allows the user to annotate a target genome by simply providing annotated protein sequences, in widely accepted formats, from organisms related to the target. grc uses a similarity search against these sequences, and sequence information from the genome itself, to find protein coding genes and determine putative function of their products. we believe an integrated, open source annotation tool such as grc benefits the life sciences community in several ways. it opens up the realm of electronic annotation to researchers who wish to annotate sequences in-house but who lack the resources to setup an annotation pipeline. also, submission to an online annotation service may not be realistic for those wishing to annotate a large number of sequences or for sequences that do not meet with submission restrictions. grc can provide targeted whole genome annotation since it allows users to provide the protein sequence database to be used for annotation; such a mechanism can be especially helpful in situations where users have their own curated database of sequences in addition to publicly available sequences.

in whole genome annotation, before an organism's genes can be annotated they must be found within the genomic sequence. in its current form, the grc focuses on finding orfs and evaluating whether they will likely be translated into protein. in making this evaluation, one consideration is sequence composition: whether the amino acid composition of the sequence is characteristic of typical coding genes found in the target organism. some other sources of information to consider are: whether the sequence is conserved across multiple organisms , whether two open reading frames overlap with one another, and the sequence length of an orf.

once an orf is determined likely to be a real gene, an annotation procedure may assign some additional information. typically this information includes the function of the gene product. currently there is no way to computationally determine function ab initio. that is, to determine the function of a gene solely based on its sequence composition without reference to a similar sequence whose function is already known.

common practice is to assign the function of genes based on sequence similarity comparisons to a database of genes whose functions are known. in many annotation procedures, the database sequence that has the top scoring, statistically significant alignment with a target gene has its function transferred to that target gene. because functional information is frequently electronically transplanted from one sequence to another, the degree of separation between the original source of functional information and where it is applied can be great. this may cause an inappropriate functional assignment and can lead to "error propagation", where erroneous information is repeatedly applied to various sequences through multiple electronic annotations  <cit> . to address this situation the grc provides several mechanisms for controlling how functions are assigned and gives the evidence for each assignment as part of the annotation.

traditional biological nomenclature for describing genes and their products have many subtleties, redundancies, and inconsistencies. the distinctions and assumptions necessary for interpreting this information do not promote interoperability among functional genomic databases and are difficult to account for computationally. this problem can be addressed by using a structured, precisely defined system for specifying information about a gene. one such system is the gene ontology  <cit> . the gene ontology, or go as it is commonly called, is a controlled vocabulary of terms that describe the molecular function, biological process, and cellular component of a gene. go is structured as a directed acyclic graph that creates a subsumption hierarchy through its "is_a" and other directed arcs. in this hierarchy, when one node/function is assigned to a particular sequence, all parent/ancestor nodes up to the root are implicitly assigned. using the gene ontology gives an added measure of precision to assigning functions to genes. by making use of evidence codes and the go term id numbers, we can adapt the behavior of the annotation process to the information available for a specific sequence.

the rapid accumulation and widespread availability of genomic information for prokaryotes makes it possible to use information from previous annotations of closely related organisms to annotate a newly sequenced genome. sequencing costs are already low enough that hundreds of new prokaryotic genomes are being sequenced every year. moreover, efforts are underway to fill the still existing "phylogenetic gaps" in the databases of prokaryotic sequences  <cit> . the grc depends on this availability to create its annotations. using prior annotation information raises several questions that can be addressed computationally. how should the assertions made in another organism's annotation impact the assertions made for the target organism? in what context are we to believe or disbelieve indications made by previous annotations? when multiple annotations are involved, how do we resolve conflicting information? in creating an integrated annotation tool we investigate possible answers to these questions and explore novel ways for determining, in silico, the location and function of protein coding genes as part of an integrated process.

implementation
gene finding
many popular gene finding algorithms perform ab initio by building a sequence model based on the target genomic sequence. in creating or applying this model it is possible to overly bias results against anomalous sequences, such as viral genes or recently acquired conjugated genes. grc incorporates a gene finding module which uses information from closely related genomes. in addition to sequence similarity information, this algorithm evaluates the information content of sequences using entropy-density profiles  introduced by zhu et al.  <cit> .

to evaluate whether sequences are likely to be protein coding genes we consider sequence conservation, composition, and overlap in the genome. conservation is determined by a sequence similarity search using fsa-blast  <cit>  against a user-provided sequence database . composition is evaluated using entropy-density profiles introduced by zhu et al.  <cit> , and subsequently used in med  <dig>   <cit>  and glimmer <dig>  <cit> . edps are emphasized by the grc to discriminate between likely coding and non-coding sequences when there is low scoring or no sequence similarity information for an orf. in their previous work zhu et al. show the efficacy of this value by testing it on several well annotated bacterial genomes. an edp is a feature vector, based on shannon information theory  <cit> , used to describe the amino acid content of a sequence. in this work, we use the edp as an additional piece of evidence to indicate the coding potential of a sequence. in the method used by zhu et al., each sequence is mapped to its own edp and then compared to both a representative coding and non-coding edp, which we will refer to as the global edps. each sequence is then classified as coding or non-coding based on its distance from the global edps in the 20-dimensional phase space. let pi be the count for each amino acid in a sequence where i =  <dig>  ...,  <dig> represents the index of a specific amino acid. for a given sequence of length l, let fi be the frequency of the ith amino acid where fi=pil. the shannon entropy for the given sequence is then defined as:

 h=−∑i=120filog⁡ 

the entropy-density for the ith amino acid of a sequence is defined as:

 si=−filog⁡h 

to compute the edp feature vector for a given sequence we compute si for i =  <dig>  ...,  <dig> 

zhu et al. demonstrate that global edps representing coding and non-coding sequences for all prokaryotes can act as good centers for their respective groups in the 20-dimensional phase space and as a result can be used as initial discriminators to classify a sequence as coding or non-coding  <cit> . to perform this classification, they calculate what we will call the "entropy distance ratio" . the edr is the ratio of the relative distances to the global edps. the distance for a particular sequence to the global edps, dc or dnc, is defined as the euclidean distance:

 dα=2)1/ <dig> 

where α represents "c" for coding or "nc" for non-coding.

the edr is then defined to be:

 edr = dc/dnc 

the gene finding procedure for grc is as follows: all orfs are generated from a linear scan of the genome. let m represent this set of sequences. in order to minimize the number of unnecessary overlap evaluations, we first determine the most likely start site for each orf. the start sites are adjusted from the original maximal coordinate to the highest scoring start site. each start site is scored according to the average frequency at which its codon occurs and how well they fit the gene model suggested by the highest scoring compatible alignment . all potential start sites are placed in a priority queue based on score.

orfs that occupy the same genomic space are said to overlap. these overlaps are evaluated and resolved by either adjusting the start coordinate of one of the offending orfs or removing an orf from set m. this process creates a set of likely coding orfs c as well as a set of orfs likely to be non-coding l. the likely coding and non-coding sets c and l are used to retrain the respective coding, non-coding global edps for the organism. entropy distance ratios are calculated for each sequence using the new global edps. all orfs with poor similarity scores and edr scores are removed from the original set m creating a refined set m'. using the new edr values, a second round of overlap evaluation is performed on m' to determine the final set of protein coding genes .

grc takes a heuristic approach in using information from multiple pairwise alignments and start codon frequencies to rank potential translation initiation sites. each alignment, in the multiple pairwise alignments of the query orf, is taken to be evidence of the start sites that occur between the aligned region and the beginning of the maximally long orf . a score, α, is calculated for each putative start site, for each supporting alignment. as it is possible for each start site to be supported by more than one alignment, only the maximum α across all supporting alignments is used to represent a particular start site. we give weight to start sites that occur in closer proximity to the conserved region and that occur at a higher frequency by scoring each site according to the function α = β + γ + δ, where β is the average of the frequencies that a start site codon is found in the experimentally verified datasets of e. coli  <cit>  and b. subtilis  <cit>  as computed by makita et al.  <cit>  . these start codons and their corresponding β values are used by default but may be changed by the user to match the target organism. the γ and δ components are alignment specific: γ=bitbitself. here bit represents the bit score from the alignment used to score the start and bitself is the bit score that would result from an alignment of the entire sequence to itself. this "bit fraction", γ, is also used in overlap evaluation and orf removal. the last component, δ, is the bit score of the alignment divided by the largest bit score of all the alignments for the given orf. this gives weight to those starts supported by longer conserved sequences.

in the "all orfs evaluation" procedure from figure  <dig>  orfs with poor similarity and edr scores are removed from consideration as coding genes. orfs greater than  <dig> bp are kept if they have an alignment γ score greater than  <dig>  or an edr value less than  <dig> . orfs less than  <dig> bp are considered small and occur at a higher frequency than those with longer sequences. because they occur so often, small orfs can represent a significant source of predictions and still pose a challenge for gene prediction  <cit> . small orfs are kept if they have a γ score greater than  <dig>  or an edr value less than one positive standard deviation from the mean edr value of the coding set used to retrain the edps .

genes can and do overlap in prokaryotic genomes  <cit> . some of these overlaps are speculated to be important in regulation of gene expression  <cit> , while others are thought to stem from phage interaction  <cit> . for our purposes, when evaluating overlaps present in the set of all orfs, it is important to determine whether the overlaps represent a biological phenomenon, an error in gene coordinates, or an indication that one of the orfs involved is not a protein coding gene. to do this, we use the blast hits and the edr values for the orfs involved to specify the amount of overlap allowed. for any given pair of overlapping orfs it is possible for both to have alignments with significant scores. each alignment is taken as evidence that an orf exists as a protein coding gene . if the overlap is large and there can be no reconciliation by adjusting the start site coordinate, then it is likely that one of the orfs is not a protein coding gene and should be removed.

in a study of  <dig> microbial genomes johnson et al.  <cit>  find that  <dig> percent of gene overlaps are less than  <dig> bp and  <dig> percent are less than  <dig> bp. extrapolating, we define a range of  <dig> .. <dig> bp for initial allowable overlap between orfs. although empirical observation indicates a maximum overlap of  <dig> bp, we allow up to twice that  if the evidence for both orfs is strong. this allows the overlap to be evaluated by the user so that he or she can make a value judgment based on the evidence. the amount of allowable overlap is defined to be:

 allowed = ) *  <dig> 

if the edp for the sequence is closer to the non-coding profile, then the edr value will be greater than one leading to a decrease in the overlap allowed. here we use the edr and γ values from the orf that will be removed if the overlap is not resolved.

to determine which orf in an overlapping pair will be removed we compare each orf's alignment score, edr, and length according to the following heuristic:

if one orf has an alignment and the other does not, then the orf with no alignment is removed. in all other cases the property which is determined to be the stronger discriminator is used. for two orfs, orf <dig> and orf <dig>  this is decided by comparing the values of the percentage difference, ds for each property where s = {γ, edr, length}.

 ds = |s <dig> - s2|/m in  

if both orfs have alignments, then the ds values for bit fraction and edr are compared. if neither do, then the ds values for edr and orf length are compared. in both of these cases the property with the highest ds value is used to decide which orf is removed.

as part of the overlap evaluation process, it may be found that altering the start coordinate of one of the conflicting orfs will resolve an overlap. because the highest scoring start sites are determined before overlaps are evaluated, only the alternative start sites for the low-scoring orf of an overlapping pair are considered in resolving an overlap. obviously if the overlap does not occur on the 5' end of an orf, there is no point in exploring alternative start sites. alternative start sites are considered in order of their score as given by the start site priority queue. because the grc stores information about multiple pairwise alignments for each orf, it is possible that certain alignments are compatible with some start sites and not with others . for each start site the alignment that best fits the sequence  is used to represent the orf.

functional assignment
the functional assignments of grc are based on associations, established through sequence similarity, between query orfs found in the target genome and the subject sequences in the grc blast database. each association comes from an alignment that meets a user specified, e-value significance threshold. by default, the functions assigned to a query orf are based on the annotation of one subject sequence chosen from those that have a significant alignment to the query. the subject whose alignment gives the highest α value , and is compatible with the start coordinate , is used as the source of functional information to annotate a particular orf . if the database does not contain a sequence similar to the query sequence, then there can be no function assigned to it.

the exact information assigned to an orf depends on the input provided to grc. at its most basic level grc takes a collection of amino acid fasta files and uses it to create the blast database. in this case grc simply parses the contents of the fasta header of a subject sequence to create the annotations. if the user provides annotation tables for the corresponding sequence files then the parsing and annotation construction becomes more precise. with this level of input the product description and gene name are specified exactly and inappropriate information can be excluded. currently the grc supports protein annotation tables from ncbi and embl. the output of grc also provides detailed information about functional assignment decisions, including confidence scores for assigned go terms that are based on the γ score of the corresponding alignment.

if go annotations are provided as additional input, grc's functional assignment becomes more adaptable. by default grc assigns go terms associated with the source subject as it does in the regular annotation procedure. however, when using the gene ontology with grc the user also has the option to filter the term assignments based on go evidence codes, term depth, and go category. evidence codes are a three letter code associated with a gene ontology annotation, which specifies a source of support category for a particular annotation. although currently the vast majority of evidence codes for prokaryotic annotations are 'iea', inferred by electronic annotation, we expect this feature to be useful as the number of experimentally derived annotations and the complexity of the evidence code system increases. the user also has the option to specify which go categories to use in making annotations .

a problem encountered in transferring function is deciding which function to use when there are multiple high-scoring alignments. grc's default practice is to transfer the function of the database sequence whose alignment best fits the orf sequence. however, just because a subject sequence is most similar to the target gene does not guarantee that it is well annotated and is the best candidate for functional transference, e.g. transferring a function from a 98% identical sequence experimentally determined to be glucokinase may be preferable to transferring the term "hypothetical" from a 99% identical sequence. if the user specifies a minimum go term depth, terms associated with the source subject, that pass the depth restriction, are assigned. if none of the go terms from the source subject meet all the filtering criteria then go terms are assigned from another subject that has the highest a score and go terms that do meet the criteria.

grc also has the option of generating go "consensus annotations." multiple, significant alignments, and their associated functions, can represent a net or distributed knowledge about the query sequence. in these cases, if only the top-scoring function is transferred, then the net knowledge is lost. we provide in grc a feature for capturing this net knowledge by creating go consensus annotations. consensus annotations are intended to leverage the information distributed across the go-dag from multiple alignments into term assignments which have a high level of evidential support. the assumption behind consensus annotations is that multiple alignments will indicate terms that occur in relative proximity to one another within the go-dag and that this proximity is indicative of either a protein family with similar function or a variation in function specifics for homologous sequences in the database. the goal is to capture the proximity, and subsequent agreement, of a group of terms through these go term assignments. similar algorithms have been developed in gomit  <cit>  and clugo  <cit>  but to our knowledge no publicly available implementation of these algorithms exist.

additionally, the user is able to specify a minimum percent coverage that the alignment must satisfy, for both the query and subject, in order to be used for function assignment. these options give a measure of control such that the annotation of an entire genome can be customized to a user's particular interests. the ability to fine-tune go term assignment in terms of go evidence codes, depth, and category, the use of consensus annotations, and the extensive information about functional assignment decisions contained in the output, together constitute a powerful functional assignment system not found to our knowledge in other automated annotation systems.

evaluation
also implemented in grc is a module that allows the user to evaluate the performance of the tool with respect to a reference annotation. one part of the module provides a detailed analysis of precision and sensitivity with respect to gene finding. the details provided are meant to act as the engine to drive open-source development of the grc and allow the user to easily evaluate the impact of his or her changes with respect to real organisms. this module also does automatic evaluation of function assignment.

output from this module allows the review of current annotations based on evidence found in the annotation process.

gene finding
evaluating the performance of gene finding requires both a reference set of gene coordinates, r, and a defined system of measurement. for the purposes of using metrics, all the coordinates provided in the reference set are assumed correct. we evaluate the correctness of gene calls with respect to the starting set m composed of those orfs found through a linear scan of the genome. this allows us to frame the gene finding problem for the grc as one of classification. given the set m, label each orf in m as either coding  or non-coding . this leads to the following evaluation with respect to the reference set: every gene coordinate pair in set p is either a true positive , a false positive , or has no reference , and every coordinate pair in n is either a true negative  or false negative .

true positive : an orf in set p that is in the same frame and has the same stop site as a gene in set r

false positive : an orf in set p that occupies the same space as a gene in set r but does not meet the conditions for a tp

no reference positive : an orf in set p that does not occupy the same space as any gene in set r

false negative : an orf in set n that is in the same frame and has the same stop site as a gene in set r 

true negative : an orf in set n that does not meet the conditions for a fn

when using the grc, the user must specify the minimum gene length. this is the minimum nucleotide length for gene finding, which means all putative genes returned by the grc will be greater than or equal to this number. genes in r that are shorter than the minimum gene length specified are not counted as false negatives.

when measuring the performance of gene finding with respect to a reference, we wish to answer the following:

• how many of the genes in the reference set did we find ?

• out of the orfs we asserted as being protein coding, how many were correct?

• and out of those correct, how many also had correct start site coordinates?

we can answer each of these questions with the following measurements:

 sensitivity or recall=tptp+fn 

 precision or accuracy=tptp+fp+nrp 

 start precision=tpstp+fp+nrp 

where tps = the number of true positives which have a correct start coordinate.

functional assignment
in testing function assignment, we wish to measure the number of genes we assign a correct function to and, because one gene can have multiple functions, the total number of functions correctly assigned. without a system for formal functional classification, testing function assignment can be difficult.

comparing plain text functional descriptions will result in measuring the number of common keywords and trying to ensure that they do not convey a common biological phenomena with little meaning, e.g. "protein." to address this problem we use the gene ontology, which allows us to devise a more precise system for measuring function assignment performance. this system assumes that there exists a reference annotation that specifies the most specific go terms detailing the functional characteristics of each gene in the test genome. goa formatted files from embl's integr <dig> project  <cit>  and the gene ontology website  <cit>  are freely available and provide this information.

let t be the target gene whose functional assignment correctness we wish to determine. let r be the reference gene whose function we wish to compare t to. there are three conditions which must be met before we can evaluate whether the function assigned to t is correct:

 <dig>  t must be a true positive in gene finding with respect to the reference gene r.

 <dig>  t must be assigned a go term as a result of the blast search.

 <dig>  r must also be assigned a go term from the same go category as t.

assuming these conditions are met, we then assign a label to each go term that has been assigned to each tp orf in the result set p . a term assignment is labelled confirmed if it coincides with or is the ancestor of a reference go term belonging to r. a term is labelled compatible if it has as its ancestor one of the specific go terms assigned to r. these represent potential refinements of the current annotation of the gene. a term is labelled incompatible if it does not meet the requirements to be labelled confirmed or compatible. these terms only share a common ancestor with the terms listed for r. incompatible term assignments are not necessarily incorrect. the relevance of this evaluation depends on the correctness and completeness of the reference go term assignments. if an evaluation of "incompatible" results from comparison to a complete  and correct reference annotation, then the incompatible assignment is likely incorrect. if, on the other hand, there is a relevant go term missing in the reference annotation, then there is a chance that the grc assigned term might be accounting for this missing information. for the purposes of grc evaluation  incompatible assignments are considered incorrect.

architecture
grc is comprised of multiple components, each of which can be used independently from the annotation pipeline . grc_orfs takes a genomic sequence and finds all orfs of maximal length. these sequences are redirected to grc_translate which translates the nucleic acid sequence into amino acid based on the translation table specified. using the translated sequences as queries, fsa-blast performs a sequence similarity search against a user-specified database in order to identify conserved sequences and provide putative functions. grc_annotate takes blast results, and adjusts starts, assigns function, and gives putative protein coding genes as its output.

the algorithms comprising the grc are implemented in c++ and perl. the source code is available to download under the gnu license and comes packaged with precompiled binaries on an intel × <dig> linux machine. running the software requires only that the user have standard installations of g++, perl, and make on a linux operating system.

we provide an additional component that can be used to easily evaluate the performance and decisions made by the grc. grc_compare takes as input the output from grc_annotate and a reference annotation for the genome annotated. it provides an evaluation of the gene finding as well as functional assignment.

the grc is run from the command prompt. annotating a genome is as simple as specifying the files that contain the genomic sequence and the functionally characterized sequences from one or a number  of closely related organisms. we support several major formats from both ncbi and embl.

example for running the grc:

grcv <dig> .pl -g genome.fna -d databasedirectory

because the grc can take advantage of multiple sequence alignments in gene finding, determining start site position, and making functional assignments, the user also has the option to specify the number of top blast hits to use.

the output provided by the grc increases with the amount of information provided by the user. at base level grc provides both a list of putative protein coding genes and a list of orfs, generated by grc orfs, hypothesized not to be protein coding. these lists provide the following for each orf:

 <dig>  highest scoring alignment values.

 <dig>  entropy distance ratio for the sequence.

 <dig>  assigned functions and associated confidence values.

 <dig>  gene coordinate information.

this level of output requires only the genomic sequence and fasta-formatted amino acid sequences for the annotation database. in this case, the functions assigned are merely the plain text descriptions obtained from fasta headers. if the user provides additional functional information in the form of go annotations, these will be combined with the sequence information to provide go term assignment.

RESULTS
we test the performance of the grc using leave-one-out genome annotation. for a group of related organisms, all with pre-existing annotations, each organism is annotated by the grc using the sequences and functional descriptions from the rest of the group. performance information is then generated using grc_compare to compare the grc's annotation to that of the target organism.

in gene finding it is common practice to specify a minimum gene length  <cit> . any sequences under this minimum are ignored. as the minimum gene length decreases more candidate sequences are generated from a linear scan of the genome. this increased number of sequences results in increased computation time and a higher degree of difficulty in choosing which are actually protein coding genes. gene finding results were generated over a range of minimum gene lengths  at  <dig> bp increments. all sequences and gene coordinate information were obtained from ncbi's refseq repository  <cit> .

for each annotation the grc was set using the following parameters:

• number of blast hits to use per query = 10

• blast e-value threshold = .001

• effective blast database size =  <dig> 

• blast scoring matrix = blosum62

to provide a frame of reference, we compare the grc's performance to the popular gene finding program glimmer v <dig>   <cit> . glimmer was tested using the same procedure and reference files as the grc. it should be noted for this comparison that many of the prokaryotic annotations in the refseq repository may have been generated using glimmer. indeed refseq even provides glimmer output files for various organisms. glimmer was run using its iterated procedure in which it uses the sequences from the first run to create a training set for the second run. this also allows the glimmer method to build a position weight matrix for the ribosomal binding sites and for the estimation of start-codon usage in the genome. for each run of glimmer the default parameters were used. only the minimum gene finding length was changed.

glimmer parameters:

• maximum overlap = 50

• score threshold ≥ 30

in order to test functional assignment, we use gene ontology terms. the go annotations are used as both database functions to be assigned and as reference functions. currently, there are relatively few well curated go annotations for multiple closely related organisms. we obtain each organism's go annotation from embl's intergr <dig> project  <cit> . these go annotations are created through "a mixture of manual curation, and automatic inference from other annotations such as interpro hits, uniprot keywords, and enzyme commission classification  <cit> ." in testing functional assignment, we performed annotations using a minimum gene length of  <dig> bp.

test cases
we test the grc on three groups of bacteria with varying levels of relatedness. group  <dig> is composed of different strains of the species e. coli, group  <dig> from members of the genus pseudomonas, and group  <dig> from members from the class gammaproteobacteria . in terms of the tree of life, both groups  <dig> and  <dig> are fairly specific and represent an availability of closely related sequences which may be lacking in some newly sequenced genomes. in all three groups we use only the primary replicon for testing the annotation capability of grc.

test groups for leave-one-out genome annotation. there is a gradation in phylogenetic distance, from closest in the e. coli group to the most distant in the gamma group.

performance
using leave-one-out annotation, we test gene finding at minimum gene lengths of  <dig>   <dig>   <dig>   <dig>  and  <dig> bases. for both the e. coli and pseudomonas groups grc performs well with respect to the reference files, having average values in the  <dig>  –  <dig>  range for both sensitivity and precision . relative to glimmer, grc typically performs within a  <dig> percent margin for the sensitivity and precision measurements in the first two target groups. as seen in figure  <dig>  grc tends to be more precise than glimmer at shorter minimum lengths, but with slightly lower sensitivity. grc is also able to consistently perform well with respect to determining the correct start site . grc places heavy emphasis on sequence similarity information. as expected the precision and sensitivity with which genes are predicted, and start sites are determined, decreases as the phylogenetic distance between each member of the group increases. although the gamma group was distantly inter-related, grc was able to achieve precision and sensitivity in the ninetieth percentile for the majority of the annotations. it is assumed that performance will continue to decrease, similar to many similarity based methods, as the relationships between the target sequences and those in the annotation database grow more distant. great care should be taken when choosing the organisms and annotations that will make up the annotation database. any comparison of grc to an ab initio gene finder can be deemed inappropriate since grc takes advantage of prior knowledge in making its predictions. in this case we simply wish to demonstrate the viability of a similarity based genome annotation and that grc, despite being an explorative annotation tool, has the ability to perform satisfactory gene finding for a variety of organisms.

regarding the results presented in figure  <dig> it is important to note the following. as stated above, for the purposes of this evaluation  we have not counted as false negatives the reference genes that are shorter than the minimum gene length. note that the lowest threshold  means protein sequences as short as  <dig> aa. very few bona fide bacterial genes are shorter than that. in our tests, we verified that the e. coli group has on average  <dig>  genes shorter than  <dig> bp, the pseudomonas group has  <dig> , and the gamma group has  <dig> . the precision results in turn are affected by our concept of no reference positives . if the nrps were not taken as false positives our precision results would be better than those shown in figure  <dig>  as examples, using  <dig> bp as minimum gene length, and for the genome e. coli w <dig> the count of nrps is 240; for the genome p. syringae pv. tomato strain dc <dig> the count of nrps is  <dig> .

given the functional assignment performance evaluation method we have established using go terms, there are two ways to measure the quality of a grc annotation. one is to compare the fraction of orfs that have functions correctly assigned  versus the fraction that have functions that could be incorrect . the other is to look at the total number of terms correctly assigned. figure  <dig> shows that the average fraction of orfs with correctly assigned functions is far greater than the fraction that may have incorrect assignments. because a single orf can have multiple go terms, there may be tp orfs that are counted as having confirmed, compatible, and incompatible term assignments.

number of terms for each go evaluation classifier. only tp orfs that have "verifiable" terms can be evaluated. depth and distance are averaged over all term assignments for each organism.

it is possible for a confirmed or compatible annotation to be trivial in that the term assigned has no functional specificity e.g. assign the molecular function term. the depth and distance information in table  <dig> shows that for the majority of term assignments this is not the case. as the phylogenetic relationships of an annotation group grow more distant the number of verifiable terms and confirmed terms decreases. full tables of all go analysis statistics can be found in the supplementary material .

term assignments labelled incompatible do not necessarily mean the assignment is incorrect. for instance, in the annotation of pseudomonas pha1448a, a protein known to be part of tryptophan synthesis  was assigned the term go: <dig> by grc. this is a biological process term defined as "amino acid biosynthetic process." because protein q48qg <dig> was already assigned a biological process term for tryptophan metabolic process  in the reference annotation, and that term was neither an ancestor nor child of the one assigned by grc, the assignment was labelled incompatible. also interesting to note, is that the number of compatible annotations increases as the groups become more distantly related. these annotations could be improvements on the current annotation but are also likely to include some incorrect functional assignments.

with a carefully selected annotation database the user can annotate a genome of interest in a few hours. the main bottleneck in the annotation procedure of grc is the sequence similarity comparison. blast is known to scale in proportion to the product of the lengths of the query sequence and the database searched  <cit> . in figure  <dig> we show the total run time of the grc in relation to the product of the total query and database sequence lengths for each organism across all test groups and minimum lengths. the average total running time for all non-blast components of the grc is  <dig> seconds with a standard deviation of  <dig> seconds. the total run time for non-blast components scales according to the amount of information available for each organism, e.g., the number of orfs and the number of alignments. all times were obtained on a desktop computer with a  <dig>  ghz processor and  <dig> gb of ram.

as noted in the introduction, there exist genome annotation services available, most notably rast  <cit> . although the goals of these services and those of grc are essentially the same  the approaches adopted are quite different. annotation services are centralized whereas grc is a tool to be used locally and even tuned in different ways by different users. in spite of these differences we provide a comparison of the annotation results of grc to those of rast for escherichia coli str. k <dig> substr. w <dig> and pseudomonas syringae pv. tomato str. dc <dig>  in table  <dig> we show the performance of rast compared to grc for making gene calls. we also provide a comparison of the go terms given in the rast annotation to that of grc . the performance of rast is determined by using files from embl's integr <dig> project  <cit> . although the primary form of annotation for rast is not gene ontology terms, we demonstrate that the system we have established can be used to characterize the state of functional annotations on a genomic scale beyond simply listing the differences that exist. we also take the opportunity to note that the results presented above show that grc can run in a matter of a few hours on a standard desktop computer, whereas rast takes anywhere from one day to three days.

the performance of gene finding for rast and grc. the precision, sensitivity, and fraction of gene calls that have correct start sites for escherichia coli str. k <dig> substr. w <dig> and pseudomonas syringae pv. tomato str. dc <dig> .

the performance in making go annotations for rast and grc. the number of true positives that have go terms for the reference and the called gene are tp-verifiable. the number of go terms found to be confirmed, compatible, and incompatible and the average depth for those terms.

CONCLUSIONS
in grc we have created a reliable, open-source, annotation tool which can be used for explorative annotation to investigate a genome based on the users interests. by supporting commonly available sequence and annotation formats, we provide a tool that puts very little demand on any user wishing to annotate a prokaryotic genome. grc synthesizes information from both sequence composition and sequence similarity to minimize the deficiencies inherent in using just one. using standards from ncbi refseq  <cit>  grc has demonstrated high precision and sensitivity in gene finding for groups of closely related prokaryotes. grc's modular design and generic use of sequence similarity information for functional assignment and annotation means that it can be easily adapted to fit within other annotation pipelines. grc was the automated annotation tool used in the pseudomonas syringae pathovar tomato strain t <dig> genome project  <cit> . for this project researchers relied on the fact that grc can use any user-provided protein sequence database; a custom database of effector protein sequences was used, and this was essential for the project's goals.

when predicted computationally, gene calls, start coordinates, and assigned functions should be taken as highly tentative until they have been curated and approved by an expert human curator. predictions made by grc are no different. although grc achieves high performance values with respect to two test groups, these groups are close phylogenetically. as the relationships between the organisms in the database and the target genome become more distant so will the applicability of annotations made by grc. it should also be re-emphasized that the functional performance metrics were generated using reference functions  that were themselves electronically created. ideally all reference information used to measure the performance of grc should be experimentally derived. because the grc effectively transfers information from one organism to another, mistakes in database annotations can be propagated into a new annotation created by grc. the confidence values, alignment information, and many of the other values output by grc are provided so that the user can evaluate whether a gene call or functional assignment merits further investigation. these values do not provide any kind of guarantee that an in silico prediction will be a biological reality.

work on grc is ongoing. we are currently working on the following aspects. rna annotation. rna genes and features are important pieces of information in any prokaryotic genome. the fact that rnas are usually well conserved in closely related species should make it relatively easy to include them in grc annotations, although locating precise boundaries may be difficult. better use of user-provided data. there are two main issues here. the first is the presence of experimentally derived functional assignments; those should be given preference in functional transfer, and are easily detectable in go annotated genomes by the evidence code. the second is a user-defined special reference genome. it is often the case that among several closely related genomes there is one that is especially well annotated. for example, among pseudomonas syringae, strain dc <dig> is by far the best annotated. if users provide such information, grc can be modified to make use of it and thus produce better annotations. metagenomics annotations. an explorative annotation tool is in theory ideally suited for annotation of metagenomics sequences. in order for grc to be useful in such a context a user would have to provide a blast database that would cover a wide range of prokaryotic species. this is not a simple task, and therefore we are planning to develop techniques that will allow the generation of a reasonably small approximation of a nonredundant and yet comprehensive set of well-annotated prokaryotic proteins.

availability and requirements
project home page: 

operating systems: linux

programming languages: c++ and perl requirements: linux, g++, perl, make

license: gnu general public license. this license allows the source code to be redistributed and/or modified under the terms of the gnu general public license as published by the free software foundation. the source code for the application is available at no charge.

any restrictions to use by non-academics: none

authors' contributions
aw contributed the bulk of the writing for this work, is the main programmer for the project, conceived many of the performance measurement techniques, and various other software features. js conceived the initial grc project idea, provided funding and guidance for this work, and has contributed to the interpretation of data and writing of the manuscript. both aw and js have read and approved the final manuscript.

supplementary material
additional file 1
supplementary data. full performance tables for gene finding and go analysis for each organism.

click here for file

 acknowledgements
we thank the authors of fsa-blast for making a their software freely available. we also thank chris lasher, tsai-tien tseng, and nalvo franco de almeida for their valuable feedback.
