BACKGROUND
ecologically linked groups of organisms often place selective pressures on one another driving the evolutionary process  <cit> . these selective pressures give rise to tightly coupled coevolutionary systems. coevolution occurs in a wide variety of biological systems including host-parasite relationships  <cit> , mimicry between species  <cit> , biogeography  <cit> , insect-plant interactions  <cit> , host-pathogen networks  <cit> , and predator-prey systems  <cit> .

the study of the macro scale coevolutionary associations  formed between the host and parasite phylogenies is encompassed by the field of cophylogenetics  <cit> . analysis of these systems can be applied to tackle some of the most pressing global health issues facing society today  <cit> . coevolutionary analysis of systems such as primates and malaria-causing plasmodium  <cit>  offer the potential to provide further insights into this deadly disease. although encompassing a large number of biological scenarios each coevolutionary system consists of an independent evolutionary history often refered to as the host phylogeny and its corresponding dependent evolutionary history known as the parasite phylogeny  <cit> .

cophylogenetics aims to provide such insights by evaluating the significance of the observed associations  between the host  and parasite  phylogenies and the branching patterns between h and p to identify if these ecologically linked organisms have formed deep coevolutionary bonds or if their evolutionary histories are independent  <cit> . the host and parasite phylogenies considered herein are bifurcating trees where the total number of nodes for both trees is bound by o. therefore, cophylogenetics aims to analyse and understand the tuple , often visualised as a tanglegram  <cit>  as seen in figure  <dig>  as a result, the complexity of this problem is bound in terms of n, the size of h and p .

a common method for evaluating the tuple  is cophylogeny mapping where the parasite tree is mapped into the host tree such that the associations  are conserved. a cophylogeny mapping ) estimates the parasite's evolutionary history with respect to its host using the four recoverable coevolutionary events of codivergence, duplication, host switch and loss.

a codivergence event is a concurrent divergence of both a host and parasite species  <cit> . a duplication event, by contrast, is an independent divergence of a parasite species. following this divergence event both new parasite species continue to track their initial host  <cit> . a host switch, similar to a duplication event, is an independent divergence of a parasite species. in contrast to a duplication event, however, one of the new parasite species switches to a new host while the remaining parasite species continues to inhabit the initial host  <cit> . a loss event represents one of three possibilities: failure to diverge by the parasite species following a divergence event by its host, an extinction event of a parasite species or sampling error in the phylogenetic reconstruction of the parasite phylogeny  <cit> . these four events when applied together are capable of recovering the full set of mappings possible where each parasite may only inhabit a single host. this is the permutation of the cophylogeny reconstruction problem which is considered herein. an example of all four recoverable events applied to solve a simple tanglegram can be seen in figure  <dig>  the aim when recovering a cophylogeny mapping is to retrieve a solution where the resultant cost is minimised. the set of all mappings with a minimum cost are contained within the pareto set  <cit> . the cophylogeny reconstruction problem is defined as the problem of reconstructing a map from the pareto set where the mapping cost is minimised, which has been established as np-hard  <cit> , which has in turn given rise to a number of heuristic approaches. currently there are two classes of heuristics, pattern and event-based methods. event-based algorithms have been shown to be the only approach that can guarantee recovered solutions are optimal  <cit> . ronquist  <cit> , however, has argued that pattern-based algorithms can produce robust approximations that can be as good as event-based methods which impose constraints upon the solution space. imposing constraints is required due to the computational intractability of this problem, and therefore pattern-based methods have the potential to offer comparable precision to event-based methods. an existing pattern-based approach is page's reconciled tree analysis  <cit> , which solves this problem optimally with the condition that host switches are not permitted. this algorithm recovers a pareto optimal solution in o. this approach, while recovering an optimal solution, is unable to recover solutions which accurately represent coevolutionary interactions where host switch events are prevalent, such as host-pathogen systems or where closely related parasites infect distantly related hosts. another well known pattern-based method is brooks parsimony analysis   <cit> . this method uses a binary coding representation of the parasite phylogeny and uses this binary coding to map the parasite into the host. this method has been shown to produce good solutions  <cit>  but has not yet been implemented due to inconsistencies in the selection of events and the ordering of nodes in the host phylogeny.

due to the limitations faced by both these approaches, pattern-based algorithms are not often applied to this problem, with the majority of recent cophylogenetic analyses using event-based methods  <cit> . approximating this problem using event-based methods aims to recover cophylogeny mappings where the global score is minimised. this approach is based on ronquist's generalised definition of the cophylogeny reconstruction problem, which states that only by minimising the total cost of all events can an algorithm recover a pareto optimal reconstruction  <cit> . two recent algorithmic approaches that have leveraged this generalised definition apply dynamic programming to modified instances of the cophylogeny reconstruction problem. the first approach ignores the relative ordering of the internal nodes of the host tree and the second approach fixes the relative order of the internal nodes of the host tree.

by ignoring the relative order of the internal nodes of the host tree the cophylogeny reconstruction problem can be solved in polynomial time. this approach is derived from a heuristic used to approximate the feedback arcs set problem which is also np-hard  <cit> . tarzan  <cit>  and core-pa  <cit>  apply this technique to recover cophylogeny mappings in polynomial time. this approach is currently the fastest known approach for recovering solutions where all four recoverable events are permitted with the fastest proposed algorithm running in o  <cit> .

an unfortunate consequence of ignoring the relative order of the internal nodes of the host tree is that recovered mappings may be time-inconsistent  <cit> . a time-inconsistent solution is the case where the order of the parasite divergence events contradicts the order of the internal nodes in the parasite's phylogeny and as a result the coevolutionary history of the parasite contradicts its phylogenetic history. a mapping that is time-inconsistent is biologically infeasible  <cit> . such a mapping can be seen in figure  <dig> 

to overcome the limitation of potentially reporting time-inconsistent solutions libeskind-hadas and charleston  <cit>  proposed an algorithm where the relative ordering of the host phylogeny's internal nodes is fixed and each internal node is assigned a unique distance from the root. under these conditions the cophylogeny reconstruction problem can be solved in polynomial time and the solutions recovered are guaranteed to be biologically feasible. the initial algorithm proposed required o running time  <cit> , which significantly limited its applicability as it was unable to converge on good solutions for large problem instances. subsequent solutions significantly reduced this running time with edge mapping  <cit> , improved node mapping  <cit> , and slicing  <cit> , all running in o.

although polynomial time algorithms exist for solving the case where the internal nodes are fixed, the number of internal node orderings increases exponentially for every internal node added to a bifurcating tree. therefore, such algorithms rely on a metaheuristic to iterate through the exponential number of internal node orderings. this approach has been shown to be successful, with software tools such as jane  <cit>  converging on solutions for coevolutionary systems with up to  <dig> taxa  <cit> .

cruaud et al's analysis  <cit>  demonstrated the value of coevolutionary analysis of larger phylogenetic histories and also highlighted the need for further research of large scale coevolutionary analysis. the use of algorithms such as those implemented in jane, however, are not feasible in all cases. consider the coevolving system of wolbachia and their insect hosts. it is currently estimated that 20% of all insect species are inhabited by wolbachia  <cit> , and that the estimated number of insects is approximately  <dig> million  <cit> . such a problem instance represents a  <dig> times increase in the number of taxa compared to the largest system successfully analysed using jane. this is a significant increase in the complexity of the problem, especially when considering the exponential increase in complexity for every additional node added. this example demonstrates the need to develop further algorithms for the cophylogeny reconstruction problem, which while recovering biologically feasible reconstructions, are able to do so in sub o time.

this paper introduces a new greedy approach for solving the cophylogeny reconstruction problem where the internal node ordering is fixed. this algorithm is able to guarantee that all reported solutions are biologically feasible. further, this approach is tested on a combination of synthetic and real data sets and is shown to recover comparable solutions to existing o algorithms but with a significantly reduced running time of o.

methods
the algorithm proposed incorporates a number of techniques which have been successful in their own right for solving the cophylogeny reconstruction problem and utilises them in a novel manner to tackle the problem of recovering biologically feasible reconstructions for large coevolutionary systems. the algorithm referred to here as treecollapse applies a combination of both pattern and event-based reconstruction techniques, with the aim of producing a fast and scalable method for solving the cophylogeny reconstruction problem for the case where the internal node order is fixed.

this algorithm is then applied to a metaheuristuc framework similar to the dynamic programming algorithm leveraged by jane  <cit> . this research does not focus on improving the search strategies applied by the metaheurstic for traversing the exponential search space, but rather aims to minimise the time spent evaluating each instance. unlike the dynamic programming algorithm used by jane  <dig> and subsequent releases which requires an o  <cit>  evaluation step for each instance processed by the metaheuristic, treecollapse recovers a cophylogeny mapping in o. this allows treecollapse to evaluate o instances for each case evaluated by jane.

treecollapse is an extension of the pattern detection methodology first proposed by ronquist  <cit> . a significant change to ronquist's pattern detection framework is the leveraging of local pattern detection rather than ronquist's history classification technique  <cit> . the proposed pattern detection framework bounds the search space of each pattern to a constant size by considering only a constant number of cherries at each step. a cherry  is defined by mckenzie and steel  <cit>  as:

definition  <dig> in a bifurcating tree a cherry  is a pair of leaf nodes  each of which is adjacent to a common ancestor .

the proposed framework constrains all pattern detection to both o running time and search space, to maximise the number of unique internal host tree node orderings which can be explored in a fixed period of time. the result of the o bound on the pattern detection is the ability of this algorithm to construct cophylogeny mappings in o time and space, where all reported solutions are time-consistent; using the trade off that not all solutions recovered are from the pareto front.

local pattern detection
the proposed algorithm reconstructs a cophylogeny mapping based on patterns formed by cherries in both the host and parasite trees. the eight patterns used consist of four base patterns, as can be seen in figure  <dig>  which are used to recover the four recoverable events that can occur in a coevolutionary system. these patterns are derived from the history classification framework proposed by ronquist  <cit> . an additional four patterns have been included to improve this framework's performance at handling the complexity of host switch events. these hybrid patterns extend the initial base patterns to allow each hybrid pattern to detect two consecutive events. the hybrid pattern set consists of codivergence-switch, duplication-switch, loss-switch and double switch, all of which can be seen in figure  <dig>  by including these hybrid patterns this approach is able to more accurately recover host switch events, which results in a reduction in the total parsimony score. this is achieved by only considering an additional two cherries which is clearly still bounded by o. a further in-depth analysis on the accuracy improvements achieved by the proposed hybrid patterns is discussed as part of the results.

the patterns are detected for each cherry in the host tree by executing a depth first search. this algorithm is designed to traverse the tanglegram instance , starting at the leaves of the host cherry and terminating once a path is found back to a leaf in the host tree. to ensure that this algorithm runs in o, the number of levels which the depth first search algorithm may traverse through the parasite tree is fixed to a constant factor. once the algorithm has terminated, the resultant path found by the depth first search algorithm is compared to the permitted pattern set. this search algorithm is bound to o as there is a constant number of levels searched and the branching rate of a bifurcating tree is also constant. it is important to note that this is only one approach to implementing this pattern detection algorithm in constant time.

each pattern recovered by the local pattern detection algorithm gives rise to one or more cherries from the host or parasite trees to collapse, hence the algorithm's name treecollapse. this operation is based on a bottom up iteration technique, where the cherries in the host tree are sequentially processed based on their distance from the root. as a result, this algorithm continues until both trees consist of only a single node .

the treecollapse local pattern detection framework allows for three different collapse functions. the first case is where both a host and parasite cherry are collapsed, which indicates a codivergence event. the second case is where a cherry from the parasite tree is collapsed, indicating either a duplication or host switch event. finally, if no pattern is formed with the parasite tree, then a loss event is inferred and the host cherry is collapsed.

there are three possible final states when this process is performed to completion. first, the host tree and parasite tree are both collapsed up to their respective root nodes. in this case there is a codivergence event at the root of the host tree. the second case is where the host tree still has more than one node remaining after the parasite tree is completely collapsed. in this case we can ignore all remaining nodes in the host tree. finally, the case where the host tree is completely collapsed before the parasite tree results in the remaining nodes in the parasite tree being appended before the root of the host tree as duplication events. as treecollapse handles all three scenarios, it is capable of recovering solutions for all instances of the cophylogeny reconstruction problem.

guarantee that treecollapse recovers time-consistent solutions
treecollapse requires that each cherry in the host tree be processed in decreasing order based on the node's depth. depth is defined in this context as the distance to the root as the sum of the branch lengths. we will refer to the depth of a node a as d. to prevent timing inconsistencies, treecollapse requires that the edge weights in the host tree are set in such a way that each internal node's depth is unique and bound between  <dig> and , where the total number of the internal and leaf nodes in the tree is . this approach has been previously applied by dynamic programming approaches to ensure that recovered solutions are biologically feasible  <cit> . the n leaf nodes are then assigned to a common depth of . under such a construction we claim that:

theorem  <dig> the treecollapse local pattern detection and collapse framework ensures that no host switch event gives rise to time-inconsistent solutions.

proof by contradiction we show that all cophylogeny mappings reported by treecollapse are time consistent. let us assume treecollapse returns cophylogeny mappings that are time-inconsistent. for this to occur requires that there exists a cherry in the host tree ca which forms a switch pattern with another node in the host tree b where d < d as seen in figure  <dig> 

there are two cases to consider, where b is an internal node in the initial host tree and where b is a leaf in the initial host tree. the case that b is an internal node in the host tree requires the cherry for which b was previously a parent  to be collapsed before ca. this violates the condition that treecollapse must process the cherries in decreasing order based on the distance from the root, which is clearly not true if cb is processed before ca. alternatively, where b is a leaf node from the initial host tree is also invalid as the initial depths of all leaf nodes must be greater than the depth of all internal nodes, which is not true if d < d. therefore, as d ≮ d for all valid constructions of the host, we have proved theorem  <dig> 

this result can be extended to all hybrid patterns as they are each derived from the switch pattern and in all cases require that the cherry whose parent has the maximum depth is the next selected. enforcing this restriction, however, results in an approach that potentially over-counts the number of loss events. in the next section we introduce an o post processing algorithm that aims to counterbalance this result by minimising the number of loss events in the final reconstruction.

increasing accuracy further
while the treecollapse algorithm guarantees that all histories reported are time-consistent, it does not give such a guarantee that reported solutions have a minimum cost, as no algorithm to date has been able to achieve this in sub o time.

to further minimise the cost of the resultant solution, we propose a postprocessing algorithm called right push which follows after the treecollapse algorithm. this post-processing step aims to find the optimum switch placement for a cophylogeny mapping for a specific event order where the node ordering is also fixed. this is achieved by minimising the number of loss events without introducing time-inconsistencies. the aim of this post-processing step is to reduce the number of overcounted loss events which result from ensuring that time-inconsistent switch events do not arise during the pattern detection and collapse phase.

right push is a greedy algorithm which runs bottom up through the cophylogeny mapping ), shifting the host switch take-off and landing edges to the optimum position. the algorithm was named right push as traditionally host trees are drawn with their root on the left and their leaves on the right, as seen in figure  <dig>  and therefore this algorithm aims to pull host switch events towards the leaves, that is, towards the "right". a case where right push minimises the number of loss events can be seen in figure  <dig>  this algorithm selects the optimal take-off and landing edges, while ensuring the resultant solution is time-consistent by maintaining the the properties set out in definition  <dig> 

definition  <dig> suppose p ∈ Φ has children pleft and pright, with Φ = s and Φ = t. then the optimal host switch location is a pair of edges ei and ej ∈ e where the total number of loss events between  and between  is minimal, and where ei and ej lie in the same time interval.

this definition, based on prior work by drinkwater and charleston  <cit> , allows for the optimal take-off and landing edge for the host switch event to be recovered using the level ancestor problem  <cit> . consider the children s and t where d < d. under this definition, we use d as the search candidate using the level ancestor query function to find both ei and ej, which allows for the optimal host switch event to be recovered in o  <cit> .

the right push algorithm is therefore designed to iterate through a cophylogeny mapping ) consisting of o parasite nodes. for each parasite node mapped into the host corresponding to a host switch event, the take-off and landing sites are evaluated using the level ancestor problem to identify if a lower cost switch location exists. this evaluation check along with the host switch repositioning both run in constant time  <cit> .

by shifting the host switch to the optimal position within the current cophylogeny mapping the right push algorithm minimises the number of loss events while maintaining the order of the current set of codivergence, duplication and host switch events, which in turn ensures that the current mapping remains time-consistent. analysis of right push's impact on the accuracy of the treecollapse framework is discussed in detail as part of the results.

complexity analysis of treecollapse
the previous sections describe two algorithms which have been applied together to provide a novel greedy algorithm to solve the cophylogeny reconstruction problem. in this section we prove that the running time complexity of both these algorithms is in fact o. to assist with the complexity analysis, we define the number of nodes in the host tree to be o and the number of nodes in the parasite tree to be o, with the total number of nodes in both trees being o, which is consistent with existing complexity analyses in this field  <cit> .

to compute the complexity of treecollapse's local pattern detection algorithm, we will break the process into three stages: firstly, setting and storing the order of cherries to process, secondly, processing each cherry, and finally, the iteration over all current and future cherries in the host tree.

the first step in the treecollapse algorithm requires the generation of a list of current and future cherries in the host tree, which are sorted in descending order based on their distance from the root. generally sorting such an unordered list requires a running time of o. in this case, however, we can use certain properties of the fixed node orderings to show the following:

lemma  <dig> a list of current and future cherries in the order they will be processed can be constructed in o, where the number of nodes in the host tree is o.

proof the input to this algorithm is a host tree where each of the internal nodes have a set of unique indices . therefore, this step reduces to creating a list of current and future cherries. our first step is to recursively set the distance to the root for each node which is well established to take o. using this result we can then construct an ordered list using a bucket sort where the number of buckets required is bounded by the number of unique depths in the host tree, o. therefore, as the number of the buckets is bounded by o the running time of the bucket sort also runs in o  <cit> .

the second stage requires the uncovering of all patterns for each cherry ci, of which there are up to o, as there is a pattern for each node in the parasite tree. we consider two possible approaches to process these patterns. the first, a brute force approach, is to uncover all possible patterns for each event processed. this method requires o time to process all the events for the cherry ci. an alternative approach is that for each cherry ci, all patterns recovered are stored as a list of patterns to be processed. if ci is collapsed before this list of patterns is processed then this list is allocated to its parent for subsequent processing. this approach, unlike the previous brute force method, requires that each pattern only be uncovered once for each node, and that the list of o patterns is sequentially processed. if the second approach is applied we can prove the following:

lemma  <dig> the number of patterns formed at each node in the host tree is okm

proof by only recovering each pattern once the running time to detect all possible patterns for each node is reduced to o to process each cherry ci. this running time can in fact be reduced further to okm as the average running time for each internal node. this can be verified by considering the number of nodes in the parasite tree. each pattern formed by a parasite tree cherry requires at least three nodes. of these three nodes only one of these will be reused once the cherry is collapsed. as each cherry can only apply one pattern, then the total number of patterns which can be formed by the parasite tree is o. therefore, the average number of patterns formed for each internal node on average is okm, even if it is possible for a single cherry in the host tree to have up to o patterns.

lemma  <dig> and lemma  <dig> give rise to the following result:

lemma  <dig> the running time of the treecollapse algorithm is o

lemma  <dig> establishes the running time required to process each cherry ci in the host tree. from lemma  <dig> the time required to construct a cophylogeny mapping of the initial problem instance can be derived as om×km+m=o, where k is the running time required to map the parasite tree into the host tree and m is the time taken to collapse any sections of the host that do not share a common coevolutionary history with the parasite tree.

the running time of treecollapse is also dependent on the running time of any post processing algorithms. as a result the running time of right push is required to establish the overall computational complexity of the treecollapse algorithm. we claim that the running time of right push is as follows:

lemma  <dig> the running time of the right push algorithm is o.

proof the right push algorithm is designed to iterate over the cophylogeny mapping ). this requires iterating over a list of size o. at each step the mapping instance is evaluated using the query function of the level ancestor problem. the result of this query is used to update the mapping, minimising the number of loss events in the current reconstruction ordering. the running time of a query made to the level ancestor problem is known to run in o, when pre-processing has been applied to the query tree  <cit> ; in this context, the host tree and updating the new location is an o assignment operation.

therefore, the right push algorithm runs in o + o. the preprocessing step for right push is the complexity of the pre-processing step of the level ancestor problem. this has previously been shown to be bounded by the size of the query tree  <cit> , which in this context is the size of the host tree o.

therefore, based on lemma  <dig> and  <dig> the running time of both treecollapse and right push is bounded by o. as n = k + m we immediately get:

theorem  <dig> the running time of the treecollapse's local pattern detection framework and the post-processing algorithm right push is bounded by o.

corollary  <dig> therefore, as the space complexity of any algorithm is bounded by its time complexity, the space complexity of treecollapse's local pattern detection framework and the post-processing algorithm right push is also bounded by o.

applying an approximation algorithm
treecollapse and right push are algorithms designed to solve the special case of the cophylogeny reconstruction problem where the internal node order in the host tree is fixed. therefore, treecollapse, similar to previous algorithms leveraging this technique, is embedded in a metaheuristic framework as a means to recover the minimum cost reconstruction.

we apply a genetic algorithm to iterate over the exponential number of node orderings. this approach was selected over other metaheuristics, such as particle swarm optimisation  <cit>  or ant colony optimisation  <cit> , due to genetic algorithms' proven success for this particular problem  <cit> .

the chromosomes of the genetic algorithm represent each internal node within the host tree, with the exception of the root which always has a depth of  <dig> . the depth range  allocated for each internal node is bounded by the number of ancestor nodes between the current node and the root , and the total number of internal nodes minus the number of descendants between the current node and its leaves . therefore, i and j are constant values for all instances processed by the genetic algorithm.

following the allocation of depths for these chromosomes, an o validation step defined by conow et al.  <cit> , is run to ensure that the numerical ordering does not violate the topological ordering. this ensures that all internal nodes are assigned unique node depths between  <dig> and , and that all leaves are assigned a timing of .

the genetic algorithm's fitness function promotes minimum cost reconstructions based on the jungle event cost scheme  <cit> . under this cost scheme codivergence events are assigned a cost of  <dig>  while duplication and loss events are assigned a cost of  <dig>  and host switch events are assigned a cost of  <dig>  representing that a host switch is made up of a duplication followed by a switch. this fitness function was selected as it best represents the default cost functions of existing tools such as core-pa  <cit> , jane  <cit> , and improved node mapping  <cit> . we note, however, that any cost scheme may be used.

RESULTS
we evaluate the treecollapse algorithm in three stages. the first stage evaluates the improvements offered by the newly proposed hybrid patterns compared to the four base patterns derived from ronquist's previous work along with the improvement in accuracy provided by the post-processing algorithm right push. the second stage aims to establish a baseline measurement of treecollapse's performance by comparing its accuracy with two polynomial approximation algorithms for this problem. in the third stage treecollapse is compared to well established dynamic programming algorithms for approximating the cophylogeny reconstruction problem to identify the accuracy trade off required to produce a linear time algorithm for the fixed node ordering permutation of the cophylogeny reconstruction problem. in each of these stages a combination of synthetic and real data sets are used to evaluate treecollapse's performance.

the synthetic data applied for this analysis was constructed under a yule process  <cit>  for a previous study using core-gen   <cit> . of the  <dig> synthetic coevolutionary systems,  <dig> were removed as they included at least one tree with only a single node, which cannot be processed correctly by some of the software tools included in this analysis, e.g. jane. as a result, the synthetic data applied in this study consisted of  <dig> instances.

the real data sets used for this analysis consist of  <dig> previously published data sets. these test cases cover the full spectrum of coevolutionary instances including pathogens and their hosts  <cit> , mutualistic coevolution  <cit> , plant-insect interactions  <cit> , mimicry between species  <cit> , plant-fungi relationships  <cit> , biogeography  <cit> , and host-parasite systems  <cit> . further information on each of these data sets is provided in additional file  <dig> .

this evaluation compared cophylogeny mappings based on their resultant parsimony score. this score was derived using the jungle cost scheme  <cit> , consistent with previous algorithmic evaluations in this field  <cit> . for the pattern-based methods, this required a post processing step to evaluate the total cost. for event-based methods the jungle cost scheme was applied to the algorithm itself.

as a further evaluation step the topology of treecollapse's reported mappings were compared with the results of the existing algorithms to identify the similarity of the mappings produced by each method. this evaluation acts as a further benchmark to evaluate how closely the newly proposed algorithm converges on the mappings recovered by these well-established algorithms. this includes an in-depth analysis of a coevolutionary system which is of particular importance to human health, i.e. primate-malaria  <cit> ; where core-pa, jane and treecollapse each recover a unique topological mapping.

evaluating treecollapse's patterns
this research builds on ronquist's original hypothesis, that pattern-based algorithms provide an effective approximation for the cophylogeny reconstruction problem. to evaluate each pattern's additional contribution, treecollapse was run where the pattern detection framework consisted of the initial four base patterns plus a single additional hybrid pattern, with the aim of identifying the benefit provided by each new pattern in isolation.

the results for this analysis over both the synthetic and real data sets can be seen in table  <dig>  the synthetic data highlights that all additional patterns in isolation decrease the total parsimony score and that the four hybrid patterns combined provide a significant decrease to the overall parsimony score of  <dig> % on average. of note, however, is that the individual contribution is not directly proportional to the reduction achieved when they are all applied. the results for the real data set show a similar trend with the exception of the duplication-switch pattern, which indicates a slight increase in the total parsimony score. while this increase exists, the parsimony score when all four hybrid patterns are combined is reduced  <dig> % on average, even further than the results achieved over the synthetic data set.

based on the prior result and the inconsistent results surrounding the duplication-switch pattern, a more in-depth analysis was undertaken. this led to an individual analysis of each coevolutionary instance to identify whether any benefits were provided by the duplication-switch pattern to test whether if it should be removed from the treecollapse framework. to achieve this result each real data set instance was evaluated in terms of their distance to the pareto front. it was confirmed that while removing duplication-switch improves the total resultant parsimony score , the number of solutions that lie on the pareto front was reduced from  <dig> out of  <dig>  to  <dig> of  <dig> . as recovering pareto optimal solutions is key, the duplication-switch pattern was retained as a default pattern within the pattern detection framework. this result, however, highlights that further work can be undertaken in both detecting other effective patterns to apply in this framework and also that pattern classification based on the particular coevolutionary instance may provide an even more robust method.

overall, this analysis demonstrates a significant decrease in the parsimony score recovered by treecollapse compared to those only using the base patterns. when the results of both the synthetic and real data sets are averaged such that each group is weighted equally, it can be seen that the four hybrid patterns provide a decrease in the parsimony score of  <dig> %. this is a significant result considering this is achieved without any increase in the computational complexity of the algorithm.

improvements provided by right push
to evaluate the impact of right push, treecollapse was run with and without right push enabled. we show that across both data sets right push offers an average decrease to the parsimony score of 6%, without any additional increase in the computational complexity.

when comparing the total parsimony scores for synthetic and real data sets , it can be seen that there is a  <dig> % and  <dig> % decrease in the total parsimony score respectively when right push is enabled. this result provides strong evidence of right push's ability to minimise the total parsimony score. this result also demonstrates the potential that the right push algorithm may offer to other greedy algorithms which apply pattern-based methods to recover cophylogeny mappings. further, while the reduction of  <dig> % using patterns was achieved using all four possible events, the 6% improvement offered by right push is achieved by only reducing loss events.

the evaluation is run on both synthetic and real data sets.

establishing a baseline
before comparing treecollapse against the current methods for cophylogenetic reconstruction, we compare treecollapse to two polynomial time approximation algorithms which provide a baseline for treecollapse's performance. these algorithms include page's reconciled tree analysis and edge only mapping.

page's reconciled tree analysis recovers a pareto optimal solution which can also be found by treecollapse in the case where host switch patterns are ignored. page's reconciled tree analysis recovers this mapping in linear time as the order of internal nodes does not impact on the final solution as host switch events are not considered.

the second method allow for only host switch and duplication events  and is able to achieve a cubic running time by avoiding the computational complexity of internal node orderings. this is achieved by reconstructing a cophylogeny mapping bounded by the final timing interval  of the host tree. a mapping bounded within this edge set can be recovered using an existing fixed node ordering algorithm such as improved node mapping  <cit>  where the values for codivergence and loss are set to infinity and any random selected fixed node ordering is applied. this method is of interest as a dynamic programming algorithm that allows for all four recoverable events will never reconstruct a cophylogeny mapping that is more expensive than the mapping recovered by this method, and, therefore, it provides an excellent baseline for new algorithms, particularly greedy algorithms that may not offer any accuracy guarantees.

these two methods both recover pareto optimal solutions, which are generally considered excessively expensive when applying cost schemes that assign approximately the same cost to each event, such as the jungle cost scheme  <cit> . although known to often report solutions with a high global cost, these algorithms do offer a strong preliminary baseline for the performance of treecollapse, which is designed to recover solutions which better approximate this problem using all four recoverable events.

the results for this analysis can be seen in table  <dig>  these results show that for both synthetic and real data sets, treecollapse's performance is significantly better than both algorithms as the aim here is to minimise the total parsimony cost. if we consider the distance from the best solution recovered i.e. the assumed pareto front then it can be seen that over the synthetic data set, treecollapse is 11% more expensive compared to 31% additional expense for page's reconciled tree analysis and 50% for edge only mapping. this is compared to the real data set where treecollapse is 6% more expensive compared to 54% for page's reconciled tree analysis and 45% for edge only mapping. as an average, this shows that treecollapse is 8% more expensive than the optimal compared to 42% and 48% for these two baseline algorithms clearly demonstrating that treecollapse outperforms both these baseline algorithms.

an interesting result from this analysis, that does not directly relate to this study but does offer an avenue for further research, is the contrasting results of page's reconciled tree analysis and edge only mapping over the real and synthetic data sets. these results, along with the contrasting results as part of the right push algorithm analysis and the analysis of the duplication-switch pattern, suggest that the core-gen may not be successfully modelling existing biological coevolutionary systems, compared to the  <dig> real data sets used in this analysis.

comparing against dynamic programming algorithms
finally, we compare treecollapse to core-pa and jane, the cutting edge approximation algorithms for solving the cophylogeny reconstruction problem. these two methods are responsible for the majority of recent coevolutionary analyses using cophylogeny mapping  <cit> .

core-pa was selected as it is the most recent algorithmic implementation that ignores the relative order of the internal nodes in the host tree. although known to produce time-inconsistent solutions in the worst case, core-pa was included to evaluate its overall performance compared to treecollapse.

jane was selected, as the metaheuristic framework leveraged by treecollapse is derived from jane's genetic algorithm  <cit> . it is, therefore, expected that the optimal node ordering arrangement will be converged upon by both algorithms at approximately the same rate, if the number of iterations and population size are consistent. therefore, the genetic algorithms for both methods were configured to run for  <dig> iterations with a population size of 100; the default configuration for the current version of jane.

as a result, core-pa generated time-inconsistent solutions in  <dig> % of cases over the synthetic data and  <dig> % of cases over the real data set. this demonstrates that core-pa is often reasonably accurate at estimating cophylogeny reconstructions especially considering that it runs in polynomial time, though the result also indicates that the resultant mapping may be time-inconsistent.

although jane outperforms treecollapse, a further analysis was run to explore how often treecollapse was able to find a solution close to that recovered by jane. the result of this analysis is presented in table  <dig>  where the number of instances where the parsimony score is equal to jane is computed, along with the number of cases where the solution is within  <dig>   <dig>   <dig>  or  <dig> or more away from jane's reported solution.

these results demonstrate that while the total parsimony score is 8%  away from the total reported by jane, treecollapse is able to converge on pareto optimal solutions in 65% of cases , and that 83% of solutions  are within a score of  <dig> from the pareto front. this is a significant result as it demonstrates treecollapse's ability, with a high frequency, to recover solutions which are approximately equal to those recovered by jane.

it is important to note, however, that while treecollapse and jane may recover mappings with an equivalent cost in 65% of cases, that the actual configuration of the mapping may not always be identical. in a number of examples, treecollapse and jane reported unique mappings, which are both pareto optimal. an example of such a case is the primate-malaria coevolutionary system , which we will consider in further detail.

the mappings recovered for the primate-malaria tanglegram for treecollapse, jane and core-pa can be seen in figures  <dig>   <dig> and  <dig>  the respective parsimony scores for each of these mappings were  <dig> for both treecollapse and jane and  <dig> for core-pa. figure  <dig> highlights that core-pa's reduced parsimony score compared to jane and treecollapse is due to the time-inconsistent switch , which gives rise to three additional codivergence events. jane and treecollpase, however, both reported solutions which are time-consistent but portray contrasting views of the origin of the parasite divergence within the host phylogeny, with treecollapse suggesting a longer evolutionary history between primates and malaria. this mapping further indicates a higher number of codivergence events, resulting in a more congruent reconstruction.

the unique mapping recovered for this coevolutionary system by treecollapse demonstrates its value as a complementary mapping algorithm for coevolutionary analyses. in this instance, by using both treecollapse and jane, a larger sub-set of the pareto front could be recovered, compared to what was achieved by using either method alone. this result affirms the value of treecollapse, not only as a faster way in which to approximate the cophylogeny reconstruction problem compared to approaches such as jane, but may potentially provide further insight into coevolutionary instances.

CONCLUSIONS
by building on the work of ronquist, libeskind-hadas and charleston, and conow et al, this work presents a novel greedy algorithm for solving the cophylogeny reconstruction problem where the internal node ordering is fixed, in linear time. the reported solutions, while on average 8% more expensive than those reported by jane, are produced by an algorithm with a quadratic running time reduction. the reported results, while produced by a linear time algorithm guarantee, all reported solutions are biologically feasible, as opposed to existing quadratic time algorithms such as core-pa. further, while jane may recover cheaper mappings than treecollapse in some cases, the newly proposed framework is able to uncover optimal solutions from the pareto front that are not reported by jane. we therefore assert that treecollapse is an algorithm that complements the set of existing tools for cevolutionary analysis. finally, we have set a baseline for algorithms which solve the fixed node ordering problem in linear time, of  <dig> % accuracy over  <dig> biological data sets. this baseline affirms ronquist's earlier hypothesis that pattern based reconstruction frameworks offer the potential to recover accurate approximations for host-parasite systems. furthermore, this suggests that further work in this field using pattern based methodologies, may result in even more efficient linear time algorithms for solving cophylogeny reconstruction problem, where the internal node ordering is fixed.

availability and requirements
treecollapse, along with the real data set supplementary material, is available at http://sydney.edu.au/engineering/it/~mcharles/. treecollapse runs on any machine running java  <dig>  or higher.

competing interests
the authors declare that they have no competing interests.

authors' contributions
bd is responsible for the creation and implementation of the treecollapse algorithm and framework along with contributing to this manuscript. mc is responsible for the original problem definition and contributed to this manuscript.

supplementary material
additional file 1
this file contains the references and brief description of the  <dig> real data sets used for validation of treecollapse.

click here for file

 acknowledgements
this work was supported by an australian postgraduate award to bd and an australian research council grant  to mc.

declarations
the publication of this article was paid for by the university of sydney.

this article has been published as part of bmc bioinformatics volume  <dig> supplement  <dig>  2014: thirteenth international conference on bioinformatics : bioinformatics. the full contents of the supplement are available online at http://www.biomedcentral.com/bmcbioinformatics/supplements/15/s <dig> 
