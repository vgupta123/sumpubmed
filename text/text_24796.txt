BACKGROUND
the driving aim of systems biology is to understand complex regulatory systems. a powerful tool for this is reverse engineering, a top-down approach in which we use data to infer parameter values for a model of an entire system. this differs from the traditional bottom-up approach of building up the larger picture through individually measured simple interactions. many methods have been developed for reverse engineering of gene regulatory networks, most of which are based on expression data from gene expression microarrays. however, most of these approaches do not consider temporal or spatial aspects of gene expression. examples of this are methods that infer regulatory modules from expression data across different experimental conditions  <cit> , or methods based on  bayesian network models  <cit> . network models with a temporal component can be used to analyse time-series of expression data  <cit> . in contrast, microarray-based approaches are impractical for investigating spatial gene expression patterns at cellular resolution, since they are usually performed on homogenised tissue. single-cell microarray analysis is possible, but technically difficult and highly time-consuming  <cit> .

there are many systems for which the spatial aspects of gene expression are essential. even in single-celled organisms, spatial localisation of regulatory factors is important  <cit> . spatial aspects become absolutely central for one of the most promising applications of reverse engineering: the in silico reconstitution of developmental gene regulatory networks. in this context, reverse engineering is used to infer the gene networks underlying pattern formation, i.e. to determine which genes activate or repress which other genes at which point in time and space to yield the observed dynamics of gene expression. to achieve this, a spatio-temporal approach is absolutely required.

here, we are going to consider a computational technique which allows the inference of explicitly spatio-temporal developmental gene networks. the approach--called the gene circuit method  <cit> --involves collecting spatial gene expression data at nuclear resolution for various stages of development. this is achieved by confocal laser scanning microscopy of embryos immunofluorescently stained against particular gene products, combined with subsequent quantification of the expression data  <cit> . a gene network model--consisting of a set of deterministic non-linear differential equations--is then used as a computational tool to extract regulatory information from the spatial time-series data: it is formulated such that its regulatory parameters determine whether each individual regulatory interaction is activating, repressing or absent altogether. these parameters are phenomenological in the sense that they summarise the regulatory effect of each transcription factor as a single numerical value; as such, it is not possible to measure them experimentally. instead, they must be inferred by fitting the model to the data. we employ a global optimisation procedure to reduce the least-squares difference between the two. this technique has been successfully used to gain insights into the gene regulatory networks involved in pattern formation in the early embryo of the fruit fly drosophila melanogaster. the resulting models were used to unambiguously assign specific regulatory interactions to the control of specific expression features, and enabled the quantitative analysis of expression dynamics, as well as error reduction capabilities of the system  <cit> .

one of the main problems with this approach is that both the number of equations and the number of parameters of the model--and thus the time required to run the optimisation for fitting the model to the data--increase rapidly as more genes are considered. it is thus extremely important to design effficient global optimisation algorithms to keep up with the ever-increasing scope of systems biology; efficiency in this case means both directly increasing the speed of the algorithms, as well as allowing the algorithms to run efficiently in parallel. the most commonly used algorithm for fitting gene circuit models has been parallel lam simulated annealing   <cit> . however, plsa has a very high computational cost, which makes it difficult to scale to more complex problems. an alternative approach dramatically increases computational efficiency by dividing the optimisation procedure into several distinct steps, some of which can easily and efficiently be run in parallel  <cit> . the drawback of this approach is that it depends on problem-specific assumptions about gap gene expression, and is not easily adapted to other inference problems. an extensive review of global optimisation methods for reverse engineering regulatory networks indicated that evolutionary algorithms--and in particular evolution strategies --often outperform other methods at optimisation of biological network models  <cit> . such evolutionary strategies have been implemented in systems biology parameter estimation tools  <cit> , and in particular an adapted es  has been shown to fit a gene network model more efficiently than simulated annealing  <cit> . up to this point, the main practical advantage of the simulated annealing approach for the gene network optimisation problem was that it had a proven efficient parallel algorithm, whereas no parallel version of the island-es has been applied to this problem before. in the hope of harnessing the same parallel utility that has been successful for simulated annealing, we developed a parallel version of the island-es algorithm. in addition to the previously reported advantages of evolutionary algorithms  <cit> , the parallel es algorithm is also an asynchronous algorithm, in the sense that processors send and receive communications independent of the activity of others. this eliminates waiting times, and leads to additional speed-up. in this paper we describe our synchronous and asynchronous parallelisations of the island-es, and compare their efficiencies against plsa on a real gene network problem.

methods
the problem: drosophila gap gene circuits
one of the few developmental systems that the reverse engineering approach has been applied to so far is segment determination in the early drosophila embryo. during the first three hours of development, regulatory interactions among approximately  <dig> segmentation genes establish a segmental pre-pattern of gene expression that determines the positions at which morphological body segments will form. the general principles by which this occurs are well understood  <cit> : a number of maternal mrnas become localised at the anterior and posterior pole of the embryo during egg development. after fertilisation, long-range spatial gradients are established by diffusion of translated proteins from their localised source. these maternal gradients then regulate expression of the zygotic gap genes in broad, overlapping domains. maternal factors and gap genes together regulate pair-rule genes , which in turn regulate segment-polarity genes, whose periodic expression in  <dig> stripes constitutes the segmental pre-pattern. the overall structure of this regulatory network is hierarchical: maternal genes regulate gap genes, gap genes regulate pair-rule genes, pair-rule genes regulate segment-polarity genes but not vice versa. however, while it was once believed that each layer of the hierarchy was fully determined by the layer above it, it is now known that such vertical interactions are insufficient to account for the expression patterns of their targets  <cit> . to fully explain the observed patterns, we need to consider the  horizontal interactions between genes in the same layer as well. here, we will focus on reverse engineering of the regulation of gap genes by maternal factors and gap-gap cross-repression  as a test problem for our optimisation algorithm.

mathematical model
we model the gap gene network using the connectionist gene circuit formalism developed by mjolsness et al.  <cit> . our model corresponds precisely to gene circuit models used in earlier studies of the gap gene system  <cit> . the state variables of the system are protein concentrations in embryonic nuclei. our model includes ng =  <dig> maternal and gap genes , hunchback , krüppel , knirps , giant  and tailless ), plus the maternal factor bicoid  as an external regulatory input. segment determination occurs along the major, or antero-posterior , axis of the embryo, and is independent of pattern formation along other axes. therefore, we consider nnuc nuclei laid out in a row, located between  <dig> and 92% along the a-p axis. each nucleus has an index i ∈ { <dig>  ..., nnuc}. there are nnuc × ng concentration values {}, each governed by an ordinary differential equation , given by   

the three main terms of the equation correspond to protein production, decay and diffusion. we will discuss each of these terms separately.

the production term is equal to some fraction of the maximum production rate ra. this fraction is given by the sigmoid regulation-expression function   

which takes on values between zero and one. , which contains three terms:  is the sum of activation or repression by regulators b, where the contribution of each b on gene a is given by its concentration multiplied by the weight of the connection between them (); the weight  matrix w defines the network of gene regulatory interactions: a positive value of  represents activation of gene a by regulator b, a negative value represents repression, and a value equal or close to zero represents no interaction. the second term ma represents the effect of the maternal factor bcd  on gene a, where ma is the regulatory weight  and  is the concentration of bcd in nucleus i. the final term ha is a threshold parameter for the sigmoid Φ, which represents the regulatory influence of ubiquitous maternal factors.

the diffusion term  is a standard implementation of fickian diffusion, in which proteins diffuse between neighbouring nuclei at a rate proportional to the difference between their concentrations. diffusion depends on the distance between nuclei which halves upon every division. da is the diffusion rate of each protein; as diffusion is proportional to the square of the distance between nuclei, da is a function of the number of cell divisions that have occurred prior to time t . every time the nuclei divide the distance between them halves, and the rate of diffusion changes according to da = 4da.

the decay term λa assumes that gene products decay exponentially, with a decay rate λa for gene a.

the half life of each protein is given by ln 2/λa.

the model takes account of cell division. the lengths of interphase and mitosis occur according to a well determined schedule  <cit> , and are modelled using three rules: during interphase, a continuous rule is applied, in which equation  <dig> holds. during mitosis, a second continuous rule is applied, in which the production term of equation  <dig> is set to zero. finally, a discrete division rule is applied, in which n is incremented, and each nucleus  splits into two, with the concentrations of all gene products copied from the mother nucleus to the daughter nuclei. the precise timing of the mitotic schedule is given in  <cit> .

quantitative spatial gene expression data
quantitative expression data for segmentation genes in the early drosophila embryo are from the flyex database, available online at: http://urchin.spbcas.ru/flyex  <cit> . the data set used here is identical to that used in earlier studies  <cit> . data acquisition and quantification methods are reviewed in  <cit> . here, we only provide a brief summary: expression data are acquired using laser scanning confocal microscopy of immunofluorescently stained embryos. each embryo is stained with antibodies against three distinct transcription factors , which is used as a standard for time classification and data registration; the other two consist of various combinations of gap proteins and other components of the segmentation gene network), and a nuclear counterstain to identify the positions of the nuclei. an automated image processing pipeline is used to extract per-nucleus concentrations and combine them into high-resolution time-series of integrated data. first, each embryo image is segmented; the position and extent of each nucleus are determined using a combination of watershed and either edge detection or thresholding algorithms, and protein concentrations are averaged for each data channel in each nucleus; this converts embryo images into tables with nuclear centroid positions and average protein concentrations per nucleus. the developmental age of each embryo is determined by visual inspection  based on eve expression and embryo morphology . non-specific background staining is removed; this is performed based on the observation that non-specific binding of antibodies follows a two-dimensional paraboloid distribution; such a paraboloid is fitted to non-expressing regions of an expression pattern and then subtracted by an affine transformation. the expression data are registered using an affine co-ordinate transform with the position of the eve stripes  as reference points; this minimises embryo-to-embryo variability, reducing positional errors introduced during data integration. finally, the images are averaged for each time-class and gene, in order to create an integrated data-set.

model fitting by optimisation
in our reverse-engineering approach  we wish to find estimates for parameter values, which are best able to explain the data. we can frame this as an optimisation problem in which we attempt to find the set of parameter values  opt that gives the minimum value of an objective function e(). we define the objective function for a particular set of parameter values  as the sum of squared differences between the model output and the experimental data:   

where the sum is over all time classes t, genes a, and nuclei i for which we have data, and where   

is the vector of parameters to be estimated, with a length of n = ng =  <dig> 

as mentioned above, optimisation for complex problems such as these is non-trivial. the system of equations is non-linear with a large number of parameters to be estimated, and the fitness landscape is multimodal. a full search is impossible, and a local search  is likely to get stuck in a local minimum. thus, we must use a global optimisation algorithm; we shall compare the parallel lam simulated annealing  algorithm with our newly developed parallel evolution strategy .

to get a value for e, we need to numerically solve the ordinary differential equations in equation  <dig> for a particular set of parameters and initial conditions. for all algorithms given below, we numerically solved the equations using a bulirsch-stoer adaptive-step-size solver scheme adapted from  <cit> .

optimisation algorithms
search space constraints
we do not need or want to search the entire, unbounded parameter space; there are certain values that we know a priori that parameters should not take , and we do not want regulatory parameters to grow without bound along the saturated arms of the sigmoid expression-regulation function. to represent this, we may either introduce absolute criteria that prevent the optimisation algorithm from assigning out-of-bounds values, or we can produce a penalty function, which increases as the parameters move further into areas of unacceptable solutions. the penalty function may be added to the objective function , or it may be kept separate and handled in an algorithm-specific way .

for the gene network problem, we use a penalty function for the regulatory parameters , ma and ha:   

where Λ is a control parameter, and  is the maximum observed intensity of gene b in the data. the justification for using this penalty function is that it remains  <dig> for   

i.e. when the absolute value of the total regulatory input is below a certain threshold, but rises steeply outside of those bounds. this allows individual parameter values to become quite large, while keeping total regulatory input within strict limits. we took Λ = 10- <dig>  based on earlier results  <cit> , we fix ha parameters to a value of - <dig> , which reduces the number of parameters to be determined from n =  <dig> to  <dig> 

the production, decay and diffusion rates, ra, λa and da are given explicit limits, such that any parameter value outside these limits is considered unacceptable and rejected. the ranges are  <dig> <ra <  <dig>   <dig> <da <  <dig>  and  <dig> < ln 2/λa <  <dig> for all a. these search space constraints are identical to those used in earlier studies  <cit> .

serial island evolution strategy
the evolutionary algorithm we are using is a parallel island -evolution strategy . it is a parallel version of the serial island es algorithm developed by fomekong et al., which was successfully applied to the same gene network problem  <cit> . we will describe this serial algorithm first. wherever possible, we have used the same values for optimisation parameters as used in the earlier study.

the island es algorithm operates on nisl populations of individuals, each with a population size λ. each population is initialised independently, and selection, recombination and mutation are performed only within populations. a migration operation links the populations; in the serial algorithm, the best individual from each island is copied to a population randomly selected from a uniform distribution. migration occurs every m generations. we took m =  <dig> .

we denote the set of all possible individuals as i, with individuals i in population p ∈ { <dig>  ..., nisl} denoted by vector , i ∈ { <dig>  ..., λ}. each individual has a parameter vector associated with it, , as given in equation  <dig>  we define a fitness function Φ(): i → ℝ, which is equal to the objective function e() as defined in equation  <dig>  and use the penalty function Π(): i → ℝ defined in equation  <dig> 

selection is performed to produce a set of μ offspring , according to a selection operator : iλ → iμ. the operator selects the top μ individuals of the population, according to a stochastic ranking procedure based on both the fitness function and the penalty function. this stochastic ranking method--introduced by runarsson et al.  <cit> --uses a bubble-sort-like procedure, in which an arbitrary ranking is produced, and λ sweeps are performed, in which each individual in turn  is compared to the one directly below. if the result of the penalty function for both individuals is less than or equal to zero, the fitness values of the two are compared, and the pair is ordered accordingly. if the penalty function of the top individual is greater than zero, then there is a probability pf that the individuals will be ordered according to their fitness, and a probability 1-pf that they will be ordered according to their penalty value. this procedure is ended if there is no change in the order in any given sweep. we use pf =  <dig> , which is the value used in  <cit> .

recombination is then performed on the offspring, using a recombination operator rλ: iμ → iλ. the operator first produces λ-μ individuals as direct  copies of the selected individuals in the parent population, with the fittest λ  individuals being represented twice if λ is not a multiple of μ.

second, μ additional individuals are produced by recombination; each individual  in the parent population produces an offspring  with parameter vector  by recombination between its own parameter vector , the next fittest individual's parameter vector , and the fittest individual's parameter vector , using the equation   

where λ is the recombination factor. we have taken λ =  <dig>  as in  <cit> .

the λ-μ individuals that do not undergo recombination are then mutated, according to the local mutation operator m{φ, α}: i → i. mutation is performed according to a non-isotropic self-adaptive mutation rule, in the sense that each individual i has associated with it a step size for mutation  for each parameter j, denoted as . this allows the step size to undergo evolution under selection, giving an adaptive step-size without having to specify a specific adaptation rule. mutation starts with a random change to the mutation rate, given by   

for i ∈ {μ +  <dig>  ..., λ} and j ∈ { <dig>  ..., n}, where  and  are tuning parameters. we have used φ* =  <dig>  ni and nij are a vector and a matrix of random values sampled from a normal distribution with zero mean and unit variance, which is generated afresh each generation.

next, we mutate the parameters  themselves, using   

for i ∈ {μ +  <dig>  ..., λ} and j ∈ { <dig>  ..., n}, where  is another randomly sampled normal unit vector, generated at each generation.

finally, we apply exponential smoothing to the step sizes, to reduce fluctuations   

for i ∈ {μ +  <dig>  ..., λ} and j ∈ { <dig>  ..., n}, where α is a smoothing parameter. we have taken α =  <dig> .  then becomes the mutation rate for the next round of mutation  <cit> .

every τ generations, the populations are checked to see if they have met the termination criterion ; at the same time, information on descent speed  is saved to a log. the algorithm has two termination conditions: it either runs for a preset number of generations, or it halts when the lowest value of the objective function remains below a particular preset amount for ρ × τ generations. preliminary investigation showed that the convergence time was relatively constant across runs, so we use a constant number of generations. we ran all runs for  <dig> generations, which we found to be long enough for virtually all runs to converge.

parallel island evolution strategy
parallelisation of the serial island-es  relies on running each population on a separate processor. since selection, recombination and mutation operate strictly within populations, only the migration operation, checking termination criteria and recording information for log files need to be parallelised. the simplest parallelisation of the serial ies is a synchronous parallel island-es . the algorithm is synchronous in the sense that all communication occurs simultaneously across all processes; when migration or other exchange of information is required, each processor halts until all other processes have caught up, and then all information is exchanged. the synchronous algorithm does not modify the behaviour of the serial algorithm, and is deterministic in the sense that serial and parallel runs with the same set of random seeds will produce exactly the same solution.

migration occurs according to the following scheme: a node designated the master node generates a migration schedule, in which every population is assigned another population to migrate an individual to, and this schedule is broadcast to all nodes. the individual nodes then communicate with each other point-to-point, with each individual sending the parameter values for its highest-ranking individual to its designated receiver, and replacing its lowest ranking individual with the best individuals of the population for which it is a designated receiver.

the collection of data related to descent speed and the checking of termination criteria are performed together. every τ generations, the best individual in each population is backed up, and the processors communicate between each other to find the lowest value of the objective function of any individual across all populations, which the master node records to a log file along with a time-stamp. as every process is aware of the fitness of the fittest individuals in all other populations, both termination criteria can be evaluated separately on each processor.

the disadvantage of the synchronous algorithm is that processors spend a significant amount of time idle. the asynchronous pies algorithm avoids this by having the processors communicate asynchronously; for migration and other communication, each processor sends information to a memory buffer associated with the process it is communicating with, which can then receive it at a later time , avoiding waiting times.

for migration, every m generations each process copies its best individual to the buffer of a randomly selected population, and adds any individuals in its own buffer to its population. no individuals are added if the buffer is empty. its buffer is then cleared. to avoid buffer sizes growing without bound, each processor will only place a maximum of  <dig> individuals in a given population buffer at any time before waiting for the them to be picked up . logging descent information and checking the termination criterion also occurs asynchronously. every τ generations each processor sends the fitness of its fittest individual to the buffer of a designated master node. every τ generations, the master node collects the fittest individuals, records them to a log and checks the termination criterion; if the termination conditions are met, the master node sends out a terminate signal to the buffers of all processors. similar to migration, we avoid buffer overflows as follows: each processor will leave a maximum of  <dig> messages in the master node buffer before waiting for it to read them .

parallel lam simulated annealing
we use the parallel lam simulated annealing  algorithm developed by chu et al.  <cit> , running on k processors with one processor being arbitrarily defined as the master node. optimisation parameters are taken from jaeger et al.  <cit> . the algorithm is described in depth elsewhere  <cit> . briefly, sa functions by defining an energy, given by the objective function e() plus the penalty function Π () . during each iteration  of the algorithm, the k processors change their parameter set , to a new state , according to an adaptive move generation strategy. they then evaluate the energy difference between the old and new states Δe = e()-e(); if this is negative, the move is accepted; if not, then it is still accepted with a probability exp. the temperature starts at t <dig> and is decreased according to the lam schedule, which gives the fastest decrease in energy possible while maintaining the system is quasi-equilibrium  <cit> . the lam schedule requires information on the mean and variance of the energy over time; a set of running estimates of these are calculated using specially designed estimators  <cit> . the same temperature is used across all nodes, and thus all processors must periodically pool their local statistics  to allow the temperature schedule to be maintained  <cit> . this pooling of statistics allows the temperature to be lowered k times as fast as in the serial case.

to compensate for processes which leave the quasi-equilibrium regime , a mixing of states is performed every m iterations. the energy states of all processes are collected and redistributed according to boltzmann probability: the probability of any given processor being assigned the state of process i is given by , where ei is the current energy of process i. this mixing of states allows the best results to propagate, but also allows nodes to explore higher energy solutions. it strongly resembles the selection procedure used in evolutionary algorithms.

in order to avoid the final solution being affected by the initial conditions, the algorithm performs an 'initial burn', in which each processor spends ninit iterations running as normal serial sa at a constant temperature t <dig>  after that, the algorithm needs to run for another ninit/k iterations to calculate initial statistics.

there are two types of potential stopping conditions that could be used for the algorithm: the absolute condition, and the freeze condition. in the absolute condition, the algorithm terminates after the absolute mean value of e remains below a target energy for a certain period of time. in the freeze condition, the algorithm terminates after the absolute energy e changes by less than a certain proportion over a certain period of time. as preliminary investigations showed that the final energy and the convergence time were both very variable, we exclusively use the latter.

algorithm performance metrics
all algorithm implementations write the current value of the objective function and running times to log files at regular intervals ; these log files are used to calculate mean descent curves with standard errors and 95% ranges for each such interval. these curves can be used to compare the value of the objective function for different algorithms at any time during an optimisation run, and give an estimate of the variability in the algorithm's performance. we choose two target values of the objective function e, which correspond to good solutions  and 'good-enough' solutions , which in most cases are sufficiently close to the global solution to be usable as starting points for local search strategies  <cit> . we calculate the mean time taken to reach each target value for all runs that have actually reached it, as well as the standard error of this mean , where σ is the standard deviation of times-to-reach-the-target, and nruns is the number of attempts in a series of optimisation runs). from this, we can calculate confidence intervals based on the assumption of normally distributed error. in addition, we calculate the success rate for reaching a target value, defined as the proportion of runs that reached that target . in general, we give the inverse of the time taken, which measures the efficiency of the algorithm, whereas the success rate represents its robustness. overall performance of an algorithm needs to take into account both of these measures.

in order to assess how effective our parallelisation of the evolution strategy was, we calculate relative and absolute speed-up. the relative speed-up is defined as   

and represents a measure of the efficiency of the parallelisation in terms of communication overhead . the absolute speed-up is defined as   

where k* is the number of islands resulting in optimal serial algorithm performance, which we found to be equal to  <dig> . the absolute speed-up measures how effective the parallel algorithm is compared to the best serial algorithm, as opposed to merely the serial version of the parallel algorithm. thus it takes into account both communication overhead and loss in efficiency due to having a non-optimal number of islands. note that this is a much more stringent definition of parallel efficiency than the relative speed-up , but it is also the measure most often required for practical decision making, as it puts a value on exactly how much extra speed will be gained by moving to a parallel algorithm, assuming you are using an optimal serial algorithm.

we estimated 95% confidence intervals on absolute and relative speed-up using fieller's theorem  <cit>  for confidence intervals on ratios of gaussians. errors on ratios tend to be large, which explains the large confidence intervals around the speed-up values.

note that in the simulated annealing literature, the value of the objective function is often called the 'energy', and in the evolutionary algorithms literature the same value is often referred to as the 'fitness'. to avoid confusion, we use 'value of the objective function' or 'objective value' instead.

code implementation
the parallel -island-es code is implemented in c++, and is based on code written and used by fomekong et al.  <cit>  . parallel communication is implemented using the message passing interface . the plsa code is implemented in c, and is based on code taken from the supplementary material of jaeger et al.  <cit> , . little modification was made to the original plsa code, other than minor alterations to allow finer-scale time-stamping in the log files for descent curves.

for both algorithms, we used a parameter scrambling procedure to give the problem different starting conditions; the plsa algorithm reads in initial parameter values, which were randomised prior to starting each instance of the program, while the pies algorithm generates its starting conditions according to a random seed, which is itself randomised for each optimisation run.

both implementations were compiled using the intel c++ compiler , and both implementations make use of the qlogic implementation of the message passing interface . data analysis was performed using the statistical programming language r  <cit> .

source code is available from the authors upon request.

optimisation runs were performed on the darwin parallel cluster of the university of cambridge high performance computing facility .

RESULTS
analysis of the serial island evolution strategy
the performance of the serial island-es algorithm is affected by the number of islands it uses  <cit> . however, this dependence has never been investigated beyond four islands. this is directly relevant for our parallelisation strategy: a perfect, synchronous parallel algorithm running on k nodes  behaves exactly like a serial algorithm with k islands running on a computer k times as fast. we can thus calculate the theoretical limits of the algorithm's relative speed-up by dividing the speed of the serial algorithm by the number of islands nisl.

we performed  <dig> optimisation runs each using the serial algorithm with  <dig>   <dig>   <dig>   <dig>   <dig> and  <dig> islands. the number of individuals on every island was kept constant , resulting in a meta-population size of  <dig> × k. note that our individual partitioning strategy differs from that used by  <cit> , who kept a constant meta-population size, and decrease the population size with number of islands; the latter method may be more efficient for smaller numbers of islands, but will lead to unfeasibly small population sizes above about  <dig> islands.

the amount of time required to reach both 'good-enough' and 'good' solutions is shown in table  <dig>  and the speed of the algorithm for various number of islands is plotted in figure 1a. for both the 'good' and 'good-enough' targets, we observe a gradual decrease in efficiency as the number of islands increases. this decrease in efficiency occurs because the increased computational load of adding more populations out-weighs the increase in search capacity. we do not observe the dramatic increase in efficiency of  <dig> islands over  <dig> island reported by  <cit> ; this is probably due to the different ways in which population size is partitioned in our approach.

the time taken to reach 'good-enough' and 'good solutions' for the serial island es algorithm with different numbers of islands. the number of ode solutions is also given. times are given in hours and minutes , and the values in parentheses are 95% confidence intervals.

we calculated the theoretical speed of a perfect parallel algorithm on n nodes  by dividing the speed of the serial algorithm with nisl islands by n. from this value, we produced a theoretical absolute speed-up curve , by dividing each theoretical parallel speed by the highest mean speed of the serial algorithm for any number of islands. this theoretical absolute speed-up curve is shown in figure 1b; the black line represents a perfect absolute speed-up curve, where the speed-up of an algorithm on n nodes is n times faster than the best serial algorithm. we see that a perfect pies could continue to give speed-up all the way up  <dig> nodes, with the ideal 50-node run being around 8- <dig> times faster than the best serial algorithm.

parallelisation efficiency
to estimate the efficiency of our parallel algorithm, we performed  <dig> runs each using both synchronous and asynchronous implementations of the pies on  <dig>   <dig> and  <dig> processors. running times and speed-up values are given in table  <dig>  and the speed-up curve is plotted in figure 2; the speed-ups are calculated relative to the serial runs discussed above, with the absolute speed-up being calculated using the optimal island size of  <dig>  the relative speed-up for both parallel implementations is close to perfect for  <dig> and  <dig> processors, and the efficiency of the two algorithms is largely indistinguishable. in contrast, the relative speed-up for the synchronous algorithm is low for  <dig> processors, while the relative speed-up remains high for the asynchronous algorithm. this indicates that communication overhead due to idle processors waiting for each other becomes significant only above  <dig> processors.

the time taken to reach 'good-enough' and 'good solutions' for the optimal serial island es, and the two parallel pies algorithms, along with the relative and absolute speed-up for each parallel algorithm . times are given in hours and minutes  and the values in parentheses are 95% confidence intervals.

the absolute speed-up  remains significant regardless of the number of nodes used, showing that the parallel algorithm is always faster than the best serial algorithm. as expected, the absolute speed-up is generally lower than the relative speed-up: these two measures increasingly diverge as the number of processors increases, reflecting the negative effect of adding islands beyond the optimum. however, the asynchronous algorithm continues to gain speed as more nodes are added all the way up  <dig> nodes, with the parallel algorithm running on  <dig> processors nearly  <dig> times faster in absolute terms than the best serial algorithm.

comparison of algorithms
to compare all three algorithms , we ran  <dig> plsa runs each on  <dig>   <dig> and  <dig> processors. example descent curves for the asynchronous pies and plsa are shown in figure 3a; these are the mean descent curves for the  <dig> processor runs . coloured regions around the descent curves represent the region in which 95% of descent curves fall. we observe a lower initial value of the objective function, a higher initial descent speed and a lower mean convergence value for the pies compared to plsa. in addition, the pies shows far less variation in the descent trajectory. figure 3b compares synchronous and asynchronous pies; there is a slight increase in initial descent speed for the asynchronous algorithm over the synchronous algorithm, but both algorithms perform very similarly at later stages of the descent.

a comparison between the times required to reach the 'good-enough' target show an approximately linear increase in speed with the number of processors for the asynchronous pies . in contrast, there is a marked drop in speed-increase at  <dig> processors for both plsa and the synchronous pies algorithm . both synchronous and asynchronous pies achieve virtually perfect robustness regardless of the number of processors, while plsa becomes significantly less reliable as the number of processors increases . table  <dig> gives the mean number of ode solutions performed by each algorithm to reach the 'good' and 'good-enough' solutions; as expected, the synchronous and asynchronous pies algorithms both perform roughly the same number of ode solutions, and the relationship between number of ode solutions for the pies and plsa algorithms follows the same pattern as the time taken.

the mean number of ode solutions performed before reaching 'good-enough' and 'good' solutions for the synchronous and asynchronous pies algorithms, and plsa.

the behaviour of the algorithms changes significantly when they are required to reach the 'good' target . while the asynchronous pies remains slightly faster than the synchronous version, the speed of both algorithms is largely independent of the the number of processors. in contrast, an increase in the number of processors does increase the reliability of the algorithms, which both achieve the target nearly 100% of the time when run on  <dig> processors. this contrasts strongly to the behaviour of plsa. the probability of reaching the target value falls off dramatically with the number of processors ; when the algorithm is made highly parallel, the vast majority of the jobs fail. however, the speed of the few runs that actually reach the target value drastically increases with the number of processors, showing that, while a majority of highly parallel runs fail, the ones that do not reach the target remarkable quickly.

discussion
parallel efficiency of the evolutionary strategy
the results from the investigation of the serial algorithm show an interesting outcome: increasing the number of islands gives increased descent speed per generation, even if the number of islands is very large. in the serial case, this increased search capacity becomes outweighed by the increased computational load of the population when the number of islands increases beyond the optimal number of  <dig>  on the other hand, it suggests that the algorithm has the capacity to be parallelised to a large number of processors.

the rate at which the serial algorithm speed decreases with the number of islands places a limit on the efficiency of the parallel algorithm . however, this limit only applies when migration rate and per-island population size remain constant, and can likely be circumvented by tuning these values for a given set of islands or nodes. for instance, the migration rate will probably need to be elevated with an increased number of islands, to allow solutions to propagate around the larger meta-population. it may also be advantageous to decrease the population size and increase the mutation rate; a smaller population size will decrease computation time, and an elevated mutation rate will increase the search capacity of individuals. this could make solutions less stable within an island, an unwanted effect which is counteracted by the ability for good solutions to spread across the population. we have not tuned the algorithm here to allow for accurate comparison between algorithm implementations and various numbers of islands and processors. in practice, however, we can easily tune the algorithm in serial , which will make testing these hypotheses relatively simple, especially if compared to the complex and time-consuming tuning required to reach optimal behaviour of the plsa algorithm  <cit> .

both synchronous and asynchronous parallel implementations of the island-es scale well with the number of nodes . that the relative speed-up is high for the synchronous algorithm is a direct result of the highly  parallel nature of the serial algorithm, and the asynchronous algorithm improves on this even further to give a nearly perfect relative speed-up for up to  <dig> processors. it is worth pointing out that the change in migration schedule from the synchronous to the asynchronous implementation is relatively ad-hoc; that the algorithm does not lose efficiency despite changing its behaviour is yet another testament to the flexibility of evolutionary algorithms. contrast this to the difficulty with which many optimisation algorithms are parallelised, including simulated annealing  <cit> . the absolute speed-up is not as striking as the relative speed-up, but it is also a far more stringent measure of algorithm efficiency. the asynchronous parallel algorithm on  <dig> nodes is  <dig> times faster than the fastest serial version, and increasing this to  <dig> nodes gives nearly a 10-fold increase in speed; in both cases, speed-up is significant and comparable to the predicted perfect absolute speed-up . algorithm performance increases yet further if we consider the robustness of convergence, which for good solutions increases drastically with the number of processors; an algorithm that has an initial descent 10-fold faster than the serial version and is almost guaranteed to converge on a good solution is indeed a powerful tool for reverse engineering biological systems.

simulated annealing vs evolutionary strategy
the most striking feature of the descent curves of plsa and the pies algorithm  is how much faster the es algorithm converges in almost all cases. examining the data closely, we can see that there are three aspects that characterise the difference in the curves.

first, the pies mean descent curve begins at a much lower objective function value than that of plsa. this is caused by differences in the initialisation procedure of the two algorithms. the plsa algorithm begins with a single starting solution for all processors, which undergoes a high temperature 'burn period' to erase dependence on the initial condition. this is followed by a period of statistics collection  at constant, high temperature in order to initialise estimator values for the temperature schedule. this means that each of the k processors has an individual initial state. in contrast, the pies algorithm starts with a much larger number of randomly created initial states equal to λ × nisl, allowing a far higher diversity of objective values, and thus a lower expected minimum initial objective value.

second, the initial speed of descent is much higher for the pies. this is probably due to a particular difference in the early operation of the two algorithms. during the early stages of descent, the annealing temperature is high for plsa, and thus there is little selection for better solutions; once the temperature is lowered the selection for better solutions increases, but simultaneously the solution is getting closer to the minimum, and the slowing associated with the decreased move size counteracts the lower temperature. the pies algorithm, in contrast, begins a full selection schedule straight away, allowing descent at maximum speed from the very start of the algorithm. note that the reason that the pies can afford to start fast, but plsa cannot, is that the multi-individual nature of evolutionary algorithms allows a diversity of individuals  to remain despite a decrease in mean objective value; if plsa was to decrease at this rate, it would lose quasi-equilibrium and fail to converge, becoming stuck in a local minimum.

third, the pies algorithm converges to a lower mean objective value across all runs than plsa. the reason for this appears to be driven by the unreliable nature of plsa compared to the more robust performance of the pies, as shown in figures 4b and 5b. while plsa can achieve very low values of the objective function , the large proportion of runs that fail to reach good solutions increases the mean final objective value to above that of the pies. this also explains why we see so much faster convergence to the 'good' target in figure 5a compared to 4a. when difficult targets are set, the failure rate for simulated annealing increases drastically, and thus the only runs that converge are in the small minority of 'good' runs. this implies that the increased speed for the 'good' target at  <dig> and  <dig> nodes is largely an artifact of the high failure rate, or at least should be judged in light of their rarity.

the unreliable nature of plsa has been commented on before  <cit> , with significant failure rates even for small 2-gene networks used as a test problem  <cit> . the fact that island-based evolutionary algorithms can be highly reliable function optimisers in large parameter estimation problems has been well established  <cit> . it is difficult to say precisely why our island-es should be more reliable than a plsa; both involve within-processor means of landscape searching , and both of them involve a process by which solutions propagate from processor to processor . it is possible that the diversity within each population in the pies prevents the propagation of solutions stuck in local minima throughout the population; even if a locally minimal solution spreads to all populations, there will still be higher-objective valued individuals that will continue to search the state-space outside of this minimum, and once they achieve a lower solution than the local minimum they will begin to propagate. this does not occur in plsa; if every processor is stuck in a local minimum, then there are no back-up individuals to allow for an escape.

further methodological improvements
the complexity of models in systems biology is constantly increasing, and thus the speed required of optimisation is always growing. the drosophila segmentation system alone consists of interactions between dozens of genes and gene products  <cit> , and to model all of them would create a drastic increase in computational complexity. future methodological developments in optimisation will have to address how this increasing complexity will be handled.

comparisons between gap gene circuits with  <dig> or  <dig> genes indicate that even a very moderate increase in model complexity can lead to a significant decrease in reliability of the plsa algorithm . our observations indicate that lack of robustness of the plsa algorithm is due to the fact that most plsa runs fail. on the other hand, those runs that converge, do so very rapidly. therefore, efficiency of the plsa algorithm could be improved significantly, if we managed to find a reliable method to separate failing from promising runs early on during optimisation. such an approach has been suggested previously  <cit> .

while the pies is both faster and more reliable than plsa, figure  <dig> shows that the communication overhead is starting to become a problem even for the asynchronous algorithm at around  <dig> processors. moreover, as the number of processors increases, the difference between relative and absolute speed-up increases due to the use of populations beyond the optimum number. therefore, it seems unlikely that the pies algorithm will scale well into the hundreds of processors and we must seek further algorithmic improvements to increase scalability, robustness and efficiency of optimisation.

one method for increasing the speed of both plsa and pies algorithms comes from the observation that local searches tend to converge very rapidly and reliably to the global minimum, given initial conditions which are sufficiently close to the global solution  <cit> . this suggests a hybrid approach, which uses a global search algorithm for the initial phase--during which descent curves are steep --and switches to a local search method once the descent curve has begun to flatten out. the role of the global optimisation algorithm now becomes to descend as fast as possible to a low-enough value of the objective function for the local search to converge. many local search methods exist that can be parallelised for this purpose  <cit> . the critical issue is to determine the ideal switch-over point from global to local search. this can have a large impact on the efficiency of the hybrid algorithm, as a late switch wastes time on slow global descent, while a premature switch causes failure of the local search method to converge  <cit> . as a first step towards such a hybrid approach, local search methods have been shown to significantly improve the quality of solutions for the gap gene problem obtained by plsa  <cit>  or a serial ies  <cit> . the pies algorithm seems particularly suited for this, as it achieves a relatively low objective value very fast .

an alternative approach for increasing parallel efficiency--specific to evolutionary algorithms such as the pies--is the hierarchical approach  <cit> . a hierarchical algorithm consists of small groups of processes that run one specific aspect of an evolutionary algorithm. for example, in master-slave algorithms, a master processor performs all operations except evaluating the objective function, which is farmed out to other computers. such master-slave clusters can in turn form part of a larger evolutionary algorithm . this becomes especially relevant as the complexity of the model, and thus the computational cost for calculating the objective function, increases. hierarchical genetic algorithms have been applied to a variety of problems  <cit> , and have been particularly effective in a grid computing environment  <cit> . furthermore, they are ideally suited for running on multi-core architectures or highly multi-threaded graphics cards. an appropriate hierarchical implementation of the pies would be straightforward to implement, which could lead to a highly efficient, massively implementation of this parallel optimisation algorithm.

CONCLUSIONS
progress in systems biology crucially depends on efficient and innovative computational methods. in the case of the gap gene network, it was an innovative approach--the gene circuit method  <cit> --that allowed the extraction of regulatory information directly from the intact wild-type system. this reverse-engineering approach is generally applicable to the quantitative study of pattern-forming and other complex gene regulatory networks, if powerful optimisation methods are available to fit gene circuit models to data. our investigation has shown that both implementations of the pies algorithm are significantly more efficient than plsa both in terms of speed and reliability. we have demonstrated that the asynchronous pies algorithm exhibits excellent parallel speed-up for up to  <dig> processors, and have provided a detailed discussion of why it outperforms the plsa algorithm on various accounts.

it was not our intention here to achieve a systematic benchmark comparison of different optimisation strategies. this has been achieved elsewhere  <cit> . instead, we attempt to provide a practical guide on what kind of algorithm works best on a real-world biological problem, which we believe to be representative for the nature and complexity of many reverse-engineering problems which arise in the study of regulatory networks involved in physiology, development and ecology. the asynchronous pies algorithm is a powerful computational tool, which allows yet another incremental increase in the complexity of models that can be successfully fitted, and thus increases the breadth of our knowledge of the complexity of natural systems. we think that our pies algorithms not only demonstrate the power, but also the potential of evolutionary computation. evolutionary algorithms are inspired by the processes of real-world evolution, and as such they potentially have available to them the tools that lead to the most successful optimisation run we have yet examined  <cit> . it is apparent that there is a whole array of modifications and improvements that can be made to such algorithms, some of which are already known, and many more that are yet to be discovered.

authors' contributions
lj implemented both versions of the pies algorithm, performed optimisation runs, algorithm comparison and the statistical analysis of optimisation results. jj proposed the research and supervised the work. lj and jj wrote the manuscript.

