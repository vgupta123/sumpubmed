BACKGROUND
the size of genome sequence data has been rising at an exponential rate for the past decade or two, and will dramatically increase with new sequencing technologies becoming widely available. to analyze, annotate and compare these genome sequences, new algorithms and software for post-sequencing functional analysis are demanded by the scientific community.

whole genome comparisons can be used as a first step toward solving genomic puzzles, such as determining coding regions, discovering regulatory signals, and deducing the mechanisms and history of genome evolution. of importance to the genome annotation process, the genome comparison approach obviates the need for a priori knowledge of a protein sequence motif and provides a straightforward means for mapping information from the stored annotated genomes to the novel ones.

sequence comparison in the context of comparative genomics is complicated by the fact that both local and global mutations of the dna molecules occur during evolution. local mutations  consist of substitutions, insertions or deletions of single nucleotides, while global mutations  change the dna molecules on a large scale. global mutations include inversions, transpositions, and translocations as well as large-scale duplications, insertions, and deletions.

thus, if the organisms under consideration are closely related  or one compares regions which are suspected to be orthologous , then global alignments can, for example, be used for the prediction of genes and regulatory elements. this is because coding regions are relatively well preserved, while non-coding regions tend to show varying degrees of conservation. genome comparisons of more closely related species may also help to determine the genetic basis for phenotype variation and may reveal species-specific regions  that can be targeted for identification.

for diverged genomic sequences, however, a global alignment strategy is likely predestined to failure for having to align non-colinear and unrelated regions.

in fact, the realm of comparative genomics is not limited to the comparison of two or multiple uni- or multi-chromosomal genomes. it also includes the comparison of two or multiple draft genomic sequences, the comparison of different assemblies, cdna/est mapping, and the comparison of two cdna/est libraries from different species. in all these tasks, the key problem is to identify regions of similarity among the sequences, and to align them.

to cope with the shear volume of data, most of the comparative genomics software-tools use an anchor-based method that is composed of three phases:

 <dig>  computation of fragments ,

 <dig>  computation of highest-scoring chains of colinear non-overlapping fragments , and

 <dig>  alignment of the regions between the anchors.

see  <cit>  for reviews about the tools using this strategy for comparing whole genomic sequences, and see  <cit>  and the references therein for the tools addressing the task of cdna/est mapping. all the tools employing this strategy implement the three phases, but the details depend on the task and are different among the tools. for example, some tools use exact algorithms, some use greedy algorithms, some use a graph based solution, and others use a geometric based solution.

comparative genome analysis on a large scale
a tool for the systematic comparative study of sequences as large as vertebrate or plant genomes must satisfy the following criteria.

versatility
to be useful for molecular biologists, such a tool should be able to deal with versatile tasks. the coconut system supports the following genome comparison tasks:

• computation of a multiple alignment of closely related  sequences.

• computation of regions of high similarity among multiple genomic sequences.

• comparison of two draft or multi-chromosomal genomes. .

• identification of segmental duplications in whole genomic sequences.

• cdna/est mapping.

to the best of our knowledge, there is no other software-tool which covers so many tasks. coconut is freely available for non-commercial purposes.

compositionality and usability
a complex system supporting the manifold tasks of genome analysis usually consists of several advanced programs. thus it must provide simple interfaces to enable the composition of these programs. coconut uses variations of the above-mentioned anchor-based strategy to support genome comparison tasks. the three phases  computation of fragments,  chaining of fragments, and  post-processing of chains are clearly separated. thus, it is possible to exchange a program performing one of the phases without affecting the whole system. moreover, it is possible to stop the computation at any phase, and store the intermediate results for later use.

efficiency
to analyze complete genomes of up to several billion base pairs, the space and time used by the algorithms must scale "almost" linearly with the sequence length and the output size. coconut is based on the anchor based strategy mentioned before and its algorithms meet this requirement. our implementation of the crucial first phase  is linear, see  <cit>  for more details. the second phase uses techniques from computational geometry to chain the fragments. this approach is "almost" linear in the number of fragments, which is a considerable advantage over the straightforward graph based approach . for more details about our chaining algorithms, see  <cit> .

experimental results show that coconut is able to efficiently handle large sequence sets. for example, four bacterial genomes are processed  in a few minutes. coconut can process three large mammalian x-chromosomes in about one hour on a standard workstation. however, for the largest vertebrate chromosomes, a server class machine  is probably required. comparing a set of complete mammalian genomes in one run would require even more ram, and therefore we recommend to perform the comparison on the chromosome level. however, a general statement about the upper limit of the number and size of the sequences which can be processed is difficult, because the resource requirement very much depends on the similarity of the genomes. the more similar, the more matches are to be computed and the more resources are required.

interactive visualization
the large amount of data delivered by comparative genomics requires a visualization. coconut comes with an interactive visualization tool called vischainer. this displays dot plots of the comparison results . in contrast to established dot-plot tools like dotter  <cit>  or gepard  <cit> , vischainer can automatically display dot plots of multiple genome comparisons. that is, all two-dimensional projections of the common regions among multiple genomes are plotted. moreover, vischainer has functionalities specific to the anchor-based strategy.

related work
whole genome comparison
in  <cit> , treangen and messeguer presented a classification of genome comparison tools. in this classification, coconut falls into the category of large-scale multiple genome comparison tools. some of these  can deal with genome rearrangements. in what follows, we briefly compare our system with these software-tools except for mulan, because mulan is a network server based on tba. aba and tba employ a progressive alignment strategy, i.e., they construct local alignments from pairwise comparisons, possibly following a "guide" tree. both tools use blastz  <cit>  to identify hits  between pairs of genomes, and then they combine these hits into larger alignment blocks. therefore, these tools can detect similarities that must not necessarily be present in all of the genomes under consideration. this is an advantage over mauve, m-gcat, and coconut. on the other hand, both tools suffer from large running times even for short sequences; see  <cit>  and .

mauve and m-gcat use maximal unique matches as fragments. by definition, these matches occur only once in each genome . as a consequence, for genomes containing large-scale duplications , the number of fragments may be very small and thus no reasonable alignment can be produced. in fact, this shortcoming was already mentioned in  <cit>  and  <cit> .

identification of large genomic duplications
there are many software tools for locating repeated segments in large genomic sequences; see  <cit>  for a review. coconut is different from other tools because it can efficiently locate large genomic duplications . these are difficult to detect as they  are very long,  may be interrupted by large gaps , and  might have undergone rearrangement events. as an example, we show how coconut can locate the genome duplications in chromosome i of a. thaliana.

cdna/est mapping
standard dynamic programming algorithms cannot be used for high throughput mapping of cdna sequences because they have a quadratic running time. hence, heuristic algorithms have been developed for this task. all of them either use a seed-and-extend strategy or a chaining strategy.

tools applying the seed-and-extend strategy include, among others, blat  <cit>  and mgalign  <cit> . these tools differ in the type of seeds they use and in the way the seeds are computed. tools using the chaining based strategy include, among others, genomethreader  <cit> , gmap  <cit>  and the program by shibuya and kurochkin  <cit> .

the work of  <cit>  is worth mentioning because it uses suffix trees for the computation of exact matches and introduces a geometric-based chaining algorithm. in  <cit> , the algorithm of  <cit>  was further refined by using enhanced suffix arrays instead of suffix trees, by using maximal exact matches instead of maximal unique matches, and by using a chaining algorithm that is less complicated and more suitable for cdna mapping. its sensitivity/specificity was compared to the program blat . it was shown in  <cit>  that the chaining strategy is more specific than the seed-and-extend strategy, while achieving the same level of sensitivity. moreover, the algorithm obviates the need for masking the genomes, while unmasked sequences can often not be processed by k-mer based seed-and-extend strategies, as the number of k-mers is too large. seed-and-extend strategies based on maximal exact matches  may be able to process unmasked, sequences, but for cdna mapping they are less specific than the chaining approach, see above. in coconut, the algorithms and software prototypes presented in  <cit>  were rewritten and extended by additional splice site detection methods.

implementation
computing the fragments
for i,  <dig> ≤ i ≤ k, let si = si denote a string of length ni = |si|. in our applications, si is a long dna sequence . furthermore, si is the substring of si starting at position li and ending at position hi. a fragment consists of substrings s <dig>  s <dig> ..., sk that are "similar". if s <dig> = s <dig> = ... = sk , then such a fragment is called exact fragment or multiple exact match. a multiple exact match is called left maximal, if si ≠ sj for some i ≠ j, and it is called right maximal if si ≠ sj for some i ≠ j. a multiple maximal exact match  is left and right maximal. in other words, the constituent substrings cannot be simultaneously extended to the left and to the right.

a multimem is called rare if the constituent substrings si appear at most r times in si, where  <dig> ≤ i ≤ k and r is a natural number specified by the user. we call the value r the rareness value. a multimem is called unique if r =  <dig>  in this case, we speak of a multiple maximal unique match or multimum for short. note that the maximal unique matches used in the program mummer can be viewed as multimems with rareness value r =  <dig> for k =  <dig> sequences.

if character mismatches, deletions, or insertions are allowed in the constituent substrings of a fragment, then we speak of a non-exact fragment. the programs dialign  <cit>  and lagan  <cit>  compute fragments with substitutions, and the program blastz  <cit>   computes fragments with substitutions, insertions, and deletions.

our system can use any kind of fragments, provided that they are output in the coconut format. for our experiments, we use  multimems because these are easier and faster to compute than non-exact matches. using spaced seeds  <cit>  for pairwise comparisons would also be reasonable. note that multimems of minimum length k achieve the same level of sensitivity as approximate matches computed by extending seeds of length k. moreover, the number of multimems is much smaller than the number of k-mers, which results in faster processing and better specificity.

geometrically, a fragment f of k genomes can be represented by a hyper-rectangle in ℕ≥0k with the two extreme corner points beg and end. beg is the k-tuple , where l <dig> ..., lk are the start positions of the fragments in s <dig> ..., sk. end is the k-tuple , where h <dig> ..., hk are the end positions of the fragments in s <dig> ..., sk, respectively; see figure  <dig>  with every fragment f, we associate a positive weight f. weight ∈ ℝ. this weight can, for example, be the length of the fragment  or its statistical significance. in our system, in the default case, we use the fragment length as weight.

chaining the fragments
we define a binary relation ≪ on the set of fragments by f ≪ f' if and only if end.xi <beg.xi for all i,  <dig> ≤ i ≤ k. if f ≪ f', then f precedes f'. two fragments in a chain are colinear if the order of their respective segments is the same in all genomes. in the pictorial representation of figure  <dig>  two fragments are colinear if the lines connecting their segments are non-crossing .

a chain of colinear non-overlapping fragments  is a sequence of fragments f <dig>  f <dig> ..., fℓ such that fi ≪ fi+ <dig> for all  <dig> ≤ i < ℓ. the score of a chain ⟨c = f <dig>  f <dig> ..., fℓ⟩ is

 score=∑i=1ℓfi.weight−∑i=1ℓ−1g 

where g is the cost of connecting fragment fi to fi+ <dig> in the chain. we will call this cost gap cost. the gap cost implemented in the current version of coconut is defined as follows. for two fragments f ≪ f',

 g=∑i=1k|beg.xi−end.xi| 

given n weighted fragments from two or more genomes, the following problems can be defined:

• the global chaining problem is to determine a chain of maximum score starting at the origin  <dig> =  and ending at the terminus point t = . such a chain will be called optimal global chain. figure  <dig> shows a set of fragments and an optimal global chain.

• the local chaining problem is to determine a chain of maximum score ≥  <dig>  such a chain will be called optimal local chain. it is not necessary that this chain starts at the origin or ends at the terminus. figure  <dig> shows a set of fragments and an optimal local chain.

• given a threshold t, the all significant local chains problem is to determine all chains of score ≥ t. obviously, the all significant local chains problem is a generalization of the local chaining problem.

in a solution to the all significant local chains problem, some chains can share one or more fragments, composing a cluster of fragments. in the example of figure  <dig>  the local chains ⟨ <dig>   <dig>  6⟩ and ⟨ <dig>   <dig>  6⟩ share the fragments  <dig> and  <dig>  yielding the cluster ⟨ <dig>  { <dig>  4}, 6⟩. the cluster ⟨ <dig>  { <dig>  9}⟩ represents two local chains ⟨ <dig>  8⟩ and ⟨ <dig>  9⟩. to reduce the output size, we report the clusters and from each cluster we report a local chain of highest score as a representative chain of this cluster. this representative chain is a significant local chain. in the example, the representative chains are ⟨ <dig>   <dig>  6⟩ and ⟨ <dig>  8⟩.

our chaining algorithm is not heuristic, i.e., it computes an optimal chain w.r.t. the given constraints. it is based on the line-sweep paradigm and uses range maximum queries  with activation. during the line sweep procedure, the fragments are scanned w.r.t. their order in one of the genomes. if an end point of a fragment is scanned, then it is activated. if a start point of a fragment is scanned, then we connect it to an activated fragment of highest score occurring in the rectangular region bounded by the start point of the fragment and the origin. this highest-scoring fragment is found by an rmq, see figure  <dig>  for more details about our chaining algorithms; see  <cit> . in practice, variations of the basic algorithms or certain pre-processing steps are required. because these variations are specific to each application, we handle them in detail in the respective sections.

the data flow in coconut
the input to the system is a set of genomic sequences. for genome analysis, all chromosomes are input. usually, each chromosome is given as a single fasta file and one compares a combination of chromosomes at a time.  inversions can be taken into account by considering the backward strands of some chromosomes and the forward strands of the other chromosomes. in coconut, all combinations of orientations are considered by default, but the user has the option to restrict the comparison to the forward strands only. for repeat analysis, the input is a single genomic sequence in single or multiple fasta files. for cdna mapping, the user submits one genomic sequence and cdna sequences in a multiple fasta file.

each comparison consists of a fragment generation phase and a chaining phase. the fragments are usually generated by the program ramaco  <cit> , which computes rare multimems using an enhanced suffix array of one of the chromosomes. alternatively, if one does not expect too many repeats in the considered sequences , it may not be necessary to specify a rareness parameter. in such a case, one can use the program multimat  <cit>  to compute the multimems. while ramaco can also compute multimems , multimat does this more efficiently at the expense of a larger index size  the program chainer carries out the chaining phase and delivers all significant local chains, where each chain corresponds to a region of similarity.

upon completion of these two phases, coconut provides the functionality to

• visualize the resulting chains in 2d plots, or

• compute an alignment on the nucleotide level for each chain  and filter out chains with low sequence identity, or

• compute and visualize regions of high similarity, or

• perform a second chaining step with the chains of the first chaining step as new fragments.

to repeat parts of the comparison with different parameters, the user can re-start the comparison at four points:  after the index generation,  after the fragment generation,  after the first chaining step, and  after the alignment. for example, if the user has already computed the fragments and chains, then he/she could run the alignment program later, based on the stored fragments and chains. he/she could also repeat the chaining step with the stored fragments, but with different parameters.

RESULTS
finding regions of high similarity
the first two phases of coconut are  the computation of fragments  and  the computation of all significant local chains. these chains correspond to regions of high similarity, but the reader should keep in mind that the regions depend on the parameters with which the program was called. this behavior bears resemblance to the widely used program blast  <cit>  for comparing dna or protein sequences. a blast search enables a researcher to compare a query sequence with a database of sequences, and identify sequences in the database that are similar to the query sequence. the sequences delivered by blast depend on the parameters with which the program was called, and the parameter choice is very important. the following scenario shows a typical usage of blast. following the sequencing of a dna segment of functional importance in a certain species, a scientist will typically perform a blast search against genomes of related species. it is then a research hypothesis that the sequences identified by the search are in fact homologous  to the query sequence. however, because sequence similarity may arise from different ancestors  this working hypothesis must be corroborated. the same is true for coconut. the regions of high similarity identified by coconut may or may not be homologous, and an alignment of these may or may not be meaningful.

other authors use the terms synteny or syntenic regions instead of regions of high similarity. in genetics, synteny describes the physical co-localization of genetic loci on the same chromosome within an individual or species, while shared synteny describes preserved co-localization of genes on chromosomes of related species. the term shared synteny is sometimes also used to describe preservation of the precise order of genes on a chromosome passed down from a common ancestor, but many geneticists reject this use of the term. passarge et al.  <cit>  wrote: "we believe molecular biologists ought to respect the original definition of synteny and its etymological derivation, especially as this term is still needed to refer to genes located on the same chromosome. we recognize the need to refer to gene loci of common ancestry. correct terms exist: 'paralogous' for genes that arose from a common ancestor gene within one species and 'orthologous' for the same gene in different species." however, in our context, the term orthologous regions cannot be used either, simply because we cannot generally infer orthology from sequence similarity alone . because there is no "right word" yet, we will use the term regions of high similarity, although we feel that this term does not have the right connotation .

in contrast to global alignment tools , which assume global similarity, coconut can cope with genome rearrangements. it uses the three step approach depicted in figure  <dig>  the user can specify several parameters in the coconut system and a reasonable parameter choice is very important.

in the fragment generation phase, the parameter "minimum fragment length" can be set by the user, but it is usually a good idea to first use the default parameter, which is estimated based on the count statistics; see  <cit> . furthermore, the user can specify the rareness value of a fragment. the rareness parameter depends on the number of "important to see" repeated segments in the genomes, an information that cannot be determined automatically. therefore, the user has to test different rareness values. in our experiments, we found that  <dig> is a reasonable rareness value to start with.

only fragments  whose lengths exceed the minimum fragment length are generated. on the one hand, if the minimum fragment length is too small or the rareness value is too large, a large number of fragments is generated. on the other hand, if the minimum fragment length is too large or the rareness value is too small, too few fragments for a meaningful comparison may be generated.

in the chaining phase, chainer solves the all significant local chains problem. in addition, the user can specify an upper bound on the gap length between fragments in a chain. that is, two fragments can only be connected in a chain if the number of characters separating them does not exceed this user-defined maximum gap-length, which is identical for all sequences. this option prevents unrelated fragments from extending a chain. the user can also filter out chains based on their length or their score. 

the fragments of a local chain represent anchors that form the basis of the local alignment. only the regions between them must be aligned on the nucleotide level. if one compares just two genomes, the regions between the anchors are aligned by a global alignment algorithm based on standard dynamic programming. for more than two genomes, the program clustalw  <cit>  is used to align these regions. this strategy is also used in the multiple global alignment tool mga  <cit> , albeit for a single global chain.

for closely related genomes, it is recommended to increase the minimum fragment length. this usually does not affect the sensitivity of the procedure. moreover, a single chaining step is usually enough to identify regions of high similarity.

for distantly related genomes, the minimum fragment length needs to be reduced to increase the sensitivity of the comparison. this, however, has the effect that many fragments appear by chance. to identify regions of high similarity in the "noisy" fragment set, it is important to use a double-chaining strategy. in the first chaining phase, one computes chains of multimems with a stringent gap length. in the second chaining phase, the chains resulting from the first chaining step are considered as new fragments. moreover, the gap length is increased. in this way, it is possible to remove the noise without missing relevant fragments.

we exemplify these two strategies by comparing three related bacterial genomes and three distantly related mammalian chromosomes. the experiments were carried out on a sun sparc v processor with  <dig> mhz and 6gb ram.

comparing closely related bacterial genomes
we compared the three bacterial genomes e. coli, s. sonnei, and s. boydii . as a reference, we first compared the proteomes of the three genomes and obtained the best hit of all proteins encoded in three genomes. this comparison was performed using the comprehensive microbial resource web-based comparison tools  <cit> . we used the option that reports the best hits for each protein. figure  <dig>  shows the projection e. coli vs. e. sonnei in which the hits that appear on a vertical or horizontal line correspond to repeated segments in e. coli or e. sonnei encoding the same protein. 

we used coconut to compare the three genomes on the dna level. the minimum length of the fragments was between  <dig> to  <dig> and the rareness value was between  <dig> and  <dig>   in the chaining step, the maximum gap length was set to  <dig> bp. for minimum length  <dig> and rareness value  <dig>  we obtained the best results w.r.t. the reference comparison on the protein level. all chains of length less than  <dig> bp were filtered out. as can be seen in figure  <dig>  the regions containing orthologs are covered by the local chains. the remaining repeated segments visible in the dna plot, but not in the protein plot, are insertion elements that do not encode a protein.

in this comparison, there was no need for a second chaining step because regions of high similarity could easily be identified. all alignments derived from the chains show an identity of more than 70%. the whole experiment, including the computation of the multiple alignment, took a few minutes.

we applied the program mauve to the same three bacterial genomes. mauve uses fragments of the type multimums, and as shown in figure  <dig>  is not able to identify repeated segments.

comparing distantly related mammalian chromosomes
the x-chromosomes of human, mouse, and rat were compared by coconut. we used masked and unmasked sequences of the latest assemblies of the three genomes. we used the human genome version  <dig> ncbi build  <dig>  the mouse genome version  <dig> ncbi build  <dig>  and the rat x-chromosome version  <dig> rgsc v <dig>  from the ucsc genome browser. the accession numbers of the x-chromosomes of human, mouse, and rat are nc_ <dig> and nc_ <dig>  and nc_ <dig>  respectively.

as a reference, we used the biomart system  <cit>  to retrieve all orthologous proteins among the three x-chromosomes. the human x-chromosome was taken as a reference. figure  <dig>  shows the plot for the human vs. mouse x-chromosome.  each point in this plot corresponds to a protein shared in all x-chromosomes with identity larger than 25%.

we also compared our results with bourque et al.  <cit> , who identified synteny blocks and used them to compute genome rearrangement scenarios.  the synteny blocks were identified by first combining the results of all pairwise genome comparisons, and then by verifying these using all pairwise proteome comparisons.

we ran coconut using different parameters, starting with the default values. the parameters that produced good results were as follows: the minimum fragment length was  <dig> and the rareness value was  <dig>  furthermore, the gap length between two fragments in a chain was set to  <dig> bp and chains with length less than  <dig> bp were filtered out. figure  <dig>  shows the projections of the resulting chains w.r.t. the human and mouse chromosomes. 

although the results show that the regions containing the orthologous proteins are covered by coconut local alignments, it is difficult to automatically identify large regions of high similarity by visual inspection. therefore, we performed a second chaining step. in this step, the gap length between two fragments was  <dig> kbp, and chains with length less than  <dig> kbp were filtered out. the resulting chains were considered to be the regions of high similarity. the parameters were chosen to mimic the strategy of  <cit> . figure  <dig>  depicts the results of the second chaining step w.r.t. the human and mouse chromosomes.  table  <dig> in additional file  <dig> lists the exact coordinates of the regions of high similarity.

coconut can optionally filter out repetitions and coalesce the regions of high similarity into synteny blocks. the corresponding output is shown in figure  <dig> ; see table  <dig> in additional file  <dig> for the exact coordinates. a detailed analysis of the genome comparisons of the three x-chromosomes reveals that our results are very similar to the results presented in  <cit>  , except for two segments that are not in the same orientation. we attribute this difference to the fact that the genome assembly we used is a more recent one compared to  <cit> . in the new assembly, the x-chromosome sizes were modified and the orientation of two large segments in the mouse x-chromosome was corrected. . the reason why we preferred to use the new assemblies is to stimulate a follow-up study for re-estimating the rearrangements scenario using the new synteny blocks.

for masked x-chromosomes, the fragment generation and the chaining step took about  <dig> minutes, and the alignment step took about  <dig> minutes. for unmasked x-chromosomes, the fragment generation and the chaining step took about  <dig> minutes, and the alignment step took  <dig> minutes. the time for the second chaining step is a few seconds.

we can conclude from this example that the use of rare multimems permits coconut, unlike other tools such as blastz, to work with complete unmasked sequences. although the computation of rare multimems takes most of the time of the genome comparison, it is still much faster than masking and processing the sequence using other tools.

comparing two draft/multi-chromosomal genomes
in contrast to a finished genome, a draft genome consists of contigs of unknown order and orientation . unlike any other software tool, coconut can compare two draft or multi-chromosomal genomes in a single run, i.e., without the explicit comparison of all pairs of contigs/chromosomes. although there is no theoretical advantage in running the experiment at once, it is still an attractive feature, as it does not require to artificially split up a collection of sequences. less important, but worth to mention, is that it is slightly faster because the comparison runs at once in main memory, and no repeated access to the external memory for each pairwise comparison is required. the disadvantage of this feature is the increased space consumption, due to the fact that the complete sequence set is stored as an enhanced suffix array.

we proceed as depicted in figure  <dig>  but now the boundaries between the contigs/chromosomes are taken into account. more precisely, all contigs/chromosomes of each draft/multi-chromosomal genome are concatenated, but a unique separator symbol is inserted between consecutive contigs/chromosomes to represent their border. the fragments are then generated w.r.t. the concatenated sequences. this allows us to use the same line-sweep algorithm as in the basic chaining algorithm, but we have to make sure that the chains do not cross the borders between contigs/chromosomes. this can be done by restricting a range maximum query to the fragments lying in the same contig/chromosome; see figure  <dig>  regions of high similarity and synteny blocks are computed as described in the previous sections, but the contig/chromosome boundaries are taken into account.

to exemplify this, we compared the finished multi-chromosomal genome of s. cerevisiae and the draft genome of s. paradoxus. . figure  <dig> shows the result of this comparison. the plot shows a high similarity between the two genomes.  this comparison including the alignment step takes about two minutes.

identification of genomic duplications
coconut also provides a chaining based strategy that is able to locate genome duplications. this is accomplished in coconut by comparing a chromosome s with itself. in this case, each  mem s = s computed in the fragment generation phase is in fact a repeat in s with first instance s and second instance s. for the special task of finding repeats, we use the algorithm from  <cit>  for computing either maximal repeated pairs or supermaximal repeats. 

for detecting genome duplications, we use – as default – supermaximal repeats as fragments. in fact, supermaximal repeats can be regarded as rare maximal repeated pairs in which the rareness value is  <dig> . this follows from . that is, a repeated pair  is excluded if s occurs more than  <dig> times in the sequence. the use of supermaximal repeats has the advantage of skipping other abundant repeats not belonging to genome duplications, and speeding up the determination of genome structures.

to identify large segmental duplications, these repeats are chained with the basic local chaining algorithm mentioned in the implementation section, but with one extra constraint: every chain c = f <dig>  f <dig> ..., fℓ of fragments must satisfy end.x <dig> <beg.x <dig>  that is, the first instance of the last element of a chain must not overlap with the second instance of the first element of a repeat; see figure  <dig>  this constraint is necessary for detecting non-overlapping repeats.

analyzing chromosome i of a. thaliana
locating the genome duplications within chromosome i of a. thaliana  is a difficult task due to the abundance of repeated segments of different types , and rearrangements of the repeated segments. we overcame these obstacles by a double-chaining strategy. fragments of the type supermaximal repeats  were generated. these were chained with maximum gap length  <dig> bp. chains spanning less than  <dig> bp were filtered out. figure  <dig>  shows the resulting chains. note that the red points near the diagonal line correspond to tandem repeats, which are abundant in this genome. some traces of large segmental duplications can be seen in this plot. to automatically identify these, we performed a second chaining step with a gap length of  <dig> kbp. chains of length smaller than  <dig> kbp were filtered out. the result, shown in figure  <dig> , clearly reveals the genomic duplications. it is worth mentioning that our result is consistent with previous work:  <cit>  found the same large segmental duplications in the a. thaliana genome, albeit with methods that are not fully automatic. for this comparison, coconut took less than two minutes, including the computation of the alignments .

cdna mapping
an important step in gene annotation of eukaryotes is the mapping of cdna/ests to the genome. complementary dna  is obtained from mrna through reverse transcription. the cdna is a concatenation of the exons of the expressed gene, because the introns have been spliced out. while the exons are short segments ranging from tens to hundreds of base pairs, introns can span segments of many kbp. expressed sequence tags  are segments of the cdna usually obtained by sequencing their 3' and 5' ends.

the problem of cdna/est mapping is to find the gene and its exon/intron structure on the genome from which the cdna originated; see figure  <dig> 

coconut can compare one genome to a complete cdna or est database. it also provides functionality for post-processing the mapped cdna sequences . it clusters and reports the mapped cdna sequences whose positions are overlapping in the genome. this feature helps in detecting alternatively spliced genes. furthermore, coconut reports genes which are repeated in the genome.

for cdna mapping, coconut uses a variation of the chaining method which tolerates overlaps between the successive fragments of a chain. two fragments overlap if their segments overlap in one of the genomes. the rationale of allowing overlaps is twofold: first, overlapping fragments were found to be very common in cdna mapping  <cit> , and they usually occur at the exon boundaries in the cdna; see figure  <dig>  second, the amount of sequence covered by the chain will increase, which is crucial for both improving the sensitivity/specificity and for speeding-up the mapping. in  <cit> , it was shown how to optimally solve the chaining problem with overlaps in subquadratic time based solely on range maximum queries.

after computing the optimal chain of fragments, coconut computes the alignment on the nucleotide level. the alignment step is different from standard sequence alignment because of the intron-exon structure and the splice site signals at the exon boundaries. the user can either use canonical models of the splice sites or specify a position weight matrix   <cit> .

experimental results, presented in  <cit> , show that our chaining algorithms achieve better specificity with the same level of sensitivity, compared to other software tools based on a seed-and-extend strategy . moreover, the algorithms work for unmasked sequences.  other software tools based on the seed-and-extend strategy cannot efficiently handle unmasked sequences. to avoid redundancy, we refer the reader to  <cit>  for more details.

CONCLUSIONS
we have presented the software tool coconut that does not only provide functionality for whole genome comparisons  of finished genomes. it is also able to detect large scale duplications, to map a cdna/est database to a genome, and to compare draft genomes. in principle, the latter fact allows for processing the unordered sets of sequences  delivered by new sequencing technologies . however, we have not yet evaluated such an application. there are other software tools which solve one of the mentioned tasks individually but to the best of our knowledge coconut is the first software tool with such a broad spectrum of applications. this feature makes it especially attractive to users who have to solve a wide range of comparative genomics problems.

coconut uses several new algorithms developed by the authors of this article, notably an algorithm for the space efficient computation of rare multimems  <cit>  based on enhanced suffix arrays  <cit>  and new chaining algorithms  <cit> . as a consequence, coconut is fast and memory efficient, and users will certainly appreciate that it scales well for large input sizes.

availability and requirements
coconut is freely available for non-commercial users. for details and tool download, see http://toolcoconut.org. mirror site: http://www.nubios.nileu.edu.eg/tools/coconut.

project name: computational comparative genomics utility toolkit 

project home page: http://toolcoconut.org; mirror site: http://www.nubios.nileu.edu.eg/tools/coconut

operating system: unix/linux 

programming language: c, c++, perl

license: free for non-commercial purposes

any restrictions to use by non-academics: see license agreement on the tool home page

authors' contributions
eo initiated and lead the project to develop a versatile software tool for comparative genomics. the roots of the project go back to a time when all authors worked jointly at bielefeld university. all authors contributed to theoretical developments which form the basis of coconut. ma developed and tested the software, except for the programs ramaco and multimat which were implemented by sk. all authors wrote and approved the manuscript.

supplementary material
additional file 1
the coordinates of the regions of high similarity and the synteny blocks. additional file  <dig> contains the coordinates of the regions of high similarity and synteny blocks  of the  x-chromosomes of human, mouse, and rat.

click here for file

 acknowledgements
this work was supported by the deutsche forschungsgemeinschaft . we would like to thank the anonymous reviewers for valuable comments on a previous version of the article.
