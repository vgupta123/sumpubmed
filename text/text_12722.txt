BACKGROUND
the genome encodes the physiological functions and regulatory logic by which a cell interacts with its environment. therefore, visualization and exploration of genome-wide data in the context of their organization across the genome is critical to fully understand how an organism dynamically utilizes the information encoded in its genome to affect its physiology  <cit> . recent advances in whole genome tiling arrays and next-generation sequencing technologies are providing new ways to collect genome-wide data at much higher resolution than previously possible. the ability to dynamically explore and visualize these data in a flexible, interactive and informative manner will be key to understanding these data and directly linking the mechanistic information they provide with cellular physiology.

to this end, we have created the gaggle genome browser , an interactive graphical tool which enables plotting of multiple tracks of data of diverse types along the genome at multiple scales with dynamic panning and zooming. applications initially targeted are visualization of expression and protein-dna interaction from several measurement technologies including gene expression arrays, whole-genome tiling arrays, mass spectrometry, chromatin immunoprecipitation  and sequencing  for microbial genomes.

several genome browsers have existed for some time and our intention was not to duplicate previous efforts. with development of ggb, we focus on interactive exploration, easy access to user data, and interoperability, along with the ability to handle large sets of user-generated data gracefully. interoperability with the gaggle  <cit>  framework is a central feature. by connecting to the gaggle framework, the genome browser joins a suite of bioinformatics tools giving the researcher the power to analyze complex biological systems across several data types, from high-resolution gene expression to protein interactions, metabolic pathways, and much more.

implementation
the gaggle genome browser is written in the java  <cit>  programming language using the swing ui framework and the sqlite  <cit>  database engine. message passing between applications is provided by the gaggle framework. these components support the design goals of creating a cross-platform interactive graphical application that can handle large user-generated datasets, interoperate with existing tools and flexibly accommodate extension. several key features are illustrated in figure  <dig> 

data model
the program shares its basic data model with several genomics software packages. its core abstractions  are sequences, tracks and features, with a dataset composed of a collection of sequences and a collection of tracks. sequences, which may be chromosomes, plasmids, contigs or any other sequences of interest, define the coordinate system on which track data is plotted. tracks group together features from a common source. a feature is a tuple containing coordinates on the genome  augmented by additional data specific to a particular type of feature. genes, microarray probe values, peptide measurements, or protein-dna binding sites are all potentially features. in addition, datasets, sequences and tracks have attributes  which are used to assign visual properties, provenance or other information to these entities. this flexible and extensible data model means that our software is not tied to any particular format, data type, or array platform. any feature encoding data that can be related to position on the genome can be displayed in the browser.

rendering
features are drawn on the plot by an implementation of trackrenderer, an abstract class which is a key extension point of the program . visualizations are implemented by extending this class. several renderers are built into the program including those for genes, quantitative data series, and heatmaps. renderers visually encode properties of individual features using color, shape, and other cues. tracks are mapped to the user's choice of renderer by the track's attributes, which also hold other parameters used to configure the renderer. the open-ended data model for features with arbitrary key/value pairs dovetails with customizable renderers to support extension of the software with new visual representations or visualize unforeseen data types while confining code changes to a limited scope.

data access
an in-process database, sqlite, provides data storage and a command shell with a standard data manipulation language  without the need for a separate database server or the overhead of socket communication. features are stored in a database in a separate table per track to avoid restricting the types of features the program can handle. all feature tables have columns holding coordinates on the genome. additional columns may be included to represent properties such as quantitative values or statistical measures.

the main task of the program is to visualize features according to their position on the genome. doing this quickly requires an efficient flow of data from the data store to the screen, with particular attention to minimizing disk access. features are collected in tracks, which may have hundreds of thousands of features for tiling arrays or many millions for high-throughput sequencing. for large tracks, features should only be loaded into memory as needed. this is accomplished by dividing each track into contiguous blocks of features. a block may be loaded into memory and paged out as needed, providing a unit for caching and preserving a degree of locality . like individual features, blocks are keyed by their genomic coordinates, so the program can efficiently determine which blocks intersect the visible window and schedule them to be loaded. caching reduces the odds of rereading the same block repeatedly while keeping a tunable limit on memory usage.

queueing
both data access and rendering take place off the swing event dispatch thread so the user interface remains responsive to user input. data access and rendering are time-consuming and can lag behind the events generated by the ui. this mismatch of rates is handled using the queueing arrangement shown in figure  <dig>  to protect swing's event dispatch thread from long-running tasks, ggb creates a separate task queue for data access and rendering tasks. a worker thread takes tasks from this second queue, rendering to an off screen image buffer. only the copy to the display need be performed by the swing event dispatch thread.

gaggle connectivity
the genome browser is a stand-alone desktop program, but its power is multiplied when used within the gaggle framework. the gaggle framework  <cit>  provides data exchange between bioinformatics applications using a handful of universal data types which cover a wide range of use cases within the systems biology domain. gaggle data types include lists of identifiers, tuples , matrices containing numeric data, and networks.

applications become part of the gaggle framework by implementing the ability to send and receive messages containing these data types. software tools connected through the gaggle include: cytoscape  <cit> , a network viewer; mev  <cit> , an application for analysis, visualization and data-mining of large-scale genomic data; the r project  <cit>  for statistical computing; and bioinformatics resource manager  <cit> , a data management, analysis and integration environment for systems biology. firegoose  <cit> , a toolbar for the firefox browser, further extends the gaggle environment to web resources such as: kegg  <cit> , for metabolic pathways; string  <cit> , for protein interactions; and david  <cit> , for functional annotations.

the effect of gaggle connectivity is that the genome browser can focus on visualization without taking on the impossible task of reimplementing all the functionality of the various gaggle-connected resources.

architecture
the application is factored into modular components which communicate with each other through events. the application exposes an api  for use by components, plug-ins and scripting. this api is used to implement gaggle integration and forms the basis for an r package that enables control of the genome browser by commands within the r environment.

heer et al.  <cit>  present a system of software design patterns for visualization, several of which are applied in ggb. the general structure of the application loosely follows the reference model design pattern, a specialization of the model-view-controller pattern that further divides the model into the underlying data model and a visualization, a mapping onto visual properties such as color, shape, and position.

when a single track has features numbering in the tens or hundreds of millions, allocating an object for each feature is prohibitively inefficient. for this reason, features in ggb are typically flyweights  <cit> . for all features of a track, a single flyweight feature provides an object oriented interface backed by parallel arrays. an individual feature then reduces to an index into the arrays and iterating through features simply amounts to incrementing the index. thus memory is used efficiently and features nearby in the genome are also nearby in memory boosting cache locality.

software designed to meet the fluid requirements of research applications must be flexible, adapting to changing needs and a range of usage styles  <cit> . the goal of our architecture is to provide the necessary flexibility through extensibility and interoperability with a range of tools from point-and-click web resources to sophisticated environments such as r.

RESULTS
the architecture described above results in a versatile tool for visualizing genome related data. data can be imported from a wide variety of sources including the gff standard file format  <cit>  and the ucsc genome browser  <cit>  through a wizard interface. once imported, data can be visualized at multiple zoom levels and navigated by scrolling, searching, or jumping to directly to bookmarked regions of interest. computationally oriented users can leverage the powerful data manipulation features of the r statistical environment  <cit>  or sql. track data can be visualized using several renderers, including one for heatmaps and a scaling renderer that changes representation based on zoom level .

fast graphical rendering is difficult to achieve in cross-platform applications. ggb delivers frame rates sufficient for interactive visualization for datasets in our experience . leaving aside window dimensions, rendering speed depends mainly on the number of features visible in the viewing area  and the complexity of their visual representation. for example, a heatmap takes longer to draw than a line plot. rendering speed shows no discernible dependence on the size of the database or total number of features. in all cases, even when rendering slows, the program remains responsive to user input, resulting in good subjective performance. the program has been tested with datasets as large as  <dig> million features, equivalent to covering human chromosome  <dig> at single nucleotide resolution. it runs comfortably with a heap size of  <dig> mb resulting in a total memory footprint of about  <dig> mb independent of total data size. we tested the program both on a workstation class machine  and on modest hardware  finding adequate performance even on the low-end machine. further performance measurements are available on the ggb website  <cit> .

a pair of case studies demonstrate the use of the gaggle genome browser in analyzing diverse, complex and large datasets to discover biologically meaningful insights. the first focuses on a discovery of internal promoters that was made possible by extensive manual exploration and curation of the transcriptome structure in conjunction with protein-dna interactions and interactive statistical analysis in r. the second example illustrates that ggb gracefully handles  <dig> tracks of single nucleotide resolution next-generation sequencing data, with a total of over  <dig> million features in a  <dig> mb database.

case study: discovery of a conditionally active promoter inside a coding sequence of the succinate dehydrogenase operon
our genome browser was developed in conjunction with a study of the transcriptome structure of halobacterium salinarum <cit> .  transcription and protein-dna binding were measured using whole-genome tiling arrays at several time points over the growth curve. this data was used to revise computationally predicted genes and discover new protein-coding regions and non-coding rnas. a segmentation algorithm was used to find breaks in transcription defining transcription start and termination sites and operon structure. in some cases, these structures were shown to change over the growth curve revealing the dynamic nature of transcription. chip-chip data was used to relate changes in transcription to the binding of transcription factors.

an important discovery made in this study was that there is a higher than expected incidence of transcription initiation inside operons, including within the coding sequences of member genes. the discovery of these and other novel insights required the genome browser to support extensive interactive exploration of transcriptome structure changes and protein-dna interactions in context of the genome map and to integrate well with r, which was used to process raw signal data and compute derived data such as segmentation and probable binding sites. part of this analysis is reconstructed here to illustrate the features of the genome browser and its interoperability with other tools. the reader is encouraged to follow along with the detailed instructions on the gaggle website  <cit> .

in brief, we will focus on an observation that there is a growth-associated transcriptome structure change within the  <dig> gene operon for succinate dehydrogenase. we wished to investigate whether the break in transcription associated with this event coincides with the location of a transcription factor binding site  for the transcription factor tfbd. we assayed dna binding for tfbd using chromatin immunoprecipitation followed by two different whole genome tiling array platforms, an in-house array with  <dig> base-pair resolution   <cit>  and a higher resolution nimblegen tiling array . part of the intent was to test the sufficiency of the  <dig> bp array to predict binding sites.

given the low resolution of this data it is difficult to evaluate visually whether there is a statistically significant tfbd binding event in the vicinity of the putative internal promoter. the resolution to which specific binding sites in a chip-chip assay can be identified is limited by:  the resolution of the tiling microarray, and  the variable sizes of the immunoprecipitated dna fragments. together, these issues can influence the accuracy of localizing tfbss from chip-chip data. to address these technical challenges we developed medichi  <cit> , to precisely localize binding locations at a resolution higher than the tiling array probe spacing. medichi produces a model fit and peaks representing locations and intensities of predicted tfbss.

the workflow used to derive these results started with a track of chip-chip data in ggb, which was transmitted to r for analysis with medichi. products of that analysis are then transmitted back to the genome browser for visualization. data transfer was done by establishing a connection between the genome browser and r using the gaggle framework  assisted by a library of supporting functions called genome_browser_support.r.

first, a description of the dataset was broadcasted from the genome browser to r.  this descriptive data about the dataset and its tracks includes information necessary to access the genome browser's underlying database directly from within r. sharing the database between r and ggb amounts to a form of pass-by-reference which avoids pushing large data structures through gaggle's messaging protocol, efficiently passing pointers instead. the  <dig> bp resolution chip-chip track was selected by interrogating the dataset metadata  and the track data loaded into the r environment .

medichi was then applied to the chip-chip data over the genome region containing the succinate dehydrogenase operon. the genome browser's search function was used to find the coordinates of this region  for input into medichi's chip.deconv function . the two kinds of derived data from this analysis -- a profile which represents the best fit of medichi's model to the data and a list of peaks at the predicted sites of protein-dna binding -- were broadcasted back to the genome browser for visualization . the genome browser's track visual properties editor was then used to set rendering options for the new tracks .

by visualizing the raw and processed transcriptome and chip-chip data we observed a binding site for tfbd close to the 3' end of sdhb. as growth progresses, a break in the transcript for this operon appears, suggesting that there are condition-dependent alternative transcripts for this operon. based on such interactive analysis we hypothesized the presence of transcriptional promoters in at least 40% of all operons in h. salinarum nrc- <dig>  several of these were validated with promoter-gfp fusion assays. in sum, the interactive exploration of the diverse genomic datasets within ggb was crucial in formulating hypotheses that led to the discovery of extraordinary complexity in prokaryotic transcription.

case study: inspection of transcriptome structure through interactive exploration of  <dig> mb of next-generation sequencing data
passalacqua, et al.  <cit>  mapped the transcriptome of bacillus anthracis at single-nucleotide resolution using high-throughput sequencing technology . to test our ability to handle data at this density, we imported the eight tracks of single nucleotide coverage data for this  <dig>  megabase genome. as represented in the genome browser, these ~ <dig> million features occupy  <dig> mb. ggb renders this data responsively and maintains a moderate memory footprint . this visualization is shown in figure  <dig> and is available as a live demo on the gaggle website  <cit> . bookmarks annotating a region of the genome with a name and short description are included to allow quick navigation to features discussed in the paper.

because data come from instruments, public repositories and other software in a bewildering variety of formats, ggb allows users to import data using their choice of tools and scripting languages. in this example, a short python script created the sqlite data file taking as input sequence annotation data from ncbi  and coverage data provided by the authors in tab-delimited text files. the same result could have been achieved using r and gaggle or sqlite's command line shell as well as importing from formatted text files.

discussion
related work
the insight to be gained by visualizing biological data plotted along the scaffold of the genome has long been recognized. there are several established genome browsers. recent developments in both laboratory techniques and computing technologies have motivated several new entries in this category as well.

the ucsc genome browser  <cit>  and its microbial counterpart  <cit>  are the most widely known. a major asset of these popular resources is that each model organism is augmented with a rich collection of curated track data. the table browser feature  <cit>  provides user-level and programmatic access to this data making these services excellent data sources as well as visualization tools. a wizard interface to acquire chromosome layout data from these sources is built into ggb, as is a link in the right-click menu that opens the currently selected or displayed region in the ucsc genome browser, for available organisms. the ucsc genome browsers are page-based web applications in which images are generated on the server, which places some limits on interactivity. for example, pan and zoom operations require a page refresh.

rich web technologies can provide a more interactive experience with all the advantages of a remotely hosted web application. x:map  <cit>  is an impressive example, using the google maps api to interactively scroll and zoom through pre-rendered image tiles. jbrowse  <cit>  demonstrates the efficiency of ajax based client-side rendering. like its predecessor gbrowse  <cit> , jbrowse is backed by the bioperl library. web applications benefit from handling data and cpu intensive operations on the server. however, requiring users to upload their own data to another institution's server has implications for security and bandwidth. even so, a rich web implementation remains an appealing option especially one taking advantage of the enhanced vector graphics capabilities of flash, svg or html <dig> 

our choice to build the ggb as a desktop application was largely motivated by the need to support large user-generated datasets. java was chosen to complement other gaggle tools and for cross-platform support. other desktop genome browsers also implemented in java include the apollo genome annotation curation tool  <cit> , which was used to annotate the fly genome. affymetrix released the integrated genome browser   <cit>  and the supporting genoviz sdk  <cit>  as open-source projects. the broad institute provides argo  <cit>  and igv   <cit> . the recently published mochiview  <cit>  is an excellent tool which integrates support for motif detection based on chip data. both igv and mochiview emphasize handling of high-density data types.

the central distinguishing feature of ggb is gaggle integration, which offers a wealth of options for exploring different types of data in relation to location on the genome. also, ggb's flexibility in track rendering enables visualizations that would be difficult to reproduce using any other software. this flexibility derives mainly from a variety of customized renderers and a free-form approach to laying out tracks. multiple data series may be drawn on top of each other or partially overlapping, using transparency and z-order to convey additional information. finally, ggb offers a point-and-click wizard for creating a new project based on any genome curated by ucsc. a similar feature using ncbi as a data source is under development.

future directions
ggb remains a work in progress. various directions for future development are under consideration, dependent on user demand. primarily, ggb is designed to be ready for extension in the kinds of visualizations and the data types being visualized as well as additional avenues of interoperability.

a feature currently lacking is the ability to work directly with sequence data. directly storing and looking up sequence data is one option, but we hope that integration, through gaggle or other mechanisms, with existing applications may serve this purpose. we also do not display exons, given the emphasis in our own research on microbes. new data types and renderers supporting exon display could be implemented through existing extension points.

interoperability is a particular emphasis in our development efforts. building on gaggle integration, we are prototyping a library of r functions for communicating with ggb. further developing this library could help computational scientists use the sophisticated analysis and data manipulation capabilities of r and bioconductor  <cit>  together with visualization in the genome browser. for other users, enhanced point-and-click import of data from widely used sources such as the ucsc genome browser, ncbi entrez  <cit> , or das   <cit>  would be most important. extending these mechanisms would allow the software to be applied to a larger variety of organisms and to more easily take advantage of the wealth of existing resources.

to address rendering performance in zoomed out views, where data points greatly outnumber the pixels available in which to display them, our scaling renderer aggregates features during rendering by computing ranges and means. precomputing these aggregates at predefined scales could further increase performance. buffering and reusing previously rendered image tiles would decrease cpu load while increasing opportunities for parallelism.

CONCLUSIONS
ggb provides the researcher with an interactive visualization tool for any data type that can be related to a location on the genome. through the gaggle framework, ggb can function as part of a powerful suite of bioinformatics tools able to exchange data with analysis software, other visualizations, and several public data sources.

biological data can be joined together along several axes. expression, interactions, and functions can be merged by gene or protein identifiers. sequence similarity can form the basis of mapping data across organisms by orthology. in the gaggle genome browser, heterogeneous data is joined by its location on the genome to create information-rich visualizations yielding insight into transcription and its regulation and, ultimately, a better understanding of the mechanisms that enable the cell to dynamically respond to its environment.

availability and requirements
the gaggle genome browser is written in java  and depends on the sqlite database engine. it runs on linux, mac os x, and windows, either as a stand-alone application or by web-start. we recommend a minimum screen resolution of  <dig> Ã—  <dig> and at least  <dig> gb of memory.

the program and its source code are released under the terms of the lgpl http://www.gnu.org/copyleft/lesser.html and are available on the gaggle web site  <cit> . demos, documentation and forms for submitting bug reports and feature requests are also linked from this page.

authors' contributions
jcb designed and implemented the software and drafted the manuscript. tk performed the characterization of the h. salinarum transcriptome that led to the case study. djr performed the analysis of the h. salinarum transcriptome that led to the case study and assisted in r and medichi integration. dt reviewed software design. nsb conceived and initiated the project, provided direction and feedback on the quality of results and software design and crafted the case study and drafted the manuscript. all authors reviewed and approved the manuscript and reviewed early versions of the software.

