BACKGROUND
phylogenetic trees represent the evolutionary relationships of organisms. while recent advances in genomic sequencing technology and computational methods have enabled construction of extremely large phylogenetic trees , assessing the support for phylogenetic hypotheses, and ultimately identifying well-supported relationships, remains a major challenge in phylogenetics. support for a tree often is determined by methods such as nonparametric bootstrapping  <cit> , jackknifing  <cit> , or bayesian mcmc sampling , which generate a collection of trees with identical taxa representing the range of possible phylogenetic relationships. these trees can be summarized in a consensus tree . consensus methods can highlight support for specific nodes in a tree, but they also may obscure highly supported subtrees. for example, in figure  <dig>  the subtree containing taxa a, b, c, and d is present in all five input trees. however, due to the uncertain placement of taxon e, the majority rule consensus tree implies that the clades in the tree have relatively low  support.

alternate approaches have been proposed to reveal highly supported subtrees. the maximum agreement subtree  problem seeks the largest subtree that is present in all members of a given collection of trees  <cit> . for example, in figure  <dig> the mast includes taxa a, b, c, and d. finding the mast is an np-hard problem  <cit> , although efficient algorithms exist to compute the mast in some cases . in practice, since any difference in any single tree will reduce the size of the mast, the mast is often quite small, limiting it usefulness.

a less restrictive problem is to find frequent agreement subtrees , or subtrees that are found in many, but not necessarily all, of the input trees . in this problem, a subtree is declared as frequent if it is in at least as many trees as a user supplied frequency threshold. several algorithmic approaches have been suggested to identify fasts, and specifically the maximum fasts , or fasts that contain the largest number of taxa. a variant of this problem seeks the maximal fasts, i.e., fasts that are not contained in any other fasts. notice that an mfast is a maximal fast, however, the inverse is not necessarily true. zhang and wang defined algorithms, implemented in phylominer, to identify fasts from a collection of phylogenetic trees  <cit> . these algorithms are guaranteed to find all fasts but they may be prohibitively slow for data sets larger than  <dig> taxa. cranston and rannala implemented metropolis-hastings and threshold accepting searches to identify large fasts from a bayesian posterior distribution of phylogenetic trees  <cit> . this approach can handle thousands of input trees but it may not be feasible if the trees have more than  <dig> taxa  <cit> .

another approach to reveal highly supported subtrees from a collection of trees is to identify and remove rogue taxa, or taxa whose position in the input trees is least consistent. recently, several methods have been developed that can identify and remove rogue taxa from collections of trees with thousands of taxa  <cit> . however, unlike mast or fast approaches, they do not provide guarantees about the support for the remaining taxa.

in this paper, we describe a heuristic approach for identifying mfasts in collections of trees. unlike previous methods, our method easily scales to datasets with over a thousand taxa and hundreds of trees. towards this goal, we develop a heuristic solution that works in multiple phases. in the first phase, it identifies small candidate subtrees from the set of input trees which serve as the seeds of larger subtrees. in the second phase, it combines these seeds to build larger candidate mfasts. in the final phase, it performs a post processing step. this step ensures that the size  of the fast found can not be increased further by adding a new taxon without reducing its frequency below a user supplied frequency threshold. we demonstrate that this heuristic can easily handle data sets with  <dig> taxa. we test the effectiveness of these approaches on simulated data sets and then demonstrate its performance on large, empirical data sets. although our heuristic does not guarantee to find all mfasts or the largest mfast in theory, it found the true mfast in all of our synthetic datasets where we could verify the correctness of the result. it also performed well on the empirical data sets. its performance is robust with respect to the number of input trees and the size of the input trees.

methods
in this section we describe our method that aims to find maximum frequent agreement subtrees  in a given set of m phylogenetic trees t= {t <dig>  t <dig>  …, tm}. our method follows from the observation that an mfast is present in a large number of trees in t. the method builds mfasts bottom up from small subtrees of taxa in the trees in t. briefly, it works in three phases. 

• phase  <dig>  seed generation .in the first phase, we identify small subtrees from the input trees that have a potential to be a part of an mfast. we call each such subtree a seed.

• phase  <dig>  seed combination .in the second phase, we construct an initial fast by combining the seeds found in the first phase.

• phase  <dig>  post processing .in the third phase, we grow the fast further to obtain the maximal fast that contains it by individually considering the taxa which are not already in the fast. we report the resulting maximal fast as a possible mfast.

first, we present the the basic definitions needed for this paper in section “preliminaries and notation”. we then discuss each of the three phases above in detail.

preliminaries and notation
in this section, we present the key definitions and notations needed to understand the rest of the paper. we describe our method using rooted and bifurcating phylogenetic trees. however, our method and definitions can easily be applied to unrooted or multifurcating trees with minor or no modifications. also, we assume that all the taxa are placed at the leaf level nodes of the phylogenetic tree, and all the internal nodes are inferred ancestors. figure  <dig> shows a sample phylogenetic tree built on five taxa. we define the size of a tree as the number of taxa in that tree. we start by defining key terms.

definition  <dig> 
let t be a phylogenetic tree. given an internal node of t, we define the set of all nodes and edges of t contained under that node as the clade rooted at that node.

each internal node of a phylogenetic tree corresponds to a clade of that tree. figure  <dig> depicts the clade of the tree in figure  <dig> rooted at x <dig> 

definition  <dig> 
let t be a phylogenetic tree with n taxa. the contraction operation transforms t into a tree with n− <dig> taxa by removing a given taxon in t along with the edge that connects that taxon to t.

the contraction operation can extract the clades of a tree by removing all the taxa that are not a part of that clade. it can also extract parts of the tree that are not necessarily clades. we use the term subtree to denote a tree that is obtained by applying contractions to arbitrary set of taxa in a given tree. formal definition is as follows.

definition  <dig> 
let t and t’ be two phylogenetic trees. we say that t’ is a subtree of t if t can be transformed into t’ by applying a series of contractions on t.

if a tree t’ is a subtree of another tree t, we say that t’ is present in t. notice that a clade is always a subtree, but the inverse is not true all the time. figures  <dig> and  <dig> illustrate two subtrees of the tree in figure  <dig>  let us denote the number of combinations of k taxa from a set of n taxa with nk. in general, if a tree has n taxa, then that tree contains nk subtrees with k taxa. as a consequence, that tree contains 2n −  <dig> subtrees of any size including itself.

definition  <dig> 
let t = {t <dig>  t <dig>  … , tm} be a set of m phylogenetic trees and t be a phylogenetic tree. let us denote the number of trees in t at which t is present with the variable m’. we define the frequency of t in t as 

 freq=m′m. 

definition  <dig> 
let t = {t <dig>  t <dig>  … , tm} be a set of m phylogenetic trees and t be a phylogenetic tree. let γ be a number in  <cit>  interval that denotes frequency cutoff. we say that t is a frequent agreement subtree  of t if its frequency in t is at least γ ≥γ).

we say that a fast is maximal if there is no other fast that contains all the taxa in that fast. clearly, larger fasts indicate biologically more relevant consensus patterns. the following definition summarizes this.

definition  <dig> 
let t = {t <dig>  t <dig>  …, tm} be a set of m phylogenetic trees. let γ be a number in  <cit>  interval that denotes frequency cutoff. a fast t of t is a maximum frequent agreement subtree  of t if there is no other fast t’ of t that has a larger size than t.

formally, given a set of phylogenetic trees t = {t <dig>  t <dig>  …, tm} and a frequency cutoff, γ, we would like to find the mfasts in t in this paper. we develop an algorithm that aims to solve this problem. table  <dig> lists the variables used throughout the rest of this paper.

phase one: seed generation
the first phase extracts small subtrees from the given set of trees. from these subtrees we extract the basic building blocks which are used to construct mfasts. we call these building blocks seeds. conceptually each seed is a phylogenetic tree that contains a small subset of the taxa that make up the trees in t. we characterize each seed with three features that are listed below. we elaborate on each feature later in this section. 

 <dig>  seed size  is the number of taxa in the seed.

 <dig>  number of contractions  is the number of taxa we prune from a clade taken from an input tree in order to extract the seed.

 <dig>  frequency  is the fraction of input trees in which the seed is present.

we explain the seed features with the help of figures  <dig> and  <dig>  the first two characteristics explain how a seed can be found in one of the trees in t. they indicate that there is a clade of a tree in t such that this clade contains k + c taxa and it can be transformed into that seed after c contractions from that clade. for instance in figure  <dig>  when k =  <dig> and c =  <dig>  only seed s <dig> can be extracted from t <dig> by choosing the clade rooted at x <dig>  when k =  <dig> and c =  <dig>  seeds s <dig>  s <dig> and s <dig> can be obtained using one contraction  from the clade rooted at x <dig> 

the last feature denotes the number of trees in t in which the seed is present. for example in figure  <dig>  there are nine seeds s <dig>  s <dig>  …, s <dig> extracted from the three input trees using only one contraction. among these, the frequency of s <dig> is  <dig> as it is present in all the trees. frequency of s <dig> is about  <dig>  for it is present in only two out of three trees . the frequency of the rest of the seeds is only about  <dig> . recall that, by definition, an mfast is present in at least a fraction γ of the trees in t. therefore, we consider only the seeds whose frequency values are equal to or greater than this number .

given the values of k, c and γ, we extract all the seeds which possess the desired feature values from the set of input trees as follows. in the newick string representation of a tree, a pair of matching parentheses corresponds to an internal node in the tree. the number of taxa in the clade rooted at this internal node is given by the number of labels between the two matching parentheses. following from this observation, we scan the newick string of each tree one by one. for each such tree, we identify the clades which have k + c taxa. notice that, if a tree contains n taxa, then it contains at most nk+c clades of size k + c as no two such clades can contain common taxa. we then extract all combinations of k taxa from each of these clades by contracting the remaining c taxa. the number of ways this can be done is k+cc. notice that all the small trees extracted this way possess the first two characteristics explained above. at this point, we however do not know their frequencies. therefore, we call them potential seeds. it is worth mentioning that the same seed might be extracted from different trees. as we extract a new potential seed, before storing it in the list of potential seeds, we check if it is already present there. we include it in the potential seed list only if it does not exist there yet. otherwise, we ignore it. this way, we maintain only one copy of each seed.

once we build our potential seed list for all the trees in t, we go over them one by one and count their frequency in t as the fraction of trees that contain them. we filter all the potential seeds whose frequencies are less than the frequency cutoff. we keep the remaining ones as the list of seeds along with the frequency of each seed.

in figure  <dig>  consider the tree t <dig> that has four taxa. for k =  <dig> and c =  <dig>  there is only one clade of size k + c =  <dig> which is the tree t <dig> itself. we extract four potential seeds, each having three leaves from this tree. the potential seeds in this figure are given by s <dig>  s <dig>  s <dig> and s <dig> which we extract by contracting a <dig>  a <dig>  a <dig> and a <dig> respectively from t <dig> 

phase two: seed combination
at the end of the first phase, we obtain a set of frequent seeds from the input trees. notice that each seed is a fast as each seed is present in sufficient number of trees specified by γ. these seeds are the basic building blocks of our method. in the second phase of our method, we combine subsets of these seeds to construct larger fasts.

we first define what it means to combine two seeds. in order to combine two seeds, it is a necessary condition that both seeds are present in at least one common tree t in t. we call such a tree t as the reference tree. we combine two seeds with the guidance of a reference tree. let s <dig> and s <dig> be two seeds and let t be their reference tree. let l <dig>  l <dig> and l be the set of taxa in s <dig>  s <dig> and t respectively. combining s <dig> and s <dig> results in the tree that is equivalent to the one obtained by contracting the taxa in l −  from t. for simplicity, we will denote the combine operation using t as the reference network with the ⊕t symbol. for instance we denote combining s <dig> and s <dig> with t being the reference tree as s1 ⊕ ts <dig>  to simplify our notation, whenever the identity of the reference tree is irrelevant, we will use the symbol ⊕ instead of ⊕t.

so far, we have explained how to combine two seeds s <dig> and s <dig> using a reference tree. it is possible that many trees in t have both seeds present in them. thus, one question is which of these trees should we use as the reference tree to combine the two seeds? the brief answer is that all such trees need to be considered. however, we make several observations that helps us avoid combining s <dig> and s <dig> using each such reference tree one by one exhaustively without ignoring any of such trees. we explain them next.

consider two trees t <dig> and t <dig> from t where both seeds are present in. there are two cases for t <dig> and t <dig>  

• case 1: s1 ⊕t1s2 = s1 ⊕t2s <dig>  in this case, it does not matter whether we use t <dig> or t <dig> as the reference tree. they will both lead to the same combined subtree. thus, we use only one.

• case 2: s1 ⊕t1s2 ≠ s1 ⊕t2s <dig>  in this case, the trees t <dig> and t <dig> lead to alternative combination topologies. so, we consider both of them separately.

we utilize the observations above as follows. we start by picking one reference tree arbitrarily. once we create a combined subtree using that tree, we check whether that subtree is present in the remaining trees in t. we mark those trees that contain it as considered for reference tree and never use them as reference for the same seed pair again. this is because those trees fall into the first case described above. this way, we also store the frequency of the combined subtree in t. if the number of unmarked trees is too small  then it means that even if all the remaining trees agree on the same combined topology for the two seeds under consideration, they are not sufficient to make it a fast. thus, we do not use any of the remaining trees as reference for those two seeds. otherwise, we pick another unmarked tree arbitrarily and repeat the same process until we run out of reference trees.

the next question we need to answer is which seed pairs should we combine? to answer this question we first make the following proposition.

proposition 1
assume that we are given a set of phylogenetic trees t. let s <dig> and s <dig> be two seeds constructed from the trees in t. for all trees t∈t, we have the following inequality 

 freq≤min{freq,freq} 

proof
for any t, both s <dig> and s <dig> are subtrees of s <dig> ⊕ts <dig>  thus if s <dig> ⊕ts <dig> is present in a tree, then both s <dig> and s <dig> are present in that tree. as a result, freq ≤ freq and freq ≤ freq. hence, 

 freq≤min{freq,freq} 

 □

proposition  <dig> states that as we combine pairs of seeds to grow them, their frequency monotonically decreases. this suggests that it is desirable to combine two seeds if both of them have large frequencies. this is because if one of them has a small frequency, regardless of the frequency of the other, the combined tree will have a small frequency. as a result its chance to grow into a larger tree through additional combine operations gets smaller. following this intuition, we develop two approaches for combining the seeds. 

 <dig>  in-order combination .

 <dig>  minimum overlap combination .

both approaches accept the list of seeds computed in the first phase as input and produce a larger fast that is a combination of multiple seeds. both of them also assume that the list of input seeds are already sorted in decreasing order of their frequencies. we discuss these approaches next.

in-order combination
the in-order combination approach follows from proposition  <dig>  it assumes that the seeds with higher frequencies have greater potential to be a part of an mfast. it exploits this assumption as follows, first it picks a seed as the starting point to create a fast. it then grows this seed by combining it with other seeds starting from the most frequent one as long as the frequency of the resulting tree remains at least as large as the given cutoff γ. it repeats this process by trying each seed as the starting point, algorithm algorithm  <dig> in order combination presents this approach.

algorithm  <dig> in order combination
fast ← ∅

for all seeds sido

fast′ ← si

mark si as considered

repeat

sj ← seed with highest frequency among unconsidered seeds mark sj as considered cutoff ← γt_fast′ ← fast′

repeat

pick the next unconsidered tree t∈t as reference

mark all the trees as that contain fast′ ⊕tsj as considered

if freq≥ cutoff then

t_fast′ ← fast′ ⊕tsj

cutoff ← freq

end if

until less than γ × m unmarked reference trees are left in t

fast′←t_fast′

unmark all trees in t

until all seeds are considered

if size of fast′ ≥ size of fastthen

fast ← fast′

end if

unmark all seeds

end for

in algorithm algorithm  <dig> in order combination we first initialize the fast as empty. we then consider each seed one by one. we initialize a temporary subtree denoted by fast’ with the seed si under consideration and mark si as considered. we combine the fast’ with a seed sj which has the highest frequency amongst the seeds that have not been added. if multiple seeds have the highest frequency, we randomly pick one of them and mark that seed sj as added to the fast’. there can be alternative ways to combine fast’ with sj leading to different topologies. we use the trees in t that contain both fast’ and sj as guides to try only the topologies that exist in t. we stop constructing alternative topologies as soon as we ensure that there are not sufficient number of trees to yield frequency of γ. we set fast’ to the combined seed if the combined seed has large enough frequency. we then consider the seed with the next highest frequency for addition and repeat this step till all sj have been considered. if the resulting temporary fast is larger than fast we replace the smaller fast with the larger one. in the next iteration, we initialize the fast with the next si. using this approach we can initialize the fast with all si, alternatively if the user wishes to limit the amount of time spent using a maximum time cutoff  we stop the outermost loop  as soon as the allowed running time budget is reached.

notice that in algorithm  <dig> each seed si can lead to a different fast. we record only the fast that has the largest size. however, it is trivial to maintain the top k fasts with the largest size instead if the user is looking for k alternative maximal fasts.

minimum overlap combination
the purpose of combining seeds is to construct a fast that is large in size. our in-order combination approach  aimed to maximize the frequency of the combined seeds. in this section, we develop our second approach, named minimum overlap combination. this approach picks seeds so that their combination produced as large subtree as possible. we elaborate on this approach next.

when we combine two seeds, the size of the resulting tree becomes at least as big as the size of each of these seeds. formally let s <dig> and s <dig> be two seeds . let l <dig> and l <dig> be the set of taxa combined in s <dig> and s <dig>  we denote the size of a set, say l <dig>  with |l1|. the size of the tree resulting from combination of s <dig> and s <dig> is |l1| + |l2| − |l1 ∩ l2|. for a given fixed seed size, the first two terms of this formulation remains unchanged regardless of the seed. the last term determines the growth in the size of the fast. thus, in order to grow the fast rapidly, it is desirable to combine two frequent subtrees with a small number of common taxa.

our second approach follows from the observation above. we introduce a criteria called the overlap between two subtrees as the number of taxa common between them. our minimum overlap combination approach works the same as algorithm algorithm  <dig> in order combination with a minor difference in selecting the seed sj that will be combined with the current temporary fast . rather than choosing the seed with the largest frequency, this approach chooses the one that has the least overlap with fast’ among all the unconsidered and frequent seeds. if multiple seeds have the same smallest overlap, it considers the frequency as the tie breaker and chooses the one with the largest frequency among those.

phase three: post-processing
so far we described how to obtain seeds  and how to combine them to construct fast . the two approaches we developed for combining seeds aim to maximize the size of fast. however, they do not ensure the maximality of the resulting fast. there are two main reasons that prevent our seed combining algorithms from constructing maximal fast. first, some of the taxa of a maximal fast may not appear in any seed . as a result no combination of seeds will lead to that maximal fast. second, even if all the taxa of a maximal fast are parts of at least one seed, our algorithms will reject combining that seed with the fast of the seeds if those seeds contain other taxa that are not part of the maximal fast .

in the post-processing phase, we tackle above-mentioned problem. algorithm  <dig> describes the post processing phase in detail. we do this by considering all taxa which are not already present in the fast one by one. we iteratively grow the current fast by including one more taxon at a time if the frequency of the resulting fast remains at least as large as the frequency cutoff γ. we repeat these iterations until no new taxon can be included in the fast. thus the resulting fast is guaranteed to be maximal.

algorithm  <dig> post processing
input = fast from the seed combination phase

input = t

output = maximal fast

result ← fast

for all ai not in fast do

cutoff ← γ

t_result ← result

repeat

pick the next unconsidered tree t∈t as reference

result’ ← result ⊕tai

mark all the trees that contain result’ as considered

if frequency of result’ ≥ cutoff then t_result ← result’ cutoff ← frequency of result’

end if

until less than γ × m unmarked reference trees are left in t

result ← t_result

unmark all trees in t

end for

return result

we expect the post processing step to identify quickly the taxa that have a potential to be in an mfast that might have not been considered during the seed generation and seed combination phases. at the end of the post processing step we obtain an mfast.

complexity analysis of our method
in this section we discuss the complexity of our method in terms of the three phases involved in it. let t be a set of m phylogenetic trees having n leaves each. the complexity of the different phases of our method are as follows.

phase one
finding the seeds involves enumerating all the subtrees and checking their frequencies. given seed size k and number of contractions c, each tree will contain at most nk+c clades each leading to k+cc alternative subtrees. thus, in total there can be up to mnk+ck+cc seeds  from all the trees in t. typically, the values of k and c are fixed and small  leading to o seeds.

the complexity of finding whether a seed is present in a single tree is o. given that there are m trees in t, the cost of computing the frequency of a single seed is o. thus, the time complexity for finding the frequency of all the seeds is this expression multiplied by the number of seeds, which is o.

phase two
consider a set of p frequent seeds that will be considered for combining in this phase. recall that we have two approaches to combine them. below, we focus on each.

inorder combination we try to combine each seed with every other seed leading to o iterations. the complexity of checking the frequency of each combined subtree is o. also, there can be up to o different reference trees for guiding the combine operation. multiplying these terms, we obtain the complexity of phase using this approach as o.

minimum overlap combination the complexity of combining the frequent seeds using the minimum overlap combination approach is very similar to the inorder approach except for an additional term. the additional complexity is because we maintain the overlap between the subtrees. this leads to the complexity o.

phase three
here, we consider the fast obtained from each of the p frequent seeds in phase two. for each fast, we sequentially go over each taxa one by one leading to o iterations. there can be up to o references to add a taxon. so the cost of extending all p fasts is o.

notice that each frequent seed has to appear in at least γ × m trees. thus, the number of unique frequent seeds p is bounded by o= o. thus, adding the cost of all the three phases, the overall time complexity of our method using inorder combination is 

 o. 

that using minimum overlap combination is 

 o. 

in the two summations above, the second term is asymptotically larger than the first and the last terms. thus, we can simplify the asymptotic time complexity of inorder and minimum overlap combinations as 

 o 

 and 

 o) 

 respectively.

RESULTS
this section evaluates the performance of our mfast algorithm experimentally.

implementation details
we implemented our mfast algorithm using c and perl. more specifically, we implemented the first two phases  in c and the third phase  in perl. we utilize the functions provided in the newick utilities  <cit>  package by modifying the source code provided in that package. we use k ∈ { <dig>   <dig>  5} and c ∈ { <dig>   <dig>   <dig>   <dig>   <dig>  5} in all of our experiments unless otherwise stated. in our experiments, we observed that the minimum overlap combination produced larger mfasts than the in-order combination approach. therefore, we limit our experimental results to the minimum overlap combination approach.

methods compared against
we have compared our method against phylominer  <cit>  and the mast command implemented in paup*  <cit> . among these, phylominer also seeks mfasts in a collection of trees. however, the time complexity of this method is exponential in the size of the input trees, and hence it becomes intractable for large trees. in our experiments, we observed that it does not scale beyond  <dig> taxa. paup* is primarily a program for phylogenetic inference, although it also can compute masts. masts have a strict 100% agreement criterion unlike the arbitrary frequency cutoff values γ in our method.

evaluation criteria
we evaluate our algorithm based on the size of the mfast found. larger mfasts are preferable. when possible, we report the size of the optimal solution as well.

test environment
we ran our experiments on linux servers equipped with dual amd opteron dual core processors running at  <dig>  ghz and  <dig> gb of main memory to test the performance of our method.

datasets
we test the performance and verify the results of our method on synthetic datasets and real datasets. 

• synthetic dataset we built synthetic datasets in which we embedded an mfast as described below. we characterize each synthetic dataset using five parameters. the first two parameters denote the size and number of trees in t. mfast frequency specifies the fraction of trees in t which contain an mfast. mfast size is the number of taxa in the embedded mfast. the noise percentage is the percentage of taxa that is not a part of the embedded mfast but is placed on the branches within the clade that contains the mfast. we place all the other taxa on the branches outside this clade.given an instantiation of these parameters, we first created a tree that has n’ taxa. this tree serves as the mfast. we then created m × f trees that contain this mfast. we build each of these trees by inserting n − n′ taxa randomly in the mfast. with probability ∊ we insert each taxa within the clade that contains mfast. with probability 1 − ∊ we insert it outside that clade. we then created m −  trees that do not contain the current mfast. we simply do this by inserting all the taxa one by one at a random location.

 <dig>  tree size .

 <dig>  number of trees .

 <dig>  mfast frequency .

 <dig>  mfast size .

 <dig>  noise percentage .

• real datasets. we use two empirical datasets to evaluate the performance of our heuristic. the data sets contain  <dig> bootstrap trees generated from phylogenetic analysis of the gymnosperm  <cit>  and saxifragales  plant clades. to make the bootstrap trees, we assembled super-matrices, matrices of concatenated gene alignments with partial taxon overlap, from gene sequence data available in genbank. we performed a maximum likelihood bootstrap analysis on each super-matrix using raxml v.  <dig> . <dig>  <cit> . the gymnosperm trees each contain  <dig> taxa, and the saxifragales trees each contain  <dig> taxa.

effects of number of input trees
in our first experiment, we analyze how the number of input trees in t affects the performance of our algorithm. for this purpose, we created  <dig> synthetic datasets. the size of the embedded mfast in all the datasets was  <dig>  among these  <dig> datasets,  <dig> contained  <dig> trees,  <dig> contained  <dig> trees and  <dig> contained  <dig> trees. we set the noise percentage to 20% in all the datasets. the frequency of the embedded mfast was  <dig> . we set the number of taxa in all the trees in these datasets to  <dig> 

we ran our algorithm on each of these datasets to find the size of the mfast for γ =  <dig> . table  <dig> lists the average mfast size we found for each of the dataset sizes before post processing  and after post processing . the results demonstrate that our method can identify an mfast that is almost as big as the embedded one even without post processing, regardless of the number of trees in the dataset. post processing improves the mfast size slightly. on the average, we always find an mfast that is as large as or larger than the embedded one. an mfast larger than  <dig> here implies that while randomly inserting the taxa that are not in the embedded mfast, at least one of them was placed under the same clade at least a fraction γ of the time. more importantly, our method successfully located such taxa along with the rest of the mfast.

the number of trees is set to  <dig>   <dig> and  <dig>  for each number of trees we run our experiments on ten datasets. each dataset contains trees with  <dig> taxa and an embedded mfast of size  <dig>  we report the average size of the mfast obtained by our method across the ten datasets.

effects of tree size
our second experiment considers the impact of the number of taxa in the input trees contained in t on the success of our method. to carry out this test, we built datasets with varying tree sizes . particularly, we used n =  <dig>   <dig>   <dig> and  <dig>  for each value of n, we repeated the experiment  <dig> times by creating  <dig> datasets with the same properties. in all datasets, we set the number of trees to m =  <dig>  the noise percentage at ∊ = 20%, the size of the embedded mfast at 15% of n, and the mfast frequency at  <dig> .

the tree size is set to  <dig>   <dig>   <dig> and  <dig>  for each tree size we run our experiments on ten datasets. each dataset contains  <dig> trees with an embedded mfast of size 15% of the input tree size. second column shows the embedded mfast size. last two columns list the average size of the mfast found by our method across the ten datasets.

the results also suggest that our method identifies a significant percentage of the taxa in the embedded mfast after the second phase  when the tree size is small. as the tree size grows, it starts missing some taxa at this phase. it however recovers the missing taxa during the post-processing phase even for the largest tree size. this indicates that at the end of phase two our method could identify a backbone of the actual mfast. the unidentified taxa at this phase are scattered throughout the clades in the input trees. thus, there is no clade of size k + c that contains them with c contractions for small k or c. as evident from table  <dig>  this however does not prevent our method from recovering them. this is because the backbone reported at the end of phase two is large enough, and thus specific enough, to recover the missing taxa one by one in the last phase. this is a significant observation as it demonstrates that our method works well even with small values of k and c.

effects of noise percentage
recall that the noise percentage ∊denotes the percentage of taxa that is added inside the clade that contains the mfast. as ∊increases, the pairs of taxa in the mfast get farther away from each other in the tree that contains it. as a result, fewer taxa from mfast will be contained in small clades of size k + c. this raises the question whether our method works well as ∊increase and thus the mfast taxa gets scattered around in the trees that contain it.

in this experiment, we answer the question above and analyze the effect of the noise percentage on the success of our method. we create synthetic datasets with various ∊ values. particularly, we use ∊ =  <dig>   <dig> and 60%. we set the size of the embedded mfast to n′ =  <dig>  the tree size to n =  <dig>  number of trees to m =  <dig> and the mfast frequency to f =  <dig> . we repeat our experiment for each parameter  <dig> times by recreating the dataset randomly using the same parameters. we set the frequency cutoff to γ =  <dig> . we report the average mfast size found by our method in table  <dig> 

the size of the embedded mfast in all the experiments is  <dig>  we list the average size of the mfast found by our method before and after the post processing phase.

the results suggest that our method can identify the embedded mfast successfully even when the noise percentage is very high. we observe that the size of the mfast found by our method before post processing decreases slowly with increasing amount of noise. this is not surprising as the taxa contained in the embedded mfast gets more spread out  in the trees in t with increasing noise. as a result, if there are taxa that are not part of any seed with the provided values of k and c, they will never be included in the computed mfast at the end of phase two. we however observe that  only a small number of such taxa exists. for instance, even for the largest noise percentage , only  <dig>  taxa  are missing on the average.  the missing taxa are recovered during phase three. this is because the computed mfast at the end of phase two is very large, and thus it is specific to the embedded mfast.

impact of seed creation
so far, in our experiments we consistently observed two major points for all the parameter settings :  our method always finds a large subtree of the embedded mfast after phase two.  our method always recovers the entire embedded mfast after phase three. the second observation can be explained from the first one that the outcome of phase two is large enough to build the entire mfast precisely. the first observation however indicates that the set of seeds generated in phase one contain a significant percentage of the taxa in the embedded mfast. in this section, we take a closer look into this phenomenon and explain why this is the case even for small values of seed size k and contraction amount c, and large noise percentage ∊. to do that, we will compute the probability that a subset of the taxa of the embedded mfast appears in at least one seed generated in phase one. in our computation, we will assume that the taxa can appear at any location of a given tree with the same probability. we discuss the implication of this assumption later in this section.

the number of rooted bifurcating trees for a given set of n taxa is 

 r=!2n−2!. 

consider a clade with k + c taxa. the number of trees with n taxa that contains this clade is r + 1) as the topology of the k + c sized clade is fixed. for a given a subtree with k taxa, let us denote the number of clade topologies of size k + c that contains that subtree with nu. we can compute this function recursively as nu =  <dig> and for c >  <dig>  

 nu=nu×2×. 

let us denote one of these clades by u. also, let us denote the probability that the clade u exists in a random tree topology that contains n taxa with p. intuitively, p is the probability that our method will extract a specific k taxa subtree from one n taxa tree after only c contractions. we can compute this probability as the ratio of the number of tree topologies that satisfy this constraint to that of all possible tree topologies. we formulate this as 

 p=nu×r+1)r. 

recall that it suffices for our algorithm to have a k taxa subtree of the mfast in at least one tree in the given set of m trees. the probability that the clade u exists in at least one of the m random tree topologies each containing n taxa is 

 p=1−)m. 

assume that the mfast size in the given set of trees t is h. let us denote the number of k taxa subtrees of the mfast as ns. the probability that at least one of these subtrees will be found in at least one of the input trees is then 

 p=1−)ns. 

a lower bound to ns is h − k +  <dig> which can be obtained by picking a contiguous block of k taxa from the canonical newick representation of the mfast by considering all possible h − k +  <dig> starting point locations. notice that the larger the value of p, the higher the chances that our algorithm will construct some part of the mfast. similarly, the larger the value of ns, the higher the chances that our algorithm will construct some part of the mfast.

overall, we conclude from this experiment that even small values of k and c suffices to capture a part of the mfast in phase two. therefore, although our algorithm’s complexity increases exponentially with k and c, we do not need to use large values for k and c. this enables our algorithm to scale to very large datasets with thousands of taxa and trees. these results explain the theory behind the practical results we observed in sections “effects of number of input trees” to “effects of noise percentage”.

evaluation of state of the art methods
so far, we have shown that our method could successfully find the mfasts contained in sets of trees t for up to  <dig> taxa and  <dig> trees . an obvious question is how well do existing methods perform on the same datasets. here, we answer this question for two existing programs, namely paup*  and phylominer.

when we fix the number of trees and the number of taxa to  <dig>  paup* was able to find the mast for for all datasets. as we grow the number of taxa to  <dig> or larger while keeping the number of trees as  <dig>  paup* runs our of memory and fails to return any results. after reducing the number of trees to  <dig>  paup* still runs out of memory and cannot report any results for more than  <dig> taxa.

the scalability problem of phylominer is even more severe. phylominer is able to compute the mfasts on datasets with up to  <dig> taxa. however, as we increase the number of taxa further, its performance deteriorates quickly. when we set the number of taxa to  <dig>  even with as few as  <dig> trees, phylominer takes more than a week to report a result. moreover, in our experiments, the maximum size of the subtrees it found on average contained fewer than  <dig> taxa, even though the size of the true mast was  <dig> 

another interesting question about existing methods would be whether the majority consensus rule can be used to find mfasts. to evaluate this, we used the same three synthetic datasets used in section “effects of noise percentage”. recall each of these three datasets contains an mfast of size  <dig> which is embedded in 80% of the trees. the datasets are created with 20%, 40% and 60% noise indicating different levels of difficulty in recovering the embedded mfast. we computed 70% majority consensus tree. notice that if majority consensus rule can identify an mfast, that would correspond to a bifurcating subtree topology in the consensus tree. in other words a subtree is bifurcating in this experiment only if 70% or more of the input trees agree on the topology of that subtree. the resulting tree, however, was multifurcating for all the three datasets. this means that majority consensus rule could not recover even a smaller portion of the embedded tree while our method was able to locate the entire mfast successfully .

these results demonstrate that both paup* and phylominer are not well suited to finding agreement subtrees in larger datasets, our method scales better in terms of both the number of taxa and the number of trees. when paup* runs to completion, we observed that it reports the true results. recall from previous experiments that our method always found the true results on the same datasets as well as larger datasets. this suggests that our method has the potential to have an impact in large scale phylogenetic analysis when existing methods fail. 

empirical dataset experiments
to examine the performance of the mfast method on real data, we performed experiments using  <dig> maximum likelihood bootstrap trees from a phylogenetic analysis of gymnosperms  and saxifragales . specifically, we evaluated how the performance of the mfast algorithm was affected by the number of input trees and the size of the input trees.

effects of number of input trees
we first examined the effect of input tree number on the size of mfast. for both the gymnosperm and saxifragales trees, we generated  <dig> sets of  <dig> and  <dig> trees by randomly sampling from the original  <dig> trees without replacement. we compared the average size of the mfast in the  <dig> and  <dig> tree data sets with the size of the mfast in the original  <dig> tree data set. first, in all analysis, the post-processing step greatly increases the size of the mfast, sometimes more than doubling it . this increase is similar to the one observed in the  <dig> taxon simulated data sets , emphasizing again the importance of the post-processing step with large tree data sets. although the sizes of the mfasts were similar, they decreased slightly with the addition of more trees . this may simply be a matter of observing more conflict with more trees.

the size of the mfast found by running only the post processing step is also shown. we run our method on the entire dataset that contains  <dig> trees as well as randomly selected subsets of  <dig> and  <dig> trees. we repeated the  <dig> and  <dig> tree experiments  <dig> times by randomly selecting the trees from the entire dataset and reported the average value.

the large gap between the mfast sizes before and after the post processing suggests that phase three is the main reason behind the success of our method, and thus, the costly seed combination phase  may be unnecessary. to answer whether this conjecture is correct, we ran a variant of our method by disabling the second phase; we only ran the post processing phase starting from each seed as the initial mfast one by one. we reported the largest mfast found that way as the output of this variant in table  <dig>  the results demonstrate that although phase three can grow a large fast, phase two is essential to find the largest frequent agreement subtree. in other words, post processing finds the true mfast only if a large portion of it is already found . in conclusion, phase three of our method cannot replace phase two, yet both phases are essential for the success of our method.

effects of size of input tree
next, we examined the effect of number of leaves in the input trees on the size of mfasts. for both the gymnosperm and saxifragales trees, we generated  <dig> sets of  <dig> input trees with  <dig>   <dig>  and  <dig> taxa. to make each set, we randomly selected  <dig>   <dig>  or  <dig> taxa, and we deleted all other taxa from the original sets of  <dig> trees. thus, these sets of trees with  <dig>   <dig>  or  <dig> taxa are subtrees of the original data sets. the size of the average mfast increases with more taxa in the original trees . however, interestingly, the average size of the mfasts for the gymnosperm data set with  <dig> trees is larger than the mfast found from the original gymnosperm trees with all the taxa . since the mfast from the  <dig> taxon data sets should all be found within the full data set, this indicates that on the larger trees, our method may not always find the true  mfast. the full data sets may require a larger number of contractions to find the true mfasts.

the size of the mfast found by running only the post processing step is also shown. we run our method on the entire dataset that contains all the taxa  as well as randomly selected taxa subsets of size  <dig>   <dig> and  <dig>  we repeated the  <dig>   <dig> and  <dig> taxa experiments  <dig> times by randomly selecting the taxa from the entire dataset and reported the average value.

similar to the experiments in section “effects of number of input trees”, we investigated the gap between the mfast sizes before and after the post processing step. we ran a variant of our method by disabling the second phase; we only ran the post processing phase starting from each seed as the initial mfast one by one. we reported the largest mfast found that way as the output of this variant in table  <dig>  the results are in parallel with those in table  <dig>  phase three can grow a large frequent agreement subtree, but not quite as big as that when both phase two and three are executed.

effects of sample size
in our final experiment, we evaluated the effect of the maximum time cutoff , we described in section “in-order combination” on the accuracy of our method. recall that, this cutoff limits the number of initial seeds tried in our algorithm by randomly sampling a small percentage of the seeds. it only uses the sampled seeds as possible initial seeds. however, it uses the entire set of seeds while growing the mfast determined by the initial seed. as each initial seed roughly takes the same amount of time to grow into an mfast, using x% of the seeds as the sample set reduces the total running time our method to roughly x% of that of our original implementation.

we carried out this experiment as follows. for both the gymnosperm and saxifragales trees, we ran  <dig> sets of experiments for each sampling percentage of  <dig>   <dig>   <dig>   <dig>   <dig> and 100%. thus, totally we ran  <dig>  experiments. table  <dig> presents the average mfast sizes for varying sample sizes. the results demonstrate that even for very small sampling percentages, our method finds mfast that is almost as big as the mfast found by using the entire dataset . this is very promising as it demonstrates that the running time cost of our method can easily be cut to a small fraction by sampling the starting seeds. the rationale behind this is that the mfast contains many seeds. starting from any of these seeds, our algorithm has the potential to lead to that mfast. the probability that at least one of these seeds appear in the sample set is large particularly for large mfasts.

we run our method by randomly picking 2%, 5%, 10%, 25%, 50%, 100% of the seeds found in phase one for combination in phase two.

CONCLUSIONS
in this paper, we present a heuristic for finding the maximum agreement subtrees. the heuristic uses a multi-step approach which first identifies small candidate subtrees , from the set of input trees, combines the seeds to build larger candidate mfasts, and then performs a post-processing step to increase the size of the candidate mfasts. we demonstrate that this heuristic can easily handle data sets with  <dig> taxa, greatly extending the estimation of mfasts beyond current methods. although this heuristic is not guaranteed to find all mfasts, it performs well using both simulated and empirical data sets. its performance is relatively robust to the number of input trees and the size of the input trees, although with the larger data sets, the post processing step becomes more important. overall this method provides a simple and fast way to identify strongly supported subtrees within large phylogenetic hypotheses.

although the method we developed is described and implemented for the rooted and bifurcating trees, it can be trivially extended to multifurcating as well as unrooted trees. the central technical difference in the case of unrooted trees would be the definition of clade  as the definition requires a root. a clade in an unrooted tree encompasses two sets of nodes;  a given set of taxa x,  the set of all internal nodes that are on a path between two taxa in x on the phylogenetic tree. we expect that this will increase the number of seeds substantially and thus make the problem more computationally intensive. the amount of increase will depend on the tree topology. the theoretical worst case happens when all the taxa are connected to a single internal node . in that case any subset of taxa can lead to a potential seed as long as the subset size is equal to the seed size allowed. one possible way to overcome this problem would be to exploit randomization or graph coloring strategies and avoid enumerating majority of the possible seeds.

abbreviations
mast: maximum agreement subtree; fast: frequent agreement subtree; mfast: maximum frequent agreement subtree.

competing interests
the authors declare that they have no competing interests.

authors’ contributions
ar participated in algorithm development, implementation, experimental evaluation and writing of the paper. tk participated in algorithm development, experiment design and writing of the paper. gb participated in experiment design, dataset collection and writing of the paper. all authors read and approved the final manuscript.

acknowledgments
this work was supported partially by the national science foundation .
