BACKGROUND
plummeting cost of high-throughput sequencing  allowed population geneticists to analyse hundreds of individuals on the whole genome level . moreover, the researchers are no longer limited to the model species as draft genome sequences can be assembled de novo from hts data . the quality of these draft genomes is generally lower than that of the traditionally sequenced genomes  <cit>  but they are still considered adequate for various types of analysis in population genetics as well as genome-wide association studies.

the core algorithm of a modern genome assembler usually implements either a de bruijn graph  <cit>  or a string graph  <cit> . both approaches involve constructing a graph based on sequence overlaps and finding the optimal path through the graph. such path would correspond to a contiguous assembled sequence known as contig. in a string graph, vertices are represented by reads while a sufficiently long overlap between two reads forms an edge. to construct a de bruijn graph, each read is split into all possible sequences of length k . the k-mers form vertices of the graph while overlaps between k-mers that are k− <dig> bases long become edges. among the assemblers that implement the string graph approach are sga  <cit>  and sage  <cit>  while de bruijn graphs are incorporated into abyss  <cit> , meraculous  <cit> , allpaths-lg  <cit> , and soapdenovo <dig>  <cit>  among many others.

pipeline for genome assembly normally includes a rigorous error correction of the reads, which can be done either before the assembly with another tool or during the assembly by the assembler itself. contig assembly may be followed by scaffolding whereby mate-pair reads that map to two different contigs are used to splice these contigs together into a scaffold. finally, some pipelines for genome assembly involve merging of the overlapping paired-end reads into longer sequences before the construction of de bruijn graphs. in fact, allpaths-lg requires that sufficient number of overlapping paired-end reads are present in the input data  <cit> . such approach allows the selection of longer k-mer size for the de bruijn graph construction, which in turn improves the assembly of repetitive regions  <cit> .

here, we report a stark pattern that appears when calling variants against assemblies generated from de bruijn or string graphs. if paired-end reads are aligned to the assembled contigs, an unexpectedly high number of variants will be called at a certain position from the end of a contig or scaffold. depending on the assembler’s implementation, this position matches either the k-mer length used for de bruijn graph construction or the length of reads used in string overlap graphs. our analyses suggests that the bias is caused by repeated sequences that cannot be successfully resolved by assemblers. while scaffolding mitigates the bias, it does not remove the bias completely and variants are still more likely to appear at the same relative position within contigs incorporated into scaffolds. the most effective approach to attenuate the bias is to remove all variants present in repetitive elements. since the bias-causing variants are mostly false positives, the bias may have serious implications on downstream analyses performed in resequencing projects  <cit> .

methods
whole genome assemblies
a subset of maylandia zebra  and boa constrictor  whole genome assemblies  submitted by various teams  as entries to the assemblathon  <dig> competition  <cit>  were downloaded from the official repository. to reduce the extent of post-processing that could potentially obscure the problem, only the teams representing the original assembler developers were chosen. since the competitive soapdenovo <dig> assembly of the snake genome was generated using mislabelled mate-pair libraries, we downloaded the corrected version that the team made available after the competition .
this study focused on a subset of the b. constrictor  and m. zebra  genome assemblies submitted by the assembler developers to the assemblathon  <dig> competition. in addition, we simulated reads from a. thaliana chromosomes  <dig> and  <dig>  and constructed several assemblies with varying parameters. for sga, we varied the minimum string overlap . for soapdenovo <dig>  we set the -k parameter to  <dig> and  <dig>  which corresponded to k =  <dig> and  <dig> for soap_k <dig> and soap_k <dig> respectively. ‘pos’ column shows the position  where variants occur most frequently. ‘na’ in the ‘k’ column indicates that the choice of k was not reported and could not be determined from other sources


*the bcon assembly by the soapdenovo <dig> team submitted for the competition was assembled using an incorrectly labelled library. we analysed the corrected version that was constructed after the competition  <cit> 




for the alignment against these assemblies, we randomly selected a  <dig> bp insert library for b. constrictor  and  <dig> bp insert library for m. zebra . each library was aligned only against the assemblies of its respective species. both libraries were downloaded from the ncbi sequence read archive.

simulated data set
sequences for chromosomes  <dig> and  <dig> of arabidopsis thaliana  were downloaded from the arabidopsis information resource website  <cit> .

to simulate the reads we used simseq application that aims to reproduce the biases present in normal illumina data sets  <cit> . we ran the application with default parameters to simulate  <dig> mln  <dig> bp paired-end reads with the mean insert size of  <dig> bp and  <dig> mln  <dig> bp mate-pair reads with the mean insert size of  <dig> kb. since the combined size of the chosen chromosomes is about  <dig> mb, the simulated libraries yielded 60× and 20× coverage respectively.

we assembled the short reads from these libraries using allpaths-lg v <dig>  <cit>  with default parameters. henceforth, we will refer to this assembly as sim_allp where ‘sim’ indicates simulated libraries and ‘allp’ denotes the assembler. we also constructed two assemblies  with soapdenovo <dig> v <dig>   <cit>  specifying different k-mer lengths. the optimal length  was determined by running kmergenie  <cit>  for the range of lengths between  <dig> and  <dig> with the step of  <dig>  another length value  was selected as the next best length according to the kmergenie output. in both cases, we ran soapdenovo-127mer with the options to resolve repeats  and to drop low-frequency k-mers . finally, we constructed two assemblies  using a string overlap assembler, sga v <dig> . <dig>  <cit> . for both sga assemblies, we ran error correction with k-mer length set to  <dig>  and the minimum overlap of  <dig>  for the overlap command. the minimum overlap in the assemble command was set to either  <dig> or  <dig> . subsequent scaffolding was performed using default parameters as described in the sga documentation.

to investigate variant calling for resequencing analysis, we downloaded a short-insert library  of a. thaliana bs- <dig> genotype from dna data bank of japan . the reads were sequenced with illumina hiseq  <dig> and have the insert size of  <dig> bp with  <dig> bp read length  <cit> .

variant calling
variants were called with gatk v <dig> - <dig>  <cit>  following the established best practices  <cit> . briefly, the corresponding short insert library was aligned against the assembled sequences using bwa v <dig> . <dig>  <cit> . after marking the duplicates, the reads were locally realigned around insertions/deletions  and variants were called with haplotypecaller. the obtained raw calls were filtered using the criteria recommended for cases when variant calibration was not possible .
snps with statistics above or below  the corresponding threshold were removed from consideration. for detailed description of these statistics and justification for the threshold selection, see van der auwera et al.  <cit>  and gatk documentation at https://www.broadinstitute.org/gatk/





to make sure that variants in the regions with excessively high coverage do not affect the results, we separately applied more restrictive coverage filters to the variants called in the fish and snake genomes. the thresholds were set to the expected coverage calculated using the lander-waterman equation c=l
n/g  <cit> , where c is the expected coverage, l is the read length, n is the number of reads, and g is the estimated haploid genome length. based on the reported genome lengths of  <dig>  and  <dig> gb  <cit> , the expected coverage was  <dig> × and  <dig> × for the snake and fish genomes respectively.

alternative read alignment and variant calling tools
to exclude the possibility that the bias was caused by the tools we used for read alignment and variant calling , we also analysed the variants detected against simulated contig assemblies with alternative tools. we ran gatk on the alignments produced by each nextgenmap  <cit> , gsnap  <cit> , and bowtie <dig>  <cit> . we accepted the default parameters for each of these read alignment applications. since we suspected that bowtie <dig> might have lower sensitivity than the other aligners, we also ran bowtie <dig> with the default parameters to align bs- <dig> reads against the simulated contig assemblies.

we relied on bwa alignments to test the freebayes  <cit>  and samtools mpileup  <cit>  variant callers. we ran the multithreaded version of freebayes and specified the same maximum coverage threshold  as with gatk. following the recommendations from the freebayes documentation, variant calls were subsequently filtered using a minimum quality threshold . we also used the default parameters for samtools mpileup except for the maximum indel coverage, which we set to  <dig>  the resultant data was processed with bcftools  <cit>  to produce a vcf file and filter out the variants with low quality  and abnormally high coverage .

scaffold position transformation 
to transform variant scaffold positions to contig positions in allpaths-lg assemblies, we employed the information from the final.summary file that allpaths-lg generates by default. for each scaffold, the file reports scaffold length, list of included contigs with their respective lengths, and gap sizes. overlapping contigs have negative gap sizes. we noticed that occasionally a scaffold in the final assembly extends beyond the length specified in the summary file. in such cases, we reported the snps located beyond the reported scaffold length as ‘untransformed’ because their coordinates could not be mapped to any contigs.

for the transformation of scaffold positions in soapdenovo <dig> assemblies, we parsed the file with the contigposinscaff extension. the file is automatically generated by soapdenovo <dig> during scaffolding. for each scaffold, the file lists one or more contig entries. each entry specifies contig id, starting position within scaffold , contig orientation, and ending position within scaffold. we also used the contig length information from the file with contig extension because soapdenovo <dig> often inserted gaps between overlapping contigs in a scaffold. such a gap would effectively split one of the contigs into two parts making it impossible to derive a transformation map exclusively from the contigposinscaff file.

our scaffold coordinate transformation would produce two contig coordinates if a variant is located in a scaffold region where two contigs overlap. we chose this approach because such scaffold variants in principle should have two corresponding contig variants, one on each of the overlapping contigs.

identification and filtering of repetitive elements
we identified repetitive elements and low complexity sequences in the simulated assemblies using repeatmasker v <dig> . <dig>  <cit>  with the library version  <dig>  <cit> , ncbi search engine, and ‘viridiplantae’ species filter. to calculate the number of position k snps appearing in repetitive elements, we checked the snp coordinates against the repetitive sequence ranges reported by repeatmasker. if a repetitive element spanned position k at both ends of a contig and contained two position k snps , we counted it as a single occurrence, i.e. for each repetitive element sequence the count was either  <dig> or  <dig>  to adjust for family frequency, we divided the number of position k snps appearing within that family by the total number of the family sequences present in the assembly. snp filtering process entailed the removal of all variants located within any of the identified repetitive elements or low complexity sequences.

RESULTS
positional bias in variant distribution within contigs
in our analysis, we used the publicly available data from the assemblathon  <dig> competition  <cit> . for each of the two analysed species, we randomly selected a single short-insert library among those provided to the teams for assembly and aligned the reads against each of the chosen contig assemblies submitted for the competition. in each case, both the aligned reads and the assembly came from the same individual . hence, any variant calls would be false positives and the distribution of their positions within contigs should be approximately uniform.

after calling the variants, we calculated how frequently they appeared at each position counted from both ends of contigs . frequencies were estimated separately for single nucleotide polymorphisms  and insertions/deletions . all of the tested assemblies showed positional bias in the distribution of variant calls . for some assemblies the bias was evident in the distribution of both snps and indels while others exhibited only snp distribution bias. since indels are typically less frequent, more difficult to call and, therefore, less reliable than snps, we will focus on the snp distribution bias.
fig.  <dig> distribution of snp positions at the 5′ end of contigs. the analysis includes a subset of five b. constrictor and three m. zebra assemblies submitted to assemblathon  <dig>  <cit> . the description of assembly identifiers is given in table 1





in addition to the assemblathon  <dig> entries, we simulated  <dig> bp paired-end library and  <dig> kb mate-pair library using chromosomes  <dig> and  <dig> of arabidopsis thaliana. we assembled the simulated paired-end library into contigs separately with several assemblers. we called variants and analysed the results using the same approach as with assemblathon  <dig> data. the simulated data set provided several advantages. first, it excluded the possibility that aligning additional paired-end libraries used for assembly would affect variant calling. assemblathon  <dig> teams had access to several paired-end libraries while we only aligned a single one to call variants against those assemblies. the simulated data set contained only a single short-insert paired-end library, which was subsequently aligned to the de novo assemblies. second, we knew the exact origin of each simulated read, which helped us explain why some variants were called. third, available hts data for a different a. thaliana genotype enabled us to explore the effects on variant calling for resequencing analysis. finally, we were able to run more analyses because of the smaller data set size.

in the literature describing de bruijn graph approaches to assembly, k-mer length may refer to either the length of sequences at graph vertices  <cit>  or the length of sequence overlaps at graph edges  <cit> . to avoid the confusion, we will use the first definition and denote such length as k. the length of sequence overlaps at graph edges will be denoted as k, i.e. k=k− <dig> for de bruijn graphs.

only three teams  reported k-mer lengths used for assembly . in all cases, the position where snps occurred most frequently matched the reported k-mer length . this was independent of the tool and the actual k value used in the assembly . when assembling our simulated paired-end reads with soapdenovo <dig>  we changed the k configuration parameter from -k  <dig> to -k  <dig> and the most frequent snp position shifted from  <dig> to  <dig> .
fig.  <dig> distribution of snp positions at the 5′ end of contigs in the simulated data set. the description of assembly identifiers is given in table 1





among the assemblers we analysed, sga  <cit>  was based on string graphs rather than de bruijn graphs. in this assembler, the parameter equivalent to the k-mer length would be the string overlap length used for graph construction. it can be specified as -m parameter for the assemble command. changing this parameter did not cause a shift in the peak position . instead, the peak position was linked to read lengths. for the assemblathon  <dig> entry and the simulated data sets, the read lengths were  <dig> and  <dig> bp respectively. both values matched the most frequent snp position of their respective assembly . hereafter, we will use the read length to establish the k position in sga assemblies.

to make sure that the positional bias is not limited to the very short contigs with potentially poor quality, we removed all contigs shorter than  <dig> bp and repeated the analysis. the bias was still clearly visible in all cases  indicating that such filtering is not effective for bias reduction.

to remove the variants called in the regions with abnormally high coverage, we used the  <dig> × threshold . the value was higher than the expected coverage calculated with lander-waterman equation  <cit> . however, the bias was still apparent even among the variants with coverage that did not exceed the expected levels .

we also compared the distributions of various quality statistics reported by gatk  for snps at position k to those reported for snps at other positions, and found them very similar . while the differences might be statistically significant due to large sample size, the effect size is minimal and considerable overlap between distributions makes snp discrimination unfeasible. the only statistic that could be possibly used to reduce the bias without substantial effect on other snps is mapping quality . even then, the results would be largely dependent on the assembler choice and the underlying data set. in particular, the distribution of mq for snps in non- k positions had fairly long left tails in m. zebra  while the mq distributions for k and non- k snps in the simulated data set were hardly separable regardless of the assembler .

scaffolding does not eliminate the positional bias
assembly pipelines generally include a step to concatenate contigs into longer scaffold sequences based on mate-pair read alignments. we discovered that the positional bias was attenuated but still persisted in the b. constrictor and m. zebra assemblies after scaffolding . the only assembly where the bias appeared less evident was mzeb_allp_6c but even there the peaks at the position k were notably high. similar results, including the greatest reduction of the bias appearance in the allpaths-lg assembly, were observed with the simulated data set . removal of the short scaffolds  from the b. constrictor and m. zebra assemblies did not completely eliminate the bias either .
reads column indicates the origin of aligned reads: ‘sim’ refers to the simulated paired-end reads while ‘bs-1’ denotes the actual a. thaliana bs- <dig> short-insert library  <cit> . contig and scaffold columns show the number of snps at position k in the respective contig and scaffold assemblies. ‘transf’ column shows the number of snps at position k called against scaffolds after the scaffold coordinates were transformed to contig coordinates. only sim_allp and sim_soap_k <dig> scaffold coordinates were transformed. ‘untransf’ column indicates the number of snps that failed to transform because of contig length threshold  or scaffold being extended beyond the length specified in the assembler’s scaffold map . ‘shared’ column reports the number of snps present in both contig and tranformed sets. ‘masked’ column shows the snps that appear in contig and transformed but not in scaffold because of the change in their relative positions. all counts except ‘untransf’ are for snps in position k





there are two mechanisms that may cause the bias reduction after scaffolding. first, many contigs will be placed in the middle of scaffolds. thus, many snps that were previously present near contig ends would appear in the middle of scaffold sequences as well. consequently, some snps that contributed to the bias before would emerge as snps that do not cause the bias because they would not be in position k relative to scaffold ends. this mechanism makes the bias less apparent but it does not actually decrease it because corresponding snps still persist in the scaffold assembly . the second mechanism is triggered by alterations in read alignments. scaffolding typically involves concatenation of overlapping contigs and gap filling between adjacent contigs. both actions may alter read alignments in the affected regions. in particular, reads that previously caused snp calls on individual contigs would not align sufficiently well to the same contigs or would align better elsewhere after scaffolding. thus, the number of snps in both k and non- k positions may diminish. such bias reduction would be real because it effectively eliminates the bias causing snps.

we can measure the effects of these two mechanisms by analysing the intersection between snps called before and after scaffolding. to compute the intersection, we have to transform snp scaffold coordinates into contig coordinates using a scaffold map reported by the assembler. bias masking occurs when a scaffold snp from a non- k position appears in the position k after transformation and there is a contig snp at the same position. genuine bias reduction takes place when a contig snp in position k does not have a corresponding scaffold snp.

we transformed scaffold coordinates into contig coordinates in two assemblies constructed from the simulated reads. in the sim_allp assembly, scaffolding reduced the number of snps in position k from  <dig> to  <dig> . after transforming scaffold coordinates to contig coordinates, the position bias was clearly visible  as the number of scaffold snps in position k increased to  <dig> . out of those,  <dig> were also called against the contig assembly  while  <dig> were unique to the scaffold assembly . coordinates for one snp could not be transformed because the scaffold was longer than specified in the assembler’s scaffold map. out of the  <dig> contig snps present in position k,  <dig>  emerged in the scaffold assembly at non- k positions relative to scaffold ends  while  <dig>  snps completely disappeared due to altered read alignments.

in the sim_soap_k <dig> assembly, scaffolding also reduced the number of position k snps  but the underlying processes were different. a large number of snp coordinates  were not transformed  because they corresponded to locations on contigs shorter than  <dig> bp. those contigs were excluded from the sim_soap_k <dig> contig assembly for snp calling while the assembler still used them for scaffolding. therefore, the ‘untransformed’ scaffold snps could not overlap with the contig snps in principle and we ignored them when calculating the overlap between contig and transformed scaffold snps . we also noticed that soapdenovo <dig> tends to introduce gaps within overlapping contigs. a gap is placed between the end of one contig and the non-overlapping part of the other contig, which breaks the second contig into two non-contiguous parts. this leads to considerable changes in read alignments and consequently yields many snps unique to the contig assembly . these two reasons also explain the large difference between the number of contig and coordinate-transformed scaffold snps  but much smaller difference between contig and scaffold snp counts . it also explains why the bias masking level is so low; only  <dig>  scaffold snps in non- k positions could be matched to contig snps in position k.

positional bias with alternative tools
to make sure that the positional bias was not caused by one of the selected tools , we executed variant calling pipelines with alternative read alignment or variant discovery applications on the simulated contig assemblies. running gatk with either nextgenmap  <cit>  or gsnap  <cit>  still resulted in clearly visible peaks at the expected locations . when using gatk with bowtie <dig>  <cit> , the peaks were much smaller in sga and soapdenovo <dig> assemblies and the bias was completely absent in the allpaths-lg assembly . however, the number of variants at other positions was much smaller as well.

previous reports indicated that bowtie <dig> was less sensitive to sequence mismatches  <cit>  and may have higher error rates  <cit> . to check the sensitivity of bowtie <dig> on our simulated data set, we ran the bowtie <dig> – gatk pipeline using resequencing data . compared to the bwa – gatk pipeline, we saw a considerable reduction in the total number of variant calls . this is in contrast to cornish and guda  <cit>  who reported only a minor decrease in snps between similar pipelines. these results should be interpreted with caution as we do not know the actual number of errors in each case.
total columns show the total number of snps in any position while ‘pos k’ columns show the number of snps at position k





variants detected by each freebayes  <cit>  and samtools mpileup  <cit>  using bwa alignments also exhibited strong positional bias . since samtools skips anomalous read pairs and orphan reads by default, filtering out improperly-paired reads would not remove the positional bias.

positional bias is present in resequencing analysis
in the previous subsections, reads used for variant calling came from the same individual as the reads used for the reference genome assembly. therefore, any called variants would be considered false positives. in this subsection, we investigate the alignment of reads from a different individual to the reference genome. in this case, some of the called variants should be real but there could also be false positives that would potentially manifest themselves as the positional bias described in this study. this analysis imitates the practical use of draft de novo assemblies in resequencing projects that focus on non-model species.

to verify that the positional bias would still be present in variant calling performed with reads from a different individual, we aligned a short-insert library of a. thaliana bs- <dig> genotype  <cit>  against our assemblies constructed from the simulated read data. the bias was present in all contig assemblies . it was also clearly visible in both sim_sga and both sim_soap scaffold assemblies at the expected locations . meanwhile, the bias essentially disappeared in the sim_allp scaffold assembly, probably because of the assembly’s high quality . as before, we transformed scaffold positions into contig positions for all scaffold snps and observed partial recovery of the bias in sim_allp . we traced a large number of snps on sim_soap_k <dig> scaffolds to contigs shorter than  <dig> bp . we also found that  <dig> and  <dig> snps  from non- k positions in sim_allp and sim_soap_k <dig> scaffolds respectively corresponded to position k snps in the contig assemblies . these results are consistent with those uncovered through the alignment of our simulated reads.

we tested whether the variant positions in the bs- <dig> alignments overlapped with the variant positions in the simulated read alignments. if they overlap well, removing these positions may provide a useful solution for the bias reduction. despite the partial overlap , sim_allp and sim_soap_k <dig> data sets possessed abnormally high number of position k snps that were unique to the bs- <dig> alignments . these snps comprise the variants that would remain after the filtering of the shared snps. the remaining bias was particularly strong in case of sim_soap_k <dig>  similar pattern appeared when positions of scaffold snps were transformed into contig coordinates . even though the filtering essentially eliminated the bias from the 5′ end of the sim_allp assembly , the results were not universal and other solutions would be needed.

considerable reduction in bias achieved by repetitive element filtering
for each assembly created from the simulated read data, we traced the origins of all reads that had primary alignments to snps at position k with the mapping quality of at least  <dig> and without any insertions or deletions compared to the reference . such conservative filtering ensured that the analysed reads aligned well only to a single location in the assembly and the alignments were not coerced by read clipping. if all such reads had a single origin per variant, it would suggest that the corresponding variants were caused by either simulated sequencing errors or poorly aligned reads from remote genomic regions with modest similarity. if the reads had multiple origins, the variants were likely caused by highly similar repeated or homologous sequences in the genome.

fewer than 6% of the snps had the selected reads coming from the same origin. it suggests that the bias is not caused by poor alignments or sequencing errors but rather by repetitive or homologous sequences. such sequences would lead to multiple potential path extensions through de bruijn or string graphs. the extensions would also have equally high support and may form either a junction or a so-called “bubble” in the path  <cit> . further investigation is needed to determine why the assemblers tend to terminate the path extension shortly after a bubble or a junction is formed.

we used repeatmasker  <cit>  to identify repetitive elements in the assemblies constructed from the simulated reads and discovered that the vast majority of snps near contig or scaffold ends were within those sequences . the pattern persisted whether the snps were called against contigs  or scaffolds  and whether the snps were called from the alignment of our simulated reads  or from the alignment of the actual bs- <dig> reads .
fig.  <dig> distribution of snp positions at the 5′ end of contigs in the bs- <dig> data set with repetitive element annotation. colour indicates whether the snps are within repetitive sequences  or not . snps were called from the bs- <dig> read alignments. repetitive elements included all sequences reported by repeatmasker




in the simulated contig data set, position k snps appeared within diverse repetitive elements. the largest number of snps were in the dna and long terminal repeat  families , which had the highest representation in the a. thaliana genome  <cit> . when adjusted for family frequency, snps were more likely to appear in the satellites  or dna repeats . however, none of the families were strongly overrepresented.

when the snps located in repetitive elements were filtered out from the set obtained through the alignment of the simulated reads, the positional bias was either completely eliminated as in the case of sim_allp or reduced to negligible levels as in the case of sim_soap and sim_sga assemblies . the remaining bias might be due to unannotated repetitive elements or other homologous sequences. the same tendency was observed with the snps called from the alignment of the actual bs- <dig> reads  except that more snps remained overall. this is expected because the alignment of the simulated reads can only produce false positives while the alignment of bs- <dig> reads should additionally yield real snps.
fig.  <dig> distribution of snp positions at the 5′ end of contigs in the bs- <dig> data set after repetitive element filtering. snps were called from the bs- <dig> read alignments and snps located in the annotated repetitive elements were removed




finally, we checked whether it would be possible to reduce the bias even further by removing both snps in repetitive elements and snps produced with the simulated read alignments from the bs- <dig> snp set. since the bias after the repetitive element filtering was already absent in sim_allp and barely detectable in sim_sga assemblies, we only report the results for sim_soap_k <dig>  after transforming scaffold coordinates to contig coordinates, there were  <dig> snps called at position k from bs- <dig> read alignments. out of them,  <dig> snps were also produced by the simulated read alignments . overall effect of the additional filtering is fairly minor  but the bias almost entirely disappears .

discussion
resequencing projects rely on a wide range of complex applications that often need to be tuned for the best performance. to achieve high quality results, it is essential to know limitations and biases inherent to each employed application. we have shown that variants obtained from the alignment of short reads against assemblies constructed with de bruijn or string graphs suffer from positional bias. while the degree of bias varied depending on the input data and setup, it was clearly visible in most tested configurations that encompassed several popular aligners and assemblers. if not addressed, the bias may trigger confounding effects in downstream analyses.

to confirm the bias, we designed two types of analyses. first, we called variants after aligning the reads from a short-insert library that was previously used to construct the reference assembly. in this case, all variants would be false positives. however, they would also be likely to appear when aligning reads from a different individual as long as the corresponding regions are conserved. this type of analyses was performed on both publicly available assemblies and our assemblies constructed from simulated reads. second, we performed variant analyses with actual reads coming from a genotype different from the reference. in this case, the variants would contain a mix of true positives and false positives. due to the limited availability of data, we only performed these analyses with the assemblies constructed from the simulated reads.

our results suggest that the positional bias was caused by the alignment of reads from repetitive or homologous sequences that often had fewer copies included in the assembly compared to the actual genome. the most effective method to reduce the bias is to remove the variants located in repeated sequences. such variants are very likely to be false positives even when they are not located at position k. depending on the assembler configuration and input data, such filtering may either eliminate the bias completely or reduce it to almost negligible level. the remaining bias-causing snps probably reside in unannotated repetitive elements or other homologous sequences that have multiple copies in the genome but only a single copy in the assembly. while some of the variants could have been caused by heterozygosity in b. constrictor and m. zebra genomes, the simulated data set essentially represented a haploid individual without any heterozygous regions. therefore, heterozygosity is unlikely to constitute a major factor in positional bias.

we also observed the positional bias while using alternative variant callers  and read aligners . the only exception was bowtie <dig> whose read alignments yielded very weak bias in the sga and soapdenovo <dig> assemblies and no bias in the allpaths-lg assembly when calling variants with gatk. however, the alignment of the resequencing data with bowtie <dig> against the simulated contig assemblies generated considerably fewer snps in all positions compared to bwa  suggesting decreased sensitivity of the aligner.

previous reports also showed the reduced sensitivity of bowtie <dig>  <cit>  while others revealed only minor  <cit>  or inconclusive  <cit>  differences between bowtie <dig> and bwa. interestingly, li attributes the differences between variants called from bwa and bowtie <dig> alignments to lower mapping scores that bowtie <dig> assigns to reads with additional suboptimal alignments  <cit> . since similar repetitive sequences are likely to appear multiple times in the assembly, the respective primary alignments would have very low scores and they would rarely produce variants. on the other hand, such drastic reduction in the number of snps between bwa and bowtie <dig> alignments is unlikely to stem exclusively from the false positives called by bwa. therefore, further research is needed to determine whether bowtie <dig> actually outperforms bwa in terms of both sensitivity and specificity when calling variants against draft genome assemblies.

theoretically, it may be beneficial for resequencing projects to align reads previously used to construct the reference assembly, call variants and exclude them from the variants called in resequenced individuals. if the involved regions are completely conserved between the reference individual and a resequenced individual, those snps would be called for the resequenced individual as well and they would be false positives. however, this type of filtering produced very minor effects on the positional bias in the data sets we analysed, especially after the removal of snps located in repetitive elements.

the extent of positional bias obviously depends on the quality of the reference genome assembly. high quality assemblies have reduced number of contigs or scaffolds. thus, they will have fewer locations to call the bias-causing snps. for many projects dealing with non-model organisms, it may not be realistic to construct genome assemblies with adequate quality in sufficiently short time. moreover, even when a high quality assembly does not readily exhibit a strong positional bias, it may still appear after mapping scaffold coordinates to contig coordinates. we found the evidence for such bias masking in our analyses. increased number of repetitive elements in a genome would also yield higher positional bias while lowering assembly quality. therefore, regardless of the assembly quality it would be important to filter snps that appear in repetitive elements in order to avoid potential complications.

a more conservative approach would involve filtering out all variants near contig ends. when using a sufficiently large threshold , this would remove the positional bias completely. however, any true variants in those regions will also be lost. to apply such a filter, it would be necessary to know contig coordinates within scaffolds and this information may not be readily available. in any case, this kind of filtering should be done in addition to the filtering of variants in repetitive elements because some repetitive sequences would not be located near contig ends.

CONCLUSIONS
this study describes positional bias in variant calls that are made against draft genomes constructed with several popular assemblers. the variant calls that cause the bias are mostly false positives that arise from aligning the reads originated in spatially remote repeated sequences or homologous regions. the degree of the bias depends on the choice of tools, configuration, and underlying data set. however, the bias is likely to affect many projects that rely on de novo draft assemblies generated from short read data. the bias can be mitigated by removing variants located in repetitive elements that can be identified by programs such as repeatmasker  <cit> . more conservatively, the bias can also be removed by filtering out all variants located near contig ends. our findings will help researchers who work on resequencing projects to recognise and reduce the position bias, which will result in higher quality variant data sets.

additional file

additional file  <dig> supplementary figures. 




abbreviations
ddbjdna data bank of japan

dpdepth of coverage

htshigh-throughput sequencing

indelinsertion or deletion

ltrlong terminal repeat

mqmapping quality

ncbinational center for biotechnology information

qualvariant quality

snpsingle nucleotide polymorphism

tairthe arabidopsis information resource

vcfvariant call format

