BACKGROUND
rearrangements are large scale modifications of the genome, such as inversions or transpositions of dna segments, translocations between non homologous chromosomes, fusions or fissions of chromosomes, deletions or duplications of small or large portions. such modifications in the organisation of a genome are not without consequences for the cell and the organism. as a matter of fact, rearrangements have been shown to be responsible for numerous heritable diseases, called genomic disorders. they are further involved in evolution, speciation, and also in cancer . although they have been studied for a long time, the underlying mechanisms of such events remain largely unknown, in particular understanding  their location on the genome. as far as evolutionary rearrangements are concerned, it thus remains an open question to understand what determines their locations. whereas nadeau and taylor suggested in  <dig> that rearrangements occur randomly on a genome  <cit> , several observations tend to refute this model and suggest a more deterministic scenario. by comparing genomes of related species, it has thus been suggested that some rearrangements cluster in specific regions, called hotspots  <cit> . a few rearrangement locations have also been found re-used in independent lineages in the course of evolution, indicating again that some regions seem to be more prone to a rearrangement than others  <cit> . in addition, several genomic features, such as segmental duplications or fragile sites, seem to correlate with rearrangement locations  <cit> . however, the nature of the relationship between such features and rearrangements, that is, whether one is a cause or a consequence of the other, remains unknown. to investigate these issues, it is necessary to precisely identify the genomic regions which underwent a rearrangement. the latter is the main motivation of this paper. of the numerous possible sources of structural variation due to a rearrangement, we deal only with those involving chromosomal regions above a certain size in number of markers . the main motivation is that this decreases the risk of false positives, that is, of identifying regions as rearranged while they in fact have been detected as such following a wrong homology assignment. in practice, this means also that we do not deal with duplication or deletion events as those are harder to detect or to properly assign.

one crucial step before analysing the rearrangements and their possible relation with other genomic features is to locate these events on a genome. in the case of two genomes, it is possible to identify conserved regions by comparing the order and orientation of orthologous markers along the genomes. conserved regions correspond to pairs of segments, one in each genome, that are orthologous and have not been rearranged in either lineage. these are also called synteny blocks. breakpoint regions, or breakpoints for short, are segments that flank the conserved regions. more precisely, a breakpoint is the region between two consecutive synteny blocks on one genome, whose orthologous blocks are rearranged in the other genome .

a terminological clarification is called for here as the use of the term "breakpoint" to name such rearranged regions can be confusing for two reasons.

the first reason originates from the prefix "break". this suggests a physical break of the dna , and assigns an improper biological meaning to the term. indeed, the definition of breakpoints is based only on the method developed to identify it. one should therefore be aware that the so-called breakpoint regions have not necessarily been "broken". the region we call breakpoint is located on one genome, and when comparing two genomes, we can usually not decide in which lineage the rearrangement in fact occurred. suppose for instance that we are comparing the genomes of human and mouse and that the ancestral arrangement of one of the chromosomes is composed of the consecutive synteny blocks a, b and c. suppose now that the human arrangement is the same as the ancestral one, abc, and that the mouse arrangement is acb. then, by comparing the human and mouse genomes, the region between a and c in the mouse genome would appear as a breakpoint, as would the region between a and b in the human genome. however, neither of these two regions contain the real breakpoint , but both are homologous to a broken region.

the second reason why the term "breakpoint" may be confusing originates from its suffix "point". indeed, most often the location of a breakpoint is not as precise as a point, that is as the position between two nucleotides on a genomic sequence. it concerns rather in general a longer region. this latter is defined as the region between two successive synteny blocks, implying that we have not detected any homology  for the region to be added to a neighbouring synteny block, or for it to be considered as a new block in itself. however, we do not know a priori if this imprecision is due to some biological features created by  the break , or to the fact that it is computationally difficult to extend the orthology beyond the extremities of the synteny blocks.

keeping these considerations in mind, we continue calling such regions breakpoints, for short. we are interested in investigating such breakpoints more in detail. indeed, in order to analyse the breakpoint sequence and to determine whether breakpoints correlate with some other features of the genome, it is important to precisely locate them. as far as we know, current methods for detecting breakpoints are in fact methods for detecting synteny blocks: they provide the coordinates of the breakpoints only as a byproduct, simply by returning regions that are not found in a conserved synteny. we propose here to go one step further and to extend the synteny blocks by focusing on the breakpoints themselves. it has been previously observed that inside breakpoints, one can often find some smaller blocks of weak similarity that could have been included in the original synteny blocks  <cit> . we have developed a formal method to precisely locate the breakpoints on a sequenced genome by a comparative approach with related species. given two genomes, one of which will serve as reference, the core of the method assumes that some synteny blocks have been correctly identified. these delimit regions that are breakpoints but that can be refined in the sense that the blocks could be extended. thus the regions between which there is no detectable orthology, that is the breakpoints, could be far more precisely and narrowly localised. the method requires that the synteny blocks given as input do not overlap and that their extremities correspond to orthologous sequences between both species. various methods exist to construct synteny blocks from homologous markers between two sequences, but formal descriptions of these objects are rarer, and no current method can guarantee the simple properties we require. we thus describe our own method to build reliable and formally well described synteny blocks, for which we can guarantee the useful properties.

the method was then applied to mammalian genomic data. the human genome was chosen as reference and compared to two other mammalian genomes: those of the mouse and dog. we end up with a dataset of precise coordinates of mammalian breakpoints on the human genome, which is made publicly available . by comparison with other published datasets of breakpoint coordinates, we further show that in general, one can extend synteny blocks and refine breakpoints in an efficient enough manner. finally, we analysed the breakpoint sequences in terms of several genomic features. this identifies some duplications inside the breakpoints and reveals differences with the flanking sequences.

methods
refining the breakpoints
we start by describing the core of the method, that is the narrowing down as precisely as possible into the breakpoints given a set of synteny blocks.

we are given two sequenced genomes, and the synteny blocks between them. since we wish to locate all the breakpoints in one genome, the method is not symmetric: one genome is thus the reference and is denoted by gr, while the other genome to which it is compared is denoted by go. a synteny block is defined by a pair  of coordinates, one  in genome gr and the other  in genome go, each indicating a chromosome, a start point and an end point. a breakpoint on gr is a region between two synteny blocks that are consecutive on gr, but not on go. assuming that the synteny blocks are correct, it is certain that in this region, or in one of its orthologs on the other genome, there has been at least one break due to a rearrangement. the size of the region can vary from several base pairs to several millions of base pairs. as mentioned in introduction, we do not know a priori if this imprecision is due to a biological property of the region, or to the fact that orthology has not been detected beyond the extremities of the synteny blocks. we are interested in refining this region as much as possible to eliminate the latter possibility. the refinement of the region is done by aligning the region in-between the two synteny blocks in gr with the regions flanking the orthologs of the blocks in go. the results of the alignment are then coded into a numerical sequence which is partitioned to identify the narrowed breakpoint.

alignment
given two synteny blocks  and  that are consecutive in gr, three sequences of interest are defined : sr corresponds to the region in gr between ar and br, soa and sob are the sequences flanking ao and bo in go  up to the extremity of the next synteny blocks on go. part at least of the sequences soa and sob is expected to be orthologous to sequence sr. as an example, in figure  <dig>  the prefix of sequence sr should be orthologous to the prefix of sequence soa and its suffix to the suffix of sequence sob. depending on the nature of the markers, their extremities may be poorly conserved and the limits of the synteny blocks thus not very clear. the markers at the extremities of the blocks may then be added to the sequences sr, soa, and sob. for example, in the case of genes, when their orthology relationship has been assigned based on similarity criteria at the aminoacid level, the orthologous genes may not be alignable on their whole length at the dna level and thus the extremities of the genes on the genomes may not be orthologous. this can also be due to errors in the prediction of the boundaries of genes. including the genes at the extremities of the blocks in the sequences thus allows to overcome these problems.

to identify the orthologous relationships between sequence sr and the two sequences soa and sob, we perform two local alignments: one of sequence sr against sequence soa and another of sequence sr against sequence sob. we use for this the algorithm blastz  <cit> , after having masked the sequences for repeats with repeatmasker  <cit> . the choice of a local aligner like blastz is motivated by the fact that the sequences are usually  intergenic, and therefore in general not well conserved over their whole length, and blastz has been shown to be more sensitive on such sequences  <cit> . large indels, small rearrangements and duplications are possible. the sequences are also often long. these two characteristics call for an algorithm that is both sensitive and fast enough.

two lists of local alignments, called hits, are obtained and mapped onto sequence sr, regardless of their orientations and locations in the sequences soa and sob. we expect to have significantly more hits from soa in sequence sr close to block ar, and more hits from sequence sob close to br. in the region in between, in general no clear difference can be made between the amount of hits from soa and sob. this defines the refined breakpoint.

segmentation
to detect this region in a quantitative manner, the information provided by the hits is coded along the sequence sr giving as result a sequence i of discrete values of which three only are possible: - <dig>   <dig> and  <dig>  the value is  <dig>  if position i of sr is covered by at least one hit from sequence soa  and no hit from sequence sob . the value is zero if position i is covered by at least one hit from each of the sequences soa and sob. the positions covered by no hits are deleted from sequence i. thus sequence i has length n, the number of positions covered by at least one hit.

the problem we solve is then, given the sequence i of - <dig>   <dig> and 1's, to find the optimal segmentation of i into three segments, such that the first presents an orthology relationship with sequence soa, the third segment an orthology relationship with sequence sob, and the segment in between corresponds to the breakpoint. we define two change points u <dig> and u <dig> over the sequence i of length n, such that  <dig> ≤ u <dig> ≤ u <dig> ≤ n. the sequence is modelled by a piecewise constant function with the values μ <dig>  μ <dig> and μ <dig> respectively in the three segments.

we are looking for the two change points u <dig> and u <dig> that minimise the sum of the squares of the deviations of the data to the model :

  f=∑j=13∑k=uj−1+1uj <dig> withu0=0andu3=n. 

the values of μ <dig>  μ <dig> and μ <dig> are defined as follows:

• μ1={∑k=1u1iku1if∑k=1u1ik>0∞otherwise

• μ <dig> = 0

• μ3={∑k=u2+1nikn−u2if∑k=u2+1nik<0∞otherwise

in the middle segment, μ <dig> equals zero, thus representing the breakpoint. in the two extreme segments the value of the function is the observed mean of i over the segment if the latter has the "correct sign". in order for the first  segment to represent an orthology relationship with sequence soa , the value of the function must be positive  meaning that it contains more hits with soa than with sob . if the observed mean in the segment has the wrong sign, the value is infinite; it ensures that this segment will not be part of the optimal solution since the contributions over this segment will be infinite.

observe also that u <dig> can be equal to  <dig>  or to u <dig>  and u <dig> can be equal to n. this provides the possibility for some segments to be empty, and thus to segment sequence i in less than  <dig> segments.

since the objective function is additive over the contributions of the positions, a dynamic programming algorithm efficiently provides the optimal partition  <cit> . notice that, since the number of change points is two, a simple algorithm scanning all possible partitions would be as efficient: the execution time grows with the square of the length n of sequence i.

speed-up
the problem we solve is, however, more constrained than the classical change-point detection problem. we show that the two change points u <dig> and u <dig> can be found independently in linear time with the length of sequence i instead of using the classical dynamic programming algorithm in o.

lemma  <dig>  given the sequence i of size n, such that for all k ∈ { <dig>  n}, ik ∈ {- <dig>   <dig>  1}, the positions u <dig> and u <dig>  with u <dig> = u <dig>  that minimise the function f  ) are such that:

• 1u1∑k=1u1ikis maximal,

• 1n−u2∑k=u2+1nikis minimal.

proof: first, by developing the square terms of each sum in function , we obtain:

 f=∑k=1nik2−1u12−1n−u <dig> 

the first term is a constant and the other two are independent from each other. thus f is minimal when the two last sums are both maximal, that is when s1=1u1∑k=1u1ik is maximal , and s2=1n−u2∑k=u2+1nik is minimal . however the solution must respect the condition u <dig> = u <dig>  we show next that this condition is always fulfilled.

let x <dig>  be the position on i that maximises s <dig> ). suppose x <dig> > x <dig> 

then:

 s1=1x1∑k=1x1ik=1x1∑k=1x2ik+1x1∑k=x2+1x1ik 

 s2=1n−x2∑k=x2+1nik=1n−x2∑k=x2+1x1ik+1n−x2∑k=x1+1nik 

• if ∑k=x2+1x1ik≥ <dig>  then s2≥1n−x2∑k=x1+1nik>1n−x1∑k=x1+1nik=s <dig>  thus s <dig> is not minimal.

• else ,s1<1x1∑k=1x2ik<1x2∑k=1x2ik=s <dig>  thus s <dig> is not maximal.

we therefore have that x <dig> ≤ x <dig>      □

statistical test
whatever the structure of the signal, the method will output the best segmentation of the data into at most three segments. it is therefore important to test if the data are actually structured into three segments, respecting the constraints mentioned above, or if there is no such structure in sequence i. in the latter case, the obtained change points do not make statistical sense and we must conclude that we are not able to refine the breakpoint based on the alignments.

the more a given sequence i of length n is structured into three segments, the lower will be the value of the minimised objective function , and thus the better will be the quality of the fit. what we need to test is therefore whether this fit is significantly better than the one that could be obtained with a non-structured sequence.

the null model is obtained by shuffling sequence i and computing for each permutation the value of the objective function corresponding to an optimal segmentation. since i represents the alignment hits, the positions are not independent from one another and the values of  <dig> and - <dig>  appear clustered. to take into account this structure in the shuffling operation, we do not shuffle individual positions, but instead blocks of consecutive identical values, given by the extremities of the hits. we accept the null hypothesis that i is not structured if more than five percent of the random permutations have a value that is lower than the value obtained by i.

building the synteny blocks
motivation
we now describe our own method for finding the synteny blocks. the general goal of such a method is to detect unbroken chains of markers which appear in the same order and same orientation in both genomes. depending on the nature of the markers however, the orthologous relationships can be more or less reliable, and some errors or misleading relationships may disrupt regions of conserved order and orientation. this is why in general more flexible blocks of synteny are constructed.

methods for identifying orthologous markers and for constructing synteny blocks are numerous in the scientific literature, starting with blocks built from physical or genetic maps of the chromosomes  <cit> , to conserved segments of genes or blocks grouping genomic markers from whole genomic alignments  <cit> . the method to refine breakpoints described in the previous section requires two properties of the synteny blocks. first, they must not overlap on one or the other genome because this would lead to non-existing sequences sr, soa or sob since the latter are defined as the sequences that stand between two consecutive blocks. second, the extremities of the synteny blocks must correspond to an orthology because they are used to define the sequences that will then be aligned. for example, in a block , the sequence at one extremity of ar should be orthologous to the sequence at the corresponding extremity on ao.

few methods for finding blocks available in the literature satisfy these requirements, and those that do so are either very computer intensive or are incompletely described heuristics. for example, grimm-synteny  <cit>  builds blocks by clustering markers that are close together, and keeps among the maximal clusters thus detected only those that are bigger than a threshold. the synteny blocks built by grimm-synteny may thus overlap. furthermore, since markers are clustered based on a distance criterion regardless of their order and orientation, the boundaries of a synteny block on any of the two genomes may be defined by two markers which are not orthologous. for instance, in the example of figure  <dig>  the synteny block composed of the three markers a, b and c would end, according to grimm-synteny, with marker c in the first genome and marker b in the second.

the synteny blocks defined by sankoff et al. in  <cit>  do not overlap, and orthologous markers inside a block appear in the same order in both genomes. however, since the problem they propose to compute synteny blocks is np-hard, the authors introduce some constraints in order to reduce their original dataset of markers and thus to address the complexity problem. this problem comes from the fact the authors do try to solve the conflicts that may appear and from how they do it. indeed, when two blocks overlap, the authors attempt to choose which one is the "best" according to some criterion. the one adopted corresponds to maximising the overall number of markers used.

various other methods based on chaining techniques produce synteny blocks that may overlap  <cit> . they are based on the same principle: two markers are chained if they appear in the same order and orientation in both genomes, and if they stand close enough to one another in terms either of a number of intervening  markers, or of the physical distance separating them. only long enough chains are kept, the length corresponding to the number of markers in the chain or the number of nucleotides covered by the chain. none of these methods mentions, and therefore deals with the problem of overlaps and of conflicts between distinct chains.

we then describe our own method for finding the synteny blocks. it is formally well described, and thus it is possible to prove some properties of the blocks found, in particular the ones that are necessary for the refinement of the breakpoints. it takes as input, as all other methods, pairs of homologous markers described by their position and orientation on each genome. though our approach is closely related to the ones of other published methods , working with formal definitions of the objects we are looking for guarantees that the synteny blocks we use satisfy the precisely characterised properties we need.

description
we take as input an integer number k and a set of anchors between two genomes gr and go. we call anchor a pair of markers, one in gr and one in go, which are orthologous. we consider only markers that do not overlap in both genomes and that are part of exactly one anchor . if chromosomes are arbitrarily oriented , a marker can be identified by the chromosome it lies in, its position on the chromosome and its orientation . since we are interested in the relative order of markers on chromosomes, we consider the rank of a marker on a chromosome rather than its physical position on it. an anchor is then identified by a pair of chromosomes, a pair of ranks , and a relative orientation. for instance, let a be an anchor, then a is identified by , with cr and ar the, resp., chromosome and rank of the marker on gr, co and ao the, resp., chromosome and rank of the orthologous marker on go, and σa equal to + <dig> if the two markers have the same orientation, - <dig> otherwise.

if two distinct anchors a and b are located on the same chromosome in both species, the distance between a and b, denoted by d, is the maximum of the rank differences between a and b on each genome: if ar, ao  are the ranks of anchor a  on the genomes gr and go, then d = max.

thus, if a and b are consecutive on each genome, the distance between them is one. if two anchors contain markers that are not in the same chromosome in at least one of the species, then the distance is ∞.

let then gk be a directed graph, with the anchors as vertices, and an arc between two distinct anchors a and b with ar <br, if d ≤ k, and either  or . arcs are identified by the labels of their start and end vertices . thus the arc between anchors a and b, if such exists, is denoted by ab.

at this step, if k is bigger than one, one anchor can be chained to several other anchors, possibly leading to connected components that overlap regarding genomic positions, or to boundaries of connected components that are not defined by a unique anchor. we say in this case that there is a conflict. we define two types of conflict:

• conflict of type i: two arcs ab and cd belonging to the same connected component of gk are said to be conflicting if the markers of the anchors a, b, c, d do not appear in the same order in both genomes ;

• conflict of type ii: an arc ab in a component c is conflicting if there exists an anchor x whose markers appear between the markers of a and b in one of the two genomes, and x belongs to a connected component of at least k vertices, different from c .

let now hk be the subgraph of gk which contains all the non-conflicting arcs of gk. a k-block is a connected component of hk containing more than k vertices. the extremal genomic coordinates of the k-blocks define the synteny blocks.

the absence of conflicting arcs of type ii ensures that the synteny blocks never intersect. moreover, the absence of conflicting arcs of type i ensures that in each component, the markers can be totally ordered in both genomes. this yields in particular that one anchor is unambiguously present at each extremity, so we have the required property that the extremities of the blocks in each genome are orthologous.

a polynomial-time computation of the blocks is straightforward from the definition: if n is the number of anchors, the computation of the ranks needs the application of a sorting procedure over all anchors in both genomes ). then, the computation of the graph takes time o, and produces at most k × n arcs. for each arc, detecting conflicts requires the comparison to at most k other arcs or vertices, leading to a total time complexity of o, where k is a fixed parameter .

discussion on the method
our method for finding synteny blocks is flexible and outputs totally ordered and non-intersecting k-blocks, which is the right entry for the refinement method described in the previous section. indeed, we build blocks of synteny by chaining orthologous markers that appear in the same order and orientation in the two genomes, but allowing for a number of intervening markers. the maximum degree of flexibility allowed is controlled by one parameter k.

this contrasts with most of the other methods which use two parameters  <cit> , one  for the maximum distance allowed between two anchors to be chained and the other , for the minimum size of a block to be retained. however, one should fix d ≤ s to prevent a block from lying inside another one. on the other hand, one should fix d ≥ s, to prevent a block of size less than s, which we thus consider as irrelevant, from breaking a bigger one. this is why we fix d = s, and denote it by k. actually, these two parameters d and s are often assigned the same value when the methods are applied .

flexibility is necessary, at least when dealing with orthologous markers whose orthology has been inferred from alignment methods. indeed, false positives are quite common in this case, particularly in the presence of paralogous sequences. thus, some false orthology assignments can generate "false" breakpoints, that is regions which have not been rearranged in either of the two lineages. the greater k is, the more reliable are the synteny blocks since they are supported by more anchors. however, using a bigger k has the drawback of missing small blocks . the outcome is not only less breakpoints, but also a decrease in the resolution of the remaining breakpoints. in fact, if a block is missed inside a breakpoint, we may not be able to refine it efficiently.

another outcome of introducing flexibility is that it may produce conflicts. conflicting arcs represent several chaining possibilities  or overlapping ones . instead of introducing constraints that may not always have an obvious or universal biological meaning, we choose not to solve the conflicts, but instead to discard them. this may seem like a radical solution and, indeed, it produces blocks that are sometimes not as long as they could be if we attempted to solve the conflicts. however, finding the synteny blocks is just one step towards refining the breakpoints and we find preferable to use reliable blocks. the information lost in this initial step will in most cases be recovered in the second step. if removing conflicting arcs implies only the reduction of a block at one of its extremities, the removed extremities on the two genomes will be aligned during the refinement step. on the other hand, if removing conflicting arcs implies missing a whole block, this block will probably not be recovered.

RESULTS
application to two mammalian comparisons
we applied the methods of synteny blocks construction and breakpoint refinement on two pairs of genomes. we detected and refined the breakpoints on the human genome  by comparison, first, with the mouse genome , and then with the dog genome .

for each pairwise comparison, we used the one-to-one orthologous genes available on the ensembl genome browser  <cit>  as anchors to build the 2-blocks  and locate the breakpoints. we applied the refinement method to all the breakpoints, except from those containing a human centromere. we included the sequences of orthologous genes at the extremities of the blocks in the aligned sequences, as suggested in the method section. finally, we applied the permutation test to determine if the change points from the segmentation process are significant. for the human-mouse comparison, starting with  <dig> non-overlapping one-to-one human-mouse orthologous gene pairs, we obtained  <dig> within a 2-block. we obtained  <dig> blocks and  <dig> breakpoints on the human genome, with  <dig> breakpoints without a human centromere in it. table  <dig> gives some statistics on the human-mouse blocks.

description of the 2-blocks obtained between human and mouse . the 2-blocks satisfy the definition given in section  <dig> for k-blocks with k =  <dig>  consecutive 2-blocks on both species, with the same relative orientations, have been merged.

out of the  <dig> refined breakpoints, only one is not significant for the permutation test of the segmentation. after further investigation, it appeared that this breakpoint corresponds to a mouse duplication, with the entire sequence sr aligned with both sequences soa and sob. figure  <dig> shows a histogram with the sizes of the breakpoints before and after refinement. on average, a breakpoint is reduced by  <dig> kilobases and we obtained after refinement  <dig>  breakpoints less than  <dig> kb in size .

concerning now the human-dog comparison, starting from  <dig> non-overlapping one-to-one pairs of orthologous genes, we obtained  <dig> within a 2-block. this led to  <dig> blocks and  <dig> breakpoints, with  <dig> without a human centromer in it. table  <dig> gives some statitics on the blocks.

description of the 2-blocks obtained between human and dog .

the permutation test of the segmentation was significant for all the  <dig> refined breakpoints. on average, a breakpoint is reduced by  <dig> kilobases, and we obtained after refinement  <dig>  breakpoints less than  <dig> kb in size .

comparison with alignment-based methods
we compared the breakpoint sizes obtained by our method with those of other publicly available datasets of breakpoints. we used three datasets of breakpoints between human and mouse, all of them based on whole genome alignment methods. the first two are obtained with the algorithm grimm-synteny, the first one is a pairwise comparison of human and mouse  <cit>  while the second is a multiple comparison between human, mouse and rat  <cit> . we call them, respectively, grimm <dig> and grimm <dig>  the third one is retrieved from the ensembl genome browser, version  <dig> and we call it ensembl. the method used in this case is succinctly described on the ensembl web page  <cit> : it consists, starting with blastz whole genome alignments retrieved from the ucsc genome browser  <cit> , in chaining alignments that are distant by no more than a certain max_gap in number of bp, and in discarding chained blocks which span less than min_len in size. it is similar to grimm-synteny, and to our synteny block generation method, except that conflicts are not taken into account. the breakpoints we have defined with our own method are referred to as the refined breakpoints, or refined for short.

for the three datasets, we computed the breakpoints as the regions between two consecutive synteny blocks on the human genome that are not consecutive on the mouse genome. we eliminated breakpoints containing a human centromere, and when synteny blocks overlap on the human genome, we considered the intersection as the breakpoint.

we started by globally comparing the distribution of the breakpoint sizes between the different datasets. the refined breakpoints are globally smaller than the breakpoints from the other datasets, with an average length of  <dig> kb versus  <dig>   <dig> and  <dig> kb for, respectively, grimm <dig>  grimm <dig> and ensembl . we compared each dataset with ours, using the wilcoxon rank sum test. the differences are highly significant with the respective p-values of  <dig>  085e –  <dig>  <  <dig>  2e –  <dig> and  <dig>  977e –  <dig>  when compared with grimm <dig>  grimm <dig> and ensembl.

the numbers are expressed in base pairs.

since all datasets do not contain the same number of breakpoints , one could argue that we do not compare the same breakpoints, and that the length difference observed is only due to dataset-specific breakpoints. in order to test this hypothesis, we compared the length of the breakpoints which are common to both the refined and the grimm <dig> sets. the coordinates of the grimm <dig> breakpoints lie on a different assembly version of the human genome . using the ensembl identifier of the orthologous genes bordering our breakpoints , we could unambigously identify  <dig> common breakpoints. for each breakpoint, we calculated the length difference between grimm <dig> and the refined breakpoints. the distribution of the length differences is plotted in figure  <dig>  on average, the grimm <dig> breakpoints are  <dig> kb bigger than the refined ones, which is significant to a paired wilcoxon test .

observe that the refined breakpoints are computed on a more complete human genome assembly, and some gaps in the former assemblies could have prevented the detection of some synteny blocks and led to their absence from the grimm <dig> dataset.

we made a similar pairwise comparison with the ensembl dataset, for which the breakpoints lie on the same assembly version as ours. we thus eliminated this potential assembly effect. we identified  <dig> common breakpoints and for each one, we calculated the length difference between the ensembl and the refined breakpoints. the average length difference remains positive, meaning that the refined breakpoints are smaller than the ensembl ones . the differences are less marked, as one third of the compared breakpoints differ by less than  <dig> kb .

we should however be careful with the latter results, as the ensembl dataset appeared not reliable in general. first, it contains less breakpoints than the other datasets , although it was obtained with less stringent parameters than grimm <dig>  which should give more breakpoints. moreover, the distribution of their length is unusual with some breakpoints very small and some very large. in particular, the biggest breakpoints  make us believe that some synteny blocks may have been missed inside. finally, if we compute the genomic coverage of the synteny blocks, we obtain that only  <dig> %  of the genome is covered by the ensembl blocks, whereas the coverage is much larger for the other datasets .

genomic features in the breakpoints
interestingly, even after refinement, the majority of the breakpoints are still big regions and are not reduced to a point. we wanted to test whether these regions have particular characteristics with respect to those inside the sequences newly appended to the synteny blocks by the refinement method. we thus compared the sequences of the breakpoints bigger than  <dig> kb detected in the human-mouse comparison with their flanking sequences, defined as the regions outside the refined breakpoints which are not in the original synteny blocks . we measured the coverage of each sequence in whole genome local alignments, human segmental duplications and transposable elements.

the motivation for measuring the presence  of whole genome  local alignments in a human sequence is that this is indicative of the similarity between the latter sequence and any part of the mouse genome. the whole genome local alignments were taken from the chain-net alignments files available on the ucsc genome browser  <cit> . the method is described in  <cit> . it appeared that breakpoints are depleted in local alignments  with respect to their flanking sequences  and the overall coverage of the genome  . this is statistically significant using a paired wilcoxon test . notably, 42% of the breakpoint sequences  have less than 5% of their length covered by a local alignment. observe that these alignments are obtained from whole genome comparisons and are not necessarily part of a synteny block. it suggests that a number of breakpoints, spanning sometimes several hundreds of kilobases, do not show any similarity with any part of the other genome. either they are very fast evolving sequences, or they correspond to insertions of new sequences in the human genome or to deletions in the mouse one. while some breakpoints show no similarity with any part of the genome, others show similarity with several parts, either in the human or in the mouse genomes, sometimes preventing us from being able to refine them. this is the case, for instance, of segmental duplications.

segmental duplications, also called low copy repeats, are large duplications , with a high percentage of identity , that are found in a small number of copies  and often clustered in mammalian genomes. recently  <cit> , it has been shown that breakpoints and duplications tend to co-localise. two different hypotheses have been suggested to explain this trend: either the duplications caused the rearrangements by similarity-dependent mechanisms, such as non allelic homologous recombination ; or the duplications accumulated at the same places because of an inherent fragility of these genomic regions. we observed here a similar trend. breakpoints are overall more covered by segmental duplications  than their flanking sequences . this is again statistically significant using a paired wilcoxon test . notably,  <dig> breakpoint sequences are almost entirely covered by segmental duplications .

other duplicated sequences, that do not have necessarily the same properties as segmental duplications  have been found associated with rearrangements. the duplicated sequences were found at each extremity of an inverted segment, in the opposite orientation  <cit> . an alternative mechanism to nahr was suggested, which is that the duplication may have appeared as a consequence of the rearrangement, as a fill-in of the gaps resulting from staggered break ends. thanks to our refinement step, we can suggest candidates for this situation: this is the case when the human breakpoint sequence coincides with the mouse duplicates located in the two corresponding breakpoints on the mouse genome, namely in sequences soa and sob . indeed, when a breakpoint aligns with both sequence soa and sequence sob, it corresponds to the middle segment of the numerical sequence i which contains many zeros. we can thus easily detect these special cases. for the human-mouse comparison, we obtain  <dig> breakpoints which present such characteristic . in  <dig> cases, the breakpoints are absent from the human-dog comparison, suggesting that the involved rearrangements occurred in the mouse lineage, and further arguing for a relation between duplication and rearrangement events.

finally, we observe a similar trend for transposable elements as for whole genome local alignments and segmental duplications. overall, breakpoints are richer in transposable elements than their flanking sequences , paired student test significant . when we distinguish for the different types of transposable elements , no significant difference is observed, except for ltr elements .

discussion and 
CONCLUSIONS
with the availability of whole genome sequences, one would have hoped to be able to compare genomes at the nucleotide level and thus to locate evolutionary events, such as rearrangements, up to a base pair. such precision is required, for instance, in order to identify potential footprints left on the sequence by a rearrangement. however, current available breakpoint data lack such precision. the goal of the method we presented in this paper is to obtain breakpoints as precise as possible. our strategy to achieve this is divided in two steps: the first one identifies reliable blocks and the second refines the breakpoint regions in between using the information  obtained in the previous step.

having reliable synteny blocks is a requirement to the refinement method, and is the reason why we chose to deal with markers that are genes. since they are functional elements, they are usually more conserved  than intergenic dna. moreover, orthology assignments for genes are computed at the aminoacid level, which is even more conserved. the genomic coverage of orthologous genes is less extensive than the coverage of the alignments obtained by a whole genome comparison method which may detect similarity even in the non coding parts of the genome. it thus leads to synteny blocks which present also a low genomic coverage. however, the synteny blocks can be extended beyond the genes, and eventually we may reach a better coverage than with whole genome alignments. nevertheless, we wish to emphasise that the method described here is not restricted to this kind of synteny blocks, and that it can also be applied on synteny blocks originally obtained from whole genome alignments for instance.

the advantage of proceeding in two steps is that by reducing the search space for homology in the first step, we can look for weaker similarity inside the breakpoint regions in the second step. this is one of the reasons why our method gives more precise breakpoints than whole genome alignment methods. indeed, the latter operate in a single step, and require the use of stringent enough parameters to avoid obtaining blocks which are not orthologous. however, one drawback is then that they miss weak similarity inside the breakpoints.

we have shown here that this similarity does exist inside breakpoints and synteny blocks may indeed be refined, as was already pointed out by  <cit> , and we propose a quantitative method to this end.

the second argument accounting for the gain in precision of our method is based on the number of genomes compared. with the availability of an increasing number of fully sequenced genomes, methods using more than two genomes to identify synteny blocks are often privileged. however, we chose to develop a pairwise method. the motivation is to gain even further precision. comparison of the breakpoint sizes show that 3-way blocks  give bigger breakpoints than those obtained with a pairwise comparison  using the same method, even when adopting less stringent parameters. this comes from the fact that the grimm <dig> anchors are three-way, meaning that one anchor represents an orthologous marker in each of the three species. this leads to more confident anchors than pairwise ones, but it also reduces the set of anchors and thus the size of the synteny blocks.

although multiple comparisons could be useful to compute the synteny blocks, we argue that to refine breakpoints, a pairwise method is preferable. indeed, this enables to be more sensitive in the detection of homology. moreover, it also allows to discriminate between one or several rearrangement events in a seemingly common region. for example, suppose two breakpoints are very close to each other on the human genome, one being observed by comparison with the mouse genome, and the other with the dog genome. investigating the two breakpoints by pairwise  comparisons allows to determine whether they overlap position-wise as in figure  <dig>  using a multiple comparison, if the two breakpoints are too close to each other , only one breakpoint may be identified. an example of this is given in figure  <dig> where two distinct breakpoints are perceived as fused when doing a multiple comparison while pairwise comparisons enable to separately identify the two. it thus seems preferable to, first, identify precisely breakpoints between two genomes, and then to compare them with the breakpoints obtained in other species comparisons while trying to infer their evolutionary relationship. this strategy could be useful to estimate the amount of rearrangement re-use in independent lineages. as an example, we obtained five cases where a mouse breakpoint and a dog breakpoint do not overlap and are less than  <dig> kb apart on the human genome .

finally, comparison of the breakpoints with their flanking sequences confirms previous studies of rearrangement breakpoints where loss of similarity, enrichment in segmental duplications and in transposable elements were revealed  <cit> . moreover, it shows that breakpoints are actually regions which can be distinguished from the remaining of the genome, and reinforces the belief that breakpoints are indeed regions, and not single points.

authors' contributions
cl developped and implemented the method. all authors participated in discussions and writting of the paper.

supplementary material
additional file 1
dataset of the breakpoints between human and mouse. the file contains the coordinates of the breakpoints obtained with the method described in the paper, with the human genome as reference, compared with the mouse genome. the breakpoints lie on the human genome . the file format is plain text, each line corresponds to one breakpoint, and there are three columns  separated by a space.

click here for file

 additional file 2
dataset of the breakpoints between human and dog. the file contains the coordinates of the breakpoints obtained with the method described in the paper, with the human genome as reference, compared with the dog genome. the breakpoints lie on the human genome . the file format is plain text, each line corresponds to one breakpoint, and there are three columns  separated by a space.

click here for file

 acknowledgements
the work presented in this paper was funded in part by the aci nouvelles interfaces des mathematiques  of the french ministry of research, by the arc  from the inria and by the anr .
