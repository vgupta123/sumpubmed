BACKGROUND
automatic extraction of biomedical events from texts has been a major focus of biomedical natural language processing  research in recent years. an event consists of a trigger expression , zero or more participants  of the events which may be entities or other events with their roles , and hedge attributes . figure  <dig> illustrates an example of event structures in the cancer genetics   <cit>  task. in this figure, there are three events  that are represented with triggers , their roles  and argument events or entities . several event extraction systems have been developed as a result of the bionlp shared tasks  since  <dig>  <cit> . the systems have been applied both to pubmed abstracts and pubmed central full papers. the extracted events have been successfully used in the creation of resources, e.g.,  <cit>  and in practical applications, e.g., for pathway curation and reconstruction .

the use of these resources and applications has revealed that a wider range of event types and structures needs to be discovered by the event extraction systems than those addressed in the earlier bionlp shared tasks, in order that the extracted events are able to cover as many as possible of the phenomena described in biomedical articles. the bionlp shared task  <dig>  introduced several tasks to address the problem. in particular, the cg and pathway curation   <cit>  tasks defined a range of new entity and event types in the context of biomedical problems that had not previously been dealt with in the shared tasks. given that both cg and pc tasks cover a greater number of bio-entity, role and event types than previous tasks, e.g., genia  <cit> , event recognition becomes increasingly difficult since the systems need to extract correct event types and structures from a larger number of possible types and structures. although both the representation and format of events are shared among many of the bionlp subtasks, most event extraction systems participating in the bionlp shared tasks have focussed only on a limited number of specific subtasks. this is largely due to the difficultly in applying a specific event extraction system to different tasks without carrying out considerable modifications to the system. it can thus be very costly and time-consuming to tune an event extraction system to deal with new event types. accordingly, we have developed a novel method which allows an event extraction system to be applied to new tasks with competitive levels of performance, but without the onerous effort of development and tuning.

in this paper, we describe the integration of our novel method within our state-of-the-art event extraction system, eventmine  <cit> , allowing it to be adapted to new tasks without internal modification and only minimal effort, without sacrificing performance  <cit> . eventmine has been enhanced with configurability, that allows it to be applied to new tasks with minimum manual effort and adaptability, that allows it to retain competitive levels of performance. adaptation of the system to new tasks requires only that changes are made to a configuration file that is used to specify the task-specific information. in order to allow the system to adapt itself to new task specifications and achieve consistent performance, without the need for exhaustive tuning of the parameters of machine learning algorithms in eventmine, we have integrated a weighting method, a covariate shift method  <cit> , and their combination into eventmine. the enhanced, adaptable version of eventmine has subsequently been applied to new tasks, i.e., the pc and cg tasks of bionlp-st  <dig>  the state-of-the-art performance achieved by eventmine on these tasks  clearly demonstrates that the system can successfully be adapted to multiple new tasks through the specification of only minimal configuration information, and without the need for deep tuning.

method
in this section we firstly introduce eventmine, and then describe how it has been extended to facilitate more straightforward adaptation to new tasks. we conclude by describing how it has been applied for the bionlp-st subtasks of cg and pc.

eventmine
eventmine  <cit>  is an svm-based pipeline event extraction system that has been applied to several biomedical event extraction tasks, and has achieved the top-ranked performance on several corpora  <cit> , in comparison to other systems. eventmine consists of four modules: a trigger/entity detector, an argument detector, a multi-argument detector and a hedge detector. the trigger/entity detector enumerates the triggers/entities in the training data, finds words that match the head words  of the triggers/entities, and classifies each word into specific entity types , event types  or a negative type that denotes that the word does not participate in any events. for example, the word of in figure  <dig> has a negative type. the argument detector enumerates all possible event-role pairs among triggers and arguments that match the semantic type combinations of the pairs in the training data, and classifies each pair into specific event role types  or negative role types . in figure  <dig>  there is no relation that holds between overexpression and tgf-beta, so they have a negative role type. here, an event role type consists of a trigger type and an argument type with its role type. similarly, the multi-argument detector enumerates all possible combinations of pairs that match the semantic type structures of the events in the training data, and classifies each combination into an event structure type  or a negative type. here, an event structure type consists of a trigger type and argument types with their role types. the hedge detector attaches hedge attributes to the detected events by classifying the events into specific hedge types  or a negative type.

all the classifications are performed by using one-vs-rest support vector machines . the detectors use the types or type combinations mentioned above as their classification labels. labels with scores higher than the scores of the separating hyper-plane of svm and labels with the highest scores are selected as the predicted labels. classification is treated as a multi-class, multi-label classification problem with the requirement that at least one label  is selected during the prediction process. classification makes use of both lexical and syntactic features. these features consist of character n-grams, word n-grams, shortest paths among event participants within parse trees, and word n-grams and shortest paths between event participants and triggers/entities outside of the events within parse trees. we replace all gold  entity names with their types to avoid the models being tuned to specific entities. to reduce feature space cost, we compress the feature space to  <dig> by hashing  <cit> . we assign greater weights to the positive instances to alleviate class imbalance and we normalise the feature vectors for each type  as well as for the entire vectors, and set the c parameter for svm to  <dig> 

eventmine generates training instances based only on predictions by the preceding modules in the pipeline, thus ensuring that training is not carried out on instances that cannot be detected by the preceding modules. if the generated instance corresponds to gold instances, then the semantic types assigned to the gold instances are assigned to the generated instance. otherwise, a negative type is assigned to the generated instance. this mode of instance generation allows us to obtain similar distributions of training and test instances, as it is impossible to detect them if the participants are missed by the preceding modules.

extension of eventmine
this section describes how eventmine has been enhanced to allow it to be applied to new tasks with minimum manual effort, whilst retaining good levels of performance. we firstly explain the incorporation of a configuration file that allows eventmine to be applied to new tasks without internal modification of the system. subsequently, we introduce three methods which, based on the information provided in the configuration file, allow eventmine to adapt itself to carry out new extraction tasks without the need for parameter tuning.

the tees- <dig>  system  <cit>  has a similar motivation to ours regarding ease of adaptation to a range of different tasks, and it has been applied to several event extraction tasks in the bionlp-st  <dig>  both tees- <dig>  and eventmine are pipeline-based systems and extract labels required for classification from the training data. however, they vary in terms of their approaches to implementing adaptability. tees- <dig>  does not require user-provided configuration information and applies an automated, but time-consuming, hyper-parameter tuning method that uses the development data set. in contrast, eventmine takes user-provided configuration information and employs three methods that remove the requirement for parameter tuning, as explained in the following section.

configurability of eventmine
configuration of eventmine to new tasks is facilitated through the specification of task-specific information within a configuration file. figure  <dig> shows an example configuration for the cg task. this configuration file requires users to list the types of triggers  and roles  of interest with listing gold trigger/entity types  and trigger/entity types that need to be predicted . entities do not need to be explicitly specified under another "heading" in the configuration file because they can be calculated from the other "headings", i.e., entity types are those that are in gold and prediction, but not in triggers. based on the information provided in the file, eventmine enumerates all the structures among the user-specified types under both gold and prediction that appear in the training data, and uses them to generate candidate instances for use in training each of the detectors in the pipeline introduced above. these type settings are also used so that eventmine can automatically enumerate gold triggers/entities in the training data and use them to generate candidate instances in the trigger/entity detector. these type settings are further required so that eventmine can be applied to annotated data without the need to prepare separate gold  and prediction  files, which are the official formats of the bionlp sts. by specifying which types are gold in the configuration file, eventmine can flexibly change the task settings, e.g., the system can be configured to predict the types that are specified in the a <dig> files, or to treat types in the a <dig> files. although this specification of types is indispensable for eventmine, it can be automated by creating the configuration file from the training data in the bionlp st format. manual configuration is required only when users need to change the task settings and/or specify generalisations and other options, as detailed below.

the configuration file also includes two types of generalisations: one for labels and features  and one for instance generation . these generalisations are used in both training and prediction phases since they should be performed in similar situations.

label and feature generalisations reduce the number of event role types and event structure types that are used as classification labels, and the number of features used by all detectors. the event role types and event structure types are combinations of types of triggers and participants with their roles, as explained in the eventmine section. the generalisations help to reduce the computational and space costs of both training and prediction since these are dependent on the number of the classification labels. the generalisations are indispensable for the two tasks in the bionlp-st  <dig>  since the tasks cover a greater number of bio-entity, role and event types than previous shared tasks, meaning that there are thousands of potential event structure labels. considering all of these possible labels without carrying out generalisations would create an intractable problem for eventmine. although the effects of the generalisations on event extraction performance cannot be evaluated on the tasks since it is infeasible to run eventmine without them, the generalisations have both advantages and disadvantages: the generalisations may alleviate the data sparseness problem during training, but they may also induce over-generalised features when they are applied to the tasks with enough training instances. the generalisations are applied to event role and event structure labels, since the types in these labels include types that are predicted by other detectors. for example, an event role label positive_regulation:theme-phosphorylation contains positive_regulation and phosphorylation, which are predicted by the trigger/entity detector. label and feature generalisations are possible in the following three cases: firstly, trigger/entity types are predicted by the trigger/entity detector, so their prediction is not required in the argument and multi-argument detectors. secondly, the role types are predicted by the argument detector, so their prediction is not required in the multi-argument detector. thirdly, the numbered role types, e.g., theme, theme <dig>  are predicted in the multi-argument detector, so their prediction is not required in the argument detector. the numbered role types are required in events since the numbers indicate the correspondence between roles. for example, if an event has two themes and the second theme has a corresponding instrument, their roles will be theme <dig> and instrument <dig> to differentiate from the first theme and instrument. it is difficult to predict argument numbers without knowing the other arguments involved in the event, so the numbers are predicted in the multi-argument detector. these generalisations are also applied to the generation of the features used by all detectors. for example, generalisations of gold entities can be used as the basis of generating features used by the argument/trigger detector.

instance generation generalisations are used to expand the possible event role types and event structure types to create instances in prediction. the instance generation generalisations may introduce noisy instances but they may also generate instances of event structures that otherwise would not have been considered, due to lack of evidence in the training data. for example, even if there are no positive_regulation:theme-gene_expression instances in the training data, such instances are also created in prediction when there are regulation:theme-gene_expression instances in the training data and there is a rule in the configuration file specifying that positive_regulation and regulation event types should share the event structures. the rules for the instance generation generalisations are applied whenever instances are created for prediction. the instance generation generalisations are included separately from the label and feature generalisations since the latter may introduce illegal or unrealistic event structures. for example, if we specify to share the event structures of phosphorylation and dna_methylation in instance generation in cg and transfer the event structures of phosphorylation to dna_methylation, dna_methylation with molecule as theme will be illegally created 

in addition to the task specific settings, the configuration file is designed to specify other options, e.g., parsers, domain adaptation methods, dictionaries, etc. although we acknowledge that the achievement of high levels of performance on a specific task is largely dependent on determining the most appropriate combination of various methods and resources such as the above, our aim here is to demonstrate the configurability and adaptability of eventmine, rather than trying to achieve the highest possible performance for the tasks considered. accordingly, the settings for the configuration options introduced above are the same as those used in our previous application of eventmine to the epigenetics and post translational modifications  task, as described in  <cit> , unless otherwise noted. specifically, we employ both a deep syntactic parser, enju  <cit>  and a dependency parser, gdep  <cit> . we utilise liblinear-java  <cit>  with the l2-regularised l2-loss linear svm setting for the svm implementation, murmurhash <dig>  <cit>  for hashing, and snowball  <cit>  for stemming. we use no external resources  or tools  except for when we use external corpora to create stacked models for the pc task, as explained later.

adaptability of eventmine
although the above-described configuration file allows eventmine to be straightforwardly configured to new tasks, this does not in itself guarantee that the performance of the system on such new tasks will be of an acceptable quality. in other words, we need to ensure that eventmine is adaptable to new tasks. in all four modules of the event extraction pipeline, eventmine needs to solve classification problems. some of the issues relating to the 1-vs-rest classification method employed are dependent of the settings of the hyper-parameters, which should be tuned to allow the classifiers to work to their full potential. however, it is costly and time-consuming to search for the best setting from the many possible hyper-parameter combinations. there is no general, efficient method to automatically tune the parameters within in a pipeline setting and it is also unrealistic to assume that the hyper-parameters can be effectively tuned for new tasks without exhaustive searching and knowledge of how the system works.

in order to ensure effective and efficient adaptability of eventmine, we have developed a novel adaptation process that avoids the need to carry out hyper-parameter tuning when the system is being configured for new tasks. this process makes of two different methods, i.e., a weighting method and a covariate shift method  <cit> . the latter is a novel approach, which has not been employed in any other event extraction system. we also combine the methods, and investigate the potential benefits of this combination. the weighting method adds weights to the positive instances in the training data. although this method has previously been integrated into eventmine  <cit>  and its application in the context of event extraction is not novel, we introduce in order to realise our goal of achieving maximum adaptability of the system, and in order to investigate its combination with the covariate shift method. weighting positive examples has been empirically shown to improve several event extraction tasks, since it alleviates the class imbalance problem. this weighting method modifies the objective function of an l2-regularised l2-loss linear svm as follows:

  arg minw wtw+nnnpc ∑inploss+c ∑innloss 

here, xp and xn are the positive and negative instances, nn and np are the numbers of negative and positive instances, and loss is a squared hinge loss that is defined as loss = max <dig>  weighting is used in the bionlp shared task evaluation . this objective function makes the cost of the errors for all the positive instances close to one for all the negative instances, in order to encourage the classifiers to avoid prediction scores that are biased by class imbalances. the function also assigns greater penalties to rare instance errors. nn is usually larger than np in the 1-vs-rest svm, and this function achieves high recall for each module and consequently for the entire pipeline process. high recall is desirable for practical applications like semantic search, since such applications need to recognise as many events as possible. achieving high recall in each individual module of the pipeline can additionally be advantageous, since it can increase the number of training instances available for training successive modules in the pipeline. covariate shift methods generally aim to address the problem of varying distributions of instances between a training data set  and a target data set . our method estimates instance distributions in the target data set by solving an additional binary classification problem between training and target data sets using a logistic regression classifier  <cit> . the additional classification problem treats training data sets as one class and target data sets as another class. equation  <dig> shows the objective function of svm with the covariate shift method.

  arg minw wtw + ccs ∑inlloss,l=ntrainntarget⋅ptargetptrain,ccs=n∑inlc 

here, ptrain and ptarget are the outputs of the logistic regression classifier, and ntrain and ntarget are the numbers of training and target instances. this puts weights l on all the training instances according to their likelihood of appearing in the target data set. l represents the test-to-training ratio p/p, where λ denotes the training distribution and θ denotes the test distribution, and it is known that the loss on the test distribution can be minimised by weighting the loss on the training distribution with the ratio  <cit> . in contrast to the originally proposed method in  <cit> , our novel method introduces ccs that keeps the balance between the regularisation and loss terms, since the l can suffer from overfitting of the training and target instances and the imbalance of the numbers of training and target instances. if we set all the weights l to  <dig>  this is equal to the objective function of svm. this objective function tries to make the distribution of the instances close to one for the target data set. this means that it encourages the classifiers to learn more about instances that seem to appear in the target data set.

the weighting and covariate shift methods are not exclusive and it is possible to combine them. to take advantage of the strengths of both methods, we also propose in a novel way to merge the two objective functions in a straightforward manner.

  arg minw wtw + ∑innl∑inplccs ∑inplloss+ccs ∑innlloss 

if we set all the weights l to  <dig>  this is equal to equation  <dig> 

the weighting and covariate shift methods are incorporated into eventmine by applying them to all the classifications in the four modules of the system. the hyper-parameter c is kept to  <dig> for all the experiments, as mentioned in the previous section. these methods may not necessarily produce the same levels performance that could be achieved by parameter tuning through exhaustive search. however, given the costly nature of such parameter tuning, as described above, our method makes the problem of adapting eventmine to new tasks much more feasible, whilst still allowing good levels of performance to be achieved. since it is difficult to carry out exhaustive parameter tuning, it is not possible for us to compare the results of our novel methods with those that could be achieved through such tuning. instead, we show in our experiments that incorporation of the new methods within eventmine can improve the performance of the system on both the pc and cg tasks of the bionlp-st  <dig>  to a level that is competitive with other systems that participated in these tasks.

configuration of eventmine for bionlp-st  <dig> tasks
in the following sections, we describe eventmine's configuration for the cg and pc tasks, based on the notions of configurability and adaptability.

configuration for the cg task
the cancer genetics  task  <cit>  aims to extract information from bio-processes related to the development and progression of cancer. the annotations in the training data were based on the multi-level event extraction  corpus  <cit> .

the configuration for our shared task submission used several label and feature generalisations, which are shown in figure  <dig>  for the event role types, generalisations for the trigger types, role types and argument types were applied as follows. in terms of the trigger types, we generalised the three regulation types, i.e., positive_regulation, regulation and negative_regulation into a single regulation type, and post-transcriptional modification  types  into a single ptm type. in terms of role types, numbered role types were generalised as non-numbered role type . in terms of argument types, event types were generalised as a single event type and entity types were generalised as a single entity type. these generalisations, except for the entity generalisations, are the combination of the generalisations used in the genia, epi, and infectious diseases   <cit>  annotated corpora of the bionlp-st  <dig>  <cit> . for the event structure types, the same generalisations are applied, except for numbered role types, which are retained, since these are important in differentiating different types of event structures. unlike other types, the numbered role types in events are not predicted by any other modules than the multi-argument detector as we explained in the configurability of eventmine section.

further experiments carried out after the shared task involved a more fine-grained classification of entities into three general types defined in the hierarchy of entity types defined for the cg task, i.e., anatomical, pathological, and molecular, instead of using a single entity type, as in our shared task submission. in terms of instance generation generalisations, we applied them only to the regulation event types, to avoid introducing unexpected event structures.

configuration for the pc task
the pathway curation  task  <cit>  aims to support the curation of bio-molecular pathway models, with the training texts selected to cover both signalling and metabolic pathways.

for our shared task submission for this task, we incorporated a stacking method  <cit> , by training our models, using the same configuration as described above, on seven other available corpora: genia, epi, id, dna methylation  <cit> , exhaustive ptm  <cit> , mtor  <cit>  and cg. the stacking method uses the prediction scores of all the models as additional features in the detectors. although some of these corpora may not be directly related to the pc task and the models trained on them can produce noisy features, we have used all the corpora, since stacking has been shown to improve performance  <cit> . also in common with our work on the cg task, we have carried out further experiments after the shared task. the stacking method was not employed in this latter set of experiments, since our aim was to focus on the three methods introduced in the section on adaptability of eventmine.

we employ the same type of generalisations as in the cg task described in the previous section, except for entity types. for our shared task submission, entity types were generalised to a single entity type, similarly to our submission for the cg task. for our experiments that followed the shared task, a different type of entity generalisations to the one performed for the cg task was carried out, according to the different entity type definition for this task. the only type of entity generalisation we performed in the context of the pc task was to collapse the gene_or_gene_product and complex types into a single protein type. the other two entity types used in the corpus, i.e., simple chemical and cellular component, retained their original labels. the generalisation is based on the reference resources of the entity type definition  <cit> .

RESULTS
we have evaluated eventmine using the various configurations introduced in the previous sections. we firstly evaluated the system using settings employed for our shared task submission, which incorporated the use of the configuration file and the weighting method, but not the covariate shift method and task-specific entity generalisations. we compare our official results with those achieved by the best system that participated in the pc and cg tasks apart from eventmine, i.e., tees- <dig>   <cit> . this evaluation is also presented in  <cit> . subsequently, we evaluated the differences in performance that were obtained through the integration of the weighting method, the covariate shift method and their combination, together with the refined entity generalisation settings.

evaluations on instance generation generalisations and stacking
we evaluated the effect of applying instance generation generalisations and stacking to the pc development data set. the results are summarised in table  <dig>  for this evaluation, we used the same settings as those used in our shared task submission, i.e., we added weights to positive examples as in equation  <dig> and we generalised all entity types into a single type. the scores were calculated using the evaluation script provided by the organisers with the official evaluation metrics . the generalisations improved recall at the slight expense of precision, and they slightly degraded the f-score. the generalisations were applied to the test set in our shared task submission, since slightly higher recall is favourable for practical applications like semantic search  <cit> . whilst the use of the stacking method slightly improved performance, this improvement is not statistically significant  using the approximate randomisation method  <cit> .

instance generation generalisations  and the stacking method  are applied to the pc development data set.

official scores for the shared task
tables  <dig> and  <dig> show the official scores of eventmine when applied to the test data sets for the cg and pc tasks. our system ranked second in the cg task and first in the pc task. there were six participants for the cg task and two participants for the pc task, and the scores of the top performing systems  are shown in table  <dig>  and the scores of the best system among the other participating systems  are shown for reference in table  <dig>  the performance of the third-ranked system is  <dig> % lower than our system, in terms of f-score, as shown in table  <dig>  therefore, we will focus on the comparison with tees- <dig> . our system achieved the highest recall for both tasks, which is considered favourable, as mentioned above. this high recall is understandable, since we solved the problems as multi-label classification tasks in which the class imbalance problem was addressed through the application of the weighting method and the incorporation of instance generation generalisations. the performance of eventmine on both the cg and pc tasks  is slightly lower than that achieved by the system on the genia and id tasks in the bionlp-st  <dig>  <cit> , but is comparable to the performance obtained on the epi task. this may be partly because the genia and id tasks deal with fewer event types than the other tasks.

highest scores are shown in bold.

highest f-scores are shown in bold. we refer the reader to the papers of the tasks  <cit>  for the details of the event categories.

although eventmine did not achieve the best overall results in the cg task, we still consider that the performance level achieved is promising, given that we did not incorporate any external resources, and we did not carry out any tuning of parameters . a detailed comparison with tees- <dig>  shows that tees- <dig>  outperformed eventmine in the recognition of anatomical and pathological event categories, which constitute event types that have not been addressed in previous shared tasks. this indicates eventmine missed some of the novel structures introduced in these new event types. however, eventmine performed better than tees- <dig>  in the recognition of some other types of events involved in the task. the performance range of eventmine in recognising the various event types covered by the cg task is similar to the scores achieved by the system when applied to the mlee corpus  although we cannot directly compare the results since the corpora are not completely same and the test sets are different. the ranges of the scores are around 60% to 70% f-score for non-nested events , 40% for nested events  and 30% for modifications . this large range of scores may be caused by a cumulative combination of errors in predicting triggers, participants and modifications, since a similar spread of accuracy has been observed for previous tasks . also, previous tasks like genia provided more training instances per type than the cg task, but the ranges of scores are broadly similar. these results indicate that further improvements to the performance of the system may require more than a simple increase in the training instances. eventmine performed particularly well on the pc task which is an encouraging result in demonstrating the adaptability of the enhanced system, since it was a completely novel task for the system. the recall achieved by our system was considerably higher than that obtained by tees- <dig> .

evaluations on the weighting and covariate shift methods
our next set of experiments evaluated the weighting method, the covariate shift method, and their combination, explained in section on adaptability of eventmine  as a baseline system comparison, we used the version of eventmine that did not incorporate these methods.

as explained in the description of the task-specific configurations of the system above, this evaluation differed from the other evaluations in two ways. firstly, stacking was not employed for the pc task. secondly, we used refined entity type generalisations, i.e., detailed entity type generalisations based on the individual task definitions were employed in the task settings.

we show the results of the evaluations for the cg and pc development data sets in table  <dig>  without the integration of the new methods, eventmine tends to produce high precision results, but with a large imbalance between precision and recall. the tendencies towards high precision are also seen in the results obtained by eventmine in the bionlp-st  <dig> evaluation .

as evidenced in table  <dig>  the use of both the weighting and covariate shift methods improve the recall by a significant margin. additionally, the previously mentioned discrepancies between precision and recall become far less pronounced when these methods are employed. in most cases, a slight increase in f-score is obtained, with the exception of when the weighting method alone is applied to the pc development set. in terms of results achieved when the weighting and covariate shift methods are combined, the improvement observed on the cg development set is statistically significant, i.e., p =  <dig> . this improvement is surprising, since the discrepancy of the distributions between the training and test data sets is considered to be small. this is because the shared task data sets are controlled - the documents in the training and development data sets are selected using the same criteria and the separation aims for an even distribution of instances between the training and development data sets. this improvement serves to demonstrate the difficulty in preparing controlled separation of data sets. the covariate shift method accesses the target data in advance and tunes the system for the target data, meaning that the model is not suitable for application to other data. thus, it may not be appropriate to compare the results obtained on the test set with the results of other experiments. the improvement observed through the application of this method, however, provides evidence that it is possible refine the model based on the target data in a general way. this is important when we apply the models to other document collections, such as pubmed. the results in table  <dig> demonstrate how the incorporation of the adaptation methods enhances the performance of the system on the pc development set, compared to the version of the system used for the shared task . the comparison of these tables shows that exhaustive entity type generalisation  had a negative effect on precision for the pc task, and that incorporating some simple task specific knowledge, by assigning generalised semantic types to the entities, according to the individual task descriptions, can boost the performance of the system. we also compared the baseline method with the combination of the weighting and covariate shift methods on the cg and pc test data sets, as shown in table  <dig>  similarly to table  <dig>  the combination method improved the recall performance on both test data sets by a large margin in total . as a result, the method improved the f-scores achieved by the system. for the cg test set, the use of the combined method shows a slight improvement over the use of either of the methods individually . for the pc task, a lower f-score was obtained than for the original shared task results shown in table  <dig>  since that version of the system made use of the stacking method, the positive effect of making use of information from multiple corpora is clearly demonstrated. table  <dig> also shows that the combination method improves the recall performance on all the categories, and improves the f-scores except for anatomy  and pathol  in the cg task and non-reg  in the pc task. this result indicates that the combination method does not work well on these categories, and this might be one of the reasons why eventmine cannot match the performance of tees- <dig>  on the anatomy and pathol categories. in particular, the method significantly improved the performance on mod . this is partly because the high recall increased the number of training instances for modifications, and also partly because the method reduces the imbalance between precision and recall.

stacking is not used for the pc task.

CONCLUSIONS
in this paper, we have described the development of an adaptable event extraction system, which accepts task-specific information in the form of a configuration file, and employs methods that alleviate the need to carry out extensive tuning of the system to allow it to be applied to new data sets. the new system has been created by enhancing an existing state-of-the-art event extraction system, eventmine. the configuration file is used to specify the definitions of types  and generalisations over these types that are used to adapt the system to new tasks. the provision of this configuration information alleviates the need to carry out task-specific modification of the system. furthermore, to avoid the costly process of extensive parameter tuning to make the system suitable for application to new data sets, three adaptation methods are employed, i.e., a weighting method, a covariate shift method and their combination. the weighting method aims to alleviate class imbalance, while the covariate shift method aims to automatically adjust the differences in the distributions of instances in the training and target data sets. the enhanced system was applied to the cg and pc tasks with minimal task specific configuration. in the context of the bionlp-st  <dig>  only the weighting method was employed to facilitate the adaptation of the system to the specific tasks. this version of the system achieved the second best performance in the cg task and the best performance in the pc task. following the shared task, we were able to further improve the results, though the incorporation of the covariate shift method, combined with task-based generalisation of entity types, the latter of which preserves some semantic information about entities that was lost in the more extreme generalisation of the entities used in the shared task version of the system.

the positive results obtained through the integration of our novel methods demonstrate that the enhanced version of eventmine can be effectively adapted to new tasks, without the need to make changes to the system itself. the weighting method, covariate shift method, and their combination have all been demonstrated to be useful in facilitating automatic tuning of the system to the new tasks. the success of applying the covariate shift method to the shared task data underlines its potential importance in future event extraction research, as a means to resolve the differences between the training and target data sets, which is a vital step to support the development of accurate and practical applications. based on these results, our future work will involve investigating the feasibility of applying the covariate shift method to larger data sets e.g., pubmed, as a basis for the development of more practical applications. in this scenario, however, and in contrast to the training and test data sets of the shared tasks, there remain several issues to be resolved. these issues include the much larger differences in distributions between the training and target data sets, the vast number of target documents and the lack of standard evaluation criteria. moreover, unlike in the shared tasks, the named entities are not given and their detection exhibits similar problems to the above. whilst these problems are all challenging, we believe that it is vital for them to be addressed, in order to facilitate a significant improvement in the adaptability of event extraction systems to new tasks, and to allow their use in new practical applications.

competing interests
the authors declare that they have no competing interests.

authors' contributions
both authors contributed to the production of the manuscript. mm built the system and carried out the experiments. sa supervised all steps of the work. both authors read and approved the final manuscript.

