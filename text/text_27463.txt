BACKGROUND
the center string problem  is defined as follows: given k strings of length l over an alphabet Σ and a distance threshold d, find a string of length l that has hamming distance at most d to each of the given strings.

the center string problem has been studied extensively in theoretical computer science and, particularly, in computational biology  <cit> , and has various applications such as degenerate pcr primer design  <cit>  or motif finding  <cit> . we are particularly interested in its application as part of finding approximate gene clusters. the increasing speed of genome sequencing and the resulting increase in the number of available data sets offers the possibility of comparing the gene order of whole genomes. during the course of evolution, speciation results in the divergence of genomes that initially have the same gene order and content. conserved gene order is evidence of a particular biological signal  <cit> . approximate gene cluster models account for reordering inside the gene cluster, as well as additional and missing genes in the genomes compared  <cit> . the center gene cluster model limits the distance between the gene cluster and each of the approximate occurrences. for given approximate occurrences, finding the center gene cluster is equivalent to finding a center string for binary input strings.

previous work
the center string problem is np complete  <cit> , hence no polynomial time algorithm can exist unless p = np. different approaches have been studied for the problem. ma and sun  <cit>  presented a polynomial time approximation scheme with time complexity  for an approximation ratio of  <dig> + ε for any ε >  <dig>  in addition, heuristics and parallel implementations with good practical running times have been developed  <cit> . the drawback of these approaches is that they cannot guarantee that an exact solution will be found.

in parameterized algorithmics, we use a parameter to describe the complexity of a problem instance. we restrict the super-polynomial running time of an algorithm using this parameter while at the same time still guaranteeing that optimal solutions are found. formally, a problem with input size n and parameter k is fixed-parameter tractable if it can be solved in o · p) time, where f is an arbitrary function and p is a polynomial. parameters that have been studied in the literature for the center string problem are the distance threshold d and the number of input strings k. for the latter parameter, gramm et al.  <cit>  showed that the problem is fixed-parameter tractable using an integer linear program. evaluations indicate that this approach is of theoretical interest only and impractical for k ≥  <dig>  regarding the distance threshold d, in the same paper an algorithm was given with running time o. later, ma and sun  <cit>  presented an algorithm with running time od). recently, wang and zhu  <cit>  further improved running times to od), and chen et al.  <cit>  to o for binary strings. these algorithms are based on the search tree paradigm. note that for binary strings, the term d vanishes.

besides these fixed-parameter approaches, meneses et al.  <cit>  proposed a heuristic to compute upper and lower bounds using a branch-and-bound algorithm and, very recently, kelsey and kotthoff  <cit>  investigated a constraint programming approach.

all of the above results, as well as our results presented below, deal with the center string problem under the hamming distance. nicolas and rivals  <cit>  showed that the center string problem under the levenshtein distance is np-hard and w <cit> -hard regarding the number of input strings, even for binary strings. on this account, no fpt algorithm with parameter k can exist unless fpt = w <cit> . furthermore, the authors generalized these results to any weighted edit distance satisfying a certain natural condition, namely, a slightly tightened triangle inequality . note, that center string is polynomial if the number of input strings and the weighted edit distance are fixed  <cit> .

our contribution
in this paper, we focus on exact methods that are also swift in application. we have developed an advanced preprocessing to filter out unsolvable instances quickly. additionally, we compute rules that can be used within search tree algorithms to bound the search space, excluding unsolvable instances. we show how to integrate this information into the algorithms from  <cit> . we then present a new iterative search strategy called mismatchcount, which, despite its bad worst-case running time, works well in practice. we implemented all three algorithms to evaluate their performance in combination with our preprocessing. we present results of our experimental evaluation, showing that preprocessing and the novel algorithm improve running times by several orders of magnitude. we find that, in particular, the cases d = dopt -  <dig> and d = dopt are notoriously difficult for all approaches, where dopt is the smallest distance value for which a solution exists.

a preliminary version of this paper has been published in proc. of workshop on algorithms in bioinformatics, wabi  <dig>  volume  <dig> of lect. notes comput. sc., springer 2010:325- <dig> 

methods
preliminaries
for a string s over a finite alphabet Σ, let s be the ith character of s and s the substring of s starting at position i and ending at position j. the length of s is denoted by |s|.

the hamming distance dh of two strings s and t of the same length l is the number of positions p with s ≠ t. let r = {p <dig> ..., pm} ⊆ { <dig> ..., l} be a set of positions such that pi <pi+ <dig> for all  <dig> ≤ i <m. then s|r := s ... s denotes the subsequence of s restricted to the positions in r. we define the hamming distance of two strings s and t restricted to r as . for two strings s and t, let ds, t := {p : s ≠ t} ⊆ { <dig> ..., l} be the set of positions where s and t differ, and let es, t := {p : s = t} = { <dig> ..., l}\ds, t be the set of positions where s and t are identical. note that . for k input strings s <dig> ..., sk, we write  and . as noted in the introduction, we will often limit ourselves to a binary alphabet Σ = { <dig>  1}, here, we define .

the center string problem is defined as follows: for strings s <dig> ..., sk of length l over an alphabet Σ, and a distance threshold d, find a string ŝ of length l, called center string, which has hamming distances at most d to each of the given strings.

we note that permuting positions of all strings by the same permutation, results in an equivalent instance. let π be a permutation over positions  <dig> ..., l. for a string s = s ... s of length l, let π := s) s) ... s) be the permuted string. let s <dig> ..., sk be an instance of center string problem, in which all strings have length l. then, a given string s has hamming distance at most d to all strings s <dig> ..., sk, if and only if π has hamming distance at most d to all strings π,..., π. for k strings s <dig> ..., sk and distance threshold d, we can construct a naïve kernel as follows  <cit> : a position p is called clean if all sequences coincide at this position, i.e. si = sj for all  <dig> ≤ i <j ≤ k. if a position is not clean, we call it dirty. one can easily see that there can be at most kd dirty positions if an instance with k strings allows for a center string with distance d. if a position is not dirty, then all strings share the same character at this position, and the center string will also share this character. we can thus remove all clean positions and obtain an instance of length l ≤ kd. now let us assume that d is given to us as a parameter. again, we remove all clean positions from the instance. if the resulting strings have more than kd characters, the instance can be rejected. similarly, we can reject an instance that contains a string pair with distance larger than 2d, since the hamming distance is a metric and satisfies the triangle inequality. in our algorithms, we assume a distance threshold d to be given. in applications, we might not know the distance threshold d in advance but instead search for a center string minimizing d. we can do so by calling our algorithms repeatedly, increasing d =  <dig>   <dig>   <dig> ... until a solution is found for d = dopt. both in theory and in our experimental evaluation, we find that the running time of this iteration is governed by the last subroutine calls with d = dopt -  <dig> and d = dopt. to this end, we will put special focus on these two cases in our evaluations.

our proposed data reduction often allows us to infer that no solution can exist for a particular distance threshold d. however, where we cannot rule out the existence of a center string by data reduction , we still have to decide whether a valid center string exists. all algorithms for doing so, such as those presented in  <cit>  and the mismatchcount algorithm presented in this paper, scan through all 2l possible binary strings and test whether any such string is a center string of the input. the algorithms differ in the order in which they process the 2l strings and, in particular, how they constrain the search space to speed up computations.

data reduction
our data reduction is based on the pairwise comparison of the input strings. given an instance s <dig> ..., sk and d of the center string problem, we can divide all pairs of strings {si, sj} into three groups: pairs with distance less than 2d -  <dig>  greater than 2d, or equal to 2d or 2d -  <dig>  if two strings si, sj with hamming distance dh > 2d exist, then the instance has no solution. a center string ŝ can have at most distance d to each of si and sj and, hence, dh ≤ dh + dh ≤ 2d. therefore,  must hold for the instance to have a solution.

solving trivial positions
some positions of the solution string can be trivially solved. this is based on the following observation:

lemma  <dig>  given strings s <dig> ..., sk and a center string ŝ with distance d. for two strings si, sj such that dh = 2d or dh = 2d -  <dig>  we have  

proof. a center string with distance at most d to all strings is located centrally between the two strings si and sj with distance 2d and therefore has distance d to both of them. thus, all positions fixed between si and sj must also be fixed in ŝ. we can extend our reasoning to string pairs with distance 2d -  <dig>  we need to change d positions in at least one of the strings and ei,j is the set of equal positions between both strings, hence we are still not allowed to change any position p ∈ ei,j.

as a reduction rule, if we find two strings si, sj with dh ≥ 2d -  <dig>  then we can set ŝ := si for all p ∈ ei, j and mark these positions as "permanent". let  denote this set of permanent positions. we can generalize this rule to solve additional positions. assume a specific di := d for each input string si, which is increased by one for every solved position that does not match si. if we find two strings si, sj with dh = di + dj, we can again set ŝ := si for all p ∈ ei, j and mark these positions as "permanent". in the case di = dj the rule remains the same as that given above. we repeat this rule until no fitting string pair si, sj can be found.

applying this reduction rule, we may run into conflicts where we have to permanently set a certain position to '0' and '1' simultaneously. we infer that the instance has no solution for the current choice of d. if we do not have a conflict, then applying this data reduction results in a partially solved solution string ŝ with ŝ = c ∈ ∑ fixed for all , whereas all positions not in  still have to be decided.

computation of position subsets
we focus next on pairs of strings si, sj with dh < 2d -  <dig>  for a given center string ŝ we define  

as the set of positions where si and sj agree, but disagree with the center string ŝ. we extend the reasoning behind lemma  <dig> as follows:

lemma  <dig>  given strings s <dig> ..., sk and a center string ŝ with distance d. for two strings si, sj such that dh <2d -  <dig>  we have  

proof. set d := di, j. regarding the distances between ŝ|d and si|d as well as sj|d, we can state that ŝ|d has a distance of at least  to at least one of the strings si|d or sj|d:  

this is true since dh is a metric and the triangle inequality holds, dh ≤ dh + dh. since we need a distance of at least  to solve the positions from d, a distance of at most  remains to solve the positions from ei,j.

lemma  <dig> implies that the maximum number of positions p ∈ ei, j that we are allowed to choose in the center string with ŝ ≠ si is bounded by . we can transform this observation into a reduction rule as follows: when, during search tree traversal or by other reduction rules, we have a partially solved solution string ŝ such that  

for any pair si, sj, then we can infer that ŝ cannot be extended to a solution for the current choice of d. for each pair si, sj, we therefore set  and store all tuples  in an array .

removing redundant information from  may lead to further trivially solved positions. this is done by removing, for all  <dig> ≤ i <j ≤ k, all positions from ei,j. moreover, if ŝ ≠ si then we decrease xi,j by one.

for xi,j =  <dig> we set all positions p from ei,j to "permanent" and include them in . since  has changed, we continue our data reduction again until there is no tuple  with xi,j =  <dig> in . for xi,j <  <dig> we can easily infer that a conflict must exist and, as a result, the instance has no valid solution for this distance threshold d.

cascading
to enlarge further the number of solved positions we consider all pairs of strings si, sj with xi,j =  <dig> and use cascading. a valid center string ŝ has to agree with si in at least |ei,j| -  <dig> positions from ei,j, hence for binary strings, at most one position p ∈ ei,j can be set to 
.

to this end, we test for all positions p ∈ ei,j what we can infer from setting  this implies xi, j =  <dig>  hence we add the remaining positions q ∈ ei,j, q ≠ p, to  and reduce the tuple set . if we run into a conflict during this reduction, we know that setting  cannot result in a valid solution. in this case, we infer ŝ = si and permanently set position p.

unfortunately, if there is no conflict, setting ŝ = si is not mandatory. nonetheless, we get a partially solved solution string ŝp,v and a set of "potentially permanent" positions  depending on the position p and the value . we store this information in a set of rules .

we can use the set of rules  when solving the remaining instance, for example by means of a search tree algorithm. if, during the search tree traversal, we decide to set ŝ = v for the solution string ŝ, then we can immediately start the above data reduction. for all positions , we set the solution string ŝ = ŝp,v. for the remaining positions  the condition ŝ = ŝp,v must be met, otherwise we run into a conflict and, thus, this branch of the search tree does not lead to a valid solution.

integration into search tree algorithms
we can use the information derived during preprocessing, stored in the sets , , , to speed up the algorithms of ma and sun  <cit> , and gramm et al.  <cit> . unfortunately, the use of , ,  does not change the worst-case running times of both algorithms. but our preprocessing, as an algorithm engineering technique, allows us to speed up the algorithms in practice.

the algorithm of ma and sun tackles the more general neighbor string problem. given s <dig>  s <dig> ..., sk of length l and non-negative integers d <dig>  d <dig> ..., dk, find a string ŝ of length l such that d ≤ di for every  <dig> ≤ i ≤ k. the algorithm starts by testing whether s <dig> is already a valid solution. if not, there has to be at least one  with . for these two strings s <dig> and . we create the sets of equal positions  and different positions , as well as the substrings s1|d and . note that . from these strings, one can infer that  and . to fit s <dig> to the solution string ŝ, it is necessary to change the positions in d without exceeding the limits d <dig> and . thus, for any string t of length |d| we test whether t = ŝ|d is a possible solution. hence, the width of the search tree is based on the number of strings t that fulfill the condition  

for these eligible strings t, we obtain a new branch of the search tree by creating a new neighbor string instance. the new distance thresholds ei depend on the distance of t to the substrings si|d, so ei := di - dh. for e <dig> we have the additional constraint . for further information about this approach, see  <cit> .

the algorithm of gramm et al. is a depth-bounded search tree that is initialized with any s ∈ {s <dig> ..., sk}, which is adapted step by step to the solution. the first step is to find a string si that differs from the candidate string s in more than d positions. if no such string exists, then s is a valid solution. otherwise, we change s until a center string ŝ is found or more than d positions in s are changed. this results in a maximum tree height of d. from the set  we choose d +  <dig> positions to branch, leading to a total tree size of d = o. since  and , at most d elements from  do not converge to a solution. therefore, choosing d +  <dig> elements from  produces at least one exact move. for a detailed description of the algorithm, see  <cit> .

integrating the set of solved positions  into the algorithm of ma and sun is straightforward, since we can delete all solved positions and decrease di by one for every mismatch.

for the algorithm of gramm et al. we cannot have different di, hence we have to test whether or not the position is permanent within the search tree. assume s is the candidate string. for any position p from  we set s := ŝ. during the algorithm, we ensure that none of these positions is changed. let  be the set of positions that are not permanent. for each string si we can estimate the distance threshold di between  and  as described for neighbor string instances. instead of choosing d +  <dig> positions to branch, we now have to choose only di +  <dig> positions from . given that, for all positions in , the candidate string was set to the value of the solution string, there are no positions  with si = ŝ, and hence . since  and  at most d - d + di positions do not a converge to a solution. therefore, among the di +  <dig> possible modifications from , there is at least one that brings us towards a solution.

to integrate and , we exclude branches which cannot produce a valid solution. branches are pruned by simply testing whether the  string candidate of the search tree conflicts with the information. for a position p from a particular neighbor string instance we use m to denote the corresponding position in the original instance.

in the algorithm of ma and sun, when creating all strings t of length |d|, we test for their consistency with the rules from . assume t = p <dig> ... pl with pi ∈ d, ≤  <dig> i ≤ l. for all pi ∈ d,  <dig> ≤ i ≤ l we check whether there is a rule  and test if the remaining positions in t are consistent with the partially solved solution string. if that is not the case, the current t will not lead to a valid solution. there is even more information in  that we can use. if we find a t  that is consistent with , we use the solved positions from all sets , with  <dig> ≤ i ≤ |t|, to reduce the neighbor string instance for the recursion step. for that reason we build an overlay of all  with pi ∈ d to get a new set of solved positions. furthermore, we can check the consistency of t with . for all  we test whether t has more inconsistent positions than are allowed. assume t = p <dig> ... pl. we count all positions pn with m ∈ ei, j and si ≠ t. if there are more than xi,j of these positions, the current t is not consistent with  and hence cannot produce a valid solution.

in the algorithm of gramm et al., we can restrict the positions we can choose to branch. assume sk is the string with dh >d. we can only branch over a position p if we checked the following condition for all  containing p: if s = si ≠ sk we would have to change s to sk, thus we would set . for that reason we have to check at how many positions from ei,j the candidate string s differs from si. if this number is at least xi,j, we are not allowed to set a further position p to  and hence we interdict branching over p. now, let p be the current position to branch at, and set v := si. if  contains ŝp,v, we have to adapt the candidate string s to ŝp,v before calling the recursion. if s conflicts with ŝp,v, this branch of the search tree does not lead to a valid solution.

algorithm mismatchcount
even after applying our data reduction rules, we have to solve the remaining instance using an algorithm such as those from  <cit> . in this section we present another such procedure, mismatchcount, which is effecient in practice, as we will show below. given binary strings s <dig> ..., sk of length l and a distance threshold d, the mismatchcount algorithm solves the closest string problem as follows: we iterate through all strings s with distance at most d to a chosen string si -- without loss of generality, we may choose that string to be s <dig> =  <dig> ...  <dig>  this leaves us with a search space of size . we present an enumeration scheme for those s that allows effecient testing for the center condition on each candidate and that makes it possible to skip large areas of the search space based on information gained while checking those candidates.

we enumerate the mismatch positions for d mismatches in s <dig> , which is equivalent to generating all binary numbers of length m with d bits set to  <dig>  in reverse order . for every s we check its hamming distance to the remaining strings s <dig>  s <dig> ..., sk. rather than computing these distances anew for each candidate, we update the hamming distances derived from the previous candidate s'. we do this by increasing or decreasing the distances to reflect the changed positions.

the running time for verifying a center candidate s is therefore bounded by o, where g is the number of positions changed from s' to s.

we can determine the overall number of changes performed during the enumeration of all center candidates as follows: using the enumeration scheme presented, each position p in s is changed once to '1' and once to '0' for every configuration of s with at most d mismatches to s <dig>  there are  such configurations for each d' =  <dig>   <dig> ..., d. summing over all possible combinations of p and d', the number of bit changes performed can be bounded by o. since we need to update k hamming distances for each character change in s, the overall worst-case running time of the algorithm is bounded by o.

however, this worst-case analysis refers to the exploration of all legal mismatch configurations of s. as already mentioned above, the enumeration scheme enables us to skip large areas of the search space. using the maximum hamming distance dmax = maxi =  <dig> ...,k) computed in each iteration, we can derive a lower bound for the number of positions we have to change in s in order to fulfill the center condition. therefore, for each candidate s taken into consideration, we compute , where  <dig> cmin is the minimum number of positions in s we have to change when its successor is generated. we can use this condition in two ways. first, we cannot change  <dig> · cmin positions in s by changing the positions of fewer than cmin mismatches. therefore, if all current candidates s with dh = d' are enumerated and we encounter a candidate that reveals a cmin >d', we can then generate candidates with dh = cmin, without the enumeration of all s with dh ∈ {d', d' +  <dig> ..., cmin -1}.

furthermore, even if cmin does not exceed d' for a currently observed candidate, we can use that bound to skip the enumeration of certain candidates, i.e. continue with the enumeration scheme where the cmin-th mismatch from the right is moved next . the enumeration steps in between can be omitted because they involve moving fewer than cmin mismatch positions and we know that we have to change at least  <dig> · cmin positions in s.

applying the data reduction to this algorithm is straightforward. recall that  is the set of positions that are not permanent. then, the reduced instance is . when estimating for every candidate s its hamming distance to each remaining string si, we have to add the additional amount  to the distances of the reduced strings. this is done only once at the beginning, since we update the hamming distances during the algorithm.

within the other algorithms we use the information from  and  to cut off branches of the search tree that cannot contain a valid solution. however, mismatchcount uses an iterative search strategy and positions are not going to be fixed, but can be inverted again. therefore the use of  and  to fix positions interferes with the use of cmin to skip the enumeration of certain candidates.

RESULTS
generating center instances
to evaluate our algorithms, we use instances generated in the context of finding approximate gene clusters. the order of genes in genomes can be used to determine the function of unknown genes, as well as the phylogenetic history of the organisms. on this global scale, each gene is represented by one character , and orthologous genes are mapped to the same character. gene clusters are sets of genes that occur as single contiguous blocks in several genomes. unfortunately, the requirement of exact occurrences of gene clusters turns out to be too strict for the biological application. this leads to the development of the center gene cluster model  <cit> , which we recapitulate shortly in the following.

let s <dig> ..., sk be the genome strings, where each character represents a gene from the alphabet Σ. let sj denote the substring of sj from position lj to position rj. let  be the set of genes in a string s ∈ Σ*. finally, let d be the symmetric set distance, d = |c \c' | + |c' \c|. for some distance threshold δ, the center gene cluster model asks for all gene clusters c ⊆ Σ of some minimal size such that, for each j ∈ { <dig> ..., k}, there exist lj, rj with  

now, the important point is that the algorithm for center gene cluster detection  <cit> , computes candidates instead of directly finding center gene clusters. these candidates are intervals ,...,  such that the sets  might allow for some center c ⊆ Σ with d ≤ δ for all j =  <dig> ..., k. our task is to check if the resulting center does indeed meet the distance threshold.

we can transform the approximate occurrences cj, for j =  <dig> ..., k, to binary state strings by iterating over all genes that appear in at least one approximate occurrence, using '1' if the approximate occurrence contains the gene, and '0' if it does not. the order of genes is not important in this transformation, but has to be identical for all strings, see also the preliminaries. searching for a center gene cluster under the symmetric set distance, is equivalent to searching for a binary string in the transformed instance under the hamming distance.

the resulting instances are often rather "short", as most approximate gene clusters contain only few genes. to construct longer and, hence, harder instances for our evaluation, we simply concatenate several of these short instances  into one long instance, being a single block of k binary strings. this allows us to evaluate the performance of the different methods at the borderline between "tractable" and "intractable" instances. at the same time, we argue that the resulting instances are still "biologically valid."

for our evaluation, we use genomes from the ncbi genome database http://www.ncbi.nlm.nih.gov/sites/entrez?db=genome. grouping of genes into gene families is done based on the cluster of orthologous groups categorization http://www.ncbi.nlm.nih.gov/cog/. we used two protocols to construct the two data sets, where we believe the second data set to be closer to the biological application that we have in mind.

for the first data set we used five γ-proteobacteria . each approximate gene cluster instance consists of five approximate occurrences, one on each genome. an approximate gene cluster instance is converted to five binary strings, as described above. we concatenated instances  until the desired length l was reached. additional strings were constructed in the same fashion, incorporating further cluster occurrences. we created up to  <dig> instances for each combination of k and l with k =  <dig>   <dig>   <dig>   <dig> and l =  <dig>   <dig> ...,  <dig> 

five γ -proteobacteria from the ncbi genome database, used for detection of approximate gene clusters to generate biological instances of the center string problem. 'refseq' is the reference sequence from ncbi genome database, 'pc' the number of protein-coding genes.

we generated the second data set using  <dig> genomes . to obtain larger instances, we concatenated smaller instances until a pre-defined length l was reached. we created  <dig> instances for each combination of k and l with k =  <dig>   <dig>   <dig>   <dig> and l =  <dig>   <dig> ...,  <dig>  note that we do not "concatenate instances vertically", so the resulting instances are probably closer to the "biological truth" than those of the previous protocol.

genomes from the ncbi genome database used for detection of approximate gene clusters to generate biological instances of the center string problem. 'refseq' is the reference sequence from ncbi genome database, 'pc' the number of protein-coding genes.

to compute dopt we have to increase d stepwise, starting from the lower bound for dopt, given by . we removed all instances that could not be decided for any d with dlower ≤ d ≤ dopt within a time limit of  <dig> minutes by any of the algorithms, since we cannot determine the right dopt. this left us with  <dig> instances for the first data set and  <dig> instances for the second one.

removing trivial columns
to avoid taking trivial columns into account, we kept only the dirty columns, representing the "hard part" of the instances. we use l' to denote the length of these reduced instances. we stress that in the following, all computations and evaluations are performed on these reduced instances. the amount of reduction shows the difference between the two data sets. while in the first data set we only kept between  <dig> % and  <dig> % dirty columns, the instances from the second data set are much harder, containing on average between  <dig> % and  <dig> % dirty columns, depending on the number of strings. the number of dirty columns increases with the number of strings .

we concentrate on the computation of center strings for d = dopt and d = dopt -  <dig>  since these are the computationally hard instances . for the parameterized algorithms, worst-case running times grow exponentially in d, and running times of algorithms are also dominated by these cases in practice.

excluding unsolvable instances by preprocessing
our preprocessing allows us to exclude unsolvable instances more efficiently than the computation of the naïve kernel, when d is too small for a center string to exist. this is of particular interest as, here, our algorithms have to scan the complete solution space to ensure that no solution exists. recall that, during the computation of the naïve kernel, instances with more than kd dirty columns or  are rejected, since the instance cannot have a solution for this choice of d. the percentage of instances excluded by preprocessing for d = dopt -  <dig> ranges between  <dig> and  <dig> . our improved preprocessing always filters out more instances than does the naïve kernel. for different k, we can exclude between  <dig> % and 100% of instances, that have not been filtered by the naïve kernel for the first data set and, for the second data set, we can exclude between  <dig> % and  <dig> % of instances. recall that the instances we removed  have not been filtered by preprocessing for their lower bound d. since we cannot determine whether this lower bound is the real dopt or dopt -  <dig>  these instances are not taken into account, leading to the high percentages in the first data set.

solving trivial positions by preprocessing
the second advantage of our method is the computation of positions that can be trivially solved during preprocessing. the percentage of fixed positions is high for the important case d = dopt. in fact, for the first data set an average of  <dig> % of the positions were fixed for these instances during preprocessing, and  <dig> % for the second data set. recall that mismatchcount and the algorithm of ma and sun work on these reduced instances. the number of solved positions depends on the dopt /l' ratio of the instance, since at least l' - 2dopt are fixed if a string pair with distance 2dopt exists, and decreases with increasing dopt /l' . if we use dopt /l' as a measure for the hardness of the instance, the difference between the two data sets is obvious.

for the first data set we further observe that there is no "twilight zone" of fixed positions. in  <dig> % of the instances, more than 40% of positions were fixed; in  <dig> %, the data reduction did not fix any positions, and in fewer than  <dig> % of the instances, we observed a fixing of up to 40% of positions.

running times
we have implemented the algorithms of gramm et al.  <cit> , ma and sun  <cit> , and the mismatchcount algorithm, referred to as "gramm", "masun" and "mismatchcount", respectively. these algorithms do not include any preprocessing beyond the naïve kernel. name suffix "pre" indicates that preprocessing and algorithm engineering are enabled. for the mismatchcount algorithm, only the information from  is used.

we implemented all algorithms in java and compiled them with the sun java standard edition compiler version  <dig> . we did all computations on a quad-core  <dig>  ghz amd opteron processor with  <dig> gb of main memory under the solaris  <dig> operating system. the running times presented are the core running times of the algorithms and do not include i/o or removal of clean columns. we restricted running time to  <dig> minutes per instance.

we first show that running times of all algorithms are really dominated by the cases d = dopt -  <dig> and d = dopt . it is clear that it is sufficient to concentrate on the two cases d = dopt -  <dig> and d = dopt. the short running times for dopt -  <dig> for the first data set are again due to the removal of instances for which the lower bound could not be decided. note that if there is no string pair with distance 2dopt or 2dopt -  <dig>  we cannot avoid calling the algorithm with d = dopt -  <dig> to ensure that dopt is truly optimal.

to show how running times depend on dopt, we pooled instances with respect to the optimum center distance dopt. for d = dopt -  <dig> we excluded all instances where d <l'/k after removing clean columns, or  as these obviously have no solution, leaving us with  <dig> instances for the second data set, while the  <dig> remaining instances for the first data set are not enough to analyze. even if instances are not rejected by preprocessing, the algorithms tend to reject instances more quickly if the preprocessing information is used. different percentages were rejected by the algorithms within different sets of time limits for the second data set .

only the  <dig> instances of the second data set not rejected by the preprocessing were taken into account. 'mc' denotes the mismatchcount algorithm.

using data reduction and information gained during preprocessing reduces the running times of the algorithms for both d = dopt -  <dig> and d = dopt in all cases . on the first data set, mismatchcount using the preprocessing information outperforms the other algorithms, while masunpre is best on the second data set, especially where d = dopt. the improvement of mismatchcount is least significant since the information from  and  cannot be used.

CONCLUSIONS
we have presented improved preprocessing for the center string problem. this is based on the observation that, for strings with an optimal center at distance d, there are usually many pairs of strings with distance close or equal to 2d. our data reduction allows us to reject more instances that do not have a valid center string, and to draw conclusions about certain positions of a center string. we show how this information can be used in the search tree algorithms of gramm et al., and ma and sun. we have also presented the mismatchcount algorithm for binary alphabets.

in our experimental evaluation, we showed that, without preprocessing, the mismatchcount algorithm has better running times than the other two algorithms. furthermore, our data reduction is very efficient and algorithms using this information outperform the original ones, with the overall best performance shown by mismatchcount on the first data set and the algorithm of ma and sun in combination with our preprocessing on the second. our data reduction is particularly helpful for tackling the case d = dopt -  <dig>  as we can exclude more instances.

for the levenshtein distance and weighted edit distances, the center string problem problem is w <cit> -hard regarding the number of input strings. to the best of our knowledge, it is an open problem if these problems are w <cit> -hard regarding the distance parameter, too. in this case, our parameterized methods would be not applicable for these distances.

authors' contributions
fh and sb jointly developed the data reduction methods. kj, lk and js jointly developed the mismatchcount algorithm. fh carried out the computational studies and drafted the manuscript. all authors read and approved the final manuscript.

