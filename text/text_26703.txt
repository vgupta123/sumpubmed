BACKGROUND
genomics witnessed an unprecedentedly deep change a few years ago with the arrival of the next generation sequencers  also known as high throughput sequencing . these technologies enable sequencing of biological material  at much higher throughput and at cost that is now affordable to most academic labs. these new technologies generate gigabyte- or terabyte-scale datasets. the size of datasets is one of the two main bottlenecks for ngs. the other bottleneck is the analysis of generated data. current technologies cannot output the entire sequence of a dna molecule, instead they return small sequence fragments  of length around a few hundred base pairs. without a reference genome, reconstructing the entire sequence from these fragments  is challenging, especially in terms of computational resources. for instance, whole genome assembly of sequencing data from a mammalian genome requires hundreds of gigabytes of memory and several cpu weeks of computation
 <cit> .

with sequencing costs falling, sequencing efforts are no longer limited to the main species of interest . thus, biologists are increasingly working on data for which they do not have any close reference genome. in such situations, de novo assembly of reads is often carried out as a preliminary step. however, complete assembly is not always feasible, either because sequencing data is not adequate  or computational resources are too costly. moreover, it should also be noted that assembly algorithms perform heuristics that lead to suboptimal reconstruction of the original sequence, possibly generating incomplete or erroneous fragments
 <cit> . especially, highly-similar occurrences of a repeated sequence can be collapsed into a single fragment.

we seek to establish that many biological questions can be answered by analyzing unassembled reads. in particular, the user may possess a priori information on which he wants to focus. in this spirit, we present the mapsembler software. mapsembler checks if a known piece of information - a sequence fragment called a starter - is present with a bounded number of substitutions in a set of reads. the starter can be shorter, longer or equal to the read length. if the starter is indeed present, mapsembler constructs an assembly around the starter, either as a plain sequence, or as a graph showing divergences and convergences in the neighborhood structure. the read coverage per position is provided. the aim of mapsembler is not to produce contigs as long as possible, hence it should not be used as a de novo assembler nor be directly compared with such software. its aim, after the detection of the presence of approximate occurrences of a starter, is to output their neighborhoods on some hundreds or thousands of nucleotides, providing pieces of information about the starter context. as presented in the results section, these micro targeted assemblies provide relevant biological information such as the occurrences of elements known to be repeated, snps, gene fusions, alternative splicing events…

mapsembler includes a simple yet effective error correction step removing most substitution errors present in the reads. as insertions and deletion errors are not corrected, mapsembler performs better on reads provided by technologies generating a small amount of such errors as illumina technology for instance.

another key aspect of mapsembler is that its memory usage is independent from the size of the read sets. this enables mapsembler to analyze huge sets of reads on a simple desktop computer.

mapsembler inputs are a sequence fragment or a set of fragments called the starter, and a set of reads. applications of mapsembler cover a broad range of biological questions, including but not limited to: 

• for a known biological event, e.g. a snp , a splicing event  or a gene fusion , mapsembler can be used to check its presence in a set of reads, and to provide abundances in each case. this is done by using as starter a fragment localizing the event.

• do these genes have close homologs in this set of reads ? similarly, do these enzymes exist in this metagenomic set, or do these exons expressed in this transcriptomic set? using genes or the enzymes or exons as starters, mapsembler detects their presence and their approximate copies, and also reconstructs the genomic context for each copy. the exact coverage per position is provided both for the copies and for their contexts.

• in case of complex genomes, one may be interested in finding approximate repeated occurrences of known sequence fragments . using such sequence fragments as starters, their occurrences within a fixed hamming distance are found and their flanking regions are recovered as a graph.note that this approach is limited to a small number of slightly differing occurrences. indeed, graph-based mapsembler results are mainly designed to be visually inspected.

•mapsembler can be used to detect all reads corresponding to known contaminant organelles, or symbionts. this enables for instance to remove such reads from a dataset before further analysis.

the symbol  indicates that an example of this use case is given in the results section. furthermore, it is important to note that mapsembler operates without a reference genome.

methods
the mapsembler algorithm can be divided into two main phases: 

 <dig>  mapping. mapsembler detects which starters correspond to consensuses of reads, subject to coverage constraints and up to a bounded number of substitutions. such starters are said to be read coherent .

 <dig>  de novo assembly. each read coherent starter is extended in both directions. in accordance to user choice: 

 the extension process is stopped as soon as several divergent extensions are detected. in this case, the output is a fasta file containing the consensus assembly around each starter;

 the extension process continues even in the case of several divergent possibilities. extensions are represented as a directed graph. each node stores a sequence fragment and its read coverage per position. this graph, is output in xgmml or graphml format. several tools, including gephi
 <cit> , cytoscape
 <cit> , and cobweb
 <cit>  can be used to display such graph formats.

mapsembler presents the advantage of not indexing reads but only starters . in practice, independently of the size of the read file , it is possible to run mapsembler on any desktop or laptop computer, not requiring large memory facilities.

the mapping phase performs several tasks. a maximum number d≥ <dig> of substitutions  is authorized between a starter and each read. consequently, for a single starter s, several distinct read subsets that align to s yield distinct consensus sequences. these sequences are called sub-starters , see figure
1a for an example. we discard sub-starters for which the distance to s exceeds d. a local assembly is initiated from the extremities of each sub-starter.

definitions
we first introduce some notations and definitions used throughout the paper. a sequence ∈Σ∗ is a concatenation of zero or more characters from an alphabet Σ. a sequence s of length n on Σ  is represented by s <cit> s <cit> …s, where s∈ Σ  ∀ 0≤i<n. we denote by s  the sequence ss…s of s. the sequence s occurs position i in s. its length, denoted by ], is equal to j−i +  <dig>  the hamming distance dh between two sequences ω <dig>  and ω <dig>  of equal length is the number of positions at which the corresponding characters are different: 

  dh=∑i=0i<|ω1|1ifω1≠ω20else. 

definition  <dig> 
given two sequences ω <dig> and ω2∈Σ∗, and
i∈z, we define dh as the hamming distance of the overlapping part between ω <dig> and ω <dig>  considering the first character of ω <dig> aligned to position i on ω <dig>  formally,
dh=∑j=0j<|ω2|dω1i+j,ω <dig>  where
d=0ifα=βorα=ε,1otherwise. the character ω <dig> is equal to εif a prefix of ω <dig>  is not aligned with ω <dig> and/or if a suffix of ω <dig>  is not aligned with ω <dig> 

definition  <dig> 
given a sequence s∈Σ∗, a read r∈Σ∗  is said to be mapped to s at position i iff dh≤d, where d is a fixed threshold.

the notation
s∥idr denotes that r maps on s at position i, with threshold d.

example  <dig> 
given s=attcgga, r=gaatgcg and threshold d= <dig> 
s∥−21r is true as dh=1: 

  −2−10123456s=atgcgga||·||r=gaattcg 

algorithm
an overview of the whole process is presented in algorithm  <dig>  in a few words, the algorithm is divided into two main phases: the mapping phase . this first phase is similar to seed-based mapping algorithms such as gassst <cit> . however, sub-starter generation  is a novel algorithm presented in section “sub-starter generation and read coherence”. the second phase is the targetedde novoassembly phase . this phase extends sub-starter sequences similarly to greedy de novo assembly algorithms, such as ssake
 <cit> . extensions are stored in a graph using a novel procedure  presented in section “graph management”.

algorithm 1: mapsembler overview
requires: set of reads r, set of starters s, integer value k; ensure: for each starter in s, the sub-starters and extensions 

1: index the k-mers of s

2: map reads r to each starter from s, using the k-mer index

3: for alls  ∈ s do

4: using reads mapped to s, generate sub-startersof s.

5: add new sub-starters to ext <dig> 

6: i=0

7: whileexti≠∅do

8: free previous index, index exti  with k-mers

9: map reads r to sequences of exti, using thek-mer index

10: for alls  ∈  extido

11: using reads mapped to s, generate extensions of s.

12: create nodes containing the extensions &manage graph

13: store all novel extensions in exti + 1

14: i  =  i  + 1

15: simplify the created graphs

16: for each starter in s, output its sub-starters and their extensions

explanation of algorithm  <dig> steps
• step 1: an index of all k-mers that appear in the initial starter set s is created. for each sequence sid  belonging to the indexed set, and for each k-mer in sid, a list of couples  is stored, with pid  being a position where the k-mer occurs in sid. note that, as a k-mer may occur more than once in a sequence sid, several distinct couples may be stored for a given k-mer and a given sid. all couples  of a given k-mer can be accessed in constant time using a hash table with the k-mer as key.

• step 2: input reads  are processed on the fly, only mapped reads are stored in memory. the mapping process is as follows. all k-mers of each read are used as seeds to attempt to map the read to the indexed sequences. after the entire set of reads is processed, an error correction step  removes sequencing errors from mapped reads. each error-corrected mapped read r  is stored in the set
ms.

• steps  <dig> and 9: indexing of extensions exti  and read mapping are performed similarly to steps  <dig> and  <dig>  during these steps, reads have to perfectly agree with the extensions, hence read mapping is done with distance threshold d= <dig> 

• step 11: for each sub-starter, extensions are always stored in a rooted directed string graph, each node containing a sequence fragment. a node storing a sequence s is denoted by ns. the node storing the sub-starter itself is the root of the graph. for each sequence s  ∈  exti, using all error-corrected mapped reads
ms, detect those whose suffix stops after s ends . those reads are used to compute the extension of s, yielding three cases: 

 <dig>  an empty extension is found.

 <dig>  exactly one extension e is larger than s. create a node ne, and link the node ns  to the node ne. store the fragment e in exti +  <dig> 

 <dig>  several extensions {e <dig> e <dig> …,en} are found, then: 

for simple sequence output, the longest common prefix p of all ei  is stored in a new node np. link ns  to np  for output purpose. as p is not stored in exti +  <dig>  its extension stops.

for graph output, link ns  to n new extending nodes each storing an extending fragment. all fragments in {e <dig> e <dig> …,en} are stored in exti +  <dig> 

• step 12: generate enriched extensions by adding suffix of s of length k− <dig> as prefix of each extension of s . by adding such a prefix, we ensure that each node stores a sequence long enough  to be indexed and then exploited for next extensions and that each k-mer, including those overlapping nodes are considered as seeds.

step 13: novel extensions are those corresponding to nodes which are not already present in the graph .

step 16: in case of simple sequence format, the extensions graph of each sub-starter do not contain branching nodes. a simple traversal provides the consensus sequence of the contig containing the sub-starter.

error correction
actual sequencing reads are error-prone, therefore error correction mechanisms are implemented inside the mapping phase. at steps  <dig> and  <dig>  error-prone reads are mapped to starters. an error correction phase is performed immediately after both of these steps, by taking advantage of the multiple read alignments. this procedure is based on nucleotide votes, similarly to greedy assemblers
 <cit> , under the assumption that erroneous nucleotides are less represented than correct nucleotides. specifically, at each position relative to the starter, the count of each nucleotide is recorded. given a threshold t, a read position is considered to be correct if the corresponding nucleotide at this position is seen at least t times. otherwise, if only one other nucleotide appears over t times at this position, the read position is corrected by assigning this other nucleotide . in the remaining case, where many possible nucleotides can possibly correct a read position, no correction occurs, and the read is truncated before this position.

we now provide deeper algorithmic explanations for sub-starter generation  and the graph management . the remaining steps  are classically well known
 <cit> .

sub-starter generation and read coherence
the sub-starter generation and read coherence step take place immediately after the mapping phase . given a starter s and mapped reads r, this step generates a finite set  of sequences  which: 

originate from the reads, i.e. each si is a consensus sequence of a subset of reads from r,

are coherent with the starter s, i.e. the hamming distance between s and si  is at most d.

are significantly represented, i.e. each position of si  is covered by at least c reads.

a starter is read coherent if it yields at least one sub-starter. we are interested in retrieving the largest set of sub-starters for each starter s. this can be formulated as the following computational problem. to simplify the presentation, reads are assumed to contain no errors. in practice, the read correction step  effectively corrects or discards erroneous reads.

problem  <dig> 
given a starter s, two parameters c,  d  ≥  <dig> and a set of error-free mapped reads
r={risuch that s∥pidri} , find all maximal  subsets si  of r satisfying: 

 <dig>  each subset si  admits a perfect consensus si, i.e. each read ri  aligns to si  at position pi   with no mismatch:
si∥pi0ri,

 <dig>  the consensus si  aligns s with at most d mismatches:
s∥0dsi,

 <dig>  each position of s is covered by at least c reads in si.

a trivial  solution is  to generate the power set  of r,  remove sets which do no satisfy one of the propositions above, and  keep only maximal sets . the exponential complexity of this solution clearly comes from step . in algorithm  <dig>  we give a polynomial time  procedure which subsumes , as it generates a solution which includes all the correct subsets.

the completeness proof that algorithm  <dig> finds all maximal subsets corresponding to correct sub-starters is as follows. the proof is by contradiction: let s be a correct sub-starter not found by the algorithm. let r <dig> …,rn be the maximal subset of reads which yields s, sorted by increasing mapping positions to f. we show by induction that the algorithm returns a subset which includes r <dig> …,rk, for k∈. for k= <dig>  notice that a subset is assigned to each read. assuming r <dig> …,rk  is part of a returned subset s <dig>  we show that r <dig> …,rk +  <dig> is also returned. since rk +  <dig> is part of a subset which yields s, it overlaps perfectly with rk. however, rk +  <dig> does not necessarily belong to s <dig>  let
rk+1′ be the read which follows rk in s <dig>  in the ordering of the reads by increasing position, if the read rk + 1is seen before
rk+1′, then the algorithm selects
rk+1′=rk+ <dig>  else, as rk +  <dig> perfectly overlaps with rk, a new subset is created from s <dig>  which contains exactly r <dig> …,rk +  <dig>  eventually, from the induction, a subset which contains r <dig> …,rn is constructed. since r <dig> …,rn is itself maximal, the subset found by the algorithm is exactly r <dig> …,rn.

note that algorithm  <dig> may return subsets which do not satisfy all the three conditions , hence steps  and  are still required. the running time of the algorithm is now analyzed. observe that during the algorithm execution, each intermediate subset in s is included in a distinct final maximal subset. there are at most |Σ|d maximal subsets, one for each combination of substitutions with s. hence, there are o intermediate subsets at any time. assuming that the read length is bounded by a constant, the overlap detection steps  <dig> and  <dig> can be performed in o time. hence, the time complexity of algorithm  <dig> is o, where in practice d is a small constant, and |Σ|= <dig> on genomic sequences.

algorithm 2: generating candidate subsets si  for solving the multiple consensuses from read alignments problem
requires: set of reads r, starter s, minimum consensus c≥ <dig>  distance threshold d≥0; ensure: set s of candidate subsets. 

1: s=∅.

2: for each read  in r ordered by alignment position do

3: for each subset si  in sdo

4: if r overlaps without substitutions with the lastread of si then

5: add r to si.

6: else

7: ifr overlaps without substitutions with oneof the reads of si then

8: let  be the last read of si  overlapping with r.

9: let t be the subset of si of all reads up to.

10: create a new subset s′=t∪{r}.

11: insert s′ into s.

12: ifr was not appended to any subset then

13: create a new subset with r and insert it into s.

14: remove any subset from s if its consensus hasmore than d differences with s, or a position before p is covered by less than c reads.

15: return s.

graph management
adding a node
several biological events such as a snp, an indel, or exon skipping, create two or more distinct paths in the extension graph. these paths eventually converge and continue with an identical sequence. consequently, path convergence is checked during the iterative assembly phase . when a sequence s is extended with extension e, the algorithm checks if e is not already present in the graph in a node
ns′. to do this, the last k-mer of the sequence of each node is indexed in a hash table. checking if e is already present in the graph is done using k-mers of e and this last index as seeds for mapping. if the overlap of e on the sequence of a node
ns′ is perfect  then ns is linked to
ns′. if i< <dig>  an intermediate node containing the prefix of e not mapped on s′ is added between ns and
ns′. if i> <dig>  the suffix of length i of s is pruned from node ns as it is already present in node
ns′.

graph simplification
once extensions are finished, each graph is simplified as follows: 

as presented in figure
2a-b, enriched extensions are transformed into extensions, by removing the first k− <dig> characters of each internal node except the root. this removes redundant information in nodes.

two nodes ns and
ns′ are merged into node
ns..s′ if and only if ns has only
ns′ as successor while
ns′ has only ns as predecessor. this is a classical concatenation of simple paths. see figure
2a-b for an example.

for all nodes successors of a node ns having only ns as predecessor, their longest common prefix pre is pruned and factorized as suffix of the sequence stored in ns, thus generating node ns.pre. similarly, for all nodes predecessors of a node ns having only ns as successor, their longest common suffix suf is pruned and factorized as prefix of the sequence stored in ns, thus generating node nsuf.s. this simplification relocates branching in the graph, to the exact position where sequences diverge and converge. see figure
2c for an example.

availability and requirements
mapsembler is released under cecill license. it can be downloaded from
http://alcovna.genouest.org/mapsembler/website. the download comes with documentation about installation and usage. a mapsembler newsletter is also available from this address.

RESULTS
all presented results were obtained on a  <dig>  ghz dual-core laptop with  <dig> mb cache and  <dig> gb ram memory.

for each experiments presented in this manuscript, details about datasets, mapsembler commands and results are packed in additional file
 <dig>  when read datasets are public, a link to a download address is provided in the archive. when they are not, only reads used by mapsembler during mapping and assembly phases are provided.

in figures representing graphs, the node size indicates average read coverage in the sequence and the node border size indicates the length of the sequence.

note that mapsembler is not designed to be a whole genome assembler, thus classical assembly statistics  do not apply. apart from nucleotide accuracy and rate of misjoins, quality measures for de novo targeted genome assembly are, to the best of our knowledge, not defined.

mapsembler and the state of the art
targeted assembly should not be confused with sanger-generation, localized bac-by-bac assembly methods . bac-by-bac sequencing is typically not performed anymore in second-generation sequencing. mapsembler computes targeted assemblies within a whole-genome set of short reads, i.e. without any localized sequencing process. to date, we are aware of only one related targeted assembly method in the literature, tasr <cit> .

tasr is based on the ssake assembler
 <cit> . it maps a set of reads on targets  using seeds of length  <dig>  mapping between a read and a target is tested if at least one sequence of length  <dig> exactly matches both. tasr outputs the result of this mapping, including extensions obtained from reads mapped to extremities of starters. similarly to mapsembler, tasr indexes only targets, hence memory requirements do not depend on the size of the read file. mapsembler significantly differs from tasr as it offers the following novel features: 

sub-starters retrieval;

multiple iterations to extend starters as far as possible. this is equivalent to re-running tasr multiple times, using its results as starters;

graph output of the left and right neighborhood of starters.

we compared tasr and mapsembler time and memory performances using a set of  <dig>  millions of short reads of length  <dig> . we ran mapsembler without iterative extensions and set seeds length to  <dig>  to match tasr behavior.

using a unique randomly selected read as starter, mapsembler finished in  <dig> seconds, using  <dig>  mb of memory, while tasr finished in  <dig> seconds using  <dig>  mb of memory. on a larger set of  <dig> starters randomly selected from reads, mapsembler finished in  <dig> seconds using  <dig>  mb of memory. tasr was stopped after  <dig> hours, while using  <dig> mb of memory. note that in both cases, mapsembler produces strictly more results than tasr as it detects and extends all the sub-starters of each starter.

the iterative mapping and assembly strategies are also used in the image approach
 <cit> , although in a different context. image maps paired-end reads to a pre-assembled set of contigs in order to extend contig lengths and close gaps. mapsembler could theoretically be used to extend contigs with unpaired reads, but does not perform automated gap closing. in practice mapsembler is an orthogonal approach to image, as it aims to replace whole-genome assembly for a subset of biological questions.

assembly accuracy
the accuracy of mapsembler targeted assemblies is assessed. we performed targeted assembly of  <dig> starters of length  <dig> nt sampled uniformly from the e. coli genome. these starters were assembled using  <dig>  m raw illumina reads . mapsembler was run with default parameters and d= <dig>  to discard sub-starters which do not correspond exactly to starters. using  <dig> iterations, mapsembler returned  <dig> extended sub-starters of average length  <dig> nt. we computed global alignments between mapsembler extensions and the reference genome. for each alignment, the reported accuracy corresponds to the ratio of the number of substitutions and mismatches over the number aligned bases. each targeted assembly aligns with more than 99% accuracy, and no misjoin was produced. specifically,  <dig> % of the extensions were perfectly aligned. this level of accuracy is consistent with that of whole-genome de novo assemblers. for instance,  <dig> % of the contigs from a soapdenovo
 <cit>  whole-genome assembly of the same dataset align perfectly to the reference.

dealing with large data sets
in this section, we focus exclusively on mapsembler time and memory requirements. from the ncbi sequence read archive, we downloaded a human na <dig> illumina run containing  <dig> million reads of length  <dig> . five subsets, s10k, s100k, s1m, s10m, and s100m, were generated by random sampling of  <dig>   <dig>   <dig>   <dig> and  <dig> reads. a targeted assembly of  <dig> randomly selected reads as starters was performed using mapsembler with default options.

results summarized in table
 <dig> show that memory requirement does not depend on the read file size. note that a read file containing  <dig>  gbases  was analyzed using < <dig>  mb of memory. these results also show that computation time is reasonable even on such large data sets as time linearly increases with the number of starters. on average on the s100m data set, checking read coherence of all starters took  <dig> seconds while one extension of all sequence fragments took  <dig> seconds. mapsembler computation time grows linearly with respect to the number of input starters and the number of computed extensions. note that an option enables to limit the number of extensions, and note that if manually stopped, mapsembler outputs results obtained so far.

time and memory requirements for targeted assembly of  <dig> starters using increasingly large human genome read data sets. mapping time corresponds to the mapping phase . assembly time corresponds to the assembly phase  per iteration.

recovering environments of repeat occurrences
we analyzed a dataset of  <dig>  m raw illumina reads  from e. coli k <dig> using as starter a sub-sequence of the reference genome  containing inserted sequences is <dig> and is <dig> transposase. this fragment has six exact occurrences on the reference genome. using  <dig> iterations, mapsembler needed  <dig> seconds and  <dig>  mb of memory to produce the graph presented in figure
 <dig>  the graph yields neighbor sequences of all occurrences of this repeat. the six occurrences were exactly recovered by mapsembler. where classical whole genome assemblers interrupt an assembly, mapsembler retrieves the environments of the occurrences of a repeat. in this case, the exact number of occurrences can be directly inferred from mapsembler graph structure.

detecting aluy sub-families in a personal genome
alu elements are a family of highly-repeated, ≈ <dig> bp sequences found in primate genomes. sub-families of the aluy family are characterized by known evolutionary mutations. we demonstrate how mapsembler can be used to detect the aluy sub-families present in a set of reads.

we downloaded a dataset of high-coverage, na <dig> chromosome  <dig> reads from the  <dig> genomes project. we selected bases 60- <dig> of the repbase
 <cit>  consensus sequence of aluy as a starter, as prior knowledge indicates that no indel occurs inside this region. mapsembler then processed on the whole dataset  to recover sub-starters, without extending them. mapsembler error and coverage thresholds were increased according to the coverage of the dataset, and  <dig> substitutions were allowed between the starter and each sub-starter.

a total of  <dig>  reads mapped to the  <dig> bp starter and  <dig> sub-starters were constructed by mapsembler. we examine the specificity of mapsembler by verifying that sub-starters correspond to known consensus sequences. we annotated each sub-starter using sub-families consensus sequences
 <cit>  and the na <dig> reference sequence
 <cit> .starter tcacgaggtcaggagatcgagaccatcctggctaacacggtgaaaccccgtctctactaa aluy substarter_ <dig> ---cg---------------------------c---------------cg---------- alusgsubstarter_ <dig> ---ca---------------------------t---------------ca---------- substarter_ <dig> ---cg---------------------------t---------------ca---------- chr19_maternal 517189substarter_ <dig> ---tg---------------------------t---------------ca---------- substarter_ <dig> ---cg---------------------------t---------------tg---------- chr19_maternal 887598substarter_ <dig> ---cg---------------------------t---------------cg---------- aluy substarter_ <dig> ---ca---------------------------t---------------cg---------- chr19_maternal 461151substarter_ <dig> ---tg---------------------------t---------------cg---------- aluyb8

several sub-starters  did not exactly correspond to a known alu consensus sequence. we manually verified that all these sub-starters are valid as follows. sub-starters  <dig>   <dig>   <dig> and  <dig>  align perfectly to the na <dig> maternal  reference. mutations of sub-starters  <dig> and  <dig>  are also found in alu ya5
 <cit> . as further evidence, sub-sequences specific to each substarters  are abundantly present as exact substrings in the reads. for instance, bases  <dig> to  <dig> of the remaining unidentified sub-starters  are present in respectively  <dig> and  <dig> reads. consequently, the possibility that sub-starters  <dig> and  <dig> are artifacts was ruled out.

gene detection in a different strain
the fola gene  is present in several strains of e. coli, including k <dig>  and o157:h <dig> . the sequence of this gene is not exactly similar between the k- <dig> and o157:h <dig> strains . we attempted to recover the o157:h <dig> gene sequence of the fola gene, using only sequencing reads and prior knowledge of the k- <dig> sequence. to this end, we analyzed a dataset of  <dig>  m raw reads of length  <dig> bp  from e. coli o157:h <dig>  the k- <dig> allele of the fola gene  was used as the starter. the sub-starter generation module of mapsembler confirmed the presence of the gene, and furthermore recovered the exact o157:h <dig> gene sequence of fola from the reads . mapsembler performed this experiment in  <dig> seconds and using  <dig>  mb of memory.

detection of known biological events in drosophila
in this section, one illumina hiseq <dig> rna-seq run of  <dig>  million reads of length  <dig> nt from drosophila melanogaster is analyzed . as presented in upcoming sections, mapsembler enables to check for the presence or absence of a putative biological event for which one has an a priori knowledge, and to provide additional information in case of presence. recall that the tool is not dedicated for calling blindly all such events in a high throughput sequencing dataset.

exon skipping
we chose a starter located close to a known exon fragment . using less than one megabyte of memory and in  <dig> minutes, mapsembler confirmed the presence of this exon fragment. the corresponding part of the obtained graph is presented in figure
 <dig>  while a visualization of the blat
 <cit>  result is presented figure
 <dig> 
 <cit> , while the circled characters is a codon stop.
 <dig>  shorter path corresponds to the concatenation of the sequences from starter node  and from the lowest node, while longer path corresponds to the concatenation of the sequences from starter node, left most node and lowest node. the central node includes, but is not limited to a known est co <dig> 

visualizing snps
on the same read data set, we used a fragment  for which neighboring genes are known. we applied mapsembler using this fragment as starter and obtained results in less than  <dig> megabyte of memory and less than  <dig> minutes of execution . the results presented in figure
 <dig> enable to visualize the snps. note that these results do not bring phasing snp information.

detection of fusion genes in breast cancer
recent work from edgren et. al. <cit>  uses paired reads from rna-seq experiments  to detect fusion genes using a reference genome . mapsembler enabled to retrieve these fusion genes and enabled to detect new candidate fusion genes implicated in human breast cancer. here, we present results for cell line bt- <dig>  for which we downloaded the short reads used in
 <cit>  . this data set contains ≈  <dig> million reads of average length 51bp. using extremities of fusions as starters, in  <dig> hour and  <dig> minutes, using ≈  <dig> mb of memory, mapsembler retrieved in  <dig> iterations fusions genes detected in
 <cit> .

it is of particular interest to notice that mapsembler retrieved these fusion genes without making use of a reference genome nor information between read pairs. as shown figures
 <dig> and
 <dig>  for junction vapb-ikzf <dig>  mapsembler enabled to retrieve the fusion gene described in
 <cit>  and additionally detected two other fusions between genes vapb and ikzf <dig>  on different exons than those previously described. moreover, as this is usually the case while applying mapsembler on rna-seq data, the graph output enables to retrieve the exon structure in the extensions.
 <cit> , while the two other edges starting from the starter and targeting a chromosome  <dig> exon are new gene fusions.
 <cit>  results obtained after mapping paths from the starter to a leaf of the graph presented figure
 <dig>  succession of nodes of each mapped path  are indicated by their identifiers . path belonging to gene vapb chromosome  <dig> are represented on the upper part of the figure  while those belonging to gene ikzf <dig> on chromosome  <dig>  are represented on the lower part. note that the starter is not mapped on gene ikzf <dig> as it appears only on chromosome  <dig> on the genome. however, it is concatenated to rightmost exons of each of the three paths  in the transcripts.

discussion
we presented mapsembler, a new tool for targeting specific pieces of information from a possible huge set of reads, on a simple desktop computer. presented results show that such software has great potential for querying information from next generation sequencer reads. it enables to confirm the presence of a region of interest and retrieve information about surrounding sequence context. this approach presents the advantage to avoid a costly and approximative
 <cit>  full de novo assembly. however, mapsembler presents some limitations discussed in this section.

homology/similarity distance
mapsembler allows d substitutions between each starter its sub-starters. hence, this homology distance is limited to a few percent of the starter length. thus mapsembler can not be used for searching homologous genes having less than, say, 90% of similarity.

furthermore, setting a large d is not recommended for two reasons. firstly, in the worst case, there are o sub-starters having at most d substitutions with a starter s. to avoid dealing with an arbitrarily large number of sub-starters, mapsembler implements a limit of  <dig> sub-starters per starter.

secondly, mapsembler output sub-starters which may contain uncorrelated mutations, i.e. false positives. consider a starter which contains two snps a/b and c/d sufficiently far away, so that are not spanned by any read. mapsembler would reconstruct  <dig> sub-starters, corresponding to ac, ad, bc, and bd, even if only two of them were actually present in the sequenced organism.

paired reads vs. single reads
the mapsembler algorithm does not use the paired reads information. such information is difficult to incorporate in the iterative micro assembly process. we chose to discard it to keep the algorithm simple and applicable to any kind of data. however, in the case of the graph output, paired reads would enable to provide more information, for instance in splicing events. the graph constructed from single reads contains all possible junctions. paired reads can be used to eliminate paths with two or more branching junctions which do not correspond to true isoforms.

instead of injecting the paired read information in the algorithm, we believe that it is simpler to run mapsembler, then use a third party algorithm  to map paired reads to the graph and output pairs-coherent paths.

micro assembly vs. full contigs assembly
one key aspect of mapsembler is to be usable on a simple desktop computer, not requiring large memory facilities. this is achieved by an iterative algorithm which avoids indexing the read set. however, as shown table
 <dig>  on common datasets generated by a run of an existing ngs platform, each iteration can take hundreds of seconds. depending on the length of the reads, each iteration extends sub-starters by a few dozens nucleotides.

does contig length matter?
if feasible on the data, using mapsembler for the creation of contigs of length around 100kb or more would take weeks on a classical desktop computer. consequently the user should specify a maximal number of iterations, or manually stop the process after a while.

we argue that short contigs provide sufficient biological information for our purpose. as presented in the results section, we retrieved snps, different isoforms and gene fusions using short contigs. for instance, the graph presented figure
 <dig>  created in 1h <dig> after  <dig> iterations, stores a path of length  <dig> nucleotides. this whole graph is sufficient to detect the presence of  <dig> exons spread over two genes.

sensitivity to snps
similarly to greedy assemblers, in the simple sequence output mode, mapsembler aborts sequence extension as soon as more than as one extension are found. this mechanism typically yields short neighbors, in particular in sequences containing snps. thus we implemented an option to allow merging of multiple extensions having the same sequence except for one substitution. in this case, the substitution position is replaced by the nucleotide having the largest coverage. this effectively resolves ambiguities due to snps and generate longer extensions.

starter selection
the input starters are sequence fragments on which reads will be mapped. they can be of any length, however very long starters  are discouraged, as the sub-starters generation step is quadratic in the number of aligned reads. furthermore, mapsembler verifies that starters are read-coherent, hence longer starters are more likely to contain regions where the coverage is too low. also, as previously mentioned, long starters may lead to false positive sub-starters.

mapsembler discards read alignments which contain an indel. hence, it is advised to input small, well-conserved starters. however, indels in the extensions are retained in the graph structure. starters are typically constructed from an external source of information, such as sequence information from a related species, a known conserved gene, or an existing collapsed assembly.

full biological events calling versus mapsembler
mapsembler was clearly not designed for calling broadly biological events. it should not be used for this purpose. its usage should then be limited to cases where user has a piece of priori knowledge she wants to validate and extend, without making use of heavy and heuristics approaches.

CONCLUSIONS
mapsembler is a simple yet powerful, non-specific tool for extracting targeted pieces of information from newly sequenced, non-assembled genomes or transcriptomes. technically, mapsembler retrieves the approximate occurrences of a region of interest and performs targeted assembly through repeated iterations of read mapping. it also provides the possibility of visualizing the genomic context of assembled sequences as a graph. mapsembler is not a whole-genome assembly software, instead it focuses on specific targets and assemble their contexts over a few hundreds of nucleotides. mapsembler can be executed on a classical desktop computer; without cleaning the data and without a reference genome. usage possibilities are numerous and fit the actual trend of sequencing, as more and more species, including meta-genomes, are sequenced without reference genomes.

we presented the main mapsembler features and algorithmic ingredients. we have shown a selected overview of mapsembler applications, among which one enabled to detect novel fusion genes. benchmarks were ran on very large amounts of biologically relevant data. with respect to other comparable method, mapsembler runs consistently faster and consumes less memory. more importantly, mapsembler has several novel features, such as sub-starters retrieval, iterative extensions and graph visualization.

there is much room for future work. currently the error correction is based on substitutions only. for opening mapsembler to broader technologies like roche  <dig> system, insertions and deletions will be taken into account during read correction.

to finish, its simplicity and its power make mapsembler a good candidate for ambitious future ngs applications. in particular, even if it was not initially designed in this spirit, mapsembler is highly parallelizable and can be adapted to a “zero memory” whole genome de novo assembly tool.

competing interests
the authors declare that they have no competing interests.

author’s contributions
pp initiated the work and pp and rc designed the algorithms. rc developed the sub-starter generation and read coherence algorithms, while pp developed the other parts. rc and pp performed the experiments and wrote the paper. both authors read and approved the final manuscript.

supplementary material
additional file 1
material andmapsemblercommands and results.

click here for file

 acknowledgements
authors warmly thank vincent lacroix, claire lemaitre, delphine naquin, hélène falentin and fabrice legeai for their participation to discussions. this work was supported by the inria “action de recherche collaborative” arc alcovna and by the mappi anr.
