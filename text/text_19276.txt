BACKGROUND
in recent years, research in rna sequences and structures has dramatically increased: the discovery of functionally important, not protein-coding, rna sequences has challenged the traditional picture of the flow of genetic information from dna via rna to proteins as functional units. it is now well-established that rna molecules introduce an additional layer in genetic information processing. they play a significant active role in cell and developmental biology and carry out many tasks that were previously attributed exclusively to proteins. one of the most eminent examples is the class of micrornas  <cit> , an abundant class of small functional rnas that regulate gene expression by binding to a target in the mrna. other examples include snornas, which modify ribosomal rna  <cit> , signal recognition particle rnas  <cit> , cis-acting regulatory elements, and pirnas  <cit> , a novel class of ncrnas whose function is still unclear. it is likely that only a small fraction of regulatory rnas has been identified so far and that many more have yet to be discovered  <cit> .

computational analyses have contributed largely to the discovery and advancement of biological knowledge. heuristic methods, such as blast  <cit> , or exact approaches based on dynamic programming, such as the smith-waterman algorithm  <cit> , are used as everyday tools to analyze dna and protein sequences. in case of rna sequences, sequence information alone is not sufficient anymore. an rna sequence folds back onto itself and forms hydrogen bonds between nucleotides. these bonds lead to the distinctive secondary structure of an rna sequence.

rna sequences evolve more rapidly than the structure they are forming, because their evolutionary behavior follows the structure-function paradigm: rna molecules with different sequences but same or similar secondary structure are likely to belong to the same functional family, in which the secondary structure is conserved by selective pressure. hence, computational analysis of rna molecules inevitably involves considering secondary structure information in addition to the primary sequence. computing sequence-structure alignments is a key step in many important applications. these include finding homologous structures of known ncrna families  <cit> , phylogenetic fingerprinting , or the computation of a consensus structure of a set of rna molecules  <cit> . a recent study shows that pure sequence-based pairwise alignments are unable to produce satisfactory results if the pairwise sequence identity drops below  <dig> to 60%  <cit> . figure  <dig> illustrates this situation and shows two different alignments of seven trna sequences with a pairwise sequence identity of 39%, where the upper alignment is based on sequence information alone and the lower alignment additionally rewards the conservation of structural elements. one can clearly see that the sequence-based alignment is unable to preserve the typical trna-cloverleaf structure, whereas the structural alignment conserves the structural features of the input sequences.

unfortunately, considering structural information adds an additional level of complexity to the problem of aligning two or several sequences. in the remainder of this section, we present a classification of structural alignment problem variants including previous work. section  <dig> describes our new approach to multiple sequence-structure alignment. we employ methods from mathematical programming and solve the problem as an integer linear program resulting from a graph-theoretical reformulation. section  <dig> is dedicated to an extensive computational study. we describe lara, the freely available implementation of our novel approach, and present detailed results of a comparative study including state-of-the-art programs on a recently published benchmark database of structural alignments. the results show that on average our software is currently the best program in terms of alignment quality, outperforming other programs with an increasing number of input sequences. finally, we discuss our results and suggest future research directions in sect.  <dig> 

in contrast to previous work  <cit>  this article describes a full integer linear programming  formulation that does include arbitrary gap costs and an extensive performance analysis of our implementation for the first time. due to page limits the mathematical fundament and all proofs are omitted: the interested reader is referred to the companion paper  <cit>  that focuses on an in-depth description of the mathematical properties of the intricate multiple case containing all proofs.

 <dig>  previous approaches
depending on the available knowledge about the  structures that we want to align, there are three different alignment scenarios for two rna structures, which readily extend to the multiple case. figure  <dig> gives a cartoon illustration of the three scenarios.

 <dig>  structure-to-structure alignments align two known secondary structures, typically the minimum free energy structures. this scenario applies if one searches for common structural motifs that are shared by both structures and there is reason to believe that the secondary structures are correct.

 <dig>  structure-to-unknown alignments align a given structure to a sequence with unknown structure. applications are finding homologous sequences by inferring a consensus structure to a sequence , or finding new family members of ncrna families: this problem has recently sparked considerable interest in the context of searching homologous structures of noncoding-rnas in large genomic sequences. see  <cit>  for a survey.

 <dig>  in the unknown-to-unknown alignment problem, no previous structural information is given. it applies when two rna sequences are suspected to share a common, but still unknown, structure. we constrain the space of possible structures by the entire set of possible watson-crick and wobble pairs. a reduction of the size of this space is possible, for instance, by applying a folding algorithm to obtain the base pair probabilities  <cit>  and then considering only those interactions whose probabilities are above a certain threshold.

there are four major alignment models for rna structures that tackle the previous described alignment scenarios: annotated sequences, tree models, probabilistic models, and graph-based models. we give small examples for each model in fig. 3: note that we did not show an example of probabilistic models because the representation of probabilistic and tree models are the same. the underlying algorithms, however, are completely different. table  <dig> classifies previous work in the area of structural rna alignment according to the different models and scenarios.

tree-based models
tree-based structural alignment algorithms view an rna secondary structure as a tree. depending on the particular model , one either searches for the minimal number of operations  to transform one tree into the other, or into a common supertree. algorithms employing the model from  <cit>  have time complexities in o, thus making the computation expensive. here and in the following, n denotes the size of the longest sequence. tree-alignment algorithms have complexities that are on average only slightly worse than conventional sequence alignment. more precisely, their running time is in o, where Δ denotes the maximum number of branches of a multiloop in the input structures.

a tool that builds upon the tree paradigm is rnaforester  <cit> . it computes multiple structure-to-structure alignments of rna sequences by performing tree-alignment in a progressive fashion.

annotated sequences
we call a sequence that is augmented by structural information an annotated sequence. classical dynamic programming  algorithms can be extended to annotated sequences. the dp solution for the structure-to-structure and structure-to-unknown problem then typically requires o and o in time and space, respectively. bafna, muthukrishnan, and ravi describe an algorithm that simultaneously aligns the sequence and secondary structure of two rna sequences  <cit> . their method runs in time o, which still does not make it applicable to instances of realistic size. eddy  <cit>  proposes an algorithm that reduces the memory consumption to o. the stral tool  <cit>  uses the values of the base pair probability matrices, as given by the partition function  <cit> , to compute the maximal pairing probability of a single nucleotide and to align the sequences in a clustalw-like fashion.

in the restricted structure-to-structure scenario, one can resort to more sophisticated edit-models like the one proposed by jiang in  <cit>  where the authors specify operations both on the sequence and the structure level. the dynamic programming algorithm is in o, making the computation rather tedious for longer sequences. a program that implements the jiang model is marna  <cit> : it computes pairwise sequence-structure alignments, but is additionally able to compute multiple alignments. to this end, marna computes all pairwise structural alignment and uses t-coffee to compute the actual multiple alignment incorporating the structural information of the pairwise alignments.

the unknown-to-unknown scenario requires the simultaneous computation of the alignment and consensus structure. the computational problem of simultaneously considering sequence and structure of an rna molecule was initially addressed by sankoff in  <cit> , where the author proposed a dp algorithm to align and fold a set of rna sequences at the same time. the cpu and memory requirements of the original algorithm are o and o, respectively, where k is the number of sequences and n is their maximal length. current implementations modify sankoff's algorithm by imposing limits on the size or shape of substructures, e.g., dynalign  <cit> , or foldalign  <cit>  that combine a sliding window and banded alignment approach. hofacker, bernhart, and stadler  <cit>  have presented the pmmulti software to align base pair probability matrices. their recursions are essentially the same as the ones given by sankoff in  <cit>  and subsequently used for sequence-structure alignment by bafna et al. in  <cit>  with the only difference that they consider probabilities instead of fixed structures. by banding the range of possible alignment positions they bring the time and space complexity of the pairwise case down to o and o, respectively. for the multiple case, they align consensus base pair probability matrices in a progressive fashion. similar in spirit are foldalignm  <cit>  or locarna  <cit> , two recent reimplementations of the pmmulti approach. foldalignm provides both several restrictions on the alignment and a two-stage procedure to fill the dp matrix: this further reduces the running time to o where n is the length of the longer sequence and d is the maximal length difference of the alignment of two subsequences. locarna on the other hand takes advantage of the sparse base pair probabilities matrices to reduce the running time.

probabilistic models
eddy and durbin  <cit>  describe covariance models for measuring the secondary structure and primary sequence consensus of rna sequence families. they present algorithms for analyzing and comparing rna sequences as well as database search techniques. since the basic operation in their approach is an expensive dynamic programming algorithm, their algorithms cannot analyze sequences longer than 150– <dig> nucleotides. therefore, recent approaches reduce the running time by incorporating additional information, e.g. holmes et al.'s stemloc  <cit>  where the authors propose the concept of alignment/fold envelopes that constrain possible alignments. along these lines, in  <cit>  the authors keep a set of probabilistically derived alignment positions fixed: these alignment positions serve subsequently as anchors for the structural alignment which prune away large parts of the search space. the authors of  <cit>  describe a method based on conditional random fields to align an rna sequence with known structure to one with unknown structure. they estimate their parameters using conditional random fields and compute the alignment using the recursions from  <cit> .

graph-based models
kececioglu  <cit>  has introduced a graph-theoretical model for the classical primary sequence alignment problem. in  <cit>  the authors present a first extension of this model to rna structures and propose a branch-and-cut approach based on an integer linear programming formulation. based on this formulation and inspired by the successful application of lagrangian relaxation by lancia and caprara  <cit>  to the related contact map overlap problem, in  <cit>  the authors switch from branch-and-cut to the lagrangian relaxation technique. they are able to solve instances a magnitude larger by simultaneously reducing the running time significantly. in  <cit>  the authors give a graph-theoretic model for the computation of multiple sequence alignments with arbitrary gap costs. in the next section we will combine the formulations given in  <cit>  and  <cit> , resulting in a novel graph-based formulation for sequence-structure alignment with arbitrary gap costs.

note that the graph-based model naturally deals with all three alignment scenarios. in addition, unlike other algorithmic approaches, the graph-based algorithms do not restrict the input in any way and hence can handle arbitrary pseudoknots: pseudoknots have been shown to play important roles in a variety of biological processes, see  <cit>  for a recent review. most dp-based algorithms assume nested secondary structures to compute subproblems efficiently. few exceptions exist, for example  <cit> , but these algorithms are always restricted to certain classes of pseudoknots  and do not handle the general case.

 <dig> 
RESULTS
this section deals with our novel graph-based approach to structural rna alignment. we first give the problem definition and then describe the graph-theoretical model we use, which combines the models presented in  <cit>  and  <cit> . we convert the nucleotides of the input sequences into vertices of a graph, and we add edges between the vertices that represent either structural information or possible alignments of pairs of nucleotides. based on the graph model we develop an integer linear programming formulation. we find solutions using an algorithmic approach employing methods from combinatorial optimization. for sake of simplicity, we will limit the description to the two-sequence case. we want to stress, however, that the model can be extended to the multiple case without changing the core algorithms and ideas. the interested reader is referred to an extensive theoretical description including proofs and a computational complexity discussion appearing elsewhere  <cit> .

 <dig>  graph-theoretical model for structural rna alignment
problem definition
given two rna sequences, we denote by a
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaat0uy0hwztfgdpnwy1egaryqthrhal1wy0l2yhvdaiqaacqwfaefqaaa@3820@ an alignment of the two sequences. let ss be the sequence score of alignment a
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaat0uy0hwztfgdpnwy1egaryqthrhal1wy0l2yhvdaiqaacqwfaefqaaa@3820@ including gap penalties, and let sp be the score of structural features that are conserved by the alignment a
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaat0uy0hwztfgdpnwy1egaryqthrhal1wy0l2yhvdaiqaacqwfaefqaaa@3820@. we now aim at maximizing the combined sequence-structure score, that is, we search for an alignment a∗
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaat0uy0hwztfgdpnwy1egaryqthrhal1wy0l2yhvdaiqaacqwfaefqdaahaawcbeqaaiabgehiqaaaaaa@393c@ with

 ss+sp=max⁡ass+sp.
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaacqwgzbwcdawgaawcbagaem4uamfabeaakiadmcogoaakt0uy0hwztfgdpnwy1egaryqthrhal1wy0l2yhvdaiqaacqwfaefqdgajaybaasqajwigbgajakadmcohxiikaagccwajakykakiaey4kasiaem4cam3aasbaasqaaiabdcfaqbqabagccqggoaakcqwfaefqdaahaawcbeqaaiabgehiqaaakiabcmcapiabg2da9maaxababagagiyba0maeiyyaemaeiieaghaleaacqwfaefqaeqaaogaem4cam3aasbaasqaaiabdofatbqabagccqggoaakcqwfaefqcqggpaqkcqghrawkcqwgzbwcdawgaawcbagaemiuaafabeaakiabcicaoiab=bq8bjabcmcapiabc6cauaaa@61e3@ 

basic model
let s = s <dig>  ..., sn be a sequence of length n over the alphabet Σ = {a, c, g, u}. a pair  is called an interaction if i < j, and nucleotide i pairs with j. in most cases, these pairs will be watson-crick or wobble base pairs. the set p of interactions is called the annotation of sequence s. two interactions  and  are said to be inconsistent, if they share one base; they form a pseudoknot if they "cross" each other, that is, if k <m <l <o or m <k <o <l. a pair  is called an annotated sequence. note that a structure where no pair of interactions is inconsistent with each other forms a valid secondary structure of an rna sequence, possibly with pseudoknots.

we are given two annotated sequences  and  and model the input as a structural graph gs = . the set v denotes the vertices of the graph, in this case the bases of the sequences, and we write via
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaacqwg2bgddaqhaawcbagaemyaakgabagaemyqaeeaaaaa@30b4@ and vib
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaacqwg2bgddaqhaawcbagaemyaakgabagaemoqaieaaaaa@30b6@ for the ith base in sequence a and b, respectively. the set l contains undirected alignment edges between vertices of sequences a and b, for sake of better distinction called lines. a line l ∈ l with l =  represents the alignment of the k-th character in sequence a with the l-th character in sequence b. by s and t we refer to the adjacent vertices of line l in sequence a and b, respectively. a subset ℒ
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaat0uy0hwztfgdpnwy1egaryqthrhal1wy0l2yhvdaiqaacqwfsectaaa@376d@ ⊂ l represents a valid sequence alignment of sequence a and b, if there are no two lines k, l ∈ ℒ
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaat0uy0hwztfgdpnwy1egaryqthrhal1wy0l2yhvdaiqaacqwfsectaaa@376d@ such that k and l cross or touch each other  <cit> . crossing or touching lines induce ordering conflicts in the alignment . we denote with the set cl
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaat0uy0hwztfgdpnwy1egaryqthrhal1wy0l2yhvdaiqaacqwfce=qdawgaawcbagaemitaweabeaaaaa@3971@ the collection of all maximal sets of mutually conflicting lines.

we extend the original graph gs =  by the edge set i to model the annotation of the input sequences in our graph. consequently, we have interaction edges between vertices of the same sequence, i.e., an edge  representing the interaction between nucleotides i and j in sequence a. figure  <dig> illustrates these definitions by means of an example. note that at this stage gaps are not modelled in our formulation. hence, we have to extend our model to incorporate gap penalties in our model.

gap edges
the initial model containing only lines  and interaction edges  is augmented by a set of gap edges g, which represents gaps in the alignment. for sake of compactness, we just describe the gap edges of sequence a, the gap edges of sequence b are defined analogously: we have an edge ekla
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaacqwglbqzdaqhaawcbagaem4aasmaemibawgabagaemyqaeeaaaaa@31f7@ from vka
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaacqwg2bgddaqhaawcbagaem4aasgabagaemyqaeeaaaaa@30b8@ to vla
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaacqwg2bgddaqhaawcbagaemibawgabagaemyqaeeaaaaa@30ba@ with k, l ∈  <dig>  ..., |sa| representing the fact that no character of the substring ska...sla
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaacqwgzbwcdaqhaawcbagaem4aasgabagaemyqaeeaaogaeiola4iaeiola4iaeiola4iaem4cam3aa0baasqaaiabdygasbqaaiabdgeabbaaaaa@3770@ is aligned to any character of the sequence b, whereas sk−1a
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaacqwgzbwcdaqhaawcbagaem4aasmaeyoei0iaegymaedabagaemyqaeeaaaaa@328f@  and sl+1a
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaacqwgzbwcdaqhaawcbagaemibawmaey4kasiaegymaedabagaemyqaeeaaaaa@3286@  are aligned with some characters in sequence b. we say that vka,...,vla
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaacqwg2bgddaqhaawcbagaem4aasgabagaemyqaeeaaogaeiilawiaeiola4iaeiola4iaeiola4iaeiilawiaemoday3aa0baasqaaiabdygasbqaaiabdgeabbaaaaa@393c@ are spanned by the gap edge ekla
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaacqwglbqzdaqhaawcbagaem4aasmaemibawgabagaemyqaeeaaaaa@31f7@. figure  <dig> shows the graph extended by gap edges.
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaacqwg2bgddaqhaawcbagaegimaadabagaemyqaeeaaaaa@3047@ . note, however, that every node has outgoing gap edges to all other nodes in the sequence. the subset of lines and gap edges  corresponds to the alignment .

two gap edges ekla
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaacqwglbqzdaqhaawcbagaem4aasmaemibawgabagaemyqaeeaaaaa@31f7@ and emna
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaacqwglbqzdaqhaawcbagaemyba0maemoba4gabagaemyqaeeaaaaa@31ff@ ∈ g are in conflict with each other if {k, ..., l + 1} ∩ {m, ..., n} ≠ ∅, that is, if they overlap or touch. this is intuitively clear, because we do not want to split a longer gap into two separate gaps: consequently, there has to be at least one aligned character between any two realized gap edges. see fig.  <dig> for an example. we denote with the set cg
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaat0uy0hwztfgdpnwy1egaryqthrhal1wy0l2yhvdaiqaacqwfce=qdawgaawcbagaem4raceabeaaaaa@3967@ the collection of all maximal sets of mutually conflicting gap edges. finally, we define gvka↔vla
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaacqwghbwrdawgaawcbagaemoday3aa0baawqaaiabdugarbqaaiabdgeabbaaliabgszirkabdaha2naadaaameaacqwgsbabaeaacqwgbbqqaaaaleqaaaaa@380d@ as the set of gap edges that span the nodes vka,...,vla
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaacqwg2bgddaqhaawcbagaem4aasgabagaemyqaeeaaogaeiilawiaeiola4iaeiola4iaeiola4iaeiilawiaemoday3aa0baasqaaiabdygasbqaaiabdgeabbaaaaa@393c@.

interaction match
we call two interactions ∈pa
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaacqggoaakcqwgzbwcdaqhaawcbagaem4aasgabagaemyqaeeaaogaeiilawiaem4cam3aa0baasqaaiabdygasbqaaiabdgeabbaakiabcmcapiabgigiolabdchawnaacaaaleqabagaemyqaeeaaaaa@3b85@ and ∈pb
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaacqggoaakcqwgzbwcdaqhaawcbagaemyba0gabagaemoqaieaaogaeiilawiaem4cam3aa0baasqaaiabd6gaubqaaiabdkeacbaakiabcmcapiabgigiolabdchawnaacaaaleqabagaemoqaieaaaaa@3b93@ an interaction match if there exist two alignment edges a=
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaacqwghbqycqgh9aqpcqggoaakcqwg2bgddaqhaawcbagaem4aasgabagaemyqaeeaaogaeiilawiaemoday3aa0baasqaaiabd2gatbqaaiabdkeacbaakiabcmcapaaa@39c1@ and b=
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaacqwgibgycqgh9aqpcqggoaakcqwg2bgddaqhaawcbagaemibawgabagaemyqaeeaaogaeiilawiaemoday3aa0baasqaaiabd6gaubqaaiabdkeacbaakiabcmcapaaa@39c7@ that do not cross each other. we say that a subset s
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaat0uy0hwztfgdpnwy1egaryqthrhal1wy0l2yhvdaiqaacqwfse=uaaa@3844@ ⊆ l realizes the interaction match if {a, b} ⊆ s
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaat0uy0hwztfgdpnwy1egaryqthrhal1wy0l2yhvdaiqaacqwfse=uaaa@3844@. interaction matches realized by a set s
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaat0uy0hwztfgdpnwy1egaryqthrhal1wy0l2yhvdaiqaacqwfse=uaaa@3844@ represent common interactions that are preserved by aligning the begin and end nucleotides of the interaction. figure  <dig> illustrates the definitions.

gapped structural trace
a triple  with ℒ
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaat0uy0hwztfgdpnwy1egaryqthrhal1wy0l2yhvdaiqaacqwfsectaaa@376d@ ⊆ l, ℐ
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaat0uy0hwztfgdpnwy1egaryqthrhal1wy0l2yhvdaiqaacqwfqessaaa@3768@ ⊆ i, and g
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaat0uy0hwztfgdpnwy1egaryqthrhal1wy0l2yhvdaiqaacqwfge=raaa@382c@ ⊆ g is called a valid gapped structural trace if and only if the following constraints are satisfied:

 <dig>  the vertices vla
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaacqwg2bgddaqhaawcbagaemibawgabagaemyqaeeaaaaa@30ba@ and vkb
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaacqwg2bgddaqhaawcbagaem4aasgabagaemoqaieaaaaa@30ba@ of sequences a and b are either incident to exactly one alignment edge e ∈ ℒ
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaat0uy0hwztfgdpnwy1egaryqthrhal1wy0l2yhvdaiqaacqwfsectaaa@376d@ or spanned by a gap edge g ∈ g
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaat0uy0hwztfgdpnwy1egaryqthrhal1wy0l2yhvdaiqaacqwfge=raaa@382c@. in other words, a nucleotide is either aligned or "aligned" to a gap.

 <dig>  a line l can realize at most one interaction match , because a nucleotide can pair with at most one other nucleotide in a valid rna secondary structure.

 <dig>  there are no two lines k, l ∈ l that cross or touch each other: crossing lines induce ordering conflicts in the alignment, whereas touching lines imply that two different nucleotides are mapped to the same nucleotide in the other sequence.

 <dig>  there are no two gaps edges ekla,emna∈g
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaacqwglbqzdaqhaawcbagaem4aasmaemibawgabagaemyqaeeaaogaeiilawiaemyzau2aa0baasqaaiabd2gatjabd6gaubqaaiabdgeabbaakiabgigioprthrhal1wy0l2yhvtyaehbnfgdovwbhrxajfwnagabaiab=zq8hbaa@4542@ such that ekla
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaacqwglbqzdaqhaawcbagaem4aasmaemibawgabagaemyqaeeaaaaa@31f7@ is in conflict with emna
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaacqwglbqzdaqhaawcbagaemyba0maemoba4gabagaemyqaeeaaaaa@31ff@, and there are no two gaps edges eklb,emnb∈g
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaacqwglbqzdaqhaawcbagaem4aasmaemibawgabagaemoqaieaaogaeiilawiaemyzau2aa0baasqaaiabd2gatjabd6gaubqaaiabdkeacbaakiabgigioprthrhal1wy0l2yhvtyaehbnfgdovwbhrxajfwnagabaiab=zq8hbaa@4546@ such that eklb
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaacqwglbqzdaqhaawcbagaem4aasmaemibawgabagaemoqaieaaaaa@31f9@ is in conflict with emnb
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaacqwglbqzdaqhaawcbagaemyba0maemoba4gabagaemoqaieaaaaa@3201@.

we assign weights wl and wkl for each line l and interaction match  that represents the benefit of realizing l or . by default, we set these scores along the lines of standard scoring methods, e.g., blosum matrices for the weight of the lines, base pair probabilities  <cit>  for the interaction match scores, or by using the ribosum scoring matrices derived from alignments of ribosomal rnas  <cit> . our model, however, is not limited to standard scoring schemes. since we can set each  weight separately, the user can assign completely arbitrary scores to each line or interaction match which makes the incorporation of expert knowledge into the computation of structural alignments easy. furthermore, we assign negative weights to gap edges akla
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaacqwghbqydaqhaawcbagaem4aasmaemibawgabagaemyqaeeaaaaa@31ef@ with representing the gap penalty for aligning substring ska,...,sla
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaacqwgzbwcdaqhaawcbagaem4aasgabagaemyqaeeaaogaeiilawiaeiola4iaeiola4iaeiola4iaeiilawiaem4cam3aa0baasqaaiabdygasbqaaiabdgeabbaaaaa@3930@ with gap characters. note that the model allows for arbitrary, position-dependent gap scoring.

approaches for traditional sequence alignment aim at maximizing the score of edges in an alignment ℒ
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaat0uy0hwztfgdpnwy1egaryqthrhal1wy0l2yhvdaiqaacqwfsectaaa@376d@. structural alignments, however, must also take the structural information encoded in the interaction edges into account. the problem of structurally aligning two annotated sequences  and  corresponds to finding an alignment such that the weight of the sequence part  plus the weight of the realized interaction matches is maximal. more formally, we seek to maximize ∑l∈ℒwl+∑g∈gwg+∑∈ℐwij
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaadaaeqaqaaiabdeha3naabaaaleaacqwgsbabaeqaaaqaaiabdygasjabgigioprthrhal1wy0l2yhvtyaehbnfgdovwbhrxajfwnagabaiab=jrimbqab0gaeyyeiuoakiabgucarmaaqababagaem4dac3aasbaasqaaiabdeganbqabaaabagaem4zacmaeyici4sae8nbxfeabeqdcqghris5aogaey4kasyaaabeaeaacqwg3bwddawgaawcbagaemyaakmaemoaaogabeaaaeaacqggoaakcqwgpbqacqggsaalcqwgqbgacqggpaqkcqghiiizcqwfqessaeqaniabgghildaaaa@5876@, where  represents an alignment with arbitrary gap costs, and ℐ
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaat0uy0hwztfgdpnwy1egaryqthrhal1wy0l2yhvdaiqaacqwfqessaaa@3768@ contains the interaction matches realized by ℒ
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaat0uy0hwztfgdpnwy1egaryqthrhal1wy0l2yhvdaiqaacqwfsectaaa@376d@. observe that this graph-theoretical reformulation matches the problem statement given at the beginning of this section.

biological aspects
the basic entities of our model are the alignment, interaction, and gap edges in the structural graph, which contribute to the objective function rather independently. hence, one could argue that the model does not capture important features of rna structures, like the incorporation of stacking energies or loop scores that depend on the actual size of the loop. we are aware of these limitations.

nevertheless, the results of our computational experiments presented in sect.  <dig> show that this approach yields high-quality structural alignments. in the pairwise case, our graph-based model is competitive with state-of-the-art approaches and develops its strength with an increasing number of sequences, outperforming all other programs that we tested . additionally, the authors of  <cit>  showed that models that do not capture stacking energies and loops are still competitive.

beyond, our graph-based approach offers the possibility to change the model from nucleotides as the working entities to stems: instead of taking single nucleotides as the vertices of the structural graph, we could search for candidate stems in the sequences and introduce a vertex for each half-stem. this would allow us to incorporate energy-based scoring into our model, which then, however, will have to be adapted to take into account overlapping stem candidates.

 <dig>  integer linear program and lagrangian relaxation
given the graph-theoretical model it is straightforward to transform it to an integer linear program . we associate binary variables with each line, interaction match, and gap edge, and model the constraints of a valid gapped structural trace by adding inequalities to the linear program.

the handling of lines and gap edges is straightforward: we associate a x and z variable to each line and gap edge, respectively. we set xl =  <dig> if and only if line l ∈ l is part of the alignment ℒ
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaat0uy0hwztfgdpnwy1egaryqthrhal1wy0l2yhvdaiqaacqwfsectaaa@376d@, and za =  <dig> if and only if gap edge a ∈ g is part of the alignment.

interaction matches, however, are treated slightly differently: instead of assigning an ilp variable to each interaction edge, we split an interaction match  into two separate directed interaction matches  and  that are detached from each other. a directed interaction match  is realized by the line set ℒ
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaat0uy0hwztfgdpnwy1egaryqthrhal1wy0l2yhvdaiqaacqwfsectaaa@376d@ if l ∈ ℒ
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaat0uy0hwztfgdpnwy1egaryqthrhal1wy0l2yhvdaiqaacqwfsectaaa@376d@. we then have ylm =  <dig> if and only if the directed interaction match  is realized . figure  <dig> gives an illustration of the variable splitting. note that this does not change the underlying model, it just makes the ilp formulation more convenient for further processing. splitting interaction matches has first been proposed by caprara and lancia in the context of contact map overlap  <cit> .

as described in sect.  <dig> , the sets l, i, and g refer to lines, interaction edges, and gap edges, and the sets cl
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaat0uy0hwztfgdpnwy1egaryqthrhal1wy0l2yhvdaiqaacqwfce=qdawgaawcbagaemitaweabeaaaaa@3971@ and cg
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaat0uy0hwztfgdpnwy1egaryqthrhal1wy0l2yhvdaiqaacqwfce=qdawgaawcbagaem4raceabeaaaaa@3967@ contain subsets of mutually conflicting lines or gap edges.

we then give the following ilp formulation for the gapped structural trace problem:

 max⁡∑l∈lwlxl+∑l∈l∑m∈lwlmylm+∑g∈gwgzg
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaacyggtbqbcqgghbqycqgg4baedaaeqbqaaiabdeha3naabaaaleaacqwgsbabaeqaaogaemieag3aasbaasqaaiabdygasbqabaaabagaemibawmaeyici4saemitaweabeqdcqghris5aogaey4kasyaaabuaeaadaaeqbqaaiabdeha3naabaaaleaacqwgsbabcqwgtbqbaeqaaogaemyeak3aasbaasqaaiabdygasjabd2gatbqabagccqghrawkdaaeqbqaaiabdeha3naabaaaleaacqwgnbwzaeqaaaqaaiabdeganjabgigiolabdeeahbqab0gaeyyeiuoakiabdqha6naabaaaleaacqwgnbwzaeqaaaqaaiabd2gatjabgigiolabdyeambqab0gaeyyeiuoaasqaaiabdygasjabgigiolabdyeambqab0gaeyyeiuoaaaa@600f@ 

 s.t.∑l∈clxl≤1∀cl∈cl
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaafaqaaeqacaaabaacbagae83cam3exlmbbxgbcf2cpn2qvrwzqf2zlnharyavp1wzzbitldhis9wbh5gaiqaacagfuagae8hdaqnaa4nlamaaqafabagaemieag3aasbaasqaaiabdygasbqabagccqghkjyocqaixaqmasqaaiabdygasjabgigiolabdoeadnaabaaameaacqwgmbataeqaaawcbeqdcqghris5aagcbagaeyiaiiiaem4qam0aasbaasqaaiabdyeambqabagccqghiiizt0uy0hwztfgdpnwy1egarcqthrhal1wy0l2yhvdaiuaacqqfce=qdawgaawcbagaemitaweabeaaaaaaaa@5cd6@ 

 ∑a∈cgza≤1∀cg∈cg
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaafaqaaeqacaaabawaaabuaeaacqwg6bgedawgaawcbagaemyyaegabeaakiabgsmijkabigdaxawcbagaemyyaemaeyici4saem4qam0aasbaawqaaiabdeeahbqabaaaleqaniabgghildaakeaacqghaiiicqwgdbwqdawgaawcbagaem4raceabeaakiabgigioprthrhal1wy0l2yhvtyaehbnfgdovwbhrxajfwnagabaiab=jq8dnaabaaaleaacqwghbwraeqaaaaaaaa@4b20@ 

 xl+∑a∈gs↔sza=1∀l∈l
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaacqwg4baedawgaawcbagaemibawgabeaakiabgucaruaabaqabiaaaeaadaaeqbqaaiabdqha6naabaaaleaacqwghbqyaeqaaogaeyypa0jaegymaedaleaacqwghbqycqghiiizcqwghbwrdawgaaadbagaem4camnaeiikagiaemibawmaeiykakiaeyilhsqaem4camnaeiikagiaemibawmaeiykakcabeaaasqab0gaeyyeiuoaaoqaaiabgcgiiiabdygasjabgigiolabdyeambaaaaa@4baf@ 

 xl+∑a∈gt↔tza=1∀l∈l
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaacqwg4baedawgaawcbagaemibawgabeaakiabgucaruaabaqabiaaaeaadaaeqbqaaiabdqha6naabaaaleaacqwghbqyaeqaaogaeyypa0jaegymaedaleaacqwghbqycqghiiizcqwghbwrdawgaaadbagaemidaqnaeiikagiaemibawmaeiykakiaeyilhsqaemidaqnaeiikagiaemibawmaeiykakcabeaaasqab0gaeyyeiuoaaoqaaiabgcgiiiabdygasjabgigiolabdyeambaaaaa@4bb3@ 

 ∑m∈lylm≤xl∀l∈l
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaafaqaaeqacaaabawaaabuaeaacqwg5bqedawgaawcbagaemibawmaemyba0gabeaakiabgsmijkabdiha4naabaaaleaacqwgsbabaeqaaaqaaiabd2gatjabgigiolabdyeambqab0gaeyyeiuoaaoqaaiabgcgiiiabdygasjabgigiolabdyeambaaaaa@40e8@ 

 ylm = yml     ∀l, m ∈ l 

 x ∈ { <dig>  1}l y ∈ { <dig>  1}l×l z ∈ { <dig>  1}g 

lemma  <dig>  
a feasible solution to the ilp – corresponds to a valid gapped structural trace of weight equal to the objective function and vice versa.

observe that constraints – exactly correspond to the properties of a gapped structural trace as described in sect.  <dig> .

in  <cit>  the authors show that the problem of computing an optimal gapped structural trace is already np-hard, even without considering gap costs. hence, we cannot hope to find an optimal solution to the problem in polynomial time.

commonly used mathematical programming techniques for np-hard problems therefore resort to various relaxation techniques that are the basis for further processing. a relaxation results from the removal of constraints from the original ilp formulation, and is often solvable in polynomial time. a popular relaxation is the so called lp relaxation where the integrality constraints on the variables are dropped, yielding a standard linear program, for which solutions can be found efficiently.

another possible relaxation technique is lagrangian relaxation: instead of just dropping certain inequalities, we move them to the objective function, associated with a penalty term that becomes active if the dropped constraint is violated. by iteratively adapting those penalty terms using, for instance, subgradient optimization, we get better solutions with each iteration. a crucial parameter is therefore the number of iterations that we perform: the higher the number, the more likely it is to end up with an optimal or near-optimal solution.

inspired by the successful approach of lancia and caprara for the contact map overlap problem, we consider the relaxation resulting from moving constraint  into the objective function.

lemma  <dig>  
the relaxed problem is equivalent to the pairwise sequence alignment problem with arbitrary gap costs.

 <dig>  algorithms for the pairwise and multiple case
our algorithm for the pairwise rna structural alignment problem consists of iteratively solving the primary sequence alignment problem associated with the relaxation. the penalization of the relaxed inequality is reflected in an adapted scoring matrix for the primary alignment. intuitively, these weights incorporate also the structural information. in each iteration we get a new lower bound for the problem by analyzing the primary sequence alignments and inferring the best structural completion of this alignment. in fact, this corresponds to solving a maximum weighted matching problem in a general graph. for details see  <cit> . in the course of the algorithm, these solutions get better and better. furthermore, the value of the relaxation itself constitutes an upper bound on the problem, which decreases with an increasing number of iterations. when these bounds coincide, we have provably found an optimal solution, otherwise, we get near-optimal solutions with a quality guarantee. assuming an upper bound on the number of interaction matches per line, which is typically the case with base pair probability matrices of rna sequences, we get a running time of o for each lagrangian iteration. since we fix the number of iterations, this leads to an overall time complexity of o.

for the multiple case, similar in spirit to the marna software, we combine our pairwise method with the popular progressive alignment software t-coffee  <cit> . progressive methods build multiple alignments from pairwise alignments. the pairwise distances are usually used to compute a guide tree which in turn determines the order in which the sequences are aligned to the evolving multiple alignment.

progressive approaches often suffer from their sensitivity to the order in which the sequences are chosen during the alignment process. t-coffee reduces this effect by making use of local alignment information from all pairwise sequence alignments during its progressive alignment phase. we supply such local alignment information based on all-against-all structural alignments computed with our pairwise approach, assigning a high score to conserved interaction matches. the structural information is subsequently passed on to t-coffee that computes a multiple alignment, taking into account the additional structural information.

 <dig> experiments
the basis of our computational experiments is the recently published benchmark set bralibase  <dig>   <cit> . we compared our program to four other alignment programs  using two established measures for the quality of structural alignments . we performed all experiments with default parameters.

 <dig>  bralibase  <dig> 
we chose this data set, which is available from  <cit> , as our test set, since it covers a greater range of typical noncoding-rna families than the original bralibase data set  <cit> . bralibase  <dig>  contains  <dig> different rna families, ranging from approximately  <dig> nucleotides long histone 3'utr stem-loop motifs to approximately  <dig> nucleotides long eukaryotic srp rnas. see  <cit>  for a detailed listing of all instances. bralibase  <dig>  reference alignments are based on manually curated seed alignments of the rfam  <dig>  database  <cit> . out of the pool of all ncrna families that have more than  <dig> sequences in their seed alignment, either  <dig>   <dig>   <dig>   <dig>   <dig> or  <dig> sequences were randomly drawn considering constraints on the sequences . these subsets of the original seed alignments form the instances of bralibase: in the following we stick to the bralibase naming convention and refer to the sets of instances by k <dig>  k <dig>  k <dig>  k <dig>  k <dig>  and k <dig>  depending on the number of sequences per instance.

 <dig>  compalign and sci
we use two different scores to measure the quality of the computed alignments: the compalign value codes the degree of similarity to a given reference alignment as given by the percentage of columns that are identically aligned as in the reference alignment. a value of  <dig> states that the reference and test alignment are the same, whereas  <dig> denotes that no column was correctly aligned with respect to the reference alignment.

the second score is the so called structural conservation index  <cit>  . the sci basically gives the degree of conservation of a consensus structure induced by a multiple alignment in relation to the minimum free energy structure of each sequence . a sci value of ≈  <dig> indicates very high structural conservation, whereas a value around  <dig> indicates no structural conservation at all. note that the sci score can be greater than  <dig>  because covariance information is additionally rewarded in the computation.

we have used the programs compalignp and scif to compute the compalign and sci score. both tools are freely available from the bralibase website.

 <dig>  other structural alignment programs
we implemented our approach called lara in c++ within the lisa framework. lisa  contains various methods for aligning protein and rna structures as well as biological networks.

furthermore, we selected several other multiple structural alignment programs to compare the results. we used marna  <cit>   using an ensemble of three suboptimal structures as its input, stral  <cit>  , and a reimplementation of the pmcomp approach called foldalignm  <cit>  . furthermore, to compare the performance of the structure-based alignment programs to purely sequence-based ones, we performed the same tests with mafft  <cit> , a recent multiple sequence alignment program which is available from  <cit> . we want to emphasize that we did not perform any parameter tuning for any program , i.e., we downloaded the programs from the respective websites and performed the computations out of the box without specifying any optional parameters.

since earlier studies  <cit>  showed that structural alignments only contribute an additional benefit – compared to sequence-based approaches – if the pairwise sequence identity drops below ≈  <dig> – 60%, we restricted the test set to instances of low homology, i.e., instances having a pairwise sequence identity below 50%.

 <dig>  lara
a scoring system for structural alignments has to provide two different kinds of scores: scores for the sequence and the structure part . since the structure is considered to contain the necessary information for "correct" alignments, we have to make sure that the structure scores contribute the major part to the overall score.

we do not generate the complete annotation for our input sequence, that is, an interaction edge between every possible interaction, but restrict interaction edges to those having base pair probabilities larger than a threshold pmin. for our experiments we resorted to a value of  <dig> , similar as in pmcomp. the impact of different pmin values is twofold: first, the lower the value is, the higher the structure scores are. secondly, a high pmin value leads to a sparser structure graph.

for the scoring of the edges, lara provides two different schemes: first, a scoring system based on base pair probability matrices  that rescales the scores in spirit of pmcomp. more precisely, given the probability pij that nucleotide i and j pair, the actual score sij for the structural interaction between i and j is given by

 sij=lg⁡
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaacqwgzbwcdawgaawcbagaemyaakmaemoaaogabeaakiabg2da9igbcygasjabcegannaabmaabawaasaaaeaacqwgwbacdawgaawcbagaemyaakmaemoaaogabeaaaoqaaiabdchawnaabaaaleaacyggtbqbcqggpbqacqggubgbaeqaaaaaaogaayjkaiaawmcaaaaa@4078@ 

where lg is the natural logarithm. for the sequence scoring, we take the entries from the ribosum matrices  <cit>  as the actual sequence scores  and multiply them by a user-specific adjustment factor τ. the default value for τ is  <dig> , leading to a small sequence score contribution to the overall score. if one knows, however, that sequence is equally or more important than the structure , one simply has to increase the value of τ.

the second scheme employs the ribosum scoring matrices both for sequence and structure scoring: these matrices are based on given alignments of ribosomal rnas from which log-odds scores were derived. they provide both sequence and structure scores, without rescaling the scores.

the second crucial lara parameter is the number of iterations: the more iterations lara computes, the more often the penalty terms are adapted . as one can see in fig.  <dig> the number of iterations influences the quality of the computed alignment while the running time increases linearly with the number of iterations. in our experiments we set the number of iterations to  <dig> 

the scoring of gap edges follows the scheme of affine gap costs with an gap open and extension penalty of - <dig> and - <dig>  respectively.

score vs. alignment accuracy
we were interested to what extent the accuracy of our alignments correlates with the actual bpp score that we computed. since the score depends on the length of the input sequences, we normalized the score with respect to the number of paired bases in the minimum free energy structure. note that we did not use the actual structure, but the number of base pairs in the structure to get a rough estimate of how many pairings we expect in the structure. then, let p^
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaacuwgwbacgaqcaaaa@2e25@ and n be the average score and the number of base pairs in the mfe structure, then the base-pair normalized score is given by p^
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaacuwgwbacgaqcaaaa@2e25@/n. the left side of fig.  <dig> shows the results for all  <dig> k <dig> instances with an average pairwise sequence identity less than 50%. the great majority of instances behaves as expected: the higher the bp-score is, the better is the corresponding compalign score: there is, however, a group of  <dig> outliers . although they have a high bp-score , the alignment accuracy is bad: it turned out that these  <dig> instances are all secis-elements, indicating that the bpp scoring scheme is not appropriate for this group.

furthermore, we assumed that there should a correlation between the actual performance of our algorithm and, again, the quality of our alignments: remember that each lagrange iteration results in a new valid solution and a new upper bound for the problem instance. dividing the value of the highest lower bound by the value of the lowest upper bound gives an optimality ratio, i.e., a measure of how close the best solution is to an optimal one. assuming an inverse correlation between the gap between lower and upper bound and the quality of the alignment, we again took all k <dig> bralibase instances of low pairwise sequence identity and computed the arithmetic mean of the optimality ratios of all pairwise alignments. the right side of fig.  <dig> shows the plot for all  <dig> k <dig> instances with a sequence similarity lower than 50%. most of the instances behave as expected: the higher the average optimality ratio is, the closer is the computed alignment to the reference alignment . there is, however, a group of  <dig> instances that behave differently : although their average optimality ratio is high , the corresponding compalign value is rather low compared to instances of a similar average optimality ratio. a closer inspection revealed that all instances of the upper left corner  comprises almost all instances of either bacterial srp rnas or secis elements . we therefore increased the number of iterations for one secis instance to see whether this would positively influence the quality of the alignment. by setting the number of iterations to  <dig>   <dig>  and  <dig> we got average optimality ratios of  <dig> ,  <dig> , and  <dig> , by simultaneously yielding compalign values of  <dig> ,  <dig> , and  <dig> , respectively. obviously, the better the computed alignments in terms of the optimality ratio are, the worse they got with respect to the reference alignment.

consequently, for the outlier instances described above, we changed the scoring from bpp to ribosum scores. figure  <dig> shows the change in terms of the compalign score and optimality ratio for the  <dig> outlier instances:  <dig> instances had better compalign scores by using the ribosum scoring, whereas the optimality ratio decreased in the majority of instances.

in general, however, our experiments showed that ribosum scoring is not superior to bpp scoring : figure  <dig> shows a comparison of all low homology k <dig> instances using either base pair probability matrices or ribosum scoring, and it is obvious that base pair probability scoring yields better results on these input instances.

 <dig>  comparison with other programs
as described in sect.  <dig>  we used two different scores to assess the quality of the computed alignments: the compalign  and the sci score .

foldalignm performs an alignment and clustering of the input sequences at the same time: in some instances, foldalignm splits the input sequences into two clusters. since the scores that we use depend on the number of input sequences, we dropped those foldalignm alignments that did not contain all sequences in the final alignment: this leads to  <dig>   <dig>   <dig>   <dig>   <dig>  and  <dig> instances that we did not consider in case of k <dig>  k <dig>  k <dig>  k <dig>  k <dig>  and k <dig> instances.

in fig.  <dig> we show the results of our experiments broken down to the different input classes . these graphics have the average pairwise sequence identity and the compalign score as their x- and y-axis, respectively. the reference alignments therefore correspond to horizontal lines at a compalign score of  <dig> .

we have made several observations: first of all, in the pairwise case  lara has a similar performance as the sankoff variant foldalignm up to a sequence identity of ≈ 42%. for the range of ≈  <dig> – 50% all programs  have comparable performance . with an increasing number of input sequences per instance, especially for the k <dig> and k <dig> sequences, the results change tremendously: lara outperforms the other programs, yielding average compalign scores of ≈ 90%, whereas the other structure-based alignment programs have scores around ≈  <dig> – 75%. this is quite remarkable, especially considering that foldalignm and lara show a similar performance in the pairwise case: foldalignm, however, computes multiple alignments in a progressive fashion, whereas lara computes all pairwise alignments and leaves it to t-coffee to compute an alignment that is highly consistent with all pairwise alignments. with an increasing number of input sequences, the consistency-based approach generates better alignments than the progressive methods .

another astonishing observation is the performance of mafft, a purely sequence-based program: the k <dig> and k <dig> instances show a comparable performance for instances above ≈ 42%, which is already surprising. with a growing number of input instances, the performance of mafft becomes even better: in case of  <dig> input instances, the program yields – on average – the second best results , outperforming even foldalignm and stral, which incorporate structural information. it has to be investigated whether the creation of the benchmark set has to be revisited, because these plots clearly contradict the hypothesis that sequence-based programs yields significantly worse results for input instances of a pairwise sequence identity below 50%.

in fig.  <dig> we show the results with respect to the sci score . the general trend is the same as in fig.  <dig>  in the pairwise case, the lara curve has the same shape as the reference curve, but shifted to the bottom by about  <dig> . foldalignm yields the best approximation to the reference line, having almost the same performance for instances with an apsi greater than 30%. with an increasing number of input sequences, the situation changes: from k <dig> on lara generates the best approximation to the reference line, with foldalignm being the second best program. taking a look at the various result plots puts the extraordinary performance of mafft into perspective regarding the k <dig> and k <dig> input sets.

comparison of running times
we compared the programs tested on the same computing server with an intel xeon cpu running at  <dig>  ghz,  <dig>  gb ram, and linux kernel version  <dig> . <dig>  it turned out that memory requirement was not an issue, but the computation time instead: especially marna scales in o
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaat0uy0hwztfgdpnwy1egaryqthrhal1wy0l2yhvdaiqaacqwfoe=taaa@383c@, which makes the alignment of longer sequences  rather time-consuming. this, however, is not the case with lara and foldalignm, since these two programs have running times in o
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaat0uy0hwztfgdpnwy1egaryqthrhal1wy0l2yhvdaiqaacqwfoe=taaa@383c@. to evaluate the time consumption within reasonable time, we therefore set a time limit of  <dig> minutes per instance: if the computation was not finished within  <dig> minutes, the process was killed and we took  <dig> minutes as the actual running time. in table  <dig> we list the number of instances that the corresponding program was not able to align within  <dig> minutes.

we were especially interested in how the running times of the programs that use structure information scaled with respect to the number of the input sequences: foldalignm is a progressive approach which computes  pairwise alignments given n input sequences. marna and lara, however, compute all n2
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaadawcaaqaaiabd6gaujabcicaoiabd6gaujabgkhitiabigdaxiabcmcapaqaaiabikdayaaaaaa@3407@ pairwise alignments. figure  <dig> shows the execution time of all five programs on all k <dig>  k <dig>  k <dig>  k <dig>  k <dig>  and k <dig> instances. as one can see, with an increasing number of input sequences, a progressive alignment strategy pays off compared to the computation of all pairwise alignments.

 <dig> 
CONCLUSIONS
we have presented a novel method for computing high-quality pairwise structural rna alignments. we approach the original problem using a flexible graph-based model, which naturally deals with pseudoknots.

we find solutions in our model by means of an integer linear programming formulation and the lagrangian relaxation technique. for the multiple case, we compute all-against-all pairwise solutions and pass this information to t-coffee, a progressive alignment algorithm.

our extensive computational experiments on a large set of benchmark alignments show that lara, the implementation of our algorithm, is competitive with state-of-the art tools and outperforms alternative approaches with an increasing number of input sequences. the difference to other programs gets larger the more sequences that have to be aligned. in this context, we also find the performance of mafft, a purely sequence-based program, remarkable. mafft comes closer to manually curated reference alignments than all other structure-specific tools besides lara for alignments of more than ten sequences.

our plans for the future include a local version of our alignment algorithm. furthermore, we are currently implementing an exact branch-and-bound framework around the lagrangian approach and will develop a stem-based variant of lara. furthermore, the openness to pseudoknots is the main advantage of lara over alternative approaches, and we plan to adapt our method to produce high-quality alignments of pseudoknotted structures.

availability and requirements
lara  is part of the c++ library lisa and is freely available for academic purposes from . the binary runs under the linux operating system.

all alignments that we computed and the scripts for generating the plots are also available from .

authors' contributions
mb, gwk, and kr developed the integer linear program model. mb coded the program and carried out the computational experiments. mb and gwk drafted the manuscript, gwk and kr coordinated the research. all authors read and approved the final manuscript.

supplementary material
additional file 1
this is a compressed tar file containing all alignments used in the experimental study.

click here for file

 acknowledgements
this work has been partly supported by the dfg grant kl 1390/2- <dig>  mb is additionally supported by the international max planck research school for computational biology and scientific computing. the authors thank the anonymous referees for valuable comments.
