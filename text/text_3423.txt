BACKGROUND
the genome-wide characterization of chromatin protein binding sites and the profiling of patterns of histone modification marks is essential for understanding the dynamics of chromatin, unraveling the transcriptional regulatory code and probing epigenetic inheritance. the main technique for performing this characterization is chromatin immunoprecipitation , coupled with massively parallel short-read sequencing  <cit> . unlike its predecessor chip-chip  <cit> , chip-seq provides improved dynamic range and spatial resolution <cit> .

after mapping sequenced chip reads to the reference genome, the first critical task of chip-seq data analysis is to accurately identify the target binding sites or regions enriched in histone marks  <cit> . since downstream analysis relies heavily on the accurate identification of such binding sites or regions, a large number of algorithms have been proposed for peak calling <cit> .

despite the availability of such a large set of peak callers, many of these algorithms have disadvantages in real-world settings. some algorithms have high sensitivity, but call an excessive number of false positive peaks due to low specificity. others have the opposite problem. another limitation of the current generation of peak callers is that many are optimized to detect either narrow punctate features, such as those generated by transcription-factor binding site experiments, or else optimized to detect broad peaks, such as those characterized by regions of modified histones. hence a chip-seq production environment may need to install and maintain two different peak calling software packages. those algorithms that attempt to handle both type of peak typically do so at the sacrifice of inter-peak and spatial resolution. the former is the ability to distinguish two or more closely-spaced peaks, while the latter is the ability to correctly locate the target binding site or histone modification boundaries. both types of resolution are essential for understanding the underlying biology of chromatin dynamics. an example of how loss of resolution can affect the interpretation of chip-seq data is shown in figure  <dig> 

software usability is also an issue. some otherwise excellent peak callers are difficult to use because they require unusual data file formats, run slowly on real-world data sets, or do not take advantage of cluster computing. poor usability can also impede the ability of a researcher to integrate the software with other tools in an analytic pipeline.

here we present our efforts to address these concerns by creating peakranger, a novel peak caller that is both accurate and usable. across a series of six accuracy benchmarks and three software usability benchmarks, it compares favorably to  <dig> other peak callers selected from the recent literature. in addition, peakranger supports mapreduce based parallel computing in a cloud environment, allowing it to scale well to large data sets in high-volume applications.

implementation
building the read coverage profile
the first step of peak calling is to build a read coverage profile using aligned raw reads. a key step in chip-seq is to shear the immunoprecipitated chromatin into fragments of 200- <dig> bp prior to extracting the dna and sequencing it. because the shear size is much larger than the small reads produced by early next-generation sequencing machines, many peak calling algorithms make use of the "shift" distance between coverage peaks defined by plus and minus strand read alignments, but this has become less useful as the read length produced by next-generation sequencers approaches the chip-seq dna shear size. peakranger uses the same "blind-extension" strategy as peakseq <cit>  in which the shear size is provided by the user and not estimated from aligned raw reads. this choice significantly simplifies the software design and improves performance. 

peak detection
we first identify broad regions of signal enrichment using the same algorithm as peakseq, which detects contiguous enrichment regions by thresholding. after that, we use a "summit-valley-alternator" algorithm to scan for summits within regions identified by peakseq. this algorithm starts by searching for the first summit within the region, where a summit is defined as the location that has the maximum signal value before subsequent locations drop below a pre-defined cutoff value. the value is calculated by multiplying the current maximum signal value with delta, a tuning factor that should be chosen based on the needs of users. delta is in the range . since the reads signal of broad regions are usually noisy, we perform additional signal processing before calling summits. 

software engineering
peakranger is written in c++, and can be compiled on linux, macos and windows. it runs as a command-line program.

RESULTS
benchmarking
in preparation for benchmarking, we compiled a list of  <dig> third-party peak callers mentioned in two recent reviews  <cit>  plus several recently-published packages . we attempted to install and run each peak caller on a test data set, and discarded seven that either failed to install, crashed during the test run, or produced no peaks from the test data set. this reduced the number of peak callers evaluated to  <dig>  including peakranger.

sensitivity benchmarks
in order to evaluate the sensitivities of the  <dig> algorithms, we evaluated them using two independent chip-seq datasets whose binding sites had been validated by qpcr <cit> . peaks called by each peak caller were ranked by their confidence scores and then compared to the list of validated sites. as measured by the average recovered proportion of validated sites, peakranger ranks within the top group, all of which have very similar sensitivities.

specificity benchmarks
it is more difficult to evaluate the specificity of peak calling than sensitivity because there is no golden standard of true-negative binding sites of sufficient size to confidently evaluate specificity. to partially address this issue, we performed a specificity analysis using a previously-published synthetic dataset  <cit> . this data set was generated from a real-world control  experiment that contains no binding events, which was then spiked with simulated binding site peaks. since all peaks were generated by the author, the locations of all simulated binding sites are known and false positive peaks can thus be defined.

spatial accuracy benchmark
spatial accuracy measures the ability of the peak caller to correctly identify the biological binding site underlying punctate peaks. to evaluate spatial accuracy, we again used the chip-seq data sets for the gabp and nsrf transcription factor targets. to identify the most likely biological binding sites, we used mast <cit>  and the canonical target binding site motif and corresponding position specific scoring matrices  to find all matches in the  <dig> bp surrounding regions.

we ran each of the peak callers on the data sets, and measured the distance between the binding site motifs and the centers of the closest overlapping peak call. as shown in figure  <dig>  algorithms that report peaks as single bp coordinates are much better than those that report broader regions. in particular, spp, findpeaks, gps and quest were all tied for first place, closely followed by peakranger. however, the difference in spatial accuracy among the top-ranked peak callers is small.

inter-peak resolution benchmark
this benchmark measures the ability of peak callers to distinguish between two closely-spaced peaks. this is a particularly difficult task for region-reporter algorithms, which tend to merge close peaks, potentially missing biologically-significant duplets. peakranger identifies closely-spaced summits within an enriched region by identifying local maxima within a smoothed model of coverage.

there are no real-world gold standard data sets for evaluating inter-peak resolution, so we adapted the semi-synthetic data set used previously for the specificity benchmarks. we created a series of derivative data sets to simulate closely spaced binding sites by generating a peak adjacent to each synthetic binding site. the inter-peak spacing varied from  <dig> to  <dig> bp in each of  <dig> derived data sets. to compensate for changes in coverage introduced by this modification, we added the same number of reads to the control. some peak callers, including peakranger, provide a "resolution mode" that seeks to discover all summits within an enriched region. for this benchmark, we set each algorithm to use resolution mode or equivalent when available, or the default settings when not.

as shown in figure 5a, no peak caller is able to resolve closely-spaced peaks in this data set when the peak separation is less than  <dig> bp. in the range of 250- <dig> bp, findpeaks and peakranger lead the group in sensitivity, but findpeaks produces an excessive number of false positives, as shown in figure 5b. the other algorithms have lower sensitivities across this range and some exhibit very high false positive rates as well. macs crashed on the  <dig> bp,  <dig> bp and  <dig> bp data sets, so these data points are missing.

usability design and performance tuning
published algorithms are sometimes released in the research prototype stage, and do not have the software engineering necessary to work in a high volume, high availability setting. ideally, a number of software engineering issues should be addressed . first, the software should be as fast as possible. our experience in large projects such as the modencode project <cit>  supports the notion that a faster peak caller will significantly reduce the time to analyze and interpret chip-seq data, because all the downstream analyses rely on accurate peak calls and there is often a cycle in which the results of downstream analyses inform additional rounds of peak calling using different parameter sets. second, the software should support multiple common data formats. transforming file formats requires extra time, computing resources, and introduces a step in which programming errors can creep in. third, the software should be easy to use and requires less computing expertise from users. finally, the software should be able to handle very large chip-seq data sets, given the rapid increase in next generation sequencing capacity.

this table summarizes commonly supported software features by existing peak callers.

we implemented peakranger in the compiled c++ programming language to optimize performance. we avoided performance losses from disk i/o by keeping all working data in memory rather than in temporary files; this has the effect of trading a larger memory footprint for increased execution speed. to take advantage of modern multi-core processors, we also designed peakranger to use parallel processing.

to benchmark the performance of peakranger against other peak callers, we recorded the running time of them required to process a typical data set. as shown in table  <dig>  peakranger is more than twice as fast as the next fastest peak caller tested, while consuming an acceptable amount of memory.

running time and memory footprint was recorded for peak callers using the gabp dataset.

to enable the support of multiple input data formats, we adopted designs shared by spp and macs which separate data loading from data processing. we wrote individual modules for specific data formats and let users to choose the one they need. peakranger currently supports bowtie <cit> , eland, sam <cit>  and bam <cit>  formats. other file formats can be added by writing additional importation modules. peakranger is also capable of exporting its results in formats suitable for data visualization, including both compressed and uncompressed versions of the ucsc genome browser "wiggle" format.

to support multiple species, peak calling packages need basic genome build information such as the names and sizes of chromosomes. for users' convenience, peakranger can either derive this information directly from the input files, or can be given pre-computed genome tables. although the former mode is convenient, it does add a small amount of overhead to the execution time.

although hard to quantify, we noted considerably variation in the difficulty of installing and configuring the various peak caller packages during our benchmarking tests. for example, some packages require the user to make changes to the source code in order to change the location of hard-coded file paths and run-time parameters. peakranger makes all its run-time configuration parameters available as command-line options, and also provides a reasonable set of presets for common analysis tasks. for example, peakranger provides "resolution mode" and "region mode", which are presets suitable for analyzing transcription factor binding sites and other punctate data on the one hand, and broad regions such as histone modifications on the other. all run-time parameters can be read from external configuration files as well, allowing parameter sets to be managed by source code control, versioned, and shared among laboratories.

peakranger does not provide a graphical user interface  such as those provided by cisgenome, useq and sole-search <cit> . while guis are convenient for casual users, they make it difficult to integrate the software into the automatic workflows needed by high-throughput laboratories, which are the target audience for peakranger.

support for mapreduce
with sequencing industry's rapidly increasing capacity to generate more and longer sequencing reads <cit> , peak calling algorithms face an exponentially growing demand for computational resources. cloud computing <cit>  offers a cost-effective solution for groups that have highly variable demands for compute resources.

current cloud computing infrastructures offer a highly scalable parallel computational model called mapreduce <cit>  which was originally designed by google to process very large-volume datasets. we thus also implemented a mapreduce version of peakranger on top of the hadoop library <cit> , a free open source implementation of mapreduce.

the hadoop version of peakranger supports splitting the job by chromosomes to take advantage of the chromosome-level independence  of chip-seq data sets. other ways of partitioning the genome are possible, but require additional preparation by the user.

within the hadoop framework, a peakranger job can be expressed as a series of "map-then-reduce" sub-jobs . peakranger first starts a series of mappers to map the input datasets to a set of keys. then a hadoop partitioner assigns keys to a set of reducers. each individual reducer fetches the data according to the keys it receives and processes these data. in the cli case, "map-then-reduce" becomes "split-by-chromosome-then-call-peaks" where chromosomes are used as keys. that is, we delegate the data loading/preprocessing to mappers and peak calling to reducers. after mappers finishes splitting data on chromosome, the partitioner assigns jobs based on the number of available reducers and reducers then do the actual peak calling.

to evaluate the performance of hadoop-peakranger, we performed two benchmark tests: 1) test with fixed number of nodes and data sets of increasing size; 2) test with increasing numbers of nodes and data sets with fixed sizes.

in the second test, we tested how the running time scales with the increasing number of nodes . as expected, runtime decreases rapidly until the number of nodes equals the number of chromosomes , after which adding additional nodes does not provide further benefit. future versions of peakranger will provide alternate ways of splitting the genome to overcome this parallelization bottleneck.

we plan to make both the regular and hadoop version of peakranger available as public machine images in amazon ec <dig> and other cloud service providers in order to facilitate its use by the research community.

real world usage of peakranger
in this section we provide two examples of using peakranger in biological research settings.

characterization of broad enriched regions
it is common for studies of histone modifications to identify broad regions enriched in the modification of interest and then to correlate these broad regions with other biological annotations such as genes. although this type of analysis is straightforward, it ignores the detailed internal structure of the enriched profiles, which can contain summits and valleys relating to quantitative differences in modification efficiency and/or heterogeneity within the sample.

recently there have been several publications reporting biologically significant phenomena based on the internal structures of the enriched histone modification regions  <cit> . therefore it is desirable that a peak caller be able to retrieve both broad enriched regions while simultaneously identifying the detailed summits within these regions. here we demonstrate such an example using peakranger.

in the paper recently published by he et al <cit> , the authors found that after exposures to 5-α-dihydrotestosterone  the central nucleosome was depleted from a subpopulation of androgen receptor  binding sites, leaving a pair of flanking nucleosomes. without knowing the region structure in advance, it is difficult to identify the paired nucleosomes from the read coverage signal alone, and he et al built additional models to identify and quantify the paired binding sites.

we applied peakranger directly to the he data set, using a configuration that allowed it to find both broad enriched regions and summits within the regions. we then compared the number of summits in each enriched region before and after dht exposure to directly identify the subpopulation of ar binding sites that have depleted central nucleosomes. in order to accomplish this objective, we configured peakranger to detect summits with comparable heights. as shown in figure 8a, the profile plot strongly resembled that reported in the original publication, and had an average twin-peak separation of  <dig> bp, close to the publication estimate of  <dig> bp. as a comparison, we repeated the same procedure using quest. the resulting estimated peak distance was  <dig> bp and the profile plot departed from the original one. for other peak callers, since no information is available for the number of summits of an enriched region, we could not perform the same analysis.

processing modencode worm datasets
modencode is a multi-center collaboration to catalogue functional elements in c. elegans and d. melanogaster  <cit> , and includes more than  <dig> chip-seq data sets. peakranger was used by modencode as the standard chip-seq peak caller for  <dig> chip-seq experiments for involving  <dig> c. elegans transcription factors across various developmental stages <cit> . peakranger was able to process the entire data sets in less than  <dig> hours running on a regular workstation with 8g ram and a quad core cpu. this illustrates peakranger's ability to integrate into a high-throughput environment. ultra-high through-put enabled great collaborated analysis among different labs. a couple of internal analysis shows that peaks produced by peakranger were of high quality .

discussion
the algorithm used to find the summits within enriched regions are similar to those used by quest and findpeaks. to make the summit detection more reliable and flexible, we enhanced it based on our experiences of real chip-seq datasets. in quest, users can not control the sensitivity of summits detection. in comparison, peakranger allows users to specify the sensitivity by using the -r option. we also applied an additional padding algorithm to avoid calling false positive summits. in case a dataset does not have adequate sequencing depth, we pad enriched regions so that the summit detection algorithm will not call summits if two base pairs are separated with regions of zero read counts.

peakranger relies on peakseq which detects enriched regions before the step of summit detecting. peakseq is an effective algorithm but the original implementation gives only limited usage of the algorithm. we thus significantly modified peakseq so that it can be integrated as a part of peakranger. peakseq contains two separate parts: pre-processing and peak-calling. these two parts are now combined into a single module to reduce file i/o cost. we also designed indexing of chromosomes to enable support to other species with different number and names of chromosomes. the original peakseq runs in single-thread mode and we modified related data structures to support multi-thread mode.

although peakranger represents a successful compromise among multiple measures of accuracy, researchers should consider one of the other peak calling algorithms if a particular performance characteristic is of the top priority. for example, if identifying the precise center of the peak is critical to an experiment, then researchers should consider gps, quest, macs, spp or findpeaks, all of which have better spatial accuracy than peakranger.

the current design for the hadoop version is based on chromosome-level-independence , which limits the practical level of parallelization to the number of chromosomes in the genome. this concept can be generalized to region-level-independence  by breaking the genomes into a set of arbitrary regions and call peaks in each individual region. however, this is dependent on the peak calls for each region being independent of each other, a criterion that is not satisfied when an enriched region crosses the region boundary. additional manipulation of the regions to allow for overlap between them, and adjustments for the changes in coverage in overlapped regions will be necessary to implement this, and is deferred to future work. however, even with the current design we are able to archive an order-of-magnitude increase in speed, which is sufficient for most practical applications.

CONCLUSIONS
in this paper, we introduce peakranger, a general purpose chip-seq peak calling algorithm that is optimized for accuracy, speed and ease of use. it is suitable for use in small laboratories, as well as in large production centers, and can be used in a cloud environment for very high throughput environments. the software is freely available and open source under the artistic license  <dig> . the primary download site is http://www.modencode.org/software/ranger/.

availability and requirements
peakranger is under the artistic license  <dig> . peakranger can be downloaded from: http://www.modencode.org/software/ranger/. we currently provide the full source code, as well as binaries for linux systems. binaries for other operating system and an amazon ec <dig> image will be available during the first quarter of  <dig> 

authors' contributions
xf designed, implemented and tested the algorithm. ls helped testing the algorithm. rg provided hardware and software support for the cloud-enabled version. xf and ls wrote the manuscript. all authors read and approved the final manuscript.

supplementary material
additional file 1
this file contains detailed description of the algorithms and benchmarks.

click here for file

 acknowledgements
we thank michal sabala for his help on cloud computing environment configurations. we thank mark gerstein, joel s. rozowsky, bradley i. arshinoff, guanming wu and zheng zha for their comments. we thank marc perry, sonja althammer and zheng zha for their help of datasets. we thank shamit soneji, stephen taylor, ian donaldson and jasreet hundal for their feedbacks of beta releases. this project was funded by the iplant collaborative and a grant from the national science foundation plant cyberinfrastructure program .
