BACKGROUND
effective algorithms for mining genome-scale biological data are in high demand. in the analysis of transcriptomic data, many approaches for identifying clusters of genes with similar expression patterns have been used, with new techniques frequently being developed . many bench biologists become mired in the challenge of applying multiple methods and synthesizing or selecting among the results. such a practice can lead to biased selection of "best" results based on preconceptions of valid findings from known information, which raises the question of why the experiment was performed. given the great diversity of clustering techniques available, a systematic comparison of algorithms can help identify the relative merits of different techniques  <cit> . previous reviews and comparisons of clustering methods have often concluded that the methods do differ, but offer no consensus as to which methods are best  <cit> . in this paper, we compare a broad spectrum of conventional, machine-learning, and graph-theoretic clustering algorithms applied to a high quality, widely used reference data set from yeast.

a popular and diverse set of clustering approaches that have readily available implementations were employed in this analysis . these include five traditional approaches: k-means clustering  <cit> , and the de facto standard hierarchical clustering, on which we tested four agglomeration strategies: average linkage, complete linkage, and the methods due to mcquitty  <cit>  and ward  <cit> . these approaches create clusters by grouping genes with high similarity measures together.

clustering methods are listed by name, along with the type of algorithm, and a general listing of parameters tested. number of clusters in the result, given the parameters and data set tested, is only provided here as an approximate figure. empty results are obviously not included. agrid type can be either rectangular or hexagonal, in an m x n layout. we tested both types, but used an m x m layout for simplicity . brarely occurs in practice. on this data set we observed no overlap with nnn. coptional, not used in this analysis.

seven graph-based approaches are examined: k-clique communities  <cit> , wgcna  <cit> , nnn  <cit> , cast  <cit> , click  <cit> , maximal clique  <cit> , and paraclique  <cit> . these methods use a graph approach, with genes as nodes and edges between genes defined based on a similarity measure. these methods can be divided into two groups: heuristic approaches, and clique-based methods. wgcna, cast, and click are all heuristic approaches, computing approximations to various graph-based metrics. the remaining methods  depend upon finding cliques, or completely connected subgraphs, but use these resulting cliques in different manners. for example, nnn connects each gene to n similar genes and merges overlapping cliques in the resulting graph to form an initial set of networks, while paraclique begins with a clique as a dense core of vertices and gloms on other highly connected genes.

finally, two other approaches are included: self-organizing maps  <cit> , and qt clust  <cit> . som is a machine learning approach that groups genes using neural networks. qt clust is a method developed specifically for expression data. it builds a cluster for each gene in the input, outputs the largest, then removes its genes and repeats the process until none are left.

many issues influence the selection and tuning of clustering algorithms for gene expression data. first, genes can either be allowed to belong to only one cluster or be included in many clusters. non-disjoint clustering conforms more accurately to the nature of biological systems, but at a cost of creating hundreds to thousands of clusters. second, because each method has its own set of parameters for controlling the clustering process, one must determine the ideal parameter settings in practice. there are many different metrics for this problem, which have been evaluated extensively  <cit> . because there is no way of measuring bias of one metric for a particular clustering method and data set, most clustering comparisons evenly sample the reasonable parameter space for each method  <cit> .

there are commonalities between parameters used by some of these methods , for example the average cluster size k used by hierarchical methods is directly related to the number of clusters required by the k-means algorithm. other methods such as nnn and qtclust employ readily-computable graph metrics such as minimum neighborhood size and maximum cluster diameter. the clique-based methods all utilize a threshold value, the variation of which often affects the above metrics such as cluster size. higher threshold values generally result in a less connected graph and therefore smaller cluster sizes. wgcna relies upon a power parameter, to which correlation values are raised. this results in a form of soft thresholding, where the disparity between low and high correlation values is emphasized. click employs a cluster homogeneity parameter, which is a measure of similarity between items in a cluster. this is related to the idea of using a threshold value, since any two vertices in a threshold-filtered graph are guaranteed to possess a minimum pairwise similarity.

metrics for comparing clusters can be categorized into two types: internal and external  <cit> . internal metrics are based on properties of the input data or cluster output, and are useful in determining how or why a clustering method performs as it does. it provides a data-subjective interpretation that is typically only relevant to a single experimental context. examples of internal metrics include average correlation value, figure of merit   <cit> , or diameter  <cit>  which are difficult to compare. external metrics, on the other hand, provide an objective measure of the clusters based on data not used in the clustering process, such as biological annotation data. an external metric does not depend on the experimental context that produced it. such metrics enable a comparison of the relative merits of these algorithms based on performance in a typical biological study, and can be compared regardless of the annotation source.

external metrics have been used in many previous studies of clustering performance. some comparisons use receiver operating characteristic  or precision-recall curves  <cit> . these metrics are simple to calculate, but they provide too many dimensions  for a straightforward comparison of the overall performance of the methods. while it is possible to give an area under curve  summary of the entire dataset, this is often not useful to an experimentalist. a full roc plot would cover every single cluster produced, though the majority of these would normally not be considered. many other studies  <cit>  have used the rand index  <cit> , which generates a single value to measure similarity of clustering results to a known categorization scheme such as go annotation  <cit> . however, it is subject to many sources of bias, including a high number of expected negatives typically confirmed when comparing clustering results to categorized gene annotations  <cit> . the jaccard similarity coefficient ignores true negatives in its calculation, resulting in a measure less dominated by the size of the reference data, particularly in the large number of true negatives that are often confirmed. this idea has been raised in early work using the rand index and other partition similarity measures  <cit>  and in the context of comparing clustering algorithms  <cit> . the jaccard coefficient has not been widely adopted, due in part to the historical sparseness of annotations in reference sets for comparison. with deep ontological annotation now more widely available, however, external metrics such as the jaccard coefficient provide a much more relevant, objective, and simplified basis for comparison.

a variety of tools are available to calculate functional enrichment of biological clusters  <cit> . most are not suitable for high-throughput genome-scale analysis due to interface, speed or scalability limitations.  several of the tools are meant exclusively for gene ontology terms, precluding the use of the large variety of publicly available annotation sources.

in the present study, we perform an evaluation of both combinatorial and conventional clustering analyses using an evenly distributed parameter set and biological validation performed using jaccard similarity analysis of kegg and go functional gene annotations. for this analysis we implemented a new enrichment analysis tool, specifically designed to handle genome-scale data  and any gene category annotation source provided. results of clustering algorithms were compared across all parameters and also in a manner that simulates use in practice by selection of the optima generated from each method.

methods
data
saccharomyces cerevisiae was fully sequenced in  <dig>  <cit>  and has been extensively studied and annotated since. it is therefore an ideal source for biological annotation. we compared the performance of the selected clustering techniques using the extensively studied gene expression data set from gasch et al.  <cit> . this data was created to observe genomic expression in yeast responding to two dna-damaging agents: the methylating agent methylmethane sulfonate  and ionizing radiation. the set includes  <dig> genes from seven yeast strains, collected over  <dig> yeast genome microarrays.

the microarray data for yeast gene expression across the cell cycle was obtained from http://www-genome.stanford.edu/mec <dig>  these data are normalized, background-corrected, log <dig> values of the cy5/cy <dig> fluorescence ratio measured on each microarray. we performed clustering either directly on this preprocessed data or on the correlation matrix computed from the data. in the latter case, correlations for gene pairs with five or fewer shared measurements were set to zero. the absolute values of pearson's correlation coefficients were used, except when a particular clustering approach demands otherwise.

clustering methods
in order to evaluate a wide spectrum of approaches likely to be used in practice, and to avoid the difficult task of choosing the arbitrary "best" parameter setting, we selected roughly  <dig> evenly distributed combinations of reasonable parameter settings for each implementation. to facilitate comparison, we reduced the myriad of output formats to simple cluster/gene membership lists, grouped into three sizes . for example, hierarchical clustering produces a tree of clusters, which we simply "slice" at a particular depth to determine a list of clusters.

to generate results that were used in scoring, cast, qt clust and som were run with mev  <dig>   <cit> . when running the cast method, we selected threshold values evenly distributed between  <dig>  and  <dig> . for qt clust, we selected maximum cluster diameters evenly distributed from  <dig>  to  <dig> . som requires several parameters, making it difficult to select a narrow parameterization range. we therefore restricted testing to a × a grids, choosing  <dig> values so that the numbers of clusters mirrored the desired cluster sizes. we then ran each of these sizes for both rectangular and hexagonal topologies.

click was run as implemented in expander <dig>  <cit> , and we provided homogeneity values evenly distributed from  <dig>  to  <dig> . k-means and hierarchical clustering were run using the r statistical package  <cit> , with  <dig> different cluster sizes. default values for k-means were altered so that the method iterated until convergence and so that each run was repeated ten times . for nnn, we used publicly available software  <cit>  and varied the minimum neighborhood size from 10- <dig> . a standalone software package was also used for wgcna  <cit> . we applied ten different powers  across two different module detection methods  and set the minimum module size to  <dig> . wgcna requires a significance measure for each gene, which was set to  <dig> for all genes.

our own implementations were employed for maximal clique and paraclique runs. for maximal clique, we used our highly efficient implementation of the well-known algorithm of bron and kerbosch  <cit> , executed on graphs at  <dig> threshold values evenly distributed from  <dig>  to  <dig> . for paraclique, we applied four threshold values  with five glom factors each .

for k-clique communities, we employed the publicly available cfinder software  <cit> . cfinder produced results in a matter of seconds for thresholds as high as  <dig> , but failed to halt within  <dig> hours for thresholds  <dig>  and below. to speed computation, we created our own implementation of the k-clique communities algorithm, using our maximal clique codes. we verified the software by confirming cfinder's clusters at threshold  <dig> . we ran our implementation at thresholds  <dig> ,  <dig> , and  <dig> , selecting eight values for parameter k at each threshold, and evenly distributing them between three and the maximum clique size for that threshold.

three methods  required specification of the number of clusters desired. we selected  <dig> values based on average cluster size, as computed from the total number of genes  divided by number of clusters. we chose two size intervals, 10- <dig> genes and 100- <dig> genes, and then selected ten evenly distributed cluster sizes per interval.

comparison metrics
given the prevalence of publicly available gene annotation information, we compared the computationally-derived clusters with manually-curated annotations. yeast annotation sources include gene ontology  <cit> , kegg pathways  <cit> , pdb  <cit> , prosite  <cit> , interpro  <cit>  and pfam  <cit> . for clarity and brevity, and to take advantage of their evenly distributed annotation sizes, the results presented here employ only the gene ontology and kegg pathways as sources.

we used jaccard similarity as the basis for our analysis. it is easy to calculate, and concisely compares clusters with a single metric. jaccard similarity is usually computed as the number of true positives divided by the sum of true positives, false positives, and false negatives.

 jaccardsimilarity=truepositivestruepositives+falsepositives+falsenegatives 

in the case of cluster comparisons, this equates to the number of genes that are both in the cluster and annotated, divided by the total number of genes that are either in the cluster or annotated.

 jaccardsimilaritycluster=genescluster∩genesannotationgenescluster∪genesannotation 

thus jaccard measures how well the clusters match sets of co-annotated genes, from  <dig> meaning no match to  <dig>  meaning a perfect match.

we implemented a simple parallel algorithm to search all annotation sources for the genes in each cluster. for each annotation source, we found all annotations that match at least  <dig> genes in a given cluster. we then computed the number of genes in the cluster that match the annotation , the number of genes with the annotation but not in the given cluster , and the number of genes in the cluster that did not match the annotation . we ignored genes in the cluster not found in the annotation source. finally, the highest matching jaccard score and annotation is assigned to the cluster.

we grouped jaccard computations by method and parameter settings and then separated each grouping into three cluster size bins:  <dig> or fewer genes , 11- <dig> genes , and 101- <dig> genes . when running a clustering algorithm to validate a hypothesis, one generally has an idea of the desired cluster size, which we try to account for with these size classifications. a researcher looking for small clusters is often not interested in a method or tuning that produces large clusters, and vice versa. it is important to note that the use of average cluster size to determine cluster number  does not mean that all clusters will be of average size. thus we find that these methods still generate clusters with small, medium and large sizes.

each individual cluster was scored against the entire annotation set, and the highest jaccard score match was returned for that cluster. this list of scores was then grouped by cluster size and sorted by jaccard score. the highest  <dig> jaccard scores per cluster size class were averaged to get the average top  <dig> . this process was then repeated for each parameter setting tested, amassing a list of around  <dig> at <dig> scores per size class. from each list of at <dig> scores, the largest value was selected and assigned to the best average top  <dig>  for that size class. this process is then applied to the next clustering algorithm's results. when all data has been collected, the bat <dig> scores are output to a summary table, averaged, and sorted again .

results from figure  <dig> are displayed by quartile , with missing values for maximal clique discarded.  denotes hierarchical clustering agglomeration method.

clusterings produced by each method were compared pairwise using the variation of information metric  <cit> . a custom python script was created to compute this metric, which measures the difference in information between two clusterings. minimum and maximum variation of information values were extracted for each method pair . this comparison is not applicable to methods with non-disjoint clusters such as maximal clique, so this method was excluded from the analysis.

timings
execution of each method at the parameters producing the optimal bat <dig> score for each size class was timed. all timings were generated on a intel xeon x <dig>  <dig>  ghz quad core workstation with  <dig> gb main memory, running 64-bit ubuntu linux version  <dig> . methods implemented in the mev gui reported run times, while r-based methods were timed using the system.time() function within r. stand-alone programs paraclique, maximal clique, and k-clique communities were timed using the unix time function, with the total elapsed time reported by the system being reported. when possible, data load time was excluded. however, this was not possible with several of the methods tested. similarly, output was suppressed when possible to avoid including the time to write results to disk. the cfinder program allows the specification of various parameters to possibly speed computation of the k-clique communities method such as employing an approximate algorithm and specifying a maximum time to spend for each node, however these options were not used.

RESULTS
for each clustering method and parameter, clusters of different sizes were obtained. because there is an exponential distribution of annotation category sizes, matches among small categories are more readily detectable. we binned these results into three size categories , and ranked the clusters based on jaccard similarity scores. in practice, users generally are only interested in the few highest-scoring clusters. in many biological studies, only the top  <dig> to  <dig> clusters are scrutinized. data torturing is unfortunately not uncommon in microarray studies due to the wealth of tools available, and in practice, some individuals may perform clustering until a satisfactory result is found. to simulate this practice, we therefore focused on the top five cluster scores for each size grouping , whether derived from match to go or kegg annotations, and computed their average score . we chose at <dig> as a comparison score because most of the methods produce at least five clusters of each size bin, but for some of the methods, cluster scores drop off quickly after these top five results, making a larger average meaningless. it is also significant that in practice users often adjust parameter settings to improve clusters. accordingly, for each choice of method and cluster size category, we chose the highest at <dig> values across all parameter settings  for that method-size combination. these values are reported in figure  <dig>  it should be noted that for at <dig> and bat <dig>  maximal clique, like any method that allows non-disjoint cluster membership, creates bias in this score by including results from similar clusters. bat <dig> values show that clique-based methods  perform well, when clusters are compared with available annotation, in all size classes. the cast method produced high-scoring clusters for small and large groups, and the ward method of hierarchical clustering was in the top  <dig> in each case. most variation was observed at the lower end of the bat <dig> scores, though click, along with some hierarchical variants  were also unable to identify many genes from these high-scoring annotation categories. it is interesting to note that the k-clique communities method, in contrast to the high bat <dig> values produced for all size classes, performed poorly on this metric. for each clustering algorithm, we averaged the bat <dig> scores from the three size bins, and ranked them by their average. high-averaging methods not only found good results, but they found them in all three size classifications, indicating robustness to variation in cluster size. these values provide a straightforward way to compare clustering methods irrespective of cluster size.

to determine the effect of parameter selection on each method, as well as the level of agreement of the various methods over all parameter settings, a comparison of clustering methods using the variation of information metric is presented in additional file  <dig>  minimum and maximum values are given for variation of information values over all parameters for each pair of methods. examining the main diagonal, we can see which methods are least affected by changes in input parameters. click, k-clique communities, nnn, and qt clust, for example, all exhibit a small range. looking at off-diagonal elements can show which methods are very similar or different to one another at some parameter setting. we can observe that many of the hierarchical approaches  produce the same set of clustering, indicated by a  <dig>  variation of information value, for some parameter selections. this is expected, because for larger k values, very tight clusters will not be merged regardless of the agglomeration strategy used.

consideration of execution time is also an important aspect when selecting a method for clustering large biological data sets. table  <dig> shows the execution time for each of the methods tested at the parameters found to produce the optimal bat <dig> jaccard scores. most results ranged from just under one minute to more than a minute. several algorithms such as k-means, qt clust, and k-clique communities took considerably longer. analysis of algorithm runtimes shows the hierarchical methods to be the fastest. though graph-based methods are generally expected to take longer to execute, most of these methods finished in roughly 25- <dig> seconds. exceptions were paraclique and k-clique communities, with paraclique executing in under  <dig> seconds for all size classes and k-clique communities unfinished after  <dig> days.

parameters used to produce the best jaccard score, and the associated runtime for the given method and parameters are displayed. specific parameter descriptions are listed in table  <dig>  mev times were reported by gui results. hierarchical methods use the "flashclust" package for r, which is a c++ implementation of the standard "hclust" package. hierarchical timings do not include the time for tree cutting . flashclust and wgcna packages were downloaded from the cran repository june  <dig>   <dig>  versions reported refer to the version used for runtime calculation; in some cases, previous versions were used to generate clusters for scoring. r = rectangular, h = hexagonal. *a gui-based graphical tool which is no longer maintained was used to generate clusters for jaccard scoring while the latest r implementation was using in timing, **total elapsed time reported by the system.

discussion
in our comparison of clustering results by size, we found that maximal clique and paraclique perform best for small clusters; k-clique communities and paraclique perform best for medium clusters; ward and cast are the top performing methods for large clusters . combined analysis of the clustering results across result sizes based upon the quartile of the results reveals that the performance is best for k-clique communities, maximal clique, and paraclique, shown in the first three rows of table  <dig> 

for the analysis of consensus of clustering methods for cluster matches to annotation, we found that cast, maximal clique and paraclique are best at identifying clustering results found by any other method .

this analysis of the performance of diverse clustering algorithms reveals a performance distinction between graph-based and conventional parametric methods. in our study, the best ranking methods are almost uniformly graph-based, building upon the rigorous cluster definition provided by cliques. traditional methods suffer from relatively poor performance due to their less rigorous cluster definition or their heuristic nature, which often rely on growth of clusters around individual genes in a neighborhood joining or centroid proximity. these methods do not necessarily result in high inter-correlation among all cluster members, whereas clique and other combinatorial algorithms typically require this by definition.

although users perform clustering to obtain a decomposition of major co-variation in expression data, conventional clustering algorithms frequently focus on details rather than the bigger picture, by starting from a single gene instead of the full genome. thus, these methods, such as hierarchical and k-means, lack a global consideration of the data set. clusters are built incrementally at each step, beginning with a single gene's neighborhood, not a highly correlated geneset. clusters will therefore tend to converge to a local optimum. this is why repeated randomizations, as is frequently done with k-means, can typically improve results simply by selecting genes with larger neighborhoods. neural network approaches like som suffer from a similar problem, as training takes place with incomplete views of the full data. even qt clust suffers from these issues, but to some extent overcomes them through additional computation. clusters are built incrementally for each gene, but only the highest scoring cluster is partitioned from the rest of the data, at which time its individual genes are partitioned out. the process continues iteratively until no genes remain. thus, qt clust avoids bias introduced by arbitrarily selecting genes, but still has the same problem of incremental local growth of clusters.

three of the combinatorial approaches, cast, click and wgcna, represent data as graphs, but compute only heuristic solutions to the underlying graph-theoretic metrics. cast approximates a solution to cluster editing. click approximates a minimum weight cut. wgcna represents data as a weighted graph, but applies hierarchical clustering to compute its final set of clusters.

nnn computes exact solutions to somewhat arbitrary problem parameters. the poor performance that we observe for it on this data may be because its objectives differ from those of other clustering algorithms. nnn connects genes based on relative correlation among gene pairs. two genes g and g' are considered related if their correlation is high compared to all other correlations involving g and g', as opposed to all correlations for all genes. thus, nnn may find clusters that have less pronounced relationships among all cluster members. these clusters may not be present in the high-level go annotations, but may have biological relevance through more distant and indirect functional relationships.

variation of information results  indicate that while some methods have a relatively high agreement between individual clustering runs at various parameter settings, there does not seem to be many commonalities between these methods. while some methods such as k-clique communities routinely appear in the list of top-scoring methods, others such as click were not able to identify clusters with high-scoring matches to annotation categories. this tells us that consistency over parameter settings is not a good indicator of performance, since many high scoring methods exhibited a wide range of variation over parameter settings. these results further motivate our approach of selecting many common and evenly-spaced parameter settings for our tests.

our work suggests that graph-based algorithms provide superior reliability and a highly promising approach to transcriptomic data clustering. most of these methods attempt to find and exploit cliques), with the exception of click which uses minimum cut. it has been suggested that clique-based approaches possess the best potential for identifying sets of interacting genes, due to the highly inter-correlated nature of the clusters produced  <cit> . the results reported here appear to corroborate that, given that four of the six best performing clustering methods in table  <dig> are based upon finding cliques. it should be noted that we applied the algorithms on a single data set for which both deep experimental data and strong biological ground truth are available, and that results may differ when a different data set is used. it is challenging, however, to conceive of a correlation matrix that would be fundamentally biased toward one type of algorithm, especially given that we provided the selection of parameters over a large range of values.

graph-based problems relevant to clustering are often thought to be difficult to solve  because globally optimal solutions are required. this can explain both the effectiveness of exact solutions and also why so few algorithms rely on exact solutions. our results suggest that exact solutions are truly valuable in practice, and that continued research into computing exact solutions to np-hard problems is probably worthwhile.

though combinatorial approaches to clustering may perform better, implementation challenges have limited widespread adoption to date. maximal clique's stand-alone utility is rather limited. even with the best current implementations, it can take a staggering amount of time to run to completion. it tends to overwhelm the user by returning an exhaustive collection of vast numbers of overlapping clusters, even for a small genome such as yeast, which is illustrated in figure  <dig>  maximal clique also failed to produce clusters for scoring in the large size class due to its very stringent cluster membership requirement. paraclique and k-clique communities are appealing alternatives due to the more manageable nature of their results. they employ a form of soft thresholding, which helps to ameliorate the effects of noise and generate nicely-enriched clusters without excessive overlap. from a sea of tangled correlations, they produce dense subgraphs that represent sets of genes with highly significant, but not necessarily perfect, pair-wise correlations. paraclique relies on maximum clique, and thus operates in a top-down fashion. it generates impressive results through the use of its rigorous cluster definition followed by more lenient expansion, leading to very high average intra-cluster correlations. by avoiding the enumeration problems of maximal clique, it is also highly scalable. moreover, through its complementary duality with vertex cover, it is amenable to advances in fixed-parameter tractability  <cit> . paraclique's main drawback is its use of multiple parameters, making algorithm tuning more challenging. in contrast, k-clique communities relies on maximal clique and so operates in a bottom-up manner. it also generates impressive results, but its dependence on maximal clique severely restricts its scalability. even for a small genome such as that of s. cerevisiae, and even for graphs in which there are no large maximal cliques, we could not run k-clique communities to completion without resorting to our own maximal clique implementation. a faster version of community's cfinder exists , but it achieves speed only by setting timeout values for maximal clique computations, thereby creating an approximation method rather than an optimization method. thus, given the exponential growth rate of maximal cliques, exact algorithms that rely on such cliques are hobbled by memory limitations on larger genomes and denser correlation graphs. we are rather optimistic, however, that approaches exploiting high performance architectures  <cit>  may have the potential to change this picture. the fourth clique-based approach, this time via cluster editing, is cast. although its execution is relatively fast, its heuristic nature ensures only mediocre results and difficult tuning. cast is simply not an optimization technique. it seems able to detect pieces of important clusters , but it is often not comprehensive. given the extreme difficulty of finding exact solutions to cluster editing  <cit> , we think an optimization analog of cast is unlikely to be feasible in the foreseeable future.

examination of algorithm runtimes put hierarchical methods at the top. however, the performance gain from using graph-based methods appears to come at a runtime cost on the order of seconds. this is particularly true for methods such as paraclique, cast, nnn, and even maximal clique. with paraclique and maximal clique jaccard scores falling in the first quartile for all size classes, and cast in the first quartile for  <dig> of the  <dig> size classes, this should be considered further evidence for the utility and applicability of graph-based methods to the clustering of microarray data.

CONCLUSIONS
using jaccard similarity to compare clustering results to gene annotation categories, we performed a comparative analysis of conventional and more recent graph-based methods for gene co-expression analyses using a well-studied biological data set. jaccard similarity provides a simple and objective metric for comparison that is able to distinguish between entire classes of clustering methods without the biases associated with the rand index. our analysis revealed that the best performing algorithms were graph based. methods such as paraclique provide an effective means for combining mathematical precision, biological fidelity and runtime efficiency. further development of these sorts of algorithms and of user-friendly interfaces is warranted to facilitate wide-spread application of these techniques among experimentalists.

competing interests
the authors declare that they have no competing interests.

authors' contributions
jjj, jde and yz produced and collected clusters using the many clustering algorithms. jjj wrote the software to calculate jaccard scores and provided the integrative analysis. adp assisted with analysis, timings and manuscript preparation. mb, ams, and bhv provided valuable direction for refinement of the results. ejc and mal conceived of the study and participated in its design, coordination and manuscript preparation. all authors read and approved the final manuscript.

supplementary material
additional file 1
clusterings compared using the variation of information metric. results of a pairwise comparison using the variation of information metric is shown. each entry consists of a minimum and maximum variation of information value of clusters for each pair of methods and selection of parameters. high values indicate very different cluster structures while low values indicate similarity. values on the main diagonal indicate within-method consistency, with a small range indicating that parameters have little effect on clustering results.

click here for file

 acknowledgements
this article has been published as part of bmc bioinformatics volume  <dig> supplement  <dig>  2012: "selected articles from the 7th international symposium on bioinformatics research and applications ". the full contents of the supplement are available online at http://www.biomedcentral.com/bmcbioinformatics/supplements/13/s <dig> 

this research was supported in part by the national institutes of health under grants r01-mh- <dig>  u01-aa- <dig> and r01-aa- <dig>  by the department of energy under the low dose radiation research program of the office of biological and environmental research erkp <dig> and the epscor laboratory partnership program, and by the national science foundation under grant eps- <dig>  the research leading to these results has received funding from the european community's seventh framework programme  under grant agreement number  <dig>  this research used resources of the national energy research scientific computing center, which is supported by the office of science of the u.s. department of energy under contract no. de-ac02-05ch <dig>  illes farkas provided us with useful information about the cfinder software. khairul kabir and rajib nath helped generate sample results.
