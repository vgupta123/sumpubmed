BACKGROUND
next generation sequencing technologies are generating massive sequence data
 <cit> , and different platforms can introduce varied level of sequence reads error. among them, the illumina platform is the most widely used for genome sequencing with the least error rate per base. however, due to the nature of the method, it still presents a considerable amount of errors that has its specific errors pattern
 <cit> . the device performs sequencing by dna synthesis on clusters of identical dna molecules simultaneously. when elongation of some dna molecules is stopped accidentally, it creates disturbance of the cluster’s fluorescent signal, resulting sequencing errors. such errors accumulate during the process of sequencing, and cause reads quality decreasing while the length grows. besides, deficiency on sequencing chips and the existence of air bubbles on chip surface can cause failure on reads from a whole tile. to get reliable result in downstream analysis, it is necessary to remove low quality reads avoiding mismatches in read mapping, and false paths during genome assembly.

currently there are several reads quality control  software tools . however, all these software tools lack of function versatility or run-time efficiency. for example, piqa and fastqc only create reports on reads quality, but provide no tool for reads filtration
 <cit> . solexaqa and bigpre provide only read trimming utility
 <cit> . furthermore, many of these software tools are implemented using perl language
 <cit> , which as a dynamic-typed script language, provides ease on developing mini programs, but causes severe loss on run-time performance
 <cit> . therefore, a high performance sequence reads qc toolkit is needed for a faster assessment and versatile functionality.

implementation
the htqc toolkit consists of six programs that can perform reads quality assessment and filtration. to improve run-time performance, the time-consuming programs are implemented using c++. the fastq format is used for sequence data input and output, and the qc report is generated as tab-separated plain-text file
 <cit> . to create graphical charts of qc report, a perl script is included. the gnu glib is used for base utilities such as command-line parser, portable support for threads and asynchronous queues. all programs of htqc toolkit are capable of single-end or paired-end sequencing experiments, 33-based or 64-based quality score encodings and fastq sequence identifier format from different version of casava tools 
 <cit> .

the quality control pipeline begins with a quality assessment on raw reads. program ht_stat generates qc report from raw sequence reads in different aspects. on each position of the sequence reads, a heat map and a box chart are presented with quality distribution . the stacked bar chart that represents the base composition on each position is shown at the same time . the cycle-specific errors and the rapid-falling quality on reads tail can be viewed on these three charts. to find tile-specific problems like high error rate or low data production, a stacked bar chart shows the number of reads in different quality ranges using different color, each tile in one bar . the other charts that show the distribution of reads with varied length and reads with varied quality can provide an overview of sequencing quality . for paired-end reads quality assessment, the ht_stat program is used to create separate charts for each end, and to calculate the correlation between reads quality of two ends . all these results generated by ht_stat program are written to a series of tab-delimited plain-text files, which can be visualized using ht_stat_draw.pl, or any spreadsheet software like microsoft excel or libreoffice calc.

after the assessment of sequence reads quality is obtained, low quality reads should be removed. the htqc tool kit provides four different programs that include ht_tile_filter, ht_trim, ht_qual_filter and ht_length_filter, to perform reads filtration. the ht_tile_filter is designed to remove reads from problematic tiles that may not be reliable due to sequencing chip quality; the ht_trim cuts low quality bases at the beginning or the end of the reads until the quality score reaches a given threshold; the ht_qual_filter remove reads with low quality and the ht_length_filter remove short reads. when only one end of the paired-end reads is of acceptable quality, it is stored in a separate file. the cutoff value of these programs, such as the thresholds on the minimum reads quality or minimum read length are user defined.

RESULTS
workflow demonstration
to demonstrate the function of htqc, a paired-end sequence data of human gut metagenome was used as an example. to reduce the time cost, one tenth from a total of  <dig> , <dig> paired-end reads were randomly picked. the reads length was 120bp. the quality assessment was performed using ht_stat, which shows the reads quality in a series of charts that were described above in implementation. when quality assessment was done by base position, there was a gradual decrease of reads quality towards the 3’-end  that can be observed in figure
1a and
1b. the tail trimming would be routinely applied to cut the low quality reads using the program ht_trim. in figure
1c, there was at least 10% of reads that have an invalid nucleotide sequence represented by contiguous ns. the bad reads that contained these ns can be filtered with the program ht_length_filter or ht_qual_filter. when the quality assessment was done by tiles, we observed tiles  <dig>   <dig>   <dig>   <dig>   <dig>   <dig> produced reads with very low quality  that can be removed using ht_tile_filter. for the quality assessment of any paired-end reads, if the quality of read  <dig> was worse than read  <dig>  such quality imbalance can be picked up by ht_stat .

program run-time efficiency
to compare the time cost of htqc with existing tools, quality assessment on the above dataset was performed using ht_stat, solexaqa version  <dig> , fastqc version  <dig> . <dig> and bigpre version  <dig> . <dig>  the benchmark was performed using a dell poweredge server with two amd opteron  <dig> cpus . the server’s operation system was fedora linux  <dig>  for solexaqa, it by default only uses a part of the input sequences from each tile, thus we input the size of the test dataset  as the tile sample size to ensure all reads were used. for bigpre, due to its inability to parse the newest version of header format produced by casava  <dig> , or to work on quality records with “@” character, we modified its source code to allow it work properly with the test dataset. the solexaqa and the modified bigpre programs were executed using perl version  <dig> . <dig> contained within the fedora linux system. the c++ source code of ht_stat was compiled using gnu gcc version  <dig> . <dig> with optimization flag “-o2”. for the performance test of multiple threads, benchmarks for ht_stat and fastqc were carried out in two groups: one benchmark using  <dig> worker thread, the other benchmark using  <dig> worker threads. therefore, we have six benchmarks in total: one each for solexaqa and bigpre, two each for ht_stat and fastqc. all benchmarks were run  <dig> times repeatedly to overcome any random disturbance of the computer system, and the amount of real time , system time  and user time  were recorded using the time command that is a part of the linux base system. when compared with the other two perl programs, both benchmarks of ht_stat used one order of magnitude fewer amount of user time, which showed the advantage of c++ language. the parallel comparison with fastqc, a java program, ht_stat was about three times faster in both single thread and three threads test . however, the higher amount of system time in our program shows the cost of the use of threads, which indicates our parallel processing model needs further improvements . when comparing the two benchmarks of ht_stat, the time cost of the three-threaded benchmark is only one third of the one-threaded benchmark, which indicates the efficiency of multiple threads . furthermore, there is no significant difference in the amount of user time and system time between 1-thread and 3-thread benchmarks of ht_stat , which indicates the use of more threads does not produce additional system cost.

CONCLUSIONS
the htqc tool kit provides convenient utilities for illumina sequencing qc. it can process sequencing data faster than the existing tools, and generates quality assessment report both in plain-text and graphical representation, which can help in making decisions about further reads filtration. the htqc package also provides four programs that can perform reads filtration using different methods. unlike previous tools in which only single filtration method is allowed, user can choose the method they prefer to remove the low quality reads, and combine several filtration methods in any order.

availability and requirements
project name: htqc

project home page:
https://sourceforge.net/projects/htqc

operation system: linux, potentially any posix compliant system.

other requirements: gnu glib
http://ftp.gnome.org/pub/gnome/sources/glib, pkg-config
http://www.freedesktop.org/wiki/software/pkg-config, cmake
http://www.cmake.org, perl
http://www.perl.org, gnuplot
http://gnuplot.info

programming languages: c++, perl

license: gnu gpl version  <dig> or later

abbreviation
qc: quality control.

competing interests
the authors declare that they have no competing interests.

authors’ contributions
xy implemented the program; fl, xx, jz and jw provided test data; blz, dl, fqz and xy wrote the manuscript. all authors read and approved the final manuscript.
