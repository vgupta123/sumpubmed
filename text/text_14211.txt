BACKGROUND
george box  <cit>  once remarked that,

"all models are wrong, but some are useful."

this statement bears much relevance to biological sequence alignment, where there is no guarantee that the alignment model will accurately represent the evolutionary  processes which separated the two sequences. all that is certain is that exhaustive dynamic programming  algorithms  will yield the optimally scoring path in terms of the given model. heuristics for sequence comparison  generate alignments which are valid paths through the underlying alignment model, but are not guaranteed to be optimal. alignments generated by these heuristics can be calculated much more rapidly, and often closely match alignments which would be generated by exhaustive methods. furthermore, many problems in the context of genome analysis consist simply of alignment of gene products  back onto the gene from which they were produced, and consequently do not require very sensitive alignment. hence the aim here is not to attempt to develop models which are correct, but to facilitate development of models which are more useful in the context of large scale analyses.

transformation between a finite state automata describing an alignment model and the recurrence relations used in dp is a powerful technique  <cit>  as it allows modification of the alignment algorithm by direct manipulation of the alignment model. the dynamite compiler  <cit>  allows automated implementation of alignment algorithms from a description of the alignment model. this allows development of complex models which can be used to generate accurate alignments. however, calculation of alignments using these models always requires quadratic time, which is prohibitively slow for many large scale applications. this method can be applied to any alignment problem which can be represented by a regular grammar . this includes the simple three state model required for affine gaps in the smith-waterman-gotoh algorithm  <cit> , but also more complex models such as that used by est_genome  <cit> , where splice site prediction is integrated into the dp, allowing alignments to include introns. other alignment models which may be expressed by a regular grammar include those allowing non-equivalenced regions such as the abc model  <cit>  for improved modelling of divergent loops regions in protein alignments, and dna block aligner  <cit>  which finds co-linear conserved blocks in the alignment of genomic sequences. this framework also allows models such as that used by pairwise  <cit>  where the sequences are translated during alignment allowing for frameshifts, and genewise  <cit>  which integrates translated alignments with modelling of introns for alignment of proteins against genomic dna.

the availability of vast amounts of sequence data has generated a need for faster alignment algorithms  <cit> . many of these approaches use fast algorithms to identify closely matching words which seed un-gapped alignments that are subsequently joined to form the final gapped alignment. for example, blast  <cit> , fasta  <cit> , and sim <dig>  <cit>  all operate by first finding matching words before building alignments. such word finding can be done by a multitude of techniques, such as finite state machines used in blast  <cit> , table-lookup used in ssaha  <cit> , or by suffix arrays as used in quasar  <cit> . novel methods for word-based seeding of these alignments are not presented here, but rather a general system of joining these seeds to produce gapped alignments.

the alignment program fasta  <cit> , generates alignments from sets of seeds by performing dp confined to a diagonal band surrounding the initial matches  <cit> . in contrast, when building alignments, gapped blast  <cit>  permits gapped extension which allows the dp to be applied to an arbitrary high-scoring region surrounding the hsp seeds. such heuristics allow very fast sequence alignment, but it is difficult to apply to more complex models. furthermore, features such as introns cannot easily be incorporated into the resulting alignments without necessitating a large amount of dp to ensure that both very short exons and large introns can be included in alignments.

the aim here is to combine the strengths of gapped blast and dynamite, in a system which allows automated generation of heuristics in terms of the underlying model. this allows the development of heuristics for complex models such as those used in genewise.

firstly, we describe bounded sparse dynamic programming , a novel heuristic for sequence alignment, then we describe the system for automated implementation of the complex alignment algorithms required. we present proof of principle results, but this paper is primarily focussed on developing a framework for the general case.

implementation
the basic strategy of seeding alignments used here is the same as for blast, in that alignments seeds are generated, and then extended to form high-scoring segment pairs , which are then joined together to form the alignments. the alignments are seeded using an aho and corasick  <cit>  type finite state machine  built using the word neighbourhood of the query sequence. this generates the seeds which are extended to form the hsps. for large scale analyses, the fsm is multiplexed using word neighbourhoods from multiple sequences. this allows analysis of multiple queries during a single pass of a genomic database, in a manner similar to that used in mpblast  <cit> .

however the methods for seeding hsps are independent from those used for building the alignments, and this paper only deals with algorithms involved in the generation of gapped alignments from sets of hsps, and not in the calculation of the hsps themselves.

the following strategies are employed to enable alignments to be built efficiently from sets of hsps:

• to connect the underlying alignment model to the heuristics, a portal describes a set of states in the model which correspond to a set of hsps, a span refers to a looping state for large alignment features such as introns, and a sar  describes a rectangular region on an hsp to which dp is applied.

• to avoid dp in every sar, upper bounds are generated for the best alignment score for each sar, and bsdp  exploits these bounds to yield alignments in an efficient manner.

• to perform various types of dp in these sars, the required models are generated automati cally, including c code to produce an efficient viterbi implementation for each model.

bounded sparse dynamic programming
dynamic programming  requires quadratic time, and hence is the most computationally expensive part of building an alignment. for pairs of sequences more than a few kilobases long, dp becomes prohibitively slow. the approach used here is similar to sparse dynamic programming  <cit> , and the fragment chaining approaches used in the program sim <dig>  <cit> , in that dp is applied to rectangular regions surrounding alignment seeds. however, there are two major differences in our approach. firstly, dp is only applied to two small discrete regions on each hsp, as it is assumed that most of the hsp itself should appear in the alignment. these sub-alignments improve the quality of the overall alignments, and they allow complex alignment models, and large gaps such as introns to be integrated into a sparse dp framework. secondly, as it would take too long to apply dp to every sub-alignment region , upper bounds are calculated for the dp scores for each of these sars. this allows the sub-alignment dp to be avoided in cases where it joins hsps which cannot feature in the final alignment, so that alignments can still be generated very rapidly even when large numbers of hsps and sars are involved.

before the bsdp can be performed, a single point on each hsp is selected which will feature in any alignment generated using that hsp. this point corresponds to a pair of equivalenced symbols which must feature in any alignment to include that hsp. a point is chosen where half the hsp score is generated by equivalenced symbols on either side of it, as this is likely to be in the highest quality portion of the hsp. as shown in the example in figure  <dig>  this strategy is particularly beneficial where one end of the hsp has a much lower quality than the other.

the five types of region used for sub-alignments are classified in figure  <dig>  each of these require a slightly different alignment algorithm. the alignment path must meet corners of the sars that contain an hsp, so that the sub-alignments can be integrated with the hsps to produce the final alignment. this approach has been primarily designed for local models, but bsdp may also be used for global and semi-global models, in which case constraints are added such that both the terminal regions  and the resulting sub-alignments must contain the relevant sequence ends. in the case of c and d, the two hsps and their sars are separated by a span, allowing large gaps or introns in the alignment. in these cases dp must be applied to the sar before the span, and the end state scores must be integrated in an intermediate matrix before being provided as start state scores for the dp in the sar after the span.

regions for the sub-alignments are selected within the area between the centre points of the two hsps to be joined, or in the case of terminal hsps, between the hsp and the ends of the sequences. in addition, the positions of the sars must be constrained to limit their size, and so that the hsps correctly intersect with the corners of the sar. in the case of overlapping hsps, where there is a choice of positions for placement of the sar, the position is chosen such that the highest scoring parts of the hsps are outside the sars.

once the sars have been selected, an upper bound is placed on the score for each sub-alignment. the calculation of these bounds is described in a later section describing automation of this method. the bsdp approach can then utilise these upper bounds to avoid application of dp in some sars, as demonstrated by the example in figure  <dig>  in the case of a real alignment, a much greater number of hsps will be involved, so the amount of dp avoided will be larger.

the bsdp is mediated through a set of priority queues, one of which is associated with each hsp, and will contain an entry for each partial alignment that ends at the hsp. the key for these priority queues is the highest score for any partial alignment ending in that hsp. additionally, there is one global priority queue containing the highest scores from each of the other priority queues. the upper bound scores are confirmed by dp in the sars in the current highest scoring putative alignment path. the highest scoring path will change as the scores are updated during this process. dp is applied to sars in this way until the highest scoring path does not contain any bound scores, and then the alignment may be extracted. upper bounds dictate that there can be no better alignment using these hsps.

this algorithm is similar to a* search, , and retains the admissibility property of a* search, such that the result of the bsdp computation is guaranteed to be the same as if dp had been performed on every candidate sar prior to calculation of the alignment. this is because no alignment can be extracted until all the alternative sub-alignments  have been eliminated.

suboptimal alignments
the bsdp alignment process can be iterated to generate sub-optimal alignments similar to those generated by the waterman-eggert algorithm  <cit> , with only minimal recalculation of the partial alignments in the sars. each hsp may only appear in a single alignment, but further constraints are required to prevent overlapping alignments arising from overlapping sars. the likelihood of this is occurring is greatly increased during translated alignments when hsps in different reading frames may overlap each other.

after the first alignment has been reported, the scores for any sars which have already been confirmed by dp, but which are not yet included in a reported alignment, are then considered as an upper bound. sars are disallowed before recalculation when the region between the centre of the hsp and its sars overlaps with a previously reported hsp, in which case, the sars are disallowed. otherwise the dp is recomputed for sars which contain part of an alignment which has been reported since the dp for the sar was last calculated.

automated model generation
as illustrated in the previous section, bsdp becomes quite complex and requires a large number of dp algorithms for computation of the alignment through the sars. we have build a system to facilitate implementation of these models and the integration of the sub-alignments which they produce. to allow generalisation of the bsdp, everything must be defined in terms of the underlying alignment models. the alignment models are described as finite state machines, consisting of states and transitions, similar to those used in dynamite  <cit> .

briefly, to convert these models into dp implementations, each state must correspond to a score in each cell of the dp matrix, and the scores for each cell are calculated by taking the maximum of the score from transitions arriving at each cell. in addition, a topological sort is required to satisfy dependency ordering for silent states.

however, in addition to automated generation of code from alignment models, the generation of the models required for dp in the sars is also automated, as described below.

building simple models
building the heuristic model
to enable dp in the sars for the bsdp, a heuristic model is generated from the original alignment model. this model is not used directly for calculation of alignments, but a derived model is generated corresponding to each transition in the heuristic model. each of these derived models correspond to a type of sar used in the bsdp.

the model is first annotated, labelling certain states as either portal states or span states. a portal defines a group of states which can share a set of hsps ; these are the match states. a span is a state which has sequence independent looping transitions .

the heuristic model is build using states corresponding to each portal and span state, with transitions between these states in cases where there is a valid path between the corresponding states in the original model. an example model is shown in figure  <dig> for alignment of ests to genomic dna. in this example, there is a portal which corresponds to the match forward and match reverse states, and the intron forward and intron reverse states are span states.

building derived models
derived models are produced for the dp in sars automatically from each transition in the heuristic model. the source and destination states from each transition in the heuristic model become the start and end states in each derived model. all reachable states and transitions from these states in the original model are recursively copied to the derived model. an example of this process is shown in figure  <dig>  the relationships between the states and transitions in the derived model and the original model are tracked to allow conversion of the partial alignments from the derived models back to complete alignment in the original model. terminal models  are generated between portal states and a start or end state. join models  are generated between portal states, including from a portal state to itself. span models  are generated from a portal state to a span state, and vice versa. these allow incorporation of a large feature such as an intron into an alignment. the span models require a special end state in the model at the start of the span, and a special start start in the model at the end of a span, so that scores can be transferred from one dp matrix to the other via an intermediary score matrix.

for some cases, such as between the match forward and match reverse states, shown in figure  <dig>  there is no possible path, and no corresponding transition in the heuristic model, in which case, a derived model is not produced.

ten different derived models are generated from the model shown for cdna to genomic alignment in figure  <dig>  because there are two portal states and two span states in this model, and therefore, a derived model is generated for each of the five cases in figure  <dig> for both the forward and reversed genes.

building models for calculation of upper bounds
for each derived model, an additional model is created which is used for the pre-calculation of upper bounds for all possible sizes of sars. for each transition in the model which has a position dependent score associated with it, the upper bound is also supplied. for example, in a match transition, the upper bound is the maximum value from the substitution matrix. a special model is created using these transition upper bounds, instead of the normal sequence-dependent transition weights. as this removes the sequence-dependent components of the algorithm, it allows pre-calculation of the upper bound for alignment score of any sequences up to the maximum permitted size of sars. these bounds are then stored in a table for retrieval during the bsdp.

RESULTS
the model used in figure  <dig> was used with this system in the program exonerate for rapid comparison of cdnas and genomic dna. this model was used to compare a test set of genomic sequences to mrnas extracted according to the ensembl annotations. exonerate was compared to sim <dig>  <cit> , another heuristic for comparing cdnas to genomic dna, and est_genome  <cit> , which is implements the exhaustive dp for essentially the same underlying model. as can be seen from the results of this comparison are shown in table  <dig>  similar results are produced by this method, but in much less time.

this system is used for alignment of ests within the ensembl gene-building pipeline  <cit> , and a prototype implementation of this system has been used in comparison mouse and human sequences  <cit> . in this analysis,  <dig> million raw shotgun mouse reads were aligned as part of the comparative analysis of chromosome  <dig> 

another example is the alignment of the collagen alpha  <dig> precursor to a region of chromosome  <dig> containing the corresponding gene. this is a large gene, containing  <dig> exons over about a  <dig> kb region of the genome. using genewise, the alignnment required  <dig> seconds  using exonerate to perform full dp alignment required  <dig> seconds , and using exonerate with the heuristic bsdp approach required only  <dig> seconds, with all three methods generating identical alignments.

CONCLUSIONS
this approach represents an advance from previous methods for automatic implementation of sequence alignment algorithms  <cit> , in that it is not just the generation of code from the models which is automated, but also the generation of many of the models themselves.

this has allowed development of heuristics with sub-quadratic running times. this makes their application practical to a much larger set of problems, while retaining the much of the simplicity of their implementation.

we recognise that this approach is limited to the subset of sequence comparison problems which can be represented by a regular grammar. for example, it is not possible to use this system to model stochastic context free grammars as used in some types of rna secondary structure such as pseudo-knots  <cit> . this approach is also unsuitable for the types of dp algorithms used for determining optimal segmentation in gene finding algorithms  <cit> , however for these types of problems running time of the algorithm is not an issue.

this framework has already been used for many different alignment models ranging from simple models such as smith-waterman-gotoh, to more complex models such as those for protein to genome alignment as used by genewise  <cit> . it is also well suited to problems requiring comparison of very long sequences, and we are currently extending this system to accommodate syntenic pairwise comparisons of genomic sequences of the type tackled by mummer  <cit> .

although this method is useful in many cases, for some types of distantly related sequences, the method can breakdown. for example, when long regions of the correct alignment contain many gaps with intervening sequences too short to be an alignment seed, the alignment cannot be extended beyond the boundary of the sar, and the correct alignment may be missed. these cases can be avoided by increasing the size of the sars, but this results in higher bound scores, so dp become necessary in more of the sars. such gap rich alignment are the type where the gapped hsp extension used by gapped blast excels, however such gapped extension necessitates dp surrounding all hsps, which becomes time consuming when allowing both short exons and long introns during alignments of cdnas or proteins to genomic sequences.

as this system separates the development of the underlying alignment model from the heuristics which are built on top of them, we expect that this framework will prove useful for evaluation of the quality of the heuristics, as comparison between the alignments from the two techniques can be automated, and training may be performed to select optimal parameter sets.

availability
the implementation of the system described here is called c <dig> , and is implemented in c programming language. it is available as part of the exonerate sequence alignment package available from , and in the exonerate module of the ensembl cvs repository from . it is built using the glib portabilility library available from  both exonerate and glib are available under the gnu lesser general public license. the code has been tested extensively on linux and osf1/alpha but has been written to be portable to many unix systems.

code generation for the dp is performed to exploit compile time optimisations such as loop un- rolling and and efficient handling of edge conditions in the viterbi matrix, which is particularly beneficial for the small dp calculations required by sars. this generated code is typically about five times faster than using a generic viterbi implementation, but produces about a million lines of code for the current set of models used by exonerate, and hence compilation takes longer.

