BACKGROUND
expressed sequence tags  are short sub-sequences of transcribed genes and have been extensively used for gene discovery  <cit>  and digital expression analysis  <cit> . recent advances in next-generation sequencing  technologies allow sequencing of large-scale ests in an efficient and cost-effective way. one of these technologies, roche- <dig> massive parallel pyrosequencing platform  <cit> , has been widely used to sequence transcriptomes of various non-model organisms  <cit>  due to its relatively long reads generated  that greatly facilitates de novo assembly.

several de novo assembly programs such as cap <dig>  <cit> , mira  <cit> , tglcl  <cit> , phrap  <cit> , and newbler  have been developed to assemble est sequence reads into longer contigs. however, most of these programs are primarily developed for genome sequence assembly, even their transcriptome assembly modes have not been fully optimized and two types of assembly errors are frequently observed: 1) type i error-ests derived from alternatively spliced transcripts or paralogs are incorrectly assembled into one transcript; 2) type ii error-ests derived from the same transcript fail to be assembled together. we have investigated these two types of errors in the dana-farber cancer institute  plant gene index  <cit> , which was created by assembling sanger ests into unigenes using tgicl  <cit> , as well as several other est databases. surprisingly, we found that a large number of unigenes with significant overlap  and high sequence identity  were not assembled together, such as tc <dig> and tc <dig> in the dfci tomato gene index , and ests with significant sequence differences were assembled together, e.g., aw <dig> and tc <dig> , and aw <dig> and tc <dig>  in the dfci tomato gene index. the assembly error rates are also high for roche- <dig> ests as we have constantly observed that large portion of roche- <dig> unigenes contain assembly errors after reanalyzing several published datasets. recently kumar and blaxter  <cit>  recommended an assembly strategy that involves combining differently optimal assemblies from multiple programs. this strategy can generate better assemblies by taking advantage of advantages of different assembly programs; however it still contains significant number of mis-assemblies. to date, no program is available that can efficiently identify and correct the two types of errors described above.

in this paper we describe iassembler, a package that can efficiently assemble large-scale est datasets and automatically identify and correct assembly errors. we demonstrate the utility and performance of this program by performing assemblies on different est datasets with different sets of parameters.

implementation
iassembler is implemented in perl and can be executed under either 32-bit or 64-bit linux systems with bioperl  <cit>  installed. although mira, cap <dig> and ncbi megablast  <cit>  programs are required by iassembler, they are already integrated into the iassembler package for user's convenience. thus iassembler is easy to install and simple to use.

architecture of iassembler
iassembler employs an iterative assembly strategy and automated assembly error corrections to deliver highly accurate de novo assemblies of est sequences. as shown in figure  <dig>  iassembler contains seven major functional modules: general controller, mira assembler, cap <dig> assembler, megablast assembler, type i error corrector, type ii error corrector, and unigene base corrector. these seven modules can be grouped into three categories: controller , assembler , and error corrector . the general controller module controls the overall running process of iassembler. it ensures correct parameters, which are defined by users, are passed to each assembler and error corrector, and processes output files from preceding modules to ensure the file formats are compatible with current modules. it also controls iterations of assemblies and error corrections and ensures iterations stop if no new assembly errors are detected . mira and cap <dig> assemblers are perl scripts wrapping standalone programs mira and cap <dig>  respectively. they are used to generate initial assemblies of est sequences. megablast assembler uses alignment information of two sequences generated by megablast program to assemble them into one contig. this assembler is used to assemble sequences from same transcripts that fail to be assembled by either mira or cap <dig>  error correctors in iassembler include type i and ii assembly error correctors and the unigene base corrector. they contain functions to identify and correct all possible assembly errors left by mira and cap <dig> . it is worth noting that the megablast assembler and type ii error corrector are integrated modules as the identified type ii errors are immediately corrected by the megablast assembler.

error corrections in iassembler
the unique feature of iassembler is its ability to detect and automatically correct all possible assembly errors. following initial assemblies by mira and cap <dig>  all-versus-all pairwise sequence alignments of resulting unigenes are performed using the ncbi megablast program. unigenes whose overlapped sequence length and identity, and overhang length meet user-defined cutoffs are identified as type ii assembly errors, i.e., sequences from same transcripts fail to be assembled together. the megablast assembler then utilizes the pairwise sequence alignment information to join the unigenes into new contigs. next, the type i error corrector module maps individual est members to their corresponding contigs using megablast. ests that have sequence similarities to their corresponding contigs less than and/or overhang lengths larger than the corresponding user-defined cutoffs are identified as type i assembly errors, i.e., two different transcripts are incorrectly assembled together. these misassembled ests are then extracted by the type i error corrector and together with unigenes derived from the current round of assembly and error correction, are used as the input sequences in the next round of assembly and error correction .

the iterative assembly strategy employed by iassembler can result in loss of accuracy in final unigene base calling since later assemblies are performed on unigenes generated from previous assemblies, instead of ests; thus during assemblies by cap <dig> and megablast assemblers, the information of depth of coverage by individual est members at each unigene position will be lost and thus not used in base calling of assembled sequences. this will cause significant number of wrongly called bases in unigenes. iassembler provides a unigene base error correction module  which reassigns each individual base sequence of unigenes according to the sam  <cit>  output file  which contains detailed alignment information of individual ests to their corresponding unigenes. the most frequent base covering a specific position will be assigned to that position of the unigene.

following corrections of type i and ii assembly and unigene base calling errors, iassembler reevaluates the resulting unigenes and identifies and corrects new assembly and base calling errors. the error identification and correction steps will be iterated until no new errors can be identified or corrected.

it is worth noting that not all identified assembly errors can be corrected by iassembler. a simple such example is illustrated in figure  <dig>  suppose that unigene  <dig> is assembled from reads c, d and e and sequence identities between reads a, b and unigene  <dig> meet the user-defined cutoff, then during type ii error correction step, these three sequences  can be assemble into one unigene,  <dig>  by the megablast assembler module and each base of unigene  <dig> is called based on the most frequent base covered by the five reads, a, b, c, d and e. following assembly, iassembler will perform type i assembly error detection using its type i error corrector module by aligning reads a, b and unigene  <dig> to unigene  <dig>  respectively. now it is possible that sequence identities between read a and unigene  <dig>  and read b and unigene  <dig> both fail to meet the cutoff. iassembler will then treat reads a and b, as well as unigene  <dig>  as unigenes to perform type ii error correction in the next round of iteration. as shown in figure  <dig>  this will generate an endless loop and the error will never be corrected. iassembler will stop the loop if the identified errors are not new ones.

RESULTS
iassembler is designed to generate highly accurate assemblies of est sequences by performing iterative assembly strategy and automated error detection and correction. the three assemblers in iassembler, mira, cap <dig> and megablast assemblers, are all base on the overlap-layout-consensus strategy thus iassembler is applicable for ests with relative long sequences, such as those generated using sanger and/or roche- <dig> platforms.

workflow of iassembler
the workflow of iassembler is shown in figure  <dig>  iassembler takes roche- <dig> and/or sanger est sequences in fasta format as its input. before being fed to iassembler, the est sequences need to be cleaned by removing low quality regions and known sequence contaminations  to avoid misassemblies and misinterpretations. this can be achieved by using sequence cleaning programs such as seqclean  <cit>  or lucy  <cit> . it is worth noting that iassembler itself does not contain functions to clean and trim raw est sequences.

cleaned est sequences are first supplied to iassembler with appropriate user-defined parameters. iassembler first employs mira to assemble est sequences, followed by assembling the resulting mira unigenes using cap <dig>  these two open source assemblers were chosen because we have observed that mira is efficient in handling large-scale and relatively short roche- <dig> reads while cap <dig> can complement mira by correcting certain type ii assembly errors. following initial assemblies by mira and cap <dig>  type ii assembly errors  are then identified by performing all-versus-all pairwise sequence alignments of the resulting unigenes using the ncbi megablast program. iassembler then utilizes the pair-wise alignment information to assemble these unigenes into new contigs using the megablast assembler module. next, iassembler identifies type i assembly errors by aligning individual est members to their corresponding unigenes. the misassembled ests, whose alignments to their corresponding unigenes do not satisfy cutoffs of user-specified parameters such as minimum percent identity or maximum overhang, were then extracted and used in the next round of assembly and error correction. finally, unigene base calling errors are corrected based on alignment information of individual ests to their corresponding unigenes contained in the sam output file. iassembler iterates through error identification and correction steps until no new errors can be identified or corrected.

the main output of iassembler includes 1) the final assembled unigene sequence file in fasta format, 2) a text file summarizing the statistics of alignments of ests against their corresponding unigenes, which provides necessary information to assess the quality of the assembly, and 3) a file containing detailed alignment information of individual est sequences against their corresponding unigenes in sam format. sam format is a generic alignment format for storing read alignments against reference sequences  <cit>  and has been adopted by most next-generation sequence alignment and assembly programs. sam files can be processed and manipulated by samtools, for example, samtools can convert sam files into bam files, the binary form of sam files, for significant fast accessing and hard disk saving, and can generate pileup output from sam files for snp detection  <cit> . sam files can also be viewed by several next-generation sequence assembly visualization programs including igv  <cit>  and tablet  <cit> .

evaluation of iassembler
we compared the performance of iassembler to that of several commonly used est assembly programs including mira, cap <dig>  tgicl, phrap, and newbler. an olive est dataset generated using the roche- <dig> platform as described in alagna et al.  <cit>  and a tomato sanger est dataset collected from ncbi dbest database  <cit>  were first used for the evaluation. both est datasets were cleaned by removing adaptor, vector, and e. coli genome sequences, which resulted in a total of  <dig>  olive ests with an average length of  <dig> bp and  <dig>  tomato ests with an average length of  <dig> bp. est assemblies were performed using a single cpu on a server with six quad-core  <dig>  ghz intel xeon processor and  <dig> gb of ram. the following parameters were used for all the tested assembly programs, if applicable: minimum overlap length of  <dig> bp, minimum overlap percent identity of 97%, and maximum overhang length of  <dig> bp. detailed commands and parameters used for these assemblers are listed in table  <dig> 

as shown in table  <dig> and  <dig>  the final assemblies of both tomato and olive ests using mira, cap <dig>  tgicl, phrap and newbler contained large amount of type ii errors. this indicated that significant redundancies existed in these assemblies. iassembler was able to correct the majority of these errors, with very few errors left. as a result, iassembler produced fewer and significant longer unigenes than other assemblers except phrap and newbler. the longer unigene length of phrap and newbler assemblies is due to the significant more type i assembly errors they generated, which incorrectly assembled different transcripts into one longer gene . mira, cap <dig> and tgicl assemblies also contained significant number of type i assembly errors, especially mira when run under sanger settings , while iassembler only left several type i errors.

we then tested performances of these assemblers using another set of parameters: minimum overlap length of  <dig> bp, minimum overlap percent identity of 95%, and maximum overhang length of  <dig> bp. the results also indicated that iassembler generated much higher quality of assemblies than other assembly programs we investigated .

we further evaluated the assemblers using a curated arabidopsis est dataset. arabidopsis ests were downloaded from tair website ftp://ftp.arabidopsis.org/home/tair/sequences/ath_cdna_est_sequences_fasta/ath_est_sequences_ <dig> fas and aligned to arabidopsis cdnas  using the megablast program with a minimum percent identity of  <dig> and a word size of  <dig>  only ests aligned to arabidopsis cdnas in their entire length were kept and the final collection contained  <dig>  ests. these ests were assembled de novo using the six assemblers with the following parameters: minimum overlap length of  <dig> bp, minimum overlap percent identity of 97%, and maximum overhang length of  <dig> bp . the resulting unigenes were then aligned back to arabidopsis cdnas and a small portion of the unigenes  could not be aligned to arabidopsis cdnas in their entire lengths . closer examination indicated that the majority of unaligned unigenes were those joined by two isoforms. this is not unexpected since in de novo est assemblies it's inevitable that in certain cases two different isoforms could be joined together. iassembler had slightly more unaligned unigenes than tgicl, mira, and cap <dig>  but much less than phrap and newbler. however, iassembler corrected large number of type ii errors found in other five assemblies, especially cap <dig>  mira and phrap . a significant number of type ii errors found in cap <dig>  mira, tgicl, phrap and newbler assemblies were those with two nearly identical sequences with large overlaps  failed to be assembled together, similar to the example shown in additional file 1; while type ii errors found in the iassembler assembly were mainly due to sequence errors which caused two sequences not to be able to be aligned against each other  but both of the sequences could be aligned to arabidopsis cdnas. in addition, iassembler again generated significantly less type i assembly errors than tgicl, phrap and newbler, and approximately same as cap <dig> and mira.

*perfectly aligned means that the sequences were aligned to arabidopsis cdnas in their entire lengths

in summary, our extensive evaluations of iassembler and other est assembly programs using different datasets and parameters support that iassembler has significantly better performance, generating much less assembly errors in assembling sanger and/or roche- <dig> ests.

as shown in table  <dig> and  <dig>  the higher quality of assemblies achieved by iassembler is a tradeoff of longer run time. the most time-consuming steps of iassembler include the first initial assembly of est sequences by mira and error detection by megablast. the run time of iassembler can be significantly reduced by taking advantage of efficient usage of multi-threads by megablast and mira programs.

CONCLUSIONS
in this study, we describe a standalone package called iassembler, which can perform de novo assembly of ests generated by traditional sanger and/or next-generation roche- <dig> massively parallel pyrosequencing technologies. through the use of an iterative assembly strategy and automated error detection and correction, iassembler can deliver much higher accuracy in est assembly than other existing est assembly programs we investigated. although iassembler can only be executed under a command line interface, it's very easy to install and simple to use.

availability and requirement
project name: iassembler

project home page: http://bioinfo.bti.cornell.edu/tool/iassembler

operating system: linux

programming language: perl

other requirements: bioperl version  <dig>  or higher

third-party tools: blast, cap <dig> and mira. these tools are already integrated into the iassembler package.

license: none

any restrictions to use by non-academics: none

authors' contributions
zf conceived the general idea of this project and provided the guidance on the whole study. yz developed the software and performed comparison with other assemblers. jg and lz helped with design and evaluation of the software. zf, yz, and jg wrote the manuscript. all authors have read and approved the manuscript.

supplementary material
additional file 1
examples of common est assembly errors. the file provides several examples of common est assembly errors.

click here for file

 additional file 2
performances of est assembly programs. the file provides evaluation results on performances of several est assembly programs.

click here for file

 acknowledgements
we would like to thank qi sun and thomas brutnell for critical review of the manuscript. this work was supported by national science foundation grant  and the united states-israel binational agricultural research and development fund  to zf.
