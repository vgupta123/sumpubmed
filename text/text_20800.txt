BACKGROUND
sequence alignment has a long history in genomics research and continues to be a key component in the analysis of genes and genomes. simply stated, sequence alignment algorithms find regions in one sequence, called here the query sequence, that are similar or identical to regions in another sequence, called the reference sequence. such regions may represent genes, conserved regulatory regions, or any of a host of other sequence features. alignment also plays a central role in de novo and comparative genome assembly  <cit> , where thousands or millions of sequencing reads are aligned to each other or to a previously sequenced reference genome. new, inexpensive large-scale sequencing technologies  <cit>  can now generate enormous amounts of sequence data in a very short time, enabling researchers to attempt genome sequencing projects on a much larger scale than previously. aligning these sequence data using current algorithms will require very high-performance computers, of the type currently available only at the largest sequencing and bioinformatics centers. furthermore, realizing the dream of widespread personal genomics at hospitals and other clinical settings requires sequence alignment to be low cost in addition to high-throughput.

most personal computer workstations today contain hardware for 3d graphics acceleration called graphics processing units . recently, gpus have been harnessed for non-graphical, general purpose  applications. gpus feature hardware optimized for simultaneously performing many independent floating-point arithmetic operations for displaying 3d models and other graphics tasks. thus, gpgpu programming has been successful primarily in the scientific computing disciplines which involve a high level of numeric computation. however, other applications could be successful, provided those applications feature significant parallelism.

in this paper, we describe a gpgpu program called mummergpu that performs exact sequence alignment using suffix trees on graphics hardware. our implementation runs on recent hardware available from nvidia using a new software development kit  for gpgpu progamming called compute unified device architecture . mummergpu is targeted to tasks in which many small queries, such as reads from a sequencing project, are aligned to a large reference sequence. to assess the performance of mummergpu we compare it to the exact alignment component of mummer called mummer. mummer is a very fast and widely used application for this type of task  <cit> , and is also used as the alignment engine for the comparative assembler amoscmp  <cit> . overall mummergpu is more than three times faster than mummer on typical sequence alignment tasks involving data from three recent sequencing projects. as implemented, mummergpu is a direct replacement for mummer and can be used with any other programs that process mummer output, including the other components of mummer that post-process the exact alignments computed by mummer into larger inexact alignments.

sequence alignment
one of the most successful algorithms for computing alignments between sequences is mummer  <cit> . the first stage of mummer is performed by a component called mummer, which computes exact alignments between the pair of sequences. these alignments can be used directly to infer large-scale sequence structure, or they can be used to seed extensions to longer inexact alignments using the post-processing tools bundled with mummer. unlike other popular sequence alignment programs such as blast  <cit> , fasta  <cit> , and lagan  <cit> , which use fixed length seeds for constructing their alignments, mummer alignments are variable-length maximal exact matches, where maximal means that they cannot be extended on either end without introducing a mismatch. first, mummer pre-processes the reference sequence to create a data structure, called a suffix tree. this data structure allows mummer to then compute all maximal exact substring alignments of a query sequence in time proportional to the length of the query. the time to pre-process the reference sequence is proportional to its length , but this time becomes insignificant when amortized across many query searches. consequently, suffix trees are used in several alignment algorithms, including mga  <cit>  and reputer  <cit> . the suffix tree  <cit>  for string s is a tree that encodes every suffix of s with a unique path from the root to a leaf. for a string of length n, there are n leaf nodes for each of the n suffixes in s. each edge in t is labeled with a substring of variable length of s called an edge-label. concatenating edge-labels along a path from the root to a node i forms a substring, called i's path-label in s. leaves in the tree are labeled with the position where the path-label begins in s. internal nodes have at least  <dig> children, representing positions where repeated substrings diverge. the edge-labels of the children of a node each begin with a different character from the alphabet, so there is at most one child for each letter of the reference string's alphabet. consequently, the depth of any leaf is at most n, and there are o nodes in the tree.

a suffix tree can be constructed in o time and o space for a string over a fixed alphabet, such as for dna or amino acids, by using additional pointers in the tree called suffix links. the suffix link of node v with path-label xα points to node v' with path-label α where x is a single character and α is a substring  <cit> . suffix links are used to navigate between equivalent nodes of consecutive suffixes without returning to the root of the tree.

all substrings of a query string q of length m that occur in a string s can be determined in time proportional to m by navigating the suffix tree t of s to follow the characters in q. the algorithm begins by finding the longest prefix of q that occurs in t, descending from the root of t and following exactly aligning characters in q for as long as possible. assume that substring q is found in t along the path-label to node v, but there is no edge from v labeled with the next character in q because q is not present in s. the algorithm can then report the occurrences of q at the positions represented by all leaves in the subtree rooted at v after checking the alignments are maximal by comparing the left flanking base of the query and reference. the algorithm then continues by finding the longest substrings for each of the m -  <dig> remaining start positions in q. however, instead of navigating the tree from the root each time, the algorithm resumes aligning with q after following the suffix link from v to v' and without reprocessing previously aligned characters.

given a user-specifed minimum length l and a query q, suppose there is an exact alignment of length m ≥ l for the substring starting at position i in the query and ending at or along the edge to node n. the length of the alignment  is equal to the length of the path-label of the parent of node n plus the length along the edge to n. starting from n, the algorithm follows successive parent links up the tree, subtracting the edge length of each link from the alignment length, until the alignment length is less than l as shown in figure  <dig>  let r be the node with the smallest string depth greater than l on this path. for each leaf l in the subtree rooted by r, the path-label to the lowest common ancestor of n and l defines a substring starting at i in q which occurs in both q and s at the reference position defined by the leaf label of l. for a thorough discussion of suffix trees and their applications, see gusfield's classic work on sequence analysis  <cit> .

gpgpu programming
as the gpu has become increasingly more powerful and ubiquitous, researchers have begun exploring ways to tap its power for non-graphics, or general-purpose  applications  <cit> . this has proven challenging for a variety of reasons. traditionally, gpus have been highly specialized with two distinct classes of graphics stream processors: vertex processors, which compute geometric transformations on meshes, and fragment processors, which shade and illuminate the rasterized products of the vertex processors. the gpus are organized in a streaming, data-parallel model in which the processors execute the same instructions on multiple data streams simultaneously. modern gpus include several  of each type of stream processor, so both graphical and gpgpu applications are faced with parallelization challenges  <cit> . furthermore, on-chip caches for the processing units on gpus are very small  compared to general purpose processors, which feature caches measured in megabytes. thus, read and write operations can have very high latency relative to the same operations when performed by a cpu in main memory.

most gpgpu successes stem from scientific computing or other areas with a homogeneous numerical computational component  <cit> . these applications are well suited for running on graphics hardware because they have high arithmetic intensity – the ratio of time spent performing arithmetic to the time spent transferring data to and from memory  <cit> . in general, the applications that have performed well as a gpgpu application are those that can decompose their problems into highly independent components each having high arithmetic intensity  <cit> . some bioinformatics applications with these properties have been successfully ported to graphics hardware. liu et al. implemented the smith-waterman local sequence alignment algorithm to run on the nvidia geforce  <dig> gto and geforce  <dig> gtx, and reported an approximate 16× speedup by computing the alignment score of multiple cells simultaneously  <cit> . charalambous et al. ported an expensive loop from raxml, an application for phylogenetic tree construction, and achieved a  <dig> × speedup on the nvidia geforce  <dig> le  <cit> .

nvidia's new g <dig> architecture radically departs from the traditional vertex+fragment processor pipeline. it features a set of multiprocessors that each contain a number of stream processors . graphics applications can use these as either vertex or fragment processors, and gpgpu applications can program them for general computation. all processors on a single multiprocessor simultaneously execute the same instruction, but different multiprocessors can execute different instructions. nvidia anticipated the benefits of such a unified architecture for gpgpu computing, and released the compute unified device architecture  sdk to assist developers in creating non-graphics applications that run on the g <dig> and future gpus. cuda offers improved flexibility over previous gpgpu programming tools, and does not require application writers to recast operations in terms of geometric primitives, as was required by earlier gpgpu environments  <cit> .

cuda enables programmers to write programs that run on the gpu in a restricted form of the c programming language, and compiled into g <dig> bytecode. cuda programs typically consist of a component that runs on the cpu, or host, and a smaller but computationally intensive component called the kernel that runs in parallel on the gpu . the kernel cannot access the cpu's main memory directly – input data for the kernel must be copied to the gpu's on-board memory prior to invoking the kernel, and output data also must first be written to the gpu's memory. all memory used by the kernel must be preallocated, and the kernel cannot use recursion or other features requiring a stack, but loops and conditionals are allowed. furthermore, the number of registers per multiprocessor is limited and the multiprocessor schedules fewer processors to compute simultaneously if the number of registers used per kernel is too high. consequently, high-performance kernel code requires careful tuning to reduce the number of registers used and limit the amount of branching.

the improved flexibility of cuda does not solve the more fundamental problems caused by the g80's stream-computing organization: the relatively small cache and associated high memory latency for memory intensive programs. however, the g80's texture memory is cached to speed up memory intensive texture mapping operations, and can be used by gpgpu programs. gpgpu programs can pack their data structures into one-, two-, or three-dimensional arrays stored in texture memory, and thus use the cache for read-only memory accesses to these data structures  <cit> . performance is further improved by utilizing one of several software techniques for maximizing the benefit offered by even a small cache. one such class of techniques involves reordering either the data in memory or the operations on those data to maximize data and temporal locality. mellor-crummey et al. reported significant speedup in particle interaction simulations, which feature highly irregular access patterns, by reordering both the locations of particles in memory and the order in which interactions were processed. they tested a reordering strategy based on space-filling curves, such as the hilbert and morton curves  <cit> .

implementation
the mummergpu algorithm performs parallelized exact string alignment on the gpu . first a suffix tree of the reference sequence is constructed on the cpu using ukkonen's algorithm  <cit>  and transfered to the gpu. then the query sequences are transfered to the gpu, and are aligned to the tree on the gpu using the alignment algorithm described above. alignment results are temporarily written to the gpu's memory, and then transfered in bulk to host ram once the alignment kernel is complete for all queries. finally, all maximal alignments longer than a user-supplied value  are reported by post-processing the raw alignment results on the cpu. the output format and many parameters of mummergpu are identical to those of mummer , up to the order in which alignments appear in the output for each query, and thus mummergpu can be used as a drop-in replacement for mummer. in particular, all programs in the nucmer suite of programs that use the output of mummer, including those that extend the exact alignment seeds to larger inexact alignments, can take advantage of the gpu paralellization  <cit> .

the g <dig> has a relatively small amount of on-board memory, so the data are partitioned into large blocks so that the reference suffix tree, query sequences, and output buffers will fit on the gpu. as of this writing, the amount of on-board memory for a g <dig> ranges from  <dig> mb to  <dig> mb. a suffix tree built from a large reference sequence, such as a human chromosome, will exceed this size, so mummergpu builds k smaller suffix trees from overlapping segments of the reference. mummergpu computes k at runtime to fill approximately one third of the total gpu device memory with tree data. the trees overlap in the reference sequence by the maximum query length m supported by mummergpu  to guarantee all alignments in the reference are found, but alignments in the overlapping regions are reported only once.

after building the trees, mummergpu computes the amount of gpu memory available for storing query data and alignment results. the queries are read from disk in blocks that will fill the remaining memory, concatenated into a single large buffer , and transferred to the gpu. an auxiliary 1d array, also transfered to the gpu, stores the offset of each query in the query buffer. each multiprocessor on the gpu is assigned a subset of queries to process in parallel, depending on the number of multiprocessors and processors available. the executable code running on each processor, the kernel, aligns a single query sequence from the multiprocessor's subset to the reference. the kernel aligns the query to the reference by navigating the tree using the suffix-links to avoid reprocessing the same character of the query, as described above. reverse complement alignments are computed using a second version of the kernel which reverse complements the query sequences on-the-fly while aligning, allowing for computing both forward and reverse alignments without any additional data transfer overhead. the output buffer contains a slot to record the alignment result for each of the m - l +  <dig> substrings for a query of length m. the fixed size alignment result consists of the node id of the last visited node in the tree and length of the substring that exactly aligns. this information is sufficient to print all positions in the reference that exactly align the substring on the cpu.

after the kernel is complete for all the queries, the output buffer on the gpu is transfered to host ram and the alignments are printed by the cpu. each slot in the output buffer corresponds to a specific substring of a query. if multiple trees were built from the reference , then the output slots for each tree are preserved until the queries in a block have been aligned against each tree. this way all of the alignments for a given query can be printed in a single block, following the syntax used by mummer.

gpu memory layout
the suffix tree is "flattened" into two 2d textures, the node texture and the child texture. each tree node is stored in a pair of 16-byte texels  in these two textures. the node texture stores half the information for a node, including the start and end coordinates of the edge sequence in the reference, and the suffix link for the node. the remaining information for a node – the pointers to its a, c, g & t children – is stored in the child texture, addressed in parallel to the node texture. an auxiliary table containing each node's edge length, sequence depth, parent pointer, and suffix number for leaf nodes, is stored in ram and is used during the output phase.

in the cuda architecture, a program can store read-only data as cached textures. the g80's proprietary caching scheme takes advantage of 2d locality common in texturing operations. therefore, the algorithm attempts to optimize the 2d locality of the tree structure in these textures by organizing the nodes in  <dig> ×  <dig> texel blocks as shown in figure  <dig>  near the root of the tree , nodes are assigned using a level-order  traversal of the tree creating "wide" blocks of the tree. this ensures that all nodes near the root of the tree are placed in the first  <dig> ×  <dig> texel blocks, and guarantees the children of a given node will be at  adjacent cells in the texture. this is useful because at this depth, loading a single  <dig> ×  <dig> block for one kernel is likely to be reused for the other kernels running in parallel. further from the root , nodes are arranged in "tall" blocks so that a node, its children, grandchildren, and great-grandchildren are adjacently placed in the same   <dig> ×  <dig> block. as multiple queries are aligned against lower parts of the tree, it becomes less likely that their kernels will access many of the same nodes. thus, the data reordering scheme attempts to increase the cache hit rate for a single thread. the exact specification of the g80's caching scheme is proprietary information, but empirically, this hybrid layout seems to maximize the cache hit rate near the root of the tree, and towards the leaves where the kernel access patterns are radically different.

the reference sequence for the tree is transferred to the gpu as a third 2d texture, and is reordered along a simple 2d space-filling curve to maximize the cache hit rate for subsequent accesses along a node's edge. the sequence is reordered so that beginning with the first character, every four characters in the reference become the topmost four characters in the columns of the 2d array. once the array contains  <dig> ×  <dig>  characters, successive four-character chunks become the next four characters in the columns, left-to-right, and so on. we experimented with a variety of other data reordering schemes, including along a morton curve and other space filling curves, and found this to have the best performance on several reference sequences. altogether, using cache memory organized with the spacing-filing curves for the suffix tree and reference sequence improved the kernel execution speed by several fold.

complexity of mummergpu
mummergpu constructs its suffix trees in o time with ukkonen's algorithm, where n is the length of the reference. the alignment kernel running on the card computes all exact substring alignments for each query in time linear in the length of the query. the kernel is an implementation of existing alignment methods  <cit> , but with many independent instances running simultaneously on the gpu.

mummergpu uses both gpu memory and main system memory. suffix trees use an amount of memory linear in the length of the reference from which they are constructed  <cit> . the suffix trees in mummergpu thus each occupy o space, where k is the number of overlapping trees specified by the user, and m is the maximum query length supported by mummergpu. note that for most expected uses of mummergpu n ≫ m. only a fraction of that total space is actually transferred to the gpu. in the current implementation,  <dig> out of every  <dig> bytes per node are transferred. the remaining bytes are stored in the host-only auxiliary table used only for printing results by the cpu. for each query, mummergpu transfers the null terminated query sequence prepended with a special mismatch character, along with two 4-byte entries in auxiliary tables used by the kernel. for a query of length m, and a minimum substring length l, m - l +  <dig> output slots are reserved to record the query's substring alignments, and each output slot occupies  <dig> bytes. the total space required on both the cpu and the gpu for each query is  <dig> +  bytes. on a g <dig> with  <dig> mb of on-board ram, there is sufficient ram to store a tree for a  <dig> mbp reference sequence, and  <dig> million  <dig> bp or  <dig>   <dig> bp query sequences.

RESULTS
we measured the relative performance of mummergpu by comparing the execution time of the gpu and cpu version of the alignment code, and the total application runtime of mummergpu versus the serial application mummer. the test machine has a  <dig>  ghz dual-core intel xeon  <dig> with  <dig> gb of ram, and an nvidia geforce  <dig> gtx. the  <dig> gtx has  <dig> mb of on-board ram and a g <dig> with  <dig> multiprocessors, each of which has  <dig> stream processors. at the time of this writing, the retail price of the  <dig> gtx card is $ <dig>  and a retail-boxed intel xeon  <dig> cpu is $ <dig>  <cit> . input and output was to a local  <dig>  rpm sata disk. the machine was running red hat enterprise linux release  <dig> update  <dig> , cuda  <dig> , and mummer  <dig> .

we ported the mummergpu alignment kernel to use the cpu instead of the gpu to isolate the benefit of using graphics hardware over running the same algorithm on the cpu. cuda allows programmers to write in a variant of c, so porting mummergpu to the cpu required only straightforward syntactic changes, and involved no algorithmic changes. where the cuda runtime invokes many instances of the kernel on the gpu simultaneously, the cpu executes each query in the block sequentially.

the first test scenario was to align synthetically constructed reads to a bacterial genome. we used synthetic reads in order to explore mummergpu's performance in the absence of errors and over a wider variety of query lengths then are available with genuine reads. the synthetic test reads consisted of 50-, 100-, 200-, 400-, and 800-character substrings  sampled from the bacillus anthracis genome . thus, each read exactly aligns to the genome end-to-end at least once, and possibly more depending on the repeat content of the genome. when aligning each of the five sets of reads, we used l equal to the read size for the set. each set contained exactly  <dig> , <dig> base pairs of query sequence divided evenly among all the reads in the set.

the time for building the suffix tree, reading queries from disk, and printing alignment output is the same regardless of whether mummergpu ran on the cpu or the gpu, since those parts of mummergpu always run on the cpu. the actual sequence alignment portion of mummergpu ran dramatically faster, over 10× faster, on the gpu, despite the added cost of transferring the tree and query data to the gpu. the speedup of mummergpu  running on the gpu over mummergpu on the cpu is shown in figure  <dig> 

for longer reads, the speedup of using the gpu is diminished, because of poor cache performance and thread divergence, both of which are acknowledged as potential performance problems on the g <dig>  <cit> . all queries begin at the root of the tree, and many queries will share common nodes on their paths in the tree. however, as the kernel travels deeper into the tree for longer reads, the texture elements stored in the cache are reused less often, thus reducing the cache hit rate, and increasing the overall average access time. in addition, even though queries are the same length, the alignment kernel may not visit the same number of nodes, nor spend the same amount of time comparing to edges, because edges in suffix trees have variable length. this creates divergence among the threads processing queries, and the multiprocessor will be forced to serialize their instruction streams. it is difficult to quantify the relative contribution of these effects, but it is likely that both are significant sources of performance loss.

in addition to the test with synthetic data, we also aligned reads from several recent sequencing projects against the genomes from which the reads were generated. the projects included streptococcus suis sequenced with the solexa/illumina sequencer  <cit> , multiple strains of listeria monocytogenes sequenced using  <dig> pyrosequencing  and caenorhabditis briggsae sequenced with standard abi 3730xl sanger-type sequencing  <cit> . we aligned the reads against both strands of the chromosomal dna for l. monocytogenes and s. suis, and against both strands of chromosome iii of c. briggsae. little data from solexa/illumina has been made public at the time of this writing, and the public data set available had only a single lane's worth of data. to represent the full set of reads from a full solexa/illumina run, we concatenated  <dig> copies of a publicly-available file containing  <dig> , <dig>  <dig> bp reads to form the s. suis query set. the reference sequence and queries in all three tests did not include ambiguous bases. for these three tasks, table  <dig> shows the runtime parameters used and the overall speedup of mummergpu over mummer. figure  <dig> shows the wall-clock time spent by mummergpu in the various phases of the algorithm, including kernel execution and i/o between cpu and gpu.

for each of the alignment tasks, mummergpu was between  <dig>  and  <dig>  times faster than mummer. for c. briggsae, mummergpu spent most of its time aligning queries on the gpu. because we aligned all of the reads from the sequence project against chromosome iii of the c. briggsae, many of the reads did not align anywhere in the reference. as a result, a relatively short amount of time was spent in writing alignment output to disk. for other alignments, such as for the l. monocytogenes and s. suis test sets, the output phase dominates the running time of mummergpu. for these tasks, printing the output in parallel with aligning a block of queries would provide substantial speedup, as it would hide much of the time spent aligning queries on the card. we plan to adopt this strategy in a future release of mummergpu.

despite the performance hazards experienced for longer simulated reads, mummergpu on the gpu consistently outperforms mummer on real sequencing data by more than a factor of three in wall-clock application running time. unlike the idealized simulated reads, these reads are variable length and have sequencing error, which will cause further divergence in the kernel executions. furthermore, the c. briggsae alignment required the use of a segmented suffix tree and associated data transfer overhead. in general, mummergpu confers significant speedup over mummer on tasks in which many short queries are aligned to a single long reference.

CONCLUSIONS
operations on the suffix tree have extremely low arithmetic intensity – they consist mostly of following a series of pointers. thus, sequence alignment with a suffix tree might be expected to be a poor candidate for a parallel gpgpu application. however, our results show that a significant speedup, as much as a 10-fold speedup, can be achieved through the use of cached texture memory and data reordering to improve access locality. this speedup is realized only for large sets of short queries, but these read characteristics are beginning to dominate the marketplace for genome sequencing. for example solexa/illumina sequencing machines create on the order of  <dig> million  <dig> bp reads in a single run. for a single human genotyping application, reads from a few such runs need to be aligned against the entire human reference genome. thus our application should perform extremely well on workloads commonly found in the near future. the success of our application is in large part the result of the first truly general purpose gpu programming environment, cuda, which allowed us to directly formulate and implement our algorithm in terms of suffix tree navigation and not geometric or graphics operations. this environment made it possible to efficiently utilize the highly parallel and high speed  <dig> gtx. an  <dig> gtx is similar in price to a single  <dig>  ghz xeon core, but offers up to  <dig> × speedup in total application runtime. furthermore, in the near future, a common commodity workstation is likely to contain a cuda compliant gpu that could be used without any additional cost.

even though mummergpu is a low arithmetic memory intensive program, and the size of the stream processor cache on the g <dig> is limited, mummergpu achieved a significant speedup, in part, by reordering the nodes to match the access patterns and fully use the cache. we therefore expect with careful analysis of the access pattern, essentially any highly parallel algorithm to perform extremely well on a relatively inexpensive gpu, and anticipate widespread use of gpgpu and other highly parallel multicore technologies in the near future. we hope by making mummergpu available open source, it will act as a roadmap for a wide class of bioinformatics algorithms for multi-processor environments.

availability and requirements
project name: mummergpu

project home page: 

operating system: linux, unix

programming language: c, c++, cuda

other requirements: nvidia g <dig> gpu, cuda  <dig> 

license: artistic license

restrictions to use by non-academics: none.

authors' contributions
ms and ct developed the software and wrote the manuscript together. ad and av helped to draft and edit the manuscript. all authors read and approved the final manuscript.

