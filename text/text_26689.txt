BACKGROUND
automatically extracting protein–protein interactions  from free text is one of the major challenges in biomedical text mining  <cit> . several methods, which usually are co-occurrence-based, pattern-based, or machine-learning based  <cit> , have been developed and compared using a slowly growing body of gold standard corpora  <cit> . however, progress always has been slow  and seems to have slowed down even over the last years; furthermore, current results still do not cope with the performance that has been achieved in other areas of relationship extraction  <cit> .

in this paper, we want to elucidate the reason of the slow progress by performing a detailed, cross-method study of characteristics shared by ppi instances which many methods fail to classify correctly. we concentrate on a fairly recent class of ppi extraction algorithms, namely kernel methods <cit> . the reason for this choice is that these methods were the top-performing in recent competitions  <cit> . in a nutshell, they work as follows. first, they require a training corpus consisting of labeled sentences, some of which contain ppis and/or non-interacting proteins, while others contain only one or no protein mentions. all sentences in the training corpus are transformed into structured representations that aims to best capture properties of how the interaction is expressed . the representations of protein pairs together with their gold standard ppi-labels are analyzed by a kernel-based learner , which builds a predictive model. when analyzing a new sentence for ppis, its candidate protein pairs are turned into the same representation, then classified by the kernel method. for the sake of brevity, we often use the term kernel to refer to a combination of svm learner and a kernel method.

central to the learning and the classification phases is a so-called kernel function. simply speaking, a kernel function is a function that takes the representation of two instances  and computes their similarity. kernels functions differ in  the underlying sentence representation ;  the substructures retrieved from the sentence representation to define interactions; and  the calculation of the similarity function.

in our recent study  <cit> , we analyzed nine kernel-based methods in a comprehensive benchmark and concluded that dependency graph and shallow linguistic feature representations are superior to syntax tree ones. although we identified three kernels that outperformed the others , the study also revealed that none of them seems to be a single best approach due to the sensitivity of the methods to various factors—such as parameter settings, evaluation scenario and corpora. this leads to highly heterogeneous evaluation results indicating that methods are strongly prone to over-fit the training corpus.

the focus of this paper is to perform a cross-kernel error analysis at the instance level with the goal to explore possible ways to improve kernel-based ppi extraction. to this end, we determine difficulty classes of protein pairs and investigate the similarity of kernels in terms of their predictions. we show that kernels using the same input representation perform similarly on these pairs and that building ensembles using dissimilar kernels leads to significant performance gain. additionally, we identify kernels that perform better on certain difficulty classes; paving the road to more complex ensembles. we also show that with a generic feature set and linear classifiers a performance can be achieved that is on par with most kernels. however, our main conclusion is pessimistic: our results indicate that significant progress in the field of ppi extraction probably can only be achieved if future methods leave the beaten tracks.

methods
we recently performed a comprehensive benchmark of nine kernel-based approaches   <cit> . in the meantime, we obtained another four kernels: three of them were originally proposed by kim et al.  and one is its modification described in  <cit> ; we refer to them collectively as kim’s kernels. in this work, we investigate similarities and differences between these  <dig> kernels.

kernels
the shallow linguistic   <cit>  kernel does not use deep parsing information. it is solely based on bag-of-word features , surface features , and shallow linguistic  features generated from tokens left and right to the two proteins  of the protein pair.

subtree , subset tree , partial tree  and spectrum tree  kernels exploits the syntax tree representation of sentences. they differ in the definition of extracted substructures. st, sst and pt kernels extract subtrees of the syntax parse tree that contain the analyzed protein pair. spt uses vertex-walks, that is, sequences of edge-connected syntax tree nodes, as the unit of representation. when comparing two protein pairs, the number of identical substructures are calculated as similarity score.

the next group of kernels applies dependency parse sentence representation. edit distance and cosine similarity kernels , as well as the k-band shortest path spectrum  use primarily the shortest path among the entities, but the latter optionally allows for the k-band extension of this path in the representation. the most sophisticated kernel, all-path graph  builds both on the dependency graph and the token sequence representations of the entire sentence, and weighs connections within and outside the shortest path differently.

kim’s kernels  <cit>  also use the shortest path of the dependency parses. the four kernels differ in the information they use from the parses. the lexical kernel uses only lexical information encoded into the dependency tree, that is, nodes are the lemmas of the sentences connected by dependency relation labeled edges. the shallow kernel retains only the pos-tag information in the nodes. the similarity score is calculated by both kernels as the number of identical subgraphs of two shortest paths with the specific node labeling. the combined kernel is the sum of the former two variants. the syntactic kernel, defined in  <cit> , applies exclusively the structural information from the dependency tree, that is, only the edge labels are considered at similarity score calculation.

since fayruzov’s implementation of kim’s kernels does not determine automatically the threshold where to separate positive and negative classes, it has to be specified for each model separately. therefore, in addition to the parameter search described in  <cit>  and re-used here, we also performed a coarse-grid threshold searching strategy in  <cit>  with step  <dig> . assuming that the test corpus has similar characteristic as the training one—the usual guess in the absence of further knowledge—we selected the threshold between positive and negative classes such that their ratio approximated the best the ratio measured on the training set. note that apg  <cit>  applies a similar threshold searching strategy but optimizes the threshold against f-score on the training set.

classifiers and parameters
typically, kernel functions are integrated into svm implementations. several freely available and extensible implementations of svms exist, among which svm light <cit>  and libsvm  <cit>  probably are the most renowned ones. both can be adapted by supplying a user-defined kernel function. in svm light, kernel functions can be defined as a real function of a pair in the corresponding instance representation. libsvm, on the other hand, requires the user to pre-compute kernel values, i.e., pass to the svm learner a matrix containing the pairwise similarity of all instances. accordingly, most of the kernels we experimented with use the svm light implementation, except for the sl and kim’s kernels that use libsvm, and apg that uses internally a sparse regularized least squares  svm.

corpora
we use the five freely available and widely used ppi-annotated resources also described in  <cit> , i.e., aimed  <cit> , bioinfer  <cit> , hprd <dig>  <cit> , iepa  <cit> , and lll  <cit> .

evaluation method
we report on the standard evaluation measures , recall , f1-score ). as we have shown in our previous study  <cit> , the auc measure  that is often used in recent literature to characterize classifiers and independent from the distribution of positive and negative classes, depends very much on the learning algorithm of the classifier, and only partially on the kernel. therefore, in this study we stick to the above three measures, which actually give a better picture on the expected classification performance on new texts. results are reported in two different evaluation settings: primarily, we use the document-level cross-validation scheme , which still seems to be the de facto standard in ppi extraction. we also use the cross-learning  evaluation strategy for identifying pairs that behave similarly across various evaluation methods.

in the cv setting, we train and test each kernel on the same corpus using document-level 10-fold cross-validation. we employ the document-level splits used by airola and many others  to allow for direct comparison of results. the ultimate goal of ppi extraction is the identification of ppis in biomedical texts with unknown characteristics. this task is better reflected in the cl setting, when training and test sets are drawn from different distributions: in such cases, we train on an ensemble of four corpora and test on the fifth one. cl methodology is generally less biased than cv, where the training and the test data sets have very similar corpus characteristics. note that the difference in the distribution of positive/negative pairs in the five benchmark corpora  accounts for a substantial part of the diversity of the performance of approaches  <cit> . differences in the annotation of corpora not limited to distribution but also deviates in their annotation guidelines and the definition of what constitutes a ppi; those differences are dominantly kept in the standardized format  <cit>  obtained by applying a transformation approach to yield the greatest common factor in annotations.

experimental setup
for the experimental setup we follow the procedure described in  <cit> . in a nutshell, we applied entity blinding, resolved entity–token mismatch problems and extended the learning format of the sentences with the missing parses. we applied a coarse-grained grid parameter search and selected the best average setting in terms of the averaged f-score measured across the five evaluation corpora as the default setting for each kernel.

RESULTS
the main goal of our analysis was to better characterize kernel methods and understand their short-comings in terms of ppi extraction. we started by characterizing protein pairs: we divided them into three classes based on their difficulty. difficulty is defined by the observed classification success level of kernels. we also manually scrutiny some of the pairs that were found to be the most difficult ones, suspecting that the reason for the failure of kernels is in fact an incorrect annotation. we re-labeled a set of such suspicious annotations and re-evaluated if kernels were able to benefit from these modifications. we also compare kernels based on their predictions by defining kernel similarity as prediction agreement on the instance level. we investigate how kernels’ input representations correlate with their similarity. finally, to quantify the claimed advantage of kernels for ppi extraction, we compare kernels to more simple methods. we used linear, non-kernel based classifiers and a surface feature set also found in the kernel methods.

difficulty of individual protein pairs
in this experiment we determine the difficulty of protein pairs. the fewer kernel based approaches are able to classify a pair correctly, the more difficult the pair is. different kernels’ predictions vary heavily as we have reported in  <cit> . here, we show that there exists protein pairs that are inherently difficult to classify , and we investigate whether kernels with generally higher performance classify difficult pairs with greater success.

we define the concept of success level as the number of kernels being able to classify a given pair correctly. for cv evaluation we performed experiments with all  <dig> kernels, and therefore have success levels:  <dig> …, <dig>  for cl evaluation, we omitted the very slow pt kernel . figures  <dig> and  <dig> show the distribution of ppi pairs in terms of success level for cv and cl evaluation aggregated across the  <dig> corpora, respectively. we also show the same statistics for each corpus separately . figure  <dig> shows the correlation between success levels of cv and cl.

the distribution of pairs  in terms of the number of kernels that classify them correctly. results shown for each corpus separately. aggregated results are shown in figure  <dig>  all the  <dig> kernels are taken into consideration.

the distribution of pairs  in terms of the number of kernels that classify them correctly. results shown for each corpus separately. aggregated results are shown in figure  <dig>  all but the pt kernel are considered. .

the 10– <dig> percentage point difference in f-score between cv and cl settings reported in  <cit>  can be most evidently seen in the slightly better performance of classifiers on difficult pairs in the cv setting. for example, pairs not classified correctly by any kernels in the cl setting  are most likely correctly classified by some cv classifiers , as shown in figure  <dig>  not surprisingly, the pairs correctly classified by most classifiers in either of the cv and cl settings correlate well . the pairs that are difficult in both evaluation settings  are reasonable target for further inspection, as improving kernels to better perform on the them would benefit both scenarios; we attempt to characterize such pairs in subsequent section.

in order to better identify pairs that are difficult or easy to classify correctly, for each corpus, we took the most difficult and the easiest ∼10% of pairs. for this we cut off the set of pairs at such a success level that the resulting subset of pairs is the closest possible to 10%. ultimately, we define more universal difficulty classes as the intersection of the respective difficulty classes in cv and cl settings, e.g. d=dcv∩dcl. when ground truth can be considered to be known, we may further define the intuitive subclasses negative difficult , positive difficult , negative easy  and positive easy , respectively.

we investigated whether and in what extent these classes of pairs overlap depending on the evaluation setting . we used the χ2-test to check if there was a significantly higher overlap between the two sets compared to as if drawn at random. a p-value lower than  <dig>  is considered significant. there are only few cases where correlation is not significant; we discuss these cases separately  where the ground truth is known , and  where the ground truth is unknown .

we also indicated the size of each set, because they vary depending on the size of success level classes. abbreviations d, e, pd, nd, pe, and ne refer to the set of difficult , easy , positive difficult, negative difficult, positive easy and negative easy pairs, respectively; gt means ground truth. we highlighted with bold the number pairs in the intersection of cv and cl settings. we show the p-value of fisher’s independence χ2-test rounded to the closest factor of  <dig>  bold typesetting indicates that the size of the overlap is too low.

for case , the very few exceptions  account only for a mere 1% of pd and 6% of pe pairs. we can also see that the larger a corpus, the better cv and cl evaluations “agree” on the difficulty class of pairs: the strongest correlations can be observed at bioinfer and aimed.

considering case , for lll, the intersection of difficult pairs in cv and cl happens to be empty. it was shown in  <cit>  that kernels tend to preserve the distribution of positive/negative classes from training to test. lll has a particularly high ratio of positive examples . therefore, kernels predict positive pairs easier for lll at the cv evaluation, in contrast to cl: in cv evaluation, negative pairs are difficult and in cl evaluation positive ones are difficult. these factors and the relatively small size of the lll corpus  should explain the empty intersection.

we conclude that our method for identifying the difficult and easy pairs of each class finds meaningful subsets of pairs. we identified  <dig> nd ,  <dig> pd ,  <dig> ne  and  <dig> pe  pairs.

how kernels perform on difficult and easy pairs
in table  <dig> we show how the different kernels perform on the  <dig> nd pairs. we publish the same results for the pd, ne, and pe pairs, as well as for all four experiments for cl setting .

classification results on the  <dig> nd pairs with cv evaluation . ratio  refers to the distribution of positive classes predicted by the kernel measured across the  <dig> corpora; tn is the number of correctly classified nd pairs; e is 521·, the expected number of negative class predictions projected onto the  <dig> nd pairs.

classification results on the  <dig> nd pairs with cl evaluation . ratio  refers to the distribution of positive classes predicted by the kernel measured across the  <dig> corpora; tn is the number of correctly classified nd pairs; e is 521·, the expected number of negative class predictions projected onto the  <dig> nd pairs.

classification results on the  <dig> pd pairs with cv evaluation . ratio  refers to the distribution of positive classes predicted by the kernel measured across the  <dig> corpora; tp is the number of correctly classified pd pairs; e is 190·r, the expected number of negative class predictions projected onto the  <dig> pd pairs.

classification results on the  <dig> pd pairs with cl evaluation . ratio  refers to the distribution of positive classes predicted by the kernel measured across the  <dig> corpora; tp is the number of correctly classified pd pairs; e is 190·r, the expected number of negative class predictions projected onto the  <dig> pd pairs.

classification results on the  <dig> ne pairs with cv evaluation . ratio  refers to the distribution of positive classes predicted by the kernel measured across the  <dig> corpora; tn/fn is the number of correctly/incorrectly classified ne pairs; e is 1510·, the expected number of negative class prediction projected onto the  <dig> ne pairs.

classification results on the  <dig> ne pairs with cl evaluation . ratio  refers to the distribution of positive classes predicted by the kernel measured across the  <dig> corpora; tn/fn is the number of correctly/incorrectly classified ne pairs; e is 1510·, the expected number of negative class prediction projected onto the  <dig> ne pairs.

classification results on the  <dig> pe pairs with cv evaluation . ratio  refers to the distribution of positive classes predicted by the kernel measured across the  <dig> corpora; tp/fp is the number of correctly/incorrectly classified pe pairs; e is 219·r, the expected number of positive class prediction projected onto the  <dig> pe pairs.

classification results on the  <dig> pe pairs with cl evaluation . ratio  refers to the distribution of positive classes predicted by the kernel measured across the  <dig> corpora; tp/fp is the number of correctly/incorrectly classified pe pairs; e is 219·r, the expected number of positive class prediction projected onto the  <dig> pe pairs.

on difficult pairs , the measured number of true negatives  is smaller than expected based on the class distribution of kernels’ prediction. this phenomenon can be attributed to the difficulty of pairs. the same tendency can be observed for easy pairs  in the opposite direction.

the difference in performance between cv and cl settings reported in  <cit>  cannot be observed on nd pairs: kernels tend to create more general models in the cl setting and identify nd pairs with greater success in average. for pd pairs, kernels produce equally low results in both settings. on the other hand, kernels perform far better for easy pairs  in cv than in cl setting. this shows that the more general cl models do not work so well on easy pairs than the rather corpus specific cv models; that is, the smaller variability in training examples is also reflected in performance of the learnt model.

as for individual kernels, edit kernel shows the best performance for nd pairs both in terms of tns and relative to its expected performance. this can be attributed to the low probability of the positive class in edit’s prediction, which is also manifested in the below average performance on positive pairs , and the very good results on ne pairs. spt, which exhibits by far the highest positive class ratio, performs relatively well on pd pairs both in terms of fns and the expected relative performance ; this kernel shows analog performance pattern on pd and ne pairs. as for the top performing kernels  apg performs on all pair subsets equally well , except at cl on positive pairs; sl is always above the average, except at cv on nds; however kbsps works particularly well on easy pairs, and pretty bad on difficult ones .

we observed that for difficult  pairs, some kernels perform equally better independently of the class label: sst  and st . however, this advantage cannot be easily exploited unless difficult pairs are identified in advance. therefore, next we investigate whether difficulty classes can be predicted by observing only obvious surface features.

relation between sentence length, entity distance and pair difficulty
in figure  <dig> we show the characteristics of sentence difficulty in terms of the average length of the sentence, the average distance between entities, and the size of the shortest path in parse tree. it can be observed that positives pairs are more difficult to classify in longer, and negative pairs in shorter sentences. this correlates with the average length of sentences with positive/negative pairs being  <dig>  and  <dig>  words – these numbers coincide with the average length of neutral sentences. this is also in accordance with the distribution of positive and negative pairs in terms of the sentence length. positive pairs occur more often in shorter sentences with less proteins , and most of the analyzed classifiers fail to capture the characteristics of rare positive pairs in longer sentences. long sentences have typically more complicated sentence structure, thus deep parsers are also prone to produce more erroneous parses, which makes the ppi relation extraction task especially difficult.

the distance in words between entities in a sentence seems to be more independent from the difficulty of the pair . the entities in ne pairs are closer to each other than neutral or more difficult ones, while for positive pairs no such tendency can be observed: the distance in both pe and pd pairs are shorter than at neutral ones. on the other hand, one can observe also at this level that entities of negative pairs are further  from each others than positives ones . on the dependency tree level, the difference has a smaller extent:  <dig>   and  <dig>  .

we conclude that according to all the three distance measures , the farther the entities of negative pairs are located the more difficult are to classify. we also found that positive pairs are typically closer than negative pairs.

note that similar characteristics were observed at the bionlp’ <dig> event extraction task regarding the size of minimal subgraph of the dependency graph that includes all triggers and arguments. it was shown in  <cit>  that the size of this subgraph correlates with the class of the event: positive instances are present typically in smaller subgraphs. for the same dataset, in  <cit>  it is shown that the distance between trigger and potential arguments is much smaller for positive than for negative instances.

next we looked into the relationship between pair difficulty and number of entities in a sentence. in general, long sentences have more protein mentions, and the number of pairs increases quadratically with the number of mentions. we investigated the class distribution of pairs depending on the number of proteins in the sentence . we can see that the more protein mentions a sentence exhibits, the lower the ratio of positive pairs. this is consistent with the previous experiment on pd pairs: in long sentences there are only few positive pairs, and those are difficult to classify.

finally, to predict the difficulty class of pairs based on their surface features, we applied a decision tree classifier, results shown in table  <dig>  we found that predicting the difficult  class is particularly hard, with a recall of  <dig>  and an f-score of  <dig> , indicating that difficult pairs share very few characteristics.

classification by the weka j <dig> classifier. confusion matrix columns correspond to predicted classes.

still, we found a number of correlations between pair difficulty and simple surface features that cannot be exploited in kernels as they use a different feature set. later on, we will show that such features already suffice to build a classifier that is almost on par with the state-of-the-art, without using any sophisticated  kernels.

semantic errors in annotation
for some of the very hardest pairs , we manually investigated whether their difficulty is actually caused by annotation errors. we identified  <dig> pd and  <dig> nd pairs that we considered as incorrectly annotated . since the selection was drawn from the most difficult pairs, the relatively large number of incorrect annotations does not necessarily make the entire experimentation invalid, though raises the issue of the necessity of a possible re-annotation .

pair id abbreviations: a – aimed; b – bioinfer; i – iepa, l – lll; ground truth : t , f ; type of errors: indirect – no direct interaction between the entities are described; functional – only functional similarity between entities are described; enumeration – entities are just listed together in an enumeration; coreference – the same protein with different referencing. entities  are highlighted with bold typeface.

we investigated if kernels  could benefit from re-annotation by resetting the ground truth  value of the above  <dig> pairs and re-running the experiments. recall that only a mere  <dig> % of gt values were changed, most of them in bioinfer  and aimed  corpora. we analyzed the performance change both using the original and the re-trained model on the re-annotated corpora . we observed a slight performance improvement using the original model . with the re-trained model the performance of apg and sl could be further improved on both corpora . this shows that the re-annotation of corpora yield performance uplift even if only a small fraction of pairs is concerned.

modified – using the original model with modified ground truth; retrained – results of a model retrained on the modified ground truth; Δm-o – difference between modified and original; Δr-m – difference between retrained and modified.

similarity of kernel methods
classifier similarity is a key factor when constructing ensemble classifiers. we define the similarity of two kernels as the number of shared annotations versus the total number of annotations. performing hierarchical clustering with this similarity measure reveals that kernels using the same parsing information group together almost perfectly, i.e., classify pairs much more similarly to each other than to kernels using different parsing information . syntax tree based kernels form a clear and separated cluster. kim’s kernels build a proper sub-cluster within dependency-based kernels. the only kernel that does not use neither dependency nor syntax data, sl, is grouped in the cluster of dependency-based kernels. interestingly, the outlier in this cluster is kbsps and not sl. the best two kernels according to  <cit> , apg and sl, are the most similar to each other as they agree on 81% of the benchmark pairs.

clearly, such characteristics can be exploited in building ensembles as they allow a rationale choice of base classifiers; we will report on using such a strategy in the discussion.

feature analysis
to assess the importance of the aforementioned features we constructed a feature space representation of all pairs. we derived surface features from sentences and pairs , including tokens on the dependency graphs  and syntax tree shortest path, therefore also incorporating parsing information. we then performed feature selection by information gain using each difficulty class as label. the ten most relevant features of the difficult  and easy  classes are tabulated in table  <dig> according to an independent feature analysis. indicative features of the d-class negatively correlate with the class label: sentence length, the entropy of pos labels along the syntax tree shortest path, number of dependency labels of type dep , number of proteins in sentence. the importance of feature dep suggests that pairs in sentences having more specific dependency labels are more difficult to correctly predict. for the e class, the entropy of edge labels in the entire syntax tree and dependency graph, and the sentence length correlate positively, while frequency of nn, appos, conj_and, dep, det, etc. correlate negatively.

features may refer to both sentence and pair level characteristics. parsing features were generated from both syntax and dependency parses. scope of features are typically sentence , before entities , between entities , after entities .

ig – information gain; st – syntax tree; dg – dependency graph; sp – shortest path. italic typesetting indicates parsing tree labels. the sign after each feature indicates positive/negative correlation.

this experiment justifies that pairs in longer sentences may become more distant and more likely to be negative, thus easier to predict. several dependency labels are correlated with positive pairs thus their absence render the pair easier to classify .

non-kernel based classifiers
we also compared kernel based classifiers with some linear, non-kernel based classifiers as implemented in weka  <cit> . we used the surface feature space created for feature analysis . we ran experiments with  <dig> different methods , k-nn , rule learners , bayesian  and regression methods .) we found that the best surface-based classifier, bayesnet, is on par with or better than all kernel based classifiers except apg, sl and kbsps . on larger corpora, bayesnet attains  <dig>  f-score on aimed and  <dig>  on bioinfer which is outperformed only by the above three kernels. on smaller corpora that are easier to classify having more positive examples, the advantage of kernel based approaches shrinks further.

CONCLUSIONS
in this paper we performed a thorough instance-level comparison of kernel based approaches for binary relation  extraction on benchmark corpora.

first, we proposed a method for identifying different difficulty classes of protein pairs independently from evaluation setting. protein interactions are expressed at the linguistic level in diverse ways; its complexity influences the performance of automated methods to classify the pairs correctly. we hypothesized that linguistic complexity of expressing an interaction correlates with classification performance in general, that is, there are pps on which kernels tend to err independently from the applied evaluation setting . difficulty classes of pps were defined based on the success level of kernels in classifying them. we showed that difficulty classes correlate with certain surface features of the pair/the sentence containing the pair, especially word distance, shortest path length between the two proteins in the dependency graph and in the syntax tree. using these and other surface features, we build linear classifiers that yield results comparable to many of the much more sophisticated kernels. similar vector space classifiers have been used previously for ppi extraction by  <cit> , however, without an in-depth comparison with existing kernels and in a different evaluation setting. these observations suggest that ppi extraction performance depends far more on the feature set than on the similarity function encoded in kernels, and that future research in the field should focus on finding more expressive features rather than more complex kernel functions. however, it also should be noted that using ever larger feature sets requires considerably more computational resources, considerably increasing the runtime, especially for large-scale experiments. since the size of currently available training corpora do not keep up with the linguistic diversity, we see two alternatives as possible solutions. the first, computationally more economic strategy focuses on decreasing the linguistic variability using graph rewriting rules on the parse level . another alternative is to extend available training corpora e.g. by converting certain ppi specific event-level annotations  to ppi annotations in event databases, such as genia event data  <cit> . as an existing example, bioinfer originally also contains richer event information and was transformed to a ppi corpus using some simplifying rules  <cit> .

second, we built an ensemble by combining three kernels with a simple majority voting scheme. we chose kbsps, sl and apg as these show above average results across various evaluation settings, but still exhibit considerable disagreement at the instance level . combining them leads to a performance improvement of more than  <dig> percentage points in f-score over the best member’s performance . we also observed a performance increase when combining other kernels, but the results were not on par with that of the better performing kernels, showing that a detailed comparison of kernels in terms of their false positives and false negatives is very helpful for choosing base classifiers for ensembles. furthermore, we expect that even a higher performance gain can be achieved by employing more sophisticated ensemble construction methods, such as bagging or stacking  <cit> . an alternative approach by  <cit>  was to build a meta-classifier: they classified dependency trees into five different classes depending on the relative position of the verb and the two proteins and learnt a separate classifier for each of these classes.

best values are typeset in bold.

third, the identification of difficult protein pairs was found to be highly useful to spot likely incorrect annotations in the benchmark corpora. we deemed 45% of the  <dig> manually checked difficult pairs to be incorrectly annotated. we also showed that even very few re-annotated pairs  influence the kernels’ performance: the re-trained models could generalize the information beyond the affected pairs, and showed a systematic performance gain over the original model. since our method for finding incorrect annotations is fully automatic, it could be used to decrease the workload of curators at corpus revision.

overall, we showed that 1–2% of ppi instances are misclassified by all the  <dig> kernels we considered, independent of which evaluation setting  was used. vastly more, 19–30% of ppi instances are misclassified by the majority of these kernels. we also showed that, although a number of features correlate with the “difficulty” of instances, simple combinations of those are not able to tell apart true and false protein pairs. these observations lower the hope that novel types of kernels  will be able to achieve a breakthrough in ppi extraction performance.

we conclude that one should be rather pessimistic in terms of expecting breakthroughs in kernel-based methods to ppi extraction. current methods do not seem to do very well in capturing the characteristics shared by positive ppi pairs, which must also be attributed to the heterogeneity of the  available corpora. we see three main possibilities to escape this situation, some of which have already proven successful in other domains or in other extraction tasks . for all the three directions we provided below examples found among the  <dig> examined difficult cases.

the first is to switch focus to more specific forms of interactions, such as regulation, phosphorylation, or complex-building  <cit> . among the difficult cases it can be observed that incorrectly classified indirect ppis among the difficult cases  tend to be regulatory relationships. as other types of ppis may be less affected by this issue, the move from generic ppis to more specific relations should allow for a higher performance for those ppi subtypes. looking at such more crisply defined problems likely will lead to more homogeneous data and thus raises the chances of classifiers to find the shared characteristics between positive and negative instances, respectively.

second, we believe that advances could be achieved if methods considered additional background knowledge, for instance by adding them as features of the pair. this encompasses detailed knowledge on the proteins under consideration  and on the semantics of the terms surrounding them. for instance, some false positives pairs were found to contain two proteins that have nearly identical functional properties or that are orthologs. as such co-occurrences are less likely to describe actual interactions, a more informed approach could benefit from taking such aspects into consideration.

third, pattern-based methods, which are capable of capturing even exotic instances, might be worth looking into again. even early pattern-based methods are only slightly worse than machine learning approaches  <cit> , although those did not fully leverage advances which the nlp community has made especially in terms of telling apart “good” patterns from bad ones  <cit> . many difficult false positives turned out to be misinterpreted linguistic constructs like enumerations and coreferences. such constructs might be more appropriately dealt with by using linguistic/syntactical patterns. note, however, that some other pairs found in sentences with such constructs  were correctly annotated by all kernel methods in our assessment. combining intelligent pattern-selecting with semi-supervised methods for pattern generation  <cit>  seems especially promising.

abbreviations
ppi: protein–protein interaction; svm: support vector machine; rls: regularized least squares; pos-tag: part-of-speech tag; nlp: natural language processing; sl: shallow linguistic kernel; st: subtree kernel; sst: subset tree kernel; pt: partial tree kernel; spt: spectrum tree kernel; edit: edit distance kernel; cosine: cosine similarity kernel; kbsps: k-band shortest path spectrum kernel; apg: all-paths graph kernel; cv: cross-validation; cl: cross-learning; t: true; f: false; gt: ground truth; tp: true positive; tn: true negative; fp: false positive; fn: false negative; d: difficult; n: neutral; e: easy; nd: negative difficult; pd: positive difficult; ne: negative easy; pe: positive easy; dep: dependent; nn: noun compound modifier; appos: appositional modifier; conj: conjunct.

competing interests
the authors declare that they have no competing interests.

authors’ contributions
conceived and designed the experiments: dt, is, ul. performed the experiments: dt, is, pt. analyzed the data: dt, is, pt. wrote the paper: dt, is, pt, ul. all authors read and approved the final manuscript.

