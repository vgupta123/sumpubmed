BACKGROUND
to capture the behavior of an organism under different experimental conditions, we need a method that simultaneously study and compare the gene/protein expression level measured for different conditions   <cit> . high-throughput techniques like microarray  <cit>  and recently rna-seq techniques  <cit>  are used to measure mrna levels of all genes in the genome of a studied organism across a range of conditions of an experiment. in such high throughput data, instead of looking at the expression levels of each gene separately, it is more informative to look at the groups of genes coexpressed across conditions, since they may represent a biological process  <cit> . moreover, in a microarray data where conditions are time points, linking perturbed biological processes temporally can help us relating initial perturbed biological processes with the processes perturbed at later time points. a common method to extract such clusters from a high-throughput data is ‘clustering’  <cit> . another extension of such method is ‘biclustering’ which is useful to capture the genes that are correlated only in a subset of samples  <cit> .

many algorithms have been introduced since the year  <dig>  which extract groups of co-expressed genes and associated conditions of co-expression from a microarray data. few of them are cc algorithm  <cit> , isa algorithm  <cit> , bimax algorithm  <cit> , samba algorithm  <cit>  and qubic algorithm  <cit> . these algorithms require different input parameters for generating biclusters from high throughput microarray data. this is the first limitation of these algorithms. on a real dataset, it is difficult to know apriori about the values of these parameters to find the biclusters and hence, wrong input parameter may lead to wrong result. hence an algorithm with very less parameters, preferably no parameter, is expected to be more useful on real datasets. the second limitation of the existing algorithms is that none of them have been tested on the data  where the biclusters are overlapping in presence of noise. these algorithms were tested on synthetic dataset with implanted biclusters and real datasets with known biclusters and compared their performance to recover implanted or known biclusters  <cit> . the algorithms were evaluated on datasets with increase in noise levels. but, these synthetic dataset did not have any overlapping biclusters, which is very common in real biological data.

to overcome these two limitations, we introduce a new algorithm which uses only one parameter: depending on whether we want overlapping biclusters in the result or not. accordingly, we set the parameter equal to  <dig> for overlapping bicluster and  <dig> for non-overlapping. in our algorithm, we first discretize each gene and then group them based on their similar discretized profiles. finally, we select clusters  with high correlation coefficient and large size. these high correlation coefficient clusters along with the discretization information gives the biclusters with both genes and conditions. our method is similar to ‘correlation maximization biclustering methods ’ which seeks for subsets of genes and samples where the expression values of the genes  correlate highly among the samples   <cit> . other cmb algorithm such as cc algorithm  <cit>  also uses similar method to extract biclusters by imposing the condition that the mean square residue is below some threshold value δ.

in the present paper, we first introduce the algorithm and then show its performance on synthetic and real datasets. we then compare our algorithm with other existing algorithms from literature. finally, we show the application of our algorithm on a real biological dataset obtained from a mouse liver tissue.

methods
algorithm to find groups of co-expressed genes and conditions of co-expression
given a microarray mrna data matrix with n number of genes across c number of conditions, we need to find groups of co-expressed genes and the conditions of co-expression. we first started with each gene separately and determined the conditions where it is expressed. we used the idea similar to one proposed by  <cit>  where the whole set of expression values of a gene across conditions is used to determine whether the gene is perturbed or not. however, in  <cit> , the set of conditions where the gene is perturbed was not determined. to take care of this limitation, we modified the above idea by using the first difference formula  for each gene separately resulting in discretization of genes. we then grouped genes based on their discretization pattern resulting in clusters. the clusters with high correlation coefficient were further combined resulting in a set of clusters. we then described each obtained clusters by two parameters: cluster size  and correlation coefficient . next, we need to derive a cutoff on these two parameters to filter biclusters with high correlation coefficient and high size. for this, we considered a matrix of genes with expression randomly generated from a normal distribution with mean zero and a given variance. we calculated the values of these two parameters  using the biclusters obtained from this random matrix and derived a cutoff  on these two parameters, which is used to filter biclusters.

below, we are presenting the steps of the algorithm one by one in detail. for better understanding of the algorithm we are providing a small dataset example depicting application of each step of our algorithm. to enable readers to replicate our results, a small dataset example with its output bicluster results has been provided as additional file 1: file s <dig> and output of each step of our algorithm on dataset is depicted in additional file 2: figure: s <dig>  for reader’s benefit, the steps of the algorithm are presented in the following format as different functions as done in  <cit> .

step <dig> 
given a microarray mrna data for n number of genes across c number of conditions, we first normalized the data by dividing each gene by the square root of the sum of the squares of their expression across the conditions. to find groups of co-expressed genes and the conditions where this co-expression occurs, we first need to find the condition where each gene is expressed. for this, we used expression profile  of each gene separately, e.g. gene ‘a’ and identified the condition where gene ‘a’ shows high expression value relative to other condition. these condition are obtained by taking the consecutive differences of sorted absolute normalized expression profile of gene ‘a’. this helps us to identify the index with maximum difference. the condition corresponding to this identified index and all other indices above this index gives us the condition where the gene is expressed. this step is illustrated in fig. 1b and c for two genes with selected conditions circled in left panels and corresponding indices encircled in right panels. some more example genes are provided in additional file 3: figure s <dig>  this is the discretize function of the algorithm outlined in fig. 1a, which discretizes each profile  one by one to transform the data matrix to a discrete data matrix.fig.  <dig> outline of the algorithm. a flowchart of the algorithm is shown with different steps explained in text. b, c the discretize step of the algorithm is shown on two representative genes. here, the expression level of two genes at different conditions taken from an experimental data is plotted in left panels in b and c. in right panels, the sorted absolute normalized values of expression data for the two respective genes are plotted. arrows correspond to the point above which the expression values are characterized as expressed by the algorithm and the corresponding expression values are shown by circled values here and in actual expression data in left panels in b and c. this point is captured by taking the consecutive differences of sorted absolute normalized expression profile and identifying the index where this difference is maximum




step  <dig> 
once we have the discretized data, in the next step, we group them into different clusters using the group function. after discretizing each gene based on its expression values, we added the sign of expression i.e. positive or negative depending on its up or down regulation. then, we grouped genes with same signed discretized profiles into a cluster. each cluster is shown in a 2-d plot  by a point where its coordinates are size  and correlation coefficient .

step  <dig> 
this step of the algorithm generates cluster correlation matrix which is used to find cluster pairs sufficiently similar to each other and hence could be merged. we termed this step as correlation function. we used this step on the clusters  to get the cluster correlation matrix . the cluster coefficient matrix contains values of correlation coefficients within and between the clusters. here, we made negative correlation values zero to ensure that the corresponding pairs don’t come as correlated pairs. each row of this matrix contains set of correlation values of each cluster with all other clusters which we call correlation profile of the cluster. in the next step, we used the cluster merge check function on this correlation matrix to find cluster pairs with close correlation coefficients.

step  <dig> 
in this step we have three independent checkpoints which decides if two clusters can be merged for further analysis or not.

checkpoint <dig> 
in this step, we first discretized the cluster correlation matrix using our discretize function . this gives, for each query cluster, a set of clusters obtained after discretizing its correlation profile. we then selected those cluster pairs which are present in the discretized correlation profile of each other. say, for an example, we picked clusters x and y, if cluster y is present in the discretized correlation profile of cluster x, and vice-versa. thus, check  <dig> filters cluster pairs, as shown in the red dots in the matrix in fig. 1a .

checkpoint <dig> 
in this step, we multiplied the correlation profile for each pair of clusters  and discretize the product of correlation profiles of the cluster pairs. finally, we checked if the cluster obtained are same as the input cluster pair or not. if yes, then those two clusters are filtered through check <dig> function, as shown in red dots in the matrix in fig. 1a .

checkpoint <dig> 
here, for each pair of clusters, we checked if the average correlation coefficient between them is greater than the minimum correlation of each cluster with itself or not . if so, then that pair of clusters were filtered through check <dig>  as shown in red dots in the matrix in fig. 1a .

the cluster pairs satisfying all these three checks are termed as consensus clusters pairs and are merged using the next step of the algorithm called merge function.

step  <dig> 
in this step, we group the clusters pairs found above by taking the union of the genes and union of the conditions of the paired clusters. this gives us the merged clusters. this step of the algorithm that groups the cluster pairs is termed as merge function.

step  <dig> 
this step provides the user with a choice to get an overlapping bicluster. this step is termed as overlap function. here, the user chooses a predefined parameter , which gives them the choice to go for overlapping bicluster . if the user selects overlap parameter equal to  <dig>  then the biclusters are allowed to overlap and we go to the next step for final selection of cluster. if overlap is selected as zero, then we directly go to the next step for final selection of cluster.

step  <dig> 
in a real dataset, due to it complex patterns, normally we get clusters with different sizes and different correlation coefficients. the clusters with large size and high correlation coefficient will contain a large number of genes showing similar pattern and could be relevant in terms of some biological process. whereas, the clusters with small size and/or low correlation coefficient can be considered as the random clusters with very less or no functional relevance. so, in this step of the algorithm which we termed as select function, we separate the relevant clusters from the random ones by using a cutoff. to derive the cutoff, we first generated the clusters by applying our algorithm on randomly generated genes and checked their cluster size and correlation coefficient values. we then checked whether, the genes with expression values generated randomly from a normal distribution could form a cluster with large size and high correlation coefficient. for this, we built random data matrices, each of 1000 ×  <dig> dimension  where the gene expression values were generated from a normal distribution with mean zero and standard deviation equal to different noise levels. the same procedure was followed as given in section  <dig> , except that in this case no pattern was considered for the genes. we applied our algorithm on these 1000 ×  <dig> data matrices with three noise levels  and plotted the size and correlation coefficient of the resultant clusters in three subplots, see fig. 2a. in each subplot, results of the algorithm output for  <dig> different realizations of the input matrix were overlaid. we observed that with increase in the size of clusters, there was a decrease in the correlation coefficient and this pattern was same for all the input matrices generated with different noise levels, fig. 2a. since a major aim of the present study is to use minimum parameter, in order to filter relevant clusters from random clusters, so we used a straight line  as shown by green colored line in fig. 2a. we also used dataset with different number of genes and conditions to check how much this parameter is varying with size of input dataset. when we varied condition values upto  <dig> fold , we observed no change in the cluster size , but increasing gene values  and keeping condition values fixed, we notice increase in the cluster size . this implied that the parameter depends only on the number of genes in input dataset. thus, to get the parameters associated with the straight line to be independent of size of input dataset, we normalized the cluster sizes with a factor log , where n is the number of genes in the input dataset. the resulting straight line with normalizing factor is shown below:fig.  <dig> derivation of score cutoff of clusters. a for an insilco data with fixed noise level, the size and correlation coefficient of output clusters for each of the  <dig> runs from the algorithm are overlaid on each other and are shown in first subplot. three subplots correspond to three noise levels in input data matrices. and the cutoff line is shown in green. the clusters sizes and correlation coefficient plot doesn’t change much for different noise levels. b the value of c* as a function of number of conditions in input matrix is shown showing no significant change with number of conditions as shown by the fit with r2 =  <dig>  suggesting a good fit as straight line with slope zero and intercept as mean. c the value of c* as a function of number of genes in input matrix is shown showing no significant change of c* with number of genes as shown by the fit with r2 =  <dig>  suggesting a good fit as straight line with slope zero and intercept as mean


  <dig> y+logx/logn=c where y is the correlation coefficient, x is the size of the bicluster, n is the number of genes in the input matrix and c is the parameter that can be obtain using random matrix data.

since a real dataset contains unknown noise level, so we need to derive a threshold value for c , which is independent of the noise level. for a given random data matrix, applying the algorithm, we get say k numbers of biclusters, each having fixed x and y. we then calculated c using eq. for each x and y, and defined c¯=maxcii=1:k.


to obtain the value of parameter c* for a given n x c dimensional real dataset matrix, where n is the number of genes and c is the number of conditions, we first generated random data matrix of same dimension for a fixed noise level  and obtained c¯. we obtained  <dig> such c¯’s after generating  <dig> such data matrices and took c=maxc¯ii=1: <dig>  we repeated the above exercise for two more noise levels  and obtained required c
∗ = maxi = 1 :  <dig> 

finally, we need to check that the value of c* is independent of the number of genes and number of conditions of the input data matrix. we measured the value of c* using the input data matrices of different sizes as mentioned above . we fitted a straight line to the data of c* versus c  and obtained a fit with equation c* =  <dig> - <dig> e-4c with r2 =  <dig> . this low r <dig> value implies that the best fit straight line is the line with zero slope and an intercept equal to mean of the data. similarly, fitting a straight line to the data of c* versus n in fig. 2c gave a linear fit with r2 =  <dig> . this low r <dig> value again implies that the best fit line is the line with zero slope and an intercept equal to mean of data. thus, obtained c* is independent of the dimension of input matrix and hence can be used to filter the resultant biclusters.

correlation coefficient within and between clusters
correlation coefficient of a cluster with itself was calculated by taking pairwise dot product of normalized expression profiles of all its constituent genes. then, mean of the resultant set was taken. correlation coefficient of a cluster with another cluster was defined in similar way: taking dot product of normalized expression profiles of all pairwise genes i.e. one gene of the pair was taken from cluster  <dig> and the second gene of the pair from cluster  <dig> and finally, mean of the resultant was taken.

overlap between biclusters
till now, the algorithm gives different biclusters with no gene overlapping but samples can be overlapping. if the user allows the overlapping i.e. taking overlap parameter equal to  <dig>  we followed the following procedure resulting in biclusters with gene overlap too. for each query bicluster, we found bicluster  that contained samples of query bicluster. if the number of such resulting biclusters were greater than zero, then we took the union  of genes  of query and resulting biclusters to create an overlapping bicluster. if we didn’t find any biclusters, we searched for biclusters  whose samples were subset of samples of this query bicluster. if the union of samples of resulting biclusters is smaller than that of query bicluster, we include query bicluster in the list of overlapping biclusters. this procedure was repeated for each query bicluster.

generation of insilco data
a matrix of zeros was created with  <dig> rows and  <dig> columns denoting  <dig> genes and  <dig> samples respectively with 1st  <dig> genes upregulated at 1st  <dig> samples i.e. expression value of these genes at these samples is  <dig>  similarly, the next  <dig> genes are up at next  <dig> samples. this was repeated and we get a pattern of 10 ×  <dig> sub matrix block at the diagonal of the original matrix. these  <dig> x  <dig> sub matrix blocks represent ideal biclusters to be used to calculate recovery and relevance scores. then normal distributed random numbers with mean  <dig> and standard deviation as per the noise levels given in text were added to the matrix to generate the final matrix. same procedure was followed for the case where biclusters were overlapping; the expression value at overlap region remaining  <dig>  for data with zeros noise and non-zero noise with overlapping clusters, we used a  <dig> x  <dig> matrix. for data with non-zero noise and non-overlapping clusters, we used 100x  <dig> matrix with ten  <dig> x  <dig> blocks at diagonal of matrix.

assembling real data
the real data was collected from human gene expression data series in ncbi geo database  with geo accession gse <dig>  it contains expression of all genes of human across  <dig> normal tissues. tiger database  <cit>  was used to collect the tissue specificity information of each gene. only genes unique to a particular tissue were used resulting in gene tissue relationship and expression profiles of the genes belonging to brain, colon, heart, kidney, liver, placenta, and testis were used for analysis. the cancer dataset was taken from gds <dig> 

processing of microarray data
the microarray data were obtained from an experiment where one group of mice were fed with high fat high sucrose diet   and another group with normal diet  for certain days before taking tissue samples from both the groups of mice. both groups of mice were fed respective diets in the following days: day <dig>  day  <dig>  day  <dig>  day  <dig>  week  <dig>  week  <dig>  week  <dig>  week  <dig>  week  <dig>  week  <dig> and week  <dig>  this experiment was repeated for three times. then, microarray experiment was performed on tissue samples and after suitable normalization of the signal intensities of each probe using agilent genespring gx software, three values of log fold change for the control sample and the treated sample were obtained for each probe and at each time for each tissue. further details of the experiment are given in  <cit> .

this data for liver tissue was downloaded from the ncbi repository under geo accession number gse <dig>  the data also contains information about data pertaining to mice fed with high fat high sucrose diet plus an ayurvedic formulation which is out of scope from our present study. the data of the ayurvedic formulation corresponds to the columns with columns header “p2_hfx_y “ and were removed. the column headers have information of the time point of the experiment in days as well as weeks. weeks were recorded in the experiment as the number of weeks after day  <dig>  thus, 14 days were added while converting weeks to days. this implies day  <dig> and week  <dig> would correspond to same time and thus the information of the day  <dig> and week  <dig> was combined in the final matrix. so, the final time points in the matrix are day  <dig>  day <dig>  day  <dig>  day  <dig>  day  <dig>  day  <dig>  day  <dig>  day  <dig>  day  <dig>  and day  <dig> 

for each probe, the means of the log fold change for treated samples were calculated and a p-value signifying difference between three control values and three treated values by t-test was generated. the data contains  <dig> probes corresponding to  <dig> gene symbols. gene symbol information for each probe was taken from column with column header “gene symbol”. there can be multiple probes corresponding to a gene. we used the following steps to obtain a single value for each gene:step  <dig>  first, we filtered the data to have only those genes whose absolute values are changed for at least  <dig> fold in all three treated samples at a time point i.e. whose values  are lying outside the interval  and considered them significantly perturbed genes. in case two probes corresponding to the same gene satisfy this condition, the probe with minimum p-value was chosen. we repeated this process for data at different time points and combined  all filtered genes to form a matrix of filtered genes and time points. the matrix elements are fold change values of all filtered genes inserted at respective time points. if a gene is not significantly perturbed at some time point, then the matrix element of that gene at that time point will be empty. for these genes, we used the following steps to insert values at these time points.

step  <dig>  for the selected genes with empty matrix element at some time point, we check its probe’s fold change value at all three samples. if all these values are outside the interval , we select those probes and go to step  <dig>  if no probe of the selected gene satisfies the above criteria, we then select the probes which would have values at all three samples within the interval  and go to step  <dig> 

step  <dig>  the selected probe’s average over three samples were taken if in all three cases the value is greater/less than  <dig>  if multiple probes of a gene satisfied this condition, probe with minimum p-value was chosen. if no probe out of selected probes satisfies this condition, the probe’s average value over two  samples with value greater/less than  <dig> was taken. for multiple probes satisfying this condition, probe with minimum p-value was taken. for the probe chosen, if the average value lied between − <dig>  to  <dig> , then for simplicity we inserted a number  <dig>  in the matrix, else the average value was inserted.




the resulting matrix contained log fold change values at eleven time points. we combined day  <dig> and week  <dig> information in the following way. if a gene is significantly perturbed  for both time points, then we took the average value. if they are perturbed in opposite directions, we assigned a small number  to that gene. if the gene’s value is perturbed at only one time point, we used that value in the matrix. if it is unperturbed at both the time points, we assigned any one of the non-perturbed value in the matrix. in the resulting matrix of  <dig> time points, if a gene is not perturbed even at a single time point, it is removed.

the resulting matrix contained log fold change values at ten time points for  <dig> genes. the matrix was clustered using default clustergram function of matlab which uses algorithm of eisen et al.  <cit>  resulting in heatmap shown in fig. 5a.

RESULTS
benchmarking the algorithm
here, we have benchmarked our algorithm based on two scores: recovery and relevance scores. the scores were compared with best performing algorithms  like isa  <cit> , bimax  <cit> , qubic  <cit> , samba  <cit>  and cc algorithm  <cit>  algorithm  <cit> . though there exist other algorithms in the literature like jaisri et al.  <cit>  and tesson et al.  <cit> , but these are not considered in the present study as jaisi et al.  <cit>  have applied normal clustering algorithm and tesson et al.  <cit>  finds differential co-expressed modules between two conditions only. for this benchmarking exercise, we used two synthetic datasets and two real datasets. in the synthetic dataset <dig>  instead of using the select function to filter biclusters, we used all clusters. select function is more useful in complex datasets to filter off clusters of small size and low correlation coefficient, for example, in clusters containing noisy genes. application of this is shown in section  with synthetic dataset <dig>  for the two real datasets, we used the first as the tissue dataset obtained from gse <dig> and second as the cancer dataset from gds <dig>  bimax algorithm was run using bicclust r package  <cit> . qubic algorithm was run in r by importing the package  <cit> . isa and cc were run in bicat package  <cit>  while samba was run using expander  <cit> .

synthetic dataset 1
we used the same strategy as mentioned in eren et al.  <cit> , where biclusters were implanted in a background noisy matrix and the ability of different algorithms were evaluated to recover implanted biclusters. here also we implanted overlapped biclusters, with different degree of overlap, in a background noisy matrix . synthetic datasets are shown in fig. 3a where actual/implanted biclusters are clearly visible. we applied different algorithms  on synthetic datasets and generated the output biclusters. comparing the output biclusters with the actual implanted biclusters, we obtained two scores quantifying ability of the algorithm to recover known biclusters and also the relevance of obtained biclusters.fig.  <dig> application of algorithm to insilco data and comparison with other algorithms. a a schematic showing different insilco datasets on which algorithms are applied. different datasets had different levels of noise and overlap degree. b comparison with other algorithms when applied on insilco datasets as shown above. both rows contain different graphs when algorithms are applied on different datasets with increasing noise levels . in first row, in each graph recovery of biclusters score is plotted as a function of overlap degree of biclusters in datasets on which algorithm is applied. lower row contains graphs where relevance of biclusters score is plotted. cg algorithm performs better in each scenario. in the recovery graphs, qubic and bimax algorithm overlap completely with cg algorithm and can’t be seen here. similarly, in the relevance graphs, qubic algorithm overlap completely with cg algorithm  and hence can’t be seen here




we used a score s comparing two bicluster sets m <dig> and m <dig> as given in eren et al.  <cit> : sm1m2=1m1∑b1∈m1maxsb1b2b2∈m <dig> where |m
1| is the number of biclusters in bicluster set m
 <dig> 

here, s is chosen to be the jaccard coefficient applied to matrix elements defined by each biclusters as given in eren et al.  <cit> :


sb1b2=b1∩b2b1∪b <dig> 

where |b
1 ∩ b
2| is the number of elements in intersection of two biclusters i.e. number of intersecting genes x number of intersecting conditions common between two biclusters b
 <dig>  b
 <dig> and |b
1 ∪ b
2| is the number of elements in their union. s takes values between  <dig> and  <dig>  where  <dig> means two biclusters are disjoint and  <dig> means biclusters are identical. any score between  <dig> and  <dig> is the fraction of total elements shared by both biclusters.

let e be the set of actual biclusters and f be the set of output biclusters from the algorithm. recovery score is calculated as s; its maximum value being  <dig> implies e ⊆ f i.e. algorithm has captured all the ideal biclusters. relevance score is calculated as s; its maximum value being  <dig> implies f ⊆ e i.e. all found biclusters were true biclusters.

for a dataset of fixed noise levels and fixed overlap degree, we generated  <dig> data matrices, and on each data matrix we applied different algorithms to capture biclusters. as a control, we first obtained actual biclusters from the data matrices before adding noise . we then compared the resulting biclusters with the actual biclusters and calculated scores using the above formulas. thus, for each fixed noise level and overlap degree, we obtained  <dig> recovery and relevance scores for each algorithm. we then took their mean. these mean values obtained for matrices of different noise levels and overlap degrees were plotted in fig. 3b. from fig. 3b, it is clear that our algorithm ) performs better than other algorithms in all cases except in case of qubic algorithm where it performs equivalent to qubic algorithm. for noise =  <dig> , the relevance of cg algorithm is slightly low. in this case, the extra biclusters found by the algorithm can be removed by using the select function of the algorithm and the relevance can be improved as shown in next section.

synthetic dataset 2
to show the importance of the select function in improving the relevance of the obtained biclusters, we here considered a more complex dataset. we used an input dataset similar to fig. 3a with different overlap degrees and a fixed noise level =  <dig>  . we added same number of noisy genes as in the original matrix and the resulting matrices are shown in additional file 5: figure s4a. for each data matrix of fixed overlap degree, we applied our cg algorithm with and without the above select function and compared with qubic algorithm. we then obtained  <dig> recovery and relevance scores corresponding to  <dig> runs and calculated their mean values. we obtained such mean scores for data matrices with different overlap degrees and plotted them in additional file 5: figure s4b. the results clearly suggest that the recovery scores do not change with the select function but there is an increase in relevance scores after applying select function and is now much better than qubic algorithm. we want to mention here that we obtained recovery scores is close to  <dig>  even in the presence of noisy genes. this suggests that we have successfully filtered pure biclusters. next, we tried to understand why this is happening. for this, we applied our algorithm on a matrix containing  <dig> genes in  <dig> conditions with expression values generated from a normal distribution with mean zero and standard deviation equal to the noise level =  <dig> . we checked the number of genes present in each biclusters and plotted them against the number of conditions associated with the corresponding bicluster. we observed that with the increase in the number of conditions in a bicluster, there is a decrease in the size of that bicluster . this clearly suggests that there is a less chance of obtaining a bicluster having more than  <dig> genes and  <dig> conditions. thus, the chance of presence of noisy genes in a well-defined bicluster is very less, which is also observed in the high recovery scores we obtained in additional file 5: figure s4b.

real dataset 1
for real datasets, we followed the methodology mentioned in oghabian et al.  <cit> . here, we considered predefined biclusters and then evaluated the ability of different algorithms to recover these predefined biclusters. we used the tiger database  <cit>  which contains tissue specific gene list. therefore, here, our actual biclusters are defined by tiger database. we also downloaded the expression levels of all human genes across all tissues as profiled by microarray . from this matrix of expression values, we selected only those genes whose tissue specificity is mentioned in tiger database. therefore, we have a matrix of expression levels of these genes specific to different tissues. the resulting matrix of genes versus tissues is shown as heatmap in fig. 4a where we can visually identify the biclusters . here also we followed the same procedure as done for synthetic dataset. figure 4c shows the individual recovery scores for each algorithm and here also we can observe that cg algorithm performs the best.fig.  <dig> application of algorithm to real data and comparison with other algorithms. a a heatmap showing expression levels of genes across tissues. b actual biclusters according to classification from tiger database are shown as gray rectangles along diagonal of matrix. c for each algorithm,  <dig> dots are shown which correspond to  <dig> actual biclusters. dots represent the maximum similarity of each actual bicluster when compared with biclusters found by algorithms i.e. individual recovery scores. average of these  <dig> scores gives net recovery score. d plot same as in  except the input dataset used is the cancer dataset as explained in text and recovery scores to recover cancer samples are calculated




real dataset 2
as a final benchmarking of our algorithm, we used a real dataset from the breast tumor dataset gds <dig> and compared our algorithm’s performance with performance of other algorithms. the dataset and the comparison strategy is similar to one used in oghabian et al.  <cit> . the dataset contains  <dig> samples where  <dig> samples are normal and the rest are breast tumor samples. the data was log <dig> transformed before the application of algorithms. the comparison strategy briefly consists of calculating the ability of different algorithms to differentiate the two sets of samples. this was done by calculating, for each algorithm, the individual recovery scores as given in section  <dig> . <dig>  except here term implies the number of conditions common to both biclusters and term implies the number of conditions in their union. here, the two actual biclusters are: first bicluster contains all genes with first  <dig> conditions corresponding to normal samples and the second bicluster contains all genes from 25th to 42nd conditions. the output biclusters are biclusters obtained from respective algorithms. the individual recovery scores are plotted for each algorithm in fig. 4d. here also, we observed high recovery scores for the cg algorithm in comparison to other algorithms proving its better performance in differentiating the samples.

application of the algorithm on a mouse liver microarray data
after benchmarking our algorithm against predefined biclusters in both synthetic and real datasets, here we will show its application on a real microarray dataset obtained from liver of a mouse fed with high fat high sucrose diet  for different times  . the microarray data matrix contains log fold change gene expression values for mice under hfhsd fed condition in compared to normal diet condition at different time points. heatmap of the microarray data matrix is shown in fig. 5a with genes clustered using clustering algorithm  <cit> . some groups of co-expressed genes are clearly visible along with relevant time points, for example, group of genes going up at 8th time point. one can expect metabolic related processes to be perturbed in the data which can be extracted from biclusters as significant processes represented by genes belonging to the biclusters. to filter noisy biclusters that might be present in the data, we used the select function of the algorithm on the resultant biclusters. we calculated the value of c*  for n =  <dig> genes and  <dig> conditions. the obtained value of c* of  <dig>  , which is very near to the predicted value of c* = <dig>  . this proves our claim  that the mean value of c* =  <dig>  can be used for any new dataset without explicitly using random matrix data. using this c*, we filtered  <dig> clusters from a total of  <dig> clusters obtained from the algorithm . as an example, we have shown time profiles of genes from two specific clusters . the biological processes significantly represented by topmost clusters  clearly show that metabolic related processes confirming the result as expected on the basis of the experiment. finally, to check whether the clusters found by the algorithm are not random, we checked the distribution of the cluster sizes. we observed that the cumulative distribution of cluster sizes follows power law , i.e., few clusters with large sizes and large number of clusters with small size. this distribution remains same for the selected clusters too, see additional file 8: figure s <dig>  this result is well accordance with other studies, which also observed power law in cluster size distribution  <cit> . when we plotted distribution for randomly formed clusters  and total cluster size  constant), we observed that it doesn’t follow power law . so, the power law distribution confirms that the grouping done by the algorithm is biologically relevant and not random.fig.  <dig> application of algorithm on a real dataset. a a heatmap showing expression levels of genes across time is shown where some cluster of genes up at specific time points can be clearly observed. b correlation coefficient and size of each cluster is shown with two specific clusters’ time profile shown as illustration in below insets. c power law observed in cluster size distribution with slope of − <dig> with s between  <dig> to  <dig> with r <dig> of . <dig>  randomly formed clusters behave very differently from the original distribution and thus suggests biologically relevant clustering by the algorithm





discussion
biclusters play an important role in extracting information from the microarray data, particularly in case if it contains temporal dimension. this can help in elucidating processes perturbed during the experiment under different conditions and can give us mechanistic insights. to extract such biclusters from a microarray data using an algorithm whose input parameters are data independent is a challenging task. in this work, we have developed an algorithm which uses just one user input for generating biclusters. for this, we primarily used the whole time profile of a gene to find the conditions where a gene is expressed. this is similar in concept where the whole time profile of a gene is used to find whether the gene is perturbed or not  <cit> .

in the present study, we have introduced an algorithm to find groups of co-expressed genes and conditions of co-expression. the first advantage of our algorithm is that it is general enough to be used on any kind of high throughput data matrix. it can give output biclusters as overlapping set or as non-overlapping set depending on the choice of the user. default mode is selecting all biclusters and overlap is allowed. this default mode was used everywhere in our study except in section using synthetic dataset  <dig> and in section with liver and cancer data. in these cases complicated biclusters could come and so it is easier to analyze them as non-overlapping sets. second advantage is that cg algorithm also doesn’t use any parameter like score cutoff etc., as used by other algorithms. this we could attain by combining the discretization step with the grouping step and hence a single parameter can be used to filter biclusters rather than two parameters usually required for these steps. finally, applying our novel method of using random matrix data, we have even removed the dependency on this single parameter making our algorithm parameter independent for filtering biclusters.

our algorithm discretizes the data without any threshold parameter and gives better results than other algorithms in both synthetic and real datasets as shown by our recovery and relevance analysis. we wanted to explore if we can enhance the performance of our algorithm by applying fixed cutoffs like  <dig> fold log change or z-score cutoff  <cit>  in our discretization function. for this, we took a real liver microarray data used in our study and applied a  <dig> fold cutoff to discretize the data. on plotting the normalized distribution of discretized and non-discretized data, we observed better separation of values in our method as compared to  <dig> fold cutoff method  > tstat) . we further generated clusters using both the methods to see which one is giving more correlated clusters. we found that the clusters obtained using  <dig> fold cutoff method had significantly less correlation coefficient  as compared to clusters generated using the discretize function of our algorithm . next, we compared with z-score cutoff discretization method. for this, we calculated the mean and standard deviation of the expression value of a given gene under different conditions and took the z-score cutoff of + − <dig>  to discretize the data and generated clusters. here also we found that the clusters obtained using z-score cutoff method had less correlation coefficient as compared to clusters generated using the discretize function of our algorithm  . thus, our threshold free discretization method shows better performance than existing fixed cutoff methods.fig.  <dig> comparison with other discretization approaches a the actual fold change and normalized distribution of discretized and nondiscretized values obtained by applying a  <dig> fold cutoff and our discretize function on the real liver microarray data b correlation coefficient and size of clusters obtained by applying our algorithm on discretized data obtained by using  <dig> fold cutoff method and our discretize function. the distribution of correlation coefficients of clusters is also shown. c correlation coefficient and size of clusters obtained by applying our algorithm on discretized data using our discretization method and zscore cutoff method. the distribution of correlation coefficients of clusters is also shown




here, we derived the score cutoff for the clusters from a matrix by comparing it with randomly generated matrices of same dimension. this means we are deriving score cutoff of clusters assuming all the genes in the original matrix are behaving randomly. this is a very conservative estimate, since in a normal data matrix, all genes won’t be behaving randomly and there would be genes with some definite pattern that would be captured by our algorithm. so, we can safely say that the selected biclusters from the algorithm are not random and are biologically relevant. the algorithm can be applied to any microarray data or other high throughput data like proteomics data to find biclusters.

since, we have shown that our proposed algorithm performs better in comparison to other algorithms on the dataset with unknown noise levels, so it is expected that the present algorithm will definitely perform better on a dataset with known noise level. biclusters generated from the algorithm, when integrated with transcriptional networks can help finding transcription factors driving such expression patterns. also, the selected clusters from two or more microarray datasets can be compared to reveal similarities/differences among the patterns followed by genes of two datasets.

CONCLUSIONS
biclusters present in a high throughput data is important information to be extracted to find the underlying patterns present in the data. available biclustering algorithms use many input parameters to find biclusters. since, on a real dataset, it is difficult to know apriori about the values of these parameters and hence, an algorithm which uses minimum input parameters is highly desirable. we proposed here an algorithm clustered groups, which find groups of co-expressed genes and conditions of co-expression. despite requiring only a single input parameter, we have shown that our algorithm still works better than other existing algorithms. the algorithm can be used to find such groups in different data types such as microarray , proteomics, metabolomics etc.

additional files

additional file 1: the matlab code of the algorithm made in the study. contains the input example small dataset and the output resultant biclusters obtained by application of algorithm on the given small dataset. 


additional file 2: figure s <dig>  shows the heatmap of the small dataset example and output of each step of our algorithm when applied on this dataset. 


additional file 3: figure s <dig>  representative examples of gene expression profiles of  <dig> genes and their discretization.  the discretize step of the algorithm is shown for eight representative genes. here, the expression level of genes at different conditions taken from an experimental data is plotted in left panels. in right panels, the sorted absolute normalized values of expression data for the respective genes are plotted. arrows shows the jump above which the expression values are characterized as expressed by the algorithm and the corresponding expression values are shown by circled values here and in actual expression data in left panels in a. this jump is captured by taking the consecutive differences  of sorted absolute normalized expression profile and identifying the index where this difference is maximum i.e. where jump occurs. 


additional file 4: figure s <dig>  simulations with varying number of genes and conditions. in each of the plot, results for all noise levels and all runs of a fixed dimension input matrix are shown in one plot  each plot depicts the clusters obtained for three noise levels for input matrices of number of genes =  <dig> and number of condi-tions equals as given on top of each plot. the value of c* is also shown on the top of each plot. the cluster distribution doesn’t change much with different conditions.  each plot depicts the clusters obtained for three noise levels for input matrices of number of number of conditions =  <dig> and number of genes equals as given on top of each plot. the value of c* is also shown on the top of each plot. the cluster distribution change and goes towards high cluster size as number of genes in input matrix increases. 


additional file 5: figure s <dig>  ability of select function to improve relevance of output biclusters  data matrices of size  <dig> ×  <dig> to  <dig> ×  <dig> are made corresponding to over-lap degree of  <dig> to  <dig> same as in fig.  <dig>  here, highest noise level of  <dig>  is used.  average recovery scores and average relevance scores for a data matrix of fixed overlap degree corresponding to  <dig> runs are calculated and mean scores are plotted in figures for qubic algorithm and our algorithm with/without select function. no change in recovery scores can be observed and an in-crease in relevance scores are obtained for algorithm with selelct function as compared to without select function. 


additional file 6: figure s <dig>  for a matrix with  <dig> genes and  <dig> conditions with expression values of all genes across conditions obtained from normal distribution with mean zero and standard deviation =  <dig> , cg algorithm was applied and number of genes of each bicluster is plotted against number of conditions of the corresponding bicluster. as the number of conditions in a bicluster increases, its size decreases. this suggests very less probability of obtaining a large size bi-cluster with large number of conditions. 


additional file 7: figure s <dig>  the value of c* as a function of number of genes in the input data matrix. the value of c* for number of genes =  <dig>  predicted using the mean values is  <dig>  which matches with that ob-tained using actual simulation .  cluster distribution shown using simulation gives value of c* =  <dig> . here, cluster’s correlation coefficient and size obtained for  <dig> runs of input data matrix of a fixed noise level are overlaid on top of each other. the cluster’s correlation coefficient and size obtained for input data matrices of two other noise levels are also overlaid here. 


additional file 8: figure s <dig>  power law observed in cluster size distribution using only selected clusters shows slope of − <dig>  of s between  <dig> to  <dig> with r <dig> of . <dig>  




abbreviations
bicatbiclustering analysis toolbox

bimaxbinary inclusion-maximal biclustering algorithm

cccheng and church’s algorithm

cgclustered groups

expanderexpression analyzer and displayer

isaiterative signature algorithm

qubicqualitative biclustering

rnaribonucleic acid

sambastatistical-algorithmic method for bicluster analysis

tigertissue-specific gene expression and regulation

