BACKGROUND
repetitive sequences are abundant in bacteria and archaea, accounting for close to 5% of the genome size in many organisms  <cit> . these repetitive sequences come in various forms/sizes and may be found dispersed throughout a genome, clustered in close proximity or arranged contiguously. the identification of repeats has proven to be of significance, as they provide insight into the functional and evolutionary roles of various organisms  <cit> .

this study centers on a recently recognized family of repeats known as clustered regularly interspaced palindromic repeats . since their description by mojica et al.  <cit> , crisprs have attracted a great deal of interest  <cit> . crisprs have been found only in the genomes of prokaryotes and are composed of short direct repeats currently known to range in sizes from  <dig> –  <dig> base pairs. this family of repeats is unique in that they are interspaced by non-repeating sequences of similar size. crisprs were found in approximately 40% of bacterial genomes investigated  <cit> . of those genomes with crisprs present, about one half contained multiple crispr loci. the average number of repeats per loci was found to be  <dig>  with an average repeat length of  <dig> base pairs. although knowledge of the characteristics of crisprs continues to grow, their complete function is still not yet known. one recently verified hypothesis, however, is that they defend against invading viruses  <cit> .

several software applications are available for identifying various forms of repeats. however, because the focus on crispr elements is recent, only one crispr-specific tool has been published for their automatic detection  <cit> . identification based on generic repeat searching applications such as patscan  <cit>  require considerable manual post-processing. in this study, a new tool for the automatic detection of crispr elements is presented. this software program, crispr recognition tool , uses a simple sequential search technique that detects repeats directly from a dna sequence. unlike most repeat detection techniques, the algorithm presented in this paper does not rely on the use of the suffix tree or alignment matrix as a central data structure. instead, repeats are discovered directly from the dna. as a result, this technique is very efficient in terms of memory usage, and it is much easier to understand and implement than most other methods. despite its simplicity, the presented algorithm is able to achieved impressive execution speed when compared to other repeat detection tools.

implementation
crt's search for crisprs is based on finding a series of short exact repeats of length k that are separated by a similar distance and then extending these exact k-mer matches to the actual repeat length. the value of k should be small and less than the length of the shortest repeat to be detected. by making k small, string comparison is faster and the likelihood of finding exact matches between approximate repeats is increased. once actual repeats are found, they are filtered to remove those that do not meet crispr specific requirements.

searching for exact k-mer matches
the algorithm begins its search for repeats with a left-to-right scan of a sequence using a small sliding search window of length k. the value in the search window represents a candidate repeat, and each time the window reads a new k-mer, the algorithm searches forward for exact k-mer matches. when searching for each successive match, the search space can be restricted to a small range, called search range. given a k-mer that begins at position i, any exact k-mer match, if one exists, should occur in the range:

  

here, minr and maxr refer to the lengths of the smallest and largest repeats to be detected. the lengths of spacers, which are the similarly sized non-repeating regions between repeats, are referred to by mins and maxs . since crisprs are to some degree evenly spaced, the distance between the initial repeats can be used to approximate the spacing between subsequent exact k-mer matches. thus the size of the search range can be reduced further, resulting in faster processing time.

the size of the search range has a direct effect on the processing time of the algorithm, with smaller ranges being more desirable. thus, the algorithm runs fastest when there is little variation between the sizes of the smallest/largest repeats and the smallest/largest spacers.

if exact k-mer matches are found
the search described above detects a succession of similarly spaced repeats of length k. since these repeats do not represent the true length of the repeating pattern, they must be extended  to the actual repeat length. any method for extending repeats must consider that mutations occur in dna sequences, so, repeats may not be exact. the approach taken is this paper is to read the characters to the left or right of all repeats and compute occurrence percentages for each base, acgt. if there is a character that has an occurrence percentage greater than or equal to some preset value, p, the repeats are extended. for example, if extending left, a p value of 100% extends exact k-mer matches to exact -mer matches only if the character to the left of all repeats within the crispr is the same. thus, for p = 100%, exact repeats are detected, while lower values allow for the detection of approximate repeats. this method of extending repeats works well for crisprs, give an appropriate value for p .

if no exact k-mer matches are found
if no exact k-mer matches are found, the search window advances forward and the process described above is repeated. the search window can actually advance forward in intervals greater than one without missing any repeats. the size of this interval is one of the major factors contributing to the speed of the presented algorithm.

the key to being able to advance at greater intervals is guaranteeing that the search window will never skip any repetitive sequence during its traversal of the dna sequence. that is, the interval at which the search window advances must be small enough that the entire window will  fall entirely within each repeat. the length of this interval is dependent on the size of the search window, k, and the length of the smallest repeats to be identified, minr. it can be computed as follows.

 interval = max {minr - , 1} 

longer repeats produce larger intervals, as do smaller search windows. larger intervals result in significant improvements in speed because less data is analyzed. for example, for minr =  <dig> and k =  <dig>  the search window can skip  <dig> positions each time it advances. thus, processing a dna sequence of length  <dig> , <dig>  for the most part, becomes equivalent to processing a sequence of length  <dig> ,000/ <dig> .

although smaller search windows improve processing speed, if continuing to reduce their size, the speed of the algorithm may at some point worsen. this is because smaller search windows increase the likelihood of the program finding short repetitive sequences that are not really part of a true crispr element, but happen by chance. this will cause the program to spend more time processing repeats that are actually false positives. as an example, for a search window of length k =  <dig>  there is a 1/ <dig> chance that any 3-mer will be a match to the search window. this assumes that all four bases are equally likely to appear at any position.

filtering
many of the candidate crisprs found from the process described above will either be contiguous repeats or repeats with incorrect starting and/or ending positions. to remove unwanted repetitive sequences, filters are applied. the first filter checks that the candidate crispr is composed of short repeats . if that condition is met, the spacers are checked for being non-repeating and similarly sized. filtering is fast because most repetitive sequences do not make it deep into the process. also, when testing for similarly sized/non-repeating spacers, it is only necessary to check the first few spacers of the crispr.

the final part of program checks the left and right flanks of a crispr in case repeats were missed because of too many mismatches. the flank check is less strict than the initial search for repeats in that it does not look for short exact matches. instead, the discovered repeats within the crispr are used for comparison  to detect any nearby approximate repeats. the flank check is important for two reasons. the likelihood of missing repeats with mismatches increases when advancing the search window in intervals. furthermore, according to jansen et al.  <cit> , the last or last few repeats of crisprs contain mutations in most organisms, and about one-third of crisprs have the last repeat truncated.

time and space
the crt algorithm moves a search window through a sequence in intervals, at each step scanning the search range for the pattern in the search window. searching for a pattern in a text can be done using any fast search algorithm. the boyer-moore  <cit>  string-matching algorithm is used here. it is linear in time . thus, the running time of the algorithm for finding crisprs as described in this paper is o, where n is the length of the dna sequence, m is the length of the search range and l is the interval at which the search window advances.  the algorithm is also linear in space, since repeats are detected directly from the input sequence with no additional major structures required.

RESULTS
crt , pilercr   <cit>  and patscan  <cit>  were compared based on execution speed and ability to correctly identify crisprs. patscan is a generic pattern discovery application that identifies repetitive sequences given a user-specified input pattern. the number of repeats that patscan detects must be predefined, and the tool has no mechanism for distinguishing repeating and non-repeating regions of crisprs. thus, considerable manual processing of the output is required in order to remove unwanted results and to extend repetitive sequences beyond the fixed size limit set by the input pattern. pilercr is a recently developed tool designed specifically for the automatic detection of crispr elements. it is based on the piler  <cit>  program, which utilizes alignment matrices for detecting contiguous repeats.

both patscan and pilercr were implemented in the c programming language. crt was developed using java. all tools were tested on finished microbial genomes available in the img version  <dig>  database  <cit> . each was run under cygwin version  <dig> . <dig> on a pc having the following specifications: windows xp operation system, pentium  <dig>  ghz processor,  <dig>  gb ram.

speed evaluation
figures  <dig>   <dig> and  <dig> show the execution times of the three tools. the x-axis contains the accession number for the analyzed organisms followed by their approximate number of base pairs in millions . as the number of repeats may affect execution time, only genomes with similar repeats counts were used . figures  <dig> and  <dig> are based on a search with repeat size  <dig> –  <dig>  spacer size  <dig> –  <dig>  and minimum number of crispr repeats  <dig>  crt required an additional setting for search window length. it was tested for values  <dig> and  <dig>  figure  <dig> shows results when searching for longer repeats of size  <dig> –  <dig> and spacer size  <dig> –  <dig> . patscan is not included in this figure, or any subsequent figures, because it's extended running times flattens the other graph lines, making it difficult to compare the other tools .

the speed of crt and pilercr is very impressive and a huge improvement over the previous technique of crispr detection using patscan, as shown in figures  <dig> and  <dig>  crt achieves the best performance, being able to process a dna sequence of nearly  <dig> million bases in about  <dig> seconds using a search window of size  <dig>  crt, and in about  <dig> seconds for a search window of size  <dig>  crt.

in the previous example, execution speed was analyzed based on increasing genome size. in figure  <dig>  speed is analyzed for increasing number of repeats. only genomes of similar sizes were used . the repeat size is  <dig> –  <dig> and spacer size is  <dig> –  <dig>  the figures show that crt performs better than pilercr for larger number of repeats. like pilercr, whose speed appears to be independent of the size range of repeats, crt's speed is independent of the number of repeats contained in a genome. actually, crt improves slightly in processing time as the number of repeats increases. this is because it is able to process sections of a sequence containing repeats very fast, as explained in the previous section.

retrieval evaluation
in order to assist in determining the effectiveness of the three tools in identifying crispr elements, three evaluation measures were used: quality, precision and recall.

quality
detected crisprs are sometimes inconsistent with their actual form in a sequence. this generally results because dna repeats are not always exact, and consequently are often difficult to correctly identify. three common types of inconsistencies were identified in this study. type i inconsistencies occur when a tool reports a crispr that is incomplete . type ii inconsistencies occur when repeats within a crispr do not begin and/or end at the correct position. for example, a crispr that actually begins with the sequence gtttac may be reported as beginning with tttac. in this case, it can be seen that the reporting tool is off by one position. type iii inconsistencies occur when a crispr is split. for example, a single crispr containing  <dig> repeats may be reported as two crisprs, each containing  <dig> repeats.

let quality represent the likelihood that a crispr reported by a search tool does not contain an inconsistency of type i, type ii or type iii. based on this definition, there is no distinction between a crispr with one inconsistency and a crispr with three inconsistencies. given the set of crisprs resulting from a search, let a be the total number of crisprs reported and b be the total number of crisprs containing at least one inconsistency. assuming a >  <dig>  quality  for a search tool can be computed as follows.

 q=1−ba
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbamxvp5wqsxmqhnxajn0bkvguhdwzzbqegyvzyrwyufgarqqtubsr4rnchbgeagqia8vkikvafgielifelkfelk=iy=hhbbf9v8qqaqfr0xc9pk0xbba9q8wqffeay=bilkvclq=jhqvepeea0=as0db9vqpepesp0xe9fve9fve9gapdbaqaaegacagaaiaabeqaamqadiabaagcbagaemycaenaeyypa0jaegymaejaeyoei0yaasaaaeaacqwgibgyaeaacqwghbqyaaaaaa@43e1@ 

precision and recall
quality alone is insufficient for measuring performance, as it does not consider the cost of failing to retrieve relevant crisprs or the cost of mistakenly retrieving instances that are not crisprs. for evaluating inconsistencies of these types, precision and recall are used.

precision and recall are measures commonly used in the field of information retrieval  when evaluating search algorithms. their definitions are based on true positives, false positives and false negatives. the descriptions given here are expressed in terms of the tools evaluated in this study.

true positive : the number of instances retrieved that were crisprs, false positive : the number of instances retrieved that were not crisprs, false negative : the number of instances not retrieved that were crisprs.

determining fn can be problematic because it requires the total number of crisprs in the dataset to be known. as is often done in ir, in this study fn is estimated using the composite result sets from all of the available searches tools.

using the definitions above, precision  and recall  can be computed as follows.

 p=tptp+fpr=tptp+fn
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaafaqabeqacaaabagaemicaanaeyypa0zaasaaaeaacqwgubavcqwgqbauaeaacqwgubavcqwgqbaucqghrawkcqwggbgrcqwgqbauaaaabagaemocainaeyypa0zaasaaaeaacqwgubavcqwgqbauaeaacqwgubavcqwgqbaucqghrawkcqwggbgrcqwgobgtaaaaaaaa@415f@ 

precision is the ratio of the number of instances correctly identified to all the instances retrieved. given an instance from the result set, it represents the likelihood of that instance being a crispr. thus, precision can be used to answer the question, "did the retrieval system identify a lot of junk ?"

recall is the ratio of the number of instances correctly identified to the total number of instances that are crisprs . thus, recall can be used to answer the question, "were all of the crisprs retrieved?"

in  <cit> , godde and bickerton documented crisprs in  <dig> species with the use of patscan. from that set, a random sample of size  <dig> was selected for comparison with results from crt and pilercr . between patscan, crt and pilercr, a total of  <dig> distinct crisprs were identified. using the collective information, quality, precision and recall were computed for each tool. the results are presented in table  <dig> under the heading crisprs with cas genes. note that precision is not applicable for patscan, because false positives are removed during manual post-processing. also, the results for crt are based on a search window length of  <dig>  a search window length of  <dig> would produce similar precision/recall results, but would have a slightly lower quality score, because the likelihood of type iii inaccuracies is slightly increased.

a comparison of the three search tools, based on measures quality, precision and recall. the higher scores for crt and pilercr show that automatic detection of crisprs can be very reliable, even more so than with the use manual post-processing as is done with patscan. the results in the left half of the table are for crisprs containing cas genes. because the authors suspect that crisprs with cas genes have fewer mutations, and are thus easier to detect, a second experiment was performed using randomly selected finished genomes. the results of this second experiment are shown in the right half of the table. as expected, slightly lower scores resulted, and they should better reflect the effectiveness of the tools.

the high scores for crt and pilercr show that automatic detection of crisprs can be very reliable, even more so than with the use of manual post-processing as is done with patscan. however, it is not clear whether the lower scores for patscan were mostly from the human involvement in the detection process or from the patscan algorithm.

the quality score was highest for crt. the lower score for patscan was due entirely to type i inconsistencies. the categories of inconsistencies for pilercr were evenly spread, with type i and type ii inconsistencies usually missing by only small amounts. precision was highest with pilercr, while crt had the best recall score. in this application of precision/recall, recall is more significant as it gives an indication of the number of crisprs that were missed by a search tool. although precision is important, a more sensitive tool that detects most crisprs but also reports a few repetitive sequences that are not really crisprs is more desirable than a less sensitive tool that misses several crisprs but reports very few false positives.

as mentioned above, in order to include patscan in retrieval evaluations, results were used from godde and bickerton. however, they reported crisprs only for species that had crispr-associated  genes  <cit> . the authors of this study suspect that crisprs with cas genes may have fewer mutations, thus they are easier for search tools to detect. as a result, the tools have higher evaluation scores. for this reason, a second experiment was undertaken using  <dig> randomly selected finished genomes from the img version  <dig>  database. using crt and pilercr, a total of  <dig> distinct crispr elements were identified within the  <dig> genomes. the evaluation scores are shown in table  <dig> under the heading crisprs with/without cas genes. these results should be more reflective of the performance of the tools for a typical search. almost all measures show a reduction in performance. the most noticeable difference is a decrease in precision for crt and a decrease in recall for pilercr.

discussion
the importance of identifying repetitive sequences is clear; however, the considerable size of many genomes makes fast and efficient repeat detection very challenging. consequently, many detection techniques convert sequences to an alternative representation in an attempt to make analysis more efficient. a frequently used representation is the suffix tree  <cit> . here, a dna sequence is converted into a tree structure containing indices to all suffixes in the original sequence. by traversing the tree, an algorithm is able to find all occurrences of any pattern in time proportional to the size of the pattern. because of the impressive speed of suffix trees, they have been widely used in dna repeat detection  <cit> . the increased speed, however, comes at a cost. first, even before the search for repeats can begin, the suffix tree must be constructed from the sequence data. second, after it is constructed, the tree can consume large amounts of memory.

another technique frequently used for detecting repeats involves computing alignment matrices from dna sequences  <cit> . once implemented, the matrix can be used to find repeated regions in the sequence using one of several algorithms  <cit> . these algorithms, however, can be problematic because of extended processing times.

unlike most repeat detection techniques, the algorithm presented in this paper does not rely on the use of the suffix tree or alignment matrix as a central data structure. no major conversion or preprocessing of the input is required. instead, repeats are discovered directly from the dna sequence using a simple left-to-right skip search technique with localized iterative extensions of identified repeat arrays in order to find exact boundaries. as a result, crt is very efficient in terms of memory usage, at o, and o in time. thus, a standard desktop machine is sufficient for processing large prokaryotic genomes, usually in a matter of seconds.

future research plans are to modify the presented algorithm so that it is also able to identify contiguous repeats. because of the nature of the crt algorithm, the tool would not be practical for detecting very short patterns of sizes  <dig> –  <dig> nucleotides, for example. crt is fastest when identifying longer repeats, and when there is little variation between the sizes of the smallest and largest repeats to be detected. also, the tool is fast when processing genomes with large numbers of repeats; so, crt may be useful for detecting contiguous repeats in eukaryotes, which tend to have more repetitive sequences than prokaryotic genomics.

CONCLUSIONS
in this paper a new tool was introduced for the automatic detection of crispr elements. this tool, crt, was shown to be a significant improvement over the current technique for crispr identification using patscan. crt's approach detects repeats directly from a dna sequence. this leads to a program that is easy to describe and understand, yet it is very fast and memory efficient. in terms of retrieval performance, crt was shown to be very reliable in detecting crisprs, based on measures quality, precision and recall. for performance measures tested, crt outperformed patscan in all cases. additionally, when compared to a recently developed crispr detection program, pilercr, crt showed improved performance under some important conditions. however, using crt and pilercr for detecting crisprs is recommended, as both are fast and have complementary strengths for precision and recall.

availability and requirements
project name: crispr recognition tool 

project home page: 

operating system: platform independent

programming language: java

authors' contributions
cb implemented crt and wrote the manuscript. nck and ph guided the research and revised the manuscript. fs, tlr, ml and kdb participated in background research, data collection and tool comparison.

