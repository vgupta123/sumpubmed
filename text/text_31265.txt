BACKGROUND
the study of protein structure is an intensely active area of research. the number of proteins for which a three-dimensional structure has been solved has increased exponentially in recent years, and there are currently over  <dig>  entries in the protein data bank , a publicly accessible single worldwide archive of structural data for biological macromolecules. the three-dimensional structure of a protein determines what other molecules it is capable of binding and interacting with, so a deep understanding of protein structure is critical for predicting protein function and for designing drugs that interact with proteins.

the basic building blocks of protein, amino acids, are small enough that they can be easily understood using simple balls and sticks models that show every atom and bond. proteins, however, are typically composed of hundreds or even thousands of amino acids, making detailed three-dimensional models very difficult to understand. fortunately, artistic ribbon representations of the protein backbone can be used to clarify regions of secondary structure, for example by using spiral ribbons for α-helices and arrows for β-strands  <cit> , and simplified cartoon-style models using ribbons and tubes are commonly used in molecular visualization programs.

the world index of biomolecular visualization resources web page  <cit>  has an extensive listing of free molecular visualization programs that can run on ordinary personal computers. one of the most influential of these is rasmol  <cit> , which is written in the c programming language, and is available on windows, macintosh, linux, and unix platforms  <cit> . rasmol's success was apparently due to an excellent compromise between rendering speed and image quality so that even large proteins can be rotated in real time  <cit> . more recently, java based molecular visualization tools have become popular, in large part because of java's platform independence, and a typical pdb web page for a protein now contains links to allow interactive three-dimensional images to be displayed using java programs such as king  <cit> , webmol  <cit> , or jmol  <cit> .

recent advances in programmable graphics cards offer a number of new opportunities for illustrating proteins. many inexpensive, commonly available graphics cards now fully support the use of the opengl shading language , which is used to write small programs, known as shaders, for modifying the graphics pipeline to produce sophisticated visual effects  <cit> . a few free molecular visualization tools have begun to take advantage of these new opportunities. the visual molecular dynamics program uses glsl to improve image quality and rendering speed  <cit> , while qutemol goes further by using glsl to add illustrative rendering effects  such as borders around atoms and halo effects that make space filling, balls and sticks, and liquorice models much easier to interpret  <cit> .

the proteinshader program described in this paper further exploits glsl by using custom texture mapping and lighting calculations implemented on the graphics card to produce ribbon and tube cartoon-style illustrative renderings of proteins that approximate what an artist might create by hand using pen and ink. custom shading calculations are also used to map text labels and decorative textures onto the curved surfaces of tubes and ribbons shown in color.

implementation
proteinshader is written primarily in java, which was chosen because of its platform independence, as well as the ability of a java swing-based gui to adopt the look and feel of the current operating system  <cit> . the javadoc tool  <cit>  was used to extract comments from the source code and generate the api  files that are included in the help directory of the proteinshader distribution. the current version of proteinshader, beta  <dig> . <dig>  is available as additional files  <dig> and  <dig>  or can be downloaded from sourceforge  <cit> , where future versions will be posted.

to obtain hardware-accelerated rendering of high quality three-dimensional perspective images of a protein, the low-level open graphics library  that runs on most modern graphics cards is used. the ribbons and tubes used by proteinshader are drawn as collections of flat polygons tiled together to form continuous surfaces, and texture mapping coordinates are assigned to individual vertices as they are generated. because opengl is primarily intended to work with the c/c++ language, java bindings for opengl  is used to allow the java code to access opengl.

to map textures onto the surfaces of ribbons and tubes, vertex and fragment shaders written in the opengl shading language  <cit>  are used. the vertex shader allows a programmer to manipulate directional vectors associated with a vertex, while the fragment shader is for applying custom equations for setting the color of each surface fragment   <cit> .

to speed up the number of frames per second that can be rendering during an animation , geometry is cached on the graphics card by using opengl display lists  <cit> . when tested with an inexpensive good quality mid-range graphics card, the ati radeon x <dig>  caching geometry in advance resulted in a nine-fold increase in performance for ribbons and a thirteen-fold increase in performance for tubes .

RESULTS
overview of the proteinshader gui
a screenshot of the proteinshader gui is shown in figure  <dig>  where the retinol-binding protein  <cit>  is displayed as a pen-and-ink style rendering. the main window consists of a drawing canvas with a menu bar across the top, and the purpose of each menu is summarized in table  <dig>  the file menu's chooser box will open to the proteinshader's data directory by default, so that is the best place to store protein structure files downloaded from the pdb web site  <cit> .

the retractable control panel on the right side of the canvas is composed of two parts: a left-side subpanel that allows the user to select any model, chain, residue, or atom of the protein structure, and a right-side subpanel that can be switched to any of several different modifier or action subpanels. the menu at the top right of the control panel is used for changing the right-side subpanel, and the purpose of each subpanel is summarized in table  <dig>  most of the modifier subpanels also allow selection of individual α-helices, β-strands, or loop regions.

a few examples of the kind of artwork proteinshader can generate are shown in figure  <dig> using the porin protein  <cit> , the ribonuclease inhibitor protein  <cit> , the 3-isopropylmalate dehydrogenase enzyme  <cit> , and the potassium channel  <cit> . when a protein structure is loaded, the canvas automatically displays it as a pen-and-ink style illustrative rendering of ribbons and tubes, and the right side of the control panel is set to the decorations subpanel shown in figure  <dig>  a variety of patterns can be applied to the ribbons and tubes by using the halftone texture and bend texture menus of the decorations subpanel. the patterns are read from image files, which will be discussed further below in the section on texture mapping. a cartoon visibility subpanel can be used to deemphasize parts of the structure by setting them to be translucent, and the visibility menu above the canvas can be used to display heterogens, such as the 3-isopropylmalate substrate molecules in figure 2c or the k+ ion in figure 2d.

in addition to the ribbons and tubes cartoon-type representations, the style menu above the canvas can also be used to select atom-type representations: space filling , balls and sticks , and sticks . dragging the mouse across the canvas can be used to rotate or zoom in on images, or an image can be rotated at constant speed by using a motion control panel. details on mouse movements or the various control panels and menus can be found by using the help menu above the canvas.

general strategy for tubes and ribbons
three-dimensional ribbons and tubes can be drawn by sweeping a waist polygon along a curved line at regular intervals and, at each point along the curve, aligning the polygon to a local coordinate frame  that keeps the plane of the polygon perpendicular to the tangent of the curve  <cit> . when two copies of the polygon are placed at adjacent points along the curve, connecting their vertices can be used to define the small, flat polygons that ultimately approximate the curved surface of the ribbon or tube. in proteinshader, the curved line and local coordinate frames needed for creating ribbons and tubes are generated using the xyz-coordinates of the α-carbons in each polypeptide chain.

local coordinate frames for α-carbons
to define each α-carbon's local xyz-coordinate frame, the technique illustrated in figure 3a is used. for α-carbon i, a tangent vector t  is calculated as the vector pointing from α-carbon  to α-carbon . a second vector in the same plane is calculated by subtracting α-carbon  from α-carbon , and a binormal vector b  is then calculated as the cross product of this second vector and t. finally, the cross product of b and t is used to obtain a normal vector n . if a previous or next α-carbon is missing, the calculations use the current α-carbons's amino group nitrogen or carbonyl group oxygen, respectively.

n, b, and t form a right-handed perpendicular xyz-axis system, with n and t in the plane represented by the light green triangle in figure 3a. written as column vectors, n, b, and t form the rotation matrix shown in figure 3b. this matrix can be used to take a waist polygon drawn in the xy-plane of a global xyz-coordinate system and rotate it into the xy-plane of the local coordinate frame for an α-carbon.

hermite interpolation
to develop a curved line that passes through the α-carbons in a chain, hermite interpolation  <cit>  is used. the curved line is actually a spline, a series of piecewise cubic polynomial equations, where each polynomial equation begins at one α-carbon and ends at the next. the xyz-coordinates and tangent vectors of the two α-carbons are used to solve the constants a, b, c, and d in the set of parameterized equations shown in figure 3c. the parameter t is set to  <dig>  at α-carbon  and to  <dig>  at α-carbon , so intermediate values of t can be used to solve for the xyz-coordinates of any point on the curved line. the tangent vectors used in the calculations are adjusted to a length of  <dig>  because that gives a reasonable curvature for α-helices and β-strands.

slerp
an algorithm is also needed for interpolating between the local coordinate frames of α-carbons. the tangent  of each interpolated frame could be calculated from the first derivatives of the equations shown in figure 3c, and a simplistic linear interpolation could be used to calculate a normal  and binormal  for each point. however, a much smoother interpolation can be achieved by using the spherical linear interpolation  parameterized equation shown in figure 3d <cit> .

slerp, which is based on the use of quaternions, is commonly used in computer graphics for gliding a camera through a scene because it avoids the quirks and jerky motion of earlier methods  <cit> . a quaternion is a four-tuple devised by w. r. hamilton to extend complex numbers into multiple dimensions, but it can also be used to represent a three-dimensional rotation in space  <cit> . a rotation matrix can be converted into a quaternion  <cit> , and interpolating between quaternions produces a smoother rotation than attempting to interpolate between matrices.

hermite-slerp algorithm
to maintain the three-dimensional structure of a tube or ribbon, the waist polygon drawn in the xy-plane of each local coordinate frame should be kept perpendicular to the spline, so the tangent  of each local frame should closely matches the tangent of the spline. a minor problem with using slerp is that the tangent of each interpolated quaternion  will not necessarily match the tangent calculated by hermite interpolation.

to fix any discrepancy between the slerp- and hermite-calculated tangents, the tangents are compared, and if there is more than one degree of difference, a rotation is used to make the slerp tangent match the hermite tangent. the axis and angle of rotation are calculated using the cross product and dot product, respectively, of the two tangents, and for convenience the axis and angle are converted into a quaternion.

multiplying the interpolated quaternion by the tangent-fix-up quaternion adjusts the interpolated quaternion so that if it was converted back into a rotation matrix, its tangent would now match the tangent of the spline. the net effect of these manipulations is that the tangent  of each local frame along the spline is determined by hermite interpolation, while the slerp algorithm provides for a smooth, gradual rotation of the xy-axes.

frenet frames
to visualize the spline and local coordinate frames produced by the hermite-slerp algorithm, the style menu above the canvas has a frenet frames option. an α-helix from the c-jun protein  <cit>  is shown as frenet frames in figure 3e, where the local frames use the same color scheme as in figure 3a, and the interpolated frames are shown on a smaller scale. in figure 3f, the same α-helix is shown after selecting tubes from the style menu and wireframe from the decorations panel. the red end cap is the waist polygon that is swept along the spline while drawing the tube, and the lines of the wireframe connect the vertices that define the surface of the tube. in figure 3g, the α-helix is shown after selecting plain from the decorations panel and using the cartoon color panel to apply colors based on amino acid type. phong lighting calculations  <cit>  are used to smooth out the appearance of the tube's surface and to add specular highlighting  to enhance the three-dimensional quality of the image.

untwisting β-strands
the hermite-slerp algorithm works fine for α-helices and loops, but encounters a problem with β-strands, where the amino acid side chain directionality alternates by approximately  <dig> degrees for successive residues. the local coordinate frames will, in most cases, flip direction for every other α-carbon. consequently, a β-strand ribbon will appear highly twisted as illustrated in figure  <dig>  where two β-strands are shown as frenet frames  or ribbons . the twisted ribbons are visually difficult to follow, and any images mapped onto their surface become highly distorted.

to fix this problem, the local coordinate frames for successive α-carbons are compared to check for a radical change in direction. the frames are aligned along their tangents  by using the procedure described earlier for making slerp-calculated tangents match hermite-calculated tangents, and if the angle between the two binormal vectors  is greater than  <dig> degrees, the second frame is rotated  <dig> degrees about its tangent . after performing this fix-up step along a β-strand's length, the frames will be aligned as shown in figure 4c. the appearance of the ribbon is greatly improved as shown in figure 4d, and the antiparallel nature of the two β-strands becomes more obvious because the crests and valleys of the ribbons coincide.

it might seem simpler to assume that the coordinate frame for every second α-carbon should be rotated. however, that strategy will not always work because there are occasional irregularities in the structure of lengthy β-strands, as well as some problems with how β-strands are defined.

combining side chains with ribbons
because the spline runs through the α-carbons, when balls and sticks representations of amino acid side chains are combined with ribbons, the side chains appear to be firmly attached to the ribbon. this effect is illustrated in figure  <dig>  which shows two β-strand ribbons after the balls and sticks button was clicked in the cartoon side chain subpanel of the control panel. by looking closely along the length of the ribbon, the alternating orientation of side chains discussed in the previous section can be clearly observed.

segments and texture mapping
if a region of secondary structure were stored as a single collection of vertices, dynamically applying colors or textures to mark individual amino acids would become quite complex. therefore, the basic geometric unit of organization for rendering tubes and ribbons in the proteinshader program is a segment, which is defined as a length of a tube or ribbon that corresponds to a single amino acid. a segment's center is the xyz-coordinates of its α-carbon, while its beginning and end are the midpoints along the spline to the previous and next α-carbon, respectively.

a segment can be thought of as a collection of local coordinate frames, as shown in figure 6a, where an amino acid is shown as frenet frames with blue, gray, and red spheres marking the beginning, α-carbon, and end of the segment, respectively. the same amino acid is also shown as a tube segment  and as a ribbon segment . as the waist polygon that specifies the vertices of a tube or ribbon segment is swept along the spline and aligned to each local frame, every vertex is assigned a surface normal and a pair of texture coordinates. the surface normal is a vector needed for lighting calculations, while the texture coordinates allow two-dimensional images such as the swirl pattern in figure 6d to be systematically mapped onto the surface of a tube or ribbon segment. by convention, the texture coordinates are referred to as s and t, and each coordinate is on a scale from  <dig>  to  <dig>   <cit> .

vertices at the beginning of a segment are assigned a t-coordinate of  <dig> , while vertices at the end are assigned a t-coordinate of  <dig> . the s-coordinate, on the other hand, increases in the counter clockwise direction as the vertices of the waist polygon are drawn in the xy-plane, and the exact start and end values are somewhat variable. for example, the broad surfaces of ribbons have s-coordinates from  <dig>  to  <dig> , but on the narrow sides of ribbons the s-coordinates run from  <dig>  to only  <dig> . for tubes, the s-coordinate runs from  <dig>  to  <dig>  so that the same texture map will be wrapped around the tube twice.

the patterns, text labels, and wireframe buttons of the decorations subpanel accomplish their effects by using texture mapping. the images in the patterns menu are read from png  or jpeg  files in the textures/patterns subdirectory, and the menu can be modified by editing a configuration file. the lines for the wireframe images are calculated on-the-fly, while the images needed for amino acid labels are generated whenever a protein structure is first loaded by extracting letters and digits from an image file. texture mapping is also important for creating pen-and-ink style drawings.

pen-and-ink style drawings
to produce pen-and-ink style drawings, a variety of edge lines need to be added. for ribbons, many of the edge lines can be added by darkening fragments of a surface if they have an s or t coordinate close to the minimum or maximum. for tubes, however, this approach is only useful at the beginning or end of a segment, as what appears to be an edge along the length of a tube is determined by the view angle.

a solution for generating edge lines based on the view angle is presented in figure  <dig>  lighting calculations typically use a surface normal that indicates the direction a fragment faces, a view vector from the fragment to the camera, and a lighting vector from the fragment to the light source . as shown in figure 7a, if the angle between the surface normal  and the view vector  is close to  <dig> degrees, then the surface is an edge and should be darkened.

instead of a sharp cutoff, the smoothing function graphed in figure 7b is used to determine edge line intensity: i = exp <dig>  where d = 2cosine and θ is the angle between n and v. this equation is from a paper on single-pass wireframe rendering  <cit> , where d was a distance. the equation is also used to smooth edge lines generated from texture coordinates.

the result of these edge-line calculations can be seen by comparing two images of the human growth hormone protein  <cit> . in figure 7c, a color model has been converted to grayscale by using the equation: gray =  <dig>  red +  <dig>  green +  <dig>  blue. in figure 7d, edge lines generated from the view angle have been applied along with texture-coordinate based edges added to segment end caps.

the image in figure 7d is shown in figure  <dig> after using the real-time halftoning technique  <cit>  to mix a noise texture  with grayscale lighting calculations by using the smooth threshold function, color =  <dig>  - aliasfactor* and a bend texture  mapped onto the surface of each tube segment. the halftoning texture is mixed with lighting calculations, whereas the bend texture is multiplied by a bend factor from  <dig>  to  <dig>  that is determined by comparing the tangents at the very beginning and end of a segment.

to emphasize bends in the middle of segments, a second texture has been applied to the image in figure  <dig> , and the intensity of the texture is proportional to how strongly a segment's spline is bent. a bend factor on a linear scale from  <dig>  to  <dig>  is calculated by comparing the tangents at the beginning and end of a segment. if the tangents have an angle close to  <dig> degrees when placed tail to tail, the spline is nearly straight and the bend factor is close to  <dig> . if the angle is almost  <dig> degrees, the segment is strongly bent, and the bend factor is close to  <dig> .

halftoning and bend textures can be selected from menus in the decorations panel shown in figure  <dig>  the textures are stored as png  <cit>  or jpeg  <cit>  files, and the help menu has directions for adding new textures. textures can be assigned to individual segments of a ribbon or tube, so the pen-and-ink style drawing can be mixed with other options .

selection of individual segments also allows important regions of a protein to be highlighted by adding amino acid side chains to pen-and-ink style drawings. as examples, in figure  <dig> side chains involved in binding of human growth hormone to its receptor  <cit>  have been added as a space filling  or balls and sticks  style display, and the way that a loop region  of the transmembrane β-barrel porin protein fills up much of the channel  <cit>  is illustrated with space filling side chains .

performance costs for shaders
the experiments in figures  <dig> and  <dig> measure the performance costs for using vertex and fragment shaders to perform custom lighting, texture mapping, and edge-line generation calculations. for a space filling style display, phong lighting using custom shaders  produces a smoother, higher quality image than using the built-in opengl lighting . the performance cost appears to be fairly minor , with about a 12% reduction in frames per second during an animation when the phong shaders are used rather than the built-in lighting. similar results were seen for a tubes style display , with about a 17% reduction in frames per second.

the performance tests graphed in figures  <dig> to  <dig> were made on a macintosh  <dig>  ghz intel core  <dig> duo with  <dig> gb of ram and an ati radeon x <dig> graphics card with  <dig> mb vram. to prevent an out of memory error for the largest protein tested, the chaperonin complex, the maximum size of the java heap was increased to  <dig> mb by adding "-xmx512m" as an argument to the java command in the run.sh script provided with the proteinshader distribution.

for figure  <dig>  the decorations subpanel of the proteinshader gui was used to select shaders for special effects while rendering a tubes style display. for each test protein in figure 11f, if the phong lighting  frames per second is considered to be 100%, switching to the wireframe shaders or adding patterns by texture mapping typically results in a fairly minor reduction of less than 20%, while more complex calculations such as adding text labels or halftoning result in reductions of almost 50%. given the quality of the images obtained, the performance costs for using custom vertex and fragment shaders seems reasonable. a caveat to these results, however, is that a fairly recent good quality graphics card is required.

the proteins tested in figure 11f range from  <dig> amino acids to about  <dig>  amino acids , and each approximate doubling in protein size results in a roughly 2-fold reduction in frames per second. overall, the 46-fold increase in number of residues from the smallest to the largest test protein  results in very close to a 46-fold decrease in frames per second  and from  <dig>  to  <dig>  frames per second for halftoning). these results indicate that, at least within this size range, rendering times scale in a nearly linear manner for tubes style displays with custom shaders.

antialiasing
when pen-and-ink style ribbons and tubes are drawn on a white background, the darkened edges often appear to be quite jagged, as shown in figure 12a. this phenomena, which is referred to as aliasing  <cit> , occurs because a pixel is determined to be all the way in or out of an object based on whether the center of the pixel falls within a boundary line.

the proteinshader control panel has an antialiasing subpanel, where the option to antialias black edges of halftoning images can be selected. by adding gray pixels outside object boundaries, this option partially smooths out the jagged edges, as shown in figure 12b. to accomplish this effect, a translucent black silhouette of each tube or ribbon segment is rendered four times with a slight offset  before rendering the segment with halftoning.

the antialiasing subpanel also provides an option for smoothing any image by rendering the entire scene several times with jitter and blending the images. the scene can be jittered from  <dig> to  <dig> times using jitter values taken from the opengl programming guide  <cit> , and this antialiasing can be combined with the silhouette-based antialiasing to produce nicely smoothed dark edges, as shown in figures 12c and 12d.

antialiasing dramatically slows rendering during an animation, as shown in figure 12e. the silhouette-based antialiasing slows rendering by about 3-fold, while jittering the entire scene n times will slow rendering down about n-fold. because of the performance costs, antialiasing is intended mainly for saving static images as png or jpeg files. antialiasing is used on all of the images in previous figures, except for figures  <dig> and  <dig> 

CONCLUSIONS
the proteinshader program is a platform-independent java-opengl molecular visualization tool that exploits recent advances in programmable graphics cards. the primary accomplishment of this free, open-source code program is its ability to render a protein as a cartoon-style drawing that approximates what an artist might create by hand using pen and ink . the artistic effects employed by proteinshader rely heavily on texture mapping, where two-dimensional images are systematically mapped onto the curved surfaces of three-dimensional ribbons and tubes. to minimize distortions or irregularities in the images used as textures, a hybrid hermite-slerp algorithm was developed for generating smooth, gradually rotating tubes and ribbons.

the custom texture mapping and lighting calculations needed for rendering pen-and-ink style images are implemented using vertex and fragment shaders written in the opengl shading language  <cit> , which is supported on most new graphics cards for ordinary desktop and laptop computers. shaders are also used for mapping text labels and decorative textures onto the surfaces of ribbons and tubes shown in color.

to create images suitable for publication, the program has antialiasing options that can nicely smooth out the jagged  edges that are often seen in computer-generated images. however, antialiasing dramatically slows rendering time, so it may not be suitable for animations, unless a fairly high-end graphics card is used. the performance costs for using custom shaders rather than opengl's built-in lighting equations appears to be fairly minor on recent graphics cards.

as an aid to future development, a frenet frames style display allows the user to visualize the mathematics that underlies the tubes and ribbons. key areas for future development are representations of dna, which is not currently supported, and selection by clicking on parts of an image. in the present version of the proteinshader program, all manipulations are done through user-friendly menus and control panels.

availability and requirements
• project name: proteinshader

• project home page: 

• operating system: platform independent 

• programming languages: java and opengl shading language

• other requirements: java  <dig>  and a graphics card supporting opengl  <dig>  or higher.

• license: gnu general public license

• restrictions to use by non-academics: none

authors' contributions
jrw wrote the program and authored the manuscript. all authors read and approved the final manuscript.

supplementary material
additional file 1
proteinshader program without source code. this compressed file contains the complete proteinshader program including associated libraries, but no source code. a readme.txt file gives an overview of the proteinshader distribution, and the index.html file in the help subdirectory has directions on getting started with the program as well as a set of tutorials.

 additional file 2
proteinshader program with source code. this compressed file contains everything in the binary distribution plus the java source code and a build.xml file for compiling with ant.

click here for file

 acknowledgements
the proteinshader program was originally written as a thesis project for the alm in information technology program at the harvard university extension school, and i thank my thesis director, hanspeter pfister, who provided critical feedback on the project and suggested the use of the real-time halftoning technique developed by freudenberg, masuch, and strothotte  <cit> . i am also grateful to brad fish for making his glfont source code freely available and to jerome jouvie and ron sullivan for making their textureloader source code freely available. the license agreements and terms of use for the glfont and textureloader libraries are in the licenses subdirectory of the proteinshader distribution.
