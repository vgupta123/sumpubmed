BACKGROUND
pattern mining has numerous applications, such as purchasing pattern mining, biological pattern mining, and web log pattern mining. therefore the academic community has devised useful methods to mine patterns, e.g., mining traditional sequential patterns  <cit>  <cit>  <cit>  <cit> , maximal sequential patterns  <cit> , closed sequential patterns  <cit> , sequential patterns of data streams  <cit> , incremental sequential patterns  <cit> , and progressive sequential patterns  <cit> . traditional sequential pattern mining methods discover general sequential patterns, which can be applied to various constraints. the methods of mining traditional sequential patterns have two famous types of algorithms from technical view. the two types are apriori-based methods  <cit>  <cit>  and projection-based pattern growth algorithms  <cit>  <cit> . the apriori-based methods combine items into candidate patterns, and then the methods validate the patterns. the projection-based pattern growth algorithms scan all sequences and project patterns recursively. the data formats of traditional methods are divided into horizontal data formats and vertical data formats.

traditional sequential pattern mining methods discover 2l subsequences of a sequential pattern with length l. the numbers of subsequences for a sequential pattern are too large in traditional mining methods, and therefore the maximal sequential pattern mining method  <cit>  is proposed to efficiently identify maximal sequential patterns, which have no frequent supersequences. another alternative is to mine closed sequential patterns  <cit> , which patterns do not have any frequent supersequences with the same occurrence frequency. the closed sequential patterns not only largely reduce the number of reported sequential patterns, but also preserve the expressive power of traditional mining algorithms since the subsequences of a closed sequential pattern are easily derived. mining sequential patterns of data streams  <cit>  is in a different environment and has some additional constraints, such as strictly restricted memory, continuously identified sequential patterns, and a linear time execution.

incremental databases are formed with newly added sequences. the incremental sequential pattern mining algorithm  <cit>  is devised to efficiently mine incremental databases since many real data grow incrementally. most users are usually interested in recent data, and therefore the progressive sequential pattern mining algorithm  <cit>  generates sequential patterns in a period of interest. the method can find newly arriving sequential patterns and discard obsolete sequential patterns. data mining technology has been used in bioinformatics domain. for example, temporal pattern mining techniques are used to mine predictive and non-spurious patterns  <cit> . associated functional subgraphs are discovered by a pattern mining method  <cit>  in cancer protein-protein interaction networks. it is increasingly important to develop approaches for efficient biological data mining since biological sequences are now in widespread use in the field of bioinformatics.

some important research directions for data mining in bioinformatics are discovery of co-occurring biological sequences, effectively classifying biological sequences, and clustering biological sequences  <cit>  <cit>  <cit> . in molecular biology, the motifs are functional significance and have specific structures which are mined from unaligned biological sequences. mining sequential patterns  promote identifying co-occurring biological sequences and discovering relationships in dna or protein data  <cit>  <cit> . in bioinformatics domain, mining sequential patterns  have shown the usefulness, such as classification of biological sequences, prediction of transcription factor binding sites, recognition of protein folds, and identification of hot regions in protein-protein interactions.

the problems of mining sequential patterns correlate closely with some traditional problems of computational biology  <cit>  <cit>  <cit>  <cit> , such as the problems of motif finding and those of sequence alignment. in the field of biology, biological sequences conserve sequential patterns for long evolution, which may be critical functions. the 2pdf approach  <cit>  first proposed to mine sequential patterns of biological sequences, but a large number of patterns were generated, and gap constraints were not coped. dfsp  <cit>  is a general model of mining sequential patterns for biological sequences, but it did not cope with gap constraints either. the gap constraints of teiresias algorithm  <cit>  and splash  <cit>  are rigid. the teiresias algorithm has two phases. the first phase is the scanning, and the second phase is the convolution. in the scanning phase, teiresias generates all <l, w> patterns, which are at least k support. l is the number of least residues, and w is the length of patterns. in the convolution phase, teiresias constructs maximal patterns from <l, w> patterns. splash is another algorithm with the rigid gap constraints. splash first builds a seed set, and then extends patterns recursively. all the final patterns satisfy the density constraint. the density constraint denotes that all substrings of a pattern have length l <dig> and at least k <dig> full characters.

next, we briefly introduce the 2pdf method. new and different types of patterns are generated by the 2pdf method. the patterns have the form "p1*p2*...*pk*...*pn-1*pn." each "pi" denotes a frequent segment, in contrast to the complete set of patterns in traditional sequential pattern mining problems. a frequent segment represents a segment that is longer than minlen . the arbitrary lengths of items or gaps are represented by one symbol "*". they extract segments from all sequences by a generalized suffix tree. to generate the pattern tree in the 2pdf method, the segment tree  is used. the method mines the complete set of sequential patterns in only setting minlen =  <dig> for the 2pdf method. the complete set of all-length sequential patterns means the complete set of sequential patterns. the complete set of length  <dig> sequential patterns in dna sequences may be {<a>, <t>, <c>, <g>}. when minlen =  <dig>  the segment tree in the 2pdf method is too large. a combinatorial method generated the pattern tree in the method. thus, too many patterns  are generated by these techniques. for example, the 2pdf method may generate the patterns "abc*d," "ab*cd," "a*bcd," "ab*c*d," "a*bc*d," "a*b*cd," and "a*b*c*d" if the dfsg  <cit>  or genprefixspan  <cit>  merely generates the pattern "a*b*c*d" . the 2pdf method mines too many patterns for biological sequences, which are shown in this example.

the traditional algorithms of mining sequential patterns  <cit>  <cit>  <cit>  <cit>  cope with a large number of items and short sequence lengths. nevertheless, two diverse characteristics are in dna and protein data. first, the alphabet of dna data are made up of four letters, and that of protein data are made up of twenty letters. second, the dna and protein data usually have hundreds or thousands of the sequence lengths. accordingly, traditional approaches of mining sequential patterns difficultly cope with small alphabets and lengthy sequences of biological sequences. consequently, traditional algorithms are ineffective for mining biological sequences. projection-based pattern growth algorithms  <cit>  <cit>  are used to process long sequences in traditional sequential pattern mining, but they require an extensive running time because they need to construct and scan corresponding projected databases numerous times to generate long sequential patterns. another type of algorithm, apriori-based methods  <cit>  <cit> , are frequently used in traditional sequential pattern mining, but they also have a long processing time. moreover, traditional approaches suit to a larger number of items and brief sequences, such as supermarket transactions; accordingly, the traditional approaches inefficiently cope with biological data.

a novel method, the depth-first spelling algorithm for mining sequential patterns  with gap constraints in biological sequences , is devised in this work. this paper is mainly added explanations of gap constraints, explanations of various sequential pattern mining approaches, related works for biological sequences, explanations of projection-based pattern growth algorithms, explanations of the counting matrix techniques for the gap constraints, explanations of genprefixspan, explanations of how to gain our real data, more summaries for this work, and references of related works for biological sequences and rewritten from the proceedings version of our article. gap constraints are contained in dfsg, which is a generalization approach. the distance limitation between two separate letters of a sequence is a gap constraint. the gap constraint suits to the data features with fewer letters and lengthy sequences, such as biological sequences. the unrelated sections of the biological evolution are skipped by the gap constraints. for the gap constraints, a maximal number of the distance limitation in the separate letters can be assigned by the user. we devise the dfsg approach to leave traditional methods of mining sequential patterns, and struggles with the problems of the long runtime. dfsg need briefer runtime to execute to discover motifs of biological data, compared to traditional approaches of mining sequential patterns. the dfsg approach was evaluated by a large number of experiments. first, dfsg and genprefixspan  <cit>  were utilized to cope with real and simulated dna data. afterward the executing time of the two approaches was contrasted by using increased values of gap constraints, synthetic protein data, and diversified variables in synthetic biological data. in the experimental results, the runtime of the dfsg approach is superior to that of genprefixspan in biological data, and dfsg is more scalable.

some reasons are accounted for the efficient runtime and scalability of the dfsg method. we compare the dfsg approach with genprefixspan, which is a projection-based method of the pattern growth. corresponding projected databases are not needed to build by the dfsg approach unlike traditional projection-based methods of pattern growth; accordingly, the databases are not needed to scan by dfsg. then, dfsg saves recursive runtime of projection and scan. as shown in figure  <dig>  the executing steps of genprefixspan are partially exhibited in an example. genprefixspan must first scan all sequences to generate frequent items {"a","t","c","g"} in biological sequences {x: atacgat, y: atcacga, z: taacgca} with the minimum support λ equal to  <dig> and the gap constraint equal to  <dig> . then, the projected databases for "a", "t", "c", and "g" are generated individually, as {tacgat, cgat, t, tcacga, cga, acgca, cgca}, {acgat, cacga, aacgca}, {gat, acga, ga, gca, a}, and {at, a, ca}, respectively. all the sequences in the projected database of "a" are scanned by genprefixspan to generate frequent items {"a","c","g"} after projecting projected database for "a", and then projected databases for "aa," "ac," and "ag" are generated individually. the genprefixspan approach projects the corresponding databases recursively until it can not generate any frequent letters.

methods
dfsg algorithm
this section introduces the depth-first spelling algorithm for gapped sequential pattern mining of biological sequences . dfsg is designed for efficient mining sequential patterns of biological sequences with gap constraints. the gap constraints are critical and have numerous applications in bioinformatics. a counting matrix cl is proposed to cope with gap constraints and it records each position of a latest item for a gapped sequential pattern in each sequence. the latest item positions in the counting matrix cl must satisfy the gap constraint. each position of the latest item for the gapped sequential pattern is recorded in cl since each position of the latest item may extend to a next sequential pattern with the gap constraint. if the counting matrix records only one position of the latest item in each sequence, the other positions of the latest item may miss chances to contribute support counts for the next sequential pattern with the gap constraint. if the situation causes the support counts of the next gapped sequential pattern to be less than the minimum support counts, the next gapped sequential pattern will not to be generated, and the subsequent gapped sequential patterns will not be discovered either.

all positions of the latest item for a sequence in cl can contribute only one support count to the support counts of the next gapped sequential pattern since a sequence can contribute only one support count to a pattern. if each position of the latest item for a sequence in cl can contribute one support count to the next gapped sequential pattern, the support counts of the pattern will be larger, and this situation may result in wrong reported patterns. a sequence can not contribute multiple support counts to a sequential pattern by the definition. in the following, we introduce the execution of the dfsg approach. dfsg has two performed procedures. first, the three-dimensional indices are built by scanning the provided data set once for the dfsg approach. second, dfsg-generation produces gapped sequential patterns for motifs, as shown in figure  <dig>  the spelling manner of candidate-gapped patterns and the verification of gapped sequential patterns are included in the dfsg-generation operation. direct access and binary search with the three-dimensional indices are contained in the procedure of verification. the prefix of each item is depended by the succeeding appearance point of the item for each motif-producing procedure. therefore, we designed the counting matrix and the three-dimensional indices for the dfsg-generation operation. the counting matrix cannot store the succeeding appearance point ahead since there are too large and unknown feasible points for the succeeding appearance.

definition  <dig>  the set of all items is e, which equals {e <dig>  e <dig>  ..., ea}. it simulates dna sequence when a equals four. furthermore, it simulates protein sequence when a equals twenty. let a sequence s be the ordered list of items. we denote s = {s1s2s <dig> ..sn}, where si is an item. biological sequences usually have long lengths, and an identical item can occur many times in a sequence.

definition  <dig>  we denoted a sequence u = {u1u2u <dig> ..uq}, where ui is an item. a sequence s contains u if {u1u2u <dig> ..uq} is sequentially mapped to {s1s2s <dig> ..sn} . one subsequence of s is u in the above condition.

definition  <dig>  the support count of a pattern α is the number of sequences, which contain the pattern α in the database. if the support of pattern α is larger than the minimum support, this pattern is called a gapped motif. in general, the problem of mining gapped motifs does not confine any categories of biological sequences.

definition  <dig>  we denote a motif p = {p1p2p <dig> ..pm}, where pm is an item. if a sequence s can contribute the support to the motif p, this motif is one subsequence of the sequence s. the item si of the sequence is mapped by pj, and the item sk of the sequence is mapped by pj+ <dig>  if the sk position is less than the si position plus the gap constraint value, the motif p conforms to the gap constraint g.

definition  <dig>  the three-dimensional indices are the position number wk, the sequence number ej, and the item number ai. the item number ai, which appears in the sequence number ej of the biological database is the position number wk.

definition  <dig>  the counting matrix cl has multiple position numbers in each sequence number ej for the procedure of generating gapped motifs. let α=<t1t <dig> ..tn-1>be a gapped motif with the suffix β in the database that β=<t1t <dig> ..tn-1tn>is a sequence with the prefix α. the multiple position numbers form the counting matrix cl of the suffix β. the position number wk is determined by the item <tn>in each sequence number ej of the three-dimensional indices. the position number wk of the suffix β must be greater than the counting matrix cl of the prefix α. the updated position numbers of the present letter in sequences conform to the gap constraint g for the gapped motif, and they are recorded by the counting matrix cl.

definition  <dig>  the support of the suffix β is the number of rows, which have at least one value in the counting matrix cl of β. if the minimum support is less than the support γ of β, the sequence β is certainly a gapped motif.

an example of dfsg
the following is a demonstrated example of performing the dfsg approach. a set of items {a, t, c, g} for the biological sequence database d {x: atacgat, y: atcacga, z: taacgca} is mined by using the dfsg algorithm. for the dfsg example, the minimum support λ is equal to  <dig>  and the gap constraint is also equal to  <dig>  the performed procedures are in the following context. the three-dimensional indices are constructed by using the dfsg approach, which reads the biological sequence database once in the first procedure. the dfsg approach reads the biological sequence s, and puts the position wk of the read item ai into the three-dimensional indices. according to figure  <dig>  the dfsg-generation operation discovers gapped motifs of biological sequences in the second procedure. the dfsg approach spells item i to generate candidate-gapped motifs α for biological sequences in a depth-first manner. the support counts of candidate-gapped motifs are verified by using the counting matrix cl and the three-dimensional indices. if the support counts of candidate-gapped motifs are greater than the minimum support count, the recursive execution of the procedure is continued, and the motifs are gapped motifs of biological sequences.

the counting matrix cl of "c" is {,,} since "c" occurs in the position  of sequence x, the positions  of sequence y, and the positions  of sequence z. in the initial stage, all the positions of "c" are in the counting matrix cl of "c" and satisfy the gap constraint. as shown in figure  <dig>  the candidate-gapped motif "c*a" is spelt by the dfsg approach in a depth-first manner. dfsg searches the positions in dimension "a" of the three-dimensional indices to detect minimum positions that are greater than the positions in the counting matrix and satisfy the gap constraint. the current counting matrix {,,} is greater than the former counting matrix {,,}, and all the positions in the new cl satisfy the gap constraint  <dig> since the position  is less than , the positions  is less than , and the position  is less than .

the candidate-gapped motif "c*a" is certainly a gapped motif since the support count  <dig> satisfies the minimum support count. a support is regarded to satisfy a minimum support when the support is greater than or equal to the minimum support. the support of gapped pattern "c*a" is  <dig> since the position  of sequence x, the positions  of sequence y, and the position  of sequence z contribute one support count to the gapped pattern individually. dfsg continues to depth-first spell and verify candidate motifs. then, we observe another candidate motif "a*t." the positions in the "t" dimension of the indices are searched. the support count is  <dig> since the updated counting matrix is {,,}. therefore, the candidate-gapped motif "a*t" is certainly not a gapped motif, and the subsequent candidate-gapped motifs of this failed candidate "a*t" are not continued to generate.

RESULTS
design of experiments
the dfsg performance was evaluated with a number of experiments. in the first part of the experiments, we compared the performance of dfsg with that of genprefixspan in synthetic and real dna data. genprefixspan is a generalized method of prefixspan, which uses the projected database approach to recursively construct sequential patterns and is an efficient algorithm in traditional sequential pattern mining. genprefixspan stores all subsequences of each frequent item occurrence in projected databases to cope with gap constraints. we acquired real dna data from the national center for biotechnology information , which is national resource funded by u.s. government. in the second part of the experiments, we tested dfsg and genprefixspan with gap constraints, number of sequences, length of sequences, and simulated protein sequences. the scalability of the dfsg algorithm was experimented, too. the total experiments were conducted on a  <dig>  ghz pentium  <dig> pc with  <dig> gb of ram, and microsoft windows xp professional  was the operating system. in order to make fair comparisons, the two programs were written in the same environment, microsoft visual c++  <dig> .

synthetic and real dna data
dfsg and genprefixspan were evaluated by using real dna data, which are acquired from ncbi. variables used in the experiments are the length of a sequence l, the number of letters a, the value of gap constraint g, the minimum support s, and the number of sequences n. the users can access numerous public databases of molecular biology from ncbi website. for example, we introduce how to gain our real data . first, we access ncbi website, http://www.ncbi.nlm.nih.gov. second, the nucleotide database is selected. third, the query is "sequence and 35:35". fourth, the first one thousand sequences are crawled and parsed to form our data set.

the value of a is four for synthetic and real dna data in the experiments of dna data. additionally, the values of l are twenty-five, thirty, and thirty-five in the experiments. in figures 4a-c, dfsg is superior to genprefixspan for real dna data. in the experiments, the values of gap constraint are ten, seven, and five; and the number of sequences is one thousand. in the figures, the runtime of two algorithms is shown on the vertical axis, and the minimum support is shown on the horizontal axis. the runtime rate is that the runtime of genprefixspan divided by dfsg's runtime. the runtime rates are  <dig> ,  <dig> ,  <dig> ,  <dig> , and  <dig>  for real dna data, as shown in figure 4c. the rate grows when the minimum support gets larger. this means that dfsg has more superior than genprefixspan for high support thresholds in mining biological sequences.

the simulated dna data, which is used in the successive experiments, followed the reference  <cit> . the experimental results of the synthetic dna data show that dfsg is superior to genprefixspan, as shown in figures 5a-c. we simulated the letters for dna data in the experiments. the number of letters is four; the lengths of the sequences are twenty-five, thirty, and thirty-five; the value of the gap constraint is five; and the number of sequences is three thousand. according to figure 5c, the runtime rates are  <dig> ,  <dig> ,  <dig> ,  <dig> , and  <dig>  for synthetic dna data. the rate grows invariably when the minimum support becomes larger. the performance of dfsg for the real dna data is the same as these for simulated dna data in the above experiments. this situation confirms that dfsg preserves efficiency on real biological data, and simulated sequences can validate the performance of dfsg correctly.

gap constraints, simulated protein sequences, number of sequences, length of sequences, and scalability
dfsg performance and the performance of genprefixspan are compared by using gap constraints, number of sequences, length of sequences, and simulated protein sequences. scalability of the dfsg algorithm is also tested. we raise the value of the gap constraint g, and the number of letters a equals four steadily for simulated dna data in the experiments of gap constraints. dfsg is superior to genprefixspan with variable gap constraints according to figure 6a-d. in the experiments, the lengths of the sequences are forty and fifty; and the numbers of sequences are one thousand and three thousand. the execution time of dfsg and that of genprefixspan is raised since the probability of finding subsequent frequent items is enhanced, and the number of sequential patterns is increased when we increase the value of the gap constraint g.

dfsg is superior to genprefixspan with raised n according to figure  <dig>  in the experiments, the numbers of sequences are four thousand, five thousand, six thousand, seven thousand, eight thousand, and nine thousand; the number of synthetic dna data is four; the length of the sequences is thirty; the minimum support is zero point nine; and the value of the gap constraint is three. additionally, dfsg is more scalable than genprefixspan, although genprefixspan is scalable  <cit> . the runtimes of dfsg seem to be a straight line in figure  <dig> as a result of the proportional scale. dfsg runtimes of figure  <dig> are  <dig>  s ,  <dig>  s ,  <dig>  s ,  <dig>  s ,  <dig>  s , and  <dig>  s . the variations of dfsg runtimes are not obvious in figure  <dig>  furthermore, the runtime rates are  <dig> ,  <dig> ,  <dig> ,  <dig> ,  <dig> , and  <dig> . the runtime rate rises when the number of sequences gets larger. this experiment confirms that dfsg is more efficient than genprefixspan when the number of sequences is increased.

according to figure  <dig>  dfsg outperforms genprefixspan with increased l. the lengths of the sequences are forty-five, forty-six, forty-seven, forty-eight, forty-nine, and fifty; the number of letters is four; the minimum support is zero point nine; the value of the gap constraint is five; and the number of sequences is one thousand in the experiments. the dfsg runtime of figure  <dig> rises steadily when the length of the sequences l is increased that is compared to genprefixspan. as a result of the proportional scale, the runtimes of dfsg for this figure seem to be a straight line more if the maximum value of the sequence length is greater than fifty. additionally, the results of the experiment have already shown that dfsg significantly outperforms genprefixspan as l increases. in the following, we use a different alphabet size to test the execution time of dfsg and that of genprefixspan. according to figure  <dig>  dfsg mines much faster than genprefixspan when the number of letters a equals twenty for synthetic protein data. the length of the sequences is one hundred; the number of sequences is five hundred; and the value of the gap constraint is twenty in the experiment of synthetic protein data.

the number of sequences n is added from one hundred kilos to five hundred kilos to experiment with dfsg scalability. in the experiment, the runtimes of dfsg are  <dig> ,  <dig> ,  <dig> ,  <dig> , and  <dig>  s, and the numbers of sequences are one hundred kilos, two hundred kilos, three hundred kilos, four hundred kilos, and five hundred kilos, respectively. in the experimental results, the execution time of dfsg is scalable when the numbers of sequences get larger. the growth rate of dfsg runtime is steady. this experiment confirms that dfsg has the scalability for large biological data. in the experiment, the number of letters for the synthetic dna data is four; the minimum support is zero point nine; the value of the gap constraint is three; and the length of the sequences is thirty. the total experiments show that dfsg is superior to genprefixspan in various features, including synthetic dna/protein data, real dna data, length of sequences, number of sequences, and gap constraints.

CONCLUSIONS
mining sequential patterns of biological sequences is important in computational biology. however, traditional sequential pattern mining methods difficultly cope with biological sequences whose sequence lengths are long, and alphabets are small. furthermore, gap constraints for motif discovery are also important in computational biology. therefore, dfsg is proposed to efficiently mine motifs of biological sequences with gap constraints. dfsg can help biologists discover all-length motifs with gap constraints, and when mining biological sequences, dfsg is more efficient than genprefixspan. in our future works, we will devise efficient or effective algorithms to help mine biological sequences.

competing interests
the authors declare that they have no competing interests.

authors' contributions
vccl carried out this work, conceived of the study, designed the conceptual framework, developed the method, analyzed the results and drafted the manuscript. msc advised on this work and helped to draft the manuscript. both authors have read and approved the final manuscript.

declarations
the publication costs for this article were funded by the corresponding author.

this article has been published as part of bmc systems biology volume  <dig> supplement  <dig>  2013: selected articles from the ieee international conference on bioinformatics and biomedicine 2012: systems biology. the full contents of the supplement are available online at http://www.biomedcentral.com/bmcsystbiol/supplements/7/s <dig> 
