BACKGROUND
high-throughput methods for structure determination have greatly increased the number of proteins with known structure in the protein data bank   <cit> . structural genomics initiatives  <cit>  have contributed not only to this increase in number, but have also increased the diversity of known protein structures. the function of most proteins is still poorly understood or even completely unknown. automated functional annotation methods make it possible to fill in some of the gaps of missing information. such methods can be a critical component of computational drug design and protein engineering. their applicability, however, goes beyond traditional applications. for example, a nuanced and detailed understanding of protein function can also provide insight into the roles hub proteins play in protein interaction networks. sequence-based methods are an established way for detecting functional similarity  <cit> , but sequence similarity does not always imply functional similarity and vice versa. structural analysis using the entire pdb allows for the discovery of similar function in proteins with very different sequences and even different folds  <cit> . for an overview of current approaches in sequence- and structure-based methods see  <cit> .

although it is possible to compare structures at the fold level  <cit> , or by comparing pockets and clefts  <cit> , this work focuses on substructure matching methods. substructure matching methods aim to find a common substructure motif  within one or more protein structures. substructure matching methods can be used to identify functional similarity in cases where sequence similarity or fold similarity between homologous proteins is low . the identification of an important substructure that forms a motif can be separated from the process of matching the motif against a number of structures. several methods have been proposed to identify residues that are of functional importance  <cit> . typically, such methods require as input a family of proteins that are known to be functionally similar. once a structural motif has been identified that characterizes a given function or family, it is still a challenging problem to screen all the structures in the pdb for occurrences of substructures similar to this motif, and determine functional similarity. a wide variety of substructure matching methods have been proposed, such as: tess  <cit> , spasm  <cit> , cavbase  <cit> , ef-site  <cit> , assam  <cit> , pints  <cit> , jess  <cit> , sumo  <cit> , siteengine  <cit> , query <dig> d  <cit> , profunc  <cit> , proknow  <cit> , sitesbase  <cit> , giraf  <cit> , mash  <cit> , soippa  <cit> , feature  <cit> , and pevosoar  <cit> . these methods mainly differ in  the representation of structural motifs,  the motif matching algorithm, and  the statistics used to determine significance of match. representations for substructural motifs include: cα coordinates with residue labels , physicochemical pseudo-centers  <cit> , graphs  <cit> , general sets of constraints on atom positions and residue types  <cit> , binding surfaces annotated with evolutionary conservation  <cit> , or learnt vectors of features  occurring at certain distance ranges  <cit> . such representations can then be matched using a variety of techniques such as: geometric hashing  <cit> , depth-first search  <cit> , graph algorithms , and constraint solvers  <cit> . to assess the statistical significance of matches the use of extreme value distributions  <cit> , mixtures of gaussians  <cit> , and a non-parametric model  <cit>  have been proposed.

this paper describes a novel method for rapidly matching a motif against all known structures in the pdb . it addresses several algorithmic and system design issues that allow it to be run in parallel and obtain near real-time performance. the method makes very few assumptions about the motif. for instance, a motif does not necessarily have to represent a cavity or binding site. the method was designed to be easy to use by both novice and expert users: the default parameters work in variety of scenarios, but can be easily changed to control the desired output. through three case studies we demonstrate the versatility of the method and the ability to obtain highly sensitive and specific results.

RESULTS
the labelhash algorithm
we are interested in matching a structural motif against a large set of target structures. the structural motif is defined by the backbone cα coordinates of a number of residues and  allowed residue substitutions for each motif residue which are encoded as labels. previous work has established that this is a feasible representation because it can find biologically relevant results  <cit> .

the method presented below is called labelhash. we will first give a high-level description. the method builds a hash table for n-tuples of residues that occur in a set of targets. in spirit labelhash is reminiscent of the geometric hashing technique  <cit> , but the particulars of the approach are very different. the n-tuples are hashed based on the residues' labels. each n-tuple has to satisfy certain geometric constraints. the data in the hash table is indexed in a way that allows fast parallel access. using this table we can look up partial matches of size n in constant time. these partial matches are augmented in parallel to full matches with an algorithm similar to mash  <cit> . compared to geometric hashing  <cit> , our method significantly reduces storage requirements. relative to mash, we further improve the specificity. furthermore, in the labelhash algorithm it is no longer required to use importance ranking of residues to guide the matching . in our previous work, this ranking was obtained using evolutionary trace  information  <cit> . the labelhash algorithm was designed to improve the  accuracy of mash and push the envelope of matching with only very few geometric constraints. we want motifs to be as general as possible to allow for future extensions and to facilitate motif design through a variety of methods. our simple-to-use and extensible labelhash algorithm is extremely fast and can be a critical component of an exploratory process of iterative and near-interactive design and refinement of substructure templates. the algorithm consists of two stages: a preprocessing stage and a stage where a motif is matched against the preprocessed data.

preprocessing stage
the preprocessing stage has to be performed only once for a given set of targets; any motif can then be matched against the same preprocessed data. the targets can consist of single chains, but it is also possible to treat entire domains as a single target. this is useful for motifs that span multiple chains. during the preprocessing stage we aim to find possible candidate partial matches. this is done by finding all n-tuples of residues that satisfy certain geometric constraints. we will call these n-tuples reference sets. typically, n is small; in our experiments we use 3-tuples. all valid reference sets for all targets are stored in a hash map, a data structure for key/value pairs that allows for constant time insertions and lookups . in our case, each key is a sorted n-tuple of residue labels, and the value consists of a list of reference sets that contain residues with these labels in any order. so for any reference set in a motif we can instantly find all occurrences in all targets. notice that in contrast to geometric hashing  <cit>  we do not store transformed copies of the targets for each reference set, which allows us to store many more reference sets in the same amount of memory.

in our current implementation the geometric constraints apply to the cα coordinates of each residue, but there is no fundamental reason why other points such as cβ's or physicochemical pseudo-centers  <cit>  cannot be used instead. we have defined the following four constraints on valid reference sets:

• each cα in a reference set has to be within a distance dmaxmindist from its nearest neighboring cα .

• the maximum distance between any two cα's within a reference set is restricted to be less than ddiameter.

• each residue has to be within distance dmaxdepth from the molecular surface. the distance is measured from the atom closest to the surface.

• at least one residue has to be within distance dmaxmindepth from the surface.

the first pair of constraints requires points in valid reference sets to be within close proximity of each other, and the second pair requires them to be within close proximity of the surface. the distance parameters that define these constraints should be picked large enough to allow for at least one valid reference set for each motif that one is willing to consider, but small enough to restrict the number of seed matches in the targets. one would perhaps expect that the storage requirements would be prohibitively expensive, but--as described in the implementation and methods sections--the required storage is still very reasonable. the values for the four distance parameters described above were chosen empirically and kept fixed for all experiments .

matching stage
for a given motif of size m , the labelhash algorithm can look up all matches to a submotif of fixed size n, and expand each partial match to a complete match using a depth-first search. the partial match expansion is a variant of the match augmentation algorithm  <cit>  that consists of the following steps. first, it solves the residue label correspondence between a motif reference set and the matching reference sets stored in the labelhash table.  next, the match is augmented one residue at a time, each time updating the optimal alignment that minimizes the rmsd. if a partial match has an rmsd greater than some threshold ε, it is rejected. for a given motif point, we find all residues in a target that are within some threshold distance . this threshold is for simplicity usually also set to ε. the threshold ε is set to be sufficiently large  so that no interesting matches are missed.

the algorithm recursively augments each partial match with the addition of each candidate target residue. the residues added to a match during match augmentation are not subject to the geometric constraints of reference sets. in other words, residues that are not part of a reference set are allowed to be further from each other and more deeply buried in the core. for small-size reference sets, the requirement that a motif contains at least one reference set is therefore only a very mild constraint. as we will see in the next section, our approach is still highly sensitive and specific.

for a given motif, we generate all the valid reference sets for that motif. any of these reference sets can be used as a starting point for matching. however, those reference sets that have the smallest number of matching reference sets in the labelhash table may be more indicative of a unique function. reference sets with a large number of matches are more likely to be common structural elements or due to chance. we could exhaustively try all possible reference sets, but for efficiency reasons we only process a fixed number of least common reference sets. note that the selection of reference sets as seed matches is based only on frequency. in contrast, in our previous work, only one seed match was selected based on importance ordering frequently based on evolutionary importance  <cit> . because of the preprocessing stage it now becomes feasible to expand matches from many different reference sets. the information stored inside a labelhash file is stored so that only the relevant parts of the file need to be read from disk during matching.

the matching algorithm is flexible enough to give users full control over the kind of matches that are returned. it is possible to keep multiple matches per target or partial matches that match at least a certain minimum number of residues. the latter option can be useful for larger motifs where the functional significance of each motif point is not certain. in such a case, a  <dig>  Å rmsd partial match of, say,  <dig> residues, might be preferable over a  <dig> Å complete match of  <dig> residues. with partial matches, the matches can be ranked by a scoring function that balances the importance of rmsd and the number of residues matched. one can also choose between keeping only the lowest rmsd match per target or all matches for a target, which may be desirable if the top-ranked matches for targets have very similar rmsd's. finally, the number of motif reference sets that the algorithm uses for match augmentation can also be varied. usually most matches are found with the first couple reference sets, but occasionally a larger number of reference sets need to be tried before the smallest rmsd match for each target is found. with the default settings , the number is set to a conservative threshold of  <dig> 

statistical significance of matches
there is no universal rmsd cut-off that can be used to decide whether a match is significant, and picking a cut-off for a given motif and corresponding protein family is non-trivial. the cut-off depends on the structural variation within a protein family and the likelihood that a match to a non-homologous protein occurs due to chance. in our work we use a nonparametric model to compute the statistical significance of each match. this model is briefly summarized below and described in more detail in  <cit> . the model assumes that the matching algorithm returns for each target only the lowest rmsd, complete match to a motif. keeping partial matches or multiple matches per target complicates the determination of the statistical significance of each match. this is an issue we plan to investigate in future work.

for a set of matches we can compute a probability density function over rmsd by smoothing the rmsd distribution using the sheather-jones optimal bandwidth  <cit> . an example distribution is shown in figure  <dig>  in an ideal case, functionally homologous targets would have a low rmsd and would be well-separated from the non-homologous targets. from this rmsd distribution, which we will call a motif profile, we can assign a p-value to a match by dividing the area under the curve to the left of the match's rmsd by the total area under the curve. for instance, for the match at the cut-off in figure  <dig>  the p-value would be aa+b, where a and b are the areas under the curve to the left and right of the dotted line, respectively. however, the value of the distance cut-off parameter ε introduces an algorithmic bias that affects the computation of the statistical significance of a match. other matches could be found if the value of ε were increased. to correct for this bias, we model the existence of these 'missed' matches by placing a point-weight proportional to their relative frequency at infinity. the corrected p-value is then aa+b+c, where c is the weight of the missed matches. finding missed matches is straightforward: for each target where no match was found, we simply check whether there are enough residues of the right types so that a match is possible. the residue frequencies are pre-computed for each target and stored inside the labelhash tables.

it can be shown that for a motif of n residues our statistical model computes the exact p-value of matches with rmsd less than ε/n, i.e., their p-value would not change if no ε threshold was used  <cit> . for example, for a 6-residue motif and ε =  <dig> Å, the p-values of all matches within  <dig>  Å of the motif are exact.

implementation
data layout
we aimed for labelhash to be scalable to all available structures in the protein data bank, even as it continues to grow. the structural information, reference sets and indexing information require significant storage. the data layout is determined not only by the content, but also by the expected access patterns. space-efficient storage of all data that supports computationally efficient access can contribute significantly to the overall speed of the algorithm. typically, only a very small fraction of the data is accessed in matching a motif for two reasons. first, only a small number of reference sets in a motif is used for match expansion. second, often we are only interested in matching a motif against a subset of all known structures . the data format should also be extensible  and allow concurrent access to facilitate parallelized matching . in our current implementation we have chosen to use the hierarchical data format   <cit> , a standard file format used for large data sets. conceptually, the hdf <dig> software library creates a file system within a file. with hdf <dig> one can easily create and change hierarchical groups of data sets, without having to worry about keeping all the indexing information up-to-date. it also allows for sophisticated compression schemes  and includes support for parallel i/o .

the data is laid out as follows. for each target there is a group that contains data sets with the target's structural information, residue types, and any other information specific to the target that we may add in the future. for every possible set of n residue labels, we store all the reference sets with those labels in a large matrix with n columns, where n is the reference set size. associated with each matrix is some additional indexing information that keeps track of which block of rows in each matrix contains indices into which target structure. the n-tuples take up the bulk of the data that needs to be stored, but, luckily, they are also very compressible. we chose to use szip  <cit>  compression because of its high compression ratio and fast decompression speed. the labelhash hdf <dig> file for the entire pdb , including reference sets and all metadata takes up  <dig> gb. although this is a very large file, it still fits easily on commodity hard drives , and a significant portion of the file could be kept in memory  on a dedicated server.

large-scale matching
multi-core processors and distributed computing clusters are increasingly commonplace, and naturally we would like to take advantage of that. both the preprocessing stage and the matching stage are parallelized, and a near-linear speed-up with the number of cpu cores can be achieved. in the preprocessing phase a master node asynchronously sends pdb id's to slave nodes, which read the corresponding pdb file, compute the reference sets, and send all data back to the master. the master node writes all data to disk. although this seems suboptimal in terms of communication, it avoids the difficulties associated with parallel write access  or a sequential merge of several files .

matching in labelhash is also easily parallelized. the targets to be matched are evenly divided over the nodes and each node matches a given motif against its targets independently. once matching is finished, the match results are aggregated into one output file by one of the cores. this parallelization scheme could lead to load imbalance if matching against some targets takes significantly longer than others. in our experiments the number of targets was usually large enough and arbitrarily distributed over the nodes such that there was no imbalance. if load imbalance were to become an issue, it would be relatively easy to implement schemes that dynamically assign batches of targets to the nodes. another potential performance bottleneck is the simultaneous disk access by the nodes. if all nodes independently try to read data from the labelhash table, they can spend a significant amount time in system calls, waiting for disk access or seeking the right disk sectors. the bulk of the data that needs to be read consists of the n-tuples for the selected targets. this data is read synchronously using the hdf5-provided software layer on top of mpi-io. the amount of data to be read by each node is roughly equal, so that idle time is minimized. once the n-tuples have been read, the match augmentation phase starts. for each of its targets, a node will load the structural information from the labelhash table and compute the best match. the computation time tends to be significantly larger than the disk access time, so that the nodes can read the data asynchronously with only minimal disk contention.

algorithmic issues
in the original implementation of match augmentation  <cit> , the runtime was dominated by computing  rmsd alignments and  nearest neighbors for a motif point in a target structure. in addition to the performance improvements obtained through the pre-computation of reference sets, the labelhash algorithm uses a fast, new algorithm and pre-computation, respectively, to speed up these two components.

the match augmentation algorithm iteratively updates the rmsd alignment with each residue added to a partial match. since match augmentation is started from many matching reference sets and for each partial match there can be many possibilities for match augmentation, the computation of rmsd alignments can potentially be a performance bottleneck. computing such alignments typically involves computing a covariance matrix and the largest eigenvalue/eigenvector pair of this matrix  <cit> . for small substructures the computational cost is dominated by the eigenvalue/eigenvector calculation. we use a recently proposed method to compute the optimal alignment by finding the largest root of the characteristic polynomial, instead of computing a matrix decomposition of the covariance matrix  <cit> . using this method in our implementation, the time needed for rmsd calculations is drastically reduced to less than one tenth of the traditional approach.

to expand a partial match by one residue, the match augmentation algorithm looks for matching residues for the next motif point under the current optimal alignment. the matching residues are found using a proximity data structure. several such data structures exist; in our implementation we use geometric near-neighbor access trees  <cit> . the key observation to speeding up proximity queries is that the nearest neighbors of a motif point are very similar to the nearest neighbors of the point in the target closest to this motif point. suppose we are interested in all nearest neighbors within  <dig> Å of a motif point and the closest point in the target is x Å away. then the set of nearest neighbors of this point that are within  Å includes all the nearest neighbors of the motif point. those within  Å are guaranteed to be also nearest neighbors of the motif point, and only those within the  Å to  Å range need to be checked. so the nearest neighbors of an arbitrary point can simply be found by computing one nearest neighbor, and looking up the nearest neighbors of this neighbor. to be able to look up all nearest neighbors for an arbitrary point within a radius of r Å, we need to precompute nearest neighbors for each target within a radius of 2r Å, since x can be at most r Å. this is exactly what is currently implemented; the indices of the nearest neighbors and corresponding distances are stored  for each target point. this adds only marginally to the total table size, while providing significant speedups.

the labelhash server and chimera interface
the labelhash algorithm has been made accessible through a web interface at http://labelhash.kavrakilab.org. a user can specify a motif by a pdb id and a number of residue id's. for each motif residue the user can optionally specify a number of alternate labels. the user can match against either the full pdb or the 95% sequence identity filtered non-redundant pdb . once the matches for a motif have been computed, an email is sent to the user which includes a url for a web page with the match results. this page lists information for the top matches, including: the matched residues, the rmsd, the p-value, enzyme commission  numbers and gene ontology  annotations , and a graphical rendering of the match aligned with the motif.

from the results page, one can also download an xml file that contains all the matches found. this match file can then be loaded in chimera, a popular molecular visualization and analysis program  <cit> . for this, we have developed a plugin called viewmatch.  the viewmatch plugin allows the user to scroll through the list of matches. figure  <dig> shows the user interface. in the main window a selected match is shown superimposed with the motif. recall that, although all atoms in the matched residues are shown, only the cα atoms were used to compute the alignment. the cα atoms are shown as spheres. in the controller window on the right, all matches are listed in the top half with their rmsd to the motif, p-value and other attributes. by specifying constraints on the match attributes, the user can restrict the matches that are shown. the bottom half of the window shows additional information for the selected match, such as the ec classification and go terms. by clicking the pdbsum button, the pdbsum web pages  <cit>  are shown for the selected matches. this gives the user an enormous amount of information about a match.

we expect that advanced users may want to have more control over the matching parameters and the creation of labelhash tables. for that reason, we have made available for download on the labelhash web site a suite of command line tools  to do just that. it includes programs to run labelhash in parallel on a cluster of machines, as well as a python interface.

testing
the labelhash algorithm has been evaluated for speed, scalability, and functional annotation precision through a carefully selected set of case studies that demonstrate orthogonal features of the algorithm. first, the ability of labelhash to identify common substructures at the superfamily level of scop  <cit>  classification is validated within the enolase superfamily . second, the ability of labelhash to construct motifs from the output of state-of-the-art methods and then quickly match them against the entire pdb is demonstrated with the output of soippa  <cit> , a motif discovery and structural alignment algorithm. third, as a comprehensive functional annotation benchmark, labelhash motifs are created from catalytic residues documented by the catalytic site atlas   <cit>  and then matched against the nrpdb <dig> to assess per-motif functional annotation sensitivity and specificity. finally, we evaluate the speed and scalability of the labelhash algorithm by matching all motifs used in this paper against the nrpdb <dig>  together, these tests demonstrate the versatility and generality of labelhash for a variety of functional annotation problems.

identifying members of the enolase superfamily
to demonstrate the ability of labelhash to successfully identify motifs at the superfamily scale, spanning multiple ec classes, labelhash was used to identify shared catalytic substructures among enolase superfamily   <cit>  proteins. previous work by meng et al.  <cit>  used the spasm  <cit>  substructure comparison method to investigate a conserved substructure within es proteins. as a challenging validation experiment, labelhash was used to identify the conserved substructure  among the same benchmark set of es structures  that were both defined previously by meng et al.  <cit> . labelhash was able to identify those structures included in the esdb with high sensitivity and specificity. in addition to those structures included in the esdb, matches were identified by labelhash to additional es proteins which have more recently been identified and to several proteins with only putative es-like function.

the es currently includes  <dig> major sub-groups spanning  <dig> families and  <dig> well-defined ec classes as defined by the structure-function linkage database   <cit> . as shown in figure  <dig>  a core of five residues directly mediates the conserved partial reaction among es members. modeling this substructure as a five-residue motif as done by meng et al.  <cit>  results in the following superfamily-specific motif : 164kh, 195d, 221e, 247edn, 297hk; residues are numbered with respect to mandelate racemase structure . a benchmark set of es structures defined by meng et al.  <cit>   was used as a positive test set; the nrpdb <dig> was used as a background structure set which also includes several overlapping structures belonging to the es. residues making up the conserved substructure among es members are known to vary widely in cα rmsd  although the side-chains of the residues superimpose closely . by using labelhash to enumerate all reasonable substructure matches based on cα rmsd and then filtering the resulting potential matches by side-chain rmsd, labelhash successfully identifies es members with high sensitivity and specificity using the approach outlined below.

to identify matches based on a different distance metric rather than cα deviation involves adding only a simple post-processing step to the initial substructure matches identified by labelhash. for each target structure in the esdb, many possible matches are first identified based on amino acid label compatibility and cα distance cutoffs to the es motif. from these possible matches, a single "best" match is selected per target based upon minimum side-chain centroid rmsd to the motif rather than cα rmsd as done in previous experiments. the distribution of matches yielded by this process differs from the minimum cα distance distribution. for example, enumerating all possible matches in enolase structure  results in  <dig> possible matches and from these possible matches, a "best" match can be selected based on any user-defined criteria. for es we used side-chain centroid rmsd, but in general cα rmsd, surface accessibility, distance to a known ligand, or even colocation with a pocket/cavity could be used instead. for the es, side-chain centroid rmsd is preferred over full-atom side-chain rmsd due to the fact that several different types of amino acids are possible at each position and defining an appropriate one-to-one atom mapping between side-chains of different amino acids is difficult to define. however, cβ alignment is a viable alternative to the side-chain centroid if a pseudo atom is defined for glycine.

comparing the prediction performance of cα versus side-chain centroid rmsd for es, as shown in figure  <dig>  demonstrates that alternative match selection measures, such as side-chain deviation, outperforms cα deviation for the es. using minimum cα rmsd as a match selection criteria per target, only 31% of structures in the esdb are matched with statistical significance . however, with minimum side-chain centroid rmsd as a match selection criterion per target, labelhash achieves 95% sensitivity. the match rmsd distributions in figure  <dig> reveal the higher discriminating power of side-chain centroid rmsd for the es. using side-chain centroid rmsd, the distribution of matches for the esdb structures is easily separable from the much larger number of matches to nrpdb <dig> structures while cα rmsd alone results in the majority of esdb matches to overlap with unrelated matches to structures in the nrpdb <dig> 

many matches to nrpdb <dig> structures still fall below the statistical significance threshold  and these possibly false positive  matches were further investigated. out of the  <dig> total fp matches,  <dig> matches actually corresponded to structures that have now been identified to belong to es as documented by the sfld  <cit> . an additional  <dig> fp matches corresponded to structures that have only putatively defined functions, but may be related to the es: , , , , , , , , , and . the final  <dig> matches correspond to an aminoacylase from the m <dig> family  and human arginase i ; both matches correspond to dimetal binding sites within the two different enzymes which bind mn2+ and ni2+, respectively. altogether, these results highlight the potential of labelhash to identify similarities between remote homologs.

combining labelhash and soippa
recent work by xie and bourne on sequence order-independent profile-profile alignment   <cit>  and smap  <cit>  allows the alignment and identification of structurally similar, but sequentially distinct, sequence motifs. to further validate the labelhash method, the alignment output of soippa was used to create labelhash motifs that are demonstrated to maintain the high-specificity of soippa. labelhash provides the means to search the entire nrpdb <dig> for matches to soippa-derived motifs in a matter of minutes. these experiments illustrate how labelhash can be used to further enhance available structural analysis methods by converting identified residues of interest directly to labelhash motifs that can be efficiently scanned against large structural databases.

several of the aligned sequence motifs identified by soippa were used to construct the labelhash motifs listed in table  <dig>  for each template structure in this table, a labelhash motif was defined using the residues and alternate amino acid labels identified by soippa alignment  <cit> . specifically, to construct a labelhash motif from the soippa alignment output data, the coordinates of the soippa-identified motif residues from only the template structure are combined with the set of alternate amino acid labels identified by soippa-alignment; the coordinates of the structures aligned by soippa  are not used. each labelhash motif was then matched against the corresponding soippa alignment structures in the table, in addition to the nrpdb <dig> as a background structure set, in order to assess the statistical significance of matches in each corresponding alignment structure. in all cases the correct match was identified with extremely low p-values. both the labelhash motif substructure and corresponding match substructures can be seen in figures  <dig> and  <dig> 

combining multiple pairwise soippa alignments allows for the construction of a single labelhash motif that comprises the common soippa motif residues shared between each pairwise alignment. for example, based upon soippa pairwise alignments between sam-dependent methyltransferase  and each of urocanase , carbonyl reductase , and flavocytochrome c <dig> fumarate , a single labelhash motif was derived using the subset of residues from  identified by soippa  <cit>  within each of the three aforementioned pairwise alignments and the alternative amino acid labels for residues in each pairwise soippa alignment. the resulting labelhash motif correctly identifies the corresponding residues in each of , , and  without labelhash taking into account any knowledge of each of these three target structures beyond the alternate labels required. the -based labelhash motif was then matched against the full pdb to search for other structures with statistically significant similarity to the shared substructure modeled by the motif.

using labelhash to match the -based motif versus the pdb reveals many additional matches with low p-values to binding sites for adenine-containing molecules including fad, nad, and sam. although labelhash does not take into account the presence, position, or absence of a bound ligand at any point in the matching process, many of the identified matches could be confirmed as binding sites because of a bound adenine-containing ligand. matches to lipoamide dehydrogenase , urocanase , and mnmc <dig>  were identified with p-values less than  <dig> ,  <dig> , and  <dig> , respectively. each match identified is shown in figure  <dig> 

catalytic site atlas motifs
in our final experiment we matched a large number of motifs from the catalytic site atlas   <cit>  against the nrpdb <dig>  the csa is a manually-curated database of literature-documented functional sites. all experiments were conducted using csa version  <dig> . <dig> which contains  <dig> literature-documented sites. the subset of csa sites used in our experiments includes only literature-documented sites that adhere to the following criteria:

 <dig>  the pdb structure corresponding to the site must have a fully qualified ec classification ; each site will be compared against proteins within the same ec classification to assess sensitivity.

 <dig>  the ec class corresponding to the documented site must contain more than  <dig> structures so that meaningful per-site statistics can be computed for all sites included in the benchmark.

 <dig>  the labelhash motif based upon the csa site must contain at least one valid reference set .

 <dig>  the site must contain a minimum of  <dig> non-hetero residues  because the current labelhash implementation does not support matching heteroresidues/heteroatoms.

from the available  <dig> csa sites,  <dig> adhered to our criteria. from each of these  <dig> csa sites, a labelhash motif was constructed using the pdb structure that corresponded to each csa record in every case. because the csa does not include allowable amino acid substitutions or mutations for site records, only the single amino acid label that corresponds to the amino acids present in the pdb structure were used in all cases. the motifs analyzed here range in size from  <dig> to  <dig> residues, while previous work by torrance et al.  <cit>  only investigated the performance of csa motifs ranging from 3- <dig> residues in size.

to assess the ability of each csa-based motif to identify functionally equivalent catalytic sites in protein structure, each csa-based motif was matched against the ec class corresponding to the pdb structure of each site. structures sharing ec classification with the csa-based motif are considered positive matches while matches to structures outside of the motif ec class within the nrpdb <dig> were considered negative matches. for the csa benchmark, the individual chains in both positive and negative protein structures are matched individually. for the  <dig> csa-based motifs,  <dig> unique ec classes are represented spanning all  <dig> top-level ec classifications .

overall, the ability of csa motifs to identify members of the same ec class  varied wildly. this result is not unexpected due to the fact that per-ec class coverage was not a consideration in the design of the csa  <cit> ; the aforementioned study by torrance et al.  <cit>  considered the set of positive structures for each motif to be the "csa family" of psi-blast identified relatives rather than the full, 4th-level ec class. the analysis performed here widens the study by considering not only those structures with sequence similarity identifiable by psi-blast, but the entire set of structures sharing an ec class with each motif. highly successful motifs, such as the pyruvate kinase and xylose isomerase motifs based upon structures  and , respectively, correctly identify more than  <dig> matches to their corresponding ec classes, achieving > 90% ec-class sensitivity with at least  <dig> % specificity against the entire nrpdb <dig> 

the csa contains multiple catalytic site definitions for a single ec class in several cases  and the motifs based on each definition sometimes had large differences in function prediction performance. consider, for example, two motifs are defined by the csa for ec: <dig> . <dig>  : the motif based upon structure  from lactobacillus casei was defined as {198c, 219s, 221d, 257d, 259h, 60e} and matched 192/ <dig> chains with significance resulting in  <dig> % sensitivity at a p-value threshold of  <dig> , while the motif based upon structure 1tys from escherichia coli was defined as {146s, 166r, 169d, 58e, 94y} matched only 4/ <dig> chains with significance resulting in a drastically lower  <dig> % sensitivity at the same p-value threshold. examining the ec: <dig> . <dig>  matches produced by the poorer performing  motif revealed that a single motif residue  was matching a non-cognate serine residue in the majority of ec: <dig> . <dig>  structures that caused the rmsd of these matches to increase drastically and fall outside of the significance threshold. however, pruning 146s from the  motif increased the sensitivity to  <dig> %, matching 175/ <dig> chains in ec: <dig> . <dig> .

in other cases where multiple motifs were defined by the csa for a single ec class, each motif was found to match a different subset of functionally related structures. for example, the csa defines a separate motif for both cellobiohydrolase  i and ii from trichoderma reesei which both belong to ec: <dig> . <dig>  . individually, the cbh i and ii motifs have a sensitivity of  <dig> % and  <dig> %, respectively, at p =  <dig> , but because both motifs match a mutually exclusive set of structures within ec: <dig> . <dig> , the combination of both motifs identifies over 60% of structures within ec: <dig> . <dig> . however, combining the results from multiple motifs by taking the union of all positive matches will result in a decrease in overall specificity due to lack of multiple testing correction. in recent work  <cit> , we have developed a technique call motif ensemble statistical hypothesis testing that allows multiple  motifs to be statistically combined into a single function prediction test.

many of the csa motifs included in the benchmark could be further optimized to increase function prediction sensitivity and specificity. the previously developed geometric sieving  method for motif refinement  <cit>  identifies subsets of motif residues within a larger motif that preserve the overall specificity of the larger motif while increasing sensitivity by removing motif residues that do not contribute to specificity. also in previous work  <cit> , evolutionary methods based upon multiple sequence alignment  and phylogenetic tree construction, such as evolutionary trace  <cit>  and consurf  <cit> , have been used to automatically define motifs and identify alternate residue labels in order to represent residue substitutions present in a msa. therefore, while the csa motifs examined in this benchmark serve as an objective set of expert-defined catalytic site definitions, many motifs could be improved further by applying our previously investigated optimization techniques.

performance and scalability
there were  <dig> motifs used in the comparison with soippa,  <dig> motifs in the enolase superfamily study, and  <dig> catalytic site atlas motifs. in general, wallclock time can be reduced significantly by using more cores. the motifs that take more time to match tend to be larger and have more alternate residue labels. for small, simple motifs  the wallclock time with a single core is already very small and there is not much room for improvement by adding more cores. in this case the runtime is dominated by file access and communication between the cores, with only minimal time needed for computation. the difference between the solid and dashed lines show the performance increase when switching from a shared panasas filesystem to a local solid-state drive. this difference confirms that much of the time is spent simply reading data. in other words, for simple motifs there is limited room for performance improvement by modifying the match augmentation algorithm. for motifs that take longer to match  we see that an almost linear speedup can be expected.

CONCLUSIONS
we have presented labelhash, a novel algorithm for matching structural motifs. it quickly matches a motif consisting of residue positions, and possible residue types to all structures in the pdb . we have shown that labelhash often achieves very high sensitivity and specificity. the statistical significance of matches is computed using a non-parametric model. typically, the number of false positive matches is much smaller than the number of true positive matches, despite the large number of targets in our background database. this greatly speeds up the analysis of match results. our algorithm uses only a small number of parameters whose meaning is easy to understand and which usually do not need to be changed from their default values. matching results are easily visualized through a plugin for chimera, a molecular modeling program.

extensibility was an important factor in the design of the labelhash implementation. our program is easily extended to incorporate additional constraints or use even conceptually different types of motifs. for instance, matching based on physicochemical pseudo-centers  <cit>  could easily be incorporated, and we plan to offer this functionality in the future. input and output are all in xml format , which enables easy integration with other tools or web services. as we demonstrated in the study of the enolase superfamily, labelhash can be part of a multi-stage matching pipeline, where matches produced by labelhash can be given to the next program, which can apply additional constraints to eliminate more false positives. as long as the set of matches produced by labelhash include all functional homologs, this is a viable strategy. of course, the output of labelhash can also easily be passed on to any clustering algorithm or a visualization front-end.

our matching algorithm has the capability to keep partial matches and multiple matches per target. this makes the statistical analysis significantly more complicated. currently, we just disable the p-value computation when either option is selected, but we plan to investigate the modeling of the statistical distribution of these matches.

