BACKGROUND
a number of studies have described the search of repeated elements in a genome. however, except for phylogeny, few studies systematically analyze the relationships and variations between the copies of a given family of repeats.

tes  are present in nearly all genomes that have been studied to date and in some cases represent most of the genome  <cit> . these transposable elements move or are copied from one genomic location to another  <cit> . tes are characterized and classified on the basis of terminal or subterminal remarkable structures or of their protein-coding capacity. tes that encode the proteins involved in the amplification mechanism are called autonomous. two types of amplification mechanisms define two classes of transposable elements. class i elements, or retrotransposons, move via an rna intermediate. class ii elements, or dna transposons, seem to move via "cut-and-paste" mechanisms where the dna element itself is the mobile intermediate  <cit> .

the transposable elements have an important role in the evolution of eukaryotic genomes through their transposition mechanism  <cit>  but also by their evolution/domestication  <cit> . many recent studies clarify the diverse role of transposable elements in the evolution of their host genome: creation of naip protein isoforms and promoter by the insertion of l <dig> and alu elements  <cit> , plant light-sensing dependency on the presence of fhy <dig>  fhl fhy <dig> and far <dig> that are related to mule transposases  <cit> , exaptation of the transposon charlie <dig> in the mammalian zinc finger  <dig> gene  <cit>  and creation of new host gene by capture of transposable element domains  <cit> .

many families of both classes do not show any coding capacity and are called non-autonomous transposable elements. they have cumulated so many mutations, insertions or deletions that these tes are generally solely defined by their extremities  <cit> . currently, most studies do not attempt to characterize and compare the internal sequences occurring between such extremities. a few methods  <cit>  propose to segment sequences into conserved segments that we call modules, starting from a multiple alignment of these sequences.

multiple alignments that find the boundaries of these segments in highly variable sequences like non-autonomous transposable elements may be hard to obtain. moreover, multiple alignments lack to find duplication and inversion in sequences that are frequent in non-autonomous tes .

in the present study, we propose a model and develop pattern matching and classification tools that allow identification, characterization and graphical representation of the combinations of modules that make up each sequence of a given family. we applied it to the study of a family of non-autonomous tes of class ii, called foldback <dig>  <cit> , in the whole genome of drosophila melanogaster. this family has been chosen as an illustrative model of the complex internal organization of non-autonomous transposons, displaying a wide range of possible variations and a palindromic structure at the extremities of its sequences. we have also tested the method on other transposon families, namely atrep <dig>   <cit>  and sider <dig>   <cit> , which confirm the interest of the tool we propose for the study of highly variable sequences.

methods
our method represents a given family of te sequences as an assembly of elementary blocks called modules. we propose an associated tool, moduleorganizer, assuming that these sequences have been selected on the basis of local characteristic features  and providing a global high level characterization of them facilitating the study of their variations. the section starts with a precise definition of properties that are suitable to delimit modules. we then describe in detail the method we propose for module identification.

overall, it is based on the search and assembly of "maximal repeat" common to several sequences. a word w is a maximal repeat  in a non-empty set of sequences s = {s <dig>  ..., sn} if, and only if, there are si, sj ∈ s  and letters a, b, c, d, with a ≠ b and c ≠ d, such that awc is a substring of $sj$ and bwd is a substring of $sj$ . in order to compute all these mr, the sequences of the family are indexed via a generalized suffix tree  <cit> . our algorithm recursively associates maximal repeats of a same sequence into modules under restrictions corresponding to their definition, such as their size, the number of sequences supporting their presence and the content of the sequence between two mr. two final steps allow drawing an overall representation of the family: sequences are classified with respect to the presence or the absence of modules and a visualization tool yields an overall graphical view of the sequences.

defining modules in transposable elements
in theory all sequences of a given family of transposable elements are identical copies of an ancestor sequence. in practice an amount of variation is observed in te copies, in connection with the age of the copies and the mutation rate. there are several kinds of te that exhibit a reorganization of internal sequences including insertions and deletions of large sequences: the miniature inverted-repeat transposable elements   <cit> , the mu-related bacterial transposons  <cit>  and the helitron superfamily  <cit>  that integrate blocks of genomic material into their variable sequence  <cit>  and the short interspersed degenerated retroposons  <dig>   <cit> .

non-autonomous transposable elements , like mites, which represent for some sequences the main source of copies, are often subject to deletions  <cit> . in such a case, it becomes difficult to reconstruct the autonomous element from the set of non-autonomous sequences  <cit> . we have studied as a test case the mite family foldback <dig>  <cit>  and in accordance with previous studies of non-autonomous tes  <cit> , it clearly exhibits variations conserved across several sequences that could be largely explained by biological events such as insertions/deletions of mobile dna or of host sequences  <cit> . in order to automatically retrace the main events that occurred, we have systematically exploited the fact that mites and other non-autonomous transposable elements present consensus patterns in their different copies  <cit> . for example, the mite mping, foldback <dig> or atrep <dig> share consensus extremities in all their copies simply because they are necessary for transposition  <cit> . the importance of host sequence acquisition mechanisms by tes is well known in plants  <cit>  and leads to detectable repeated blocks in copies separated by small non-consensus nucleotidic regions.

we propose a definition of module for this type of repeated blocks that introduces cautiously these separating nucleotides. basically, a module is an assembly of flexible repeats. each flexible repeat is a maximal repeat combination that occurs several times in sequences where mr are separated by a variable number of nucleotides. this class of repeats can be related to the class of structured repeats introduced by m.f. sagot  <cit>  but introduces new interesting variations that will be discussed in the results and discussion section under paragraph structured versus flexible repeats. flexibility is founded on two simple criteria that delimit the possible spacers between consecutive repeats by fixing a reasonable level of similarity between instances of the same flexible repeat. flexibility cannot be greater than the parts it links.

• flexible repeats: let s = {s <dig> ..., sn} be a set of sequences. let |w| denote the length of word w and e denote the edit distance between words w <dig> and w <dig>  a flexible repeat is inductively defined as follows:

 <dig>  each maximal repeat is a flexible repeat

 <dig>  if a and b are flexible repeats and there exist a support subset of sequences t ∈ s of cardinality at least  <dig>  and words aixibi in each sequence si of t satisfying the following constraints:

 ai and bi are occurrences of a and b in sequence si

 length condition: |xi| ≤ max

 distance condition: e ≤ min for all pairs si, sj in t

then  is a flexible repeat with occurrences aixibi.

the definition recursively accepts chains of maximal repeats separated by variable constrained spacers. the length condition applies on spacers in each sequence individually whereas the distance condition requires a similarity level between all spacers globally. from this general notion of flexible repeat, one can define modules as a selection of flexible repeats that get a sufficient support in the set of sequences, that do not overlap and cover as much as possible of this set. more formally:

• modules: given parameters minsizemodule and minsequences, a module m in a set of sequences s = {s <dig>  ..., sn} is a flexible repeat satisfying the following constraints:

 <dig>  size condition: each occurrence of m has length at least minsizemodule.

 <dig>  support condition: m is present in a support subset of cardinality at least minsequences of s.

an admissible set of modules m = {m <dig>  ..., mm} in a set of sequences s = {s <dig>  ..., sn} is a set of modules such that:

 <dig>  partition condition: for two different indices i and j, mi and mj do not overlap. moreover, no other flexible repeat contains a module mi.

 <dig>  maximality condition: no other flexible repeat fulfilling the previous three conditions  could be added to m.

such a definition aims at selecting globally a set of modules that must cover a largest subset of a set of sequences. once admissibility has been reached, there remains some range of variation to build a set of modules from a set of sequences. we propose an iterative strategy based on a preliminary search for seeds at the core of the largest flexible repeats.

an assembly algorithm for the creation of modules
targeted modules have sizes greater than minsizemodule and are present in at least minsequences sequences. all admissible modules are based on an assembly of maximal repeats. in an initial step, our algorithm will thus build the set of all mrs present in at least minsequences sequences. this may be achieved in linear time with respect to the cumulated length of the sequences, using a generalized suffix tree  <cit> . these exact maximal repeats can be considered as seeds which are extended to the left or to the right depending on the admissibility of the extension. this method of seed extension is similar to the method used in blast  <cit> .

the construction of modules is detailed in algorithm  <dig>  its basic data structure is a list l of mr sorted by decreasing size, then by number of occurrences. each maximal repeat is associated with the sorted list of its occurrences in increasing position. initially, l contains the whole set of mrs present in at least minsequences sequences and it is updated after the construction of each module .

algorithm 1
 <dig>  buildmodules

 <dig>  require: sorted list l of possible mr 

 <dig>  require: minimal number of covered sequences minsequences

 <dig>  i ← 1; pairok ← false

 <dig>  comment: looking for a a pair of mr  in decreasing order of size in l

 <dig>  while 

 <dig>    seed ← l

 <dig>     ← buildpair

 <dig>    i ← i + 1

 <dig>  if 

 <dig>    discard the paired occurrences a of seed from l

 <dig>    comment: try to enlarge the current flexible repeat to the left or to the right by a new maximal repeat

 <dig>    while 

 <dig>       depending on the observed occurrences of the flexible repeat, replace seed by seedxnext or nextxseed

 <dig>       discard the paired occurrences b of next from l

 <dig>       pairok ← false

 <dig>        ← buildpair

 <dig>    if  ≥ minsizemodule)

 <dig>       seed and its occurences as a new module

 <dig>    else ∅

for each module, the algorithm considers the largest remaining mrs as seed candidates and looks iteratively and greedily at flexible repeats that can be built from such seeds. at line  <dig> of algorithm  <dig>  a flexible repeat made of a flexible repeat seed and a maximal repeat next has been discovered and will serve as a new seed for the search of larger flexible repeats . once it is not possible to extend it any more , the last condition to be checked is the size of the obtained module.

the search for maximal repeats to be associated with seeds in flexible repeats is described in algorithm  <dig>  associations are represented as axb or bxa, where a is the largest part and b is the smallest part of flexible repeats. this convention explains the simplified tests for flexible repeat length and distance in algorithm  <dig>  the spacer x can be an empty sequence . the first condition of flexible repeats is checked in line  <dig> and the second in line  <dig> . the test in line  <dig> also checks if there is at least one association in each of minsequences sequences, the first condition for a flexible repeat to be retained as a potential module. in building flexible repeats, the algorithm chooses the largest maximal repeat b that has the most associations with a.

algorithm 2
 <dig>  require: buildpair

 <dig>  require: sorted list l of possible mr 

 <dig>  require: a flexible repeat seed and a starting index start for the search in l

 <dig>  require: minimal number of covered sequences minsequences

 <dig>  j ← start; pairok ← false

 <dig>  while 

 <dig>  next ← l; pairs ← Ø

 <dig>    for 

 <dig>       search for the occurrences b of next such that axb  or bxa  is a subword of the sequence and x has size at most the size of a

 <dig>       if 

 <dig>          pairs ← pairs ⋃ {}   comment: b is the size of b

 <dig>    comment: build the graph gb of occurrences at a suitable edit distance in pairs

 <dig>    for , ) in pairs in each orientation

 <dig>       if  ≤ min)

 <dig>          create an edge in gb between vertex  and vertex 

 <dig>    if 

 <dig>       pairok ← true

 <dig>    j ← j + 1

 <dig>    return 

the worst case complexity of algorithm  <dig> is o, where n is the cumulated size of sequences: it is based on a loop on possible maximal repeats ) including a loop on possible matching occurrences  since list of occurrences of a and b can be searched in parallel), the production of a graph of similar occurrences ) and a search of a clique of size at least minsequences in this graph ). note that the last step offers no guarantee to always find the clique if it exists. algorithm  <dig> is also based on a loop on possible maximal repeats ) including calls to algorithm  <dig>  the total worst case complexity is thus o. the main data structure are the list l of occurrences of maximal repeats and the graph g, requiring o space. in practice, the algorithm is very fast  on typical transposable elements families . the tool we propose allows in fact a more flexible method of association of a and b. the size of spacer x has to be smaller than a percentage of the size of a . by default, the percentage value is 100% and corresponds to the criterion we have defined. with a lower percentage, it is possible to be more restrictive on the spacer size.

detection of all modules in sequences
after the creation of a module, the list l of maximal repeats must be pruned of any occurrence that overlaps occurrences of this module in order to fulfill condition  <dig> of the definition of modules . the algorithm stops the search for modules present in minsequences sequences when the procedure buildmodules returns an empty set.

at the beginning minsequences is set to the number of sequences present in the input file. after the algorithm has found all modules of size bigger than minsizemodule in minsequences sequences, the main loop searches for modules in minsequences = minsequences -  <dig> sequences until minsequences =  <dig> 

palindromic modules and truncated modules
transposable elements have two characteristics that are not taken into account by our module definition. first, elements may be copied in the direct or reverse direction. this leads to frequent palindromic motifs that have to be recovered in the context of flexible repeats. second, elements may be truncated due to large deletions or a high number of mutations. some partial flexible motifs may remain interesting to identify for a complete analysis of the transposon structure.

our tool proposes the identification of reverse modules on the basis of the exact mr they contain. in practice, all mrs are searched both on the direct and on the reverse strand and are consequently labeled. a reverse module has the same composition as the module it is derived from, replacing its mr by the corresponding reverse mr. once a module has been determined, the presence of its reverse module is systematically looked for in the sequences. the presence of a module in its direct or reverse form is counted whatever its direction. this way, the requested number of supporting sequences minsequences may be attained by a combination of both directions.

truncated modules may exist with a conservation level that is very low, one or several mrs being discarded from the original copy. it is difficult to define an absolute conservation threshold that would decide if a given degenerated combination of mr remains or not a truncated version of a module or if it must be considered as a new entity. modules are often composed in practice by a main founding mr surrounded by several smaller mrs at some distance. we have chosen to require that the largest mr remains present in a truncated version of a module, a simple constraint that ensures at least a core identity with the full module. unlike the previous case, truncated modules are considered only if the full module exists in the set of sequences. they are added during a second step, once all complete modules have been identified.

clustering of sequences
after the module detection stage, assume m different modules have been obtained in n sequences. the next step of moduleorganizer is to build a hierarchical clustering of sequences  conducted on the basis of module similarity. this way, the evolution of sequences in the family can be traced back by comparing sequences in decreasing order of similarity of their modular profiles. basically, each sequence is represented by a vector of values on a set of attributes , one numerical attribute per module that is a counter of its occurrences. if the user does not select the search for reverse or truncated modules, the software creates thus an incidence matrix of dimensions m × n.

if reverse modules are allowed, more attributes are necessary to finely describe the evolution of sequences. for each module we create three attributes: one counting the number of direct occurrences , one counting the reverse occurrences, and a last counter for occurrences of the module . the third attribute allows to measure the convergent evolution of palindromic structures like inverted terminal repeats  <cit> . indeed, the transposase of autonomous elements recognizes specific palindromic structure at their extremities  <cit> . the mutation of one extremity decreases strongly their transposition. a double mutation in both extremities may restore the palindromic structure and transposition. this has been observed for instance within families of mariner-like elements  <cit> . the incidence matrix has size 3m × n with the reverse option.

the presence of truncated occurrences of modules slightly extends the meaning of the attributes we have just defined. these occurrences correspond to small fragments of entire modules, and are composed of a selection of the module mr. while full module occurrences contain 100% of the cumulated size of mr, truncated occurrences contain a lower percentage of this total size reflecting the deleted fraction of a module mr: a complete direct or reverse occurrence will contribute for  <dig> and a truncated occurrence will have a strictly smaller positive contribution. for instance in figure  <dig>  the module m <dig> has one complete occurrence in sequence a and b and one truncated occurrence that contributes at level  <dig> .

sequences are clustered using a standard hierarchical agglomerative clustering  algorithm, using the ward criterion  <cit> . ward's criterion states that merging hac clusters should be focused on minimizing the increase of variance induced by the added interclass variance. basically, it is an error sum-of-squares criterion. in the first step, the loss of inertia in aggregating sequence pair x and y Δ=12n∑i∈attributes <dig> is computed between each possible pair, where xi  corresponds to the value of attribute i in sequence x  and n is the number of sequences. starting from clusters reduced to a single sequence with weight 1/n, the pair of clusters minimizing Δ is replaced by its union and the values of the weight and Δ for this new cluster is updated =1nx+ny+nzΔ+Δ−nzΔ)). the algorithm iterates until all sequences are in the same cluster.

RESULTS
implementation
the module detection program  and the classification program are written in the c language. the software produces one to three output files. the first file is the only mandatory output file. it corresponds to the list of sequences with their composition in modules. it uses the same output format as domainorganizer  <cit> . the second file corresponds to the classification of sequences and is written in newick format. the third file is the output graph written in svg  format . in this file, the sequence module contents are displayed together with their classification tree. a specific texture is associated to each domain and specific markers are used for reverse  or truncated  modules.

moduleorganizer is relatively fast. the next two sections give results on three transposable element families: atrep <dig>  sider <dig> and foldback <dig>  for a total of  <dig>   <dig> and  <dig> nucleotides respectively. on a pc running with an intel core <dig> duo  <dig>  ghz and  <dig> go ram, these results have been obtained in  <dig>  s,  <dig>  s and  <dig>  s respectively.

moduleorganizer allows users to tune a few parameters with respect to their application:

• the first parameter is the minimal size minsizemodule of admissible modules. we assume that in most cases the user has some knowledge of the sequences in the input file so that the user can fix or adjust iteratively the value of minsizemodule. by default, moduleorganizer proposes to set minsizemodule to the minimal value of x such that it exists a word of size x that is not present in the sequences.

• the second parameter maxratio is the percentage that can be used in the length condition of flexible repeats , e.g. maxratio =  <dig> corresponds to spacers between elements a and b of flexible repeats possibly reaching the size of a. the selection of modules is a trade-off between size and similarity. lower values of maxratio allows to move this trade-off to smaller sizes of modules and more similar occurrences .

• the third parameter is the minimal number of sequences that must support the presence of modules. our algorithm searches modules in minsequences sequences. by default, minsequences will get all values in the range from the number of sequences up to  <dig> sequence.

• the last parameter allows the search for palindromic and/or truncated modules .

module organization of atrep <dig> and sider2
atrep <dig> is a family of non-autonomous helitron transposable elements present in arabidopsis thaliana  <cit> . we used moduleorganizer on the  <dig> elements of this family, setting just the minsizemodule parameter to  <dig> instead of the default value  <dig> that would result in a too detailed view. no palindromic modules exist in this family  <cit>  and it is not necessary to use this optional search. there are  <dig> modules that characterize the whole family . the module number  <dig> and  <dig> correspond respectively to the left and right extremities of atrep <dig>  the comparison of results between domainorganizer  <cit>  and moduleorganizer shows a similar module organization. for example, the atrep <dig> elements number  <dig>   <dig>   <dig>   <dig>   <dig> belong to the same cluster . the sequences of atrep21- <dig> and atrep21- <dig> are clustered by moduleorganizer in a specific group that corresponds to the insertion of a long transposable element. this is the sole minor difference between results provided by the two methods. for this family, the main difference lies rather in the execution time: more than  <dig> hours for domainorganizer and less than one minute for moduleorganizer.

sider <dig> is a family of short interspersed degenerated retroposons that smith et al. found in three leishmania genomes  <cit> . we selected  <dig> of the  <dig> sider <dig> they reported. we set the parameter minsizemodule to its default value  <dig> and the parameter maxratio to  <dig>  a value that generates a more detailed segmentation with more similar module occurrences than the default value  <dig>  this allowed to better recover crossing effects that we wanted to show. the figure  <dig> shows sider <dig> sequences are clustered into four groups: a, b, c and d . group a is mainly composed by the modules  <dig>   <dig>   <dig>   <dig>   <dig>   <dig>   <dig>   <dig> and  <dig> . the larger modules of sider <dig> sequences of group c are modules   <dig>   <dig>   <dig>   <dig>   <dig>   <dig>   <dig>   <dig>   <dig>   <dig>   <dig>   <dig>   <dig>   <dig>   <dig> and  <dig>  in the sider <dig> sequences of group d, modules  <dig>   <dig> have been deleted and modules  <dig> and  <dig> have been substitued by  <dig> and  <dig> respectively. group b presents a clear combination/exchange of modules with the other groups: the modules  <dig>   <dig>   <dig> and  <dig> come from the c/d groups and the module  <dig> from group a. moreover, figure  <dig> shows some conserved modules that would be impossible to observe with multiple alignment: some modules cross themselves in sider <dig> sequences. for example, module  <dig> is present in all sequences: in group b it lies between modules  <dig> and  <dig> and the module  <dig>  but in group c it lies between module  <dig> and the modules  <dig> and  <dig> 

organization of modules in foldback4
we have chosen the family of non-autonomous tes foldback <dig>  known to be present in the d. melanogaster genome  <cit>  in order to propose a more complete comparative analysis of a te family with several available softwares.

ten foldback <dig> sequences have been identified and numbered with respect to their order of occurrence on the direct strand. these elements range from  <dig> bp to  <dig> bp. we used stan   <cit>  to find the sequences from the genome and fgenesh software  <cit>  to verify that sequences do not contain orfs and are thus non autonomous elements. minsizemodule was set to  <dig> bp and we have used the optional search for palindromes and truncated modules in sequences. the module-identification algorithm discovered  <dig> modules .

the palindromic structures of the foldback <dig> family have been recovered and are described by domain numbers 1- <dig> and  <dig>  except for foldback sequences number  <dig> and  <dig>  which present a deletion of modules  <dig>  and 2- <dig> respectively, termini palindromes of this family measure more than  <dig> bp and represent the most important part of their sequences . the foldback <dig> family shows a significant variation in internal sequences resulting from insertions, deletions or substitutions of domains. the visualization shows that foldback <dig> is mainly divided into two groups of sequences.

the first group  contains foldback <dig> sequences number  <dig>   <dig>   <dig> and  <dig>  this group is mainly composed of the combination of modules number 1- <dig>   <dig>  9- <dig> and their reverse complement. the most notable variation between them comes from the number of repetitions of modules  <dig> and  <dig> that represent the central part of these sequences. the sequence fb4_ <dig> does not contain any repetition and fb4_ <dig> contains three consecutive repetitions of modules  <dig> and  <dig> 

the second group  contains foldback <dig> sequences number 2- <dig>  7- <dig>  10- <dig>  it is mainly characterized by the deletion of modules: no sequence of this group does contain modules 8- <dig> in its middle part. the module  <dig> that belongs to the left side of the palindromic structure is deleted in sequences  <dig> and  <dig>  the sequence  <dig> contains only the module  <dig> in the right part of the palindrome and the module  <dig> is deleted in the right part of the palindrome of sequence  <dig> 

recovering the module architecture in the foldback <dig> sequences establishes a probable scenario for the evolution of this family. note that we do not propose here a complete phylogenetic analysis of the family that would be beyond the scope of this paper. our purpose is just to illustrate the kind of hypotheses that can be elaborated from such characterizations. like mite elements, non-autonomous families generally derive from autonomous elements that are subject to deletion events  <cit> . after such deletions, the amplification of te can create tandem repeats of minisatellites inserted into the non-coding sequence  <cit> . for the foldback <dig> family, we assume similar deletions and mutations have created these non-autonomous elements from autonomous elements and that in a second step some internal duplications have occurred. if it is the case, the oldest sequence  contains the highest number of modules together with the lowest number of duplications. the sequence fb4_ <dig> corresponds to these criteria: it contains both all modules and the least number of repeated modules. we then assume the evolution of this family mainly comes from the duplication or the deletion of modules. from this sequence fb4_ <dig> other sequences have evolved by the amplification of left internal modules  <dig> and  <dig> . the sequences  <dig> and  <dig> seem older than the other sequences because they did not evolve after these amplifications. from these sequences, the amplification of the right modules led to the sequence  <dig>  the other sequences then evolved from this point by the deletion of the central modules. we assume that sequences  <dig> and  <dig> have been created from sequence  <dig> by the deletion of one block of consecutive modules .

our method highlights the complexity and variance of the sequence structure between members of a given family of tes. these differences, which may result in a certain level of disconnection between te repetition and module repetition within a genome, are usually not observable by standard sequence analysis tools on dna such as blast, or specialized software programs for the analysis of tes .

structured versus flexible repeats
the idea of looking for a series of words placed at constrained distances on genomic sequences is not new. the class of structured repeats has been introduced in  <cit>  in order to formalize the type of sequences involved in regulation . basically, a structured repeat is define as an ordered collection of several simple motifs  interleaved by bounded gaps.

spaced dyads are probably the simplest notion of structured motif and have been proposed by j. van helden & al  <cit> . a spaced dyad is made of two boxes, two words at a fixed distance. the more general notion of structured motif as it is used for instance in risotto  <cit>  allows variations in the size of single motifs , in the content of single motifs  and variation in the size of gaps . the number of motifs is fixed and the search for structured motifs uses a quorum corresponding to our parameter minsequences.

numerous authors have applied structured motifs in the framework of pattern matching  and this differs significantly from the pattern discovery task we are considering in this paper where the combinatory of possible arrangements has to be carefully controlled. the language a of anrep  <cit>  is one of the early successful proposition in this respect, already distinguishing simple motifs  from network patterns that allow gaps and disjunctions. advanced algorithms have been designed since and a few papers have presented experiments on the analysis of transposable elements  <cit> .

flexible repeats introduce a few specific characteristics with respect to structured repeats. first flexible repeats are not vectors of fixed size: flexible repeats may have a variable number of boxes and they are included in an embedding structure that is not a simple linear ordering. second, the possible variations are strictly confined in the gap part . boxes are words  that have to match exactly in the sequence. the restriction to mr provides a representative basis of all words that has a linear size with respect to the cumulated length of the sequences. note that there is no restriction on the length of these words and in practice all short words including single nucleotides are maximal repeats. structured repeats present a two level view of sets of sequences, a level of similar regions shared by a sufficient subset of these sequences and a level of assembly with completely specific regions that are solely represented by their length. we have adopted a different view where only the regions exactly shared by a sufficient subset of sequences are retained and where the assembly process results from a cautious iterative aggregation of these regions on the basis of similar inter-regions. regions that are completely specific to particular sequences are not associated with a module and are thus characterized negatively by the absence of modules.

to sum up, the standard approach for the segmentation of biological sequences in relevant modules is the pattern matching approach, where one is looking for common words within a certain admissible rate of errors. the issue described in this paper in rather an aggregation approach: starting from solid anchor boxes , we establish reasonable criteria to put them in a same class, in a user-understandable way. this is why we use the length of these anchors in our criteria. dropping the first condition on length in the definition of flexible repeats results in uncontrolled aggregations: it leads to a single module spanning the whole sequences for the family foldback <dig> for instance. looking for axb with the number of allowed errors made proportional to |x| in the second condition instead of min cannot be retained because among possible a and b are single nucleotide sequences and this would results in simply looking for all common approximate words on the set of sequences, a hard problem that has not been answered satisfactorily so far, as it appears in the following discussion comparing results of available tools. to the contrary, the principle "flexibility cannot be greater than the parts it links" offers a neat basis of aggregation that can be practically finely tuned by using parameter maxratio.

comparison with other programs
studies on non-autonomous transposable elements are rare because the main method of studying the evolution of these elements is based on their alignment with other known elements. since non-autonomous elements are generally highly variable, including numerous insertions, deletions, and repetitions, previously cited methods fail to find a good organization of the non-autonomous elements. we have tested four recent softwares that combine multiple alignment and graphical tools on the foldback <dig> family, trying each time to retrieve direct or reverse copied modules: vista  <cit> , gata  <cit> , graphdna  <cit> , recon  <cit>  and domainorganizer  <cit> . graphical results of these software are provided in the additional files.

the first software, vista http://genome.lbl.gov/vista/index.shtml <cit> , requires entering sequences separately and choosing a type of alignment. the user cannot set the value of multiple alignment parameters and one of the sequence must be set as a reference. in our case, the user has to check n results where n is the number of sequences. moreover, as vista does not display the reference sequence, it is impossible to obtain a complete view of all sequences. we provide in additional file  <dig> the graph resulting from the selection of f4_ <dig> as the reference sequence. the graph shows that, except for fb4_ <dig>  both extremities are conserved in all foldback <dig> sequences and that some parts of the internal sequence are conserved. we obtained similar results with the other fb <dig> sequences as reference. vista does not provide the palindromic structure of foldback that is important to understand the evolution of these sequences. moreover, the vista interface does not allow to change the parameters of the matching region  and the complexity and the structures of foldback <dig> internal sequences vanish completely.

gata http://gata.sourceforge.net <cit>  contains two different softwares: gataliner and gataplotter  <cit> . gataliner uses blast2seq  <cit>  to create the alignment. beside standard parameters of blast, such as the seed size and the mismatch cost, it offers a specific parameter on the minimal size of alignments that corresponds to minsizemodule in our algorithm. gataplotter is an interactive graphical tool that shows the alignment of a reference sequence  against another sequence. gataplotter has lots of rendering options and provides also two interesting options for the analysis of the dataset: annotation of aligned sequences and matching regions displayed by percentage of similarity. additional file  <dig> assembles all multiple alignments with a fixed threshold of 50% similarity to the reference sequence. the first sequence of each alignment corresponds to the reference sequence. on the contrary of vista but like our algorithm, gata shows these sequences contain a large palindromic structure at the extremities. except the fb4_ <dig> and fb4_ <dig>  all other sequences have a mismatch region in the center of their sequences. the main limitation of gata is the number of sequences the user can study. the user must open n <dig> windows for n sequences to get a global view of them. for foldback <dig> sequences we needed to open  <dig> different alignments. in practice, studies with more than  <dig> sequences become tedious.

graphdna http://athena.bioc.uvic.ca/tools/graphdna <cit>  uses fixed parameters for the multiple alignment. graphdna provides many views of the alignment such as 'purine skew', 'at skew' and 'dna walker'. these views show the skew of nucleotide combination at a given position, calculated on a window of user-defined size. dna walker is a graphical view of the four nucleotide skews along the dataset sequence. we chose the 'purine skew' view for the analysis of our dataset . graphdna provides in this case a global view of similar nucleotide composition regions that fit well with the conserved blocks observed by using a multiple alignment procedure. contrary to the two previous softwares, no reference sequence is needed and all sequences are displayed within a single view. we assumed that similar or parallel curves denote similar sequence fragments. the graph shows that all left extremities of sequences, except fb4_ <dig> and fb4_ <dig>  start at the same point, and are similar . after about  <dig> common bp, the sequences start to take different skews , and after  <dig> bp, sequences completely diverge. the right extremities are parallel and present the same skew pattern. this suggests that right extremities are similar too but give no details on the internal part.

recon http://selab.janelia.org/recon.html <cit>  is a perl script using blast results  <cit>  as input. the software aggregates the different fragments of blast hits in one long aligned region. users cannot tune the parameters of recon. on our dataset, the software chose foldback <dig> number  <dig> as the reference sequence.

two results of recon are presented: the final result with all similar parts assembled in blocks after the complete execution of recon algorithm, and an intermediate state given by recon that corresponds to the similar parts identified by blast and sorted by recon. the additional file  <dig> displays the final result using moduleorganizer textures. it shows  <dig> modules that often cover a large part of the sequence. these large modules do not show palindromic structures and differ for each sequence. however, the module number  <dig> is overlapped by modules  <dig> and  <dig> in fb4_ <dig> and fb4_ <dig> respectively. because we needed details on the composition of each sequence, we had to use the intermediate results proposed by recon, which contained the unclustered fragments. first, we removed the fragments shorter than minsizemodule , we labeled the fragments of each foldback te in agreement with fragments in the reference sequence and we sorted the fragment by increasing positions. finally, we renamed modules having the same coordinates in foldback sequences but not in the reference sequences and we also associate manually modules with different names that have similar coordinates in the reference sequence. the additional file  <dig> shows the fragments detected by recon. the recon modules   <dig>   <dig>   <dig>   <dig>   <dig> and  <dig> show the relative similarity of left extremities. right extremities are similar too and share common rmodules with left extremities, suggesting they could be complementary sequences. it is extremely difficult to point at similarities or structures in the internal part of sequences with the overlapping fragments, especially in the foldback <dig> sequence  <dig> that contains all rmodules. for example, only fb4_ <dig> exibits some repeated rmodules in its internal sequence.

domainorganizer  <cit>  fails to give a result with the foldback <dig> sequences. during the crucial and costly step of domain optimization, too many candidate domains are generated and the program is unable to find out a possible cover of sequences with domains .

gata  <cit>  is the only tested software that showed the palindromic structure. all other softwares failed to show the real structure of extremities and the module evolution of folback <dig> sequences. especially the internal part of sequences remained 'black boxes' in all these tools. except for domainorganizer where we were forced to use the atrep <dig> family for the comparison, we summarize in table  <dig> the range of application of each software extracted from our study on foldback <dig> 

the table summarizes the different structural modules that can be detected by the different tested softwares. the last column indicates if the software needs a reference sequence or not. big crosses in cells indicate the software displays the corresponding type of structure, small ones mean the structure could be deduced from the results.

CONCLUSIONS
our analysis provides structural results on the internal organization of a family of dna sequences. it can describe the differences between family members in terms of module content and highlights the evolution of the host genome with respect to these components. such a structural and descriptive abstract view should ease the analysis of te-genome relationships and give some support for studies on transposition mechanisms.

our method needs very few parameters. the most crucial one is minsizemodule and tuning this parameter with several tries is generally sufficient to get desired results. if the size of minimal domains is too small, the number of domains may simply be too large to give an interesting abstraction of the sequence. on the other hand, if the size of domains is too large, the number of domains may be too restricted to formulate a relevant biological interpretation.

of course, moduleorganizer might be applied in principle to any set of nucleic sequences sharing some similarities and for which a multiple alignment fails to correctly retrieve the architecture of conserved blocks in the sequences. the study of families of transposons is a natural setting for this tool but application on other types of sequences might help to explore other sequences at the desired level of abstraction.

authors' contributions
st has produced all the necessary code with the help of cr and made the experiments. jn supervised the study and proposed the model. jn and st wrote the initial version of the paper. cr and ft have checked and improved the writing of the paper. all authors read and approved the final manuscript.

supplementary material
additional file 1
visualization of foldback <dig> family with vista. we chose fb4_ <dig> as reference sequence. the bright red zones correspond to high similarity regions and the white zones correspond to low similarity region. the alignment criteria of vista are fixed in the software.

click here for file

 additional file 2
visualization of foldback <dig> family with gata. the reference sequence is fb4_ <dig>  the black and gray rectangles correspond to regions matched in the same direction and the red and bright red ones correspond to regions matched in reverse direction. the brighter the region, the more the similarity decreases.

click here for file

 additional file 3
visualization of foldback <dig> family with graphdna. each line corresponds to a different sequence of foldback <dig>  all sequences start at the same coordinate. the sequence fb4_ <dig> is the reference sequence.

click here for file

 additional file 4
visualization of foldback <dig> family with recon. as in the results displayed by moduleorganizer, each module has its own texture with graphdna. the result corresponds to the final output of recon: all similar parts have been associated in regard to the recon results.

click here for file

 additional file 5
visualization of foldback <dig> family using intermediate results of recon. as in the results displayed by moduleorganizer, each module has its own texture with graphdna. the intermediate results correspond to the enumeration of all similar parts recognized by blast comparisons.

click here for file

 acknowledgements
we thank the reviewers for their helpful remarks that allow to improve the initial version of this paper. the necessary computing environment has been provided by the bioinformatics resource center from biogenouest http://genouest.org. thank you to olivier sallou for making the code available on the platform within the mobyle environment and jackie bynoe for help in proofreading. this work has been supported by a grant from the french agence nationale de la recherche .
