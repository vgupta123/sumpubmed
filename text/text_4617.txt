BACKGROUND
multiple alignments of protein sequences are important in many applications, including phylogenetic tree estimation, secondary structure prediction and critical residue identification. many multiple sequence alignment  algorithms have been proposed; for a recent review, see  <cit> . two attributes of msa programs are of primary importance to the user: biological accuracy and computational complexity . complexity is of increasing relevance due to the rapid growth of sequence databases, which now contain enough representatives of larger protein families to exceed the capacity of most current programs. obtaining biologically accurate alignments is also a challenge, as the best methods sometimes fail to align readily apparent conserved motifs  <cit> . we recently introduced muscle, a new msa program that provides significant improvements in both accuracy and speed, giving only a summary of the algorithm  <cit> . here, we describe the muscle algorithm more fully and analyze its complexity. we introduce a new option designed for high-throughput applications, muscle-fast. we also describe a new method for evaluating objective functions for profile-profile alignment, the iterated step in the muscle algorithm.

current methods
while multiple alignment and phylogenetic tree reconstruction have traditionally been considered separately, the most natural formulation of the computational problem is to define a model of sequence evolution that assigns probabilities to all possible elementary sequence edits and then to seek an optimal directed graph in which edges represents edits and terminal nodes are the observed sequences. this graph makes the history explicit  and implies an alignment. no tractable method for finding an optimal graph is known for biologically realistic models, and simplification is therefore required. a common heuristic is to seek a multiple alignment that maximizes the sp score , which is np complete  <cit> . it can be achieved by dynamic programming with time and space complexity o in the sequence length l and number of sequences n  <cit> , and is practical only for very small n. stochastic methods such as gibbs sampling can be used to search for a maximum objective score  <cit> , but have not been widely adopted. a more popular strategy is the progressive method  <cit>  , which first estimates a phylogenetic tree. a profile  is then constructed for each node in the binary tree. if the node is a leaf, the profile is the corresponding sequence; otherwise its profile is produced by a pair-wise alignment of the profiles of its child nodes . current progressive algorithms are typically practical for up to a few hundred sequences on desktop computers, the best-known of which is clustalw  <cit> . a variant of the progressive approach is used by t-coffee  <cit> , which builds a library of both local and global alignments of every pair of sequences and uses a library-based score for aligning two profiles. on the balibase benchmark  <cit> , t-coffee achieves the best results reported prior to muscle, but has a high time and space complexity that limits the number of sequences it can align to typically around one hundred. in our experience, errors in progressive alignments can often be attributed to one of the following issues: sub-optimal branching order in the tree, scoring parameters that are not optimal for a particular set of sequences , and inappropriate boundary conditions . misalignments are sometimes readily apparent, motivating further processing . one approach is to use a progressive alignment as the initial state of a stochastic search for a maximum objective score . alternatively, pairs of profiles can be extracted from the progressive alignment and re-aligned, keeping the results only when an objective score is improved   <cit> .

implementation
the basic strategy used by muscle is similar to that used by prrp  <cit>  and mafft  <cit> . a progressive alignment is built, to which horizontal refinement is then applied.

algorithm overview
muscle has three stages. at the completion of each stage, a multiple alignment is available and the algorithm can be terminated.

stage 1: draft progressive
the first stage builds a progressive alignment.

similarity measure
the similarity of each pair of sequences is computed, either using k-mer counting or by constructing a global alignment of the pair and determining the fractional identity.

distance estimate
a triangular distance matrix is computed from the pair-wise similarities.

tree construction
a tree is constructed from the distance matrix using upgma or neighbor-joining, and a root is identified.

progressive alignment
a progressive alignment is built by following the branching order of the tree, yielding a multiple alignment of all input sequences at the root.

stage 2: improved progressive
the second stage attempts to improve the tree and builds a new progressive alignment according to this tree. this stage may be iterated.

similarity measure
the similarity of each pair of sequences is computed using fractional identity computed from their mutual alignment in the current multiple alignment.

tree construction
a tree is constructed by computing a kimura distance matrix and applying a clustering method to this matrix.

tree comparison
the previous and new trees are compared, identifying the set of internal nodes for which the branching order has changed. if stage  <dig> has executed more than once, and the number of changed nodes has not decreased, the process of improving the tree is considered to have converged and iteration terminates.

progressive alignment
a new progressive alignment is built. the existing alignment is retained of each subtree for which the branching order is unchanged; new alignments are created for the  set of changed nodes. when the alignment at the root is completed, the algorithm may terminate, return to step  <dig>  or go to stage  <dig> 

stage 3: refinement
the third stage performs iterative refinement using a variant of tree-dependent restricted partitioning  <cit> .

choice of bipartition
an edge is deleted from the tree, dividing the sequences into two disjoint subsets . edges are visiting in order of decreasing distance from the root.

profile extraction
the profile  of each subset is extracted from the current multiple alignment. columns containing no residues  are discarded.

re-alignment
the two profiles obtained in step  <dig>  are re-aligned to each other using profile-profile alignment.

accept/reject
the sp score of the multiple alignment implied by the new profile-profile alignment is computed. if the score increases, the new alignment is retained, otherwise it is discarded. if all edges have been visited without a change being retained, or if a user-defined maximum number of iterations has been reached, the algorithm is terminated, otherwise it returns to step  <dig> . visiting edges in order of decreasing distance from the root has the effect of first re-aligning individual sequences, then closely related groups

algorithm elements
in the following, we describe the elements of the muscle algorithm. in several cases, alternative versions of these elements were implemented in order to investigate their relative performance and to offer different trade-offs between accuracy, speed and memory use. most of these alternatives are made available to the user via command-line options. four benchmark datasets have been used to evaluate options and parameters in muscle: balibase  <cit> , sabmark  <cit> , smart  <cit>  and our own benchmark, prefab  <cit> .

objective score
in its refinement stage, muscle seeks to maximize an objective score, i.e. a function that maps a multiple sequence alignment to a real number which is designed to give larger values to better alignments. muscle uses the sum-of-pairs  score, defined to be the sum over pairs of sequences of their alignment scores. the alignment score of a pair of sequences is computed as the sum of substitution matrix scores for each aligned pair of residues, plus gap penalties. gaps require special consideration . we use the term indel for the symbol that indicates a gap in a column , reserving the term gap for a maximal contiguous series of indels. the gap penalty contribution to sp for a pair of sequences is computed by discarding all columns in which both sequences have an indel, then applying an affine penalty g + λe for each remaining gap where g is the per-gap penalty, λ is the gap length , and e is the gap-length penalty .

progressive alignment
progressive alignment requires a rooted binary tree in which each sequence is assigned to a leaf. the tree is created by clustering a triangular matrix containing a distance measure for each pair of sequences. the branching order of the tree is followed in postfix order . at each internal node, profile-profile alignment is used to align the existing alignments of the two child subtrees, and the new alignment is assigned to that node. a multiple alignment of all input sequences is produced at the root node .

similarity measures
we use the term similarity for a measure on a pair of sequences that indicates their degree of evolutionary divergence . muscle uses two types of similarity measure: the fractional identity d computed from a global alignment of the two sequences, and measures obtained by k-mer counting. a k-mer is a contiguous subsequence of length k, also known as a word or k-tuple. related sequences tend to have more k-mers in common than expected by chance, provided that k is not too large and the divergence is not too great. many sequence comparison methods based on k-mer counting have been proposed in the literature; for a review, see  <cit> . the primary motivation for these measures is improved speed as no alignment is required. mafft uses k-mer counting in a compressed alphabet  to compute its initial distance measure. the alphabet used in mafft is taken from  <cit> , and is one of the options implemented in muscle. trivially, identity is higher or equal in a compressed alphabet; it cannot be reduced. if the alphabet is chosen such that there are high probabilities of intra-class substitution and low probabilities of inter-class substitution, then we might expect that detectable identity  could be usefully extended to greater evolutionary distances while limiting the increase in matches due to chance. we have previously shown  <cit>  that k-mer similarities correlate well with fractional identity, although we failed to find evidence that compressed alphabets have superior performance to the standard alphabet at lower identities. we define the following similarity measure between sequences x and y:

f = Στ min  / .     

here τ is a k-mer, lx, ly are the sequence lengths, and nx and ny are the number of times τ occurs in x and y respectively. this definition can be motivated by considering an alignment of x to y and defining the similarity to be the fraction of k-mers that are conserved between the two sequences. the denominator of f is the maximum number of k-mers that could be aligned. note that if a given k-mer occurs more often in one sequence than the other, the excess cannot be conserved, hence the minimum in the numerator. the definition of f is an approximation in which it is assumed that  common k-mers are always alignable to each other. muscle also implements a binary approximation fbinary, so-called because it reduces the k-mer count to a present / absent bit:

fbinary = Στ δxy / .     

here, δxy is  <dig> if τ is present in both sequences,  <dig> otherwise. as multiple instances of a given k-mer in one sequence are relatively rare, this is often a good approximation to f. the binary approximation enables a significant speed improvement as the size of the count vector for a given sequence can be reduced by an order of magnitude. this allows the count vector for every sequence to be retained in memory, and pairs of vectors to be compared efficiently using bit-wise instructions. when using an integer count, there may be insufficient memory to store all count vectors, making it necessary to re-compute counts several times for a given sequence.

distance measures
given a similarity value, we wish to estimate an additive distance measure. an additive measure distance measure d between two sequences a and b satisfies d = d + d for any third sequence c, assuming that a, b and c are all related. ideal but generally unknowable is the mutation distance, i.e. the number of mutations that occurred on the historical path between the sequences. the historical path through the phylogenetic tree extends from one sequence to the other via their most recent common ancestor. the mutation distance is trivially additive. the fractional identity d is often used as a similarity measure; for closely related sequences  <dig> - d is a good approximation to a mutation distance . as sequences diverge, there is an increasing probability of multiple mutations at a single site. to correct for this, we use the following distance estimate  <cit> :

dkimura = -loge      

for d ≤  <dig>  we use a lookup table taken from the clustalw source code. for k-mer measures, we use:

dkmer =  <dig> - f.     

tree construction
given a distance matrix, a binary tree is constructed by clustering. two methods are implemented: neighbor-joining  <cit> , and upgma  <cit> . muscle implements three variants of upgma that differ in their assignment of distances to a new cluster. consider two clusters  l and r to be merged into a new cluster p, which becomes the parent of l and r in the binary tree. average linkage assigns this distance to a third cluster c:

davgpc = / <dig>      

we can take the minimum rather than the average:

dminpc = min .     

following mafft, we also implemented a weighted mixture of minimum and average linkage:

dmixpc =  dminpc + s davgpc,     

where s is a parameter set to  <dig>  by default. clustering produces a pseudo-root . we implemented two other methods for determining a root: minimizing the average branch weight  <cit> , as used by clustalw, and locating the root at the center of the longest span.

sequence weighting
conventional wisdom holds that sequences should be weighted to correct for the effects of biased sampling from a family of related proteins; however, there is no consensus on how such weights should be computed. muscle implements the following sequence weighting schemes: none , henikoff  <cit> , psi-blast  <cit>  , clustalw's, gsc  <cit> , and the three-way method  <cit> . we found the use of weighting to give a small improvement in benchmark accuracy results, e.g. approximately 1% on balibase, but saw little difference between the alternative schemes. the clustalw method enables a significant reduction in complexity , and is therefore the default choice.

profile functions
in order to apply pair-wise alignment methods to profiles, a scoring function must be defined for a pair of profile positions, i.e. a pair of multiple alignment columns. this function is the profile analog of a substitution matrix; see for example  <cit> . we use the following notation. let i and j be amino acid types, pi the background probability of i, pij the joint probability of i and j being aligned to each other, sij the substitution matrix score, f xi the observed frequency of i in column x of the first profile, f xg the observed frequency of gaps in that column, and αxi the estimated probability of observing i in position x in the family. . estimated probabilities α are derived from the observed frequencies f, typically by adding heuristic pseudo-counts or by using bayesian methods such as dirichlet mixture priors  <cit> . a commonly used profile function is the sequence-weighted sum of substitution matrix scores for each pair of letters, selecting one from each column :

pspxy = Σi Σj f xi f yj sij.     

note that sij = log   <cit> , so

pspxy = Σi Σj f xi f yj log .     

psp is the function used by clustalw and mafft. it is a natural choice when attempting to maximize the sp objective score: if gap penalties are neglected, maximizing psp maximizes sp under the constraint that columns in each profile are preserved. . muscle implements psp functions based on the  <dig> pam matrix of  <cit>  and the  <dig> pam vtml matrix  <cit> . in addition to psp, muscle implements a function we call the log-expectation  score. le is a modified version of the log-average  profile function that was proposed on theoretical grounds  <cit> :

laxy = log Σi Σj αxi αyj pij / pi pj.     

le is defined as follows:

lexy =   log Σi Σ j f xi f yj pij / pipj.     

the muscle le function uses probabilities computed from vtml  <dig>  note that estimated probabilities α in la are replaced by observed frequencies f in le. the factor  is the occupancy of a column. frequencies fi must be normalized to sum to one if indels are present . the occupancy factors are introduced to encourage more highly occupied columns  to align, and are found to significantly improve accuracy. we avoid these complications in the psp score by computing frequencies in a 21-letter alphabet , and by defining the substitution score of an amino acid to an indel to be zero. this has the desired effect of down-weighting column pairs with low occupancies, and can also be motivated by consideration of the sp function. if gap penalties are ignored, then this definition of psp preserves the optimization of sp under the fixed-column constraint by correctly accounting for the reduced number of residue pairs in columns containing gaps.

gap penalties
we call the first indel in a gap its gap-open; the last its gap-close. consider an alignment of two profiles x and y, and a gap of length λ in x in which the gap-open is aligned to position yo in y and the gap-close to yc. the penalty for this gap is b + t + λe, where b and t are costs for opening and closing a gap that vary according to the position in y, and e is a length cost  that does not vary by position. a fixed length cost allows a minor optimization of the scoring scheme  <cit> . consider a global alignment of sequences x and y having lengths lx and ly. if a constant δ  is added to each substitution matrix score and δ/ <dig> is added for each gapped position, this adds the constant value δ/ <dig> to the score of any possible alignment, and the set of optimal alignments is therefore unchanged. given a scoring scheme with substitution matrix sij and extension penalty e, we can thus choose δ/ <dig> = e and instead use s'ij = sij + 2e and e' =  <dig> to obtain the same alignment. the constant 2e can be added to the substitution matrix at compile time, and no explicit extension penalty is then needed in the recursion relations. muscle uses this optimization for the psp function, but not for le . let f yo be the number of gap-opens in column y in y and f yc be the number of gap-closes in column y. muscle computes b and t as follows :

b = g/ <dig>  h),     

t = g/ <dig>  h).     

here, g is a parameter that can be considered a default per-gap penalty, hw is  <dig> if y falls within a window of w consecutive hydrophobic residues or zero otherwise, and h is a tunable parameter. by default, w =  <dig>  h =  <dig> . the factor g/ <dig>  is motivated by considering the sp score of the alignment. the gap penalty contribution to sp for a pair of sequences  is computed by discarding all columns in which both sequences have an indel, then applying an affine penalty g + λe for each remaining gap. it is convenient here to consider that half of the per-gap penalty g is applied to the open position and half to the close position. suppose a gap g is inserted into x such that the gap-open is aligned to position y in y. if a sequence s ∈ y has a gap-open at y, then the sp score includes no open penalty for g induced by any pair  : t ∈ x. the multiplier  therefore corrects the gap-open contribution to the sp score due to pre-existing gaps in y. . the increased penalty in hydrophobic windows is designed to discourage gaps in buried core regions where insertions and deletions are less frequent. note that muscle treats open and close positions symmetrically, in contrast to clustalw, which treats the open position specially and may therefore tend to produce, in word processing terms, left-aligned gaps with a ragged right margin.

terminal gaps
a terminal gap is one that opens at the n-terminal position of the sequence to which it is aligned or closes at the c-terminal; as opposed to an internal gap. it has been suggested  <cit>  that global methods have intrinsic difficulties with long deletions or insertions. we believe that these difficulties are often due to the choice of penalties for terminal gaps. clustalw, which charges no penalty for terminal gaps, tends to fail to open a needed internal gap and thus fail to align terminal motifs; mafft, which charges the same penalty for terminal and internal gaps, sometimes aligns small numbers of residues to a terminal by inserting an unnatural internal gap. by default, muscle penalizes terminal gaps with half the penalty of an internal gap. this is done by setting b, the open penalty at the c-terminal, and t, the close penalty at the n-terminal, to zero . the option of always applying full penalties, as in mafft, is also provided. we found that the compromise of a half penalty for terminal gaps gave good results for a wide range of input data, but that further improvements could sometimes by achieved by the following technique. if the length ratio of the two profiles to be aligned exceeds a threshold , then muscle constructs four different alignments in which gaps at both, one or neither terminals are fully penalized. a conservation score is defined by subtracting all gap penalties  from the alignment score, leaving a sum over profile functions only. the alignment with the highest conservation score is used.

tree comparison
in progressive alignment, two subtrees will produce identical alignments if they have the same set of sequences at their leaves and the same branching orders . we exploit this observation to optimize the progressive alignment in stage  <dig> of muscle, which begins by constructing a new tree. unchanged subtrees are identified, and their alignments are retained . a progressive alignment of the changed subtrees is constructed, producing the same alignment at the root that would be obtained starting from the leaves. tree comparison is performed by the following algorithm. consider two trees a and b with identical sets of n leaves. leaves are identified by consecutive integers   <dig> through n. call a pair of nodes, one from each tree, equivalent if they are the same leaf or they are internal nodes and their children are equivalent. the left/right position of a child is not considered; in other words, subtree rotations are allowed . traverse a in prefix order , assigning internal nodes ids n +  <dig> through 2n in the order visited. when visiting an internal node pa, take the ids of its two child nodes la and ra and use them as indexes into a lookup table pointing to nodes in b. if  la is equivalent to a node lb in b and ra is equivalent to a node rb, and  lb and rb have the same parent pb, then assign pb the same id as pa, to which it is equivalent. when the traversal is complete, a node b in b is equivalent to some node in a if and only if b has an id. this procedure is o time and space.

defaults, optimizations and complexity analysis
we now discuss the default choices of algorithm elements in the muscle program and analyze their complexity.

complexity of clustalw
it is instructive to consider the complexity of clustalw. this is of intrinsic interest as clustalw is currently the most widely used msa program and, to the best of our knowledge, its complexity has not previously been stated correctly in the literature. it is also useful as a baseline for motivating some of the optimizations used in muscle. the clustalw algorithm can be described by the same steps as stage  <dig> above. the similarity measure is the fractional identity computed from a global alignment, clustering is done by neighbor-joining. global alignment of a pair of sequences or profiles is computed using the myers-miller linear space algorithm  <cit>  which is o space and o time in the typical sequence length l. given n sequences and thus n/ <dig> = o pairs, it is therefore o time and o space to construct the distance matrix. the neighbor-joining implementation is o space and o time, at least up to clustalw  <dig> , although o time is possible; see e.g.  <cit> . a single iteration of progressive alignment computes a profile of each subtree from its multiple alignment, which is o time and space in the number of sequences in the profile np and the profile length lp, then uses myers-miller to align the profiles in o space and o time. there are n -  <dig> internal nodes in a rooted binary tree and hence o iterations. it is often assumed that lp is o, i.e. that o gaps are introduced in each iteration. however, we often observe the alignment length to grow approximately linearly, i.e. that o gaps are added per iteration. for example, taking the average over all iterations in all alignments in version  <dig> of the prefab benchmark, stage  <dig> of muscle adds  <dig>  gaps per iteration to the longer profile. it is therefore more realistic to assume that lp is o, making one iteration of progressive alignment o in both space and time. this analysis is summarized in table  <dig> 

initial distance measure
one might expect  that a more accurate distance measure would lead to a more accurate final alignment due to an improved tree, and  that errors due to a less accurate distance measure might be eliminated by allowing stage  <dig> to iterate more times. neither of these expectations is supported by our test results . allowing stage  <dig> to iterate more than once with the goal of further improving the tree gave no significant improvement with any distance measure. possibly, the tree is biased towards the msa that was used to estimate it, and the msa is biased by the tree used to create it, making it hard to achieve improvements. the most accurate measure on a pair of sequences is presumably the fractional identity d computed from a global alignment, but use of d in step  <dig>  does not improve average accuracy on benchmark tests. the 6-class dayhoff alphabet used by mafft proved to give slightly higher benchmark accuracy scores, despite the fact that other alphabets were found to correlate better with d  <cit> . we also found that the use of the binary approximation fbinary gave slightly reduced accuracy scores even when stage  <dig> was allowed to iterate. the default choice in muscle is therefore to use the dayhoff alphabet in step  <dig>  and to execute stage  <dig> once only. while the impact on the average accuracy of the final alignment due to the different options is not understood, we observe that a better alignment of a pair of sequences is often obtained from a multiple alignment than from a pair-wise alignment, due to the presence of intermediate sequences having higher identities. it is therefore plausible that d obtained from the multiple alignment in step  <dig>  may be more accurate than d obtained from a pair-wise alignment in step  <dig> , and this may be relatively insensitive to the method used to create the tree for stage  <dig>  but this leaves unexplained why k-mer counting appears to be as good as or better than d in stage  <dig>  computing f from a pair of sequences is o time and o space, so for all pairs the similarity calculation is o, compared with o in clustalw. for a typical l around  <dig>  combined with an order of magnitude improvement due to the simplicity of k-mer counting compared with dynamic programming, this typically gives a three orders of magnitude speed improvement for computing the distance matrix in muscle compared with clustalw. the default strategy is therefore well justified as a speed optimization, and has the added bonus of providing a small improvement in accuracy.

clustering
muscle implements both upgma and neighbor-joining. we found upgma to give slightly better benchmark scores than neighbor-joining; upgma is therefore the default option. we expect neighbor-joining to give a better estimate of the correct evolutionary tree . however, it is well-known that alignment accuracy decreases with lower sequence identity . it follows that given a set of profiles, the two that can be aligned most accurately will tend to be the pair with the highest identity, i.e. at the shortest evolutionary distance. this is exactly the pair selected by the nearest-neighbor criterion in upgma. by contrast, neighbor-joining selects a pair of evolutionary neighbors, i.e. a pair having a common ancestor. when mutation rates are variable, the evolutionary neighbor may not be the nearest neighbor . this explains why a nearest-neighbor tree may be superior to the true evolutionary tree for guiding a progressive alignment. neighbor-joining is naively o time, although this can be reduced to o. upgma is naively o time as the minimum of an n <dig> matrix must be found in each of n -  <dig> iterations. however, this can be reduced to o time by maintaining a vector of pointers to the minimum value in each row of the matrix. we are again fortunate to find that the most accurate method is also the fastest.

dynamic programming
the textbook algorithm for pair-wise alignment with affine penalties employs three dynamic programming matrices; see e.g.  <cit> . a more time-and space-efficient implementation can be achieved using linear space for the recursion relations and a single matrix for trace-back . consider sequences x and y length lx, ly. we use the following notation: xx is the xth letter in x, xx the first x letters in x, sxy the substitution score  for aligning xx to yy, bxx the score for a gap-open in y that is aligned to xx, txx the score for a gap-close aligned to xx, uxy the set of all alignments of xx to yy, mxy the score of the best alignment in uxy ending in a match , dxy the score of the best alignment ending in a delete relative to x  and ixy the score of the best alignment ending in an insert . a match is preceded by either a match, delete or insert, so:

mxy = sxy + max { mx-1y- <dig>  dx-1y- <dig> + txx- <dig>  ix-1y- <dig> + tyy-1}     

we assume that a center parameter has been added to sxy such that the gap extension penalty is zero. by considering all possible lengths for the final gap,

dxy = max .     

here, k is the last position in x that is aligned to a letter in y. extract the special case of a gap of length 1:

dxy = max { max , mx-1y + bxx}.     

hence,

dxy = max { dx-1y, mx-1y + bxx }.     

similarly,

ixy = max { ixy- <dig>  mxy- <dig> + byy }.     

let the outer loop iterate over increasing x and the inner loop over increasing y. for fixed x, define vectors mcurry = mxy, mprevy = mx-1y, dcurrx = dxy, dprevx = dx-1y; for fixed x, y define scalars icurr = ixy, iprev = ixy- <dig>  now we can re-write ,  and  to obtain the following recursion relations:

mcurry = sxy + max { mprevy- <dig>  dprev y- <dig> + txx- <dig>  iprevy- <dig> + tyy- <dig> }     

dcurry = max { dprevy, mprevy + bxx }     

icurr = max { iprev, mprevy + byy }.     

an lx × ly matrix is needed for the trace-back that produces the final alignment.

inner loop
the inner-most dynamic programming loop, which computes the profile function, deserves careful optimization. we will consider the case of psp; similar optimizations are possible for le. psp = Σi Σj f xi f yj sij = Σi f xi wyi, where wyi = Σj f yj sij. the vector wyi is used lx times, and it therefore pays to compute it once and cache it. observe that a typical profile column contains <<  <dig> different amino acids. we sort the frequencies in decreasing order; the summation Σi f xi wyi is terminated if a frequency f xi =  <dig> is encountered. this typically reduces the time spent in the summation, especially when sequences are closely related. as with wyi, the sort order is computed once and cached. observe that the roles of the two profiles are not symmetrical. it is most efficient to choose x, for which frequency sort orders are computed, to be the profile with the lowest amino acid diversity when averaged over columns. with this choice, the summation terminates earlier on average then if the other profile is identified as x. note that out of n -  <dig> iterations of progressive alignment, a minimum of  and maximum of n -  <dig> profile-profile alignments will include at least one profile containing one sequence only, and in the refinement phase exactly n of the 2n -  <dig> edges in the tree terminate on a leaf. at least half of all profile-profile alignments created in the muscle algorithm therefore include a profile of one sequence only. special cases where one or both profiles is a single sequence can be handled in separate subroutines, saving overhead due to unneeded loops that are guaranteed to execute once only. this optimization is especially useful for the le function as it enables the logarithm to be incorporated into the w vector.

diagonal finding
many alignment algorithms are optimized for speed, typically at some expense in average accuracy, by using fast methods to identify regions of high similarity between two sequences, which appear as diagonals in the similarity matrix. the alignment path is then constrained to include these diagonals, reducing the area of the dynamic programming matrix that must be computed. mafft uses the fast fourier transform to find diagonals. muscle uses a different technique which we have previously shown  <cit>  have comparable sensitivity and to be significantly faster. we use a compressed alphabet to find k-mers in common between two sequences, then attempt to extend the match. in the case of diagonal identification we found compressed alphabets to significantly out-perform the standard amino acid alphabet  <cit> . currently, muscle uses 6-mers in the dayhoff alphabet for diagonal finding, as for the initial distance measure, though other alphabets are known to give slightly better performance  <cit> . a candidate diagonal is rejected if there is any overlap  or if it is less than a minimum length . the ends of the diagonal are deleted  as they are less reliable. despite these heuristics, we find the use of diagonal-finding to reduce average accuracy and to give only modest improvements in speed for typical input data; this option is therefore disabled by default. similar results are seen in mafft; the most accurate mafft script is nwnsi  <cit> , in which diagonal-finding is also disabled.

additive profiles
both the psp and le profile functions are defined in terms of amino acid frequencies and position-specific gap penalties. the data structure representing a profile is a vector of length lp in which each element contains frequencies for each amino acid type and a few additional values related to gaps. we call this data structure a profile vector, as distinct from a profile matrix, an explicit n × lp multiple alignment containing letters and indels. for n >  <dig>  using profile vectors reduces the cost of computing the profile function compared with profile matrices, and is therefore preferred for use in dynamic programming. in clustalw and mafft, the implementation of progressive alignment builds a profile matrix at each internal node of the tree, which is used to compute a profile vector. this procedure is o = o in time and space, becoming expensive for large n. observe that the count of a given amino acid in a column in the parent matrix is the sum of the counts in the two child columns that are aligned at that position . with a suitable sequence weighting scheme, it is therefore possible to compute the amino acid frequencies of the parent profile vector from the frequencies in the two child profile vectors and the alignment path. this is an o procedure in both time and space, giving a significant advantage for n >>  <dig>  three issues must be addressed to fully implement this idea: the sequence weighting scheme, inclusion of occupancy factors and position-specific gap penalties, and construction of a profile matrix  at the root node.

sequence weighting
for the frequencies in the parent profile vector to be a linear combination of the child frequencies, the weight assigned to a sequence must be the same in the child and parent profiles. this requirement is not satisfied, for example, by the henikoff or psi-blast schemes, which compute weights based on a multiple alignment. we therefore choose the clustalw scheme, which computes a fixed weight for each sequence from edge lengths in the tree.

gap representation
to compute gap penalties, we need the frequencies fo of gap opens and fc of gap closes in each position. in the case of the le profile function, we additionally require the gap frequency fg. these can be accommodated by storing fo, fc and fe in the profile vector, where fe is the frequency of gap-extensions in the column . these three occupancy frequencies are sufficient for computing the profile function and the position-specific gap penalties b and t. note that we can compute the frequency fg of indels, as needed for the occupancy factor in the profile function, as follows:

fg = fo + fc + fe.     

now consider the problem of computing the occupancy frequencies in the parent profile vector, given only the child occupancy frequencies and the trace-back path for the alignment. consider first a diagonal edge in the path, i.e. an edge that does not open or extend a gap, following another diagonal edge. in this case, the occupancy frequencies are computed similarly to amino acid frequencies . for horizontal or vertical edges, i.e. edges that open or extend gaps, the parent occupancy frequencies can be computed by considering the effect of the new column of indels . it is straightforward to work through all cases and show that the three frequencies fo, fc and fe are sufficient for their values in the parent profile vector to be computed in o time from the child profile vectors and alignment path.

construction of the root alignment
by avoiding the use of profile matrices, the complexity of a single progressive alignment iteration is reduced from o space and o time to o = o space and time. the nl term in the time complexity is now due only to the increase in profile length, and is therefore typically much smaller than before. the root alignment is constructed by storing the alignment path produced at each internal node. for each input sequence, the path to the root is followed, inserting the gaps induced by each alignment path at each internal node. this procedure is o = o time, and requires o = o space for storage of the paths. this is expensive for large n, and we therefore optimize this step by using a device we call an e-string, a type of edit string.

e-strings
an alignment path can be considered as an operator on a pair of sequences that inserts indels into those sequences such that their lengths become equal. conventionally, an alignment path is represented as a vector of three symbols representing edges in the graph, say m, d and i . note that indels in one sequence are inserted only by ds, indels in the other are inserted only by is. define an e-string e to be a vector of |e| integers interpreted as an operator that inserts indels into a string by scanning it from left to right . a positive integer n means skip n letters of the string; a negative integer -n means insert n indels at the current position. we require the vector to be in its shortest form, so signs always alternate. we represent an alignment path as a pair of e-strings, one for each sequence, assigned to the appropriate edges in the tree. we will typically find that |e|, the length of the e-string, is much less than lp, the length of the alignment path. now consider the effect of applying two consecutive e-strings . this can be expressed as a third e-string, which can be efficiently computed in o time from the multiplicands. for each leaf , the product is computed of e-strings on the path to the root . the final e-string obtained at the root is then applied to the sequence. this method does not reduce the big-o time or space complexity, but is much faster than a naive implementation.

brenner's method
steven brenner  observed that a multiple alignment can be alternatively be obtained by aligning each sequence to the root profile. this requires o time, giving a lower asymptotic complexity in n at the expense of an additional factor of lp. this method gives opportunities for errors relative to the "exact" e-string solution , but can also lead to improvements by allowing the sequence to correctly align to conserved motifs that were not apparent when the sequence was added. . the chances for error are reduced by constraining the alignment to forbid gaps in the root profile. our tests show that this method gives comparable average accuracy to the e-string solution but to be slower for up to at least a few thousand sequences, and e-strings are therefore used by default.

refinement complexity
in the following, we assume that an explicit multiple alignment  of all sequences is maintained, and determine the complexity of each step in stage  <dig>  step  <dig>  determines the bipartition induced by deleting an edge from the tree. this is o time, and sufficiently fast that there is little motivation for further optimization. step  <dig>  extracts profiles for the two partitions from the current multiple alignment and computes their profile vectors, which is o time and space. step  <dig>  performs profile-profile alignment, which is o time and space. step  <dig>  computes the sp score, which is o time and o space . a single iteration of stage  <dig> is thus o time and o space. there are o edges in the tree, so executing this process for all edges is o time and o space, which is o time and o space. assuming that a fixed maximum number of iterations of stage  <dig> is imposed, this is also the total complexity of refinement. we now consider optimizations of the refinement stage.

anchor columns
a multiple alignment can be divided vertically at high-confidence  columns. each vertical block is then refined separately, improving speed and reducing space due to the o factor in dynamic programming. this strategy has been used by several previous algorithms, including prrp  <cit> , rascal  <cit>  and mafft. in muscle, the following criteria are used to identify anchor columns. the profile function  must exceed a threshold, the averaged profile function over a window around the position must exceed a  threshold, and the column may not contain a gap. in addition, the contribution to the averaged score from a single column has a ceiling, reducing skew in the averaged score due to exceptionally high-scoring columns. these heuristics are designed to avoid anchor columns that have high scores but are either artifacts  or are too close to variable regions. when performing a profile-profile alignment, each anchor column and its two immediate neighbors  are required to remain aligned; i.e., terminal gaps are forbidden except at the true terminals. introducing this constraint overcomes a small degradation in average alignment quality that is otherwise observed. this implies that the degradation is sometimes due to cases where a well-conserved region is divided into two parts by an anchor column, one of which becomes short enough that it misaligns to a similar short motif elsewhere.

sp score
notice that computation of the sp score dominates the time complexity of refinement and of muscle overall, introducing o and o terms. we are therefore motivated to consider optimizations of this step. we first consider the contribution spa to the sp score from amino acids; gap penalties require special treatment. let s and t be sequences, x be a column, s  be the amino acid of sequence s in column x, and s be the substitution score of amino acids i and j. it is convenient to impose an  ordering on the sequences and amino acid types. then,

spa = Σx Σs Σt >s s.     

define δ =  <dig> if s  = i,  <dig> otherwise, and ni  = Σs δ. we say ni  is the count of amino acid type i in column x. we can now transform the sum over pairs of sequences into a sum over pairs of amino acid types:

spa = Σx Σi ni Σj nj>i s + 1/ <dig> Σx Σi  s.     

frequencies are computed as:

f xi = ni / n.     

using frequencies,



for simplicity, we have neglected sequence weighting; it is straightforward to show that  applies unchanged if weighting is used. note that  is o but  and  are o. for n >>  <dig>  this is a substantial improvement. let spg be the contribution of gap penalties to sp, so sp = spa + spg. it is natural to seek an o expression for spg analogous to , but to the best of our knowledge no solution is known. note that in muscle refinement, the absolute value of the sp score is not needed; rather, it suffices to determine the difference in the sp scores before and after re-aligning a pair of profiles. let sp be the contribution to the sp score from a pair of sequences s and t, so sp = Σs Σt>s sp, and denote the two profiles by x and y. then we can decompose sp into intra-and inter-profile terms as follows:

sp = Σs∈x Σt∈x:t>s sp + Σs∈y Σt∈y:t>s sp + Σs∈x Σt∈y sp     

note that the intra-profile terms are unchanged in any alignment that preserves the columns of the profile intact, which is true by definition in profile-profile alignment. this follows by noting that any indels added to align the profiles are guaranteed to be external gaps with respect to any pair of sequences in the same profile. it therefore suffices to compute the change in the inter-profile term:

spxy = Σs∈x Σt∈y sp.     

this reduces the average time by a factor of about two. we can further improve on this by noting that in the typical case, there are few or no changes to the alignment. this suggests computing the change in sp score by looking only at differences between the two alignments. let π- be the alignment path before re-alignment and π+ the path after re-alignment. the change in alignment can be specified as the set of edges in π- or π+, but not both; i.e., by considering a path to be a set of edges and taking the set symmetric difference Δπ =  - . the path π+ after re-alignment is available from the dynamic programming traceback. the path π- before re-alignment can be efficiently computed in o time. note that in order to construct the profile of a subset of sequences extracted from a multiple alignment, those columns that contain only indels in that subset must be deleted. the set of such columns in both profiles is therefore available as a side effect of profile construction, and this set immediately implies π-. it is a simple o procedure to compute Δπ from π- and π+. note that spa is a sum over columns, and there is a one-to-one correspondence between columns and edges in π. the change in spa can therefore be computed as a sum over columns in Δπ, with a negative sign for edges from π-, reducing the time complexity from o to o. we now turn our attention to spg. we say that a gap g intersects Δπ if and only if any indel in g is in a column in Δπ, and denote by Γ the set of gaps that intersect Δπ. if a gap does not intersect Δπ, i.e. does not have an indel in a changed column, its contribution to spg is unchanged. it therefore suffices to consider penalties for gaps in Γ, again with negative signs for edges from π-. the construction of Γ is straightforward in o time. finally, a sum over pairs in Γ is needed, reducing the o component to the smallest possible set of terms.

dimer approximation
we next describe an approximation to sp that can be computed in o time. define a two-symbol alphabet {x, -} in which x represents any amino acid and - is the indel symbol. there are four dimers in this alphabet: xx, x-, -x and --, which denote by no-gap, gap-open, gap-close and gap-extend respectively. re-write a multiple alignment in terms of these dimers, adopting the convention that dimer ab composed of symbol a in column x- <dig> and symbol b in column x is written in column x. now consider the contribution to spg of an aligned pair of dimers, written as ab↔cd. clearly xx↔x- adds a gap-open penalty; xx↔-x adds a gap-close . to avoid double-counting, we will include only the penalty contribution of indels in the second column. then xx↔x- adds a per-gap penalty, but xx↔-x adds zero because the second column does not contain a gap. external indels must be discarded; so, for example, --↔-- adds zero. in fact, aligning two identical dimers always contributes zero because any indel in the second column is found in both sequences and is therefore external. the contribution of all possible pairs of dimers is unambiguous, with the exception of -x↔--, which can add a per-gap or extend penalty . we approximate this case by assigning it a penalty of tg, where g is the default per-gap penalty and t is a tunable parameter, set to  <dig>  by default. with this approximation, dimers can be treated like amino acids: the scores for each aligned pair of dimers forms a substitution matrix , and spg can be computed by summing substitution scores over all pairs of sequences. we can now apply equation  <dig>  re-interpreting the frequency vectors f as having  <dig> components , and compute the change in sp by considering only those columns in Δπ. we find use of the dimer approximation to marginally reduce benchmark scores. by default, muscle therefore uses the exact sp score for n ≤  <dig> and the dimer approximation for n >  <dig>  where the higher time complexity of the exact score becomes more noticeable.

evaluation of profile functions
we have previously attempted a systematic comparison of profile functions  <cit> . the methodology used in that work demanded careful optimization of affine gap parameters for each function. this proved to be time-consuming and tedious, and we therefore tried the following alternative approach, inspired by the notion that a good profile function should be good at discriminating correctly aligned pairs of profile positions from incorrectly aligned pairs. the protocol begins with a set of pair-wise structural alignments. with the sequence of each structure as a query, we used psi-blast to search the ncbi non-redundant protein sequence database  <cit> , giving a multiple sequence alignment  for each structure. note that we use the term profile in this context to mean the sequence alignment produced by psi-blast, not the scoring matrix. using the structural alignments as a guide, we then created a database in which columns from the psi-blast profiles were aligned to each other, giving a large set of pairs of alignment columns that we consider to be correctly aligned . by selecting the same number of pairs of columns at random from structures in different fssp families, we created a similar  database of unrelated pairs. a profile function was evaluated by computing the score of each pair of columns in both the true and false databases, and then sorting the results in order of increasing score. the results can be displayed by reviewing the sorted list and, for each score s in the list, plotting the number of true pairs with score ≤ s  against the number of false pairs with score ≤ s ; we call the resulting graph a discrimination plot. ideally, all true pairs would score higher than all false pairs, in which case the profile function would be a perfect discriminator and would always produce perfect alignments. a function that perfectly discriminates will appear as a Γ-shaped plot; a function that has no ability to discriminate will appear as a diagonal plot along the line x = y. if a function f has a discrimination plot that is always above another function g  > dg ∀ x, where df is the discriminator plot for f as a function of x), then f has a superior ability to discriminate true from false pairs compared with g. if the plots intersect, the situation is ambiguous and neither function is clearly superior. we used sets of structural alignments from  <cit>   and  <cit>  . pp contains  <dig> structure pairs with sequence identity ≤ 30%, z-score ≥  <dig>  rmsd ≤  <dig> Å and an alignment length of ≥  <dig> positions. these criteria were designed to select pairs of structures with low sequence identity and high structural similarity. pp <dig> contains  <dig> pairs selected from the fssp database  <cit>  with ≤ 30% sequence identity, z-score ≥  <dig> and ≤  <dig>  rmsd ≤  <dig> Å and alignment length ≥  <dig>  the criteria for pp <dig> were designed to select challenging alignments with low sequence identity and relatively high structural divergence, leading to a high frequency of gaps and therefore, presumably, a stronger dependence on accurate identification of sequence similarity. results on pp <dig> show the le function to have higher discrimination than all other tested functions . this is illustrated in figure  <dig>  in which the discrimination plot for le on pp <dig> is compared with several other functions: psp, la, yona and levitt's  <cit> , lama  <cit> . using pp, we again find that le is superior to la , but the comparison with psp is ambiguous as the discrimination plots intersect . a major advantage of this approach is that no gap penalties are required, with the result that once the databases have been constructed, a new function can be tested in seconds rather than the days or weeks that were needed with the earlier methodology. however, some caveats are in order. we are using psi-blast as a gold standard for creating profiles, but psi-blast may introduce biases both due to its selection of sequences for inclusion in the profile and due to errors in alignments of those sequences to the query. if the profile function will be used to align psi-blast profiles, then this is an appropriate experimental design. but in the case of multiple sequence alignment, where profiles are produced iteratively by the profile function itself, the results may not be directly applicable. we also note that any monotonic transformation of the profile function leaves the discriminator plot unchanged as it does not change the sort order of the scores.  where m is a monotonically increasing function). however, a monotonic transformation may change the alignments produced by a profile function, so we can regard high discrimination as a necessary but not sufficient condition for a good profile function. one can turn this into a virtue by noting that the discrimination plot allows the relative probability of true versus false to be determined from a score. it is therefore possible to numerically determine a log-odds function from the discrimination plot, which can be evaluated by table look-up. using discrimination plots for pp <dig>  we found the optimal transformation for le to be close to linear, in contrast to other functions we tried, including psp . this observation further encouraged us to explore the performance of le in an msa algorithm. testing on multiple alignment benchmarks we find le to give superior results on balibase, but statistically indistinguishable results on other databases . muscle therefore uses le as the default choice as it sometimes gives better results but has not been observed to give lower average accuracy on any of our tests. it is also useful to introduce a method with a distinctively different scoring scheme as an alternative that may give better results on some input data and may provide unique features for incorporation into jury or consensus systems. one drawback of le is its relatively slow performance due to the need to compute a logarithm for each cell of the dynamic programming matrix.

complexity of muscle
the complexity of muscle is summarized in table  <dig>  we assume lp = o, the e-string construction for the root alignment, and a fixed number of refinement iterations.

RESULTS
muscle offers a variety of options that offer different trade-offs between speed and accuracy. in the following, we report speed and accuracy results for three sets of options:  the full muscle algorithm including stages  <dig>   <dig> and  <dig> with default options;  stages  <dig> and  <dig> only, using default options ; and  stage  <dig> only using the fastest possible options , which are as follows: fbinary is used as a distance measure , the psp profile function is used, and diagonal finding is enabled.

alignment accuracy
in tables  <dig> and  <dig> we report the speed and accuracy of muscle v <dig> , clustalw v <dig> , progressive poa, a recently published method that is claimed to be  <dig> to  <dig> times faster than clustalw for large alignments  <cit> , and the mafft script fftns <dig> v <dig> , the fastest previously published method known to us. on the advice of one of the authors of progressive poa, we used command-line options selecting global alignment with truncated gap scoring . we report results both using distance matrices computed by blast  and using the distance method built into the program . we use four sets of reference alignments: balibase v <dig>  prefab v <dig>  sabmark v <dig> , and a version of smart from july  <dig>  the accuracy score is q, the number of residue pairs correctly aligned divided by the length of the reference alignment. for more discussion of the reference data, assessment methodology and a comparison of muscle with t-coffee and nwnsi, the most accurate mafft script, see  <cit> .

execution speed
to compare speeds for a larger number of sequences, we created a test set by using psi-blast to search the ncbi non-redundant protein sequence database for hits to dienoyl-coa isomerase , selecting the highest-scoring  <dig>  sequences. this set of sequences had average length  <dig>  maximum length  <dig> and average pair-wise identity 20%. we aligned randomly chosen subsets of from  <dig> to  <dig>  sequences with each program and noted the total execution time. in the case of  <dig>  sequences, the resulting alignments had from  <dig>  from  <dig>  columns, confirming that it is unrealistic to assume that lp is o. results are shown in figure  <dig>  we have previously shown that muscle-prog is faster than fftns <dig> on a set of  <dig>  sequences, for which we estimated that clustalw would require approximately one year  <cit> . in this test, muscle-fast is approximately 3× faster than fftns <dig> for  <dig> sequences, and 5× faster for  <dig>  sequences. this trend continues for larger numbers of sequences , showing that muscle-fast has lower asymptotic complexity, due largely to the use of additive profiles for progressive alignment compared with the profile matrices constructed by fftns <dig> 

CONCLUSIONS
muscle demonstrates improvements in accuracy and reductions in computational complexity by exploiting a range of existing and new algorithmic techniques. while the design–typically for practical multiple sequence alignment tools–arguably lacks elegance and theoretical coherence, useful improvements were achieved through a number of factors. most important of these were selection of heuristics, close attention to details of the implementation, and careful evaluation of the impact of different elements of the algorithm on speed and accuracy. muscle enables high-throughput applications to achieve average accuracy comparable to the most accurate tools previously available, which we expect to be increasingly important in view of the continuing rapid growth in sequence data.

availability and requirements
muscle is a command-line program written in a conservative subset of c++. at the time of writing, muscle has been successfully ported to 32-bit windows, 32-bit intel architecture linux, solaris, macintosh osx and the 64-bit hp alpha tru <dig> platform. muscle is donated to the public domain. source code and executable files are freely available at .

figures and tables
