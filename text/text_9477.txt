BACKGROUND
motivation
many complex systems can be conveniently represented using networks. the most prominent examples are: biological, social, informational, physical and transportation networks. there are many different types of biological networks, but perhaps the most interesting of them are protein-protein interaction  networks. proteins rarely function alone; instead they cooperate together to form complex networks of protein-protein interactions, which make our cells work. in ppi networks, nodes correspond to proteins and edges correspond to physical or functional interactions between them. the topology of ppi networks can give us new insight into the function of the individual proteins, as well as protein complexes and the whole cellular machinery as one complex system  <cit> . ppi datasets come from experimental studies such as yeast-two-hybrid , tandem affinity purifications , high-throughput mass spectrometric protein complexes identification , and others. recent studies have published a vast amount of ppi data for various organisms from viruses to human  <cit> . the amount of interaction data of different types and the number of organisms for which such data is available are only going to increase in the foreseeable future. hence, the problems of biological network modeling, comparison, alignment and clustering are becoming of particular importance. to address these problems, we introduce graphcrunch  <dig> - a major upgrade with added functionality to our first version of the graphcrunch software for network analysis  <cit> . the following features were added to graphcrunch 2: 1) implementations of two biologically-motivated network models: scale-free gene duplication and mutation  <cit>  and geometric gene duplication and mutation  <cit>  models; 2) implementation of the graph aligner  algorithm for topological network alignment  <cit> ; 3) implementation of a topology-based algorithm for clustering nodes in the network  <cit> ; 4) massive computational parallelization and results reuse functionality for added computational efficiency that enables analyses of large networks data sets; and 5) an easy-to-use graphical user interface for windows and linux platforms.

previous tools for network analysis
modeling, comparison, alignment and node clustering in complex networks are important problems across many domains and therefore several software tools addressing these problems have been introduced. in the biological network domain, some of the most commonly used ones are: cytoscape  <cit> , visant  <cit>  topnet  <cit>  with its successor tyna  <cit> , mavisto  <cit> , fanmod  <cit> , pajek  <cit> , mfinder  <cit>  with its visualization interface mdraw and the initial version of graphcrunch  <cit> .

since exact network comparison is computationally intractable due to the np-completeness of the underlying subgraph isomorphism problem, it is usually addressed by comparing various easily-computed network properties including degree distributions, clustering coefficients, and average pathlengths. tyna  <cit>  and pajek  <cit>  can be used to compute and compare these network properties, whereas mfinder  <cit> , mavisto  <cit>  and fanmod  <cit>  do not offer such functionality and are used for motif detection in the networks. cytoscape, graphcrunch  <cit>  and now its successor graphcrunch  <dig> are the only software tools that implement, in addition to basic network properties , highly constraining graphlet-based heuristics for network comparison   <cit> . cytoscape does it via additional plugins that a user needs to install. in terms of network models, graphcrunch  <dig> implements seven of the most commonly used random network models, whereas cytoscape, the original version of graphcrunch, mfinder, fanmod, pajek and mavisto implement  <dig>   <dig>   <dig>   <dig>   <dig> and  <dig> models, respectively, and other software tools do not support model generation at all.

the network alignment problem has been addressed by several local  <cit>  and global  <cit>  network alignment algorithms. local network alignment algorithms aim to find small regions of structural similarities in two networks, whereas global network alignment algorithms align all nodes in the smaller network to nodes in the larger network. most of these algorithms have been designed to use sequence similarity between nodes  in two networks, which makes them applicable only to networks for which such information is available, i.e., to biological networks. graal, h-graal, and isorank are the only algorithms for global network alignment that can align a pair of networks based solely on their topologies. in our previous work, we have demonstrated that graal and h-graal substantially outperform the isorank algorithm with respect to the number of aligned interactions  <cit> . since graal and h-graal produce alignments of approximately the same quality  <cit>  while graal runs significantly faster, graphcrunch  <dig> contains an implementation only of the graal algorithm.

our contribution
graphcrunch  <dig> is the only software that simultaneously implements methods for network modeling, comparison, alignment and topological node clustering. moreover, it implements more random network models than any other modeling software. also, it is the only software tool that implements all of the following:  pairwise network comparison using advanced graphlet-based heuristics;  the graal algorithm for network alignment, and  signature similarity-based clustering .

we demonstrate the utility of graphcrunch  <dig> by performing two case studies. first, we use its model generation and network comparison functionality to show that eukaryotic and viral ppi networks may belong to different network model families. second, we use its topological node clustering functionality to demonstrate a strong link between topology and function in the yeast and human ppi networks. graal, its application, and comparison with other methods is found in  <cit> .

implementation
models
finding well-fitting network models for biological networks is an important problem in systems biology, since it can improve our understanding of biological phenomena  <cit> , provide essential ingredients for statistical tests such as network motif identification  <cit> , and even empower practical applications like the de-noising of ppi network  <cit> . the network modeling problem is formulated as follows: given a data network with n nodes and m edges, define a random graph family such that if we sample a graph with n nodes and m edges from this family , it will be structurally similar to our data network. we discuss structural similarities between graphs in the "network comparison" section. graphcrunch  <dig> implements the following network models: erdős-rényi random graphs   <cit> , erdős-rényi random graphs with the same degree distribution as the data , scale-free barabási-albert preferential attachment models   <cit> , geometric random graphs   <cit> , stickiness-index based models   <cit> , scale-free gene duplication models   <cit> , and geometric gene duplication models   <cit> .

the model network generators are implemented as follows. erdős-rényi random graphs are generated by using the leda random graph generator  <cit> . er-dd graphs are generated by using the "stubs method"  <cit> : the number of "stubs"  is assigned to each node in the model network according to the degree distribution of the real-world network being modeled; edges are created between pairs of nodes picked at random; after an edge is created, the number of "stubs" left available at the corresponding "end-nodes" of the edge is decreased by one. scale-free  networks are generated by using the barabási-albert preferential attachment model  <cit> . geometric random graphs are defined as follows: nodes correspond to uniformly randomly distributed points in a metric space and edges are created between pairs of nodes if the corresponding points are close enough in the metric space according to some distance norm  <cit> . in our implementation, we use boxes in euclidean metric space, where dimensionality is a user-defined parameter. the sticky model is based on stickiness indices, numbers that summarize node connectivities and thus also the complexities of binding domains of proteins in protein-protein interaction  networks  <cit> . the sf-gd and geo-gd models are implemented by simulating gene duplication and mutation events as described in  <cit>  and  <cit> , respectively.

network comparisons
graphcrunch  <dig> uses several methods to compare the structures of two networks including: average clustering coefficients, average pathlengths, diameters, degree distributions, clustering and eccentricity spectra,  <cit>  as well as the more constraining graphlet-based heuristics  <cit> . we provide the definitions of these concepts below.

graphcrunch  <dig> can calculate all the following properties of a graph. the degree deg of a node u is the number of neighbors it has in the network. the degree distribution of the network, p, describes the probability that a node has degree k. the clustering coefficient of node u is defined as c = 2eu/ - 1)), where eu is the number of edges between neighbors of u. for nodes with deg ≤  <dig>  c is defined to be  <dig>  <cit> . the eccentricity of node u, eccen, is the maximum shortest path distance from node u to some other node in the network. the average pathlength of a network is the average shortest path length across all pairs of nodes in the network. the distributions of the clustering coefficients and eccentricities of all nodes of degree k in a network are called the clustering and eccentricity spectra, respectively. in addition, it computes pearson and spearman correlation coefficients between the degree distributions, and clustering and eccentricity spectra of two networks  <cit> . if two distributions do not have the same length, graphcrunch  <dig> disregards nodes with the smallest degrees from the larger distribution.

recently, more constraining, graphlet-based heuristics have been introduced for network comparison  <cit> . graphlets are small connected induced non-isomorphic subgraphs of a network  <cit> . by counting graphlets in the networks it is possible to quantify local topological similarities between networks or individual nodes. hence, relative graphlet frequency distance  is a measure that compares the frequencies of appearance of all  <dig> to  <dig> node graphlets in two networks  <cit> . since there are  <dig> possible graphlets on up to  <dig> nodes, rgf-distance encompasses  <dig> similarity constraints by examining the fit of  <dig> graphlet frequencies between two networks. the smaller the rgf-distance, the more similar the two networks are  <cit> . from a topological point of view, it is relevant to distinguish between automorphism orbits of each graphlet. for example, in a 3-node path, the "end-nodes" are identical from the topological point of view , whereas the "middle node" is different; therefore, a 3-node path has two different automorphism orbits. there are  <dig> automorphism orbits for the  <dig> graphlets on  <dig> to  <dig> nodes. the graphlet degree vector  of node v is a 73-component vector, such that its ith coordinate represents number of times this node is touched by an automorphism orbit i. the signature of a node is a highly constraining measure of local topology in the node's vicinity and comparing the signatures of two nodes is a highly constraining measure of local topological similarity between them  <cit> . the graphlet degree distribution agreement  is a similarity measure between topologies of two networks based on graphlet degree vector distributions . that is, it is used to compare the structural similarities between two networks. it is a number between  <dig> and  <dig> meaning that two networks are similar if they have high gdd-agreement.

network alignment
sequence comparison and alignment has had an enormous impact on our understanding of evolution, biology and disease. comparison and alignment of biological networks will probably have a similar impact and hence network alignment is a foremost problem in systems biology  <cit> . existing network alignments use information external to the networks, such as sequence. our algorithm, graal  <cit> , uses purely topological information based on graphlets in order to perform network alignment. since we use only topological information, graal can be applied to any two networks, not just biological ones. we have applied graal to biological networks to produce by far the most complete topological alignments of biological networks to date  <cit> . in that paper we demonstrated that both species phylogeny  and detailed biological function of individual proteins can be extracted from our alignments. topology-based alignments can provide a completely new, independent source of phylogenetic information. furthermore, we aligned the protein-protein interaction networks of two very different species-yeast and human-and found that even these two distant species share a surprising amount of network topology, and that aligned protein pairs share a significant amount of biological similarity. this provides strong evidence for broad similarities in internal cellular wiring across all life on earth.

it has been shown that pairwise network alignment algorithms, including our algorithm called graal that is implemented in graphcrunch  <dig>  <cit> , can be used to successfully address the following important problems:

 <dig>  finding conserved modules in ppi networks of different species  <cit> 

 <dig>  identifying functional orthologs in ppi networks of different species  <cit> 

 <dig>  reconstructing phylogenetic relationships among a group of species  <cit> 

for these reasons, we have added an easy-to-use interface to graal  <cit>  in graphcrunch  <dig>  given two networks, graal finds an "embedding" of the smaller network into the larger one such that every node in the smaller network is aligned to exactly one node in the larger one. the goal is to expose as much topological similarity between the networks as is possible. graal is a seed-and-extend algorithm that greedily aligns nodes based on their signature similarities while traversing both networks simultaneously in a breadth- first manner. in  <cit>  it was shown that graal produces topological alignments that expose regions of functional similarity that are far larger, denser, and superior in many ways to other available methods. note however, that graal should not be used for aligning noisy biological networks, since it uses topology only and hence it is not be expected to align such data correctly. instead, it should be used to align as clean and complete biological networks as possible, e.g. high-confidence parts of ppi networks, metabolic networks of closely related species, or protein structure networks.

since graal is based solely on network topology, it is applicable to all types of networks. however, such generality comes with a price graal does not utilize any additional information which might be available about nodes in the networks . even though it may seem easy to add such information to the graal algorithm  <cit> , finding an elegant and scientifically sound way of doing it is a subject of future research.

clustering
it is has been shown that similar interaction patterns imply functional similarities between proteins  <cit> . hence, one way to detect functionally similar proteins in a network is to cluster its nodes based on their topological similarities. also, such clustering might provide insights into how proteins perform their functions by interacting with each other. graphcrunch  <dig> contains an easy-to-use implementation of the k-medoids algorithm for clustering nodes in the network with a signature-based distance matrix  <cit> . the algorithm works as follows. it randomly initializes k cluster centers and then assigns the remaining nodes in the network to the clusters represented by nearest centers. then cluster centers are recomputed and the process is repeated until convergence. the only difference between k-medoids and the more conventional k-means algorithm  <cit>  is that the latter uses means of points in the cluster to represent the new cluster center, while the former requires all cluster centers to be the existing data points . this minor difference has an important implication: in the case of k-medoids, a network's nodes do not have to be represented as points in some metric space. all we need to have in order to apply the k-medoids algorithm is an all-to-all matrix of distances between nodes. graphcrunch  <dig> can load any user-provided distance matrix, or it can automatically compute all-to-all signature similarities between nodes in the network and use as the distance between any two nodes u and v, d =  <dig> - s, where s is the signature similarity between u and v.

among signature similarity-based methods that produce non-overlapping clusters , k-medoids has been shown to produce the best results  <cit> . therefore, we chose this algorithm as our default implementation. in addition, in our "case study 2" section below we use the human ppi network to demonstrate that our clustering method outperforms the markov cluster algorithm   <cit> .

finally, graphcrunch  <dig> allows several clustering scenarios. if the user wishes to use a signature similarities matrix with any other clustering algorithm, graphcrunch  <dig> can compute and save such a matrix into a file for future usage with other clustering software. in addition, such similarity matrix can be constructed for a pair of different networks, if the user wants to analyze topological similarities across different networks.

development
we developed graphcrunch  <dig> in c++ using the qt framework  <dig>  to allow the same user experience and high performance across popular windows and linux distributions  <cit> . additionally, graphcrunch  <dig> uses the free edition of leda  <dig>   <cit>  and qwt  <dig>  libraries  <cit> . the leda library is used for standardized handling of network input and basic computational analysis, while the qwt library provides plotting capabilities.

we tested graphcrunch  <dig> under microsoft windows  and linux  operating systems. graphcrunch  <dig> can be compiled  for 32- and 64-bit platforms.

user interface
we designed graphcrunch  <dig> with two main goals in mind: 1) to integrate and simplify the most important tasks of biological network analyses and 2) to provide an intuitive and easy to use graphical user interface for people whose primary area of expertise is not computer science, enabling them to run computationally expensive analyses on their laptops.

to achieve the second goal we created a simple, user-friendly graphical user interface  depicted in figure  <dig>  also, we have taken full advantage of the intuitive drag-and-drop functionality to simplify many common tasks. finally, our implementation follows the model/view/controller architecture to separate the gui from the application logic and, therefore, make graphcrunch  <dig> easily expandable.

input and output
graphcrunch  <dig> supports two input formats for representing networks: the leda graph format   <cit>  and the "edge list" format . the edge list format is simply the graph adjacency list, i.e., the list of node pairs  separated by tabs or spaces, with one edge per line. graphcrunch  <dig> automatically converts from edge list to leda graph format. the current implementation of graphcrunch  <dig> deals with undirected, simple , unweighted graphs. thus, for either of the above two formats, graphcrunch  <dig> automatically removes all self-loops, multiple edges and edge directions.

the summarized output statistics of each analysis completed by graphcrunch  <dig> can be saved in either of the following two formats: comma-separated format  or tab-separated format . additionally, the user can copy/paste the resulting tables into a separate application for further analysis. if the user clicks on the "save results" button in the main menu, graphcrunch  <dig> will save the results from the currently active tab. also, graphcrunch  <dig> has a basic plotting functionality, being able to plot the degree distributions of the data networks, gdd-agreement, rgf-distance and other statistics of the data versus models or pairwise data analyses. furthermore, the plotting functionality allows the user to select subsets of the results to be plotted, allowing the user to focus on results that are of interest. our plots can be exported in .png format, or as a table; the latter can be used by other programs for producing plots in other formats, if desired.

parallelization
graphcrunch  <dig> automatically parallelizes many complex tasks by splitting them into smaller independent tasks that can be run in parallel. graphcrunch  <dig> automatically determines the number of logical processors/cores available and runs as many basic tasks as is practical. more specifically, complex tasks  are split into the following  <dig> basic tasks: model generation, counting graphlets, computing rgf-distance, computing gdd-agreement, graal execution, computing signature similarities, k-medoids clustering and comparing basic network properties. it is important to note that there might be multiple dependencies between tasks. for example, before computing gdd-agreement between two networks, graphcrunch  <dig> must finish counting graphlets in both networks. since all such dependencies can be predetermined at runtime, graphcrunch  <dig> automatically calculates dependencies between tasks and schedules them for parallel execution without any intervention from the user.

for example, if the user has  <dig> data networks and wants to determine which model best fits the data by comparing the data networks to  <dig> instances of each model, graphcrunch  <dig> will split the computations into the following basic tasks: model generation , counting graphlets , computing gdd-agreement, rgf-distance and basic properties for each pair of data-model networks . hence, in total such analysis is split into  <dig>  basic tasks; however at any given moment in time, graphcrunch  <dig> runs only as many tasks as there are cpu cores available given that all their dependencies are satisfied.

graphcrunch automatically saves the results of each basic task for possible re-use in subsequent analyses . the user can interrupt and then resume any analyses from practically any point without losing or recomputing any results.

graphcrunch  <dig> performance
the following tests use a thinkpad with an intel core i <dig> cpu , 4gb of ram and windows  <dig> 

 <dig>  comparing  <dig> viral ppi networks  <cit>  against all models : about  <dig> hours.

 <dig>  aligning the yeast   <cit>  and human   <cit>  ppi networks using graal: about  <dig> hours. 

 <dig>  aligning any pair of the viral ppi networks listed in  <cit>  takes several seconds. performing all-to-all pairwise data comparison  of these networks also takes several seconds.

 <dig>  clustering nodes in the high-confidence yeast ppi network   <cit>  takes about  <dig> hours with the most of the time being spent on counting graphlets. once counting of the graphlets is done, graphcrunch  <dig> can re-use these results and cluster the nodes in this network in about  <dig> minutes for any k which we analyzed .

as mentioned above, the most computationally intensive basic task in graphcrunch  <dig> is counting of graphlets  <cit> . the time complexity of counting of graphlets is o. however, as it has been shown before  <cit> , the running time of graphlets count depends both on the size of the network and on its density, with sparser networks being processed much faster than the denser ones. since ppi networks are known to be sparse, and since graphcrunch  <dig> has parallel computing capabilities, it has competitive performance for processing the currently available ppi networks.

RESULTS
case study 1: modeling viral ppi networks
we analyze viral ppi networks of: varicella-zoster virus , kaposi's sarcoma-associated herpesvirus , herpes simplex virus  <dig> , epstein-barr virus  and murine cytomegalovirus   <cit> . fossum et al. noticed that ppi networks of these viruses differ from ppi networks of eukaryotic organisms . among the reported differences were: different degree distributions, smaller clustering coefficients and higher attack tolerance and robustness in the sense of smaller loss of connectivity in response to random node deletions  <cit> . hence, it is natural to ask if viral and eukaryotic ppi networks belong to the same network model. we use graphcrunch  <dig> to demonstrate that these viral ppi networks may belong to a different network family than do ppi networks of the above mentioned eukaryotic organisms. this is the first time that this has been demonstrated. using graphcrunch  <dig>  we compare the five viral ppi networks with  <dig> random instances of each of the following network models that are of the size of the data networks: er  <cit> , er-dd, sf  <cit> , geo  <cit> , sticky  <cit> , sf-gd  <cit> , and geo-gd  <cit>  . figure  <dig> and  <dig> present gdd-agreement and rgf-distance between the viral ppi networks and the corresponding model networks. for clarity, in these figures we present geo-gd probability cutoff model only for p =  <dig> ,  <dig>  and  <dig>  and sf-gd model only for q =  <dig>  and  <dig> . as it follows from figure  <dig> and  <dig>  according to both gdd-agreement and rgf-distance, the best-fitting model for viral ppi networks is the stickiness-index based model   <cit> .

this result is interesting because we have previously demonstrated that the best-fitting model  for high-quality ppi networks of eukaryotic organisms is the geometric gene duplication model   <cit> . hence, the differences in simple network properties between eukaryotic and viral interactomes noticed by fossum et al.  <cit>  may be attributable to their belonging to different network models.

case study 2: topological clustering of nodes in the human ppi network
many studies have shown that there is a link between ppi network topology and biological function  <cit> . it has been demonstrated that signature similarity-based clustering produces biologically meaningful clusters  <cit> . in particular, it can be used for protein function prediction  <cit>  and cancer gene identification  <cit> .

the intuition behind signature similarity-based clustering is as follows. in order to perform their functions, proteins interact with each other and, therefore, topologically similar interaction patterns should result in functional similarities between proteins. since signature similarity is a very powerful measure of topological similarity between nodes in a network  <cit> , we use signature-based clustering implemented in graphcrunch  <dig> to check if topological similarities in nodes' neighborhoods indeed result in biological similarities.

we take the human ppi network published by radivojac et al.  <cit>   and cluster its nodes using graphcrunch  <dig> into k =  <dig>   <dig>   <dig>   <dig>   <dig>   <dig>   <dig>   <dig>   <dig>  and  <dig> clusters . we use the gene ontology  database to see if our clusters contain functionally similar proteins  <cit> . we perform our analyses considering only "biological process" go terms. hence, we exclude from our analysis go terms corresponding to "molecular function" and "cellular component." we do so because "cellular component" go terms might be too general in this context and "molecular function" terms reflect proteins' chemical properties rather than their biological functions. hence, for each k, we analyze go term enrichment of each cluster  <cit> .

to analyze the statistical significance of go term enrichments of our clusters we use the go terms finder  software package  <cit> . this software tool examines a list of proteins to determine if there is a set of go terms, or parents of those go terms , that is shared by a statistically significant fraction of proteins in the list. hence, for each k we run go term finder on each of the k clusters to determine which go terms are shared by a statistically significant fraction of proteins in the cluster. the go terms finder calculates p-values based on the model of sampling without replacements using the hypergeometric distribution. therefore, in order to obtain valid p-values, we use as the background set not the set of all yeast proteins, but only those proteins which are present in the human ppi network that we analyze  <cit> . also, go terms finder performs bonferroni adjustment for its p-values and below we report only bonferroni-adjusted p-values; for details see  <cit> . we downloaded the go annotation data for this case study on may  <dig>   <dig> from the gene ontology website  <cit> . in our experiments, we used  <dig>  as the statistical significance cut-off for our p-values.

the results of this analysis are presented in table  <dig>  below we elaborate on several examples from table  <dig>  for k =  <dig>  there are  <dig> clusters that are statistically significantly enriched with go terms. in total,  <dig> "biological process" go terms are shared by a statistically significant fraction of proteins in at least one of these clusters. for example, there is a cluster in which  <dig> out of  <dig> proteins are responsible for positive regulation of cellular process , with the p-value of  <dig> × 10- <dig>  in the same cluster,  <dig> proteins are in a signaling pathway , with the p-value of  <dig>  × 10- <dig>  in total, this cluster is statistically significantly enriched with  <dig> go terms . in another cluster,  <dig> out of  <dig> proteins are responsible for negative regulation of ubiquitin-protein ligase activity during mitotic cell cycle , with the p-value of  <dig>  × 10- <dig> because only  <dig> proteins are annotated with this go terms in the ppi network. in total, this cluster is enriched with  <dig> different go terms.

k-medoids clusters statistics for the human ppi network  <cit> . the first column corresponds to the number of clusters  used in the k-medoids algorithm. the column labeled "# significant clusters" contains the number of clusters for which at least one "biological process" go term is shared by a statistically significant fraction of proteins in that cluster. the column "# significant terms" contains the number of "biological process" go terms that are shared by a statistically significant fraction of proteins in at least one cluster. the column "best enrichment" contains the highest percentage of proteins in some cluster that have the same "biological process" go term. the column "# best clusters" contains the number of clusters corresponding to the best enrichment.

for k =  <dig>  there are  <dig> clusters statistically significantly enriched with go terms. for example, there is cluster of  <dig> proteins that contains  <dig> proteins responsible for blood coagulation  and wound healing, with the p-value of  <dig>  × 10- <dig>  another cluster of  <dig> proteins contains  <dig>  proteins responsible for drug metabolic process , with the p-value of  <dig>  × 10-8;  <dig> of these  <dig> proteins  are also responsible for exogenous drug catabolic process , with the p-value of  <dig>  × 10- <dig>  in another cluster of  <dig> proteins there are  <dig> proteins  that are responsible for trna processing , with the p-value of  <dig>  × 10- <dig>  there is a cluster in which  <dig> out of  <dig> proteins are responsible for negative  and positive  regulation of ubiquitin-protein ligase activity during mitotic cell cycle with p-values lower than  <dig>  × 10- <dig>  in general, there are  <dig> go terms which are shared by a statistically significant fraction of proteins in at least one of these clusters.

to further explore the biological significance of our clusters, for each k, we examine each cluster in the human network with respect to the enrichment with proteins corresponding to: aging genes http://genomics.senescence.info/, hiv- <dig> interacting genes http://www.ncbi.nlm.nih.gov/refseq/hivinteractions/, pathogen-interacting genes http://staff.vbi.vt.edu/dyermd/publications/dyer2008a.html, and cancer-related genes  <cit> . to determine the significance of enrichments, we compute p-values using the hyper-geometric distribution and use the p-value cutoff of  <dig> . for k =  <dig>  there are  <dig> clusters statistically significantly enriched with aging genes,  <dig> clusters statistically significantly enriched with hiv- <dig> interacting genes,  <dig> clusters statistically significantly enriched with pathogen-interacting genes, and  <dig> clusters statistically significantly enriched with cancer-related genes. interestingly, there is one particular cluster of  <dig> proteins that is statistically significantly enriched with genes from all  <dig> categories. in particular,  <dig> % of the proteins in that cluster correspond to aging genes,  <dig> % of the proteins correspond to hiv- <dig> interacting genes,  <dig> % of the proteins correspond to pathogen interacting genes, and  <dig> % of the proteins correspond to cancer related genes . according to go terms finder, this particular cluster is statistically significantly enriched with  <dig> different go terms , among which are: interspecies interaction between organisms , regulation of signaling pathway , regulation of cell death  and  <dig> other death-related terms .

to confirm that our clustering does in fact capture a meaningful biological signal, we perform random clustering of the same human ppi networks into the same numbers of clusters as described above. then, we analyzed these random clusters with go term finder software  <cit> . not surprisingly, there is no biological signal in these random clusters. for k =  <dig>   <dig>   <dig>  and  <dig> go term finder reported statistically significant enrichment with go terms for  <dig>   <dig>   <dig>  and  <dig> clusters, respectively, with the maximum enrichment with  <dig> go terms . given the amount of generated clusters  and the amount of go terms in the database, this can be expected at random. therefore, the amount of "false" biological signal in our clusters is minimal.

as with many other clustering algorithms, the k-medoids algorithm implemented in graphcrunch  <dig> requires the number of clusters to be predefined in advance by the user. determining the right number of clusters is an important research question, and its value depends on the particular situation. we suggest trying several k's and examining all configurations for biological meaningfulness using, for example, go term finder   <cit> .

the markov cluster algorithm  is another popular graph clustering algorithm which can cluster graphs based solely on their topology  <cit> . unlike k-medoids, it does not require the number of clusters to be given in advance; however, it requires an inflation  parameter  <cit> . we ran mcl  from http://micans.org/mcl/) on the same human ppi network using the inflation parameter i from  <dig>  to  <dig>  as recommended. for i =  <dig> , the algorithm produced  <dig> clusters while for other values of the parameter  it produced more than  <dig>  clusters  many of which contained only  <dig> or  <dig> nodes. we used graphcrunch  <dig> to produce  <dig> clusters and compared their go term enrichment with that of the clusters produced with mcl , using go terms finder. out of  <dig> clusters produced by graphcrunch  <dig>   <dig> were found to be statistically significantly enriched with  <dig> go terms. also, the smallest cluster produced by graphcrunch  <dig> had  <dig> proteins. in the clustering produced by mcl,  <dig> out of  <dig> contained  <dig> proteins and therefore it is not possible to judge the statistical significance of their go term enrichment. out of the remaining  <dig> clusters, go terms finder found  <dig> clusters to be statistically significantly enriched with  <dig> go terms. hence, for this particular network, clustering produced by graphcrunch  <dig> has twice as many significantly enriched clusters and with more go terms. thus, graphcrunch  <dig> appears to produce better results than mcl for these particular datasets. in addition, it produces better results than hierarchical or signature threshold-based clustering  <cit> .

we also compare the performance of our method with that of aragues et al.  <cit> , which also predicts from ppi networks the involvement of genes in cancer. while  <cit>  focus only on direct network neighbours of cancer genes, we account for complex wirings of their up to 4-deep neighbourhoods, using 5-node graphlets; we demonstrate  <cit>  that out of all known cancer gene pairs that have similar topological signatures,  <dig> percent are not direct neighbours in the ppi network. moreover, in addition to network topology,  <cit>  also use gene expression data and structural and functional properties of cancer proteins, while we use the network topology only. even though we do not use any information external to ppi network topology, our approach is superior, as it results in higher prediction accuracy  <cit> . thus, graphlet degree signatures provide a better prediction accuracy than less constraining network properties such as nodes' direct neighbours, even when nodes' direct neighbourhoods are integrated with other data types.

comparison with existing tools
we compare graphcrunch  <dig> with eleven of the most commonly used tools: the initial version of graphcrunch  <cit> , cytoscape  <cit> , visant  <cit>  mfinder  <cit> , mavisto  <cit> , fanmod  <cit> , tyna  <cit> , pajek  <cit> , isorank  <cit> , graemlin  <cit> , and graphm  <cit> . the summary of the functionality of these tools is presented in table  <dig>  cytoscape is the closest in functionality to graphcrunch  <dig>  but graphcrunch  <dig> has the following unique features. none of the tools other than graphcrunch  <dig> can compute signature similarities between nodes in a network, or between two networks. cytoscape has a plugin "graphletcounter" that can compute node signatures, but it cannot find signature similarities between nodes, cluster nodes based on these similarities, or compare networks based on rgf-distances or gdd-agreements . hence, graphcrunch  <dig> is the only software tool that can cluster network nodes based on their topological signature similarities. furthermore, graphcrunch  <dig> is the only tool that can compare real networks to one another or to model networks based on rgf-distances and gdd-agreements. note that mfinder finds network motifs, not graphlets. graphcrunch  <dig> is the only software tool that implements the graph aligner  algorithm; this is in addition to its ability to generate model networks, compute graph properties  and comparing networks based on them, visualizing the results, computing node signature similarities and performing topological node clustering. also, graphcrunch  <dig> offers the largest number of network models. with regards to clustering, graphcrunch  <dig> implements k-medoids applied to graphlet-based node signature similarity ; this clustering method has been shown to outperform hierarchical clustering, signature threshold-based clustering  <cit>  and the mcl algorithm . cytoscape has plugins for many clustering methods, but it cannot cluster nodes based on their topological signatures. also note that cytoscape and its plug-ins are all written in java, while graphcrunch  <dig> is written in compiled c++. for example, computing all signatures for a network with  <dig>  nodes and  <dig>  edges in cytoscape takes about  <dig> minutes, while graphcrunch  <dig> can do this and cluster this network in about  <dig> minute. furthermore, compared to graphcrunch  <dig>  cytoscape lacks task-based parallelization features for counting graphlets . hence, it is not able to provide fast processing of larger data sets by compute intensive algorithms, such as graphlet and orbit counts, or network alignment. we further note that cytoscape is a plugin-based platform and therefore, to enable certain features, the user needs to install additional plugins; to summarize its functionality in comparison with other tools in table  <dig> we used a list of all available plugins from http://chianti.ucsd.edu/cyto_web/plugins/.

the "graph properties" column contains "yes" if the package can compute at least the average diameter and clustering coefficient. the "# models" column corresponds to the number of random network model families supported by the package. the "graphlets" column contains "yes" if the package can count all graphlets and orbits in the network with up to  <dig> nodes and if it can compute signature similarities. the "visualization" column contains "yes" if the package is able to visualize graphs  or results . the "clustering" and "gna" columns indicate whether the package supports clustering and global network alignment , respectively.

CONCLUSIONS
graphcrunch  <dig> is a software tool that implements the latest research on biological network analyses. graphcrunch  <dig> includes implementations of network modeling, comparison, alignment and clustering. we have demonstrated that graphcrunch  <dig> can be used to extract biological information from the network topology. we believe that our case studies barely scratch the surface of the knowledge that can be extracted from the interaction data. as more interaction data for multiple species are becoming available, software tools such as graphcrunch  <dig> will become increasingly useful.

availability and requirements
project name: graphcrunch 2

license: gnu gpl

project homepage: http://bio-nets.doc.ic.ac.uk/graphcrunch2/

operating systems microsoft windows , linux

programming language: c++

authors' contributions
ok and as contributed to the design and implementation of graphcrunch  <dig> functionality. ok performed all statistical test. wh designed and implemented the initial version of the graal alignment algorithm. np directed all aspects of the research. all authors read and approved the manuscript.

