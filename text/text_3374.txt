BACKGROUND
protein structure is obviously modular, with similar structural segments, such as alpha helices and beta strands found in unrelated proteins. such segments, identified from structure, are used extensively in description and analysis of protein structures  <cit> . several groups have demonstrated that only a small library of segments is sufficient to rebuild experimental protein structures with high accuracy  <cit> . predicted local structure segments  are also used in structural prediction, starting from the nearest neighbor approach to secondary structure prediction  <cit> . this idea was later extended and lead to even more successful applications of plsss in ab initio structure prediction by baker and colleagues, who developed a library of sequence-structure motifs called i-sites  <cit> . those motifs are later assembled in a complete protein structure by a program rosetta  <cit> . predicted local structure segments are also used in a novel protein alignment algorithm, based on the comparison of plsss for two proteins treated as networks and finding a common path through networks describing the two proteins  <cit> . the underlying idea in all those approaches is that because global folding constraints can override local preferences, the prediction of structure segments from local sequence is by necessity uncertain. therefore, instead of trying to predict a correct local structure, all possible local solutions are identified and other constraints  are used to identify a globally consistent solution.

prediction of local structure segments can be approached in two different ways. a first possibility, used in most nearest neighbor secondary structure algorithms, is to use a representative set of proteins with known structure as source of structure segments, but without any restrictions on a number or type of segments. in this approach, we don't make any assumptions about the compositions and distributions of segments in the library and this approach can be compared to unsupervised learning approach. in a second approach, used for instance in the i-site method, only segments from a specifically constructed fragment library are used in prediction, thus this approach is similar to supervised learning. interestingly, some limited tests suggest that the former approach leads to lower prediction accuracy  <cit> . the same tests suggested the possibility that different segment libraries could lead to different prediction, and likely, some segment libraries would be better suited to some tasks.

following this observation, we have developed the fraglib – a fragment library specifically designed to complement a segment alignment sea. sea alignment algorithm was developed previously in our group  <cit>  and originally used in conjunction with the i-site library. i-site library  <cit>  was originally developed to be used in ab initio folding predictions and anecdotal evidence suggested that it may not be ideally suited for alignment purposes. in this note we describe a combined fraglib/sea server and first benchmarking results of this method.

implementation
database of short fragments
fraglib is based on the idea of developing a uniform coverage of all known types of local structural regularity with the distribution based on that observed in natural proteins. the collection of segments is constructed using representative set of proteins from the astral database  <cit> . for each protein in this set, each continuous segment with regular secondary structure, including the flanking residues on both sides, is added to the fraglib . we do not utilize any further clustering algorithm so our database contains no-unique entries and it is redundant both in terms of structure and sequence information.

local structure is described by the slsr  codes consisting of  <dig> symbols {hgeebdbllxc}, each representing a certain backbone dihedral  region  <cit> . protein local structure is described as a string of local-structure symbols and a local structure segment is defined as a 5– <dig> amino acid fragment with constant local structural codes. segments are then extended by two additional residues offset at the beginning, and at the end of a segment. we store all such segments with their sequence, slsr style local structures representation codes and the homology profile  <cit> , derived from that of their parent protein. the library is highly redundant, i.e. there are many segments with the same structural description, but each of the redundant fragments is coming from a different parent protein , therefore it has a different sequence and a different profile associated with it.

fraglib prediction
in a next step, fraglib segment library is used to assign local structure segments for a new protein  based only on sequence information using a variant of the ffas profile-profile alignment algorithm  <cit> . a profile for the query protein is calculated following the ffas protocol, then for all possible overlapping segments of length from  <dig> to  <dig> amino acids, their profiles are compared to those of the segments from the fraglib database and the score of each alignment is calculated using a ffas-like scalar product of composition vectors at each position. since the segments being compared have the same length, no dynamic programming alignment is necessary and the score calculation can be highly optimized.

as the result of this procedure, each position in the query protein can be assigned to all of the possible lsss in the database, each with a specific score . only reduced sets of predicted lsss, rather arbitrarily limited to the first  <dig> highest scoring segments are kept for further analysis. this cut-off is the only free parameter of the method, and can be set by user using the web interface of the server. the q <dig> quality of the fraglib used as a secondary structure prediction algorithm , with the prediction based on the single best scoring segment for each position is 73% on a standard secondary structure prediction benchmark. the q <dig> gives percentage of residues predicted correctly as helix, strand, and coil or for all three conformational states.

sea segment alignment approach to protein comparison
the principal motivation to develop the fraglib segment prediction was to further improve the alignment quality for comparing distantly related proteins, which is one of the most important problems in practical application of comparative modeling and fold recognition  <cit> . to address this problem, we have previously developed a sea algorithm, which compares the network of predicted local structure segments  for two proteins using the network matching approach. in a previous paper we have demonstrated that the sea algorithm, using i-site server for plsss prediction and a simple sequence-sequence scoring for segment comparison resulted in alignments better than the ffas profile-profile alignment algorithm and several other alignment tools.

a full description of the sea algorithm is available in the previous manuscript  <cit> , so only a brief summary is presented here. every residue in each of the proteins being aligned is described as a vertex in the graph. two artificial vertices are added to the very beginning of each protein as a source vertex, and also at the end as a sink vertex. for each plss is described as an edge between the vertices representing its first and last positions. for some plss protocols, some parts of the protein may not be covered by any predicted segments, so virtual edges are added to all neighbor residues to form a complete, continuous network. each assembly of connected plsss corresponds to a path in this network. in a next step, plsss networks of two proteins are compared by the sea algorithm. for each pair of positions i and j, with position i coming form the first protein and position j from the second protein, all possible segments covering each of the positions must be considered in a combinatorial way and compared to get the optimal similarity score. it is not the sequences or secondary structures at two positions that are compared, but all segments that cover these two positions. this is the main feature of sea that makes it different from standard sequence pair-wise alignments. the computational complexity of sea is about o, where c <dig> and c <dig> are the average numbers of segments that cover a position in each protein . detailed description of the sea mathematical algorithm together with benchmarks results obtained using the i-site server calculated plsss network can be found elsewhere  <cit> .

the integrated fraglib and sea server is available at  <cit> . the fraglib database and segment prediction provides the plsss network for each aligned protein, and the sea algorithm aligns the two networks. on figure  <dig> we present the flowchart of the integrated web service. preliminary benchmarks for the fraglib/sea server and presented below. a full paper on the fraglib algorithm is in preparation.

RESULTS
we use here as a benchmark the database of  <dig> family-level similar pairs  <cit> . each protein pair shares at least one similar domain as identified by scop  <cit> . segments coming from the proteins of the same scop family as the proteins being compared were removed from the fraglib calculated plsss network. further analysis of the sea results also confirmed that the memorization is not a problem here, as all the sea alignment are build predominantly from segments that are not locally optimal.

to evaluate the improvement we use two measures of alignment quality: the classical root mean square deviation  and the shift score  <cit> . the shift score measures misalignment between a predicted alignment of two proteins and the reference alignment. the shift score measure ranges from -ε to  <dig> , where  <dig>  means an identical alignment. rmsd is dependent on alignment length and the shift score is dependent on the reference alignment, so both measures are less than perfect in comparing alignments. in our case we use as the reference alignment provided by the ce structural method  <cit> . we chose the ce, which is available as a single file executable for various operating systems, as an example of purely structural alignment tool. it is a method for fast calculation of pairwise structure alignments, which aligns two proteins chains using characteristics of their local geometry as defined by vectors between cα positions. heuristics are used there in defining a set of optimal paths joining termed aligned fragment pairs with gaps as needed. the path with the best rmsd is subject to dynamic programming in order to achieve an optimal alignment. for specific families of proteins additional characteristics are used to weight the alignment.

'table  <dig> ' compared the quality of the fraglib/sea  alignment with that of the structural alignment prepared with the ce algorithm  <cit>  and the sea algorithm used with i-site segment prediction , sea algorithm used with the actual  local structure segments , local single predicted structures  and few other publicly available alignment tools. all the results other than the fraglib/sea alignments, as well as alignment quality evaluation, were adopted from the original sea manuscript  <cit> . the results presented in 'table  <dig> ' show that seaf significantly improves the alignment quality as compared to all other methods, including seai , bringing it close to  the sea algorithm using the actual structure segments.

CONCLUSIONS
the benchmarks show that sea with fraglib  integrated prediction service better incorporate diversities of local structure predictions over known methods. it produces also more accurate alignments in comparison to seai , or the sea with single predicted structures . comparing those sequence pairwise alignments we can observe that predicted local structure information seems to improve the alignment qualities. alignments from sea using fraglib method of describing diversities of local structure prediction have the same quality as alignments using true local structures derived from their known 3d structures seat.

availability and requirements
an integrated sea/fraglib server is available at  <cit> . both components can be used separately, sea alignment with arbitrary plsss and fraglib for other purposes than segment alignment, but the integrated server provides the complete alignment method for comparing pairs of protein sequences using a network matching algorithm. the fragments library prediction method  is also available as the separate http server at  <cit> . the software is freely available to academics. contact dariusz plewczynski darman@bioinfo.pl or adam godzik adam@burnham.org for information on obtaining the local copy of a software.

authors' contributions
dp designed, implemented, and evaluated the fraglib program. the benchmark dataset and programme for aligning two short sequence profiles were provided by lj. the integration of fraglib predictions within sea network alignment software together with benchmark evaluation of the sea method was done by yy. ag was responsible for the overall project coordination. all authors have read and approved the final manuscript.

acknowledgments
this work was supported by the usa grant  and biosapiens project within 6fp eu programme .

figures and tables
family-level benchmark for sea algorithm using fraglib's prediction of lsss  is compared with seai , seat, sealoc , and other classical tools: ce, blast, align and ffas. the 'average' is the shift score averaged over all the alignments of the whole subset. the numbers of protein pairs with a shift score or rmsd larger than a certain cut-off value in the subset are listed in columns for each program. the counting based on rmsd requires the length of the alignment to be longer than half of its corresponding structural alignment. the 'all' stands for all the alignments with alignment length no shorter than half of the structural alignments. we use the ce for building reference alignments for shift score calculation, as an example of purely structural alignment tool. the 'len' stands for the average alignment length . we can see that our method provides very long alignments with relatively good overall score. the difference in the values between seat and seaf is explained by different lengths of these alignments.
