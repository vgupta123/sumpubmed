BACKGROUND
the level of uncertainty in next-generation sequencing  measurements is still higher than what is required for routine clinical use, even for germline variants in targeted gene panels and exome sequencing  <cit> . the measurement process includes a complex computational variant calling pipeline, which contains many alternative elements with various parameters, heavily influencing the unique characteristics and performance of the whole procedure. several studies showed that  currently there is no single best general individual variant calling method with both superior sensitivity and precision at all circumstances  <cit> , and  there are significant discrepancies between commonly used variant calling pipelines, even when applied to the same set of sequence data . an ad hoc approach is the fine-tuning of the pipeline for the actual measurement, which requires substantial expertise and time, also hindering standardization and benchmarking.

generally, variant callers aim to be sensitive, call variants “aggressively” and provide annotations to the user that can help distinguish true variants from false calls originating from sequencing, alignment or data processing artefacts. to further improve the sensitivity of the pipeline, one can use multiple variant calling methods, as it is a well-known fact that different callers produce different results . the rationale behind this practice is that the consequence of a false negative variant call  is usually more serious than the consequence of a false positive , especially in clinical settings. the union of different call sets  could be taken for maximum sensitivity. however, this would result in higher false positive rate, i.e. a decrease in precision. variants could, in principle, be validated experimentally using complementary measurement methods, but only at the cost of losing the high-throughput efficiency of ngs. therefore, an application-specific balance between sensitivity and precision is needed.

a possible solution for selecting the appropriate list of variants is the use of hard filters. variant callers produce a rich set of annotations that provide abundant information about mapping quality and various biases. for example, the evidence for a mutation is usually stronger at higher read depths  <cit> . a bias in the position of the variant in the read or a bias in the number of reads or base quality scores supporting an alternate allele may denote mapping problems and can be used to identify false variants. however, annotations have complex interrelationships  <cit> , they depend on the experimental settings, and in most cases, are difficult to interpret  <cit> . it is often unclear what an adequate hard filter is; beyond general guidelines each specific study requires experimenting and empirical testing. besides, most annotation classes depend on the actual read depth, and a filter setting which works for low coverage may not perform equally well for high coverage. the non-uniform coverage often seen in ngs studies  <cit>  makes hard filtering a challenging task. furthermore, it is also difficult to assess the resulting precision of the hard-filtered variant set.

an automated approach to improve precision of variant calling, applicable at a larger scale, is the use of variant quality score recalibration   <cit> , which can be used to reclassify variant qualities. however, it requires a large amount of data: it can be used only for whole genomes or for at least  <dig> whole exomes according to gatk best practices. if a smaller region is sequenced, one can rely only on manual hard filters. besides, vqsr uses gold standard, “error-free” variant sets as reference. in case of organisms for which these resources are unavailable, vqsr cannot be used in a straightforward manner.

in fact, automated recalibration can be also applied using abundant annotations of multiple pipelines instead of large amount of data: in this case the heterogeneous, intermediate annotations from multiple methods can be exploited for automated “recalibration”. indeed, this forms our central hypothesis that popular variant calling pipelines are not merely discordant, but the generated intermediate annotations contain complementary high-dimensional information, which can be combined into a better performing overall model. our further hypothesis is that fusion of the intermediate annotation information allows the prediction of probabilities of variants in areas not accessible by current approaches.

based on these assumptions, we constructed variantmetacaller, which combines information from various variant callers using support vector machines  . figure  <dig> shows the earlier approaches, the current study design including data sets and evaluations, and the conceptual overview of variantmetacaller. this novel method predicts the probability that a variant is a true genetic variant and not a sequencing artefact, which provides a principled solution for quantitative support for variant filtering. specifically, probabilities can be used to order the variants, and for a given threshold, probabilities can be used to estimate precision. precision then can be directly translated to the number of true called variants, or equivalently to the number of false calls, which allows finding problem-specific balance between sensitivity and precision, i.e. it allows a quantitative, precision-based filtering.
fig.  <dig> earlier approaches, current study design including data sets and evaluations, and the conceptual overview of variantmetacaller. study design: simulated sequences of various target region sizes, and real sequence data covering the whole exome of na <dig> were aligned by bwa and bowtie  <dig> to the human genome. variants were called by gatk haplotypecaller, gatk unifiedgenotyper, freebayes and samtools. evaluation: variant calling pipelines were compared by calculating concordance rates. precision-recall curves were plotted and the area under the precision-recall curves was calculated for each method. earlier approaches: hard filters can be applied to filter variants by specifying annotation cutoffs. vqsr can be applied to recalibrate variant qualities based on gold standard reference data and variant annotations. baysic combines the unfiltered variant calls by late integration. overview of variantmetacaller: variantmetacaller  combines the unfiltered call sets by svms that use variant annotations as features and  estimates the probability of each variants being real. the probabilistic output of vqsr and variantmetacaller can be used to estimate fdr at each probability cutoff and to optimally select the filtered variants with respect to the cost function of the researchers. auprc = area under the precision-recall curve, fdr = false discovery rate, ngs = next-generation sequencing, svm = support vector machine



automated fusion of multiple variant callers has been seen as a promising direction to exploit hidden information with more advanced statistical models. until now, the arising problem of high-dimensionality and heterogeneity has remained unsolved in earlier fusion approaches, for example baysic  <cit> , used only the predicted calls, implementing late information fusion. to cope with high-dimensionality, a few svm-based methods have already been introduced, such as the unpublished ensemble method  <cit>  and the one used for the exome sequencing project  <cit> . the method of the exome sequencing project was not developed to utilize the combination of multiple variant-callers, and it determines annotation value cutoffs for defining negative training examples and gold standard data sets for defining positive training examples  <cit> . variantmetacaller is conceptually similar to ensemble, but the latter is limited to single-sample variant sets, and as to our knowledge, does not produce a quantitative score and therefore cannot be used to balance between sensitivity and precision.

in this paper, we first overview the main characteristics of synthetic data sets used for evaluation throughout the paper. second, we report the performance of various variant calling methods with special emphasis on their heterogeneity and concordance. next, we present a systematic evaluation and comparison of selected previous variant calling pipelines against variantmetacaller using both synthetic and real sequencing data. specifically, we investigate the accuracy of the predicted probabilities of the variants showing the superiority of variantmetacaller over existing solutions.

RESULTS
results on simulated sequencing data
we created synthetic sequencing data with known variations in the reference genome to compare the performance of previous variant calling pipelines to that of our method. we chose chromosome  <dig> for illustrative purposes and created artificial diploid chromosomes that contained randomly selected exonic variants from the publicly available exome aggregation consortium variant call set . the target regions were all exons of the 17th chromosome with a total size of around  <dig>  mbp. we created  <dig> independent samples and arranged them into five distinct groups. the total number of snps and indels was  <dig>  and  <dig> , respectively, and the average number  of polymorphic snps and indels was  <dig>   and  <dig> , respectively in the generated samples. we simulated paired-end sequencing of the artificial chromosomes at various depths of coverage from very low  to high  mean coverage. the simulated sequences contained illumina-specific sequencing errors .

after aligning the sequencing reads with bwa–mem and bowtie  <dig> to the human reference sequence, we called variants on the five sample batches with four different variant callers  .

performance and concordance of individual variant callers
our results showed, in agreement with previous findings , that there was not a single best general individual variant calling method with superior sensitivity and precision at all read depths, neither for snps nor indels, although haplotypecaller performed quite well in case of indels and was the most precise in case of snps .

additionally, several studies showed that there were significant discrepancies between commonly used variant calling pipelines, even when applied to the same set of sequence data . to understand and utilize this phenomenon, we systematically evaluated the concordance rates of the four variant callers, with a special focus on the impact of coverage depth. this step is essential, because our newly developed method, variantmetacaller, is heavily based on the concordance and certain complementarity of the unfiltered call sets of the individual variant callers.

first, we quantified the concordance rates of the individual variant callers by counting the number of methods calling a given variant. the percentage of concordantly called variants by all four variant callers were considerably higher for snps than for indels . in case of snps, the percentage of concordant variant calls roughly increased from approximately 78− <dig> % seen in low coverage to 90− <dig> % in high coverage, depending on the aligner. conversely, the percentage of singly-called variants roughly decreased with increasing coverage, from approximately 7− <dig> % in low coverage to 1− <dig> % in high coverage . at low depths, the frequency of the singly-called variants was the second highest, but with increasing coverage, this category became the least frequent.
fig.  <dig> fraction of all, true and false variants called by a different number of variant callers in case of simulated data. sequencing reads covering the exonic region of a selected chromosome were simulated for  <dig> artificially generated samples with pre-known variations to the human genome . variants were called on the bwa–mem and bowtie  <dig> aligned reads by haplotypecaller, unifiedgenotyper, freebayes and samtools. stacked bars with different colors represent the fraction of all , true  and false  variants with respect to the reference variants, called by a given number of variant callers at various coverage depths . each panel is divided into four subpanels, where the top pair represents: snps, bottom pair: indels, left column: bwa alignment, right-column: bowtie  <dig> alignment



in case of indels, the variant callers produced markedly different results. irrespective of the coverage depth, less than the half of the indels were called by all four methods, and the fraction of singly-called variants were above  <dig> %. furthermore, the frequency of the singly-called variants was the second highest at all depths.

we also found that above medium coverages, the percentage of fully concordant variants slightly began to drop for both snps and indels. these results are in compliance with the findings of yu and sun  <cit>  and o’rawe et al.  <cit> , but it contradicts the expectation that with increasing read depth the accuracy of variant calling would also increase, which would in turn result in higher concordance between individual variant callers. although, this is not the main focus of the paper, we show in the supplementary results  that sensitivity and precision change in opposite directions at varying depths. specifically, for increasing coverage from low to medium depths, sensitivity gain surpassed precision loss alluding to increased accuracy, which also resulted in higher concordance. however, at higher read depths, the sensitivity gain and precision loss was more balanced or even reversed. we suspect that these phenomena are related to different types of statistical errors stemming from small coverage  and asymptotic errors  of the variant callers, but this requires further investigation.

the concordance rates were generally lower for variant call sets based on the bowtie  <dig> with respect to bwa, alignments, which can be partly explained by the relatively higher accuracy of variant calls based on bwa alignments .

next, we restricted variants to only true or false positives, and partitioned the variants according to the number of methods that called them. figure 2b and c illustrate the empirical distribution over the partitions. the fraction of true variants was generally the highest for the concordantly called snps and indels, and was generally the lowest for singly-called variants apart from very low coverages . in parallel with this, the fraction of falsely called variants was the highest in the category of the singly-called variants , and was negligible  in the case of highly concordant variants. the fraction of falsely called variants was an order of magnitude higher for indels than for snps, reflecting the well-known observation that indel calling is more difficult than snp calling  <cit>  . besides, the fraction of false variants increased with increasing coverage across all depths for indels and above 20× coverage for snps. at high coverage the rate of falsely called variants was approximately 2− <dig>  % for snps, and 30− <dig> % for indels depending on the aligner.

finally, we calculated the fraction of true variants among variants called by exactly one or by all four methods . the percentage of true variants among variants called by all four methods was generally high, both for snps  and for indels , irrespective of the coverage depth. conversely, the fraction of true variants among singly-called variants was significantly lower, and decreased with increasing coverage, both for snps  and especially for indels .

our novel method, variantmetacaller, exploits these observations, and uses the fully concordant variants as positive and the singly-called variants as negative training examples and trains svms to separate true variants from potentially erroneously called variants. as additional file 1: figure s <dig> shows, there is an apparent noise in the training data, specifically the substantial fraction of true variants in the negative training set. thus, we investigated its effects and found that excluding the negative training examples and including only the positive ones in a one-class svm framework decreased the performance of variantmetacaller. furthermore, we evaluated the performance of variantmetacaller using a filtered training set that was ideal in the sense that it contained only true negative singly-called and true positive fully concordant variants. however, this resulted only in a very low increase in performance . finally, it can be generally expected that the use of even more variant callers in the variantmetacaller framework will mitigate this problem .

comparison of variantmetacaller to individual variant callers
variantmetacaller combines the results of multiple variant callers based on their statistical properties described earlier. after merging the unfiltered variant calls, the program creates a data set for each input method from annotations generated by the callers coupled with annotations computed by variantmetacaller. on these data sets, svms are trained separately for snps and indels using fully concordant and singly-called variants as positive and negative training examples, respectively. a final svm score is computed for each variant, which estimates the probability of the variant being “real” .

we evaluated the performance of variantmetacaller over two different pipeline sets based on the choice of the alignment software, the four variant calling methods were run on either the bwa or bowtie  <dig> aligned reads. specifically, we calculated the precision and the sensitivity  of all variant callers at each variant quality threshold, and similarly of variantmetacaller at each svm score threshold and plotted sensitivity against precision . for the evaluations, we used the hard filtered call sets of each individual variant caller . as it can be clearly seen, variantmetacaller dominated all variant callers in the precision–sensitivity space, meaning that variantmetacaller achieved higher precision at all sensitivity levels than any of the individual variant callers irrespective of the depth of coverage, the aligner and the type of the variants. furthermore, variantmetacaller achieved higher maximum sensitivity as well, albeit the precision dropped sharply at high sensitivity values.
fig.  <dig> precision-sensitivity curves at selected coverage depths for simulated data. precision and sensitivity  was calculated for each variant of the hard filtered call sets of four individual variant callers and for the results of variantmetacaller. precision was plotted against sensitivity for snps  and for indels  at two selected coverage depths . the rows differentiate between alignment algorithms and the columns represent different coverage depths. variant calling was performed on five sample groups each containing ten samples. bands around lines represent  <dig> % confidence intervals based on the results of the different sample groups. fb = freebayes, hc = haplotypecaller, st = samtools, ug = unifiedgenotyper, vmc = variantmetacaller



as we show in the supplementary results , the precision of all individual variant callers was relatively high for snps  as opposed to the precision for indels . the precision of variantmetacaller was therefore higher for snps than for indels.

we calculated the area under the precision–recall curves , which is a summary statistic that reflects the ability of a score to correctly identify true variants. more specifically, the auprc measure can be interpreted as a probability: it equals the fraction of true variants among those variants whose score exceed a randomly selected threshold  <cit> . auprc is commonly used to assess the performance in highly imbalanced problems, where true negatives highly outnumber the true positives, such as document search on web, and this also holds in variant calling, where the true negatives virtually span the whole target region. auprc is a more informative indicator of performance in these cases than e.g. the area under the receiver operating characteristic curve , because auprc is not overwhelmed by the huge number of true negatives.

the auprc of variantmetacaller was the highest among all methods independently of coverage depth, the aligner or the type of the variants . the difference was strongly statistically significant in the case of all depths and for both aligners . as it is expected, the auprc was lower at low depths and increased with higher coverage, and for snps, the auprc was higher at the same depth than for indels. in case of snps , the individual variant caller with the highest auprc varied with different depths and aligners. at the lowest depth, unifiedgenotyper had the highest auprc, but with increasing depth it became the worst. haplotypecaller produced the highest auprc for indels among the variant callers irrespective of the depth of coverage and the aligner .

generally, the difference between variantmetacaller and haplotypecaller was the lowest with the exception of very low depths, and except for snps with bowtie  <dig> alignment where the best performing method varied depending on the coverage depth. in case of snps , both freebayes and samtools showed a relatively high difference at low depths, but these differences decreased sharply at higher coverage. interestingly, unifiedgenotyper showed an opposite trend: relatively good performance at low depths turned into the largest difference at higher depths. in case of indels , the differences of auprc between variantmetacaller and haplotypecaller, unifiedgenotyper and freebayes decreased slightly with increasing depth, and the differences between variantmetacaller and samtools increased with increasing depth.

the observed varying performance of the methods compared to variantmetacaller is due to many factors:  the relative sensitivity of the individual variant callers to each other ,  the trends of the false discovery rates of the individual variant callers ,  the varying sensitivity loss and precision change caused by hard filtering  and  the goodness of the variant quality estimation of the variant callers.

effects of the aligner
the variant callers generally achieved higher maximum sensitivity when bwa, as opposed to bowtie  <dig>  was used for alignment . consequently, variantmetacaller achieved higher maximum sensitivity and auprc when bwa was used at all read depths for both snps and indels . in case of snps, the mean difference between maximum sensitivity achieved by bwa and bowtie  <dig> alignment across all coverage depths and sample groups was  <dig>  . although the differences seem small,  <dig>  % gain in sensitivity denotes discovering approximately  <dig> additional variants in the current experimental setting. in case of indels, the difference between maximum sensitivity was even larger:  <dig>  . in the current setting,  <dig>  % gain in sensitivity denotes discovering approximately  <dig> additional indels. the overall precision and the auprc scores of variantmetacaller were also higher in case of bwa alignment than bowtie  <dig> alignments for both snps and indels . the auprc differences notably varied with the used aligner in case of snps , but showed very similar patterns in case of indels . for further details of the effects of the aligners, see supplementary results .


results at various sizes of genomic regions
in order to demonstrate the applicability of variantmetacaller on smaller genomic scales, especially in case of target region sizes that are typical in targeted gene panels, we filtered the full length chromosome to smaller non-overlapping regions, where the exonic length added up to approximately  <dig> kb,  <dig> kb,  <dig> kb and  <dig> kb, respectively. we selected ten regions for each size and performed the analyses on each region. the number of variants in the regions is shown in table s <dig> .

the auprc of variantmetacaller was the highest among all methods irrespective of the size of the region, the coverage depth, the aligner and the type of the variants . the difference was strongly statistically significant in case of all genomic sizes, depths and aligners . similarly to the case of full length chromosome, the auprc for snps was higher at the same depth than for indels.

the difference between auprc of variantmetacaller and each variant caller varied mostly with the coverage depth and showed similar patterns across the different sizes of the target regions and the used aligner . in case of snps, freebayes performed generally well, i.e. had the lowest difference of auprc compared to that of variantmetacaller , but in case of indels, haplotypecaller performed consistently better .

when the bwa aligner was used instead of bowtie  <dig>  the auprc of variantmetacaller was statistically significantly higher: the mean difference of auprc across all depths of coverage, sample groups and different regions was  <dig>   and  <dig>   in the case of snps and indels, respectively.

these results demonstrate the validity of variantmetacaller also in case of target regions that are typical in targeted gene panels.

results on real sequencing data
we also evaluated variantmetacaller on real sequencing data, using the publicly available data set of na <dig>  for which a high confident “platinum” quality reference variant call set  <cit>  is also available from illumina, inc.. we aligned the quality filtered sequencing reads with bwa–mem and bowtie  <dig>  filtered the alignments to the whole exome, and performed base quality score recalibration and indel realignment according to the gatk best practices. the mean coverage depth was approximately 12× in case of both alignments. we called snps and indels with the four selected variant callers as before .

the concordance of the unfiltered variant call sets called by the individual methods was modest . the percentage of snps called concordantly by all four variant callers was  <dig>  and  <dig>  % for bwa and bowtie  <dig> alignments, respectively. the percentage of variants that were called by only one variant caller was  <dig>  % for bwa alignments and even higher,  <dig>  % for bowtie  <dig> alignments. the concordance rates were lower for indels: less than the half of all indels were called by all four callers, and the percentage of singly-called variants was  <dig>  %  and  <dig>  % .


we combined the unfiltered variant call sets of the four variant callers by variantmetacaller. again, during the svm training, we used the concordant variants  as positive and the singly-called variants as negative training examples. after fusing the annotation data sets with svms, we estimated the probability of each variant being real . we also combined the individual call sets with baysic  <cit> , which performs a latent class analysis and estimates a posterior probability for each variant. in addition, we performed gatk vqsr for the variants called by haplotypecaller and unifiedgenotyper. vqsr fits a gaussian mixture model to the quantitative annotations given to each variant and estimates a posterior probability to each variant call. in order to be able to use vqsr on the exome of a single sample, we restricted the number of the fitted gaussians to  <dig> according the current recommendations  <cit> . finally, we restricted all variant call sets to the confident region of the platinum reference call set.

we computed the precision and sensitivity for each hard filtered variant call set, for the variant quality score recalibrated variant sets, for baysic and for variantmetacaller. variantmetacaller generally dominated all other methods in the precision–sensitivity space, meaning that variantmetacaller achieved higher precision at most sensitivity levels than any of the other method independently of the aligner and the type of the variants . this is also reflected by the finding that variantmetacaller had the highest auprc . the relative performance of the individual variant callers was similar to that of observed using synthetic data. in case of snps and bwa alignments, the hard-filtered haplotypecaller and unifiedgenotyper had roughly equal auprcs , and higher than that of freebayes and samtools . however, using bowtie  <dig> alignments, samtools performed better than any of the individual variant callers , and unifiedgenotyper proved to be the worst . in case of indels the results qualitatively mirrored those seen for synthetic data , except that the relative performance of unifiedgenotyper and freebayes was reverted. vqsr improved performance relative to hard filtering only in the case of snps and bowtie  <dig> alignments. this result may be related to the scarcity of data relative to the high demands of vqsr.
fig.  <dig> results on real sequencing data. sequence reads originating from a single lane of an illumina hiseq  <dig> run of na <dig> were aligned by bwa and bowtie  <dig> to the human genome and the alignments were filtered to the target region of the whole exome. variants were called by gatk haplotypecaller, gatk unifiedgenotyper, freebayes and samtools and the unfiltered call sets were combined by variantmetacaller and baysic. each variant call sets were hard filtered according to general recommendations and the gatk-based variant calls were also recalibrated by vqsr. all call sets were filtered to the confidently called region of the platinum reference call set. a precision-recall curves for each method for snps  and for indels  in case of bwa  and bowtie  <dig>  alignment. b area under the precision-recall curves for each method for snps  and for indels  in case of bwa  and bowtie  <dig>  alignment. c mean absolute error of estimated versus true precision of the different methods that produce probability estimates of variants. fb = freebayes, hc = haplotypecaller, hf = hard filtered, mae = mean absolute error, st = samtools, ug = unifiedgenotyper, vmc = variantmetacaller, vqsr = variant quality score recalibration



to test our central hypothesis about the advantage of intermediate information fusion, we compared variantmetacaller to the late information fusion method baysic . we found that the difference between the auprc of variantmetacaller and baysic was in the range of 1− <dig> %. this is remarkable, because  <dig> % difference means prioritizing approximately  <dig> snps, and  <dig> indels more accurately. additionally, we also computed the auprc for variantmetacaller and baysic for each chromosome, and found that the auprc for variantmetacaller was higher than that for baysic in most cases regardless of the type of the variant or the aligner and the differences were strongly statistically significant .
p-value b

anumber of chromosomes for which the auprc of variantmetacaller was greater than of baysic


bcomputed with one-tailed, paired wilcoxon test



the other central theme of our work is to provide a flexible solution for quantitative support of variant filtering, similarly to the false discovery rate based paradigm . this can be achieved by the precise estimation of the probability of the variants. specifically, probabilities can be used to order the variants, and for a given threshold, unlike scores, probabilities can be used to estimate precision . precision then can be directly translated to the number of true called variants, or equivalently to the number of false calls, which supports quantitative, application-specific filter adjustment. as variantmetacaller, baysic and vqsr estimate the probability of each variant, we also investigated the differences of the methods with respect to the goodness of this estimation. for this purpose, we calculated the mean absolute error  of the predicted and the real precision for each method. the mae rate was generally low, but it was the lowest in the case of variantmetacaller for snps irrespective of the aligner, and it was the lowest for indels with bowtie  <dig> alignment . in case of indels with bwa alignment, the mae of variantmetacaller was comparable to that of unifiedgenotyper, but the latter had substantially lower sensitivity. in summary, the predicted precision or the predicted false discovery rate can be conveniently used for filtering. furthermore, the predicted probabilities support the optimal selection of variants depending on the preferences and cost functions of the researchers  <cit> .

CONCLUSIONS
in this paper, we compared alternative variant calling pipelines, and in line with other studies , we found low concordance between them, especially in the case of indels. however, we hypothesized that the intermediate annotations generated by individual variant callers are complementary information sources, which can be exploited by their automated fusion. for this task, we presented variantmetacaller, which utilizes the high-dimensional annotation information by fusion from multiple variant callers. as a result, it provides more accurate probabilistic scores for calls compared to earlier solutions, and thereby offers improved quantitative control for variant filtering, based on expected precision. furthermore, the estimated probabilities can be propagated towards downstream analysis and combined with uncertainties from biological, clinical and population levels .

the execution time of variantmetacaller scales quadratically and the memory footprint scales linearly with the number of variants to prioritize and is independent of the number of samples, or the coverage depth . from typical, few hundred kilobase long gene panels up to even a few megabases, the execution time is significantly less than the run time of the variant callers. nevertheless, whole genome sequencing  data would result in an approximately  <dig> times increase in the number of variants compared to whole exomes. the quadratic time complexity of the svm optimization task means that the current implementation cannot cope directly with the wgs dimensionality. subsampling or more advanced optimization methods could be used, which is our plan for future work. however, the program is efficiently parallelized, as speedup scales linearly with the number of processing elements. its scalability allows further computational extensions, such as the wrapping of variantmetacaller into an expectation-maximization framework that iteratively refines the heuristically defined variant status used for training. another extension could be the sequential embedding of variantmetacaller into a monte carlo framework, in which the status of variants is randomly drawn according to the actually predicted probabilities. in this sense, the current work can be seen as a first step towards computationally more demanding applications. finally, the proposed methodology is open for the dynamic adaption, replacement and incorporation of pipelines.

in summary, our study demonstrates the usefulness of intermediate information fusion, by showing that variantmetacaller outperforms individual variant callers and a late information fusion method under a wide range of conditions e.g. for artificially generated or real benchmark data. our study also shows that variantmetacaller provides accurate probabilistic scores for calls even in areas that have been inaccessible for existing solutions, such as in targeted gene panels or organisms without accurate call sets. thus, variantmetacaller broadens the application scope of quantitative, precision-based filtering.

