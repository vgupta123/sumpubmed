BACKGROUND
in genome evolution there are two interacting relationships between nucleotides of dna resulting from two key features: dna nucleotides descend from common ancestral nucleotides, and they are covalently linked to other nucleotides. in this paper we explore the combination of these two relationships in a simple graph model, allowing for change by the process of replication, where a complete sequence of dna is copied, by substitution, in which the chemical characteristics of a nucleotide are changed, and by the coordinated breaking and rematching of covalent adjacencies between nucleotides in rearrangement operations. these processes have quite different dynamics: dna molecules replicate essentially continuously, much more rarely substitutions occur and more rarely still rearrangement operations take place. for this reason, and because of inherent complexity issues, a wealth of models, data structures and algorithms have studied these processes either in isolation or in a more limited combination.

such evolutionary methods generally start with a set of observed sequences in an alignment, an alignment being a partitioning of elements in the sequences into equivalence classes, each of which represents elements that are homologous, i.e. that share a recognisably recent common ancestor. though alignments represent an uncertain inference, and though there optimisation for standard models is intractable for multiple sequences , we make the common assumption that the alignment is given, as efficient heuristics exist to compute reasonable genome alignments .

if the sequences in an alignment only differ from one another by substitutions and rearrangements that delete subsequences, or insert novel subsequences , then the alignment data structure is naturally a 2d matrix. in such a matrix, by convention, the rows represent the sequences and the columns represent the equivalence classes of elements. the sequences are interspersed with “gap” symbols to indicate where elements are missing from a column due to indels. from such a matrix alignment, phylogenetic methods infer a history of replication . such a history is representable as a phylogenetic tree, whose internal nodes represent the most recent common ancestors  of subsets of the input sequences. to create a history including the mrca sequences, additional rows can be added to the matrix . both the problem of imputing maximum parsimony phylogenetic trees from matrix alignments and calculating maximum parsimony mrca sequences given a phylogenetic tree and a matrix alignment are np-hard .

in addition to substitutions and short indels, homologous recombination operations are a common modifier of individual genomes within a population. the alignment of long dna sequences related by these operations is also representable as a matrix. however, the history of replication of such an alignment is no longer generally representable as a single phylogenetic tree, as each column in the matrix may have its own distinct tree. to represent the mrcas of such an alignment requires a more complex data structure, termed an ancestral recombination graph  . it is np-hard under the infinite sites model  to determine the minimum number of homologous recombinations needed to explain the evolutionary history of a given set of sequences, and probably np-hard under more general models .

larger dna sequences, or complete genomes, are often permuted by more complex rearrangements, such that the matrix alignment representation is insufficient. instead, the alignment naturally forms a graph called a breakpoint graph . assuming rearrangements are balanced , inferring parsimonious rearrangement histories between two genomes has polynomial or better time complexity, whether based upon inversions , translocations  or double-cut-and-join  operations . however, for three or more genomes with balanced rearrangements  or when rearrangements are unbalanced  leading to duplications , these exact parsimony methods are intractable. exact solutions in the most general case are therefore only feasible for relatively small problems  before heuristics become necessary .

despite the hardness of the general case, there has been substantial work on computing maximum parsimony results, allowing for a wider repertoire of rearrangements. el-mabrouk studied inversions and indels, though gave no exact algorithm for the general case . recently yancopoulous  then braga  considered the distance between pairs of genomes differing by dcj operations and indels, the latter providing the first linear-time algorithm for balanced rearrangements and indels, and the former proposing a data-structure to model duplications. many methods have been proposed that deal with the combination of rearrangements and duplications, for good recent reviews see , however until recently there were no algorithms to our knowledge that explicitly unified both duplications and genome rearrangements as forms of general unbalanced rearrangement. first  <cit>  provided a model allowing for a subset of duplications and deletions as well as balanced dcj operations, giving a lower bound approximation, while  <cit>  studied a model allowing atomic  duplications, insertions and deletions, but arrived at no closed-form formula for the total number of rearrangements.

the graph model introduced in this paper is capable of representing a general evolutionary history for any combination of replication, substitution and rearrangement operations, including duplications and homologous recombinations. it therefore generalises phylogenetic trees, graphs representing histories with indels, ancestral recombination graphs and breakpoint graphs, building upon the methods described above. we start by introducing this graph and then develop a maximum parsimony problem that, somewhat imperfectly, generalises maximum parsimony variants of all the problems mentioned, facilitating the study of all these subproblems in one unified domain. we adopt the common assumption that all substitutions and rearrangements occur independently of one another, and account for tradeoffs between them by independent rearrangement and substitution costs, which are themselves essentially sums over the numbers of inferred events. importantly, replications that are combined with unbalanced rearrangements are costed by the underlying rearrangement cost. we finally provide a bounded sampling approach to cope with the np-hardness of the general maximum parsimony problem.

RESULTS
sequence graphs and threads
sequence graphs are used extensively in comparative genomics, in rearrangement theory typically under the name  breakpoint graph  and in alignment under the name a-bruijn  or adjacency graph . we use the following bidirected form, which is similar to that used by  <cit>  for sequence assembly.

a  sequence graphg= is a graph in which a set v
g
 of vertices are connected by a set e
g
 of bidirected edges , termed adjacencies. a vertex represents a subsequence of dna termed a segment. a vertex x is oriented, having a tail side and a head side, respectively denoted x
h
e
a
d
 and x
t
a
i
l
. these categories {head,tail} are called orientations. an adjacency, which represents the covalent bond between adjacent nucleotides of dna, is a pair set of sides. we refer to the two sides contained in an adjacency as its endpoints. adjacencies are bidirected, in that each endpoint is not just a vertex, but a vertex with an independent orientation . for convenience, we say a side is attached if it is contained in an adjacency, else it is unattached. by extension, we say a vertex is attached if either of its sides are attached, else it is unattached.

associated with a sequence graph is a labeling, i.e. a function l:v
g
→Σ∗∪{∅} where Σ={a/t,c/g,g/c,t/a} is the alphabet of bases, which are oriented, paired nucleotides of dna, and Σ∗ is the set of all possible labels consisting of finite sequences of bases in Σ. bases and labels are directed. for ρ/τ∈Σ, ρ is the forward complement and τ is the reverse complement. if a vertex is traversed from its tail to its head side, its label is read as the sequence of its forward complements. conversely, if traversed from head to tail, the label is read as the reverse sequence of the reverse complements. a vertex x∈v
g
 for which l=∅ is unlabeled. a label represents a multibase allele. a path through the sequence therefore represents a single dna sequence  whose bases are encoded by the labels of the vertices, where unlabeled vertices represent missing information.

a thread is a connected component in a sequence graph in which each side is connected to at most one adjacency. a thread graph is a sequence graph in which every connected component is a thread. in this paper we limit ourselves to investigating thread graphs. a thread may be a simple cycle, representing a circular dna molecule, or have two unattached sides, in which case it represents a linear dna molecule or fragment of a larger dna molecule. an example thread graph is shown in figure  <dig>  a thread graph is phased, in that each thread is assigned a maximal dna sequence , and any path though that thread corresponds to a subsequence of these maximal sequences. in contrast, a sequence graph that is not a thread graph may be unphased, in that there exist many possible maximal sequences for each of its connected components.

history graphs
nucleotides of dna derive from one another by a process of replication. this replication process is represented in history graphs, which add ancestry relationships to thread graphs.

a history graphg= is a thread graph with an additional set b
g
 of directed edges between vertices, termed branches. each vertex is incident with at most one incoming branch. the event graphd is the directed graph formed by the contractiona of adjacencies in e
g
. for g to be a history graph d must be a directed acyclic graph , a property we term acyclicity. example history graphs are shown in figure  <dig>  along with an event graph in figure  <dig> for the history graph shown in figure  <dig> 

to avoid confusion we define terminology to discuss branch relationships. each weakly connected component of branches forms a branch-tree. two vertices are homologous if they are in the same branch-tree. a vertex y is a descendant of a vertex x, and conversely y is an ancestor of x, if y is reachable by a directed path of branches from x. if two homologous vertices do not have an ancestor/descendant relationship then they are indirectly related. for a branch e=, x is the parent of e and y, and y is the child of e and a child of x. similarly, e is the parent branch of y and a child branch of x. a vertex is a leaf if it has no incident outgoing branches, a root if it has no incident incoming branches, else it is internal. we reuse the terminology of parent, child, homologous, ancestor, descendant and indirectly related with sides. two sides have a given relationship if their vertices have the relationship and they have the same orientation. similarly, a side is a leaf  if its vertex is a leaf .

simple histories
we formally define a class of history graphs, called simple histories, for which parsimonious sequences of substitutions and rearrangements can be trivially derived.

a bilayered history graph is a history graph whose threads can be partitioned into root and leaf layers, such that every branch connects a vertex in the root layer with a vertex in the leaf layer. a rearrangement epoch is a bilayered history graph in which every branch tree is a root with  <dig> child, every vertex is labeled, and any set of homologous sides are either all attached or all unattached. for n≥ <dig>  an n-way replication epoch is a bilayered history graph in which every branch tree is a root with n children, every vertex is labeled, any set of homologous sides are either all attached or all unattached, if two root sides x
α
 and y
β
 are attached by an adjacency then each child of x
α
 is attached to a child of y
β
, and a root vertex has at most one child with a label different from its own. an epoch is either a rearrangement epoch or an n-way replication epoch for some n≥ <dig>  a layered history graph is a history graph that can be edge partitioned into a finite sequence of bilayered history graphs, such that the leaf layer of a contained bilayered history graph is the root layer of the following bilayered history graph. a simple history is a layered history graph whose bilayered subgraphs are all epochs. an example simple history with epoch subgraphs is shown in figure  <dig> 

a substitution occurs on a branch if the labels of its endpoints are not identical. note that a substitution can occur either in a rearrangement or a replication epoch. the substitution cost of a simple history h is the total number of substitutions, denoted s. the example simple history in figure  <dig> has substitution cost  <dig>  note the requirement that all homologous sides in a simple history be either all attached or all unattached does not forbid rearrangements involving the observed ends of chromosomes , because it is always possible to add material to a simple history at zero cost that attaches such unattached sides and allows them to participate in rearrangements.

the substitution cost defined deals, abstractly, with changes of alleles in which any change between alleles is scored equally. however for the case Σ∗=Σ, i.e. single base labels, the substitution cost is the minimum number of single base changes. furthermore, any history graph in which all homologous labels have the same length can easily be converted to a semantically equivalent history graph for which Σ∗=Σ. more complex substitution costs to deal with the case where the alphabet represents the alleles of genes, as is commonly dealt with in rearrangement theory, are straightforward but not pursued here for simplicity.

a rearrangement cycle in a rearrangement epoch is a circular path consisting of one or more repetitions of the basic pattern consisting of an adjacency edge in the root layer, a forward branch to the leaf layer, an adjacency edge in the leaf layer and a reverse branch to the root layer. its size is the number of repetitions in it of this basic pattern minus  <dig>  a linear path that follows this same basic pattern but does not complete every pattern and return to the original vertex is a degenerate rearrangement cycle. its size is the size of the smallest rearrangement cycle that can be obtained from it by adding edges. the rearrangement cost of a simple history h is the total size of all rearrangement cycles in it, denoted r. this cost is known to be the number of double-cut-and-join  operations needed to achieve all the rearrangements.

lemma  <dig> 
the rearrangement cost of an epoch is the minimum number of double-cut-and-join  operations required to convert the root layer’s adjacencies into the leaf layer’s adjacencies.

proof.
similar to that given in  <cit> .

the example simple history in figure  <dig> has rearrangement cost  <dig> 

because different studies lay different emphases on substitution or rearrangement  and because the events do not have the same probability in practice, we allow for a degree of freedom in the definition of the overall cost function. a  cost function for a simple history is any monotone function on the substitution and rearrangement costs in which both substitutions and rearrangements have non-zero cost.

reduction
not all history graphs are as detailed as simple histories. we define below a partial order relationship that describes how one graph can be a generalization of another graph, so for example, a less detailed history graph can be used to subsume multiple simple histories.

a branch whose child is unlabeled and unattached is referred to as having a free-child. a branch whose parent is unlabeled, unattached and a root with a single child is referred to as having a free-parent. a vertex is isolated if it has no incident adjacencies or branches.

a reduction operation is an operation upon a history graph that either: 

● deletes an adjacency, an isolated vertex or the label of a vertex.

● contracts a branch with a free-child or free-parent.

see figure  <dig> for examples. the inverse of a reduction operation is an extension operation.

lemma  <dig> 
the result of a reduction operation is itself a history graph.

a history graph g is a reduction of another history graph g′ if g is isomorphic to a graph that can be obtained from g′ by a sequence of reduction operations, termed a reduction sequence.

lemma  <dig> 
the reduction relation is a partial order.

we write g⋞g′ to indicate that g is a reduction of g′ and g≺g′ to indicate that g is a reduction of g′ not equal to g′. like reduction and extension operations, if g is a reduction of g′, g′ is an extension of g. an examination of the reduction relation is in the discussion section.

history graph cost
using the parsimony principle, we now extend parsimony cost functions, previously defined on simple histories, to all history graphs.

a simple history h that is an extension of a history graph g is called a realisation of g. the set ℋ is the realisations of g.

for a given cost function c the cost of a history graph g isb

 c=minh∈ℋc,r). 

lemma  <dig> 
the problem of finding the cost of a history graph is np-hard.

proof.
there are parsimony problems on either substitutions or rearrangements alone that are np-hard and can be formulated as special cases of the problem of finding the minimum cost realisation of a history graph .

the lifted graph
although determining the cost of a history graph is np-hard, we will show that the cost can be bounded such that the bounds become tight for a broad, characteristic subset of history graphs. to do this we introduce the concept of lifted labels and adjacencies, which are used to project information about labels and adjacencies from descendant to ancestral vertices and are useful in reasoning about the cost of a history graph.

the free-roots of a history graph g are a set of additional vertices such that a single, unique free-root is assigned to each root vertex in g ). for a vertex x, its lifting ancestora is the most recent labeled ancestor of x, else if no such vertex exists, the free-root of the branch-tree containing x. for a side x
α
 its lifting ancestor  a is its most recent attached ancestor, else if no attached ancestor exists, its ancestral side in the free root of the branch tree containing it.

for a labeled vertex y, a lifted label is a label identical to l on its lifting ancestor. for a vertex the lifted labels is therefore a multiset, because the same lifted label may be lifted to a lifting ancestor from multiple distinct descendants and each is considered an element of the multiset.

for an adjacency {x
α
,y
β
}, a lifted adjacency is a bidirected edge {a,a}. in analogy with the lifted labels for a vertex, the lifted adjacencies for a side is the multiset of lifted adjacencies incident with the side.

a history graph g with free-roots, lifted labels and lifted adjacencies is a lifted graphl. figure  <dig> shows an example lifted graph that outlines these concepts.

some lifted elements do not imply change between descendant and ancestral states, while others do. to formalise such a notion we define trivial and non-trivial labels and and adjacencies. a lifted label ρ of a labeled vertex x is trivial if l=ρ. a lifted label ρ on an unlabeled vertex x  is trivial if it is the only lifted label on x. otherwise a lifted label is non-trivial.

a junction side is a most recent common ancestor  of two attached, indirectly related sides. for a history graph g, a lifted adjacency e={a,a} is trivial if there exists no unattached junction side on the path of branches from  a to  x
α
, or on the path of branches from  a to  y
β
 and either there is a  adjacency between a and a in g or a and a are free roots, else e is non-trivial. see figure  <dig> for examples of trivial and non-trivial labels and adjacencies.

ancestral variation graphs
we can now define a broad class of history graphs for which cost can be computed in polynomial time. to do this we will define ambiguity, information that is needed to allow the tractable assessment of cost. there are two types of ambiguity. the substitution ambiguity of a history graph g, denoted u
s
, is the total number of non-trivial lifted labels in excess of one per vertex. substitution ambiguity reflects uncertainty about mrca bases. the substitution ambiguity of the history graph in figure  <dig> is  <dig>  as there exists one vertex with two non-trivial lifted labels.

the rearrangement ambiguity of a history graph g, denoted u
r
, is the total number of non-trivial lifted adjacency incidences in excess of one per side.rearrangement ambiguity reflects uncertainty about mrca adjacencies. the rearrangement ambiguity of the history graph in figure  <dig> is  <dig>  because two sides have three incident non-trivial lifted edges and one side has two incident non-trivial lifted edges.

the ambiguity of a history graph g is u=u
s
+u
r
. an ancestral variation graph  h is a history graph such that u= <dig>  i.e. an unambiguous history graph.

lemma  <dig> 
simple histories are avgs.

while simple histories are avgs, so are many other history graphs that are far less detailed. for example, the avg in figure  <dig> is not a simple history.

bounds on cost
we provide trivially computable lower and upper bound cost functions for history graphs that are tight for avgs.

the lower bound substitution cost  of a history graph g, denoted s
l
, is the total number of distinct  nontrivial lifted labels at all vertices minus the number of unlabeled vertices with non-trivial lifted labels . the lbsc of the history graph in figure  <dig> is  <dig> 

the upper bound substitution cost  of a history graph g, denoted s
u
, is the total number of nontrivial lifted labels at all vertices minus the maximum number of identical lifted labels at each unlabeled vertex with non-trivial lifted labels . the ubsc of the history graph in figure  <dig> is  <dig>  for the avg in figure  <dig>  lbsc = ubsc =  <dig> 

the module graph of a history graph g is a multi-graph in which the vertices are the sides of vertices in l that have incident real or lifted adjacencies and the edges are the real and lifted adjacencies in l incident with these sides. each connected component in a module graph is called a module. the set of modules in the module graph for g is denoted m. figure  <dig> shows the modules for figure  <dig> 

the lower bound rearrangement cost  for a history graph g is: 

 rl=∑m∈m. 

for a history graph that is a simple history this definition is equivalent to the earlier definition of rearrangement cost for simple histories.

the upper bound rearrangement cost  of a history graph g, denoted r
u
, is the total number of non-trivial lifted adjacencies in l minus the number of modules in m in which every side has exactly one incident non-trivial lifted edge. the lbrc of the history graph in figure  <dig> is  <dig> and its ubrc is  <dig>  for the avg in figure  <dig> lbrc = ubrc =  <dig> 

theorem  <dig> 
for any history graph g and any cost function c, c,r
l
)≤c≤c,r
u
) with equality if g is an avg.

the proof is in given the methods section.

theorem  <dig> demonstrates that lbsc and lbrc are lower bounds on cost, ubsc and ucrc are upper bounds on cost, and that all these bounds become tight at the point of zero ambiguity. this implies that to assess cost of an arbitrary history graph g we need only search for extensions of g to the point that they have zero ambiguity and not the complete set of simple history realisations of g. for an avg h, as the lower and upper bounds on cost are equivalent, we write r=r
l
=r
u
 and s=s
l
=s
u
.

g-optimal avgs
we now explore the process of sampling avg extensions of an initial starting graph. though it is possible to start from any history graph, in practice we are likely to start from a history graph g based on sequence alignments, such as that shown in figure  <dig>  if g is already an avg, by theorem  <dig>  it is trivial to assess its cost. if not we sample avg extensions of g in order to assess cost and explore the set of most parsimonious realisations of g. with the aim of restricting this search, ultimately to a finite space, we first define the set of g-optimal avgs.

an avg extension h of a history graph g is g-parsimonious w.r.t. a cost function c if c=c,r). the set of g-parsimonious avgs is necessarily infinite: it is always possible to add arbitrary vertices without affecting substitution or rearrangement costs. to avoid the redundant sampling of avg extensions of g and their own extensions we define the notion of minimality.

an avg extension h of g is g-minimal if there is no other avg h′ such that g≺h′≺h. the set of g-minimal avgs contains those avgs that can not be reduced without either ceasing to be avgs or extensions of g. this set is also infinite for some dna history graphs .

an avg is g-optimal w.r.t. a cost function c if it is both g-parsimonious w.r.t. to c and g-minimal. we establish below that the set of g-optimal avgs is finite for any history graph g. by definition, any g-parsimonious avg is either g-minimal or has a g-minimal reduction therefore we can implicitly represent and explore the set of parsimonious realisations of g by sampling just the g-optimal avgs.

g-bounded history graphs
unfortunately, because the history graph cost problem is np-hard, it is unlikely that there exists an efficient way to sample only g-optimal. instead, we now define a finite bounding set that contains g-optimal and can be efficiently searched. conveniently this bounding set is the same for all cost functions.

a label of a vertex x is a junction  if x has more than one lifted label, else it is a bridge if x has one lifted label, its lifted label is non-trivial, the most recent labeled ancestor of x is labeled the same as x and this ancestor has at least one non-trivial lifted label ).

a side x
α
 is a bridge side if it is not a junction, is incident with one non-trivial lifted adjacency and an adjacency e that defines a trivial lifted adjacency e′ whose a endpoint is a junction side incident with a non-trivial lifted adjacency, and such that if e is deleted at least one endpoint of e′ in the original graph remains a junction side in the resulting graph ). an adjacency is a junction  if either of its endpoints are junctions, else it is a bridge  if either of its endpoints are bridge sides.

an element is non-minimal if it is a branch with a free-child or free-parent, an isolated vertex, or label or adjacency that is not a junction or bridge.

for g⋞g′, an element in g′ is g-reducible if there exists a reduction operation in a reduction sequence from g′ to g that either deletes the element if it is an adjacency, label or vertex or contracts it if it is a branch. we are interested in the set of g-reducible elements of an extension of g, as they are the elements which may be added and removed during an iterative sampling procedure.

for g⋞g′, the g-unbridged graph of g′ is the reduction resulting from the deletion of all g-reducible bridge adjacencies in g′. a side x
α
 that has no attached descendants is a hanging side. a pair of adjacencies e and e′, each with a hanging side, and such that e has an endpoint whose most recent attached ancestor is incident with e′, form a pair of ping-pong adjacencies. we call e the ping adjacency and e′ the pong adjacency ).

a history graph g′ is g-bounded if it is an extension of g that does not contain a g-reducible non-minimal element and its g-unbridged graph does not contain a g-reducible ping adjacency.

theorem  <dig> 
the set of g-bounded avgs contains the g-optimal avgs for every cost function.

the proof is given in the methods section.

importantly, the following theorem demonstrates that there is a constant k such that any g-bounded history graph is at most k times the cardinality of g.

theorem  <dig> 
a g-bounded history graph contains less than or equal to maxg-reducible adjacencies and max additional vertices, where n is the number of adjacencies in g and m is the number of labeled vertices in g. this bound is tight for all values of n and m.

the proof is given in the methods section.

the set of g-bounded history graphs and, by inclusion, the set of g-optimal avgs are therefore finite.

the g-bounded poset
finally we demonstrate how to navigate between g-bounded history graphs using a characteristic set of operations that define a hierarchy between these graphs.

for a vertex x in a g-bounded history graph the composite minimisation of x is as follows: 

● if x is unattached and unlabeled and has a g-reducible parent branch, the contraction of the parent branch, renaming the resulting merged vertex x.

● if x is then an unattached, unlabeled root and has a single g-reducible child branch, the contraction of the child branch, renaming the resulting merged vertex x.

● the deletion of x if subsequently isolated, unlabeled and g-reducible.

a g-bounded reduction operation on a g-bounded history graph is one of the following operations, provided it results in a g-bounded history graph. 

● a label detachment: the deletion of a g-reducible label on a vertex x, followed by the composite minimisation of x ).

● an adjacency detachment: the deletion of a g-reducible adjacency {x
α
,y
β
} followed by the composite minimisation of x and y ). the inverse of an adjacency detachment is an adjacency attachment.

● a lateral-adjacency detachment: the adjacency detachment of a pair of g-reducible junction adjacencies {x
α
,y
β
} and {a,a}, and a subsequent adjacency attachment that creates an adjacency that includes x
α
 or y
β
 as an endpoint ).

note that the first two g-bounded reduction operations are combinations of reduction operations, while the lateral-adjacency detachment, which proves necessary to avoid creating intermediate graphs with g-reducible ping-pong edges, involves both reduction and extension operations, but always reduces the total number of adjacencies. as with reduction operations, the inverse of a g-bounded reduction operation is a g-bounded extension operation. a g-bounded history graph g′ is a g-bounded reduction  of another g-bounded history graph g′′ if g′ is isomorphic to a graph that can be obtained from g′′ by a sequence of g-bounded reduction  operations.

lemma  <dig> 
the g-bounded reduction relation is a partial order.

the g-bounded poset is the set of g-bounded history graphs with the g-bounded reduction relation. we write ≺
g
 to denote the g-bounded reduction relation and ≺·
g
 to denote its covering relation .

theorem  <dig> 
the g-bounded poset is finite, has a single least element g, and its maximal elements are all avgs. also, g′≺·
g
g′′ iff there exists a single g-bounded reduction operation that transforms g′′ into g′.

the proof is given in the methods section.

as the g-bounded poset is finite, it can be represented by a hasse diagram whose nodes are the g-bounded history graphs and whose edges, which are the covering relation, represent equivalence classes of g-bounded operations. figure  <dig> shows a simple g-bounded poset hasse diagram.

a basic implementation
the previous four theorems establish the mechanics of everything we need to sample the finite set of g-optimal avgs, and thus, amongst other things, determine the cost of a history graph. although it will require further work to establish practical and efficient sampling algorithms, we have implemented a simple graph library in python that for an input history graph g iteratively generates g-bounded avgs  through sequences of g-bounded extension operations.

to test the library we used simulations. for each simulation we generated a simple history h by forward simulation, starting from a genome with  <dig> vertices in a single thread and simulating  <dig> epochs in which either whole chromosome replication or rearrangements occurred and substitutions were made at a constant rate at each branch. the labels in the simulation correspond to single dna bases. to ensure complexity, we selected histories with substitutions, rearrangements and at least two epochs of replication. we created a reduction g of h by removing from h all labels of internal vertices and adjacencies incident on internal vertices and finally contracting the parent branch of all internal vertices. as a result, the reduced history contained only the leaf threads and branch trees that, containing no internal vertices, simply indicate the homologies between the vertices. to simulate incomplete genome assemblies, we randomly removed, on average, 10% of the adjacencies, labels and vertices from these leaf threads. to test our library we enumerated sequences of g-bounded history graphs starting at g, at each step picking at random a possible g-bounded extension operation until we reached an avg. we sampled  <dig>  starts for each of  <dig> randomly sampled pairs of history and starting graph. to make the search strategy efficient, we restarted the search if we reached an extension with a higher total sum of lower bound substitution and rearrangement costs than s
u
+r
u
, initially, and then subsequently the sum of the substitution and rearrangement costs of the best avg found up to that point. tables  <dig> and  <dig> show the results of these  <dig> sampling runs. figure  <dig> shows one example of h, g and a sampled avg.

s
u


s

s


l

s


u

s
s
each row represents a separate initial history. the cost s is the substitution cost of the simple history from which g is derived. also given are the ambiguity u
s
, lower s
l
, and upper s
u
 substitution cost bounds for g. the minimum and maximum substitution costs of g-bounded avg extensions found by sampling are denoted s and s, resp.

r
u


r

r


l

r


u

r
r
each row represents a separate initial history. the cost r is the rearrangement cost of the simple history from which g is derived. also given are the ambiguity u
r
, lower r
l
, and upper r
u
 rearrangement cost bounds for g. the minimum and maximum rearrangement costs of g-bounded avg extensions found by sampling are denoted r and r, resp.

for these simulations the minimum rearrangement cost of any sampled avg is often close or equal to r
l
, while the maximum rearrangement cost of any sampled avg is generally slightly greater than r
u
. notably, we found that avg extensions sometimes had lower cost than the original simple history, this occurring because of the information loss that resulted from reducing h to g.

repeating these experiments with histories that started with  <dig> root vertices in the simple history, but which were otherwise simulated identically, demonstrates that the naive random search procedure implemented here fails to find reasonable histories within a set of only  <dig>  random samples , so, as might be expected, more intelligent sampling strategies will be needed to find parsimonious interpretations of even moderately complex datasets. however, with more efficient sampling algorithms, a history graph sampling algorithm could be applied to find solutions to various established parsimony problems, such as the dcj median problem, or be used for less explored problems, such as the inference of gene trees incorporating synteny information.

discussion
we have introduced a general model for genome evolution under parsimony, but the reduction relation and the definition of the g-bounded set may appear arbitrary. we highlight below the reasons for our choice of reduction relation, how reduction relates to other orderings over graphs, and how we can easily approximate a set of g-reducible elements, something critical to the sampling of g-bounded extensions of a given graph. we then briefly discuss the possibilities of yet more compact graphical representations.in the reduction relation, we allow the deletion of vertices, vertex labels and adjacencies, but forbid branch deletion. otherwise, extensions would allow the invention of homology between vertices ). conversely, branches can be contracted but not adjacencies, otherwise extensions could create interstitial vertices without any rearrangement ).we disallow the non-trivial contraction of the incoming branch of attached or labeled vertices, with the one exception for branches with free-parents, because it would allow a reduction to merge previously separate threads ), and because vertices could be reduced to become ancestors of originally indirectly related vertices ). we allow the one exception for the contraction of the incoming branch of attached or labeled vertices when the branch has a free-parent because disallowing it would forbid reductions that removed information from root vertices ) and allowing it does not permit the issues highlighted in figures  <dig> it is informative to consider the relationship between reduction operations and the reduction relation. when a graph contains multiple copies of isomorphic structures, distinct reduction operations can result in isomorphic reductions ), therefore each possible reduction in the covering set  of the reduction relation represents an equivalence class of reduction operations.

a valid permutation of a reduction sequence is a permutation in which all operations remain reduction operations when performed in sequence. clearly not all permutations of a reduction sequence have this property, however the following lemma illustrates the relationship between valid permutations.

lemma  <dig> 
all valid permutations of a reduction sequence create isomorphic reductions.

reduction is somewhat analogous to a restricted form of the graph minor. importantly, the graph minor is a well-quasi-ordering  , i.e. in any infinite set of graphs there exists a pair such that one is the minor of the other.

lemma  <dig> 
reduction is not a wqo.

proof.
consider the infinite set of cyclic threads, they are not reductions of one another.

an ordering is a wqo if every set has a finite subset of minimal elements. in contrast, it can be shown that for the reduction relation, even the set of avg extensions of a single base history g can have an infinite set of minimal elements.

lemma  <dig> 
there exists a history graph g with an infinite number of g-minimal extensions.

the proof is given in the methods section.

one barrier to exploring the g-bounded poset is deciding for a pair of history graphs g and g′ such that g⋞g′ if an element is g-reducible. this problem is of unknown complexity, and may well be np-hard. to avoid the potential complexity of this problem we can define an alternative notion of reducibility. a fix for , where g⋞g′, is a history subgraph of  isomorphic to g, where bg′+ is the transitive closure of bg′. starting from an input history graph g and a fix isomorphic to it, we can easily update the fix as we create extensions of g. for an extension of g, elements in the fix become the equivalent of g-irreducible, while elements not in the fix become the equivalent of g-reducible. from a starting graph we can therefore explore a completely analogous version of g-bounded, replacing the question of g-reducibilty with membership of the fix.

following from lemma  <dig>  there is a bijection between the set of fixes for g⋞g′ and the set of equivalence classes of reduction sequences that are all valid permutations of each other. this is the limitation of considering membership of a fix instead of assessing if an element is g-reducible, it limits us to considering only a single equivalence class of reduction sequences in exploring the analogous poset to g-bounded.

it is in general possible to reduce the size of the set g-bounded while still maintaining the properties that it can be efficiently sampled and contains g-optimal. however, this is likely to be at the expense of making the definition of g-bounded more complex. one approach is to add further “forbidden configurations” to the definition of g-bounded, like the g-reducible ping adjacencies that are forbidden in the current definition of g-bounded. forbidding these was essential to making g-bounded finite, but we might consider also forbidding other configurations just to make g-bounded smaller.

it is possible to consider a graph representation of histories that use fewer vertex nodes if we are willing to allow for the possibility that a subrange of the sequence of a vertex be ancestral to a subrange of the sequence of another vertex. this is a common approach in ancestral recombination graphs . such a representation entails the additional complexity of needing to specify the sequence subranges for every branch, but may in some applications be a worthwhile trade off for reducing the number of vertices in the graph. the theory of such graphs is mathematically equivalent to the theory of the history graphs presented here, but the implementation would differ.

CONCLUSIONS
we have introduced a graph model in which a set of chromosomes evolves via the processes of whole chromosome replication, gain and loss, substitution and dcj rearrangements. we have demonstrated upper and lower bounds on maximum parsimony cost that are trivial to compute despite the intractability of the underlying problem. though these cost bounding functions are relatively crude and can almost certainly be tightened for many cases, they become tight for avgs. this implies that we only need to reach avg extensions to assess cost when sampling extensions.

to our knowledge, this is the first fully general model of chromosome evolution by substitution, replication, and rearrangement. however, it has its limitations. for example, it treats common rearrangements, such as recombinations and indels as any other rearrangement, and only takes into account maximum parsimony evolutionary histories. we anticipate future extensions that incorporate more nuanced cost functions, as well as probabilistic models over all possible histories.

the constructive definition of the g-bounded poset, coupled with the upper and lower bound functions, suggests simple branch and bound based sampling algorithms for exploring low-cost genome histories. to facilitate the practical exploration of the space of optimal and near optimal genome histories, we expect that more advanced sampling strategies across the g-bounded poset could be devised.

