BACKGROUND
high-throughput dna sequencing technologies  have promoted the production of short reads with dramatically low unit cost. the explosive growth of short read datasets poses a challenge to the mapping quality and the execution speed. the main task of short read mapping is to align the reads to a given reference genome. however, mapping this large volume of data is a challenge for existing sequence alignment tools. the smith-waterman algorithm
 <cit>  is able to provide an accurate alignment result, but is too slow for the large volumes of data generated by current sequencers. therefore, existing software tools often use a restrictive error model for computing the alignments to improve speed, whereas more flexible error models are generally too slow for large-scale applications. as the read length continues to increase and more errors are permitted in the final alignment, many current aligners are becoming less efficient. our goal in this paper is to design, implement, and evaluate a new short read alignment  method with both high sensitivity and high throughput. to achieve these goals, our approach is based on implementing a sensitive alignment method following the “seed and extend” approach on an fpga. both high sensitivity  and decreased computational processing time are significant advances to research in the area of next-generation-sequencing .

“seed and extend” is a frequently used heuristic in short read mapping implementations. the basic idea is simple: since only a limited number of errors are allowed for a significant alignmenta long exact match regions exist. thus, discovering these exact matches  before the alignment process can largely reduce the search space. detection of these seeds is usually performed using two approaches:  indexing of the input read dataset and scanning through the reference genome,  indexing of the reference genome and aligning each read independently.

there are several alignment tools based on the first approach . maq
 <cit>  performs an ungapped alignment that takes into account quality scores for each base. zoom
 <cit>  uses “spaced-seeds” in order to improve sensitivity. shrimp
 <cit>  combines the spaced seeds and the smith-waterman algorithm to align reads with even higher sensitivity. soap, wham, bfast, and gassst apply the second approach to conduct the alignment computation. soap
 <cit>  uses seeds  and a hash lookup table algorithm to accelerate the alignment and is efficient to process alignments with a small number of gaps and mismatches. wham
 <cit>  uses a hash-based index method to quickly find potential hits and then applies bitwise operations to perform string matching. bfast
 <cit>  uses multiple indices of the reference genome to increase sensitivity. gassst
 <cit>  applies a series of filters of increasing complexity to quickly eliminate candidate hits with too many alignment errors. a drawback of these indexing methods is that the memory footprint is very large, particularly when the size of the reference genome or the reads approaches several billion. a third approach, based on the burrows-wheeler transform 
 <cit> , addresses this problem by applying an occurrence table and a suffix array to store the reference genome in a space-efficient way. bowtie
 <cit>  employs a burrows-wheeler index which greatly reduces the memory consumption. bowtie is one of the fastest alignment tools for short read alignment, but does not allow for indel  errors. bwa
 <cit>  is slightly slower than bowtie, but allows indels in the alignment. soap2
 <cit>  uses a bidirectional bwt to build the index of the reference genome and achieves a comparable alignment speed to that of bowtie. the bwt-based methods use a backward search
 <cit>  to quickly locate exact matches. however, its search space increases dramatically if more errors are allowed. therefore, this approach is generally efficient for low error rates.

as discussed above, short read mapping, particularly for very large datasets, is computationally challenging. hybrid computing platforms offer the potential to improve algorithm performance, particularly algorithm runtime. already, we have seen the development of hybrid short read alignment tools using the parallel computing capabilities of gpus. saruman
 <cit>  uses a nvidia graphics card to accelerate the time-consuming alignment step. soap3
 <cit>  and cushaw
 <cit>  achieve performance improvements by parallelizing the bwt-approach on gpus.
 <cit>  proposed a hybrid system combining both cpu and gpu to accelerate the phylogeny-aware alignment kernel.

fpgas are also suitable candidate platforms for this application, due to their fine-grained pipelining and massive parallelism. however, short read mapping tools on fpga are less common due to the design efforts required. alachiotis et al.
 <cit>  proposed a fpga-based short read alignment accelerator for the phylogenetic tree search, which is based on the papara
 <cit>  algorithm. knodel et al.
 <cit>  developed a massively parallel structure to conduct the straightforward search for short reads in a reference database. however, gaps are not allowed in the design and as such it limits this design’s application scope. fernandez et al.
 <cit>  designed a short read aligner based on bwt indexing. however, as it stores the table contents utilizing on-chip memory resources, the supported reference genome size is quite limited. tang et al.
 <cit>  presented a heterogeneous short read aligner based on the algorithm used in perm
 <cit> . for its current version, the maximum working clock frequency is 175 mhz and gaps are not allowed. olson et al.
 <cit>  designed another fpga aligner based on the bfast algorithm. the index data structure and candidate alignment locations  finder design improve the search efficiency. the final system achieves two orders of magnitude speedup against bfast and an order of magnitude speedup against bowtie with the help of  <dig> virtex- <dig> fpgas, × <dig> pcie buses, and ddr <dig> memory interfaces. generally, it is very difficult to make a meaningful direct comparison between two different fpga designs. the performance of an fpga design is influenced by many factors, including the fpga architecture and the original algorithm that was implemented. unlike above designs, our fpga aligner design is inspired by the concept of pre-filtering. in this paper, we present a hybrid short read aligner built on one virtex <dig> fpga chip with a similar structure to that of gassst, but with faster processing speed.

methods
runtime profiling
our hybrid aligner design follows the “seed and extend” strategy and indexes the reference genome. the “seed” stage identifies candidate regions with a high degree of similarity between the reference genome and each read sequence. the hash table lookup is a conventional method to quickly eliminate irrelevant regions. it can be easily implemented on the fpgas due to its simple structure. the extension stage extends the seed in both directions. if indels are supported, the dp-based needleman-wunsch  algorithm
 <cit>  can be applied. the nw algorithm provides a high degree of accuracy, but is also computationally expensive due to its quadratic search space. based on our experience, the number of indels allowed is much less than that of substitutions for short read alignment. this provides us the opportunity to use another dp-based algorithm with a much smaller search space, the banded nw algorithm. to evaluate the performance bottleneck of the sequential nw-based short read mapping, we record the runtime of the three different stages, i.e. indexing, seed generation, and seed extension with the nw algorithm on a conventional cpu using a single thread. in this test, we use one million simulated reads of length  <dig> base-pairs  each from the e. coli genome and a 4% error rate. the results in table 
 <dig> show that the extension stage is the most time-consuming part. furthermore, the seed generation stage also occupies over 13% of the overall runtime. the extension stage is quite suitable for fpga implementation, as it has a regular systolic architecture. the seed generation stage mainly consists of random memory accesses to a large lookup table. in our earlier version of the hybrid aligner design
 <cit> , we mapped the seed generation stage into software. the general purpose cpu pre-caches part of the data from the main memory to accelerate consecutive memory accesses. unfortunately, the performance deteriorates significantly for random memory accesses. our earlier experiments showed that this type of partitioning is unable to generate enough  pairs for the extension stage on the fpga. thus, we have decided to construct a seed engine module to implement the seed generation operations on the fpga to achieve better performance.

parallel banded nw search
for two given letters x and y  over the nucleotide alphabet ∑ = {a, c, g, t}, we use the following scoring scheme:  <dig> for a match , and  <dig> for a mismatch . furthermore, the penalty for each indel error is also set to  <dig>  the computation of the dp alignment matrix between a read sequence  and a substring of the reference genome  is given in equation  for 1 ≤ i ≤ m and 1 ≤ i ≤ n.

  si,j=min{si− <dig> j+1si− <dig> j−1+δsi,j−1+ <dig> 

where δ =  <dig> if ref  = read ; otherwise, δ =  <dig>  the dp matrix initializations are given by s  = i and s  = j for 0 ≤ i ≤ m and 0 ≤ j ≤ n. the optimal global alignment score with respect to the given scoring scheme is then the value s. in fact, short read mapping can be considered as a semi-global alignment, where only the query read needs to be globally aligned. thus, the optimal score is given by the minimal value in the last column of s, i.e. min{s∣i∈{ <dig> …,m}} and the gaps in the first column are omitted.

the search space for the conventional global alignment is of size m × n. the banded nw algorithm limits the search process around the main diagonal with a band width of d, which largely reduces the search space. however, the alignment score is still computed sequentially. figure 
 <dig> shows a typical case for a banded semi-global alignment with a band width of one.

to further utilize the parallelism inherent in fpgas, we have modified the banded nw search to a fine-grained parallel version. instead of computing the alignment score directly as in equation , we first take only substitution errors between bases into account. the highlighted bases in figure 
 <dig> indicate the best alignment between two sequences. as a good alignment permits only a limited number of errors, the optimal alignment score is usually related to the path with fewer 1’s, which gives an insight as to how to conduct the alignment in parallel. as the paired match information is independent of each other, we can divide the search space into multiple blocks and compute the alignment score for each block in parallel. as the best alignment in the block is not always part of the final alignment, we compute the alignment scores for three different diagonals at the same time with each block, labelled as , to prevent possible sensitivity loss. we also record the start locations for each score labelled as {u, m, l} representing the upper diagonal, the main diagonal, and the lower diagonal. afterwards, we concatenate the block scores to get the complete alignment score. since the block scores are independent of each other, we use a tree structure to concatenate multiple block scores in parallel to reduce the computation time. our parallel block alignment algorithm is similar to the four-russian speedup technique
 <cit>  for block alignment, but we employ a different block construction strategy. instead of partitioning the search space into overlapping square blocks, we divide the search space into consecutive “v-shaped” regions, without any overlap. gassst also introduces a tiled-nw filter to compute the alignment score in blocks. a small lookup table for 4 bp long sequence pairs is applied for the block score computation. the lower bound score is computed among three overlapping regions along the main diagonal. as the tiled-nw filter is the first stage of the cascading filters in gassst, its performance for eliminating the candidate hits is quite limited. in contrast, our parallel block alignment algorithm can provide a high sensitivity on candidate elimination . figure 
 <dig> gives an example of our parallel banded nw search for two 12 bp sequences. the bold lines in figure 
 <dig> construct three blocks for alignment computation. after block reformation, we get a substitution matrix for each block. the alignment score computation is determined by its substitution matrix. assuming the threshold is three, if the alignment score is higher than the threshold, the alignment will be ignored and labelled with the symbol “×”. the block score computation is divided into two categories: the initial block alignment and the latter block alignment.

the initial block score computation is the same as the conventional banded semi-global alignment. the block b <dig> score computation in figure 
 <dig> belongs to this category. its alignment score is s1 =  and the start location is . the score computation for block b <dig> and block b <dig> falls into the other category , and also follows equation , but assumes that there are three possible start points  for the alignment. figure 
 <dig> shows the detailed computations steps for block b <dig>  the dashed arrows in figure 
 <dig> indicate the trace-back paths of the alignment. based on these paths, we can determine the start location for each score in the last column of the score section. the final score for block b <dig> is s2 =  with a start location of . following the same method, the alignment score for block b <dig> is s3 =  and the start location is  . in figure 
 <dig>  we use the arrows to represent the start locations after block alignment. for example, the arrow from s3l to s2u indicates the start location of ‘u’. by concatenating block b <dig> and b <dig>  we get the alignment score s23 =  and the updated start location . following the same strategy, we can get the score for all three blocks as: s123 = . then, the final alignment score is  <dig> . for the conventional algorithm, it requires at least 12 cycles to get the alignment score. in contrast, our method only requires 6 cycles . thus, as the read length increases, we can expect greater computational efficiency. in practice, we have designed an fpga aligner including twelve blocks, where each block can conduct an 8 bp alignment.

hybrid system architecture
the overall hybrid system structure is shown in figure 
 <dig>  in our design, we use a constant-length seed model and index the reference genome. thus, the reference genome only needs to be processed once and the results can be reused for different read datasets. therefore, indexing is treated as a pre-processing stage, which is not included in the overall alignment work flow.

the complete system is running on a drc coprocessor system
 <cit>  and the host pc communicates with the fpga chip through the hypertransport interface. the main tasks for the host pc are simple and are not compute-intensive, consisting of: read coding  and transferring the coded reads to the short read aligner; sending operating commands to the aligner; receiving the alignment results and writing them to an output file. the short read aligner  conducts the seed generation and extension operations on the fpga chip.

the hybrid system includes two working states, the initialization state and the processing state. in the initialization state, the host pc first configures the aligner’s parameters through the use of setup commands. the fpga aligner design supports different read lengths, which is controlled by the length_setup command. although currently the maximum read length is 100 bps, it is relatively simple to modify the aligner to support larger lengths. the threshold score is set based on the thresh_setup command before the alignment start. unlike other designs which conduct the alignment read by read, our hybrid system processes the alignment chunk by chunk. in our implementation, the host pc processes  <dig>  reads per iteration. the coded read chunk is stored in fpga bram resources. for  <dig>  reads of length 100 bps, this consumes 400kbit of memory space . the memory consumption is thus moderate and will not compete for resources required for subsequent stages. when the read chunk is ready, the host pc sends a start command to start the fpga aligner. when chunk processing is finished, the fpga aligner sends back an operation_done flag to inform the host pc. based on our observation, the processing speed of the host pc is slower than that of fpga aligner. thus, to apply multi-threading on the read coding part can further improve the overall performance. an experiment related to multi-threading is given in “results and discussion” section.

our short read aligner is composed of two major fpga components: the seed engine and the align core. the seed engine identifies all  candidates with high similarity. the align core implements our parallel banded nw algorithm. the overall structure of the short read aligner is shown in figure 
 <dig>  each of the off-chip ddr <dig> sdram memories provides 2gbytes of storage with a bandwidth of 128bits, while the rldram memory provides 256mbytes storage with a bandwidth of 64bits. two tables are attached to the seed engine. both of them are generated by the indexing of the reference genome. the reference genome itself is also stored in the off-chip memory to generate  pairs. the local reads module stores the coded read chunk data using on-chip memory.

seed engine
the hash table construction is the main task for the seed engine design. software tools  usually apply a flexible seed model, i.e. for different read lengths using different seed sizes. the advantage of the flexible seed model is that it can avoid generating too many candidate regions and moderate the work burden for the extension stage. however, the flexible seed model also requires repetitive indexing of the reference genome.

in our seed engine design, the constraint on the number of candidate regions is less stringent, since the align core can provide very fast alignment computation. thus, a much simpler constant seed model is used. to evaluate the influence of different seed models, we record the number of duplicate seeds and alignments with different seed length settings in table 
 <dig> .

table 
 <dig> shows that a longer seed length can effectively reduce the number of duplications, but the alignment sensitivity drops correspondingly. as duplicate seeds require extra computation time for hash table access, we arbitrarily choose 15 bp as the seed length to avoid a large number of duplications while slightly sacrificing the alignment sensitivity. to quickly identify candidate regions, two requirements exist for the hash function selection:  a simple hash function representation, and  a reduced number of collisions. a complex hash function would compete with the hardware resources needed for the later extension stage implementation. furthermore, if there are too many collisions, the additional off-chip memory accesses will reduce the overall performance.

we apply the bucket hash strategy with hash functions chosen from the h <dig> family
 <cit> . the bucket hash first divides the seeds into multiple buckets. a separate hash function is applied for individual buckets to guarantee that there are only a limited number of hash collisions. a seed is divided into two parts: the prefix and the suffix. figure 
 <dig> gives an example of the hash query data path for a 15 bp seed. as the dna alphabet size is only four characters, 30bits is enough to represent a 15 bp seed. the first 16bits are used as the prefix to construct the buckets; the remaining 14bits  are used for hash computation. the hash table address is computed by combining both the prefix and the hash value. as collisions only appear among seeds in the same bucket, the bucket hash strategy can effectively reduce the number of collisions.

to avoid sensitivity loss for seeds which collide, an additional table, called the collision table, is also constructed. the definitions of the primary table and the collision table fields are:c 1bit, the collision flagcount 7bits, the total number of seeds that were hashed to this slotptr 24bits, if the collision flag is ‘0’, it indicates the position in the reference genome otherwise, it indicates the start location in the collision tablepos 24bits, the match position in the reference genome

for the e. coli reference genome, the primary table consumes 64 k × 4 k × 32bits of memory and the collision table consumes 421623 × 32bits of memory. as both the primary hash table and the collision table are too large for the on-chip memory, the primary hash table is stored in ddr <dig> sdram <dig> and the collision table is stored in rldram. storing them in separate memories allows us to pipeline the hash query rather than waiting for a complete query operation. once a match position in the reference genome is found, the seed engine will extract the related base information from sdram <dig>  to generate the valid  pair for the extension stage.

as the seed engine computation refers to data transfer between the fpga and off-chip memories, its performance is largely influenced by these i/o operations. the estimated highest clock frequency for the seed engine is around 250 mhz .

align core
the inner structure of the align core module is shown in figure 
 <dig>  it consists of two alignment engines, a command interface, a best alignments module, and an output fifo. the command interface sets the operation parameters of the align engine and monitors the operation_end flag. the output fifo temporarily stores the match  information. the alignment engine performs the alignment computation.

normally, a single alignment engine is enough for the banded nw alignment, but in some occasional situations , the alignment score will be incorrect. figure 
 <dig> gives an example of such special cases.

in figure 
 <dig>  case  is missing the extra character to the left of the candidate region. in case , the final score will be s +  <dig>  for the normal search. however, if the character to the left of the candidate region happens to be ‘a’, the correct alignment score will change to s. this will introduce a false negative answer in the final results. to prevent possible sensitivity loss, we expand the search space by applying two alignment engines. one is for the normal search; the other searches the reference region shifted one base to the left. the “best alignments” module chooses the best alignment score between these two alignment engines and at the same time removes the duplicate results. in contrast, case  is missing extra characters to the right of the candidate region. as fewer nucleotides are computed, the alignment score could be less than its actual value, which adds false positive answers to the final results. to solve this problem, we also load one extra base to the right of the candidate region and compare it with the last character of the read. the alignment score from the lower diagonal will be updated with the extra base compare result.

the alignment engine design  follows the parallel banded nw algorithm mentioned in section ii. it consists of three components: a head processing module, twelve smaller alignment modules , and a concatenate module.

the head-processing module conducts the semi-global alignment for the first four bases. twelve align8bp modules can support up to 96 bp alignment computation. the align8bp module conducts the alignment computation using a substitution matrix of size 3 ×  <dig> for each block. its inner structure is shown in figure 
 <dig>  each cell in figure 
 <dig> is initialized with the value in the substitution matrix. the alignment score is updated along the path labeled in the inner structure. meanwhile, each cell also records the updated start location based on the score computation result. when all computations are done, the last column will report the block alignment scores and corresponding start locations.

the most time consuming path for the align8bp module is updating the main diagonal score. we have labelled the critical path with red arrows in figure 
 <dig>  to further improve the align8bp module’s performance, we insert extra registers to shorten the critical path. the alignment concatenation module design follows the method shown in figure 
 <dig> and it also uses a tree structure to reduce the computation latency.

to support reads longer than 100 bp, we can simply duplicate the align8bp module to extend our fpga aligner’s processing capability. for alignments allowing more gaps, the parallel block algorithm still works except that the search space needs to be expanded. our current fpga aligner only supports alignments with a band width of one. to cope with more gaps, we need to expand our search space by adding more cells into the align8bp module .

paired-end alignment
unlike single-end short read alignment, the paired-end alignment problem involves a pair of short read datasets and two parameters, an outer distance d and a standard variation d. similar to the single-end alignment, each read in the pair  will firstly be aligned individually, which can be accomplished utilizing our fpga-based short read aligner. define that p <dig> is the start location in the reference genome that read s <dig> is aligned; p <dig> is the start location in the reference genome that read s <dig> is aligned. then, an additional pairing scheme is applied to complete the paired-end search on the host pc. the pairing scheme includes three cases:  both s <dig> and s <dig> have matches in the reference genome;  only s <dig> has matches in the reference genome;  only s <dig> has matches in the reference genome. the pseudo code for the pairing scheme is shown in figure 
 <dig>  for each sw operation in the pseudo-code, we conduct the forward search and the reverse complement smith-waterman alignment of the short read to increase sensitivity.

RESULTS
we have implemented the fpga aligner using verilog hdl and have targeted it to a xilinx virtex <dig> lx <dig> device. the design consumes  <dig>  slice registers ,  <dig>  slice luts , and  <dig> 36 kb bram blocks . the fpga aligner works at 200 mhz, which maximizes the i/o data transfer. several experiments are conducted to evaluate the fpga aligner’s performance at this clock frequency setting. the performance of our fpga aligner is compared with gassst  and bwa . the fundamental work flow of our fpga aligner design is similar to that of gassst, except that gassst uses multiple pre-filters to eliminate irrelevant data before the computation intensive global alignment. bwa uses a totally different strategy  to conduct the short read alignment computation. it is probably one of the fastest aligners to date for alignments with a low error rate and is also a popular choice in the bioinformatics community. thus, we also include bwa in the performance evaluation. gaps are allowed in all three aligners. all tests are performed on a quad-core  amd opteron processor with 8gbyte ram running the linux os. the reference genome is the e. coli nc_ <dig> dataset with  <dig>  million residues. we have generated several simulated short read datasets using the wgsim utility program in the samtools package
 <cit>   with different error rate settings. in all experiments, the identification percentage is set to 90% and the number of gaps allowed is one. for example, for a 36 bp read alignment, at most three errors are allowed . the other parameters for gassst and bwa are set to the default values.

to analyze the performance bottleneck for our hybrid system, we first measure the cumulative execution time of different parts of our system running with a single cpu thread. the results are shown in table 
 <dig> using a 76 bp single-end read dataset with 4% error rate. the results show that the host pc computation occupies 69% of the overall execution time, which is related to read coding and match output. this indicates that the read coding and the match output is now the bottleneck for our hybrid system design. further improvements on the fpga aligner cannot improve the hybrid system’s performance significantly using just a single thread. however, the system performance can be improved using multi-threading.

additional experiments are also prepared to give a more thorough analysis of the fpga aligner design. the second experiment is to evaluate the align core’s processing capability. we compare the runtime performance between the filtration part in gassst and our align core, assuming that the input data for each of them is available. as this experiment only compares the “alignment” section runtime, the runtime performance of bwa is not included. three small short read datasets  of varying error rates are used. each dataset contains one million reads. table 
 <dig> reports the runtime comparison under different conditions. the gassst filter runtime includes all filtration stages from the tiled-nw filter to the real nw filter computation using a single thread. the align core runtime also includes data transfer from off-chip memory to fpga.

table 
 <dig> shows that the fpga align core provides a much better runtime performance for the alignment computation . as the filtration  stage is accelerated by the align core, it is no longer the performance bottleneck for the “seed-and-extend” strategy. however, the performance of the align core alone does not represent the complete performance of our hybrid system. to make a fair evaluation on the hybrid system’s performance, we have compared the complete execution time of gassst, bwa, and our hybrid aligner using one million reads with 4% error rate with different read lengths . we also record the performance under multi-threaded conditions. the results are shown in table 
 <dig> 

.

the performance of our hybrid aligner reported in table 
 <dig> is partially multi-threaded, i.e. different threads share the same fpga aligner which only processes data from one thread at a time. once a thread offloads the operations to the fpga aligner, this thread needs to wait for the fpga’s “computation done” flag. at the same time, other threads can keep encoding the short reads. as the fpga aligner’s computation time is much shorter than that of read encoding, the waiting time for the thread is acceptable. as the bwt index can be reused for the same reference genome, the execution time of bwa in all our tests only includes aln and samse . bwa provides a faster processing speed than gassst by taking advantage of the bwt-based search. our hybrid aligner achieves a speedup of  <dig> over gassst and of  <dig> over bwa with a single thread. the execution time speedup is less than that reported by the align core alone. this indicates that the align core is not fully utilized. when alignment computation is no longer the performance bottleneck, two other factors are responsible for the system’s overall performance: the read coding and the seed engine processing. the read coding computation is simple, but the total number of bases is large. therefore, we utilize streaming simd extensions  <dig>  instructions to minimize its computation time. notice that there is no performance improvement for our fpga aligner, when the number of threads changes from two to four. to find out the performance bottleneck for the current design, we further record the runtime consumed by the fpga aligner under different thread conditions. table 
 <dig> shows the runtime performance for the 100 bp case.

table 
 <dig> results show that when two threads are applied, the fpga aligner’s runtime is almost doubled and its proportion jumps from  <dig> % directly to 77%. this indicates that if more threads are applied, the fpga aligner will be the performance bottleneck, which is proven by the zero performance improvement of the  <dig> thread case. as the align core is no longer the performance bottleneck for the fpga aligner, the seed engine is the only explanation for such a performance limitation. the seed engine computation requires frequent off-chip memory accesses , which intrinsically limits its runtime performance. since the processing speed is limited by the off-chip hash table access, several methods exist to further improve the design’s performance:  using fpga platforms with multiple off-chip memory interfaces , or  using fpga chips with larger on-chip memories . as the resource consumption of our fpga aligner design is less than 50% of the total fpga resources, it is possible to duplicate the align core module or even the full fpga aligner module on the same fpga chip. however, the limited number of off-chip memory interfaces in the current experimental platform cannot generate any more  pairs in the seed engine module. an fpga board with more interfaces would eliminate this bottleneck, bringing additional performance improvements.

runtime testing with a single error rate might not be enough to explore the performance of the three programs. thus, we also test the runtime performance under different error rate conditions using simulated read datasets with a single thread. the performance is shown in table 
 <dig> 

from table 
 <dig>  we can find that more execution time is consumed for all three alignment tools, as a longer read length is applied. this is because a longer read length leads to a larger search space, which naturally requires more computation time. another interesting observation is that, under different error rate conditions, our hybrid aligner provides a relatively stable performance. in contrast, gassst shows performance improvements and bwa shows performance deterioration, as the error rate increases. the search strategy used within the tools can explain such a difference. bwa applies the bwt-based search algorithm, which consumes additional computation time when an error occurs. therefore, its computation time will increase, if more errors exist in the read dataset. the gassst computation is based on the “seed and extension” strategy. as the error rate increases, the number of seeds in the read decreases, which reduces the computation time required in the extension stage. our hybrid system also uses the “seed and extension” strategy, but the fpga aligner computation only occupies a small portion of the total runtime . thus, the error rate change only has limited influence on the execution time.

besides investigating the speed of the fpga aligner, we also examine the alignment quality among the different tools based on two factors:  the total number of alignments found  and,  the number of true alignments found . since we know the exact positions for each read in the simulated datasets, the correctness of the reported alignments can be easily evaluated by comparing the position information. in practice, if an alignment position is within a maximal distance d  to the correct position, this alignment will be treated as a correct alignment. table 
 <dig> shows the quality comparison using one million reads with different error rate settings.

the alignment results show that bwa’s sensitivity drops dramatically compared to gassst and our hybrid aligner, when the bases error rate increases. in contrast, both gassst and our hybrid aligner maintain a relative stable performance: over 96% sensitivity for a 4% error rate and over 85% sensitivity for a 6% error rate. all three tools provide over 98% alignment accuracy. the alignment quality of our hybrid aligner is better than that of gassst under the above test conditions, particularly at the higher error rate. the reason for the improvement is related to the seed model. gassst uses a flexible seed model to ease the alignment computation. for longer read lengths, gassst will use longer seed lengths . in contrast, our fpga aligner uses the constant seed model , which can provide extra sensitivity for longer read datasets.

we have also conducted a further performance comparison of gassst, bwa, and our hybrid system using larger read datasets. the simulated read datasets are  <dig> million sequences of length 76 bp and 100 bp, with a 4% error rate. the alignment performance is shown in table 
 <dig> for a single thread implementation.

the experimental results show that bwa only achieves around 83% sensitivity, while gassst and our hybrid system achieve around 97% sensitivity. this indicates that both gassst and our hybrid system are more effective in finding good alignments under this error setting. on the runtime performance side, bwa provides a faster processing speed than gassst by taking advantage of the bwt-based search. our hybrid system achieves the fastest processing speed, while maintaining the sensitivity at a high level. in addition to the simulated short read datasets, we have also evaluated the alignment performance using a real dataset . in this case, a separate program is used to perform the substitution. the original read length within srr <dig> is 101 bp. as our design only supports a maximum 100 bp short reads, we chop one character from the 3′ end. for the single-end alignment, we use the first  <dig> , <dig> short reads to conduct the test. table 
 <dig> records the alignment quality and the runtime performance with a single thread for the three aligners. it is clear that our hybrid aligner reports more alignments than the other two aligners with a faster processing speed .

as gassst does not support paired-end alignment, the performance comparison is made only between bwa and our hybrid aligner using one million simulated short reads. before the performance analysis, we further introduce several parameters to evaluate the alignment quality: precision , recall , and f-score . the f-score combines the influence of precision and recall together to evaluate the alignment quality. the comparison results are shown in table 
 <dig>  the paired-end read dataset is generated using the wgsim utilities with an outer distance of  <dig>  a standard variation of  <dig>  and a 4% error rate. the performance is tested with a single thread. table 
 <dig> records the performance achieved using the real srr <dig> dataset.

table 
 <dig> results show that our hybrid aligner finds more paired-end alignments than bwa, but with a slightly worse precision performance for one million simulated 100 bp reads. we notice that the speedup achieved by pair-end alignment is smaller than that of single-end alignment. this is related to the pairing strategy applied by bwa which further utilizes the advantage of the bwt index to accelerate the pairing process. in table 
 <dig>  our hybrid aligner reports more alignments, but bwa reports more alignments in table 
 <dig>  we believe such difference also routes on the pairing strategy. the reported alignments can be increased simply by increasing the search space , l <dig> is the read length; l <dig> is the candidate region) in the pairing process, but the execution time will also increase correspondingly.

the above experiments show that our hybrid system achieves a significant performance improvement when testing with a small reference genome . while our hybrid system design is independent of the reference genome, the restricted memory size of the experiment platform  limits the possibility to test with a larger reference genome, such as the human genome . if no partitioning is applied for the human genome and we use the minimal perfect hash function to construct the hash table, the system requires at least 12gbyte memory for the hash table . in contrast, our experimental platform only has 2gbyte of off-chip memory for the hash table, which is not large enough to support the human genome. in practice, the memory footprint is likely to even larger than 12gbyte, as it is difficult to get a minimal perfect hash function for the human genome. a different fpga platform with more off-chip memory could support the short read mapping against the human genome using our proposed architecture. another possible solution to support human genome is to apply bwt-based methods in the seed generation stage design to reduce the memory consumption.

a number of short read aligners built on other hybrid platforms, such as gpus, have appeared in the research literature. we have further compared our fpga-based aligner to the gpu-based aligner cushaw
 <cit>    on an nvidia tesla c <dig> gpu attached to an intel xeon quad-core cpu  <dig>  ghz with 8 gb ram running the 64bit ubuntu  <dig>  os. similar to the previous experiments, the short read dataset consists of one million 76 bp short reads with 4% base error rate. the reference genome is the e. coli genome. table 
 <dig> shows the runtime performance for the two aligners running with a single cpu thread as well as some key features of the two experiment platforms.

* the clock frequency is the clock for the tesla c <dig> board and the fpga chip, respectively. the gpu specifications are from
 <cit> .

in this experiment, cushaw is twice as fast as our hybrid aligner. this runtime speedup is achieved by a combination of both the mapping algorithm within cushaw and the gpu platform. these advantages include:  bwt-based indexing, which largely reduces the memory footprint;  disallowing gaps, which reduces the search space;  a wider memory i/o, as short read mapping requires intensive memory accesses, this will definitely be an advantage;  the much higher clock frequency of the gpu provides a better runtime performance. additionally, the nvidia tesla c <dig> board was released in  <dig>  in contrast, the lx <dig> fpga was released in  <dig>  which means it is at least two generations older than the c <dig>  for example, when mapping our fpga aligner to the up-to-date xilinx virtex- <dig> xc7vx1140t chip, the xilinx tool chain estimated a working frequency of 264 mhz . in addition, this chip contains 68mbit of bram . therefore, we can use sdram <dig>  to store another copy of the primary hash table to further double the  pair generation rate. furthermore, when we replace the ddr <dig> memory with the ddr <dig> memory on the virtex- <dig>  the memory i/o bus clock increases from 200 mhz to 400 mhz resulting in an additional  <dig> times speedup. thus, we can expect approximately  <dig>  times performance improvement in total .

both fpgas and gpus are powerful platforms for high performance computing, but they have advantages for different types of applications. the advantage of gpus lies in the many hundreds of cores, the different types of memories and the fast data transfer interfaces; whereas the advantage of fpgas lies in their fine-grained pipelining and massive parallelism. fpgas can provide the freedom to fully customize the circuit to fit a specific application. integer and bit operations are more suitable for a fpga implementation. however, like any implementation, to achieve the best possible performance, the original algorithm needs to be carefully tailored to fit the specific architecture.

CONCLUSIONS
in this paper, we have presented a novel hybrid system to accelerate the mapping of short reads to a reference genome based on the seed-and-extend approach. we propose a parallel banded semi-global alignment architecture to accelerate the computation-intensive extension stage on an fpga. meanwhile, we also apply a bucket hash structure to improve the seed generation stage computation. the performance comparison to the gassst and bwa software implementations under different test conditions shows that our fpga aligner achieves a high degree of sensitivity and requires less overall execution time with only modest resource utilization. as a result, the performance bottleneck on the fpga aligner changes from the extension stage to the seed generation stage.

as part of our future work, we are planning to expand the functionality of our fpga aligner to cope with longer read datasets. meanwhile, we will also investigate the possibility to integrate the bwt-based search algorithm into our seed generation stage design to reduce the memory consumption.

endnote
anormally, there are three types of alignment errors: insertion, deletion, and substitution.

competing interests
there is no competing interests for this manuscript.

authors’ contributions
yc conceptualized the study, carried out the design and implementation of the architecture, performed the performance tests, analyzed the results and drafted the manuscript; bs and dlm conceptualized the study, participated in the analysis of the results and contributed to the revising of the manuscript. all authors read and approved the final manuscript.
