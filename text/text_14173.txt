BACKGROUND
in recent work, we developed a highly multiplexed pcr-based target-enrichment system called hi-plex  for massively parallel sequencing   <cit> . hi-plex is a simple, low-cost protocol that can achieve highly accurate results. one of its key features is the ability to define a uniform library size which facilitates the removal of off-target amplification by size selection and, in combination with paired-end sequencing, allows complete overlap of read-pairs for each amplicon. the latter aspect permits a high degree of stringency in both the detection of variants and the filtering of artefacts caused by sequencing errors. previously, we developed rover, a variant calling tool which takes advantage of the overlapping reads produced by hi-plex  <cit> , and successfully applied hi-plex and rover to screening for genetic variants in the coding regions of palb <dig>  detecting all  <dig> variants identified by previous mutation screening and producing no false positive calls  <cit> .

rover requires as inputs a file describing the genomic coordinates of target amplicon regions in tab-delimited format and one or more sequence files in bam format  <cit>  containing paired-end reads mapped to a reference genome. it produces a list of variants in vcf format  <cit> . rover can detect single nucleotide variants  and small insertions and deletions . a variant is only reported by rover when it appears at the same position in both of the reads in an overlapping pair.

by far the most computationally expensive part of detecting variants with rover is the time taken to map  the reads to the reference genome. in one indicative experiment, described below, the time taken for mapping with bowtie   <cit>  constituted approximately 78 % of the whole rover variant calling pipeline. read mapping is a standard part of whole-exome and whole-genome dna sequencing pipelines but, as has been demonstrated previously by amplivar  <cit>  and as we demonstrate in this paper in the context of hi-plex, it can be avoided in pcr-based mps approaches. this is because the 5′ end of each read begins with a primer sequence whose genomic coordinates are already known. this latter information is determined during primer design. the reads do not need to be mapped to the reference because the primer-pairs identify the genomic coordinates of the intervening sequence. optionally, we can further increase our confidence that a read is mapped to the correct location by checking that at least one of the reads in a pair is identical to the reference for a small sequence following the primer.

having determined the starting coordinates of a particular read, we can then compare its sequence to the reference. to allow for insertions and deletions, it is necessary to perform a gapped alignment in the style of the needleman-wunsch algorithm  <cit> . however, the complexity of this algorithm is a quadratic function of the length of the aligned sequence and, therefore, expensive to compute for every read in the input. fortunately, we can often avoid this cost because most reads in the input will be identical to the reference or will only differ by a small number of mismatches. in these cases, a simple linear comparison of the read to the reference is sufficient. we fall back to the gapped alignment algorithm only when the linear comparison fails.

amplivar is based on premises similar to those underlying undr rover but applies a different mechanism. amplivar uses primer sequences to associate reads with amplicons and reduces computational overheads by aligning reads as groups . furthermore, amplivar merges overlapping reads , whereas undr rover keeps both reads to test their concordance as part of a stringent filtering system.

undr rover was designed to support hi-plex targeted sequencing but is also compatible with other amplicon-based targeted sequencing systems that retain gene-specific primer sequences in the sequencing reads and for which primer and insert coordinates and primer sequences and paired fastq files can be supplied in the formats outlined in our documentation. ampliseq-generated data would not be compatible, for example, because the gene-specific primers are largely cleaved during library generation. a key consideration is that undr-rover is intended to work with sequencing data exhibiting considerable overlap of read-pairs - as such, it is not recommended for use with systems that do not achieve this.

implementation
undr rover is implemented in python  <dig>  as a command-line application. its four mandatory arguments are: 1) a tab-delimited format file which associates primer-pairs with their genomic coordinates; 2) a tab-delimited format file which matches primer names to their insert sequences; 3) a fasta format file containing the reference sequence ; 4) one or more pairs of fastq files. the main output of undr rover is a vcf file containing the detected variants. additionally, it produces two log files which report on the overall execution of the program and the depth to which each amplicon is covered by the reads.

hi-plex employs pcr to amplify selected target regions of dna. larger segments of dna are split into tiles of a specified narrow size range . the regular tile size facilitates size selection of the amplified product which increases on-target stringency and allows both reads of a pair to overlap the entire tile. hi-plex is compatible with short-read sequencing platforms such as illumina truseq  and ion torrent   <cit> . hi-plex primers consist of a pool of relatively low concentration  gene-specific primers  that seed the pcr, and universal adapter primers that drive the majority of the reaction. gsps are designed to correspond to the sequences flanking the target inserts. figure  <dig> illustrates the structure of a hi-plex library element in relation to the two overlapping reads of a read-pair.fig.  <dig> hi-plex library structure and overlapping reads. the center rectangle represents the target insert dna sequence flanked by gene-specific primer  sites  and adapter sequences . the two reads of a pair are shown in yellow. the 5′ end of each read starts with its corresponding gene-specific primer sequence. the insert size is chosen so that both reads overlap the target insert sequence completely. the 3′ ends of reads may extend into the adapter sequence depending on the read length and the presence/absence of insertions/deletions in the template dna. the diagram is not to scale. typically, the insert sequence will be significantly longer than the primer sequences



undr rover comprises two main steps: 1) associating reads with their corresponding primer tiles and 2) calling variants.

a primer tile is a contiguous section of the genome which is flanked by a primer-pair. we take advantage of the fact that the 5′ end of each read starts with a gsp sequence for which the coordinates are known. therefore, the start of each read can be compared to the full set of gsps to identify its corresponding tile. this comparison is made efficient by storing primer information in a hash table indexed by primer sequence. as such, the coordinates of each read can be found in time proportional to the length of the primer sequence. hi-plex primers can vary in length to a small degree, therefore undr rover stores only the first n bases of primers in the hash table. the value of n is user definable and should be no larger than the length of the shortest primer used in the experiment. this scheme requires that the first n bases of a read is an exact match to its corresponding primer sequence and, therefore, does not tolerate mismatches derived from errors in the sequencing chemistry and/or production of primer oligonucleotides. reads which do not start with a known primer sequence are discarded. we have not found this to be a problem in practice due to the high fidelity of modern mps platforms, especially at the 5′ end of reads. in the example experiment described below, out of a total of over  <dig> million reads, 84 % matched exactly with a primer sequence.

undr rover uses the same variant calling algorithm as its predecessor, rover, which requires that both reads in a pair overlap their associated tile by at least a specified percentage . reads which do not satisfy this requirement are discarded. some provision to allow incomplete overlap is engineered to accommodate contexts that preclude the achievement of complete ‘tiling’, such as the presence of genomic insertion events or intractable sequences for primer design. for additional stringency, undr rover can optionally test whether, in at least one of the reads in a pair, the sequence just after the primer sequence is an exact match with the corresponding target reference sequence. by default, this test will use a sequence of  <dig> nucleotides, but it can be configured by a command-line argument. since only one read of a read-pair  is required to match the expected sequence for a read-pair to contribute to variant calling, variants that are present in the terminal regions are detectable unless they coincide with additional variants at the other end of the read-pair.

undr rover compares the expected insert sequence from the reference genome to the part of the read following the gsp. in the common case we expect the sequences to be identical or only have one base mismatch. therefore, as an optimisation, undr rover first performs a linear comparison of the two. if more than one mismatch is detected by the linear comparison, then a gapped-alignment of the two sequences is performed using the needleman-wunsch algorithm as implemented in the pairwise <dig> module of biopython  <cit> . in the majority of cases the linear comparison is sufficient, thus avoiding the significantly greater cost of gapped alignment most of the time. additional speed can be achieved  optionally by allowing more than one mismatch to occur in the linear comparison if each mismatch is separated by less than or equal to a specified number of bases. we use the term thorough when no more than one mismatch in the linear comparison is permitted, and the term fast for the more lenient option.

as with its predecessor, undr rover only calls variants which appear in both reads of a pair such that 1) the frequency of the variant-pair is above a minimum absolute value, 2) the variant-pair occurs above a minimum percentage of all read-pairs overlapping the amplicon, and 3) each read of a pair overlaps the target amplicon by a user-defined minimum percentage. all of these conditions can be adjusted by command line arguments. optionally, undr rover can filter out any bases which do not meet a minimum base-quality score.

we illustrate undr rover’s algorithm with the pseudo-code in fig.  <dig>  the algorithm is realised by the get_variants procedure which takes four parameters: 1) a sequence of paired-end fastq files, one pair for each input sample; 2) the list of tile coordinates associated with primer names; 3) a list of primer names associated with corresponding dna sequences; 4) a reference genome sequence. the output is a vcf file containing variants and associated metadata such as frequency count, genotype and whether they passed various filtering tests.fig.  <dig> pseudo code for variant calling algorithm employed by undr rover



a hash table mapping primers to their corresponding tiles is intialised . the keys of the hash table are length n prefixes of the primer dna sequences. the values associated with each key contain the genomic coordinates of the tile plus the reference sequence at the same location. primer pairs are connected by having the entry for the reverse primer point back to the entry for its forward partner. each pair of fastq files is processed in sequence ; undr rover calls variants in each input sample separately. for each sample, all reads in each fastq file are associated with their corresponding tile , then variants are called for each tile . each read is associated with its tile by hashing the first n bases of the sequence and looking up the result in the tile map. each read in a pair is compared to the corresponding reference sequence and differences between the two are computed  using the approach described earlier. differences which appear on both read pairs are retained . frequencies for each variant are computed and the filters described above are applied. each snv is genotyped by computing a pileup of bases at the position of the variant. the most likely genotype is computed by comparing the expected distribution of dna bases for a given pileup coverage size to the actual distribution of bases. the expected distribution is computed from the ploidy of the putative genotype and a very simple error model, which assumes a constant read error rate which defaults to 1/ <dig>  but can be overridden as a command line parameter. by default, undr rover assumes a diploid genotype model, but this can be overridden to a haploid model via a command line argument. the distance between the expected and actual base frequency distributions are computed using a statistical g-test which is based on a log-likelihood ratio. the genotype with the smallest distance to the observed data is taken to be best explanation for the observed data. genotyping can add extra time to variant calling and is therefore only performed when an optional command line argument is set.

RESULTS
we have demonstrated the performance of undr rover by comparing it to its predecessor rover using a previously published dataset  <cit> . hi-plex was used to screen  <dig> blood-derived dna samples targeting the protein coding and some flanking intronic and untranslated regions of palb <dig> and xrcc <dig> using  <dig> primer-pairs in the pcr. the resulting library was sequenced on a miseq instrument  producing  <dig> pairs of fastq files  with an average file size of  <dig> mib. previous application of rover to this dataset  using bowtie2- <dig> .0) accurately detected all  <dig> variant occurrences identified through mutation screening and assigned no false positive calls. application of undr rover to the same data set yielded the same set of called variants in both thorough and fast modes. future experiments will seek to validate undr rover using additional data sets that, similar to the data set used in this study, have been extensively characterised by sanger sequencing.

we also applied the gatk haplotypecaller   <cit>  variant calling software to the same samples, after aligning the fastq files to the reference with bowtie. we instructed gatk to only call variants in the targeted regions. gatk called the same variants as rover and undr rover plus two additional calls which appear to be false positives caused by sequencing artefacts. both rover and undr rover were able to filter out these false positives because the artefacts did not appear on both reads in the affected read pairs. the gatk command used to call variants is shown below:

figure  <dig> compares the total sequential computing time for undr rover against the gatk and rover pipelines  when applied to the entire set of  <dig> samples. we applied undr rover in three different modes to show the performance implications of different settings. the performance tests were executed on a single node of an ibm idataplex cluster with  <dig> core  <dig> ghz cpus and 256gb of ram using the red hat enterprise linux version  <dig> operating system. total sequential computation times for computing variants in all  <dig> hi-plex input samples were 9535 s for the gatk-based pipeline, 5721 s for the rover-based pipeline, 2480 s for undr rover in thorough mode without genotyping,  <dig> for undr rover in fast mode with genotyping, and 690 s for undr rover in fast mode without genotyping. approximately 78 % of the rover pipeline time is constituted by read alignment with bowtie. this highlights the significant performance gains possible by avoiding the alignment step. in summary, for this indicative experiment, we see that undr rover is able to achieve between a 2-fold and 8-fold performance improvement compared to its predecessor, and up to 13-fold improvement over a pipeline based on gatk, whilst producing the same set of variant calls.fig.  <dig> runtime comparison of gatk, rover and undr rover. total sequential computing time of the gatk pipeline, rover and undr rover  when applied to  <dig> hi-plex samples targeting palb <dig> and xrcc <dig> with  <dig> primer-pairs in the pcr. the computing time for the gatk and rover pipelines are decomposed into alignment with bowtie , conversion of alignment file from sam to bam format , indexing and sorting of bam file , and variant calling . computing times for undr rover are shown for both the thorough mode  and the fast mode with snv genotyping , and the fast mode without snv genotyping 



discussion
the following command line illustrates a typical invocation of undr rover:

where the input files coords.tsv and seqs.txt provide the primer coordinates and dna sequences, respectively, hg <dig> fa is the reference dna sequence and sample1_r <dig> fastq and sample_r <dig> fastq contain the input dna reads. the output variant calls are written to the file results.vcf.

below is a short example primer coordinates file illustrating two pairs of primers:

the first column indicates the chromosome of the targeted sequence. the second and third columns indicate the start and end coordinates of the target tile. the fourth and fifth columns indicate the unique symbolic names of the forward and reverse primers for a target tile.

below is a short example primer sequences file, with entries corresponding to the gene-specific portions of primers from the example coordinates file above:

the first column indicates the unique symbolic name of the primer and the second column indicates the primer dna sequence written in the 5′ to 3′ direction. primer coordinates are matched with primer sequences via their unique symbolic names.

CONCLUSIONS
undr rover provides a computationally more efficient alternative to rover and other standard variant calling pipelines for the detection of genetic variants from hi-plex-generated datasets while maintaining a high level of accuracy.

availability and requirements
project name: undr rover

project home page: https://github.com/bjpop/undr_rover

usage instructions: http://bjpop.github.io/undr_rover

operating systems: posix-like operating systems 

programming language: python

other requirements: pyvcf, pyfaidx, biopython and scipy libraries

abbreviations
gspgene specific primer

mpsmassively parallel sequencing

snvsingle nucleotide variant

vcfvariant call format

competing interests

the authors declare that they have no competing interests.

authors’ contributions

bjp, djp and rl designed the overall algorithm. bjp, el and pg designed and implemented the genotyping algorithm. bjp and rl carried out the implementation. rl and tn-d conducted testing of the software. bjp, djp, rl, el, pg and tn-d contributed to the writing of the manuscript. all authors read and approved the final manuscript.

