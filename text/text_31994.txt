BACKGROUND
many resampling algorithms used in microarray association studies can be formulated within the framework of embarrassingly parallel problems in the sense that the algorithm can be split up into smaller components which can be completed mutually independently of each other  <cit> . standard algorithms used in this context include permutation and bootstrap resampling, and cross-validation. these algorithms consist of replicates which can be processed independently of each other. furthermore, each replicate consists of the calculation of a large number of test statistics. the calculation of these test statistics can often be divided into independent parts. there are several protocols, including mpi  <cit>  and openmp  <cit> , that facilitate parallel programming for these algorithms.

due to their highly parallel structure, graphics processing units  are more effective than general-purpose central processing units  for a set of algorithms widely used in the quantitative biomedical sciences. this has been demonstrated by using gpus for example in feature detection in proteomics experiments  <cit> , analysis of epistasis  <cit> , statistical phylogenetics  <cit> , and sequence alignment algorithms  <cit> . the r 
 <cit>  extension package gputools 
 <cit>  provides gpu enabled implementations of a set of commonly used functions for analysis of microarray data. another attractive feature of using a gpu is that the hardware is relatively inexpensive, currently ranging from $ <dig> to $ <dig> for consumer grade cards  and $ <dig> to $ <dig> for high-end cards , compared to high-end multi-core workstations or cluster farms. gpu hardware can be easily added to existing workstations.

the primary focus of many published microarray association studies is the identification of genes differentially expressed with respect to a binary trait. an extensively cited example is the data set reported by golub et al  <cit>  who identified genes differentially expressed in acute myeloid leukemia  and acute lymphoblastic leukemia . for many microarray experiments, especially those in cancer, the primary endpoint of interest is not a binary outcome but rather a censored time-to-event outcome such as time to death or time to relapse. an example is the data set reported by beer et al  <cit>  who identified genes associated with survival in early-stage lung adenocarcinoma. more recently, the director's challenge consortium  for the molecular classification of lung adenocarcinoma reported predictive models for survival, based on gene expression profiles and clinical data from  <dig> patients with adenocarcinoma lung cancer  <cit> . the repository of molecular brain neoplasia data  database currently provides  <dig> gene expression arrays and survival outcomes from brain cancer patients  <cit> . in this context, cases for which the event of interest is not realized  at the time of the analysis are censored. specifically, let y <dig> denote the time of event and let c be the censoring time. what is observed is not y <dig> but rather y = min{y <dig>  c} along with event indicator Δ = . the censoring times vary among patients since they are registered to studies at different times. a proper analysis must take into account not only the distribution of y <dig>  called the survival distribution, but also the censoring mechanism induced by the distribution of the censoring time c. a popular approach for analyzing time-to-event outcomes is to dichotomize the outcome at a given landmark, say τ >  <dig>  that is believed to be clinically and biologically relevant  <cit> . for example, suppose that for a specific cohort of early stage lung adenocarcinoma patients, the median survival time τ =  <dig> years. in this case, one may categorize patients who live less than five years as high risk and those who live at least five years as low risk. this type of simplification allows for the use of methods and software tools developed for binary outcomes, but is not an optimal approach as the censoring mechanism is entirely ignored while the survival distribution is considered only at a single time-point . in a recent article, subramanian and simon  <cit>  conducted a critical review of sixteen published prognostic signatures in lung cancer and provided guidelines for statistical analysis in this context. avoiding this type of binary transformation is the first item in this set of guidelines. thus, software tools which can expeditiously conduct large-scale association testing for censored time-to-event outcomes are of great importance.

in this paper, we present a compute unified device architecture   <cit>  framework, permgpu, that employs gpus in microarray association studies. we illustrate the performance and applicability of permgpu within the context of permutation resampling for a number of test statistics. the software is provided as a stand-alone application that can be used to carry out permutation resampling inference for binary , quantitative  or censored time-to-event  traits. for wider use, we also have integrated permgpu into the r statistical environment as an extension package. the source code along with documentation is provided in additional file  <dig>  updates will be available from http://code.google.com/p/permgpu/.

implementation
we illustrate our framework using a simulation study by implementing a single-step multiple testing procedure based on the maximum statistic as described in  <cit>  and  <cit> . the cuda toolkit from nvidia, a minimal set of extensions to the c and c++ languages, is used for programming on a gtx  <dig> gpu, with  <dig> processor cores and  <dig> gb of memory. for comparison, we carry out a timing analysis based on a single cpu. the cpu code is compiled using g++ version  <dig> . <dig> with - <dig> and -funroll-loops, while the gpu code is compiled using nvcc with - <dig> and --use_fast_math optimization flags. the current implementation is designed for cuda enabled gpus.

both the gpu and cpu analyses are carried out on a  <dig>  ghz intel core <dig> quad cpu q <dig> with  <dig> gb ram of memory using the amd <dig> linux operating system. for wider applicability to the research community, we integrated permgpu into an r extension package. this implementation has been developed and tested on r version  <dig> . <dig> 

the gene-expression matrix x is of dimension n × k, where k is the number of genes, or other features, and n is the number of patients. the vector of outcomes is denoted by y while the test statistic for testing the hypothesis of marginal association between feature k and the outcomes is denoted as tk. we consider test statistics where the critical region is of the form {|tk| > ξ} for some ξ >  <dig>  for a given family-wise error rate  α ∈ , we determine the critical value ξ >  <dig> such that  under the hypothesis that no feature is associated with the outcome. the null sampling distribution is approximated using permutation resampling as follows:

 <dig>  compute the k statistics t <dig>  ..., tk based on y|x <dig>  ..., y |xk.

 <dig>  let  be a random permutation of y .

 <dig>  compute , permutation replicates of the test statistics, based on |x <dig>  ..., |xk.

 <dig>  compute 

 <dig>  repeat the last three steps b -  <dig> additional times.

the unadjusted and fwer adjusted two-sided permutation p-values are computed as  and  respectively, where i is the indicator function.

the code implementing our algorithm is a combination of kernels  and functions . while most of the calculations for the test statistics are carried out as kernels on the gpu, some of the calculations are relegated to functions on the cpu. the results of these functions are then copied to the gpu. for example, the random shuffling of the outcome is carried out only once per permutation. therefore, we found it more efficient to permute the outcome vector on the cpu and then copy the result to the gpu. the components of the code that compute the k test statistics, their maximum and p-values, are separate kernels. the kernel that computes the k test statistics is the most computationally expensive. global memory reads and computation are the primary bottlenecks for speed. to increase global memory read speed, we allocate x and other auxiliary data types via the function cudamallocpitch(), thus automatically assuring aligned memory access. the random numbers are generated on the cpu. the data is copied between the cpu and gpu using standard cuda library functions.

RESULTS
we illustrate the timing performance of our approach using an extensive simulation study considering the t test statistic, for two-sample problems, the pearson test statistic, for continuous outcomes, and the cox rank score test statistic  <cit> , for censored time-to-event outcomes. the gene expression matrices are obtained by simulating n × k mutually independent and identically distributed standard normal variates where n =  <dig>  ...,  <dig> and k =  <dig>  for the two-sample case, the groups are drawn from a bernoulli law with mean  <dig> . for the continuous case, the outcomes are drawn from a standard normal law. for the time to event case, the expected censoring rate is set to  <dig> . the illustrations for the t and pearson test statistics are based on b =  <dig> permutations. the cpu approach for the cox rank score test statistic is prohibitively slow for large problems. for  = , an analysis based on a mere b =  <dig> replicates takes approximately  <dig> minutes versus only  <dig> seconds on the gpu. the cpu/gpu execution time ratios along with the gpu times  are shown in figure  <dig>  it can be seen that the biggest speed increase is in the case of the survival test, where speedup factors of  <dig> can be observed. next, we illustrate an application of permgpu by conducting an analysis of the dcc  <cit>  data set. for this illustration, we limit our attention to finding genes associated with survival. the analyses presented here are based on gene expression profiles and survival data from n =  <dig> patients from this data set. the observed death rate is  <dig>   and the estimated median survival time is  <dig>  months. the biospecimens are profiled on the affymetrix genechip® human genome u133a  <dig>  array which profiles the rna using k =  <dig> probe sets. to conduct the analysis, we pre-processed the array source files  using the rma algorithm  <cit> . we tested the association between the expression level of each of the k =  <dig> probe sets with survival using the cox score test with b =  <dig> permutation replicates. in table  <dig>  we list the probe sets significant at most  <dig>  two-sided fwer level. in addition to the observed test statistic, the unadjusted and fwer-adjusted permutation p-values, and the gene symbol and description linked to the probe set are provided. using our gpu approach, the time required to conduct the analysis is about  <dig>  minutes while the corresponding time based on the cpu approach is about  <dig>  hours suggesting a time reduction factor in the order of  <dig> 

results from survival analysis of the director's challenge consortium for the molecular classification of lung adenocarcinoma  data are shown in this table. the arrays were pre-processed using the rma algorithm. the association between the summary expressions for each probe set and survival were tested using the cox score test with b =  <dig> permutation replicates. probe sets significant at the two-sided fwer level of  <dig>  are listed. the test statistic, permutation unadjusted and fwer adjusted p-values are denoted by t, , and  respectively. the gene symbol and description linked to each probe set was obtained from the bioconductor hgu133a.db  annotation package.

discussion
although we have limited the discussions to three tests, our approach can be applied to most tests used for analyzing high-dimensional data. currently, our code also implements the wilcoxon, spearman and cox score statistics, and can be extended using other test statistics including the family of score tests. the existing six test statistics can be used as a starting template. this may not be the most computationally efficient approach. it may however serve as an appropriate reference point. as in the case of the existing six test statistics, the most efficient code for any given test statistic must take full advantage of the computational resources offered by both the cpu and gpu and therefore should most likely consist of a combination of kernels and functions.

permutation resampling to control fwer is one approach to address multiple testing for high-dimensional data. our method can be easily extended to use the bootstrap via resampling with replacement. the false-discovery rate   <cit>  is another framework for adjusting for multiplicity. our framework can be modified by omitting the calculation of the fwer adjusted p-values and applying any fdr algorithm to the unadjusted permutation p-values.

in many studies, including shedden et al  <cit> , the primary interest is not the identification of significant features but rather the building of predictive models. it is neither appropriate nor practical to build the model using all features. feature selection is typically used to identify, from the training data, a set of features, which are marginally important based on some criterion. note that the feature selection needs to be redone for each cross-validation training set. our framework can be customized to speedup the feature selection by recomputing the test statistic tk based on the training set.

it may be argued that for microarray data sets the permutation analysis only needs to be done once and that the gain in speed is not practically important. in practice, however, one does not carry out a single analysis but rather a series of analyses to assess the implications of using a specific test statistic or pre-processing method. as a case in point, consider the analysis of the dcc data based on the cox score statistic. as illustrated in  <cit> , the test procedure is robust with respect to the survival distribution, but is not robust with respect to the marginal distributions of the gene expressions and is thus sensitive to outliers. the cox rank score statistic  <cit> , already implemented by permgpu, can be used to conduct a robust analysis. if considerable discrepancies between the sets of results from these two test statistics are observed, then one may need to be concerned about the presence of outliers in the microarray data. furthermore, as pointed out in  <cit> , microarray association analyses are sensitive to the pre-processing method used, especially in the presence of batch effects or outliers. for example, the dcc data set is comprised of specimens and clinical data provided by four institutions. thus, one should be concerned not only about batch effects among the four sets of arrays but also about differences among the study populations and treatments. the conduct of, say, three additional analyses will bring the total time expenditure to almost  <dig>  days in contrast to  <dig>  hours on the gpu.

finally, as illustrated in  <cit> , for power and sample-size calculations, the permutation analysis needs to be repeated n times. our approach can be extended to accommodate this type of analysis. for  =  and b =  <dig>  our gpu pearson algorithm takes about  <dig> seconds. a power analysis based on b =  <dig> and n =  <dig> would then be expected to take less than  <dig> hours. since the projected speedup time factor for this case is about  <dig>  the expected time for completion on the cpu would exceed  <dig> days.

CONCLUSIONS
a cuda based implementation for deploying gpus in rna microarray association studies has been presented. our implementation can be customized by incorporating other statistical tests and scales readily with gpu cores. an extension for incorporating our framework into the r statistical environment has been developed. dramatic increase in speed in comparison to an optimized c/c++ code was demonstrated. the increased speed becomes more pronounced when the test statistic is computationally complex or the data set size is large, which makes our algorithm ideal for handling large genomic data sets. this is a practical framework that can be easily implemented using relatively inexpensive hardware.

availability and requirements
• project name: permgpu

• project home page: http://code.google.com/p/permgpu/

• operating system: linux amd64

• programming language: cuda, c/c++ and r

• other requirements: cuda sdk and toolkit  <dig>  or higher; gcc/g++  <dig> .2; r http://www.r-project.org  <dig> .1; biobase http://www.bioconductor.org  <dig> .1

• license: gpl v3

abbreviations
cpu: central processing unit; cuda: compute unified device architecture; gpl: general public license; gpu: graphics processing unit; fdr: false discovery rate; fwer: family-wise error rate; gtx 280: nvidia geforce gtx 280; mpi: message passing interface; openmp: open multi-processing; rna: ribonucleic acid; sdk: software development kit.

competing interests
the authors declare that they have no competing interests.

authors' contributions
ids conceptualized the research, designed, programmed, optimized and tested the algorithm, and drafted the manuscript; s-hj contributed to the research and critically revised the manuscript; slg contributed to the research, provided funding and critically revised the manuscript; ko proposed and conceptualized the research, and drafted the manuscript. all authors read and approved the final manuscript.

supplementary material
additional file 1
supplementary material for: "permgpu: using graphics processing units in rna microarray association studies". the compressed tar archive contains the source code for the examples discussed in "permgpu: using graphics processing units in rna microarray association studies" by shterev et al. it also contains a tutorial for compiling and executing the code. the development version of the code is available for download from http://code.google.com/p/permgpu/.

click here for file

 acknowledgements
the authors thank a reviewer for comments and suggestions, which substantially improved the manuscript, and thank john pormann and tom milledge of the duke scalable computing support center for providing gpu support. partial support for this research was provided by grants from the national cancer institute .
