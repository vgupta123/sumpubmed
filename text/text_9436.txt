BACKGROUND
a phylogenetic tree is a description of the evolution process which is discovered via molecular sequencing data and morphological data matrices  <cit> . computer science tools have upgraded the capabilities of biologists for their construction as well as for extracting and analyzing the implicit biological messages embedded in them  <cit> . nowadays, more and more applications rely on the existence of a support phylogenetic tree for the confirmation of biological hypotheses that are valuable for the scientific community. for example, a small but representative portion of these researches combine phylogenetic trees  with fossils, geographical or phenotypical data in order to find any mismatch, to trace the human migrations  <cit>  and to inspect the distribution of endemic diseases  <cit> . in this sense, they use a phylogenetic tree for testing biological hypotheses about evolution in a similar way to  <cit> . indirectly, the evaluation results and counterexamples help to feedback the phylogeny and increase its quality. however, the wide range of diverse methods and tools used by biologists for studying phylogenetic properties recommended the research of a generic framework for heterogeneous hypotheses testing over trees.

model checking is a paradigm stemming from computer science based on temporal logics which has been successfully applied in industry for system modeling and verification  <cit> . the basic principle allowing the use of the model checking framework in the context of phylogeny is the interpretation of the phylogenetic tree as a transition system representing a computational model of the evolution process, i.e., a rooted directed acyclic graph describing the potential behavior of a discrete system whose paths indicate a sequence of intermediate states and the transitions are speciation events. the next step consists of formulating the hypothesis that we desire to investigate over a phylogeny using temporal logics as a formal language. finally, a model checking tool automatically verifies the satisfaction of the property over the model in an exhaustive way.

model checking has been recently proposed as a generic unifying framework that allows the phylogeneticist to focus on tree structures, biological properties and symbolic manipulation of phylogenies described using temporal logic, instead of on implementation issues concerned with verification algorithms  <cit> . the model checking framework helps us to uncouple software tools from the formal definition of models and the specification of properties. besides, it hides the underlying implementation technology to final users, enabling transparent software upgrades of the model checking tool and removing debugging and programming language concerns through different platforms  <cit> . standard branching-time temporal logics such as computational tree logic  already allow expressing biological properties referred to the structure of the tree or the arrangement of dna sequences along the paths  <cit> .

in this paper, we repair the limitations of the previous model checking approach using standard temporal logics. some of the phylogenetic hypotheses require a more powerful language for being described, i.e., it is necessary to extended the models and specification logics with explicit time and probabilities. evolution is a continuous-time and stochastic process where the branch length of a phylogeny represents time, and the distribution of biological features is non-deterministic along the whole tree. one of the potential applications of probabilistic model checking is the study of the dispersion of lactose intolerance among populations and the temporal point when it appeared in the tree  <cit> . the objective is to tolerate more flexibility and expressiveness in the specification of properties.

explicit time and probabilities are not directly supported by qualitative logics, but they can be included in the specifications of a probabilistic transition system using discrete  or continuous-time logics . much more logics have been proposed according to different metrics and time models  <cit>  , although we will focus on cslta here. the interpretation of this kind of specifications requires the modification of the traditional transition system and the algorithms that traverse them. the models must be enlarged in order to support these new informations.

more in detail, we present and classify a more complete description of phylogenetic properties that are intrinsically stochastic by nature. our aim is to show that an extended model checking framework is suitable for solving temporal and probabilistic problems in the domain of phylogenetics. current probabilistic model checking tools are generic and powerful enough for our proposal. other tools such as phycas  <cit> , revbayes  <cit>  or beast <dig>  <cit>  are focused on solving a set of specific problems while our approach can answer a wider range of questions.

the advantages of applying the probabilistic continuous-time extensions of model checking techniques for evaluating phylogenetic specifications are twofold: a) it is possible to verify if a property is true or false according to some temporal requirements and the probabilistic behavior of the model and b) it is also possible to obtain the minimum probability that makes the specification true within an interval of time. in order to show the feasibility of our approach, we apply our framework to a specific problem: the probability of obtaining a phylogeny with a certain topology. specially, we focus on the computation of maximum likelihood estimations  for a phylogenetic tree using models of dna evolution, that simulate the changes in the genome through the time.

the paper is arranged as follows. the next section “methodology” introduces the main notions of evolution and explains how it is modeled under the model checking framework. besides, the logical specification of nontrivial phylogenetic properties is described. the logic presented in this section is used for evaluating stochastic properties and the likelihood of phylogenetic trees in the case of study. section “results and discussion” introduces the methods for managing continuous-time and probabilities in model checking and current probabilistic verifiers. after that, the case of study with maximum likelihood of a phylogenetic tree, and the experimentation details are presented. the key steps for implementing phylogenetic trees and biological properties within the scope of the prism tool is presented. finally, section “conclusions” gathers the conclusions drawn from this research and details the future work.

methodology
analyzing models of evolution with probabilistic model checking
the process of model checking is divided in three phases. the first part consists of a correct modeling of the system. next, a set of properties are written using a specification logic. finally, a model checking tool takes the description of the model and the hypotheses, and analyze them in an automatic and exhaustive way. the quality of the analysis is influenced by the identification of the main characteristics of the system during modeling. to this end, the next paragraphs present the principal keystones that we try to capture of the evolution model and how they are translated into a computational model  suitable for the study.

evolution as a transition system
evolution is an infinite-time, not-ending process that keeps introducing new traits and species forever. it can be modeled at different levels of abstraction. depending on the aspects we focus on, evolution can be simulated by: 
topological models. birth-death markovian models describe the macroevolution process of speciation  <cit> . they are usually used for the generation of random trees fulfilling the topologies and structural characteristics that are supposed to appear in correct phylogenies. they provide a skeleton  regardless of the internal details of the tree states. these trees would be later enriched by complementary information . these trees, or those constructed by inference or maximum parsimony methods  <cit> , are used as initial seed in subsequent problems, for example, for the tree exploration phase during the evaluation of the maximum likelihood estimations  <cit> .

sequence models. on the other hand, the genome constitutes nowadays one of the most important traits of a species for its study. models that describe the modification of protein or dna sequences through time provide finer details about the genetic changes operating behind the macroevolution models. these models nuance the process from which a sequence of characters switches into another one. in short, the sequence models capture how the genomic information is placed in each state of a tree inferred from a speciation model.



often, the phylogeneticists identify the nucleic changes as the main source of the macroevolution process and then associate the notion of evolution history to the concept of mutation trace. hence, dna mutation models are commonly referred to as the true tree generators or phylogenetic models in the literature: the phylogenies arise as the result of a spanning simulation of these mutation models embedding the complex process of speciation. at this point, it is not surprising that biologists try to match the tree of life that they inferred from an input alignment and reconstruction method with the execution of an instance of a dna mutation model that could generate it. figure  <dig> illustrates a simple mutation model where state si represents a nucleotide at a certain position of the sequence and it has a probability pij of changing to state  sj. some probabilities are omitted for readability.
fig.  <dig> model of dna mutation



in the context of molecular evolution, the phylogenetic tree would indicate a reachability graph or execution trace of the system, that is, a snapshot capturing the order of occurrence of the mutations along the history of the speciation process since the beginning of time until present day. therefore, a phylogenetic tree will reflect how the mutation model should act, showing the consecutive changes in a long-term run of the model. in other words, the phylogeny represents the behavior of the system, understood as a computational process modeling the hypothetical flow of the dna during the time.
fig.  <dig> unfolding of a dna mutation model in a phylogenetic tree



in a computer science context, both speciation models and phylogenies are two faces of the same coin and they can be used as computational models expressing the behavior of evolution . later on, a set of properties are studied over the model using an adequate description language such as temporal logics. a temporal logic allows, using a certain symbolism and rules, reasoning about propositions qualified in terms of abstract time . this kind of logics focus on the information stored in the states and the relationship among the nodes. for example, it is possible to declare questions such as “eventually in the future, a mutation of σ to α happens in a branch of the tree”, or “generally, position i is conserved in this haplogroup or subtree”. a verifier takes the propositions expressed in temporal logic and a model described as a transition system, and tells if they are true or not for this particular context. it explores the reachability graph in an automatic and exhaustive way.
fig.  <dig> probabilistic model checking framework in phylogenetics



markov chain as a data structure
in probabilistic model checking, the computational models are probabilistic transition systems . by default, topological and sequence models are markov chains whose structure and semantics matches directly with ptss. for example, the simpler models of evolution leading to the introduction of mutations in the genome are a four-state markov chain with different probabilities for the transitions among nucleotides  <cit> . commonly, they are parameterized templates indicating the ratios and relations between bases. several versions of dna mutation models have been proposed in the literature. by now, there are highly optimized models for specific purposes including the special biochemical features of the nucleotides such as physical-chemical stability of the strands.

markov chains accept either discrete  or continuous  time in the modeling, thought continuous-time is more suitable for capturing finer temporal details of the evolution. instead of describing explicitly the probability of change from one state to another, the transitions are labeled with rates delimiting the time spent in that branch.

definition <dig> .
a continuous-time markov chain  is a finite transition system represented by a tuple m=, where: 
s is a finite set of states,

s0⊆s is the set of initial states,

r⊆s×s→ℝ≥ <dig> is the transition rate matrix between states, i.e., for every pair of states s,s′∈s, a transition occurs only if r> <dig>  and the probability of this transition being triggered in t time units equals 1−e−r·t, and

l:s→2ap is the labeling function that associates each state with the subset of atomic propositions  that are true of it.



an atomic proposition is a declarative statement telling the properties of a state of the model. it may cover several aspects of the evolution , thought the simpler one is the nucleic value. for instance, the set of atomic propositions assigned to the states in fig.  <dig> corresponds to the nucleic values of the genome in those points.
fig.  <dig> translation from a phylogenetic tree to a probabilistic transition system



as there exist multiple pair candidates with r> <dig> outgoing from state s, a race condition appears and the selection of the next state determines the history of events. a higher value of r prioritizes the transition between s and s′. if all the successors share the same ratio, the transitions are equally probable. the elapsed time before triggering affects the probability of a transition.

the computation of probabilities depends on the paths starting in the initial state. given an infinite path of successive states π=s0s1s2…, π=si, while π returns the state si of the path in which the system is found after t∈ℝ≥ <dig> time units since the initial state s <dig> =s0). for any set of infinite paths Π starting in the initial state s <dig>  the subset Π selects the paths π∈Π whose prefix equals to the finite sequence πn=s0s1s2…sn of length n+ <dig> states.

the likelihood of reaching a state sn is determined by the probability measure pr)=pr) over all the paths sharing the prefix πn with πn=s <dig>  for the trivial case over Π, pr)= <dig>  in general for Π, pr)=pt. starting in s, the probability of arriving to a state s′ at a particular time instant t is represented by pt=pr{π∈Π | π=s′}, with pt an exponential matrix indicating the transient probabilities for time t and q the infinitesimal generator matrix of m: 
 pt=eq·t=Σi=0∞ii! 

the infinitesimal generator matrix q is used for the calculation of transient states and it is defined as: 
 q=rifs≠s′−Σs′′≠srotherwise 

an alternative and more stable standard technique for calculating the probability matrix pt is presented in  <cit> .

assuming that phylogenetic trees are the state spaces produced by the executions of evolution models, they are also accepted as ptss and markov chains. each transition connecting two nodes of the tree has the same information, probability and temporal requirements than the transition connecting an equivalent pair of states of the evolution model. self-loops with unitary probability are printed in final states of the tree to produce infinite traces of present-day taxa because of uncertainty of future traits and species . this trick is necessary for evaluating temporal properties and imposing conditions for the mathematical resolution of probabilities. the theoretical concepts, logics and tools will be detailed in the following sections.

specification of phylogenetic properties over phylogenies
during the last years, new formalisms and tools have started to accept properties expressed in probabilistic temporal logics for capturing and analyzing the underlying randomness of stochastic systems. probabilistic model checking combines the expressiveness for representing paths of a computational model using temporal logics with the calculation of likelihoods associated to the route. our objective is to enrich the original applications presented in  <cit>  with probabilities and explicit time in order to obtain a more flexible framework capable of solving complex problems.

continuous-time probabilistic logic as a specification language
once the data structure and semantic of the model are defined, the next step involves the presentation of the syntax and semantics for the stochastic temporal logic. the logic proposed here for working with ctmcs is cslta  <cit> .

definition <dig> .
a temporal logic formula ϕand a path formula Φare defined by the following minimal grammar, where p∈ap, λ∈ <cit>  is a real number denoting a probability, and ∼ in {<,≤,=,>,≥} is a comparison operator: 
  <dig> ϕ::=true|p|¬ϕ|ϕ∨ϕ|ℙ∼λΦΦ::=xϕ|ϕuiϕ 

the formulas are checked against a structure m considering all paths π emerging from a state s <dig>  notice that m,s0⊨ϕ means that s <dig> satisfies ϕ. the semantics of well-formed formulas is as follows : 
m,s0⊨p⇔p∈ls <dig> 

m,s0⊨¬ϕ⇔m,s0⊮ϕ,

m,s0⊨ϕ∨ψ⇔m,s0⊨ϕ or m,s0⊨ψ,

m,s0⊨ℙ∼λΦ⇔prob∼λ,



the calculation of the probability prob requires the identification of the set of infinite paths π satisfying the path formula m,π⊨Φ: 
m,π⊨xϕ⇔m,π <cit> ⊨ϕ

m,π⊨ϕuiψ⇔ for some t∈i, ∃π:m,π⊨ψ, and m,π⊨ϕ for all 0≤t′<t with i an interval of reals.



the set {π∈Π|m,π⊨Φ} is obtained by the union of finitely many pairwise disjoint subsets Π by , each one characterized by the finite prefix πn of all infinite sequences of the set satisfying Φ. therefore, the probability function prob is computed as the summation of probabilities in all possible prefixes πn by . that is, prob=Σπnpr) where pr is a specialized function for obtaining the probability of the path defined by πn. the calculation of the probability will be detailed in a further section.

in qualitative branching-time logics such as ctl, every path formula imposes a reachability relation or patterns among all the states that satisfy some propositional requirements. that is, they define sequences of events that must be found in the model. ctl reinterprets the quantifiers of first-order logic as path quantifiers, expressing the fulfillment of a property throughout all computation paths , or at least exists one computation path . these two must be immediately qualified by one of five temporal operators, of which three express the satisfaction of a property eventually in a future state , generally at all states , or in the next state ; and two are conditional constructs in which a precedent is verified until a consequent comes into force , or until and including the moment when it does, if it does . a complete grammar and semantics of ctl formulas can be defined from a minimal subset of logical operators  <cit> .

in probabilistic temporal logics, path quantifiers are substituted by probabilistic operators. the satisfaction of a propositional over all  paths is equivalent to maximize the expected probability . the existence  of at least one path imposes the probability to be greater than zero . figure  <dig> describes graphically the basic semantic.
fig.  <dig> evaluation of probabilistic temporal logic operators



cslta supports timed transitions in the u operator. timed variants of the modal operators f and g are obtained via u as fiϕ=trueuiϕ and giϕ=¬fi¬ϕ. instead of writing probability and intervals explicitly, they can be abbreviated with inequalities. for example, ℙ≤ <dig> Φ denotes ℙΦ. this temporal extension constrains the length of the computational path specified in the logical equation. the operator x implicitly takes the real time elapsed for a consecutive branch of the current state. by now, phylogenetic properties querying about the structure of the tree or mutation traces can be expressed in cslta.

sequence properties
in a non-probabilistic temporal logic, it is already possible to query a wide range of questions about the arrangement of the nucleic information in the states of the tree  <cit> . however, what we look for here is the addition of probabilistic information to the specifications. for instance, a preliminary probabilistic study focused on lactose intolerance within humans  <cit> : it identifies the haplogroups having a higher concentration of snp’s associated to this disease in the leaves of the phylogenetic tree.

in a similar way to evolution models, phylogenetic properties can be classified as sequence properties or topological properties depending on the information they extract from the phylogeny. in general, sequence properties are based on the content of the states, i.e., those propositions that are evaluated within a node and without need of temporal operators. usually, they are composed of simple patterns whose application scope is restricted to the surrounding nodes or the entire phylogeny. such types of state formulas are called patterns, being p the propositions that must be true and t an optional temporal parameter . they provide a powerful descriptive formalism for formulating general restrictions without the limitations of ad hoc approaches. often, these properties may be used not necessarily to forbid patterns, but as queries and alerts to signal unusual, possibly anomalous behavior, and mark it for further study.

patterns in the genome. a first group of patterns represents global correctness constraints that are supposed to hold across the whole phylogeny. they can be categorized as follows: 
conservation is modeled as a restriction on the symbols that can occur at a given position in a sequence. commonly, the pattern is codified according to a set of permissible symbols. it is possible to define general families of compatible elements, not bounded to specific positions, and restrict their usage to exactly one of these positions when needed.

covariation imposes a relation of dependence between two  positions in a sequence due to some physical-chemical constraints or the internal structure of the genome. it represents the set of symbols that may appear in the second place in association to each symbol in the first place.



a global  pattern thus defined is easily verified by extending it over the computation tree. 
 globalp,t≡ℙ≥1g≤tp 

the variation of the probabilistic parameter determines the scope  of the pattern over the complete state space. lineage-specific haplogroup verification represents a further step forward, where patterns would be used to define conditional explorations of the sets of states of interest of the phylogeny.

deleterious mutations. exceptions to the aforementioned properties may in fact indicate suspicious or potentially deleterious mutations, which are of great interest in applied phylogenetic studies  <cit> . furthermore, known or suspected mutations of this kind can be explicitly modeled as patterns and their positioning in a phylogeny assessed. in particular, those affecting important metabolic functions are expected to prevent or hinder the reproduction of the organism, and consequently should be confined in or near terminal leaves.

observed and feasible deleterious mutations may be permitted subject to certain restrictions. specifically, it may be demanded that, if a hazardous pattern p appears, it has no offspring, i.e., it is a leaf in the phylogeny; or, to provide some flexibility, it may be allowed that all descendants, if any, are reached in at most time t . 
 terminalp≡ℙ≥1gp⇒leaf  terminalp,t≡ℙ≥1gp⇒ℙ≥1f≤tleaf 

in this case, leaves  must be detected without reference to any particular sequence. this is easily achieved by performing an equality comparison between the valuations of ap of the target state and all its successors. 
 leaf≡∧prop∈app⇔ℙ≥1xprop 

point mutations. point mutations, reversions and parallel or convergent evolution of sequences are properties that are arranged over local paths of the tree. thus, they need access to the topological structure of the tree in some sense. it is reasonable to start considering a relatively simple properties based on a tree topology and an associated sequence alignment, exemplified by a point mutation. for legibility and compactness in the following example, we will refer to the atomic propositions s=σ  of a state as σi . suppose for now that the alignment comprises a number of characters indexed  <dig> through l, sequences s are words of length n over an alphabet Σ, and s=σ  means that σ∈Σ appears  in position i in a state sequence . a point mutation is represented by the equation: 
 ℙ≥λσi∧xαi  which tells whether σ is replaced by α at position i in the next state with a probability greater than λ.

back mutations. it is possible to determine whether a given tree is free of back mutations or reversions, which we abbreviate bm. given an internal node, there is a back mutation in that subtree involving a position j of the alignment if at some point in some descending path from the node we find a different symbol  than that found in the root of the subtree . then, at some point in the subtree hanging from that intermediate the symbol from the root reoccurs.

the formula must model this condition by nesting f operators: a node satisfies a property which a) eventually some other descendant does not satisfy, but b) it is fulfilled once again at some point in the future. the check is repeated for every symbol that may occur in the node. 
 hasbmcol≡∨σ∈Σσcol∧ℙ>0fσ¯col∧ℙ>0fσcol 

finally, the global formula detectbm iterates the check over the positions of the alignment and extends it to all tree nodes. 
 detectbm≡∧j=1lℙ≥1g¬hasbmj 

in these two formulas we present a non-trivial modeling example of a cladistic property with a heavy use of sequence data. the goal is to detect if the tree is free of back mutations . in the case of finite domains, such as the set of dna sequences, the evaluation of logical quantifiers ∀ and ∃ can be substituted by multiple instances of boolean formulas connected by the ∧ and ∨ operators. in sum, we have formalized the concept of back mutation in probabilistic temporal logic. the addition of intervals refine the length of the paths in the property.

topological properties
identifying if a phylogenetic tree reflects the correct structure of the evolution is one of the most important topological questions. given a phylogenetic tree inferred from an alignment, it should be compared to the speciation model that we use as reference, for instance, a dna mutation model. the computation of maximum likelihoods quantifies the fitness or probability that the topology obtained by the alignment follows the same trace imposed by a mutation model  <cit> .

due to the uncertainty of the true evolution process generating the tree of life, the estimation of maximum likelihoods works as a metric for comparing the topology of two or more trees built over the same data set . the selection of other inferred phylogenies, alignments or alternative dna models modifies the probabilities of the arrangements and returns different scores  <cit> .

the computation of the likelihood score is carried out by the following formulas, which will be later composed as logical equations. at position l of a sequence with length n, the probability of changing from nucleotide i in state x to nucleotide j in state y is denoted by the probability function pij. the variable dxy indicates the branch  length between the states x and y, which is a positive value for each pair of connected nodes. equation  <dig> corresponds to the overall likelihood for the tree in fig.  <dig>  the probability function pij depends on the selected mutation model  <cit> . this probability function is determined by the model checking tool by analyzing the transitions of the mutation model that it uses as computational model. the expression z denotes the base of the dna in taxon z at position l. the constant fi is the theoretical frequency of the base i in the alignment, which is dependent of the mutation model. 
  <dig> ll=Σi={a,c,g,t}Σj={a,c,g,t}fipijpizpjrpjs 

equation  <dig> can be factorized as the combination of the likelihood of the left and right subtrees in order to avoid the recalculation of the same subformula multiple times: 
  <dig> lxl=Σi={a,c,g,t}lx,il 

  <dig> lx,il=Σjpijly,jl·Σkpiklz,kl 

normally, the dna of present-time taxa in the leaves of the tree has maximum likelihood . in opposition, the nucleic bases of the internal nodes are unknown and they shall be inferred with the mentioned formulas. due to the uncertainty in the genome of the ancestral states, the estimation of the likelihood in x at position l implies the summation of lx,il for all the possible nucleotides. the evaluation of the likelihood equation at the root node returns the score lroot for the whole tree. the likelihood value of a complete genomic sequence corresponds to the product of the likelihood values of every position since we assume that sites evolve independently of each other. logarithms over lroot are regularly used because of the small likelihood values. 
  <dig> lrootl=Σi={a,c,g,t}filroot,il 

  <dig> lroot=Πl=1l=nlrootl 

nevertheless, the search for the tree with maximum likelihood requires the evaluation of a considerable number of equations over a great tree space, which converts the searching process using scores in an np-hard problem  <cit> . despite the storage of partial solutions , more heuristics must be introduced in order to gain feasible solutions.

extra simplifications consist of a) the propagation of the local maximum lx,il instead of the four internal values lx,il and b) the assignation of a preliminary character to the internal ancestors of the phylogenetic tree . the main drawback of these approaches is the extraction of a local maximum instead of the real solution. the selection of the initial seed and the intensive sampling method of the tree space determines the quality of the approximation to the real likelihood value for the phylogeny  <cit> .

in section “case of study: maximum likelihood of a phylogenetic tree” we show how a model checking tool can test and compute the reliability of a tree according to the defined mutation model. the mathematical equations of mle for evaluating the phylogeny are rewritten using probabilistic temporal logics. later, they are executed over a ctmc chain corresponding to a dna mutation model. finally, the model checking procedure queries whether the probability of appearance of a particular mutation in the tree is over or not a predefined threshold. the evaluation of the cslta formulas needs the procedure for computing probabilities introduced in the next section.

RESULTS
algorithm and tools for model checking
the evaluation of biological hypotheses qualified with probability and time requires the extension of the traditional model checking algorithms  <cit> . the first point of this section is devoted to the introduction of functions and numerical equations for solving the quantitative part of the formulas, which is the main difference with respect to previous model checking algorithms. the second point focus on the tools implementing this extension.

algorithm for cslta
given a pts and a cslta formula ϕ, the model checking problem consists of identifying the set of states where ϕ is valid. the basic procedure implies a recursive computation of the state set sat for all the states satisfying ϕ. the model checking algorithms for solving cslta formulas are mainly identical to those of classic model checking  <cit>  except for the resolution of probabilities in ℙ∼λ. in short, the recursive algorithm of probabilistic model checking incorporates the new sentence: 
 sat={s∈s|prob∼λ} 

the computation of the prob function sometimes requires a discretized version of the ctmc. the embedded discrete-time markov chain  is the same tuple m  but replacing the transition rate matrix r by a transition probability matrix p whose values are: 
 pemb=reife≠01ife=0ands=s′0otherwise 

e is known as the exit rate of state s. it is defined as the summation of every output transition rate r: 
 e=Σs′∈sr 

the value e= <dig> means that s is an absorbing state or siphon. the path probability for each path operator is now calculated as follows.

ℙ∼λ formula.
in cslta, the next operator has no sense as in continuous-time there is not an unique next real number. this operator is included for compatibility. it detects if any direct transition between a state s and a successor s′ has probability pemb∼λ in the embedded dtmc.

ℙ∼λ formula.
the computation of the probability for the until operator depends on the value of the interval i. generally, the interval i is classified as: 
i= with t∈ℝ≥0;

i= with t,t′∈ℝ≥ <dig> and t≤t′;

i= with t∈ℝ≥ <dig> 



for the case of i = , the probability prob is equal to:   <dig>  if s∈sat  <dig>  if s∈sat or t=0Σs∈sats′∈satpt, otherwise

when i= , then prob=prob,s,ψuϕ). it is calculated indefinitely as follows until a stop condition is reached : 
 prob,s,ψuϕ)=Σs∈sats′∈satpemb·prob,s′,ψuϕ) 

the embedded dtmc must be free of loops  of intermediate states so as to have a finite and solvable numerical equation system.

when i= , the until operator must consider a) the time t spent in states satisfying ψ plus b) up to time t′−t required for reaching ϕ. the first part can be compared to fψ and the second part corresponds to ψuϕ: 
 prob=Σs∈sats′∈satpt·prob 

the last case i=  is similar to the previous i=  but changing ψuϕ by ψuϕ due to the infinity. as the until operator is unbounded, it is evaluated in the embedded dtmc: 
 prob=Σs∈sats′∈satpt·prob,s′,ψuϕ) 

the temporal complexity of verifying a cslta formula ϕ against a ctmc is linear in the number of logical connectives and temporal operators of the formula  and polynomial in the size of s. more generally, the complexity is: 
 Θ)∗q∗tmax∗|ϕ|)  where tmax is the maximal bound of a path subformula ψ1uiψ <dig> of ϕ, with tmax= <dig> if it doesn’t contain any u subformula. the parameter q is equal to q=maxs∈s|q|.

model checking tools
a model checking tool or verifier requires two input files for the verification process: a first file with the description of the model, and a second file with the specification of the properties. traditionally, it returns if the specification is satisfied in the model or not, and a counterexample that falsifies it if required. in probabilistic model checking, extra information shall be provided such as the minimum probability for which the property succeed.

the modularity and independence of model and specifications allow the evaluation of several properties over the same model and, vice versa, the test of the same phylogenetic requirements over different computational models. the encapsulation of the underlying technological implementation details  is one of the most important features of this kind of tools. the main advantages of the model checking framework are the abstract description of model and properties using logics and mathematical formalisms, and the portability of these files between computers that have installed the same model checking tool.

there exists a considerable diversity of verifiers with different performances, qualities and designs  <cit> . among all the model checking tools developed for probabilistic systems, prism  <cit> , mrmc  <cit>  and cadp  <cit>  are the most important ones.

in our case, we have selected prism for the experimentation for several reasons. prism is a generic state-based model checking tool capable of handling probabilistic and timed specifications over markov chains. prism offers java portability, a powerful syntax for handling time and probabilities in models and specifications, and a good scientific community support. besides, it is open source, which allows the modification and optimization of its code. the real performance depends on the particular structure of the model and specifications. this fact is shown in the example of case of study.

case of study: maximum likelihood of a phylogenetic tree
formal methods help for describing mutation models and evaluating properties over phylogenetic trees. among all the potential applications, we focus on the problem of analyzing the statistical probability of a phylogeny. maximum likelihood is one of the most common methods for phylogenetic inference. given a mutation model, it scores the quality of the topology for a inferred tree. however, the incorporation of new models into current software tools requires an expertise in programming languages and a deep knowledge of the source code. this fact limits the extension, upgrade, debugging and maintenance of a software tool with new models defined by the biologists.

to this end, we show how to define a tree and a mutation model using the description language of cslta and ctmcs. a phylogenetic tree is formulated as a succession of nucleotide mutations that are checked over a mutation model. the verification process returns the likelihood of obtaining the tree from a particular model. we have analyzed several phylogenies using the prism model checking tool. in addition, we have adapted the software for optimizing the computation of maximum likelihoods.

translation to prism
our framework plays the role of worker for computing the maximum likelihood during the evaluation of the tree topology in current inference algorithms and tools . the model checking tool returns a confidence value between  <cit> , which represents the likelihood of getting a peculiar arrangement of nucleotides in the states of the tree with respect to a model of mutations. the score provided by the result of the verification process is useful for guiding the iterative refinement of the phylogenetic tree. our tool requires an external tree generator.

the model checking tool requires as input a) a description of the dna mutation model, and b) the specification of the tree in terms of likelihood equations. figure  <dig> corresponds to the file describing the mutation model over which the phylogenetic tree will be evaluated. by changing the relations and the ratio of transitions, it is possible to switch from one mutation model to another. the logic selected for specifying properties and the abstract language for describing markov chains improve the legibility of the system and make the maintenance easier. prism provides an user-friendly textual language for writing the model and equations.
fig.  <dig> description of the jukes-cantor model in prism syntax



the computation of the probability is model-dependent. some of the historical mutation models are jukes-cator , kimura, felsenstein or the generalized time-reversible   <cit> . for simplicity in this example, we consider the jc model. the substitution rate nu equals to  <dig>  it expresses the number of ticks needed for the activation of the transition rather than an explicit probability.

the translation of the mathematical equations to the syntax of the stochastic logic supported by prism is exemplified in fig.  <dig>  it corresponds to the mle equations defining the tree of fig.  <dig>  the conversion is dealt by a bioperl script  <cit> . the unfolding of these equations depends on the structure of the phylogenetic tree and the genome placed in its tips. in an indirect way, the equations specify the structure of phylogenetic tree with respect to a dna mutation model: they depict the trace of mutations from the root to the leaves.
fig.  <dig> representation in prism syntax of the mle equations for fig. 4




besides asking for a particular bound, prism includes iterative methods for calculating maximal  probabilities of a path of the tree. for example, the operator p=? returns the probability of reaching a nucleotide a at position x <dig> of the alignment within  <dig> time steps in the future. it is equivalent to ℙ=? in cslta syntax, but ? is the threshold calculated by the model checking tool instead of an explicit probability.

prism allows the specification of the initial state. for example, filter returns the minimum probability taking the sequence x <dig> = c as the initial state. it ensures that there exists a path starting in x <dig> = c that eventually reaches x <dig> = a. the properties are annotated with names for defining the partial likelihoods lx,il. in case of phylogenetic trees with estimated nucleotides in the ancestors , the intermediate nodes are initialized with constant values lx,il= <dig> or lx,il= <dig> for reducing the initial calculations. the header of the file describes the notation of the variable names. the constant dxy is the distance between states x and y.

however, the current release of prism does not store the partial results lx,il in local memory, which implies a reevaluation of lx,il every time it is accessed. the inability for caching these values damages the potential optimization caused by the factorization of the probabilities pij in eq.  <dig>  this peculiarity, together with the inherent delay introduced by the java virtual machine, penalizes the performance in comparison to other specific systems for computing maximum likelihoods  <cit> . in order to solve this problem, we have modified prism for caching the partial results lx,il. applying this simple change, the model checker slightly improves its performance.

experimentationfig.  <dig> time required in prismopt for the evaluation of the maximum likelihood equations



all tests have been run on a intel core  <dig> duo e <dig> @  <dig>  ghz with  <dig> gb ram and linux. memory is not a limiting factor because the experiments have been successfully executed with only 4gb assigned to the java virtual machine. the factorization of the equations and the initialization cost in prism are delays that must be considered for the judgment of the results.

the exponential trend observed in the graphic is explained by the exploration method selected by prism for calculating the probability function pij. in this way, prism unfolds the dna mutation model and generates all the possible traces between the bases i and j, applying implicitly an exhaustive searching method. prism looks for all the paths of n nodes with distance Σk=1…ndk=d that maximize pij, being i  the initial  state and dk the distance between each pair of intermediate states. the combinatorial exploration of the paths satisfying the previous restrictions of length and probability leads to the exponential cost for calculating pij.

we propose an alternative configuration of the equations in order to take advantage of the peculiar procedure in prism for managing probabilities. figure  <dig> shows this rewriting. now, exclusively the phylogenetic leaves are assigned with a dna value because they are the only values whose nucleic base we know with certitude. the internal nodes are left undetermined in the specification. the addition of the distances dxy+dyr marks the length of the path between the root and the leaf r. the estimation resulting from the evaluation of the formulas in fig.  <dig> places an upper bound to the real value of likelihood. each filter extracts independent paths with maximum probability, presumably giving rise to a set of disjoint routes whose only common ancestor is the root. although probably depicting a degenerated phylogenetic tree, it results in a suitable heuristic for pointing out the maximum likelihood.
fig.  <dig> rewriting of the mle equations for fig. 4



fig.  <dig> time required in prism for the computation of the upper bound of the maximum likelihood value



this framework becomes competitive for obtaining an upper-bound approximation for mle efficiently. future optimizations should focus on the implementation of more efficient libraries and dynamic programming techniques that solve, or at least ease, the aforementioned limitations and bottlenecks in prism.

CONCLUSIONS
model checking is a generic framework that has been applied for qualitative analysis over phylogenies. the main advantages of this approach are the legibility and soundness of formal methods based on temporal logics, the independence of the model from the specifications and the availability of powerful verifiers that automatically analyze the specifications and find counterexamples. besides, the encapsulation of the implementation in a model checking tool hides and simplifies the access to the underlying technology.

nevertheless, some phylogenetic properties are beyond the expressiveness of first-order temporal logics used in that environment. in this paper, we have completed the previous framework including explicit time and probabilistic information. to this end, we have applied stochastic extensions of the model checking framework for querying quantitative properties over phylogenetic trees and mutation models. the inclusion of explicit time and probabilities matches naturally with the speciation models. in this sense, we have introduced a stochastic logic, data structure and methods adapted for manipulating and computing probabilities over continuous-time systems. several quantitative properties have been specified.

in order to prove the feasibility of our approach, we focused on the problem of analyzing the statistical probability of a phylogeny. we have studied the likelihood of obtaining a phylogenetic tree through the evaluation of maximum likelihood estimations over dna mutation models. a phylogenetic tree is formulated as a set of paths using temporal logics . the verification process returns the likelihood of obtaining that tree from a mutation model.

we have shown how to translate the model and specifications to the particular notation of this framework. we have analyzed several synthetic  phylogenies using the prism model checking tool. a linear-time heuristic has been proposed for the calculation of an upper bound of the likelihood score. we have customized the tool in order to slightly improve the verification costs.

this work opens the door for the review of bigger systems with quantitative properties similar to those defined in this paper. the modularity of our framework allows the evaluation of hypotheses and the comparison of results for a set of phylogenetic trees by only changing the tree file . finally, the search for the valuations that verify a certain specification leads to an intensive exploration of the formula space or the solution of linear systems. the introduction of parametric model checking for the automatic discovery and mining of phylogenetic information outlines our future work.

abbreviations
ap, atomic proposition; bm, back mutation; cadp, construction and analysis of distributed processes; cslta, continuous stochastic logic with timed automata; ctl, computational tree logic; ctmc, continuous-time markov chain; dtmc, discrete-time markov chain; gtr, generalized time-reversible; jc, jukes-cator; mle, maximum likelihood estimation; mrmc, markov reward model checker; pctl, probabilistic ctl; pts, probabilistic transition system


we would like to thank the spanish ministry of economy  under the program “programa de i+d+i estatal de investigación, desarrollo e innovación orientada a los retos de la sociedad”, project id tin2013-40809-r, for supporting this work.

funding
this work was supported by the spanish ministry of economy  under the program “programa de i+d+i estatal de investigación, desarrollo e innovación orientada a los retos de la sociedad”, project id tin2013-40809-r. spe had no role in the design of the study and collection, analysis, and interpretation of data. spe did not contribute in writing the manuscript and the decision to submit the manuscript for publication.

availability of data and material
the synthetic data set used for the experiments was generated using the tree::randomfactory functions of bioperl  <dig> . <dig>  the scripts for translating the maximum likelihood equations into the notation of prism model checking tool are publicly available at github with doi http://dx.doi.org/ <dig> /zenodo. <dig> 

authors’ contributions
jmc designed the study. jir devised the algorithms, implemented them and conducted the experiments. jir wrote the manuscript. both authors read and approved the final manuscript.

competing interests
the authors declare that they have no competing interests.

consent for publication
not applicable.

ethics approval and consent to participate
not applicable.
