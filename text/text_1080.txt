BACKGROUND
boolean network  models are widely used in molecular and systems biology to capture coarse-grained dynamics of a variety of regulatory networks, with a particular focus on features such as steady state behavior  <cit> . one advantage of discrete models of this type is that, for small models, the entire dynamics can be explored by exhaustive enumeration of all state transitions. since the size of the state space of a boolean model with n nodes is 2n, this approach becomes unfeasible for larger models, those with more than approximately  <dig> variables, depending on the computational resources available. also, for larger models, finding steady states  through sampling is not effective anymore either, since even large attractors can be missed entirely by this approach. on the theoretical side, it has been shown that the problem of finding, or even counting, steady states of boolean networks is np-hard  <cit> , so that any algorithm for this problem will eventually encounter serious limitations. since the size of published models has increased in recent years, including models with  <dig> or more nodes  <cit> , it is important to develop more efficient methods that find all steady states of a boolean model.

several methods have been proposed in the literature for dealing with this problem, including exact as well as heuristic methods. we provide a brief review of the different types here. for this purpose, we represent a boolean network as follows. let k={ <dig> }, and assume that the network has n nodes x <dig> …,xn. each node xi has associated to it a boolean function fi:kn→k. thus, we can represent the boolean network as a function 

 f=:kn→kn. 

 one can represent the variable dependencies through the dependency graph of the network, whose nodes are the variables x <dig> …,xn. there is an edge xi→xj if xi appears in the function fj, that is, the state of xj depends on the state of xi. the problem of finding steady states is then formulated as finding all states x∈kn such that f=x.

one approach to the problem is model reduction. some existing reduction methods use a “steady-state approximation”  <cit>  to reduce the number of variables. intuitively, if a function depends on a variable, e.g., fi=fi, then we can remove variable xj from the network by replacing fi with the new function fi,xk,xl). by repeating this process, one obtains a reduced network that in practice is much smaller than the original network. the stopping criteria for reduction methods is that variables can be removed only if the steady state information is preserved. the steady states of the reduced network are in algorithmic one-to-one correspondence with the steady states of the original network. more precisely, the reduction algorithm decomposes a large system into a smaller system and a set of equations in triangular form, so that when the steady states of the reduced system are found, the steady states of the original systems can be found simply by backwards substitution. that is, the existence of the one-to-one correspondence is not just theoretical.

another method uses the fact that one can represent a boolean function as a polynomial function in the variables x <dig> …,xn, with coefficients in the finite number system k={ <dig> } . the problem of finding the steady states of a boolean network in n variables, as above, can then be reformulated as the problem of finding the solutions to a system of polynomial equations pi:=fi−xi=0;i= <dig> …,n <cit> . then, the roots of the system of polynomial equations is encoded by the set {p <dig> …,pn}. using tools from computational algebra it is possible to find another set that has the same roots , such that it is possible to do a generalized version of gaussian elimination. these computations can be done using several different software packages developed for this purpose.

a graph-theoretic method, minimal feedback vertex sets, consists of finding a set of vertices in the dependency graph of the network that “generate” all steady states. more precisely, one finds a set s⊂{ <dig> …,n} such that knowing the coordinates xi, for all i∈s, of a steady state completely and algorithmically determines the other coordinates of the steady state. it turns out that so-called feedback vertex sets have this property. in practice, by finding a minimal feedback vertex set, one reduces the problem from checking 2n states to the problem of checking 2|s| states, where |s| is typically much smaller than n <cit> . a feedback vertex set can be found by removing vertices from the graph until the graph has no directed cycles. a minimal feedback vertex set can be found by finding the smallest number of vertices that we need to remove from the graph so that it does not have directed cycles.

sat methods have also been used for the purpose of finding steady states of boolean networks, which are used to determine whether a boolean expression in several variables has a variable assignment that makes the expression true; see  <cit> . in essence, the system of boolean equations, fi=xi, is rewritten as a single equation g= <dig>  and then the problem of finding the steady states becomes the problem of finding when the equation g= <dig> is satisfied. for example, melkman, tamura, and akutsu  <cit>  used sat algorithms to find steady states of and/or boolean networks, i.e., boolean networks in which the fi contain only the and and or operators, with a time complexity of o . dubrova and teslenko  <cit>  also developed a sat-based algorithm to find all attractors of a boolean network with very good performance characteristics. the methodology was tested on boolean networks with sizes ranging from  <dig> to  <dig>  it was also tested using random networks with up to  <dig> nodes and average in-degree less than  <dig>  for a fixed in-degree of  <dig> the maximum size networks tested have  <dig> nodes.

integer programming-based method have also been used to find the steady states of boolean networks, tamura, hayashida, and akutsu  <cit> . in essence, the system of boolean equations is rewritten as a set of inequalities ax≤b,x≥ <dig> and the goal is to maximize a linear function of the form ctx.

strategic sampling,  is a recursive search approach to identify all steady states of a random boolean network with maximum in-degree  <dig>  with an average time complexity of o . the idea is that the equations are solved recursively: first one considers the solutions of the equation f1=x <dig>  since the fi’s depend on few variables in practice, one only has to keep track of the variables that appear in f <dig>  then, one finds the solutions of f2=x <dig> that are compatible with the solutions previously found. the process continues until one finds solutions of all equations. in the worst case, however, algorithm complexity can be o  <cit> .

finally, the problem of finding attractors has also been studied by using binary decision diagrams   <cit> . the idea is to represent the boolean functions as a directed graph that efficiently encodes the functions by allowing fast evaluation. then, by combining the bdd representation of all the boolean functions, the problem of finding steady states becomes a search problem in the larger bdd. many of these methods were tested on some biologically relevant networks with fewer than  <dig> nodes.

in this paper, we present a new method for computing steady states of a boolean network, combining a graph theoretic reduction/transformation method with an approach using computational algebra. we show that the method performs favorably on some types of networks in comparison with other methods on a collection of benchmark networks, consisting of both published models and random networks with certain properties, namely kauffman networks and networks whose in-degree distribution satisfies a power law.

methods
the method we propose for steady state analysis is a combination of network reduction/transformation and computational algebra . the reduction technique we use is based on results in  <cit> . in  <cit>  it was shown that any boolean network can be “transformed” into an and-not network, namely a network whose boolean functions are all of the form y1∧y2∧…, where yi∈{xi,¬xi}. the and-not network has the property that its steady states are in one-to-one correspondence with the steady states of the original network. furthermore, the one-to-one correspondence between steady states is algorithmic. in  <cit> , the authors proposed a method to reduce an and-not network to another, smaller and-not network in polynomial time, in such a way that the steady states of the original and the reduced network are in one-to-one correspondence, in a constructive way. this reduction algorithm looks for motifs  in the wiring diagram and removes nodes in such motifs; the reduction stops when there are no more motifs to be reduced . once the reduced network is constructed, one can compute its steady states by converting the boolean functions into polynomial functions and then solving a system of polynomial equations, as explained above. the computational algebra technique is based on  <cit> . the idea is that by computing a gröbner basis , it is possible to find the roots of the system of polynomial equations using a generalized version of gaussian elimination.

the correspondence between boolean and polynomial functions is accomplished via the “dictionary” x∧y⇔x·y,x∨y⇔x+y+xy,¬x⇔x+ <dig>  the correspondence is unique if we limit the degree with which each variable appears in the polynomial function to  <dig>  since any function kn→k can be represented uniquely as a polynomial function that is square-free, that is, in which every variable appears with exponent  <dig> 

the algorithm is summarized in the following pseudocode and a more detailed description follows. the source code can be found at github.com/plantsimlab/ adam.   

the input of our algorithm is an n−dimensional boolean network f=. in step  <dig>  we use the formulas from  <cit>  to compute an and-not network g=, with m≥n, which has the same number of steady states as f. the idea is to introduce variables to rewrite the boolean operations using only the operators and and not; for example, f1=¬x2∧ can be written as f1=¬x2∧¬x <dig>  where f5=¬x3∧¬x <dig>  furthermore, the steady states of f are given by projecting the steady states of g to their first n coordinates. in step  <dig>  we simply consider the wiring diagram of g, which is a signed directed graph that encodes which variable depends on which others and whether the interactions are activating or inhibiting. in step  <dig>  we use the algorithm from  <cit>  to reduce the wiring diagram of g to another signed directed graph, w. then, in step  <dig>  we construct the and-not network that has w as its wiring diagram, h=; the steady states of g can be computed from the steady states of h by backtracking  <cit> . in step  <dig>  we compute the polynomial representation of h. this is done by replacing ¬xi with 1+xi, and xi∧xj with xixj, as explained earlier. in step  <dig> we solve the system of polynomial equations hi=xi, i= <dig> …,l; this is done using tools from computational algebra as done in  <cit> . the solutions of the system, l″={s1″,…,sr″}, will also be solutions of h. in step  <dig>  we use backtracking to compute the steady states of g, l′={s1′,…,sr′}. and finally, in step  <dig>  we project each sj′ to its first n coordinates and obtain the steady states of f .

RESULTS
we first tested the software implementation of our algorithm on  <dig> , <dig> boolean networks with  <dig> nodes each, for which we also computed all steady states by a custom-made algorithm based on minimal feedback vertex sets. for each graph we found the minimal number of vertices that had to be removed so that the graph had no directed cycles; call this set s. then, for each element in { <dig> }|s|, the values of the other variables are completely determined. this gave us 2|s| candidates for steady states which we then checked by exhaustive search. in all cases our algorithm computed correctly all steady states. we are therefore confident that our implementation is error-free. this extends to the relevant functionalities of other software packages we used for intermediate computations .

then we used over  <dig>  boolean networks to benchmark our method against others. the methods we used for comparison were those with published benchmarks or those for which the code was readily available. as we will see later, for kauffman networks with k= <dig>  the timing of our method grows linearly with the number of nodes; thus, it was not necessary to include in our benchmarks methods that were reported to grow exponentially for such networks . we selected three methods with good computational efficiency for k=2: zanudo and albert  <cit> ; devloo, hansen, and labbé  <cit> ; and tamura, hayashida, and akutsu  <cit> . for the most recent algorithm, zañudo and albert  <cit>  use a method that identifies motifs  that stabilize in one or a small number of states. the steady states from these motifs are used to reduce the network to find the attractors. it is important to mention that this method can find not only the steady states of boolean networks, but also information about all the attractors of the network, which our method is not currently designed to do.

we used random biologically meaningful boolean networks  <cit>  and published networks  <cit>  . the results for zañudo and albert and our algorithm were generated by us and the other results are reported from published benchmarks  <cit> . the computations for our algorithm and that of  <cit>  were done on a  <dig>  ghz linux machine. the computations for tamura’s and devloo’s algorithms were done on a linux system with 3ghz and a sun sparc ultra  <dig> machine, respectively, as reported in  <cit> . considering that the different computers described above have processors with similar speed and that the computations were done in a single processor, the use of results from different machines will not affect the main conclusions of our comparison. moreover, some methods did not have reported results for certain network sizes; in that case, we computed an approximate timing using interpolation/extrapolation of the reported values; we linear and exponential fits for the timings that grew linearly and exponentially, respectively.

first, we compare the performance of different methods on kauffman networks with connectivity k= <dig> and k= <dig>  for our and the zañudo algorithm, each reported number is the average or standard deviation of  <dig> boolean networks. in table  <dig> we report the timings for kauffman networks with k= <dig>  we can see that the algorithm in  <cit>  performs best, followed by our algorithm. note that all timings grow linearly with the number of nodes. as mentioned in  <cit> , the good results with tamura’s algorithm may be due to the fact that the authors optimized the computations for boolean functions that have  <dig> inputs. the results for kauffman networks with k= <dig> in table  <dig>  however, show that our method performs better by an order of magnitude. these results show that, while our algorithm is not optimized for very low in-degree networks, it is more scalable for networks with higher connectivity.
k=2


  
the best results are in bold. *=interpolated/extrapolated from reported results. nr=not reported.
k=3


 
the best results are in bold. *=interpolated/extrapolated from reported results. df=did not finish in a day. nr=not reported.

not all molecular networks have properties similar to kauffman networks, but can exhibit power law properties for their degree distribution. thus, we supplemented the results from tables  <dig> and  <dig> with benchmark networks whose connectivity follows a power law distribution  <cit> . we considered power-law networks with average connectivity 〈k〉= <dig> and 〈k〉= <dig>  that is, the average number of edges is the same, but the connectivity distribution is more biologically realistic. there were no bechmarks for these types of networks for tamura’s and devloo’s algorithms, so we only report zañudo’s and our algorithm. in table  <dig>  we see that our algorithm can handle networks with 〈k〉= <dig> with up to  <dig> nodes in under  <dig> seconds on average. it is important to mention that these timings differ considerably from the timings for k= <dig> . table  <dig> shows the results for networks with connectivity 〈k〉= <dig>  not surprisingly, increasing the average connectivity has a dramatic effect on the size of networks that can be studied; for example, the network sizes that can be dealt with in under  <dig> seconds decreases from  <dig> to about  <dig> when we increase 〈k〉 from  <dig> to  <dig>  further increasing the average connectivity will have a much more dramatic effect.
〈k〉=2


 
df = did not finish in a day.
〈k〉=3


 
df = did not finish in a day.

finally, our results on published networks are shown in table  <dig>  sorted by average connectivity. since all models have external parameters corresponding to environmental conditions , we sampled the parameter space and computed the average timing of each algorithm. the numbers we report are the averages of  <dig> simulations for each model. as expected, for all networks with small average connectivity  our algorithm performed very well and finished in less than half a second, consistent with the timings from tables  <dig> and  <dig>  four models have average connectivity greater than  <dig> and our algorithm performed very well on three of them. however, for the largest network , there were parameter sets  which could not be analyzed.

n
〈k〉
df=did not finish in a day. *=49% of simulations reported, 51% of simulations were stopped because they did not finish in a day or had a large memory consumption.

the computational complexity of our algorithm depends on the type of networks used as well as the connectivity. the algorithm seems to run in polynomial time for kauffman networks with k= <dig> , but slower for power-law networks with the same connectivity . for other types of networks the complexity is much harder to infer, but table  <dig> suggests that the complexity is exponential. also, the complexity of the mathematical tools we use is not well understood in the context of boolean models. for example, the algebraic step of our algorithm can be doubly exponential, but it has been shown to work much faster in practice and, as our work shows, it runs much faster for sparse boolean models.

CONCLUSIONS
the capability to analyze the attractors of discrete dynamic models of biological networks is a key technology in any systems biology toolkit that incorporates this popular type of model. this capability needs to include steady state analysis as well as the determination of periodic points of larger periods. and it needs to apply to models that allow an arbitrary  number of states for its variables, such as logical models. in this paper, we have focused on boolean networks as the model type most commonly used currently. and we have focused only on steady state analysis, at the exclusion of periodic limit cycles. as is the case in many situations, algorithms available for this purpose, some of which we used here for comparison, perform well on some types of models and not so well on others. for instance, for kaufmann networks with connectivity  <dig>  the method in  <cit>  outperforms all other methods, including ours. the method in  <cit>  is generally slower than our method in computing steady states, but has the added capability that it also finds limit cycles of larger lengths, which our method is not currently equipped to do.

we have used three types of networks for benchmarking: kauffman networks, power law networks, and published networks. kauffman networks are commonly used for this purpose, but they don’t capture all properties of molecular networks, which include a power law distribution of node connectivities. our analysis of published networks shows that some of them have high average connectivity, not generally considered in theoretical studies. these pose serious challenges to computational methods, as we demonstrate. as more large published networks become available, they will represent the most important suite of benchmark models to be used, in our opinion.

we believe that this study also holds another important lesson. our method is a combination of two methods, neither one of which performs particularly well when applied on its own . in combination, however, they are quite powerful: model reduction plus polynomial algebra. this might point towards a general strategy for other algorithms of this type. nonetheless, as our calculations show, the challenge of finding steady states is far from solved in general, even for existing published models. thus, much work remains to be done.

competing interests
the authors declare that they have no competing interests.

authors’ contributions
av-c designed and applied the graph reduction methods, and combined them with the computer algebra algorithm. he also generated the suite of benchmark networks used in the study. ba implemented the graph reduction methods. he also surveyed the literature for other available methods and carried out and collected performance data for the other methods used in the study for comparison. fh carried out gröbner basis calculations for a subset of the benchmark networks. rl conceived, planned, and directed the project. all authors contributed to the writing of the manuscript. all authors read and approved the final manuscript.

supplementary material
additional file 1
example and individual performance of network reduction and computational algebra.

click here for file

 additional file 2
instructions for usage.

click here for file

 additional file 3
source code.

click here for file

 acknowledgements
the work of r.l. was supported in part by the grant plantsimlab: a simulation laboratory for plant biology, funded by nsf, award number dbi- <dig>  f.h. did the work at mbi .
