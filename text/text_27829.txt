BACKGROUND
the minimum evolution  principle is a commonly used principle to estimate phylogenetic trees of a set Γ of n species  given an n × n symmetric matrix d = {dij} of evolutionary distances. first introduced by kidd and sgaramella-zonta  <cit>  and subsequently reinterpreted by rzhetsky and nei  <cit> , the me principle aims at finding a phylogeny characterized by minimal sum of branch lengths, under the auxiliary criteria that branches have a positive length and the pair-wise distances on the tree are not smaller than the directly observed pair-wise differences. its biological justification is based on the fact that, when unbiased estimates of the true distances are available, the correct phylogenetic tree has an expected length shorter than any other possible tree  <cit>  compatible with the distances in d. more formally, the me principle can be expressed in terms of the following optimization problem:

problem  <dig>  minimum evolution under least square 

 min⁡‖v‖1s.t.f=0x∈x
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaacpc6xni=xi8qivkypfjydhavhbbf9v8qqaqfr0xc9vqfj0dxdbba91qpepei8k8fii+fsy=rqgqvepae9pg0db9vqaivgfr0xfr=xfr=xc9adbaqaaegacagaaiaabeqaaeqabiwaaagcbaqbaeqabmgaaaqaamaaxababagagiyba0maeiyaakmaeioba4galeaacqggoaakieqacqwfybawcqggsaalcqwf2bgdcqggpaqkaeqaaagcbawaauwaaeaacqwf2bgdaiaawma7caglkwoadawgaawcbagaegymaedabeaaaoqaaiabdohazjabc6cauiabdsha0jabc6cauaqaaiabdagamjabcicaoiab=reaejabcycasiab=hfayjabcycasiab=zha2jabcmcapiabg2da9iabicdawaqaaaqaaiab=hfayjabgigioprthrhal1wy0l2yhvtyaehbnfgdovwbhrxajfwnagabaiab+dr8ybaaaaa@5909@ 

where || · || <dig> is the ℒ1
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaacpc6xni=xh8vivgi8gi=heeeu0xxdbba9frfj0xb9qqpg0dxdb9aspei8k8fii+fsy=rqgqvepae9pg0db9vqaivgfr0xfr=xfr=xc9adbaqaaegacagaaiaabeqaaeqabiwaaagcbawenfgdovwbhrxajfwnhbqeg0uy0hwztfgdpnwy1aaceagae8nehw0aawbaasqabeaacqaixaqmaaaaaa@37b1@-vector norm; v is a vector of the 2n -  <dig> edge lengths; x is a n/ <dig> ×  topological matrix <cit>  encoding a phylogenetic tree as an unrooted binary tree with the n taxa in Γ as terminal vertices ; x
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaacpc6xni=xh8vivgi8gi=heeeu0xxdbba9frfj0xb9qqpg0dxdb9aspei8k8fii+fsy=rqgqvepae9pg0db9vqaivgfr0xfr=xfr=xc9adbaqaaegacagaaiaabeqaaeqabiwaaagcbawenfgdovwbhrxajfwnhbqeg0uy0hwztfgdpnwy1aaceagae83fxjfaaa@3775@ is the set of all the topological matrices; finally, f defines the level of compatibility among the distances in d and the distances induced by the phylogenetic tree edges. any optimal solution  of problem  defines a phylogenetic tree satisfying the minimum evolution principle. a topological matrix x is an edge-path incidence matrix of a tree   that encodes a tree as follows: any generic entry xij,k is set to  <dig> if the edge k belongs to the path from the leaf i to the leaf j,  <dig> otherwise. in the rest of the paper we refer to problem  as the me problem.

the distance matrix d of problem  is estimated from the dataset, e.g., accordingly to any method described in  <cit> . condition f =  <dig> typically imposes that, for any given ept matrix x, v minimizes the  sum of the square values of the differences between the distances in d and the corresponding distances induced by the phylogenetic tree edges  <cit> . in particular, under the unweighted least-square )  <cit> :

 v = x†dΔ 

where x† is the moore-penrose pseudoinverse of x, and dΔ is a vector whose components are obtained by taking row per row the entries of the strictly upper triangular matrix of d.

others  <cit>  and  <cit>  have suggested the use of a weighted least-squares  function:

 v = -1xtwdΔ 

where w is a strictly positive definite diagonal matrix whose entries wij represent weights associated to leaves i and j. finally, hasegawa et al.  <cit>  introduced a generalized least-squares  function in which v is computed using:

 v = -1xtc-1dΔ 

where c is a strictly positive definite symmetric matrix representing the covariance matrix of d. to avoid the occurrence of negative branch lengths  <cit> , problem  can be modified as follows:

problem  <dig>  minimum evolution under linear programming 

 min⁡‖v‖1s.t.xv≥dΔv∈ℝ+2n−3x∈x
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaacpc6xni=xi8qivkypfjydhavhbbf9v8qqaqfr0xc9vqfj0dxdbba91qpepei8k8fii+fsy=rqgqvepae9pg0db9vqaivgfr0xfr=xfr=xc9adbaqaaegacagaaiaabeqaaeqabiwaaagcbaqbaeaabqabaaaaaeaacyggtbqbcqggpbqacqggubgbdawgaawcbagaeiikagccbegae8hwaglaeiilawiae8ndaynaeiykakcabeaaaoqaamaafmaabagae8ndayhacagljwuaaypcsdwaasbaasqaaiabigdaxaqabaaakeaaaeaaaeaaiegacqgfzbwccqgfuaglcqgf0badcqgfuaglaeaacqwfybawcqwf2bgdaeaacqghljysaeaacqwfebardaahaawcbeqaaiabfs5aebaaaoqaaaqaaiab=zha2bqaaiabgigiodqaamrr1ngbprwthrhayaqeguudjxwakbsthrhagq1dvbaceagae0xhhi1aa0baasqaaiabgucaraqaaiabikdayiabd6gaujabgkhitiabiodazaaaaoqaaaqaaiab=hfaybqaaiabgigiodqaamrthrhal1wy0l2yhvtyaexbnfgdovwbhrxajfwnagqbaiab8dr8ybaaaaa@68a4@ 

unfortunately, both problems  and  are np
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaacpc6xni=xh8vivgi8gi=heeeu0xxdbba9frfj0xb9qqpg0dxdb9aspei8k8fii+fsy=rqgqvepae9pg0db9vqaivgfr0xfr=xfr=xc9adbaqaaegacagaaiaabeqaaeqabiwaaagcbawenfgdovwbhrxajfwnhbqeg0uy0hwztfgdpnwy1aaceagae8xdx7kaeeiuaafaaa@3888@-hard  <cit> . in this context, let us observe that, given Γ, the cardinality of x
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaacpc6xni=xh8vivgi8gi=heeeu0xxdbba9frfj0xb9qqpg0dxdb9aspei8k8fii+fsy=rqgqvepae9pg0db9vqaivgfr0xfr=xfr=xc9adbaqaaegacagaaiaabeqaaeqabiwaaagcbawenfgdovwbhrxajfwnhbqeg0uy0hwztfgdpnwy1aaceagae83fxjfaaa@3775@ is:

 |x
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaacpc6xni=xh8vivgi8gi=heeeu0xxdbba9frfj0xb9qqpg0dxdb9aspei8k8fii+fsy=rqgqvepae9pg0db9vqaivgfr0xfr=xfr=xc9adbaqaaegacagaaiaabeqaaeqabiwaaagcbawenfgdovwbhrxajfwnhbqeg0uy0hwztfgdpnwy1aaceagae83fxjfaaa@3775@| = !! = !! 

where n!! is the double factorial of n. hence, the number of topological matrices grows exponentially with the number of leaves .

problem  has received great attention from the scientific community such that exact and approximate algorithms to solve it have been developed. exact algorithms for solving problem  are typically based on an exhaustive approach . as an example, paup*  <dig>   <cit>  allows exhaustive search for datasets containing up to  <dig> taxa. a number of heuristics were also developed in the last  <dig> years. e.g., rzhetsky and nei  <cit>   start from a neighbor-joining  tree  <cit> ,  apply a local search generating topologies within a given topological distance  from the nj tree, and  return the best topology found. kumar  <cit>  further improved the approach as follows: starting from a topology, a leaf l is selects at each step and all possible assignments of l on the topology are tested. despite that the neighborhood size in kumar's approach is larger than in rzhetsky and nei's algorithm, it requires examining a number of topologies that is, at most, an exponential function of the number of leaves n: !/ <dig>  and generates solution in a shorter computing time. finally, bryant and waddell  <cit>  implemented programming optimisation and desper and gascuel  <cit>  introduced a greedy search that both improved speed and accuracy of the search.

here, we introduce the ant colony optimization  algorithm for estimating phylogenies under the minimum evolution principle, and show that aco has the potential to compete with other widely-used methods. aco  is a widely-used metaheuristic approach for solving hard combinatorial optimization problems. aco is inspired from the pheromone trail laying and following behavior of real ants. aco implements indirect communication among simple agents, called  ants. communication is mediated by  pheromone trails implemented as a probabilistic model to which the ants adapt during the algorithm's execution to reflect their search experience. aco has proven a successful technique for numerous np
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaacpc6xni=xh8vivgi8gi=heeeu0xxdbba9frfj0xb9qqpg0dxdb9aspei8k8fii+fsy=rqgqvepae9pg0db9vqaivgfr0xfr=xfr=xc9adbaqaaegacagaaiaabeqaaeqabiwaaagcbawenfgdovwbhrxajfwnhbqeg0uy0hwztfgdpnwy1aaceagae8xdx7kaeeiuaafaaa@3888@-hard combinatorial optimization problems , although no application to the me phylogeny problem is currently known. our specific implementation of the aco algorithm exploits a stochastic version of the neighbor-joining  algorithm  <cit>  to explore tree space.

RESULTS
iterative addition
given a set Γ of taxa, let us define a partial tree as a m-leaf tree whose leaves are taxa of a subset Γ' ⊂ Γ, with m = |Γ'|. moreover, given a partial tree, with node set v and edge set e, let us say that we add/insert a leaf i  on the edge  ∈ e , and generate a new partial tree with node set v^
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaacpc6xni=xh8vivgi8gi=heeeu0xxdbba9frfj0xb9qqpg0dxdb9aspei8k8fii+fsy=rqgqvepae9pg0db9vqaivgfr0xfr=xfr=xc9adbaqaaegacagaaiaabeqaaeqabiwaaagcbagafmovaylbakaaaaa@2d18@ = v ∪ {i, t} and edge set e^
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaacpc6xni=xh8vivgi8gi=heeeu0xxdbba9frfj0xb9qqpg0dxdb9aspei8k8fii+fsy=rqgqvepae9pg0db9vqaivgfr0xfr=xfr=xc9adbaqaaegacagaaiaabeqaaeqabiwaaagcbagafmyraukbakaaaaa@2cf6@ = e ∪ {, , }\{}. in other words, we add a leaf i on an edge, divide that edge with a new node t, and join the leaf i to t. all algorithms described here build complete phylogenetic trees by iteratively adding one leaf at a time on the edges of a partial tree.

primal bound
to generate a first upper bound  <cit>  of the me problem, we adapted the sequential addition  greedy algorithm  <cit> . the sequential addition algorithm is less prone, than nj, to generate a systematic local optimum at the end of the search .

the pseudo-code of our version of the sequential addition algorithm is presented in figure  <dig>  in the initialization step, we arbitrarily chose a subset Γ' ⊆ Γ of m ≤ n leaves, and we generate as initial m-leaf partial tree, i.e., an optimal solution of the problem  when only m leaves are considered. a each iteration, we join the leaf i to all possible leaves already present in Γ', and choose the solution that minimize tree length , hence, generating a new partial tree and new set Γ' = Γ' ∪ {i}. we iterate the procedure until a tree with n leaves is obtained. finally, fixing the topology matrix x^m
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaacpc6xni=xh8vivgi8gi=heeeu0xxdbba9frfj0xb9qqpg0dxdb9aspei8k8fii+fsy=rqgqvepae9pg0db9vqaivgfr0xfr=xfr=xc9adbaqaaegacagaaiaabeqaaeqabiwaaagcbaacbegaf8hwaglbakaadawgaawcbagaemyba0gabeaaaaa@2eb1@, we determine the optimal edge weights by imposing f  the pheromone update phase during which artificial ants walk on a graph with all possible connections among the n taxa and  internal nodes, and lay a trail of volatile pheromone on the branches of the starting tree;  the stochastic construction phase during which new trees are built using both the heuristic information of the pairwise distances and the stochastic process guided by the newly-updated pheromone trail matrix ; and  the 2-opt local search phase that corresponds to a local search using taxon swapping. the curved arrow indicates the stochastic jump of an ant from one edge to another. see text for details.

unfortunately, the computation complexity of our heuristic is o!! + n2). at each iteration, given a partial tree, i.e., a k-leaf phylogenetic tree of the leaves in Γ' ⊂ Γ with k = |Γ'|, and a leaf i not in Γ', the procedure generates all the different -leaf partial trees that can be obtained by adding the leaf i in each edge of the current partial tree.

the ant colony optimization algorithm
the specific aco algorithm for the minimum evolution problem  that we introduce here , is a hybrid between the max-min ant system   <cit>  and the approximate nondeterministic tree search   <cit> . both methods are modifications of the original ant system approach  <cit> .

the core of the aco-me algorithm is the iteration phase, where the ants generate a set t
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaacpc6xni=xh8vivgi8gi=heeeu0xxdbba9frfj0xb9qqpg0dxdb9aspei8k8fii+fsy=rqgqvepae9pg0db9vqaivgfr0xfr=xfr=xc9adbaqaaegacagaaiaabeqaaeqabiwaaagcbawenfgdovwbhrxajfwnhbqeg0uy0hwztfgdpnwy1aaceagae83extfaaa@376d@ of trees. then, starting from the trees in t
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaacpc6xni=xh8vivgi8gi=heeeu0xxdbba9frfj0xb9qqpg0dxdb9aspei8k8fii+fsy=rqgqvepae9pg0db9vqaivgfr0xfr=xfr=xc9adbaqaaegacagaaiaabeqaaeqabiwaaagcbawenfgdovwbhrxajfwnhbqeg0uy0hwztfgdpnwy1aaceagae83extfaaa@376d@, a local search is performed until a locally optimal tree is found and compared with the current-best tree. if stopping conditions are met the procedure ends, otherwise the iteration phase is repeated.

each ant builds a phylogenetic tree by iteratively adding a leaf at a time to a partial tree. following a relation-learning model  <cit> , the choices performed by an ant about  which leaf to insert, and  where to add it on the partial tree are based of a set of parameters {τij} called pheromone trails. the values of the pheromone trail parameters {τij} represent a stochastic desirability that a leaf i shares a direct common ancestor with a vertex j on a partial tree. the ants generate a new set t
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaacpc6xni=xh8vivgi8gi=heeeu0xxdbba9frfj0xb9qqpg0dxdb9aspei8k8fii+fsy=rqgqvepae9pg0db9vqaivgfr0xfr=xfr=xc9adbaqaaegacagaaiaabeqaaeqabiwaaagcbawenfgdovwbhrxajfwnhbqeg0uy0hwztfgdpnwy1aaceagae83extfaaa@376d@ of trees and the pheromone trail parameters are updated at the end of the main iteration phase.

let us now consider the algorithm in more details. it uses two identical data structures: s* and sk. the former stores the current-best complete reconstruction  known, whereas the latter stores the best complete reconstruction obtained by the ants during iteration k. the algorithm also uses a variable na, i.e., the number of artificial ants. how to set the value of na is discussed in the parameter settings section. in the initialization phase, s* is first set to the reconstruction obtained by the sequential addition algorithm and sk is set to null, then the pheromone trail parameters are updated. we implemented the mmas  <cit>  method of pheromone update, where τmin ≤ τij ≤ τmax. here, we set τmin and τmax to  <dig>  and  <dig> , respectively  <cit> . in the initialization phase, the pheromone trail parameters {τij} are set to  <dig> , i.e., all positions for leaf insertion have the same desirability.

before describing the iteration phase, let us introduce some definitions. let gk
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaacpc6xni=xh8vivgi8gi=heeeu0xxdbba9frfj0xb9qqpg0dxdb9aspei8k8fii+fsy=rqgqvepae9pg0db9vqaivgfr0xfr=xfr=xc9adbaqaaegacagaaiaabeqaaeqabiwaaagcbawenfgdovwbhrxajfwnhbqeg0uy0hwztfgdpnwy1aaceagae8nbxf0aasbaasqaaiabdugarbqabaaaaa@38de@ be a partial tree with k leaves, v the set of vertices of gk
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaacpc6xni=xh8vivgi8gi=heeeu0xxdbba9frfj0xb9qqpg0dxdb9aspei8k8fii+fsy=rqgqvepae9pg0db9vqaivgfr0xfr=xfr=xc9adbaqaaegacagaaiaabeqaaeqabiwaaagcbawenfgdovwbhrxajfwnhbqeg0uy0hwztfgdpnwy1aaceagae8nbxf0aasbaasqaaiabdugarbqabaaaaa@38de@, and Γgk
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaacpc6xni=xh8vivgi8gi=heeeu0xxdbba9frfj0xb9qqpg0dxdb9aspei8k8fii+fsy=rqgqvepae9pg0db9vqaivgfr0xfr=xfr=xc9adbaqaaegacagaaiaabeqaaeqabiwaaagcbagaeu4kdc0aasbaasqaamrthrhal1wy0l2yhvtyaehbnfgdovwbhrxajfwnagabaiab=zq8hnaabaaameaacqwgrbwaaeqaaawcbeaaaaa@3a7e@ the set of leaves of gk
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaacpc6xni=xh8vivgi8gi=heeeu0xxdbba9frfj0xb9qqpg0dxdb9aspei8k8fii+fsy=rqgqvepae9pg0db9vqaivgfr0xfr=xfr=xc9adbaqaaegacagaaiaabeqaaeqabiwaaagcbawenfgdovwbhrxajfwnhbqeg0uy0hwztfgdpnwy1aaceagae8nbxf0aasbaasqaaiabdugarbqabaaaaa@38de@. let us also use the recursive distance definition of  <cit> : if a and b are two non-intersecting subtrees from a tree g
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaacpc6xni=xh8vivgi8gi=heeeu0xxdbba9frfj0xb9qqpg0dxdb9aspei8k8fii+fsy=rqgqvepae9pg0db9vqaivgfr0xfr=xfr=xc9adbaqaaegacagaaiaabeqaaeqabiwaaagcbawenfgdovwbhrxajfwnhbqeg0uy0hwztfgdpnwy1aaceagae8nbxfeaaa@3753@, then the average distance between a and b is:

 Δa|b=1|a||b|∑i∈a,j∈bdij.
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaacpc6xni=xi8qivkypfjydhavhbbf9v8qqaqfr0xc9vqfj0dxdbba91qpepei8k8fii+fsy=rqgqvepae9pg0db9vqaivgfr0xfr=xfr=xc9adbaqaaegacagaaiaabeqaaeqabiwaaagcbagaeuildq0aasbaasqaaiabdgeabjabcyha8jabdkeacbqabagccqgh9aqpjuagdawcaaqaaiabigdaxaqaaiabcyha8jabdgeabjabcyha8jabcyha8jabdkeacjabcyha8baadaaeqbqaaiabdsgaknaabaaabagaemyaakmaemoaaogabeaaaeaacqwgpbqacqghiiizcqwgbbqqcqggsaalcqwgqbgacqghiiizcqwgcbgqaeqacqghris5aiabc6cauaaa@4bd2@ 

in the iteration phase, each artificial ant r generates a complete phylogenetic tree using the constructcompletereconstruction procedure, as illustrated in figure 3: ant r randomly selects four leaves from the set Γ, and builds a partial tree gk
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaacpc6xni=xh8vivgi8gi=heeeu0xxdbba9frfj0xb9qqpg0dxdb9aspei8k8fii+fsy=rqgqvepae9pg0db9vqaivgfr0xfr=xfr=xc9adbaqaaegacagaaiaabeqaaeqabiwaaagcbawenfgdovwbhrxajfwnhbqeg0uy0hwztfgdpnwy1aaceagae8nbxf0aasbaasqaaiabdugarbqabaaaaa@38de@, k =  <dig>  then, ant r  chooses, among the leaves not yet inserted in the partial topology, the leaf i defining the smallest distance dij, j ∈ Γgk
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaacpc6xni=xh8vivgi8gi=heeeu0xxdbba9frfj0xb9qqpg0dxdb9aspei8k8fii+fsy=rqgqvepae9pg0db9vqaivgfr0xfr=xfr=xc9adbaqaaegacagaaiaabeqaaeqabiwaaagcbagaeu4kdc0aasbaasqaamrthrhal1wy0l2yhvtyaehbnfgdovwbhrxajfwnagabaiab=zq8hnaabaaameaacqwgrbwaaeqaaawcbeaaaaa@3a7e@, and  computes the probability that i has a common ancestor with the vertex j ∈ v  using the formula suggested by ants  <cit> :

 pij=ατij+ηij∑q∈Γ\Γgk
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaacpc6xni=xi8qivkypfjydhavhbbf9v8qqaqfr0xc9vqfj0dxdbba91qpepei8k8fii+fsy=rqgqvepae9pg0db9vqaivgfr0xfr=xfr=xc9adbaqaaegacagaaiaabeqaaeqabiwaaagcbagaemicaa3aasbaasqaaiabdmgapjabdqgaqbqabagccqgh9aqpjuagdawcaaqaaggaciab=f7ahjab=r8a0naabaaabagaemyaakmaemoaaogabeaacqghrawkcqggoaakcqaixaqmcqghsislcqwfxoqycqggpaqkcqwf3oaadawgaaqaaiabdmgapjabdqgaqbqabaaabawaaabeaeaacqggbbwwcqwfxoqycqwfepaddawgaaqaaiabdghaxjabdqgaqbqabagaey4kasiaeiikagiaegymaejaeyoei0iae8xsdemaeiykakiae83tdg2aasbaaeaacqwgxbqccqwgqbgaaeqaaiabc2fadbqaaiabdghaxjabgigiolabfo5ahjabcyfacjabfo5ahnaabaaabawenfgdovwbhrxajfwnhbqeg0uy0hwztfgdpnwy1aaceagae4nbxf0aasbaaeaacqwgrbwaaeqaaaqabaaabegaeyyeiuoaaaaaaa@6c2e@ 

where ηij represents the "heuristic desirability" that leaf i shares a common ancestor with a vertex j of v . finally, α ∈  <cit>  allows the relative weighting of heuristic and stochastic desirabilities. the heuristic desirability ηij is computed as:

 ηij = - <dig> 

where ui=∑j∉vgkΔij/
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaacpc6xni=xh8vivgi8gi=heeeu0xxdbba9frfj0xb9qqpg0dxdb9aspei8k8fii+fsy=rqgqvepae9pg0db9vqaivgfr0xfr=xfr=xc9adbaqaaegacagaaiaabeqaaeqabiwaaagcbagaemydau3aasbaasqaaiabdmgapbqabagccqgh9aqpdaaeqaqaaiabfs5aenaabaaaleaacqwgpbqacqwgqbgaaeqaaogaei4la8iaeiikagiaeiifawnaemovay1aasbaasqaaiabfo5ahnaabaaameaat0uy0hwztfgdpnwy1egaryqthrhal1wy0l2yhvdaiqaacqwfge=rdawgaaqaaiabdugarbqabaaabeaaasqabagccqgg8bafcqggpaqkasqaaiabdqgaqjabgmgiplabdafawnaabaaameaacqwfge=rdawgaaqaaiabdugarbqabaaabeaaasqab0gaeyyeiuoaaaa@534a@, i.e., the sum of the distances from i to the leaves not yet inserted in the partial tree divided the number of leaves inserted in the partial tree.

note that ηij, Δij, and ui correspond to the quantities used in the neighbor-joining algorithm <cit> . hence, computation of the vector pi = {pij}, for all i ∈ Γ, can be interpreted as the stochastic application of the neighbor-joining algorithm. a possible problem  is that ηij can take negative values. finally, ant r randomly chooses a vertex j on the basis of the probabilities pi, and the leaf i is added to the tree.

at the end of the construction phase, a set t
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaacpc6xni=xh8vivgi8gi=heeeu0xxdbba9frfj0xb9qqpg0dxdb9aspei8k8fii+fsy=rqgqvepae9pg0db9vqaivgfr0xfr=xfr=xc9adbaqaaegacagaaiaabeqaaeqabiwaaagcbawenfgdovwbhrxajfwnhbqeg0uy0hwztfgdpnwy1aaceagae83extfaaa@376d@ of trees is obtained and a 2-opt local search  is iteratively performed on each tree: two randomly-chosen leaves are swapped and the tree length is evaluated. swap i is performed on the new tree if swap i- <dig> generated an improvement, otherwise it is performed on the old tree. to reduce the 2-opt computational overhead, we perform no more than  <dig> swappings on each tree in t
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaacpc6xni=xh8vivgi8gi=heeeu0xxdbba9frfj0xb9qqpg0dxdb9aspei8k8fii+fsy=rqgqvepae9pg0db9vqaivgfr0xfr=xfr=xc9adbaqaaegacagaaiaabeqaaeqabiwaaagcbawenfgdovwbhrxajfwnhbqeg0uy0hwztfgdpnwy1aaceagae83extfaaa@376d@. if the best tree generated by the 2-opt local search is shorter than the tree in s*, both s* and sk are updated, otherwise only sk is updated.

the pheromone update completes the iteration phase: each entry τij is updated following:

 τij ← τij + εij 

where

 εij={κρ/lg|Γ|,if wi adjacent to wj in sbest; <dig> otherwise.
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaacpc6xni=xi8qivkypfjydhavhbbf9v8qqaqfr0xc9vqfj0dxdbba91qpepei8k8fii+fsy=rqgqvepae9pg0db9vqaivgfr0xfr=xfr=xc9adbaqaaegacagaaiaabeqaaeqabiwaaagcbaaccigae8xtdu2aasbaasqaaiabdmgapjabdqgaqbqabagccqgh9aqpdagabeqaauaabaqaciaaaeaacqwf6owacqwfbpgccqggvawlcqwgsbabdawgaawcbawenfgdovwbhrxajfwnhbqeg0uy0hwztfgdpnwy1aaceagae4nbxf0aasbaawqaamaaemaabagaeu4kdceacaglhwuaayjcsdaabeaaasqabagccqggsaalaeaacqqgpbqacqqgmbgzcqqggaaicqwg3bwddawgaawcbagaemyaakgabeaakiabbccagiabbggahjabbsgakjabbqgaqjabbggahjabbogajjabbwgaljabb6gaujabbsha0jabbccagiabbsha0jabb+gavjabbccagiabdeha3naabaaaleaacqwgqbgaaeqaaogaeeiiaaiaeeyaakmaeeoba4maeeiiaaiaem4cam3aawbaasqabeaacqwgibgycqwglbqzcqwgzbwccqwg0badaagccqgg7awoaeaacqaiwaamcqggsaalaeaacqqgvbwbcqqg0badcqqgobaacqqglbqzcqqgybgccqqg3bwdcqqgpbqacqqgzbwccqqglbqzcqgguaglaaaacagl7baaaaa@7ee0@ 

where κ ∈ ℝ and ρ, the pheromone evaporation rate, are two tuning constants, sbest is one of the tree s* or sk , and lg|Γ|
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaacpc6xni=xh8vivgi8gi=heeeu0xxdbba9frfj0xb9qqpg0dxdb9aspei8k8fii+fsy=rqgqvepae9pg0db9vqaivgfr0xfr=xfr=xc9adbaqaaegacagaaiaabeqaaeqabiwaaagcbagaemibaw2aasbaasqaamrthrhal1wy0l2yhvtyaehbnfgdovwbhrxajfwnagabaiab=zq8hnaabaaameaadaabdaqaaiabfo5ahbgaay5bslaawia7aaqabaaaleqaaaaa@3da2@ the length of sbest. when applying equation , if τij is greater than τmax or smaller than τmin, then its value is set to τmax or τmin, respectively. we set to ρ  <dig> , κ to κρ ∈  <cit> , and α to  <dig> . fine-tuning of these parameters might have a significant impact on search efficiency but such a systematic analysis is out of the scope of a proof-of concept for the use of aco-me. finally, if the objective function does not decrease after  <dig> iteration, aco-me chooses sk as sbest instead of s* for the pheromone updating; if the objective function does not decrease after  <dig> additional iterations, then all {τij} are reset to  <dig>  and s* is used for pheromone updating.

parameter settings
we evaluated the performances of the aco-me algorithm under different values of the parameter κ, and different numbers of ants . for each of the  <dig> possible combinations of these parameters values, we run aco-me for  <dig> iterations. as suggested elsewhere , we do not consider colony sizes larger than  <dig> 

relative performances are measured using a normalized index as in  <cit> :

 ijk=xj−xjminxjmax−xjmin
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaacpc6xni=xi8qivkypfjydhavhbbf9v8qqaqfr0xc9vqfj0dxdbba91qpepei8k8fii+fsy=rqgqvepae9pg0db9vqaivgfr0xfr=xfr=xc9adbaqaaegacagaaiaabeqaaeqabiwaaagcbaqcfaoaemysak0aa0baaeaacqwgqbgaaeaacqwgrbwaaagaeyypa0zaasaaaeaacqwg4baedaqhaaqaaiabdqgaqbqaaiabcicaoiabdiha4jabcmcapaaacqghsislcqwg4baedaqhaaqaaiabdqgaqbqaaiabd2gatjabdmgapjabd6gaubaaaeaacqwg4baedaqhaaqaaiabdqgaqbqaaiabd2gatjabdggahjabdiha4baacqghsislcqwg4baedaqhaaqaaiabdqgaqbqaaiabd2gatjabdmgapjabd6gaubaaaaaaaa@4f10@ 

where xj
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaacpc6xni=xh8vivgi8gi=heeeu0xxdbba9frfj0xb9qqpg0dxdb9aspei8k8fii+fsy=rqgqvepae9pg0db9vqaivgfr0xfr=xfr=xc9adbaqaaegacagaaiaabeqaaeqabiwaaagcbagaemieag3aa0baasqaaiabdqgaqbqaaiabcicaoiabdugarjabcmcapaaaaaa@31e7@ is the best solution found under parameter value k using dataset j, whereas xjmin
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaacpc6xni=xh8vivgi8gi=heeeu0xxdbba9frfj0xb9qqpg0dxdb9aspei8k8fii+fsy=rqgqvepae9pg0db9vqaivgfr0xfr=xfr=xc9adbaqaaegacagaaiaabeqaaeqabiwaaagcbagaemieag3aa0baasqaaiabdqgaqbqaaiabd2gatjabdmgapjabd6gaubaaaaa@32f9@ and xjmax
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaacpc6xni=xh8vivgi8gi=heeeu0xxdbba9frfj0xb9qqpg0dxdb9aspei8k8fii+fsy=rqgqvepae9pg0db9vqaivgfr0xfr=xfr=xc9adbaqaaegacagaaiaabeqaaeqabiwaaagcbagaemieag3aa0baasqaaiabdqgaqbqaaiabd2gatjabdggahjabdiha4baaaaa@32fd@ are respectively the best and worst solutions found on the instance j using the parameter value k. by definition, performance index values are in the interval  <cit> . the optimal parameter value exhibits the smallest relative performance index . figures  <dig>   <dig>  and  <dig> indicate that, for small, medium, and large datasets, the optimal combinations of number of ants/κ are 7/ <dig>  10/ <dig> , and 8/ <dig> , respectively. however, differences of performances are not spectacular among different combinations of parameter values .

experimental evaluation
we first used a set of distance matrices generated from real datasets: the dataset " <dig> nex" that includes  <dig> rbcl sequences of  <dig> nucleotides each, and the dataset "zilla <dig> nex" that includes  <dig> rbcl sequences of  <dig> nucleotides each. these datasets are available at  <cit> . note that sequences in these datasets were aligned using clustalx  <cit>  and columns including gaps were excluded before computing pairwise distances. second, we generated   <dig> artificial instances of  <dig> taxa ;   <dig> artificial instances of  <dig> taxa ; and   <dig> artificial instances of  <dig> taxa . each artificial instance was generated by random sampling of taxa and partial character reshuffling of the zilla <dig> nex data set. more explicitly, after random selection of the  <dig> or  <dig> or  <dig> taxa, we randomly reshuffled characters among taxa, for  <dig> percents of the aligned columns. as the reshuffling makes the dataset prone to yield undefined pairwise distances  <cit> , we simply used the absolute number of differences between sequence pairs for generating the distance matrix. edge lengths were computed using the standard ols because wls and gls can potentially lead to inconsistent results et al.  <cit> . all numerical experiments were performed on a workstation apple 64-bit power mac g <dig> dual processor dual core, with  <dig> gb of ram, and os x. the aco-me source code is written in c/c++ and compiled using ibm xl c/c++ compiler version  <dig> . we compared the quality  of trees generated by the aco-me algorithm to those obtained using a classical hill-climbing algorithm  after a fixed run time of  <dig> minute. the starting tree was generated using the neighbor-joining algorithm  <cit> , and the tbr branch-swapping operator  <cit>  was used for exploring the solution space. paup*  <dig>  was used with and without the "steepest descent"  option. when sd is activated, all possible tbr are tried, and the rearrangement producing the largest decrease in tree length is selected, inducing a computational overhead similar to that of the 2-opt local search implemented in our aco-me algorithm. each algorithm was run  <dig> times on each of the two real datasets. figure 7a and 7b show that aco-me performances are intermediate between hill-climbing with sd, and hill-climbing without sd. furthermore, figure 7a and 7b indicate that the relative performances of aco-me, in comparison to hill climbing, increase with larger datasets. note that, contrary to our simple implementation of aco-me, the implementation of me in paup*  <dig>   <cit>  incorporates procedures  <cit>  that greatly speed-up the ols ). we trust that implementation of these procedures in combination with further tuning of the aco parameters  would lead to better performances of the aco-me algorithm. figure 8a and 8b indicate that the relative performances described above are relatively stable trough time, especially for large data sets .

CONCLUSIONS
we introduce here an ant colony optimization algorithm  for the phylogeny estimation problem under the minimum evolution principle and demonstrate the feasibility of this approach. although much improvement in performances can probably be obtained through  modification of the local search phase,  tuning of the aco parameters , and  implementation of speed-up procedures and optimization of the code, the current implementation of our algorithm already demonstrates that the ant colony metaphor can efficiently solve instances of the phylogeny inference problem.

authors' contributions
all authors read and approved the final manuscript. daniele catanzaro, raffaele pesenti, and michel c. milinkovitch conceived the study and wrote the manuscript, daniele catanzaro performed the numerical analyses.

supplementary material
additional file 1
an ant colony optimization algorithm for phylogenetic estimation under the minimum evolution principle – supplementary material. the supplementary file includes discussions on the structure of the ept matrices as well as how we generate and enumerate topologies in aco-me.

click here for file

 acknowledgements
daniele catanzaro is a research fellow at the belgian national fund for scientific research . this work was supported by the "communauté française de belgique"  and the "région wallone". we thank c. korostensky, and mike steel for helpful discussions, as well as j. l. deneubourg, l. keller, and two anonymous reviewers for constructive and helpful comments on a previous version of this manuscript.
