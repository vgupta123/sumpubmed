BACKGROUND
regulation of gene expression is a key driver of adaptation of living systems to changes in the environment and to external stimuli. abnormalities in this highly coordinated process underlie many pathologies. at the transcription level, the control of the amount of mrna transcripts involves epigenetic factors such as dna methylation and, in eukaryotes, chromatin remodeling. but the key role in both prokaryotes and eukaryotes is played by transcription factors , that is, proteins that can bind to dna in the regulatory regions of specific genes and act as repressors or inducers of their expression. many interactions between transcription factors and genes they regulate have been discovered through traditional molecular biology experiments. with the introduction of high-throughput experimental techniques for measuring gene expression, such as dna microarrays and rna-seq, the goal moved to reverse-engineering genome-wide gene regulatory networks   <cit> . knowledge of grns can facilitate finding mechanistic hypotheses about differences between phenotypes and sources of pathologies, and can help in the drug discovery and bioengineering.

high throughput techniques allow for collecting genome-wide snapshots of gene expression across different experiments, such as diverse treatments or other perturbations to cells  <cit> . analyzing these data to infer the regulatory network is one of the key challenges in the computational systems biology. the difficulty of this task arises from the nature of the data: they are typically noisy, high dimensional, and sparse  <cit> . moreover, discovering direct causal relationships between genes in the presence of multiple indirect ones is not a trivial task given the limited number of knockouts and other controlled experiments. attempts to solve this problem are motivated from a variety of different perspectives. most existing computational methods are examples of influence modeling, where the expression of a target transcript is modeled as a function of the expression levels of some selected transcription factors. such a model does not aim to describe physical interactions between molecules, but instead uses inductive reasoning to find a network of dependencies that could explain the regularities observed among the expression data. in other words, it does not explain mechanistically how transcription factors interact with regulated genes, but indicate candidate interactions with a strong evidence in expression data. this knowledge is crucial to prioritize detailed studies of the mechanics of the transcriptional regulation.

one group of existing methods describes grn as a system of ordinary differential equations. the rate of change in expression of a transcript is given by a function of the concentration levels of transcription factors that regulate it. network inference includes two steps: a selection of a model and an estimation of its parameters. popular models imply linear functions a priori  <cit> . bayesian best subset regression   <cit>  has been proposed as a novel model selection approach, which uses bayesian information criterion  to select an optimal model for each target gene. another group of methods employ probabilistic graphical models that analyze multivariate joint probability distributions over the observations, usually with the use of bayesian networks   <cit> , or markov networks   <cit> . various heuristic search schemes have been proposed in order to find parameters of the model, such as greedy-hill climbing or the markov chain monte carlo approach  <cit> . however, because learning optimal bayesian networks from expression data is computationally intensive, it remains impractical for genome-wide networks.

other approaches are motivated from statistics and information theory. twixtwir  <cit>  uses double two-way t-test to score transcriptional regulations. the null-mutant z-score algorithm  <cit>  scores interactions based on a z-score transformed knockout expression matrix. various algorithms rely on estimating and analyzing cross-correlation and mutual information  of gene expression in order to construct a grn  <cit> , including anova η <dig> method  <cit> . improvements aimed at removing indirect edges from triples of genes have been proposed, including techniques such as the data processing inequality in aracne  <cit> , and the adaptive background correction in clr  <cit> . another method, narromi  <cit> , eliminates redundant interactions from the mi matrix by applying ode-based recursive optimization, which involves solving a standard linear programming model.

recently, machine-learning theory has been used to formulate the network inference problem as a series of supervised gene selection procedures, where each gene in turn is designated as the target output. one example is mrnet  <cit> , which applies the maximum relevance/minimum redundancy   <cit>  principle to rank the set of transcription factors according to the difference between mutual information with the target transcript  and the average mutual information with all the previously ranked transcription factors . genie <dig>  <cit>  employs random forest algorithm to score important transcription factors, utilizing the embedded relative importance measure of input variables as a ranking criterion. tigress  <cit>  follows a similar approach but is based on the least angle regression . recently, boosting  <cit>  was also used to score the importance of transcription factors, in adanet  <cit>  and okvar-boost  <cit>  methods.

in this paper, we propose a method that combines gradient boosting with regression stumps, augmented with statistical re-estimation procedures for prioritizing a selected subset of edges based on results from the machine-learning models. we evaluated our method on the dream <dig>  dream <dig> and dream <dig> network inference data sets, and achieved results that in all cases were better than the currently available methods.

methods
the ennet algorithm
formulating the gene network inference problem
the proposed algorithm returns a directed graph of regulatory interactions between p genes in form of a weighted adjacency matrix v∈ℝp×p, where vi,j represents regulation of gene j by gene i. as an input, it takes gene expression data from a set of experiments, together with the meta-data describing the conditions of the experiments, including which genes were knocked out. usually, the raw expression data need to be pre-processed before any inference method could be applied to reverse-engineer a grn. pre-processing has a range of meanings, here it is regarded as a process of reducing variations or artifacts, which are not of the biological origin. it is especially important when the expression is measured with multiple high-density microarrays  <cit> . concentration levels of transcripts must be adjusted and the entire distribution of adjusted values aligned with a normal distribution. methods for normalization of expression data are outside of the scope of our work. the data we used were already normalized using rma  <cit>  by the dream challenge organizers. we further normalized the expression data to zero mean and unit standard deviation.

the network inference process relies heavily on the type of expression data provided as an input. two main groups of expression profiles are: the one with known, and the one with unknown initial perturbation state of the expression of genes in the underlying network of regulatory interactions. for example, knockout and knockdown data are provided with the additional meta-data, which describe which genes were initially perturbed in each experiment. on the other hand, multifactorial and time series data are usually expression profiles of an unknown initial state of genes. wildtype, knockout, knockdown, and multifactorial data describe the expression of initially perturbed genes, which are however in a steady state at the time of measurement, whereas time series data describe the dynamics of the expression levels of initially perturbed genes. the types of data available in popular benchmark data sets are summarized in table  <dig> 

different types of expression data provided in popular data sets: wt- wildtype, ko- knockouts, kd- knockdowns, mf- multifactorial, ts- time series, • available, ◦ unavailable. ⋆) even though all the data types are available, they are all processed as mf.

the variability of possible input scenarios poses a problem of representing and analyzing expression data. here, we operate on an n×p expression matrix e, where ei,j is the expression value of the j-th gene in the i-th sample. columns of matrix e correspond to genes, rows correspond to experiments. we also define a binary perturbation matrix k, where ki,j is a binary value corresponding to the j-th gene in the i-th sample, just like in the matrix e. if ki,j is equal to  <dig>  it means that the j-th gene is known to be initially perturbed, for example knocked out, in the i-th experiment. otherwise ki,j is equal to  <dig>  if no information is available about knockouts, all values are set to  <dig> 

decomposing the inference problem into gene selection problems
we decompose the problem of inferring the network of regulatory interactions targeting all p genes into p independent subproblems. in each subproblem incoming edges from transcription factors to a single gene transcript are discovered. for the k-th decomposed subproblem we create a target expression vector yk and a feature expression matrix x−k. columns of the x−k matrix constitute a set of possible transcription factors. vector yk corresponds to the expression of the transcript, which is possibly regulated by transcription factors from x−k. in a single gene selection problem we decide which tfs contribute to the target gene expression across all the valid experiments. columns of x−k correspond to all the possible tfs, but if a target gene k is also a transcription factor, it is excluded from x−k. we do not consider a situation in which a transcription factor would have a regulatory interaction with itself. when building the target vector yk corresponding to the k-th target gene, k∈{ <dig> ...,p}, we consider all the experiments valid except from the ones in which the k-th gene was initially perturbed, as specified in the perturbation matrix k. we reason that the expression value of the k-th gene in those experiments is not determined by its tfs, but by the external perturbation. each row in the yk vector is aligned with a corresponding row in the x−k matrix. in order to justify all the possible interactions we need to solve a gene selection problem for each target gene. for example, if a regulatory network consists of four genes , we need to solve four gene selection problems. in the k-th problem, k∈{ <dig> , <dig> }, we find which tfs regulate the k-th target gene. in other words, we calculate the k-th column of the output adjacency matrix v.

solving the gene selection problems
once the target gene expression vector yk and the tf expression matrix x−k are created for each gene k, we solve each k-th gene selection problem independently, in the following way. we search for the subset of columns in x−k that are related to the target vector yk by an unknown function fk, as shown in equation  <dig>  

  ∀k∈{ <dig> ...,p},∃fk:yk=fk+εk, 

where εk is a random noise. a function fk represents a pattern of regulatory interactions that drive the expression of the k-th gene. we want fk to rely only on a small number of genes acting as transcription factors, those that are the true regulators of gene k. essentially, this is a feature selection or a gene selection task  <cit> , where the goal is to model the target response yk with an optimal small set of important predictor variables, i.e., a subset of columns of the x−k matrix. a more relaxed objective of the gene selection is the variable ranking, where the relative relevance for all input columns of the x−k matrix is obtained with respect to the target vector yk. the higher a specific column is in that ranking, the higher the confidence that a corresponding tf is in a regulatory interaction with the target gene k.

our solution to the variable ranking involves ensemble learning. we use an iterative regression method, which in each iteration chooses one transcription factor based on an optimality criterion, and adds it to the non-linear regression ensemble. the main body of our method, presented in figure  <dig>  is based on gradient boosting machine  <cit>  with a squared error loss function. first, ennet initializes f <dig> to be an optimal constant model, without selecting any transcription factor. in other words, f <dig> is initialized to an average of yk. at each next t-th step the algorithm creates an updated model ft, by fitting a base learner ht and adding it to the previous model ft− <dig>  the base learner is fitted to a sample of pseudo residuals, with respect to a sample of transcription factors, and thus is expected to reduce the error of the model. pseudo-residuals are re-calculated at the beginning of each iteration with respect to the current approximation ft. as a base learner, we use regression stumps, which select a single tf that best fits pseudo residuals. a regression stump ht partitions the expression values x of a candidate tf into two disjoint regions r1t and r2t, where r2t=ℝ−r1t, and returns values γ1t and γ2t, respectively, for those regions, as shown in equation  <dig>  

  ht=γ1ti+γ2ti, 

where i is the identity function returning the numerical  <dig> for the logical true, and the numerical  <dig> for the logical false. regions r1t, r2t are induced such that the least-squares improvement criterion is maximized: 

  i2=w1tw2tw1t+w2t <dig>  

where w1t, w2t are proportional to the number of observations in regions r1t, r2t respectively, and γ1t, γ2t are corresponding response means. that is, γ1t is the average of the values from the vector of pseudo-residuals for those samples where an expression of the chosen tf falls into the region r1t. the value of γ2t is defined in an analogous way. the averages γ1t and γ2t are used as the regression output values for regions r1t and r2t, respectively, as shown in equation  <dig>  the criterion in equation  <dig> is evaluated for each tf, and the transcription factor with the highest improvement is selected. in each t-th step, we only use a random portion of rows and columns of x−k, sampled according to the observation sampling rate ss, and the tf sampling rate sf.

the procedure outlined above creates a non-linear regression model of the target gene expression based on the expression of transcription factors. however, in the network inference, we are interested not in the regression model as a whole, but only in the selected transcription factors. in each t-th step of the ennet algorithm, only one tf is selected as the optimal predictor. the details of the regression model can be used to rank the selected tfs by their importance. specifically, if a transcription factor φt is selected in an iteration t, an improvement it <dig> serves as an importance score iφt <dig> for that φt-th tf. if the same tf is selected multiple times at different iterations, its final importance score is a sum of the individual scores.

in the training of the regression model, the parameter ν, known as a shrinkage factor, is used to scale a contribution of each tree by a factor ν∈ when it is added to the current approximation. in other words, ν controls the learning rate of the boosting procedure. shrinkage techniques are also commonly used in neural networks. smaller values of ν result in a larger training risk for the same number of iterations t. however, it has been found  <cit>  that smaller values of ν reduce the test error, and require correspondingly larger values of t, which results in a higher computational overhead. there is a trade-off between these two parameters.

refining the inferred network
once the solutions of the independent gene selection problems are calculated, we compose the adjacency matrix v representing a graph of inferred regulatory interactions. each of the solutions constitutes a single column-vector, therefore we obtain the adjacency matrix v by binding all the partial solutions column-wise. then we apply a re-evaluation algorithm to achieve an improved final result. the first step does not require any additional data to operate other than the previously calculated adjacency matrix v. it exploits the variance of edge probabilities in the rows of v, i.e., edges outgoing from a single transcription factor, as a measure of the effect of transcriptional regulation. we score transcription factors based on their effects on multiple targets. we assume that the effect of transcriptional regulation on a directly regulated transcript is stronger than the one of the regulation on indirectly regulated transcripts, e.g. transcripts regulated through another transcription factor. otherwise, knocking out a single gene in a strongly connected component in a network of regulatory interactions would cause the same rate of perturbation of the expression level of all the transcripts in that component. as a measure of that effect we use previously a calculated adjacency matrix v and multiply each row of v matrix by its variance σi <dig>  an updated adjacency matrix v <dig> is given by equation 4: 

  ∀:vi,j1=σi2·vi,j, 

where σi <dig> is a variance in the i-th row of v. note that v matrix is built column-wise, i.e., a single column of v contains the relative importance scores of all the transcription factors averaged over all the base learners with respect to a single target transcript. on the other hand, rows of v matrix are calculated independently in different subproblems of the proposed inference method. each row of v contains relative importance scores with respect to a different target transcript. we reason that if a transcription factor regulates many target transcripts, e.g. a transcription factor is a hub node, the variance in a row of v corresponding to that transcription factor is elevated and therefore it indicates an important transcription factor.

the second step of refining the network requires knockout expression data. we reason that direct regulation of a transcript by a transcription factor would lead to a distinct signature in the expression data if the transcription factor was knocked out. a similar reasoning gave foundations for the null-mutant z-score method  <cit>  of reverse-engineering grns. however, in the proposed method this step is only applied if knockout expression profiles are available. in this step we calculate an adjacency matrix v <dig>  which is an update to an already derived adjacency matrix v <dig>  as shown in equation 5: 

  ∀:vi,j2=|eα,j¯−eβ,j¯σj|·vi,j <dig> α={r:kr,i≠0},β={r:kr,i=0}, 

where eα,j¯ is an average expression value of the j-th transcript in all the experiments α in which the i-th gene was knocked-out, as defined by k matrix, eβ,j¯ is the mean expression value for that transcript across all the other knockout experiments, β, and σj is the standard deviation of the expression value of that transcript in all the knockout experiments. the |eα,j¯−eβ,j¯σj| coefficient shows how many standard deviations the typical expression of the j-th transcript was different from the average expression in the experiment in which its potential i-th transcription factor was knocked-out.

performance evaluation
a considerable attention has been devoted in recent years to the problem of evaluating performance of the inference methods on adequate benchmarks  <cit> . the most popular benchmarks are derived from well-studied in vivo networks of model organisms, such as e. coli <cit>  and s. cerevisiae <cit> , as well as artificially simulated in silico networks  <cit> . the main disadvantage of in vivo benchmark networks is the fact that experimentally confirmed pathways can never be assumed complete, regardless of how well the model organism is studied. such networks are assembled from known transcriptional interactions with strong experimental support. as a consequence, gold standard networks are expected to have few false positives. however, they contain only a subset of the true interactions, i.e., they are likely to contain many false negatives. for this reason, artificially simulated in silico networks are most commonly used to evaluate network inference methods. simulators  <cit>  mimic real biological systems in terms of topological properties observed in biological in vivo networks, such as modularity  <cit>  and occurrences of network motifs  <cit> . they are also endowed with dynamical models of a transcriptional regulation, thanks to the use of non-linear differential equations and other approaches  <cit> , and consider both transcription and translation processes in their dynamical models  <cit>  using a thermodynamic approach. expression data can be generated deterministically or stochastically and experimental noise, such as the one observed in microarrays, can be added  <cit> .

here, we used several popular benchmark grns to evaluate the accuracy of our proposed algorithm and compare it with the other inference methods. the data sets we used come from dialogue for reverse engineering assessments and methods  challenges and are summarized in table  <dig>  we evaluated the accuracy of the methods using the overall score metric proposed by the authors of dream challenges  <cit> , as shown in equation 6: 

  overall score=−12·log <dig>  

where p¯aupr and p¯auroc are geometric means of p-values of networks constituting each dream challenge, relating to an area under the precision-recall curve  and an area under the roc curve , respectively.

RESULTS
we assessed the performance of the proposed inference algorithm on large, universally recognized benchmark networks of  <dig> and more genes, and compared it to the state-of-the-art methods. we summarize the results of running different inference methods in figure  <dig>  for a comparison we selected a range of established methods from literature: aracne, clr, and mrnet as implemented in the minet r package  <cit> , genie <dig> and c3net as implemented by their respective authors, our previously reported method adanet, and the top three performers in each of the three dream challenges as listed on the dream web site. some of the methods were designed for use with knockout data, while others are developed with multifactorial data in mind, where no information is given about the nature of the perturbations. therefore, depending on the nature of the particular dream data set, only the suitable group of methods is used for the comparison.

the accuracy of ennet
dream <dig>  <cit>  features in silico networks and expression data simulated using genenetweaver software. benchmark networks were derived as subnetworks of a system of regulatory interactions from known model organisms: e. coli and s. cerevisiae. in this study we focus on a dream <dig> size  <dig> subchallenge, as the largest of dream <dig> suite. the results of all the competing methods except those that are aimed at multifactorial problems are summarized in table  <dig>  ennet and yip et al. methods achieved the best overall scores for that subchallenge, as well as the best scores for all the individual networks. however, it is believed from the analysis of the later challenges  <cit>  that yip et al. method made a strong assumption on the gaussian type of a measurement noise, which was used in dream <dig>  but was no longer used in later dream challenges. for example, in dream <dig> challenge yip et al. method was ranked 7th.

results of the different inference methods on dream <dig> networks, challenge size  <dig>  an area under the roc curve  and an area under the precision-recall curve  are given for each network respectively. the overall score for all the networks is given in the last column. the best results for each column are in bold. numbers in the “experimental results” part of the table were collected after running the algorithms with the default sets of parameters on pre-processed data. however, adanet, genie <dig>  clr, c3net, mrnet, and aracne methods, as they are originally defined, take a multifactorial matrix as an input, which is unavailable in this challenge. therefore they were excluded from the comparison. numbers in the “winner of the challenge” part of the table correspond to the best methods participating in the challenge.

dream <dig> challenge  <cit>  was posted one year after dream <dig> challenge. it features two large subchallenges: dream <dig> size  <dig>  and dream <dig> size  <dig> multifactorial. for each subchallenge, the topology of the benchmark networks were derived from the transcriptional regulatory system of e. coli and s. cerevisiae. in dream <dig> size  <dig> subchallenge all the data types listed in table  <dig> were available except multifactorial, therefore adanet, genie <dig>  clr, c3net, mrnet, and aracne methods were excluded from the comparison. the results of all the methods are summarized in table  <dig>  ennet method clearly outperformed all the others and achieved consistently high scores across all the benchmark networks. in the second dream <dig> large subchallenge, dream <dig> size  <dig> multifactorial, only multifactorial data were available, therefore all the methods were included in the comparison, and run as originally designed. the results of all the methods are summarized in table  <dig>  ennet achieved the best overall score.

results of the different inference methods on dream <dig> networks, challenge size  <dig>  an area under the roc curve  and an area under the precision-recall curve  are given for each network respectively. the overall score for all the networks is given in the last column. the best results for each column are in bold. numbers in the “experimental results” part of the table were collected after running the algorithms with the default sets of parameters on pre-processed data. however, adanet, genie <dig>  clr, c3net, mrnet, and aracne methods, as they are originally defined, take a multifactorial matrix as an input, which is unavailable in this challenge. therefore they were excluded from the comparison. numbers in the “winner of the challenge” part of the table correspond to the best methods participating in the challenge.

results of the different inference methods on dream <dig> networks, challenge size  <dig> multifactorial. an area under the roc curve  and an area under the precision-recall curve  are given for each network respectively. the overall score for all the networks is given in the last column. the best results for each column are in bold. numbers in the “experimental results” part of the table were collected after running the algorithms with the default sets of parameters on pre-processed data. numbers in the “winner of competition” part of the table correspond to the best methods participating in the challenge.

three benchmark networks in dream <dig>  <cit>  were different in size, and structured with respect to different model organisms. however, this time expression data of the only one network were simulated in silico, the two other sets of expression data were measured in real experiments in vivo. like in all dream challenges, in silico expression data were simulated using an open-source genenetweaver simulator  <cit> . however, dream <dig> was the first challenge where participants were asked to infer grns on a genomic scale, e.g. for thousands of target genes, and hundreds of known transcription factors. gold standard networks were obtained from two sources: regulondb database  <cit> , and gene ontology  annotations  <cit> . the results of all the inference methods for dream <dig> expression data are summarized in table  <dig>  ennet achieved the best score for the in silico network, and the best overall score, as well as the best individual auroc scores for all the networks. clearly all the participating methods achieved better scores for an in silico network than for either one of in vivo networks. ennet shows better in vivo results than the other methods in terms of an area under the the roc curve. still, predictions for in vivo expression profiles show a low overall accuracy. one of the reasons for a poor performance of the inference methods for such expression profiles is a fact that experimentally confirmed pathways, and consequently gold standards derived from them, cannot be assumed complete, regardless of how well is a model organism known. additionally, there are regulators of gene expression other than transcription factors, such as mirna, and sirna. as shown in this study, in silico expression profiles provide enough information to confidently reverse-engineer their underlying structure, whereas in vivo data hide a much more complex system of regulatory interactions.

results of the different inference methods on dream <dig> networks. an area under the roc curve  and an area under the precision-recall curve  are given for each network respectively. the overall score for all the networks is given in the last column. the best results for each column are in bold. numbers in the “experimental results” part of the table were collected after running the algorithms with the default sets of parameters on pre-processed data. numbers in the “winner of the challenge” part of the table correspond to the best methods participating in the challenge.

computational complexity of ennet
computational complexity of ennet depends mainly on the computational complexity of the regression stump base learner, which is used in the main loop of the algorithm. as shown in figure  <dig>  we call the regression stump algorithm t times for each k-th target gene, k∈{ <dig> ...,p}. given a sorted input, a regression stump is o complex. we sort the expression matrix in an o time. all the other instructions in the main loop of ennet are at most o. the computational complexity of the whole method is thus o. because, in practice, the dominating part of the sum is tp2n, we report a final computational complexity of ennet as o, and compare it to the other inference methods in table  <dig>  note that the measure for the information-theoretic methods: clr, mrnet, and aracne does not include a calculation of the mutual information matrix.

the computational complexity of ennet and the other grn inference methods with respect to the number of genes p and the number of samples n. the computational complexity of clr, mrnet, and aracne is given without calculating the mutual information matrix.

when implementing ennet algorithm we took advantage of the fact that gene selection problems are independent of each other. our implementation of the algorithm is able to calculate them in parallel if multiple processing units are available. user can choose from variety of parallel backends including multicore package for a single computer and parallelization based on message passing interface for a cluster of computers. the biggest data we provided as input in our tests were in vivo expression profiles of s. cerevisiae from the dream  <dig> challenge. these are genome-wide expression profiles of  <dig> genes  measured in  <dig> experiments. it took  <dig> minutes and  <dig> seconds to calculate the network on a standard desktop workstation with one intel®;core™i7- <dig> processor with  <dig> cores and two threads per core  and  <dig> gb ram. however, it took only  <dig> minutes and  <dig> seconds to calculate the same network on a machine with four amd opteron™ <dig> se processors, each with  <dig> cores and two threads per core  and  <dig> gb ram. all the data sets from the dream  <dig> and the dream  <dig> challenges were considerably smaller, up to  <dig> genes. it took less than one minute to calculate each of these networks on a desktop machine.

setting parameters of ennet
the ennet algorithm is controlled by four parameters: the two sampling rates ss and sf, the number of iterations t and the learning rate ν. the sampling rate of samples ss and the sampling rate of transcription factors sf govern the level of randomness when selecting, respectively, rows and columns of the expression matrix to fit a regression model. the default choice of the value of ss is  <dig>  i.e., we select with replacement a bootstrap sample of observations of the same size as an original training set at each iteration. because some observations are selected more than once, around  <dig>  of random training samples are out of bag in each iteration. it is more difficult to choose an optimal value of sf, which governs how many transcription factors are used to fit each base learner. setting this parameter to a low value forces ennet to score transcription factors, even if their improvement criterion, as shown in equation  <dig>  would not have promoted them in a pure greedy search, i.e., sf= <dig>  however, if a chance of selecting a true transcription factor as a feature is too low, ennet will suffer from selecting random genes as true regulators.

even though reverse-engineering of grns does not explicitly target a problem of predicting gene expression, we choose the values of sampling rates such that the squared-error loss of a prediction of the target gene expression as given by ft  is minimal. this is done without looking at the ground truth of regulatory connections. for each benchmark challenge we performed a grid search over ∈{ <dig> , <dig> , <dig> , <dig> ,1}×{ <dig> , <dig> , <dig> , <dig> ,1} with fixed ν= <dig> , t= <dig>  for each specific set of parameters we analyzed an average 5-fold cross-validated loss over all the observations . we further analyze our approach with respect to one of the challenges: dream <dig> size  <dig>  as shown in figure  <dig>  the minimal average loss was achieved for ss= <dig> and sf= <dig>  , which is consistent with the default parameters proposed for random forest algorithm  <cit> . we also compared the measure based on an average loss with the overall score as defined by equation  <dig>  the results were consistent across the two measures, i.e., a selection of parameters that gave a low average loss also led to the accurate network predictions . an advantage of the average loss measure is a fact that the gold standard network is not used to tune parameters.

in figure  <dig> we present a detailed analysis of the accuracy of the grn inference across different networks of the dream <dig> size  <dig> challenge. each point on both figure  <dig> a and figure  <dig> b is a result of running ennet with different parameters: ∈{ <dig> , <dig> , <dig> , <dig> ,1}×{ <dig> , <dig> , <dig> , <dig> ,1} with fixed ν= <dig> , t= <dig>  the highlighted points are corresponding to ss= <dig>  sf= <dig> , ν= <dig> , t= <dig>  an area under the precision-recall curve and an area under the roc curve are two different measures of the accuracy of an inferred network, which are well preserved across the five networks: for each separate network we observe that aupr and auroc decreases in a function of an average loss. as the overall score is closely related to aupr and auroc, the results shown in figure  <dig> explain the shape of a surface shown in figure  <dig> 

as ennet uses boosting, it needs a careful tuning of the number of iterations t and the learning rate ν. it has been shown  <cit>  that parameters t and ν are closely coupled. usually the best prediction results are achieved when ν is fixed to a small positive number, e.g. ν≤ <dig> , and the optimal value of ty is found in a process of cross-validation. as described above, we reason that the choice of parameters, which gives a low average loss on a cross-validated test set, leads to an accurate network prediction. therefore in figure  <dig> we present how an average loss depends on t∈{ <dig> ...,5000} for different values of ν∈{ <dig> , <dig> , <dig> , <dig> , <dig> }, with fixed ss= <dig>  sf= <dig> . each of the line shows how much ennet overtrains the data for a given t and ν. finally, the optimal choice of parameters for dream <dig> size  <dig> challenge is ss= <dig>  sf= <dig> , t= <dig>  ν= <dig> . following the same practice, we used this default set of parameters: ss= <dig>  sf= <dig> , t= <dig>  ν= <dig>  to evaluate ennet algorithm on all the benchmark networks using ground truth, i.e., for calculating the overall score and comparing it to the other algorithms.

stability of ennet
because ennet uses random sampling of samples and features at each iteration of the main loop, as shown in figure  <dig>  it may calculate two different networks for two different executions on the same expression data. with the default choice of parameters, i.e., ss= <dig>  sf= <dig> , t= <dig>  ν= <dig> , we expect numerous random resamplings, and therefore we need to know if a grn calculated by ennet is stable between different executions. we applied ennet to the  <dig> networks that form dream  <dig> size  <dig> benchmark, repeating the inference calculations independently ten times for each network. then, for each network, we calculated a spearman’s rank correlation between all pairs among the ten independent runs. the lowest correlation coefficient we obtained was ρ> <dig> , with p-value < <dig> e− <dig>  indicating that the networks that result from independent runs are very similar. this proves that ennet, despite being a randomized algorithm, finds a stable solution to the inference problem.

CONCLUSIONS
we have proposed the ennet algorithm for reverse-engineering of gene regulatory networks. ennet uses a variety of types of expression data as an input, and shows robust performance across different benchmark networks. moreover, it does not assume any specific model of a regulatory interaction and do not require fine-tuning of its parameters, i.e., we define the default set of parameters, which promises accurate predictions for the future networks. nevertheless, together with the algorithm, we propose a procedure of tuning parameters of ennet towards minimizing empirical loss. processing genome-scale expression profiles is feasible with ennet: including up to a few hundred transcription factors, and up to a few thousand regulated genes. as shown in this study, the proposed method compares favorably to the state-of-the-art algorithms on the universally recognized benchmark data sets.

competing interests
the authors declare that they have no competing interests.

authors’ contributions
js and ta conceived the method and drafted the manuscript. js implemented the method and ran the experiments. js and ta read and approved the final manuscript.
