BACKGROUND
in recent years, the advent of high density arrays of oligonucleotides and cdnas has had a deep impact on biological and medical research. indeed, the new technology enables the acquisition of data that is proving to be fundamental in many areas of the biological sciences, ranging from the understanding of complex biological systems to clinical diagnosis .

due to the large number of genes involved in each experiment, cluster analysis is a very useful exploratory technique aiming at identifying genes that exhibit similar expression patterns. this may highlight groups of functionally related genes. this leads, in turn, into two well established and rich research areas. one deals with the design of new clustering algorithms and the other with the design of new validation techniques that should assess the biological relevance of the clustering solutions found. despite the vast amount of knowledge available in those two areas  <cit> , gene expression data provide unique challenges, in particular with respect to internal validation criteria. indeed, they must predict how many clusters are really present in a data set, an already difficult task, made even worse by the fact that the estimation must be sensible enough to capture the inherent biological structure of functionally related genes. as a consequence, a new and very active area of research for cluster analysis has flourished  <cit> . techniques in artificial intelligence find wide application in bioinformatics and, more in general, data analysis  <cit> . although clustering plays a central role in these areas, very few clustering algorithms based on the genetic paradigm are available  <cit> , yet such a powerful paradigm  <cit>  has great potential in tackling a difficult optimization problem such as clustering, in particular for high dimensional gene expression data.

here we give a genetic algorithm, referred to as genclust, for clustering gene expression data and show experimentally that it is competitive with either classical algorithms, such as k-means  <cit> , or more innovative and state-of-the-art ones, such as click  <cit>  and cast  <cit> . moreover, the algorithm is well suited for use in conjunction with data driven internal validation methodologies  <cit>  and in particular fom, which has received great attention in the specialized literature  <cit> . finally, we mention that genclust is a generic clustering algorithm that can be used also in other data analysis tasks; e.g., sample classification, exactly as all other algorithms we have used here for our study.

implementation
clustering as an optimization problem
let x = {x <dig>  x <dig> ..., xn} be a set of elements, where each element is a d-dimensional vector. in our case, each gene is an element x ∈ x, and xi is the value of its expression level under experimental condition i. given a subset y = {y <dig>  y <dig>  ..., ym} of x, let c denote the centroid of y and let its variance be

var=1m∑i=1m∑j=1dj) <dig>      
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqacigacagaaeqabaqabegadaaakeaacqwgwbgvcqwgbbqqcqwgsbgucqggoaakcqwgzbqwcqggpaqkcqgh9aqpdawcaaqaaiabigdaxaqaaiabd2gatbaadaaewbqaamaaqahabagaeiikagiaemyeak3aasbaasqaaiabdmgapjabcycasiabdqgaqbqabagccqghsislcqwgjbwycqggoaakcqwgzbqwcqggpaqkdawgaawcbagaemoaaogabeaakiabcmcapmaacaaaleqabagaegomaidaaogaeiola4caleaacqwgqbgacqgh9aqpcqaixaqmaeaacqwgkbaza0gaeyyeiuoaasqaaiabdmgapjabg2da9iabigdaxaqaaiabd2gatbqdcqghris5aogaaczcaiaaxmaacqggoaakcqaixaqmcqggpaqkaaa@5801@

given an integer k, we are interested in finding a partition p
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbamxvp5wqsxmqhnxajn0bkvguhdwzzbqegm0b1jxaljhiov2daebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabawaaegaeaaakeaaimaacawfqbaaaa@396b@ of x into k classes c <dig>  c <dig> ..., ck- <dig> so that the total internal variance

var=∑i=0k−1var     
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbamxvp5wqsxmqhnxajn0bkvguhdwzzbqegm0b1jxaljhiov2daebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabawaaegaeaaakeaacqwgwbgvcqwgbbqqcqwgsbgucqggoaakimaacawfqbgaeiykakiaeyypa0zaaabcaeaacqwgwbgvcqwgbbqqcqwgsbgucqggoaakcqwgdbwqdawgaawcbagaemyaakgabeaakiabcmcapawcbagaemyaakmaeyypa0jaegymaedabagaem4aasmaeyoei0iaegymaedaniabgghildgccawljagaaczcaiabcicaoiabikdayiabcmcapaaa@5410@

is minimized. genclust provides a feasible solution to the posed optimization problem, and experiments show its convergence to a local optimum.

the algorithm genclust
genclust proceeds in stages, producing a sequence of partitions pi
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbamxvp5wqsxmqhnxajn0bkvguhdwzzbqegm0b1jxaljhiov2daebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabawaaegaeaaakeaaimaacawfqbwaasbaasqaaiabdmgapbqabaaaaa@3af2@, each consisting of k classes, until a halting condition is met. let α =  be an individual, x ∈ x and  <dig> ≤ λ <k. a partition pi
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbamxvp5wqsxmqhnxajn0bkvguhdwzzbqegm0b1jxaljhiov2daebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabawaaegaeaaakeaaimaacawfqbwaasbaasqaaiabdmgapbqabaaaaa@3af2@ is best seen as a collection of individuals arranged in any order, i.e., a population. only at the end, genclust assembles elements according to cluster number. following the evolutionary computational paradigm, a population evolves by means of genetic operators, i.e., cross-over, mutation and selection, resulting in a random walk in cluster space, where the fitness function gives a drift to the process towards a local optimum.

the internal data representation and coding is crucial to genclust. the elements of x are stored into an n × d matrix, and the row r, corresponding to x, is the internal name of x. we also keep the inverse mapping r- <dig> = x,  <dig> ≤ i <n -  <dig>  a partition p
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbamxvp5wqsxmqhnxajn0bkvguhdwzzbqegm0b1jxaljhiov2daebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabawaaegaeaaakeaaimaacawfqbaaaa@396b@ of x is encoded with a list of n 32-bit strings, each representing an individual . that individual is encoded, one-to-many, by arbitrarily choosing a string s from a set of 32-bit strings, as follows. the least significant  <dig> bits of s give a "representation" of λ and the remaining ones a "representation" of r. if r is in , the binary encoding of any integer in 
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqacigacagaaeqabaqabegadaaakeaadawadaqaaiabdmgapjabgehiqmaagmaabawaasaaaeaacqaiyagmdaahaawcbeqaaiabikdayiabisda0aaaaoqaaiabd6gaubaaaiaawcp+cagl7jpacqggsaalcqggoaakcqwgpbqacqghrawkcqaixaqmcqggpaqkcqghxiikdagbdaqaamaalaaabagaegomaizaawbaasqabeaacqaiyagmcqai0aanaaaakeaacqwgubgbaaaacaglwjvaay5+4dgaeyoei0iaegymaedacaglbbgaayzxaaaaaa@4cb1@ will do. otherwise, the binary encoding of any integer in 
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqacigacagaaeqabaqabegadaaakeaadawadaqaaiabd6gaunaagmaabawaasaaaeaacqaiyagmdaahaawcbeqaaiabikdayiabisda0aaaaoqaaiabd6gaubaaaiaawcp+cagl7jpacqggsaalcqaiyagmdaahaawcbeqaaiabikdayiabisda0aaakiabgkhitiabigdaxagaay5waiaaw2faaaaa@3f71@ will do. analogous rules apply to λ, except that  <dig> and n are replaced by  <dig> and k, respectively. given any 32-bit string, we can recover in a constant number of operations the unique , λ) of which it can be an encoding, and therefore  . the straightforward details are omitted. in what follows, d returns , λ), with d <dig> = r and d <dig> = λ, x ∈ x and  <dig> ≤ λ <k. the chosen encoding is compact, easy to handle, and allows up to  <dig> classes and data sets of size up to  <dig> , <dig> elements, values adequate for real applications.

the initial partition p0
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbamxvp5wqsxmqhnxajn0bkvguhdwzzbqegm0b1jxaljhiov2daebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabawaaegaeaaakeaaimaacawfqbwaasbaasqaaiabicdawaqabaaaaa@3a85@ can be computed by either randomly partitioning the elements of x into k classes or by using a user specified partition of the elements of x, such as the one produced by yet another clustering algorithm.

the heart of genclust is the transition in cluster space from pi
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbamxvp5wqsxmqhnxajn0bkvguhdwzzbqegm0b1jxaljhiov2daebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabawaaegaeaaakeaaimaacawfqbwaasbaasqaaiabdmgapbqabaaaaa@3af2@ to pi+1
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbamxvp5wqsxmqhnxajn0bkvguhdwzzbqegm0b1jxaljhiov2daebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabawaaegaeaaakeaaimaacawfqbwaasbaasqaaiabdmgapjabgucariabigdaxaqabaaaaa@3cc4@, i ≥  <dig>  this is accomplished by a proper manipulation of the 32-bit strings in the list li =  encoding pi
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbamxvp5wqsxmqhnxajn0bkvguhdwzzbqegm0b1jxaljhiov2daebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabawaaegaeaaakeaaimaacawfqbwaasbaasqaaiabdmgapbqabaaaaa@3af2@. assume that li is sorted according to the internal representation of the elements; i.e., d <dig> <d <dig>  p <j. the following steps are applied in order.

cross-over
the objective is to produce a list ltemp of new binary strings by properly recombining the ones in li. for each string sj,  <dig> ≤ j <n, the standard one point cross-over operation is performed  <cit> , with probability  <dig> . the second string is chosen at random from the ones in li - {sj}. the cross-over operation generates two new strings that are appended to ltemp. at the end, ltemp is a list of m ≤ n 32-bits strings. notice that, because of the encoding and decoding process we are using, the recombined string will still represent a pair , λ), with  <dig> ≤ r <n and  <dig> ≤ λ <k.

first selection
notice that while each string in li corresponds to exactly one element x ∈ x and vice versa, that is no longer true for the concatenated lists li ○ ltemp. we eliminate duplicates by keeping only the rightmost string s in li ○ ltemp such that d <dig> = j, for j =  <dig>  ..., n -  <dig>  denote the result by l'.

one-bit mutation
l' is an encoding of a partition related to pi
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbamxvp5wqsxmqhnxajn0bkvguhdwzzbqegm0b1jxaljhiov2daebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabawaaegaeaaakeaaimaacawfqbwaasbaasqaaiabdmgapbqabaaaaa@3af2@. in order to climb out of local minima, it is perturbed as follows. for j =  <dig>  ..., n -  <dig>  a one-bit mutation is applied to s′j
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqacigacagaaeqabaqabegadaaakeaacuwgzbwcgaqbamaabaaaleaacqwgqbgaaeqaaaaa@2fb2@ ∈ l' with probability  <dig> , resulting in a string s. there are several possible outcomes. the mutation is silent, i.e., d = d. no action is taken. it affects the cluster membership of d <dig>  i.e., d <dig> = d <dig> but d <dig> ≠ d <dig>  or it causes a collision, i.e., there exists an s′p
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqacigacagaaeqabaqabegadaaakeaacuwgzbwcgaqbamaabaaaleaacqwgwbacaeqaaaaa@2fbe@ in l', p ≠ j, such that d <dig> = d <dig>  then, s replaces s′j
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqacigacagaaeqabaqabegadaaakeaacuwgzbwcgaqbamaabaaaleaacqwgqbgaaeqaaaaa@2fb2@.

second selection
we have now two lists li and l' of n 32-bit strings, representing the encoding of pi
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbamxvp5wqsxmqhnxajn0bkvguhdwzzbqegm0b1jxaljhiov2daebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabawaaegaeaaakeaaimaacawfqbwaasbaasqaaiabdmgapbqabaaaaa@3af2@ and p′i
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbamxvp5wqsxmqhnxajn0bkvguhdwzzbqegm0b1jxaljhiov2daebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabawaaegaeaaakeaaimaacewfqbgbauaadawgaawcbagaemyaakgabeaaaaa@3afe@ where this latter one is possibly a new partition. let l' be sorted according to the internal representation of the elements, i.e., d <dig> <d <dig>  p <j. the encoding li+ <dig> = {c <dig>  ..., cn-1} of pi+1
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbamxvp5wqsxmqhnxajn0bkvguhdwzzbqegm0b1jxaljhiov2daebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabawaaegaeaaakeaaimaacawfqbwaasbaasqaaiabdmgapjabgucariabigdaxaqabaaaaa@3cc4@ is obtained via the following selection process:

cr={s′rif f)<f)srotherwise
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqacigacagaaeqabaqabegadaaakeaacqwgjbwydawgaawcbagaemocaihabeaakiabg2da9maaceaabaqbaeaabigaaaqaaiqbdohazzaafawaasbaasqaaiabdkhaybqabaaakeaacqwgpbqacqwgmbgzcaamc8uaemozaymaeiikagiaemiraqkaeiikagiafm4camnbauaadawgaawcbagaemocaihabeaakiabcmcapiabcmcapiabgyda8iabdagamjabcicaoiabdseaejabcicaoiabdohaznaabaaaleaacqwgybgcaeqaaogaeiykakiaeiykakcabagaem4cam3aasbaasqaaiabdkhaybqabaaakeaacqqgvbwbcqqg0badcqqgobaacqqglbqzcqqgybgccqqg3bwdcqqgpbqacqqgzbwccqqglbqzaaaacagl7baaaaa@5b75@

r =  <dig>  ..., n -  <dig> and where

f)=1d∑j=1dj)2max⁡j))2     
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqacigacagaaeqabaqabegadaaakeaacqwgmbgzcqggoaakcqggoaakcqwg4baecqggsaalcqah7oabcqggpaqkcqggpaqkcqgh9aqpdagcaaqaamaalaaabagaegymaedabagaemizaqgaamaaqahabawaasaaaeaacqggoaakcqwg4baedawgaawcbagaemoaaogabeaakiabgkhitiabdogajjabcicaoiabdoeadnaabaaaleaacqah7oabaeqaaogaeiykakyaasbaasqaaiabdqgaqbqabagccqggpaqkdaahaawcbeqaaiabikdayaaaaoqaaigbc2gatjabcggahjabciha4jabcicaoiabdiha4naabaaaleaacqwgqbgaaeqaaogaeiilawiaem4yammaeiikagiaem4qam0aasbaasqaaiabeu7asbqabagccqggpaqkdawgaawcbagaemoaaogabeaakiabcmcapiabcmcapmaacaaaleqabagaegomaidaaaaaaeaacqwgqbgacqgh9aqpcqaixaqmaeaacqwgkbaza0gaeyyeiuoaasqabagccawljagaaczcaiabcicaoiabiodaziabcmcapaaa@6570@

is the fitness function of individual  in a generic partition p
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbamxvp5wqsxmqhnxajn0bkvguhdwzzbqegm0b1jxaljhiov2daebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabawaaegaeaaakeaaimaacawfqbaaaa@396b@, and cλ is cluster number λ in that partition. that is, f) refers to the partition encoded by l' and f) to the one encoded by li.

there are several types of halting criteria that can be used for genclust. we have considered one in which the algorithm is given a user-specified number of iterations, i.e., number of partitions pi
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbamxvp5wqsxmqhnxajn0bkvguhdwzzbqegm0b1jxaljhiov2daebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabawaaegaeaaakeaaimaacawfqbwaasbaasqaaiabdmgapbqabaaaaa@3af2@ to produce. at each iteration, apart from the current partition, it also keeps track of the partition corresponding to the best internal variance seen over the iterations performed so far. another user-specified parameter indicates whether, at the end of the iterations, the algorithm must output the last partition or the one corresponding to the minimum internal variance seen during its execution. we refer to those partitions as plast
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbamxvp5wqsxmqhnxajn0bkvguhdwzzbqegm0b1jxaljhiov2daebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabawaaegaeaaakeaaimaacawfqbwaasbaasqaaiabdygasjabdggahjabdohazjabdsha0bqabaaaaa@3f23@ and pbest
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbamxvp5wqsxmqhnxajn0bkvguhdwzzbqegm0b1jxaljhiov2daebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabawaaegaeaaakeaaimaacawfqbwaasbaasqaaiabdkgaijabdwgaljabdohazjabdsha0bqabaaaaa@3f17@, respectively. the rationale behind the described mode of operation is to allow genclust to climb out of local optima. since the number of iterations must be determined experimentally, the algorithm outputs also two auxiliary files: variance, reporting the values of internal variance, and best, internal variance for each iteration. this point is related to the convergence of genclust to a local optimum and is discussed in the experiments subsection.

we point out that the inherent freedom of the one-to-many mapping of individuals to binary strings, which we have used, provides enough flexibility so that genclust can work on one single partition, allowing it to change. this should be contrasted with other existing clustering algorithms based on the genetic paradigm, since at each stage, they typically maintain a family of partitions  <cit> . this results in higher computational demand when going from one iteration to the next.

since genclust needs in input the number k of clusters, it must be used in conjunction with a methodology that guides in the estimation of the real number of clusters in a data set and also evaluates the quality of clustering solutions. we have chosen fom for our experiments, since it has had great impact on the scientific literature in this area. valid alternatives are described in  <cit> , where additional references to the literature are also given. data reduction techniques, such as filtering  <cit>  and principal component analysis may also be of help in those circumstances.

RESULTS
experimental methodology
we have chosen data sets for which a biological meaningful partition into classes is known in the literature: e.g., biologically distinct functional classes. we refer to that partition as the true solution. we have also chosen a suite of algorithms, average link among the hierarchical methods  <cit> , k-means  <cit> , cast, click against which we compare the performance of genclust, established by means of external and internal criteria. the external criteria measure how well a clustering solution computed by an algorithm agrees with the true solution for a given data set. among the many available  <cit> , we have chosen the adjusted rand index  <cit> , a flexible index allowing comparison among partitions with different numbers of classes and also recommended in the statistics and classification literature  <cit> . when the true solution is not known, the internal criteria must give a reliable indication of how well a partitioning solution produced by an algorithm captures the inherent separation of the data into clusters, i.e., how many clusters are really present in the data. we have chosen fom for our experiments.

data sets
rcns. the data set is obtained by reverse transcription coupled pcr to study the expression levels of  <dig> genes during rat central nervous system development over  <dig> time points  <cit> . that results in a 112x <dig> data matrix. it was studied by wen et al.  <cit>  to obtain a division of the genes into  <dig> classes, four of which are composed of biologically functionally related genes. this division is assumed to be the true solution. before the analysis, wen et al. performed two transformations on the data for each gene:  each row is divided by its maximum value;  to capture the temporal nature of the data, the difference between the values of two consecutive data points is added as an extra data point. therefore, the final data set consists of a 112x <dig> data matrix, which is the input to our algorithms. we point out that the second transformation has the effect to enhance the similarity between genes with closely parallel, but offset, expression patterns.

ycc. the data set is part of that studied by spellman et al.  <cit>  and has been used by sharan et al. for validation of their clustering algorithm click. the complete data set contains the expression levels of roughly  <dig> yeast orfs over  <dig> conditions. the analysis by spellman et al. identified  <dig> genes that are cell cycle regulated. in order to demonstrate the validity of click, sharan et al. extracted  <dig> out of those  <dig> genes, over  <dig> conditions, by eliminating all genes that had at least three missing entries. additional details on that "extraction process" can be found in  <cit> . the resulting 698x <dig> data matrix is standardized  and used for our experiments. the true solution is given by the partition of the  <dig> extracted genes according to the five functional classes they belong to in the classification by spellman et al.

rycc. this data set originates in the one by cho et al.  <cit>  for the study of yeast cell cycle regulated genes and has been created and used by ka yee yeung for her study of fom in her doctoral dissertation  <cit> . ka yee yeung extracted  <dig> genes from the yeast cell cycle data set in cho et al. to obtain a 384x <dig> data expression matrix. the details of the extraction process are in  <cit> . that matrix is then standardized as in tamayo et al.  <cit> . that is, the data matrix is divided in two contiguous pieces and each piece is standardized separately. we use that standardized data set for our experiments and assume as the true solution the same as in the dissertation by ka yee yeung. it is to be pointed out that each gene in the rycc data set appears also in the ycc data set. however, the dimensionality of the two data sets is quite different, and this may cause algorithms to behave differently. moreover, rycc is also useful for a qualitative comparison of our results with the ones in the doctoral dissertation by ka yee yeung.

pbm. the data set was used by hartuv et al.  <cit>  to test their clustering algorithm. it contains  <dig> cdnas with a fingerprint of  <dig> oligos. this gives a 2329x <dig> data matrix. each row corresponds to a gene, but different rows may correspond to the same gene. the true solution consists of a division of the rows in  <dig> classes, i.e., the data set consists of  <dig> genes.

rpbm. since fom was too time demanding to complete its execution on the data set by hartuv et al., we have reduced the data in order to get an indication of the number of clusters in the data set. we have randomly picked 10% of the cdnas in each of the  <dig> original classes. whenever that percentage is less than one, we have retained the entire class. the result is a 235x <dig> data matrix, and the true solution is readily obtained from that of pbm. data sets are provided as supplementary material  <cit> .

algorithms
average link has been implemented, among the hierarchical methods. following prior work  <cit> , a dendogram is built bottom-up until one obtains k subtrees, for a user-specified parameter k. then, k clusters are obtained by assuming that the genes at the leaves of each subtree form a distinct cluster. we have also implemented genclust and k-means. both algorithms take as input a parameter k and return k clusters. they can either start with a randomly generated initial partition of the genes in k classes, or they can take as input a user-specified partition of the elements, for instance the output of yet another clustering algorithm. for our experiments, we have chosen the output of average link in this second case. in what follows, the type of initial partition chosen for those two algorithms appear as a suffix, i.e., k-means-random means that the initial partition has been generated at random. moreover, since genclust can output one of two partitions, i.e., plast
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbamxvp5wqsxmqhnxajn0bkvguhdwzzbqegm0b1jxaljhiov2daebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabawaaegaeaaakeaaimaacawfqbwaasbaasqaaiabdygasjabdggahjabdohazjabdsha0bqabaaaaa@3f23@ or pbest
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbamxvp5wqsxmqhnxajn0bkvguhdwzzbqegm0b1jxaljhiov2daebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabawaaegaeaaakeaaimaacawfqbwaasbaasqaaiabdkgaijabdwgaljabdohazjabdsha0bqabaaaaa@3f17@, we also add the appropriate suffix. so, genclust-random-last takes as input a random partition and returns the last partition produced during its execution. we also used an implementation of cast that was made available to us by ka yee yeung and that is well suited for the fom methodology. finally, we have used the version of click available with the expander software system  <cit> .

validation criteria
the adjusted rand index measures the level of agreement between two partitions, not necessarily containing the same number of classes. qualitatively, it takes value zero when the partitions are randomly correlated, value one when there is a perfect correlation, and value - <dig> when there is perfect anti-correlation. those statements can be put on a more formal ground.

2-norm fom, which is the internal measure used for our experiments, is a measure of the predictive power of a clustering algorithm. it should display the following properties. for a given clustering algorithm, it must have a low value in correspondence with the number of clusters that are really present in the data. moreover, when comparing clustering algorithms for a given number of clusters k, the lower the value of 2-norm fom for a given algorithm, the better its predictive power. experiments by ka yee yeung et al. show that the fom family and its associated validation methodology satisfy those properties with a good degree of accuracy. indeed, ka yee yeung et al. give experimental evidence of some degree of anti-correlation between fom and adjusted rand index, in particular when the number of clusters is small. since it is a rather novel measure, we provide a formal definition.

for a given data set, let r denote the raw data matrix, e.g., the data matrix without standardization for our data sets. assume that r has dimension nxm, i.e., each row corresponds to a gene and each column corresponds to an experimental condition. assume that a clustering algorithm is given the raw matrix r with column e excluded. assume also that, with that reduced data set, the algorithm produces k clusters c <dig>  ..., ck- <dig>  let r be the expression level of gene g and mi be the average expression level of condition e for genes in cluster ci. the 2-norm fom with respect to k clusters and condition e is defined as:

fom=1n∑i=0k−1∑x∈ci−mi)2     
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqacigacagaaeqabaqabegadaaakeaacqqggbgrcqqgpbwtcqqgnbqtcqggoaakcqwglbqzcqggsaalcqwgrbwacqggpaqkcqgh9aqpdagcaaqaamaalaaabagaegymaedabagaemoba4gaamaaqahabawaaabuaeaacqggoaakcqwgsbgucqggoaakcqwg4baecqggsaalcqwglbqzcqggpaqkcqghsislcqwgtbqbdawgaawcbagaemyaakgabeaakiabcicaoiabdwgaljabcmcapiabcmcapmaacaaaleqabagaegomaidaaaqaaiabdiha4jabgigiolabdoeadnaabaaameaacqwgpbqaaeqaaawcbeqdcqghris5aawcbagaemyaakmaeyypa0jaegimaadabagaem4aasmaeyoei0iaegymaedaniabgghildaaleqaaogaaczcaiaaxmaacqggoaakcqai0aancqggpaqkaaa@5d8d@

notice that fom is essentially a root mean square deviation. the aggregate 2-norm fom for k clusters is then:

fom=∑e=1mfom     
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqacigacagaaeqabaqabegadaaakeaacqqggbgrcqqgpbwtcqqgnbqtcqggoaakcqwgrbwacqggpaqkcqgh9aqpdaaewbqaaiabbaeagjabb+eapjabb2eanjabcicaoiabbwgaljabcycasiabbugarjabcmcapawcbagaemyzaumaeyypa0jaegymaedabagaemyba0ganiabgghildgccawljagaaczcaiabcicaoiabiwda1iabcmcapaaa@479d@

a few remarks are in order. both formulae  and  can be used to measure the predictive power of an algorithm. the first gives us more flexibility, since we can pick any condition, while the second gives us a total estimate over all conditions. following the literature, we use  in our experiments. moreover, since the experimental studies conducted by ka yee yeung et al. show that fom behaves as a decreasing function of k, an adjustment factor has been introduced to properly compare clustering solutions with different numbers of clusters. a theoretical analysis by ka yee yeung et al. provides the following adjustment factor:

n−kn.     
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqacigacagaaeqabaqabegadaaakeaadagcaaqaamaalaaabagaemoba4maeyoei0iaem4aasgabagaemoba4gaaawcbeaakiabc6cauiaaxmaacawljagaeiikagiaegonayjaeiykakcaaa@36cd@

when  divides , we refer to  and  as adjusted foms. we use the adjusted aggregate fom for our experiments and, for brevity, we refer to it simply as fom.

experimental setup
all of the experiments were performed on a pc with 1g of main memory and a  <dig>  ghz amd athlon  <dig> processor. for the randomized algorithms, i.e., cast, genclust-random, k-means-random, we executed five runs to measure the variability of the validation measures with respect to the various solutions found by the algorithms. we find that only k-means-random and genclust-random-best display a non-negligible variation from run to run, but for the adjusted rand index only. for those algorithms and particular index, we report the minimum and the maximum value obtained in each run, while we give the results of a single run in all other cases.

experiments
we now analyze the performance of genclust, with respect to the choice of the initial partition, the two partitions it can give in output, and the performance of the other algorithms.

convergence to a local optimum of internal variance
for each of the chosen data sets, we have run genclust-random-last for  <dig> iterations; i.e., it has produced  <dig> partitions. the value of k has been set equal to the classes in the true solution for each data set. the results are reported in figure  <dig>  as is evident, such a convergence indeed takes place with a good degree of accuracy. it is also worth noting that for rcns, ycc and rycc, the convergence is rather fast, i.e.,  <dig> iterations. for the remaining two data sets, it is somewhat slower and, for one of them, less pronounced. the same conclusions apply to genclust-random-best.

genclust and the best and last partition
the discussion here refers to the data available at  <cit>  , summarizing the experiments we conducted for genclust-random-best and genclust-avlink-best. this latter algorithm is really indistinguishable from avlink. indeed, it is not surprising that genclust-avlink-best retains the main characteristics of the initial partition given by avlink, which, in our experiments, often provides an initial partition to genclust-avlink-best with the best variance. this fact seems to indicate that the partition corresponding to the best variance should not be required as output to genclust if the initial partition is given by another clustering algorithm. genclust-random-best seems to be related to k-means-random. indeed, the relation is quite strong for fom. as for the adjusted rand index, the minimum values of the two algorithms are in many circumstances quite close. such a relation is less pronounced for the maximum values, where sometimes one of the two algorithms dominates the other. there is, however, one important difference between the two algorithms: genclust-random-best is much faster than k-means-random, e.g., four times faster on the pbm data set. the relation between the two algorithms seems to have the following justification. starting from a random partition, k-means-random tries to minimize the internal variance and, in practice, it aims at a good local optimum. genclust-random-best performs pretty much the same task by keeping track of the partition corresponding to the best variance seen during its execution. based on those considerations, from now on we discuss only genclust-random-last and genclust-avlink-last and, for brevity, drop the suffix last.

a synopsis of genclust performance for external and internal criteria
the values of interest are the adjusted rand index and fom. they have been computed requiring all algorithms, except click, to produce a number of clusters equal to the classes of the true solution in each data set. the results are reported in tables  <dig>   <dig>   <dig>   <dig>   <dig>  table  <dig> refers to click, used in an unsupervised fashion, and for the adjusted rand index. indeed, click does not lend itself to adaptation with the fom methodology. data has been given to click, which has returned a partition. since click leaves elements unclustered, we have grouped all of those singletons together in one class in order to compute the adjusted rand index. the number of classes in table  <dig> accounts for that unification.

the first striking conclusion is that no algorithm is markedly superior to the others on all indexes and all data sets. indeed, in many cases the observed differences between the worst and best performing algorithm may be statistically insignificant and they could be considered equivalent. however, there are cases in which an algorithm may be better than others and therefore worthwhile.

based on the synopsis, it appears that genclust-avlink is to be preferred to genclust-random. moreover, genclust-avlink seems to take better advantage of the output of average link than k-means. it also appears that genclust-avlink is competitive, both in comparison with classic algorithms, i.e., average link and k-means, and more recent state-of-the-art ones, such as cast and click. the following present a detailed description of our experiments.

external criteria
this discussion refers to figure  <dig>  we recall from the literature that a good algorithm must display a good value of the adjusted rand index for clustering solutions that have a number of clusters close to the classes of the true solution, for any given data set.

with that criterion in mind, we see that, with the exception of the rcns data set, genclust is better with an initial partition provided by average link, in particular around the number of clusters in the true solution of each of the corresponding data sets.

moreover, on the ycc, rycc and rpbm data sets, genclust seems to take better advantage than k-means of the initial knowledge of the partition produced by average link.

when compared with all of the methods, genclust-avlink has a performance at least as good, and sometimes better, on three of the data sets, i.e., ycc, rycc and rpbm, around the number of classes in the true solution of each data set.

internal criteria
this discussion refers to figure  <dig>  we recall from the literature  <cit>  that the fom methodology captures the intrinsic structure in the data by exhibiting a very characteristic steep decline as the number of clusters grows and approaches the number of clusters in the true solution. for our data sets, we find that all partitional algorithms exhibit excellent predictive power on the rcns, ycc and rycc. in particular, the curve of each algorithm indicates that the number of clusters really present in the data is close or at exactly the number of classes in the true solution of each data set. moreover, when the genclust curves are excluded from the fom diagrams, the results are essentially analogous to the ones reported in  <cit>  for the same algorithms on essentially the same data sets. since in  <cit>  it is concluded that k-means and cast have excellent predictive power, we can draw the same conclusion for both versions of genclust. as for the rpbm, we see that all algorithms do not exhibit any noticeable decline as the number of clusters grows. this may be a limitation of the fom methodology, which displays some anti-correlation with the adjusted rand index only for data sets with a small number of clusters in the true solution, as shown by ka yee yeung et al. in fact, the internal validation of pbm and rpbm attempted here may indicate both a computational and sensitivity limitation of the fom methodology; i.e., a data set with relatively large numbers of conditions and genes and a large number of clusters. indeed, the external validation measure on both data sets shows that genclust picks a substantial part of the true solution at a number of clusters reasonably close to  <dig>  in general, any algorithm such as genclust and kmeans, will be limited by the power of the validation methodology associated to it. valid alternatives to fom are given in  <cit> . in particular, monti et al. provide a good presentation of those alternatives. unfortunately, the data driven measures may display the same computational limitations displayed by fom. principal component analysis, a widely used data dimensionality reduction technique for clustering, may be of great help to reduce the computational demand of data driven validation measures. unfortunately, its application to gene expression data is not entirely straightforward. this point is investigated experimentally in ka yee yeung doctoral dissertation, where different strategies are proposed and compared. in those circumstances, it is also advisable to filter the data set, for instance with the genecluster software package  <cit> , leaving out genes that do not display any significant changes. that may result in a substantial reduction of the data set, as shown ka yee yeung et al. in the analysis of the barrett esophagus data set.

CONCLUSIONS
we have presented a very simple genetic algorithm for clustering of gene expression data, i.e., genclust, and we have evaluated its performance on real data sets and in comparison with other either classic or more state-of-the-art algorithms, with use of both external and internal validation criteria. the study shows that none of the chosen algorithms is clearly superior to the others in terms of ability to identify classes of truly functionally related genes in the given data sets. however, genclust seems to be competitive with all of the implemented algorithms and well suited for use in conjunction with the data driven internal validation measures, as the experiments with fom indicate.

availability and requirements
- project name: genclust

- project home page: 

- operating systems: windows xp, mac osx, linux operating systems .

- programming languages: standard ansi c. compilation tested on microsoft visual c++  <dig>  pelles c for windows-version  <dig> . <dig>  and various gcc versions .

- other requirements: none

- license: gnu gpl

- any restriction to use by non-academics: reference to paper

abbreviations
fom: figure of merit

pbm: pheripheral blood monocytes

rpbm: reduced pheripheral blood monocytes

rcns: central nervous system rat

rycc: reduced yeast cell cycle

ycc: yeast cell cycle

authors' contributions
all authors participated in the design of the evaluation of genclust. the initial design and engineering of the algorithm is due to g. lo bosco and v. di gesú. d. scaturro and a. raimondi realized part of the software needed for the comparative analysis of genclust. r. giancarlo coordinated the research and wrote the report. all authors have read and approved the manuscript.

