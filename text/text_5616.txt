BACKGROUND
recent chip and high-throughput sequencing technologies are currently generating functional annotations at unprecedented speed and resolution. the availability of detailed protein binding locations, dna methylation, histone modifications, dna variations of individuals, and more for different tissues and conditions, provides the basis for a plethora of representational formats of genome wide data. adding to this, new technologies for assessing the three-dimensional structure of the dna, such as hi-c  <cit> , introduce the concepts of distance measures between different parts of a genome, opening up a whole new set of representational complexity.

several efforts have been attempted at defining general formats for the textual representation of genome annotation data. one such format is the general feature format , currently in version  <dig>  <cit> . other generic formats are provided in connection to the ucsc genome browser  <cit> , the browser extensible data format , bedgraph and wig, among others. one reason for the different formats is that different properties are required, often in order to support information related to specific domains, technologies or experimental methods. consider for instance the bed <dig> format by ucsc. this is an extension of the bed format, adding  <dig> columns in order to represent microarray expression data  <cit> . other examples are the gene transfer format   <cit>  for gene tracks and the genome variation format   <cit>  for dna variant files, both based on the gff format.

another reason behind the proliferation of formats seems to be an issue of practicality. certain types of genome annotations, or genomic tracks, are more efficiently and elegantly represented by certain data formats. consider a track of dna melting temperatures, i.e. an algorithmic prediction of the denaturation temperature for each base pair of the genome, e.g.  <cit> . representing such a track in the wiggle format  would take around  <dig> gb for the human genome. the exact same information could be represented in the bedgraph format, but the file size would then expand to around  <dig> gb. in this case, the file would contain much redundant information, such as repeated chromosome declarations, and start and end positions that are always increased by one for each line. the help pages at the ucsc genome browser explicitly recommend the wig format for "dense, continuous data" and bedgraph for "continuous data that is sparse or contains elements of varying size"  <cit> . from this it seems that, at an abstract level, there may exist fundamental distinctions between track data, such that warrants the use of particular textual formats. we are, however, not aware of any systematic discussion of such distinctions in the literature.

expanding on this notion of systematic distinctions between track data, it seems that such distinctions also warrant differences in which analyses are applicable. it is for instance meaningful to ask whether snps fall inside exons, but it is not meaningful to ask whether snps fall inside melting temperature. conversely, one can ask whether snp locations have high melting temperatures, but not whether snps have high exons. this indicates that there may be some form of abstract grammar, where each track defines a set of informational properties, and each analysis only makes sense on certain sets of informational properties for the tracks in question.

in this paper, we start with a clarification of basic nomenclature. we then discuss how the presence of different core informational properties of a track can be used to delineate fifteen different types of tracks at an abstract level. the fifteen track types encompass most existing data formats, in addition to open up for data sets making use of cross-positional linking, e.g. data sets based on the three-dimensional structure of dna. we continue by reviewing common, generic formats, in tabular, xml-based, or binary form, and discuss how they fit with the proposed track types. this is followed up with the proposal of a new tabular format and an updated xml format for track data. these formats build closely on previous ones, but obey the distinctions between types of tracks. finally, we discuss supporting tools for the proposed formats, including a code base supporting the storage of tracks in efficient binary format, illustrating how the formats can be pragmatically applied in high-speed analyses.

RESULTS
definitions
a reference genome may be abstracted as a line-based coordinate system. to build on this powerful metaphor, we use the term genomic track  to refer to a series of data units positioned on such a line. the basic informational unit is called a track element, that is, a unit of data with associated genomic coordinates that may or may not be explicitly specified. a track element is to be thought of as a mathematical or implementational abstraction, in tabular formats typically represented as a single data line. although the concept of genomic tracks is most useful for describing data that refer to a single reference genome, the meaning carries easily over to datasets referring to multiple reference genomes, or to contigs or scaffolds of partially assembled genomes.

we further define a genome feature as a track element or set of track elements comprising a biological unit, e.g. a specific gene, of a certain feature type, e.g. genes. the term biological unit is to be understood broadly and should also include experimental results, algorithmic predictions and similar concepts, such as defined under sequence feature in the sequence ontology  <cit> . note that a feature, e.g a gene, may be composed of several track elements, e.g. representing the exons of that gene. often, a complete genome annotation, i.e. features of many feature types connected to a genome, are collected into a single file. this complicates the comparison of different feature types, creating the need for filtering such a file for the appropriate feature types prior to analysis. on the other hand, restricting a track to contain only a single feature type may reduce the information. for example, the connection between genes and their exons is lost if the two feature types are stored as separate tracks. we thus define a genomic track more specifically as set of track elements of one or several feature types, defined over an appropriate genome-scale coordinate system, where the set of feature types constitutes a pragmatic unit for analysis. a genomic track is then, in our view, defined in relation to an analytical purpose, whether explicitly defined or only suggested; this, in contrast to a data file used mainly for storage, which should be considered more as a flat file database.

core informational properties of tracks
a genomic track consists of a set of track elements and, for each element, describes a set of properties, such as an identifier, a quality score or the method used. the positional information of a track element is obligatory for any genomic track and can be interpreted generically across tracks. the position of a track element is often encoded as a pair of start and end coordinates. however, when looking at genomic tracks from the perspective of information content, we find it fruitful to identify the positional information equivalently as the lengths of the track elements and the gaps between them, both measured in base pairs. as the positional information is essential and generic, we refer to gaps and lengths as core informational properties of the track.

a genomic track may also carry a main value associated with each track element, for instance the measured expression of a gene or the copy number of a genomic region. we thus include values among the core informational properties. this main value can be a number , a binary value , a category , a character , or a list of values .

lastly, a track element may be connected to other track elements located at different locations on the genome. this is critical for three-dimensional tracks, as locations that seem far apart when the dna is unwound, could still be co-located in the nucleus. the corresponding core informational property of a track is then interconnections. the interconnections, or edges, are either directed or undirected, possibly with an attached weight value.

fifteen genomic track types
all four core informational properties  will not always be defined for a track. consider, for instance, a track of viral insertion points on a genome. as it makes no sense to talk about the length of an insertion point, such a track will not have the lengths property defined. similarly, a track of single nucleotide polymorphisms  will only contain elements that refer to single discrete positions on the genome. the track elements will, however, have associated values denoting the respective alleles. consider also the dna melting map, a track where a temperature value is assigned to every base pair of the genome  <cit> . as temperature values, i.e. track elements, are defined for every consecutive position of the genome, there is never any gaps between the elements. also, the elements refer to single base pairs and have no lengths. thus, a track of dna melting will have neither the lengths nor the gaps property defined, only the values property .

four core properties, being defined or not, gives  <dig> =  <dig> distinct combinations. assuming that a genomic track always consists of track elements with the same core properties, we can distinguish tracks on the basis of which combination of core properties are defined. for one of the sixteen combinations, no core properties are defined. it is thus of no interest, hence reducing the set to fifteen combinations.

looking closely at the fifteen combinations, an interesting pattern appears. figure  <dig> shows an illustration of the informational contents of each combination. as every combination denotes a particular geometric configuration, strikingly distinct from the others, we refer to tracks of the different combinations as having different track types. the concept of dividing genomic tracks into track types was partially introduced in  <cit> , but has now been expanded from five to fifteen track types.

looking at the top left of figure  <dig> and going downward, we start at the base case where the only core informational property is the gaps between the track elements. in this case, each track element represents an exact base pair location on the genome, denoting e.g. viral insertion sites. we call this track type points . adding informative values to this case, e.g. associating snps with allele frequencies, we get the track type valued points . in the next two cases, the lengths property is added, resulting in the track types segments  and valued segments . segments are probably the most common track type of existing tracks, representing common features such as genes or exons. valued segments could, for instance, denote genes with associated expression levels.

moving on, we remove the values and gaps properties, leaving only lengths. such tracks consist of segments covering all base pairs of the genome, i.e. a partition of the genome into potentially unequal pieces. hence, the track type is called genome partition . basic examples of this track type are the partition of a genome into chromosomes or cytobands. adding a value to each part of a partition creates a step function , covering the whole genome with values. basic examples of such tracks are tracks denoting results of tiling microarrays, providing that any gaps or overlaps between the tiles are ignored. removing the lengths core property, the step function track is transformed into a track of type function , where every base pair has an associated value. examples of function tracks are tracks with close dependency on the genome sequence, such as gc content tracks, or predictions of melting temperatures, as outlined above. we call the seven track types outlined here for basic track types.

the fourth core informational property, interconnections, can be envisioned as an orthogonal extension to the previous discussion. adding interconnections, or edges, to the seven track types previously outlined  defines linked versions of the same track types, e.g. linked segments  or linked step function  . although tracks that include interconnections are presently in little use, enough datasets exist to warrant the definition of all the linked track types, at least for completeness. for example, the recent hi-c dataset of dekker et al.  <cit>  partitions the genome into  <dig> mbp regions , where each pair of regions has an associated proximity value. this dataset is then of type linked genome partition , where every region has a weighted edge to all other regions. more traditionally, one could envision a gene/protein pathway being represented as gene segments, perhaps also with associated expression data, being linked together with directed edges representing associations . this would be of type linked valued segments . note that a track type is considered linked if at least some track elements are interconnected.

to complete the picture, a last track type needs to be defined. if only the interconnections core property is defined, track elements do not have gaps between them, lengths, or values. all base pairs are then track elements, with each base pair connected to other base pairs by edges, hence the name linked base pairs . thinking in term of graphs, all base pairs will thus be nodes, although not all nodes need to have any edges. this, in contrast to the track type linked points, which limits the nodes to a specified set of points. the track type linked function  is similar to linked base pairs, only adding an associated value to each base pair . the linked base pairs track type is mostly suggestive at this point, but at least theoretically, this would be the track type of the perfect three-dimensional track, mapping the distance between all base pairs of a genome. another example of a track of this kind is the representation of a randomization of a genome, with each edge representing the positional relocation of a base pair. we refer to the eight linked track types as the extended track types. figure  <dig> shows an overview of the relations between the fifteen track types and the combination of core informational properties defined.

formal model of genomic tracks
formally, we base the discussion of track types on a specific mathematical model of genomic tracks. we treat the genomic coordinates as forming a discrete metric space on the natural numbers, defined by the discrete metric d:

  d=∣a-b∣+ <dig> a, b∈ℕ 

the genomic coordinates in the model are thus isolated points. a segment or interval starting at a position a and ending at b is defined as the subset s of natural numbers where:

  s={s∈s∣a≤s≤b∧b>a} 

the length of a segment is defined by the metric d, and is equal to the number of elements in the set. the length of the segment s = { <dig>   <dig>  3} is thus d = | <dig> - 3| +  <dig> =  <dig> = |s|. transferred to the biological domain, the length of a segment is the number of base pairs covered by the segment. the end position of a segment must be larger than the start position. we thus exclude segments of length  <dig> from the model, as such segments would be exactly equal to a point, e.g. the set of a single number:

  p={p∈p∣p=a} 

from the set notation follows that a point p can be precisely defined as falling inside a segment s if and only if p ⊂ s. two segments, on the other hand, may partially overlap. a function is precisely defined as a mathematical function from genomic coordinates to corresponding values, e.g. f = ℕ → ℝ. a step function is similarly a function from disjoint intervals covering the entire domain to corresponding values.

analysis dependency on track types
as each of the fifteen track types implies a set of core informational properties, a track type also poses a limit to which analyses are appropriate for a track. it makes sense to calculate the base pair coverage of a track of genes , but not for a track of snps , which should instead be counted. this logic also carries on to analyses applied to more than one track. consider, for the sake of simplicity, only five of the fifteen track types. if we select two tracks, each of one of these five types, we get  <dig> combinations, provided that the order of the tracks is not important. each of these combinations could then define a set of appropriate analyses. table  <dig> provides analysis examples for many of the pairwise combinations of the five track types points, segments, function, valued points, and valued segments. although assigned to a single combination of track types, an analysis may often be meaningful for a set of such combinations. for instance, asking whether the points of one track are located inside the borders of the segments of another track  will trivially also give meaning where one or both of the tracks has associated values . also, it could give meaning to ask whether small segments of one track are located inside the borders of the segments of another track . the correspondence between the track types and possible analyses are at the core of the idea of track types. although storing data sets as efficiently as possible is an important aspect, the bioinformatics field is currently lagging more in terms of general understanding and standards for analyzing data sets in meaningful ways. it is our hope that the definition of track types will help in this regard.

examples of analyses for different combinations of track types . note that many of these analyses are valid for several  combinations, and are assigned to what we consider the most typical combination for the analysis. all these analyses are carefully described significance tests  <cit> , available online at the genomic hyperbrowser  <cit> 

existing representational formats
existing formats for representing genomic tracks can broadly be divided into three groups: textual formats, binary formats, and xml formats. often textual and binary formats are closely connected, such as the sam and bam formats for read alignments  <cit> . this duality is due to the different advantages of the two forms. textual formats are often humanly readable and simpler to parse and manipulate than their binary alternatives. the binary formats, on the other hand, are more compact and more efficient to use, often incorporating indexing schemes for fast random access to data. xml formats aim to bridge this gap by defining data structures that can exist in both textual and binary forms. note that we limit the discussion to formats that aim at being general, in one form or another, thus excluding formats that are special to a particular technology or platform.

the large majority of formats for genomic data are textual, and the large majority of the textual data formats are tabular, that is, they consist of tab-separated columns. three of the most common tabular formats are generic feature format   <cit> , browser extensible data format   <cit>  and wiggle track format   <cit> . figure  <dig> shows an overview of these three tabular formats, with example files.

a main reason for the popularity of tabular formats is that they are inherently simple to create and read, both manually and by computers. this has been a major asset in the field of bioinformatics because of the widespread use of both ad hoc scripting and wysiwyg editing in spreadsheet software . still, the abundance of different formats, together with the increased complexity of particular formats, creates practical problems when e.g. creating new tools.

xml formats represent a way of letting go of the entire process of custom and explicit parsing of files. in particular when an xml format is specified by a dedicated xml schema , the data included in an xml document can be automatically transformed into convenient runtime data objects. xml formats are much used in connection with web services, xml databases, or serializations of object models, but there have so far been only a few xml formats used for exchanging sequence-feature data. the distributed annotation system  <cit>  uses the dasgff xml format, which is similar to the tabular gff. web services for feature prediction at cbs  <cit>  have been using a common xsd-based output format that has been inspired by gff. numerous web services and databases define their own xml formats for annotation data, such as the uniprot xml  <cit>  or the elmdb web service  <cit> . bioxsd version  <dig>  has defined a format for sequence features that is expressive enough to be able to substitute the majority of other feature formats  <cit> . the main disadvantages of using xml for genome-scale annotations have been the verbosity of the textual serialization of xml data and the large memory usage of most of the libraries parsing xml. the recent w3c standard for highly optimized binary representation of xml - the efficient xml interchange  format  <cit>  - promises to solve these problems.

binary formats are often used internally in software systems, and not necessarily provided as public formats. some exceptions to this are the aforementioned bam, as well as the bigbed and bigwig formats  <cit> . the last two formats are binary versions of the bed and wig format, respectively, providing efficient storage and indexing capabilities, allowing users to store large tracks on their own computers, while a server requests only the parts needed for analysis or visualization. another binary format is the useq compressed binary format  <cit>  focusing on tight compression of tabular data files of different types, while keeping them in an indexed structure.

as figure  <dig> illustrates, different formats support different combinations of the core informational properties, and hence, different track types. table  <dig> provides an overview of which of the basic track types are covered by some common formats. as each of the different groups of formats  has advantages in distinct scenarios and communities, one would ideally like to select three formats that cover all track types, one from each group. unfortunately, no common formats do. one option would be to extend an existing format to support all track types. a main reason for such an extension would be to be able to make use of the plethora of tools and parsers already available. in the case of xml formats, the existing bioxsd  <dig>  format was found to be easily extensible to support all track types. in the case of tabular formats, however, the only major format to support extensions is gff, through the attribute column. however, using gff to represent e.g. tracks of type function would be highly impractical. each base pair would then be represented by a data line of nine columns, wasting considerable amounts of space. the remaining option is then to create a new tabular format. in order for the introduction of a new format to be justified, such a format should have the potential to replace at least some of the existing formats, in addition to having the extensibility required to meet future needs when new types of data appear. as binary formats are often not independent formats, but typically linked to tabular ones, we will not focus on such formats here. we thus present a pair of general formats aware of all track types, one of which is tabular and the other based on xml. the tabular format, gtrack  <dig> , is a new format that builds closely on the bed and wig formats, while adding support for extensions in a similar fashion as in gff. the xml format is a successor of the existing bioxsd  <dig>  format. besides catering to a broader user base, presenting "track type"-compliant formats of both kinds illustrates that the fundamental concepts of track type are independent of implementation. the primary goals for the formats are to support all track types systematically, to allow custom extensions, and to provide efficient storage, while at the same time focusing on simple parsing and manipulation of files.

the track type abbreviations are as follows: points , segments , valued points , valued segments , genome partition , step function , and function . l refers to any of the linked track types. the table also denotes whether the format supports specification of strand, the number of columns of the tabular formats, and the type of the dominant value, if any.

 <dig> points are specified using both start and end values. there is no way of specifying that a file contains only points.

 <dig> only a special case of linked segments is supported, namely part-of relationships, such as en exon being a part of a gene.

 <dig> the chosen value type refers to what may be considered the main score column of the format. the format also includes a configurable column containing values that may be extracted by specialized parsers.

 <dig> we limit the bigbed format to the standard bed columns for simplicity, as the bigbed format is highly customizable through the use of autosql configurations.

 <dig> the float values represent a set of gene expression values from microarray experiments.

 <dig> the values represent the possible alleles at a snp position. also, the allele frequencies and quality scores are reported and could be used as values.

 <dig> e.g. the number of bases that match/do not match.

 <dig> e.g. the mapping quality or the aligned sequence itself.

 <dig> links to alignments in other genomes.

 <dig> there is no way of specifying that a record contains only points or only segments.

 <dig> no weights are supported in bioxsd  <dig> .

 <dig> numerical values are always signed double precision floats . a limited set of other value types is also allowed .

gtrack: type-aware tabular format
we here introduce a new tabular track format: the gtrack format, short for both "genomic track" and "generic track". the gtrack format supports all fifteen previously defined track types, illustrated in figures  <dig> and  <dig>  a gtrack file includes a column specification line, specifying the names of all the columns in the file. each track type has a one-to-one correspondence to a combination of core columns being present in the column specification line, as detailed in table  <dig>  the four core informational properties are represented by the four core reserved columns in such a way that the existence of each core column  corresponds to a core property being defined :

c core reserved column 

n non-core reserved column 

✓ column is mandatory

? column is optional

. column is not allowed

! property must be present, either as a column or in a bounding region specification

 <dig> the length is the difference between the end and the start position, or, if the start column is not present, the difference between the current end position and the previous.

 <dig> the non-core reserved column id is required when the edges column is present.

• gaps are implicitly represented by the start column, i.e. it holds the start coordinate of a track element and thus marks the end of any preceding gap.

• for sparse track types, i.e. track types with gaps, length is implicitly represented by the difference between start and end columns. for dense track types , there is no start column. the length is then the difference between the previous end position and the current. deriving length from the end position, rather than the start position, is preferable, as a parser in the opposite case would have to read the subsequent line before concluding on the length of the current track element. the existence of the end column thus corresponds directly to the track elements having the length property.

• although several columns in a data set may contain values of potential interest, one of these columns will typically provide a main value used in processing or analysis according to a given purpose. this focus is specified by the value column.

• the edges column contains, for each track element, a comma-separated list of id's of other track elements which are interconnected with the element in question, in addition to values associated to the edges, e.g. weights or edge types

• a gtrack file may contain several columns containing values or edges. users may then switch between them by simply editing the column specification line.

the edges column requires that the non-core reserved column id is present, containing a unique identifier for each track element. three other non-core columns are specified in the gtrack format: genome, seqid and strand . the titles of the eight reserved columns are reserved words in the column specification line. they may appear in any order, and any number of additional columns may be specified. figure  <dig> shows six example gtrack files, five of which are conversions of the example files in figure  <dig>  the example files illustrate the variation stemming from the different column specification lines .

when creating the gtrack format, we have emphasized simplicity, both for creation, manual reading and automated parsing of the format. we have identified three principles towards simplicity: independence of data lines, overview of structural characteristics and equally sized lines.

the principle of independent data lines states that it should be possible to interpret each data line in a tabular format independently of its location in the file. this is a principle followed in many common formats, e.g. gff  <cit>  or bed  <cit> . following this principle gives several advantages. first, when creating or manipulating a file, keeping data lines independent allows the filtering and sorting of data lines while still keeping all the relevant information. second, keeping a track element on a single line makes it easier to read for the human eye. third, independent data lines reduce the need of automatic parsers to hold state information. the gtrack format follows the principle of independent data lines with two exceptions. first, data lines of dense track types are dependent on their positions in the file. second, the gtrack format allows  the specification of bounding regions around each block of values. a bounding region specification line defines the domain of the following track elements, i.e. the region where we have information about the features modeled by the track elements. it is recommended that tracks mask out regions of a genome where nothing is known  using bounding regions, rather than just omitting track elements or specifying 0-values, as the difference is important for many analyses. bounding regions unfortunately require parsers to store state information. see figure 4a, 4c <dig>  4c <dig> and 4d for examples of bounding region specification lines .

the principle of including an overview of structural characteristics means that a track file should start with a set of configurable options that describe the structure of the data lines, in an easily readable manner. note that many of these characteristics will, by nature, include redundant information, i.e. that could have been collected from the data lines themselves. there are several reasons for explicitly stating such characteristics. first, it gives the human reader a simple overview of the type of data stored in the file, without having to scrutinize the actual data. second, it allows the creator of a track to validate that the file is structured in the way intended . third, inclusion of structural characteristics allows parsers to be restrictive on which kind of structures to support. a quick script can then, for instance, read the header and check whether the track type is segments with no overlapping elements, failing explicitly if the header does not match this requirement. the script can then assume that the remaining file follows the asserted structure, safely ignoring the non-relevant generality of the gtrack specification. in the gtrack format, the structural characteristics are specified in header lines, starting with the characters '##'. table  <dig> contains an overview of all gtrack header variables. note that header lines are optional when their values are equal to the default values. we also provide the "expand gtrack headers" tool, which generates a gtrack file with full headers based on a supplied, incomplete gtrack file, further simplifying the process of generating header lines.

all header variables not specified in a gtrack file retains their default values.

* defined in the extended part of the gtrack specification. see the gtrack specification  for more details.

the principle of equally sized lines states that all data lines contain the same number of columns, i.e. that all attributes have a value. columns that do not contain information are marked with a period character. there are several advantages for this solution compared to the solution used in the gff format, where the last column may contain a list of attributes in the format tag = value, allowing the attribute list to differ for each line. first, having equal size columns allows validation that all data lines are complete, or at least that the creator of the track has considered all attributes for all track elements. with a variable size attribute column, there is no way to check that all attributes have been considered. second, parsing attribute lists as in the gff format is more cumbersome, as the parser will not in advance know which attributes may appear in the file. third, not having to repeat attribute names for all lines saves some space. fourth, and most importantly, having the same number of columns in each data line keeps the interface of the format coherently organized, with attributes as columns and track elements as rows. as the gtrack format supports custom columns, it can completely replace the attribute solution of the gff format.

in addition to simplicity, the gtrack format aims at being highly extensible and inter-operable. first, the ability to define columns in any order and number, provides ample options for extensibility, in addition to simplifying conversion. in many cases, converting another tabular format to gtrack is as simple as adding a column specification line. note that basic, three-column bed files are directly compatible with the gtrack format, without the need for any modifications. also, both 0- and 1-based indexing, in addition to the end position being inclusive or exclusive, are included in the gtrack specification, further simplifying conversion. second, gtrack includes a strategy for making structured extensions of the format, namely the specification of subtypes. four subtype header lines are available , specifying the name and version of a subtype, the url of the subtype specification, and the strictness of adherence required by the subtype. the idea is that research communities can define their own tabular formats, making use of a subset of the gtrack specification. such formats could for instance be replacements of existing formats, or formats that are honed to specific technologies or tools. the header variable "subtype url" points to a gtrack file that can be used as model for the subtype, and is intended to be read by automatic parsers. figure 5a shows an example of such a subtype specification file, based on the example gtrack file in figure 4a. specifying subtype models allows the reduction of a complete gtrack header down to a minimum of one line, as shown in figure 5b. it is our belief that allowing extensions of the gtrack format via subtypes caters for a range of future extensions, while ensuring backward compatibility. subtypes can be defined in a range of settings, from project specific, ad hoc solutions, to the specification of generic formats. further examples of gtrack subtypes are described in the gtrack specification . a set of standard gtrack subtypes are available online  <cit>  .

bioxsd  <dig> : enhanced and optimized xml format
bioxsd has been developed as a universal xml format for the basic types of bioinformatics data that is in particular suitable to be used with web services  <cit> . it models common types of data for which a specialized xml schema  has not been widely adopted: biomolecular sequences, alignments, sequence feature records, and references to ontologies and data resources. the bioxsd schema defines formats of data but not formats of particular xml documents, by defining xsd types but no global xml elements. bioxsd types can thus be used according to applications' needs in applications' own xsds such as those in wsdl files of web services.

bioxsd  <dig>  type annotatedsequence can represent annotations of a biomolecular sequence or genome with any types of positioned or non-positioned features, which can be combined in one record. although the textual serialization of xml is in general more verbose than a tabular format, already the bioxsd  <dig>  has included a number of optimizations compared to traditional feature formats like gff or bed, thanks to the tree-like structure of xml. these have been mainly:

• not repeating the reference to a sequence in every feature occurrence

• not repeating the type of feature in every feature occurrence

• representing multi-segment and multi-point feature occurrences in one feature-occurrence element

the goal of bioxsd version  <dig>  has been to further improve the expressiveness of the bioxsd formats and at the same time focus on optimizations of the data size. the successor of bioxsd  <dig>  annotatedsequence is bioxsd  <dig>  type featurerecord. bioxsd  <dig>  in general allows more types of sequence positions, distinguishing them in the same way as the tabular gtrack format. sparse positions are segments, points , and outer positions. dense positions have been added: dense points  marked-up by < nextpoint/> empty elements; and dense partition or step function marked by < nextpartition max="..."/> elements including the border position where each interval ends. however in contrast to gtrack, the different types of positions can still be freely combined within a featurerecord. the representation of all types of sequence positions have been refactored, simplified, and optimized. another crucial set of optimizations allows specification of the ontologies, databases, and computational tools of interest in a condensed way for a list of feature annotations, so that they do not have to be repeated. detailed contents of the bioxsd feature record are listed in table  <dig>  examples of data represented in bioxsd  <dig>  format are available at  <cit> .

 <dig> at least one of these two is mandatory.

 <dig> by any ontology concept, referred to by a concept uri, identifier, or term; or by a custom term if no ontology concept is available.

 <dig> points are bases/residues or insertions between them.

 <dig> for example if annotating the position of a regulatory element of a coding sequence, or relations between genes or protein domains.

 <dig> positions can form multi-segment subsequences, multi-point tuples, and can be combined within feature occurrences according to users' needs. the positions are always 1-based. the feature occurence may apply to the whole sequence .

* added in bioxsd version  <dig> .

there is one slight difference in how the gtrack and bioxsd deal with focus of feature records. gtrack defines one operational focus of a concrete dataset. that is the reason why it allows to specify only one type of track locations and only one value column and one edges column at a time, although other values and edges may still be "hidden" in out-of-focus columns. bioxsd on the other hand allows combining features, types of track positions, values, and interconnections freely without any operational focus. thus, if a tool consuming bioxsd feature data demands it, a particular operational focus of the data must be supplied by the user.

compared to other generic sequence-feature formats, bioxsd allows defining complex, structured meanings of annotations, as well as complex feature data and metadata, or relations. this would not be conveniently possible in a tabular format and takes advantage of the xml. bioxsd types can freely be combined and included within documents, files, or applications' inputs and outputs. they can easily be combined with other xml formats defined in other xsds, can be extended just like classes in an object-oriented programming language, or further restricted using built-in xsd mechanisms. bioxsd can be validated and parsed by ordinary xml/xsd-handling frameworks.

it has, however, been problematic to use xml formats for highly voluminous data such as whole-genome annotations. the textual serialization of xml is more verbose compared to a textual tabular format, and even more compared to a bespoke binary format. many basic xml-handling tools have high runtime demands for computer memory, making parsing of huge xml documents impossible. all these problems are hopefully going to be solved thanks to the recent and long-expected efficient xml interchange  standard by the world wide web consortium  <cit> , together with its growing family of supporting libraries, and tools for streamed xslt transformations and random-access xpath and xquery queries. exi defines the way any xml data or document should be serialized in a standard binary format that will be many times smaller and at the same time faster to access than the textual xml. there is no need to develop one's own bespoke binary encodings and parsers when using exi, and the data can be programmatically handled transparently, with the same look and feel as the ordinary xml.

availability of specifications and supporting tools
the bioxsd  <dig>  xml schema is available at  <cit> . bioxsd data can be validated by all the main xml validation tools, and consumed and produced programmatically by the bulk of the common xml/xsd-handling libraries. further information and documentation are available at  <cit> .

a complete specification of the gtrack format version  <dig>  is attached as additional file  <dig> and is also available from the gtrack website  <cit> . the website also contains supporting tools for the gtrack format, connected to the genomic hyperbrowser  <cit> . table  <dig> contains an overview of all gtrack-related tools available as webtools.

all tools are implemented as part of the genomic hyperbrowser  <cit>  and available under the gpl license, version  <dig>  <cit> .

the gtrack format is maintained by sveinung gundersen and the bioxsd format is maintained by matúš kalaš. both formats are licensed under the creative commons attribution-noderivs  <dig>  unported license  <cit> .

the genomic hyperbrowser  <cit>  is built on top of the galaxy framework  <cit>  and provides a large set of statistical investigations tailored for the specific track types of supplied tracks. in order for such analyses to be efficient, the system uses a binary storage scheme internally. in this scheme, the core informational columns are stored as c vectors directly written to disk. the vector files are then accessed using the numpy package  <cit>  for python  <cit> , allowing very efficient vector computations. a linear index of the files is built in order to allow random access to the data. this binary representation is stored in parallel to the files in their original format, and updated automatically as the original files are updated. the implementation is open source and available as part of the hyperbrowser code base under the gpl license, version  <dig>  <cit> . as an alternative, the recently published tabix tool  <cit>  provides fast access to tabular data in compressed form, and works with gtrack files of types points and segments, and their derivatives.

CONCLUSIONS
by systematic analysis of informational properties of genomic tracks, we delineated fifteen distinct types of tracks. these track types shed light on the variability of track representations, suggesting that the differences between formats is not only due to preferences and conventions, but also to fundamental differences in the information inherent in different tracks. furthermore, discerning the informational properties of a track allows the nature of the track to be precisely conveyed, as well as clarifying what represents meaningful analyses on a given track.

the identification of core informational properties of tracks, as well as a broad survey of various practicalities concerning existing formats, created a basis for the specification of a new format for genomic data: the gtrack format. by allowing precise interpretation, simple parsing, as well as relatively straightforward conversion to several existing formats, we believe that the introduction of this "yet another format" will actually help streamline data representation in the field. finally, by coordinating the gtrack format with an enhanced and optimized version  <dig>  of the bioxsd format, this also aids in unifying tabular and xml-based track representation, while keeping the specific advantages of the two.

abbreviations
bam: binary alignment/map format; bed: browser extensible data format; chip-seq: chromatin immunoprecipitation sequencing; exi: efficient xml interchange; f: function; gff: general feature format; gtf: gene transfer format; gvf: genome variation format; gp: genome partition; p: points; lbp: linked base pairs; lf: linked function; lgp: linked genome partition; lp: linked points; ls: linked segments; lsf: linked step function; lvp: linked valued points; lvs: linked valued segments; s: segments; sam, sequence alignment/map format; sf: step function; snp: single nucleotide polymorphisms; uri: uniform resource identifier; url: uniform resource locator; vp: valued points; vs: valued segments; wig: wiggle format; wsdl: web service definition language; wysiwyg: what you see is what you get; xml: extensible markup language; xsd: xml schema definition.

authors' contributions
sg, af, eh and gks conceived and developed the ideas on track type distinctions. sg, mk, oa and gks developed the gtrack specification. sg and gks wrote the main parts of the paper. mk wrote the parts on xml-based track representation and developed bioxsd  <dig> . sg and gks were involved with the development of gtrack-related tools. all authors read and approved the final manuscript.

supplementary material
additional file 1
gtrack specification. specification document of gtrack  <dig> .

click here for file

 acknowledgements and funding
funding was kindly provided by embio, fuge, uio, helse sør-Øst, and esysbio . this work was performed in association with 'statistics for innovation', a centre for research-based innovation funded by the research council of norway. we thank kai trengereid for crucial work in developing the gtrack-related tools, and inge jonassen for valuable input on the bioxsd format. we would also like to acknowledge the excellent review work provided by the peer reviewers. these reviews have contributed significantly to the content of this paper.
