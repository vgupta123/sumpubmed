BACKGROUND
epidemiological models traditionally assume mass-action dynamics: individual hosts in a population have identical contact rates and are well-mixed, such that any given pair may interact and transmit disease with equal probability  <cit> . compartmental susceptible-infected-recovered  models implicitly assume mass-action interactions for infinite populations. however, the mass-action assumption is unlikely to be strictly valid in most instances. although there are some settings in which mass-action models provide reasonable approximations, there are others in which it is essential to consider the heterogeneous contact patterns that underlie disease transmission  <cit> .

contact network epidemiology  <cit>  explicitly models disease transmission through populations with heterogeneous contact patterns. host populations are represented as networks of individuals  and the contacts through which disease can spread . the definition of a disease-causing contact depends on the disease. for influenza, edges represent the potential for droplet or contact transmission, e.g., direct interactions such as prolonged proximity or food sharing  <cit> , or indirect transmission of fomites persisting in the environment  <cit> . a node's degree is the number of contacts an individual has, and is one indication of an individual’s epidemiological importance, relative to other individuals in the population. the degree distribution of a network can play a critical role in shaping epidemic dynamics  <cit> . by modeling disease transmission probabilistically, contact network models can predict the expected epidemic size, the likelihood that an epidemic will occur given an introduction, and with some methods, the dynamics of an outbreak and likely chains of transmission through the population  <cit> .

the  <dig> sars outbreak in china illustrates one limitation of mass-action models. early estimates of the basic reproduction number  for sars predicted that 120 days after the disease was introduced in china, between  <dig>  and  <dig> million individuals would have been infected in china  <cit> . in fact, only  <dig> sars cases were reported  <cit> . this discrepancy stems, at least in part, from the assumption that disease transmission patterns for the entire chinese population would be similar to the transmission patterns in the apartment building in hong kong and hospital in singapore from which the early estimates were made. such heterogeneity in contact patterns lends itself to a network approach, in which nodes can be connected to explicitly represent the diverse patterns of interactions that occur within human populations.

the spread of sexually transmitted infections is also often modeled more effectively with contact networks than mass-action models, because of non-randomness and heterogeneity in sexual contact patterns. an infected individual with many contacts may be more likely to spark a significant outbreak than an infected individual with fewer contacts. a study of  <dig>  randomly sampled swedes aged 18-74 years found that the number of sexual interactions per person approximately followed a power-law distribution, indicating significant heterogeneity in sexual activity  <cit> . a smaller study of sexual interactions among adolescents in a midwest us town revealed long chains of contacts and fewer cycles  than would be expected by chance, patterns that can be readily captured by network models  <cit> .

contact network models also allow straightforward analyses of epidemiological dynamics and intervention events occurring at particular nodes. for example, the approach has been used to optimize the distribution of limited resources such as vaccines and antiviral drugs within a population  <cit> , and to identify critical bridge groups connecting relatively disjoint parts of a high-risk population  <cit> .

although there are powerful mathematical methods for analytically estimating the dynamics of epidemics in complex contact networks  <cit> , simulations of disease transmission through networks are also critical to the field. they allow us to test the validity of mathematical approximations and serve as the primary modeling approach when mathematical approximations cannot adequately describe the complexity of a population. there are two widely-used approaches to simulating disease transmission through networks: the reed-frost chain-binomial model  <cit>  and the percolation model  <cit> . although they can be made arbitrarily complex, these models typically represent individual hosts as nodes with discrete disease states, and propagate infection along edges from infected to susceptible nodes according to the probability of disease transmission, called transmissibility, which may either be fixed or determined by a function.

in the chain-binomial model, time is measured in arbitrary, discrete units. simulations are parameterized with the number of time steps individuals remain infected, and the per-time-step transmissibility. the chain-binomial model may be used to generate epidemic curves , identify chains of transmission, estimate the probability of an epidemic, and assess the distribution of epidemic sizes.

percolation simulations give each infected individual one opportunity to spread disease to each of their susceptible contacts, but do so in an arbitrary, non-chronological order. one approach is to use a probabilistic breadth-first traversal of the network. in the simplest case, transmissibility is the same for all edges. one approach is to maintain four dynamic lists of nodes:  susceptible,  newly-infected,  currently-infected, and  recovered. at the beginning of a typical simulation, one or more nodes will be placed on the currently-infected list, and the remaining nodes will be on the susceptible list. then the following two-step procedure is repeated until the currently-infected list is empty.

 for each currently-infected node, a uniform random number between zero and one is generated for each edge that connects the node to a susceptible neighbor. if and only if the random number for a given edge is less than the transmissibility, then the susceptible neighbor moves from the susceptible list to the newly-infected list.

 after all currently-infected nodes have been tested in this way for transmission, the nodes in the currently-infected list are moved to the recovered list and the nodes in the newly-infected list are moved to the currently-infected list.

a breadth-first approach like this will result in a coarse approximation of the epidemic curve, similar to a chain-binomial simulation with an infectious period of one unit. percolation simulations tend not to predict realistic chains of transmission, since new infections occur in cohorts, and the order of transmission events is based on arbitrary orderings of each cohort. the percolation algorithm above can be modified slightly to simulate a chain-binomial model: rather than testing each edge from an infected to a susceptible node once, we test each edge n times, where n is the length of the infectious period or the number of time steps until transmission occurs, whichever occurs first. if parameterized appropriately, the two models will yield the same epidemic probability and final size distribution. the chain binomial model yields smoother, more realistic epidemic curves, while the percolation model is more computationally efficient.

while the field of contact network epidemiology is growing rapidly, it still lacks a flexible, user-friendly programming toolkit for generating contact networks, analyzing their structure and simulating the spread of disease through them. there are a few freely-available libraries for simulating and analyzing networks, but they are suboptimal for epidemiological research, particularly for novice programmers. specifically, networkx  <cit> , implemented in python, is straightforward but slow, whereas igraph  <cit> , implemented in c, is faster but less user-friendly. the r package statnet  <cit>  is more specialized, focusing on statistical analysis of exponential-family random graphs. none of these packages provides epidemiological simulations or functions for calculating important epidemiological values. other software packages provide valuable disease- or population-specific simulators , but lack a flexible framework for users to define alternative disease models and population structures.

here, we introduce epifire, an applications programming interface  implemented in c++. epifire includes a fast and efficient library for generating networks with a specified degree distribution, measuring fundamental network characteristics, and performing percolation and chain-binomial simulations of sir  disease transmission on generated networks. we have also developed a user-friendly interface that allows the user to perform these functions in a point-and-click environment and provides intuitive graphical results of epidemic simulations.

although network models can be made to approximate mass-action models by assuming a completely connected network  <cit> , it typically does not make sense to do so. mass-action models are computationally very efficient and network models become computationally more demanding as the number of nodes and edges increases. thus, epifire also includes a continuous time, stochastic mass-action simulation class to allow users to create hybrid models or to compare the results of mass-action and network-based models.

implementation
epifire comprises two bodies of code that are written in object-oriented c++: the applications programming interface  and the graphical user interface . the epifire gui was developed using the api and qt  <cit> , and allows non-programmers to generate networks, perform epidemic simulations, and export figures and data. we describe the epifire gui in more detail in the results section below. the entire epifire code base is open source, licensed under gnu gplv <dig> 

the epifire api consists of  <dig> classes and  <dig>  lines of non-whitespace code. the epifire gui consists of  <dig> classes and  <dig>  lines of non-whitespace code.

installation
epifire source code is available from github at http://github.com/tjhladish/epifire/ or http://epifire.com. users who have installed git version control software  may create a local copy of the epifire repository by executing, without quotes, "git clone git://github.com/tjhladish/epifire.git" on the command line. microsoft windows and mac os x users can download precompiled binaries from http://sourceforge.net/projects/epifire/.

epifire api
functionally, the epifire api consists of tools for network generation, network manipulation, network characterization, and epidemic simulation. programmatically, the api is divided into network, node, edge, and simulation classes. each class defines a type of variable and its associated attributes and functions. for example, the network class allows users to define a network variable, which can contain one or more node variables that can be connected by one or more edge variables. in the small program below, an undirected network called my_network is created, and then populated with  <dig> nodes. the nodes are randomly connected with edges such that on average, each node will be connected to five others. finally, the structure of the network is written out as an edgelist in the comma-separated-value format.

#include < network.h>

int main() {

network my_network;

my_network.populate;

my_network.rand_connect_poisson;

my_network.write_edgelist;

return 0;

}

the network constructor takes two arguments: an arbitrary text string naming the network, and either network::undirected or network::directed, which specifies whether all edges are undirected, or some or all may be directional.

each time the program is run, a different randomly connected graph will be produced. the following is an example of the beginning of the output file:

 <dig> 

 <dig> 

 <dig> 

1

 <dig> 

 <dig> 

 <dig> 

 <dig> 

 <dig> 

 <dig> 

in this case, node  <dig> was connected to nodes  <dig>   <dig>  and  <dig>  node  <dig> was not connected to any others.

more sophisticated examples, including networks being used in epidemic simulations, can be found in additional file  <dig> in the examples directory provided with the source code.

the network modeling portions of the code  can be used with or without the epidemiological code, and may therefore be useful for non-epidemiology applications. the simulation classes provided include three types of finite, stochastic epidemic simulations: percolation and chain-binomial , and mass-action. users may use the provided simulation classes or may create derived classes based on them. for example, the base class for percolation simulations, called percolation_sim assumes a disease with susceptible-infectious-recovered states. a simple derived simulation class can be created that inherits almost all the functionality of percolation_sim, but that uses an alternate progression of states. an example of a derived simulation using the susceptible-exposed-infectious-recovered state progression  can be found in the research directory provided with the source code.

networks may be constructed explicitly by reading in an edgelist file, or adding individual nodes and specifying their connections. networks can also be constructed implicitly by using one of the network generators provided. generators for ring and square lattice networks are provided, as well as three random network generators: the erdős-rényi model  <cit> , resulting in approximately poisson degree distributions, the configuration model  <cit>  that generates random networks with a user-specified degree distribution, 'and the watts-strogatz “small-world” network generation model  <cit> .

networks that are generated via the configuration model can contain edges that are usually undesirable in epidemiological models. pairs of nodes may be randomly connected by two or more edges, and nodes may be “connected” to themselves by edges going to and from the same node. these edges, called parallel edges and self-loops respectively, may be removed using the provided “lose-loops” function . this function uses a novel algorithm to reconnect the affected edges in a randomized way that preserves the degree sequence of the network. this approach may introduce some non-randomness to the network structure, but the improvement in algorithmic complexity over competing methods is significant  <cit> .

random numbers are generated using the mersenne twister algorithm  <cit>  as implemented by wagner, available at http://www-personal.umich.edu/~wagnerr/mersennetwister.html.

percolation and chain-binomial pseudocode
epifire provides epidemic simulators using the percolation and chain-binomial models, represented as pseudocode below. both pseudocode functions take a network as an argument and return final epidemic size. the most recent implementations, including additional functions for the simulators, can be found online  <cit> . in the percolation pseudocode below, t denotes the transmissibility of the pathogen, that is, the probability that transmission will occur between an infectious node and a susceptible neighbor.

percolation:

infected_queue ← empty list

foreachnodeinnetwork:

set state ofnodeto "susceptible"

first_infected ← random node fromnetwork

set state offirst_infectedto "infectious"

appendfirst_infectedtoinfected_queue

whileinfected_queueis not empty:

node ← remove first element frominfected_queue

foreachneighborofnode:

rand ← uniform random number between  <dig> and 1

ifneighboris "susceptible"andrand < t:

set state ofneighborto "infectious"

appendneighbortoinfected_queue

set state ofnodeto "recovered"

epidemic_size ← count of nodes in "recovered" state

returnepidemic_size

appendix b <dig> of additional file  <dig> provides a version of the percolation algorithm that produces an epidemic curve. in practice, it may be convenient to use integers as node states rather than text strings. in the chain binomial algorithm below, susceptible nodes have a value of  <dig>  recovered nodes have a value of - <dig>  and infectious nodes have a value equal to the number of days they have been infectious.

appendix b <dig> of additional file  <dig> provides a simple chain binomial function that performs one comparison per time unit per infectious node. here, we describe a more efficient implementation. instead of checking whether transmission occurs to each neighbor at each time step, we can determine the time until transmission along each edge. because each transmission attempt can be considered a bernoulli trial, we can determine when transmission will occur by sampling from a truncated geometric distribution with probability of "success" t_cb  and support on { <dig>   <dig>  . . . , gamma + 1}, where gamma is the infectious period. if the deviate happens to be gamma +  <dig>  then transmission never occurs. in the pseudocode below, transq is a priority queue of transmission events, sorted by time, least to greatest.

chain_binomial:

transq ← empty priority queue of  pairs

infected_list ← empty list

foreachnodeinnetwork:

set state ofnodeto 0

current_time ← 0

first_infected ← random node fromnetwork

infect_node

whileinfected_listis not empty:

foreachnodeininfected_list:

increment state ofnode

whileinfected_listis not empty:

ifstate ofinfected_list <cit>  ≤ gamma:

break

else:

set state ofinfected_list <cit>  to -1

remove first element frominfected_list

whiletransqis not empty and time oftransq <cit>  ≤ time:

event ← transq <cit> 

infect_node

epidemic_size ← count of nodes in - <dig> state

returnepidemic_size

infect_node:

set state ofnodeto 1

appendnodetoinfected_list

foreachneighborofnode:

ifstate ofneighboris 0:

rand ← geometric_random_number, see main text

ifrand ≤ gamma:

append  totransq

analytic calculations of epidemic and network quantities
given a degree distribution for a network and a transmissibility for a pathogen, the epifire api includes functions that calculate the expected epidemic threshold for the network , the basic reproductive rate of the pathogen in that network . epifire gui further calculates expected epidemic size under network and mass-action assumptions. all of the network calculations assume the configuration network model, such that the network is a random draw from all randomly connected networks with the specified degree distribution. calculations, unless otherwise noted, are adapted from meyers   <cit> , which provides additional mathematical details.

the epidemic threshold for a network is a critical transmission probability  below which outbreaks are expected to fizzle out and above which large epidemics are possible, but not guaranteed. technically, in an infinite network, outbreaks below the epidemic threshold will reach only a finite number of nodes, while outbreaks above the threshold can either be finite or infect a fraction of the network including an infinite number of nodes. this value is a function of the network structure and corresponds exactly to an r <dig> value of 1; given by

  tc=ΣkkpkΣkkpk, 

where k is the degree of a node, and pk is the fraction of nodes having degree k.

the expected basic reproductive rate is the expected number of neighbors that will be infected by each infectious node early in an epidemic, and is equal to the ratio of the actual transmissibility to the critical transmissibility, given by

  r0=ttc. 

the expected epidemic size is then given by

  enet=1−Σkpkt)k, 

where u is the solution to the self-consistency equation

  u=Σkkpkt)k−1Σkkpk. 

we also provide a function that calculates the expected final epidemic size in a mass-action model, given a value of r <dig> <cit> :

  ema=s <dig>  

where s <dig> is the fraction of individuals who are susceptible at the start of the epidemic. the expected epidemic sizes under both the mass action and network models are solved numerically using the bisection method  <cit> .

by calculating and comparing the network and mass-action expectations for an epidemic size of a specific network-pathogen combination , one can assess the epidemiological impact of the network structure. large differences in the values of network and mass-action expectations suggest that network structure plays an important role in disease transmission, and that traditional compartmental models may not be adequate.

since percolation and chain binomial transmissibilities are per-time-unit and per-infectious-period probabilities, respectively, when users switch between simulation types the transmissibility parameter is recalculated accordingly.

one important property of networks is clustering, a measure of whether nodes exist in well-interconnected groups. epifire implements the transitivity clustering coefficient  <cit> , calculated as

  transitivity=3*trianglestriples, 

where triangles is the number of sets of nodes a, b, and c such that all three are interconnected, and triples is the number of sets of nodes a’, b’, and c’ such that b’ is connected to a’ and c’.

RESULTS
epifire is an applications programming interface  implemented in c++, designed to efficiently generate networks with a specified degree distribution, measure fundamental network characteristics, and perform percolation and chain-binomial simulations of sir disease transmission for generated networks. epifire also includes a continuous time, stochastic mass-action simulation class for creating hybrid models and/or comparing the results of mass-action and network-based simulations.

epifire allows users to develop efficient epidemic simulations in c++ by providing a high-level api for running simulations and manipulating the underlying contact networks in network-based models. the following examples demonstrate simple use-cases.

example 1: percolation simulation 
this percolation simulation is performed using a random network constructed using the erdős-rényi algorithm with  <dig>  nodes and mean degree  <dig>  the probability of transmission between an infected node and a susceptible neighbor is  <dig> , and the epidemic begins with  <dig> infected nodes .

#include < percolation_sim.h>

int main() {

// construct network

network net;

net.populate;

net.fast_random_graph;

// parameterize and run simulation

percolation_sim sim;

sim.set_transmissibility;

sim.rand_infect;

cout < < "expected r0: " < < sim.expected_r0() < < endl;

sim.run_simulation();

cout < < "epidemic size: " < < sim.epidemic_size() < < endl;

}

sample output:

expected r0:  <dig> 

epidemic size: 3423

the output from this example is the expected value of r <dig> if an epidemic occurs  and the total number of individuals infected during the epidemic. by running the simulation many times, we can generate a distribution of epidemic sizes. alternatively, to generate an epidemic curve, we can report the size of the infected cohort after each round of transmission .

example  <dig> required  <dig>  sec  and  <dig>  mb  of system memory. the test system was a dell precision workstation  <dig> with two intel xeon  <dig> processors and 4 gb of ram running 32-bit ubuntu  <dig>  lts. epifire was compiled using gcc version  <dig> . <dig> with o <dig> optimization. most of the time is spent constructing the random network; the simulation itself only requires  <dig>  ms . depending on the intended application, it may be acceptable to generate and reuse a single network for many simulations, greatly reducing the time required. users should note that when reusing a network, sim.reset() should be called in between simulations to reset the state of all nodes to the default susceptible state, as in appendix a <dig> of additional file  <dig>  the running time required for example  <dig> scales linearly with the expected epidemic size, whereas the memory required is linear with n *  where n is the network size and k is the mean degree.

additional api examples
appendix a <dig> of additional file  <dig> includes a more complicated simulation of an epidemic on a dynamic network. further examples included with the source code are a chain-binomial simulation of a network with an arbitrary degree distribution; a derived percolation class that uses a susceptible-exposed-infectious-recovered progression of states; and a stochastic, continuous time, mass-action simulation using a gillespie algorithm  <cit> .

comparison with networkx and igraph
epifire is not intended to replace other network apis, which were developed to solve different problems. to compare these diverse apis, we consider one of their common functions: generation of an erdős-rényi random network. there are several algorithms that will generate random networks; we chose the most efficient algorithm available in each api when generating a  <dig>  node network with a poisson degree distribution with poisson parameter  equal to ten. epifire requires much less memory and running time than the user-friendly networkx, and somewhat less memory and time than igraph . the comparatively poor performance of networkx is likely due primarily to differences in efficiency between c++ and python.

performance comparison with networkx and igraph, generating random networks with  <dig>  nodes, poisson degree distribution. network generation in networkx was performed using the fast_gnp_random_graph() function.

overview of epifire gui
although the epifire api provides great flexibility for creating custom simulations, it requires some background in programming. as a demonstration of some of the capabilities of the epifire api, we present the epifire graphical user interface , which allows users to generate and analyze several common classes of random networks and conduct chain-binomial and percolation sir simulations on contact networks in a point-and-click environment with intuitive, automatically generated figures. the epifire gui requires no programming to create and analyze networks and run stochastic simulations on those networks.

main window
the application's main window  is organized in two panes, with model parameters and application status on the left, and automatically generated plots of simulation data on the right. the left-hand pane is divided from top to bottom, as follows:

network parameterization
by default, the tab labeled “step 1: choose a network” is active. users choose whether to import a network from a file or to randomly generate a network. the import format is an edge-list file, with each edge represented as a single line containing the names of the connected nodes, separated by a comma. currently only undirected networks are supported by the epifire gui. if users choose to generate a network, they may specify the desired number of nodes, the degree distribution type, and relevant parameters for the degree distribution. generated networks are connected randomly using the configuration model with the constraint that no pair of nodes is connected by more than one edge, and no edges loop back to connect a node to itself. users may select poisson, exponential, power law, urban, or fixed degree distributions. degree distributions are right-truncated at n –  <dig>  where n is the size of the network. exponential and power law distributions are also left-truncated so that there are no nodes with degree zero. the urban degree distribution is a semi-empirical distribution used previously to study the spread of sars and influenza in vancouver, canada  <cit> .

simulator parameterization
by clicking the tab labeled “step 2: design a simulation,” users may specify simulation parameters. epidemics can be simulated under chain-binomial and percolation models. chain-binomial is the default because it produces epidemic curves with finer temporal resolution, although percolation simulations run faster and will produce the same distribution of final epidemic sizes. both simulators allow users to specify a transmissibility, the number of infections that should start the epidemic, and the number of simulation repetitions that should be performed. chain-binomial simulations are also parameterized with an infectious period, defined as the number of time-steps an infected individual will remain infected; when this is set to  <dig>  the chain-binomial and percolation models produce equivalent results. users may also choose whether epidemic data is retained between runs or deleted prior to each new simulation. this determines which data are included in the plots.

theoretical predictions
the epifire gui also displays the expected r <dig> for the current network and epidemic simulation parameters. epidemics will not occur when r <dig> is less than one, but may occur otherwise. given this expected r <dig>  epifire calculates expected epidemic sizes under mass-action and configuration model assumptions.

control panel
the control panel allows users to clear the current network or the current epidemic data from memory, restore the default settings, open the help dialog, generate and load networks, and run a simulation with the specified parameters. note that when “generate network” or “import edge list” is clicked, any previous network is automatically cleared, and the “run simulation” button is disabled unless a network has been created.

status log
the status log provides users with updates, including the status of network generation, warnings about incompatible parameters, current simulation number, and final epidemic size.

the right pane of the epifire gui is divided into three plots  of simulation results. these plots may be resized by resizing the main window, or by clicking and dragging the horizontal dividers between the top and middle, and the middle and bottom plots. all of the plots created by the epifire gui can be exported by double-clicking the plot, and the data used to generate the plots can be exported by right-clicking.

node state plot
the top plot shows the progression of states of the first  <dig> nodes in the network, or all nodes if the network has fewer than  <dig> nodes. the horizontal axis represents the duration of the epidemic, and each horizontal band represents the states of a particular node. blue denotes susceptible, red is infectious and yellow is recovered. the range of the horizontal axis is the total duration, in time-steps, of the most recent simulation run. these plots may provide visual insights into synchrony between node states and the relative amount of time nodes spend in each state.

epidemic curve plot
the middle plot displays the number of individuals in the infectious state at each time step. the most recent epidemic curve  is shown in red. if users choose to retain data between simulation runs, then all previous simulations are shown in semi-transparent gray. these gray data points effectively become a density plot, so that after many runs, users can see the range of possible outcomes and what a typical epidemic might look like.

histogram of epidemic sizes
the bottom plot shows how many times epidemics of a given size class have been observed, where epidemic size is defined as the total number of nodes in the recovered state at the end of the epidemic . as more simulation runs are compiled, the histogram of observed epidemic sizes more accurately estimates the distribution of possible epidemic sizes.

network visualization window
displaying large networks is difficult, especially those with random connections that are uncorrelated with any two-dimensional location. if networks are small , it may, however, be useful to display their structure. we provide a “show network plot” option within the “plot” menu, which uses a variant of the fruchterman-reingold algorithm  <cit>  to plot nodes and edges in a pop-up window. our algorithm deviates from the classical fruchterman-reingold by preferentially placing high-degree nodes near the center of the plot, rather than starting with a uniform distribution of nodes. this plot is dynamic, allowing users to explore or improve the plot by clicking-and-dragging nodes to new locations. users may zoom in and out using the +/- keys, respectively. the network plot option is disabled for networks with more than  <dig> nodes due to the complexity of the algorithm used.

network analysis window
the “network” menu includes a “network analysis” option. if there is a network in memory, a new pop-up window  appears with the node count, edge count, mean degree, and a histogram of the degree distribution. by clicking on the “calculate” buttons, the user can determine the number of nodes in the largest component, number of components, transitivity clustering coefficient, diameter of the largest component, and mean shortest path in the largest component. note that the last two calculations are computationally demanding and can take much longer to complete than the others. in some cases, calculating one statistic involves first calculating another. in this situation, all calculated statistics will be shown, even if the user did not click “calculate” for each of the statistics.

the network analysis window is particularly useful for comparing networks with different degree distributions, and for elucidating unexpected simulation results. for example, a simulation with a very high expected r <dig> may fail to create correspondingly large epidemics if the underlying network has multiple components.

simulation results analysis window
under the “results” menu is the “simulation results analysis” option. once results have been generated, users can open a new window  that automatically calculates basic statistics about the distribution of final epidemic sizes, including minimum, maximum, arithmetic mean, and standard deviation. because final size distributions are commonly bimodal with the smaller mode corresponding to failed epidemics  and the larger mode corresponding to actual epidemics, these statistics are also calculated separately for the two modes. the epifire gui attempts to heuristically distinguish outbreaks from actual epidemics by checking to see if there is a single large range separating two clusters of data. if such a range exists, the middle of the range is used as the “outbreak/epidemic threshold,” which users may always change to a different value. the epidemic size distribution plot shows values below the threshold in yellow, and those equal to or above the threshold in red. users may customize the plot by specifying the number of bins and the minimum and maximum values to use on the horizontal axis.

example 2: percolation simulation 
the simulation in example  <dig> can also be performed using the gui according to the instructions below. default settings are assumed unless indicated.

 <dig>  click “generate network” or press ctrl-g to create a  <dig>  node network with a poisson degree distribution with expected mean degree equal to  <dig> .

 <dig>  click the “design a simulation” tab or press alt-2

i. change “simulation type” to percolation

ii. change “transmissibility” to  <dig> 

iii. change “initially infected” to 10

 <dig>  click “run simulation” or press enter to run the simulation.

the epidemic size will be printed in the log window in the lower left. figures characterizing the simulation run will be automatically generated on the right, including a node-state plot, an epidemic curve plot, and an epidemic size histogram. the epidemic size histogram will better approximate the true final size distribution as additional simulations are performed.

discussion
developing epidemiological simulations that scale effectively to millions of individuals can be challenging. the open source api of epifire provides a transparent, logical framework that can be used for standard percolation, chain-binomial, or mass-action sir simulations. furthermore, it can be extended to create new, specialized types of simulations, such as networks that change in response to epidemic dynamics, or multi-pathogen simulations where co-infection changes transmission probabilities. epifire allows for hybridized models and alternative network interpretations, such as using a mass-action model for within-city dynamics and a network model for between-city dynamics  <cit> .

several other publically-available software projects have overlapping functionality. however, none have been written specifically for contact network epidemiology with the intent of providing a common, extensible toolkit for researchers to use to develop their own models.

although epifire is intended as an api for contact network epidemiology, the network class is independent from the simulation classes, and is thus applicable to other types of network-based modeling, such as metabolite interaction networks  <cit>  and animal migration between habitats  <cit> .

the epifire graphical interface provides a user-friendly toolkit for performing network-based sir epidemic simulations and gaining an intuitive understanding of the impact of network structure on infectious disease dynamics. the most obvious applications are pedagogical: the straight-forward interface and rapid feedback allow users to learn first-hand the consequences of changing epidemic and network parameters. epifire has been used in courses at the university of texas at austin and at the summer institute in statistics and modeling in infectious diseases  at the university of washington  <cit> . epifire gui may be particularly useful to researchers during initial epidemiological explorations of a new contact network because of the ease with which it generates figures and network statistics.

we are currently adding support for deterministic, ordinary differential equation models, which will include derived classes implementing the standard mass-action sir model, and a network-based sir model  <cit> . the stochastic, continuous time mass-action model that epifire currently provides in massaction_sim.h will likely be refactored into a gillespie model base class and mass-action and network derived classes. finally, although the epifire simulators can be extended beyond sir epidemic models , we would like to provide a generic interface for specifying an arbitrary disease-state progression.

CONCLUSIONS
efficient and easy-to-use software plays a critical role in computational biology research. contact network approaches in epidemiology provide sophisticated analytical and efficient computational methods, but these can be technically challenging and time consuming to implement. currently no open-source toolkit is available for facilitating contact network epidemiology research. we present epifire, an applications programming and graphical interface, available for windows, os x, and linux online at sourceforge.net/projects/epifire. as the field of contact network epidemiology matures, so should its mathematical and computational toolkit. open-source code libraries like epifire help to avoid programming mistakes, increase the transparency of analyses, and reduce barriers between the conception and implementation of ideas.

availability and requirements
project name: epifire

project home page: https://github.com/tjhladish/epifire/wiki/ for source code, http://sourceforge.net/projects/epifire/ for binary installers

operating systems: platform independent

programming language: c++

other requirements: g++  <dig>  for api; g++  <dig>  and qt  <dig>  for gui

license: gnu gplv3

any restrictions for use by non-academics: none

competing interests
the authors declare that they have no competing interests.

authors’ contributions
th conceived of and implemented the project and drafted the manuscript. em assisted in developing the programmatic and graphical interfaces. lab developed a beta version of the graphical interface. lam helped to implement analytical methods, refine the graphical interface and draft the manuscript. ag helped to draft the manuscript. all authors read and approved the final manuscript.

supplementary material
additional file 1
appendices a and b.

click here for file

 acknowledgements
we wish to thank erik volz for suggesting the development of a graphical interface, and claus wilke for suggesting ways to make the software more user-friendly.

funding was provided by national institute of general medical sciences midas grant u01gm <dig> and national science foundation grant deb- <dig> to lam. this material is based in part upon work supported by the national science foundation under cooperative agreement no. dbi- <dig>  any opinions, findings, and conclusions or recommendations expressed in this material are those of the author and do not necessarily reflect the views of the national science foundation.
