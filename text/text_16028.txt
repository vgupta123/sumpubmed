BACKGROUND
large-scale computational analysis of biomolecular data often involves the execution of multiple, interdependent operations on an input dataset. the software tools, models and databases that are used in this process need to be arranged in precise computational chains, where output of one analysis serves as the input of a subsequent analysis. such chains are often referred to as pipelines or workflows. in formal terms, a pipeline can be defined as a graph that describes the order of, and mutual relationships between, the analyses to be performed on an input dataset. in a pipeline representation, an operation performed by a computational tool on input data is represented by a node. the connection between two nodes is represented by an edge and defines a stream of data in-between two analyses. an example of a simple computational pipeline representing part of a genome annotation process is depicted in figure  <dig> 

even for a small bioinformatics project with a few interdependent analyses, it is cumbersome to perform all operations manually. for larger projects, e.g. the annotation of a complete eukaryotic genome, which may require the use of dozens of interdependent tools, including gene prediction tools, homology searches against different databases, protein domain analyses and repeat discovery, this quickly becomes excessively complex. the annotation of a genome may require the use of dozens of interdependent tools, including gene prediction tools, homology searches against different databases, protein domain analyses and repeat discovery.

some of these tools may need to be executed up to tens of thousands of times. the scale and complexity of such computational analyses call for the use of dedicated pipeline software that enables the programming, execution and data-flow management of all analyses required.

with primarily the development of a system for large-scale genome annotation in mind, we have defined the following operational requirements for the design of pipeline management software:

high-throughput
the system should be capable of handling large datasets, complex data analysis workflows and large numbers of jobs requiring long periods of processing time. to this end, the system must be able to employ a compute cluster.

ease-of-use
in a high-throughput data production environment, it is important to have a pipeline system in place that is easy to use by non-expert end-users. this can be achieved by a well-designed graphical user interface  that allows easy and intuitive creation, adaptation, monitoring and administration of a pipeline.

flexible
new or upgraded bioinformatics tools, models and databases appear frequently. to remain up-to-date, it is essential that employment of new or upgraded resources within the pipeline is straightforward. the system should therefore be modular and flexible, and able to accommodate complex data relationships required by some tools. use of an open communication standard can help to achieve this and ensures the system is compatible with remote resources through the use of web services  <cit> .

updates
in ongoing projects it is often undesirable to postpone analysis until all data has been generated. initial analysis must therefore be repeated on a regular basis, for example, when genome assemblies are updated or new reference data  become available. again, adequate data storage and tracking is important, allowing the pipeline operator to identify the affected parts of the pipeline to reschedule and re-execute only the affected parts of a pipeline with minimal redundancy.

there are a number of pipeline systems publicly available, including ensembl  <cit> , pegasys  <cit> , gpipe  <cit> , taverna  <cit> , wildfire  <cit> , mowserv  <cit> , triana  <cit>  and kepler  <cit> . we will not consider systems that are not publicly available . this article describes the development of a new pipeline system, cyrille <dig>  an obvious question is why we would want to develop yet another system? the answer is, in short, that the available systems do not sufficiently comply with the requirements outlined above. we have built the cyrille <dig> system to provide this distinct set of features. in the discussion we will extend the comparison with other systems in more detail.

implementation
for a detailed description of the structural design and operation of the cyrille <dig> system several key terms must be defined. table  <dig> provides the definitions of the most important terms used. hereafter, we will start with a general overview of the cyrille <dig> design, followed by an explanation of how the data-flow is organized within the system. with this knowledge we will continue to describe the core software parts  and end with a description of pipeline operation.

system overview
the cyrille <dig> system architecture is composed of four distinct layers . layer  <dig> comprises the main functional and core software components. these core components make extensive use of a modular application programming interface  . the api allows unified access to three system databases . the biological database and the end-user interface that connect to it are third-party systems that can be integrated with the cyrille <dig> system . to allow tracking and debugging of a pipeline in operation, a centralized status and logging system is implemented. this provides a pipeline operator access to detailed information on the status of a pipeline run and errors that might have occurred.

a pipeline system needs to manage and store large amounts of diverse information. to keep different types of data separated, the system employs four databases :  the pipeline database which stores pipeline definitions, node settings and associated parameters;  the status database which stores the execution state of a pipeline at any given time, tracking all jobs and their respective in- and output.;  the biological database which stores and provides access to the results of all analyses and;  a failover database which employs a generic method to store all data that does not need to be stored in the biological database.

consider, as an illustration, the gene-prediction node  from the example pipeline given in figure  <dig>  the pipeline database identifies this node as a gene prediction node and stores all instructions  on how the gene prediction tool is to be executed on each input dna sequence from the preceding load sequence node . the status database stores information on which of the input sequences the gene prediction has been performed, which genes have been predicted and tracks all objects associated to this analysis in the biological database using unique object identifiers.

similar to the functional division of the databases, the core software is divided into three distinct functional parts: the graphical user interface , the scheduler and the executor . the gui allows a pipeline operator to create, adapt, start and stop pipeline runs and fine-tune pipeline and tool settings. a screenshot of a genome annotation pipeline created with the gui is given in figure  <dig>  additional series of screenshots showing the operation of a small pipeline using the gui are given in additional file  <dig> 

the scheduler is the core of the cyrille <dig> system. it retrieves pipeline definitions from the pipeline database and schedules all jobs for execution, accounting for dependencies between nodes. a scheduled job is stored in the status database. further details on scheduler operation are given below. the executor loops through all scheduled jobs and executes each of these. the results of each job are stored in the biological database and are tracked with unique object identifiers in the status database. if the number of jobs to be executed is large, a compute cluster is required to keep the total execution time within bounds. to this end the executor acts as a broker between the cyrille <dig> system and third-party compute cluster software such as sun grid engine . it is possible to employ multiple and different types of clusters by running multiple instances of the executor.

whereas the cyrille <dig> pipeline software functionally consists of three separate parts, from a software implementation point of view, the essential application logic of the system is implemented using object oriented programming. the system implements different scheduling strategies in different node types . a new node type  can be created from scratch or it can inherit from an existing node class making the implementation of new functionality as easy as possible.

data flow and storage
a major challenge for any pipeline system is to devise a fast and robust way to conduct data through a pipeline. this is not trivial, given that even a relatively simple pipeline  may imply that many thousands of separate jobs need to be scheduled and executed, which in turn may result in millions of objects.

automated execution of a pipeline implies that each node needs to hold information on the nature and format of the objects that enter and leave it and that it has to process such streams in a manner unique for each type of data. for example, a stream of dna sequences is different from a stream containing blast reports. the issue is best approached using a uniform syntax and identification of the data transported in a pipeline. this does not only allow for a standardized implementation of the scheduling strategies of different node types, but also for a generic node interface description and for data tracking.

several data exchange formats, with varying scope, have been devised and proposed for the handling and communication of biomolecular data, including xml-based formats such as game  and biomoby  <cit> , and flat-file formats such as gff. an appropriate data exchange format identifies and communicates data in a uniform and unambiguous manner. such a format must permit unique identification and classification, and it must be extensible to accommodate future incorporation of novel data types. with this in mind, we have chosen to implement biomoby  <cit>  as data exchange format for the cyrille <dig> system. biomoby is emerging as an important data standard in bioinformatics and is already used by mowserv  <cit>  and taverna  <cit>  when this system is dealing with biomoby operations.

the biomoby standard contains a specification on how to describe data types, formats, and analysis types. it is a meta-data format, meaning that it does not describe data but defines how to describe data. biomoby employs a system of object identification and classification, in which each biomoby object is identified with  an identification string ,  an object type  and  a namespace. biomoby encompasses the description of web services and facilitates interoperability with third-party servers. in the current era of distributed computing, this ability to communicate with systems worldwide is becoming ever more important.

standardized object identification is also applicable in standardized data storage. with a biomoby object stored with a unique id , articlename and namespace, these three values are sufficient to uniquely retrieve the object from a database. the cyrille <dig> system is designed to allow the use of different databases schemas and/or engines to ensure flexibility. a database wrapper functions as an intermediate between the object identity on the one hand and database-specific storage and retrieval of these objects on the other hand . the database wrapper contains specific instructions to store, retrieve and delete each different object type in the biological database. this solution combines the unique identification of any object with the freedom to use any database. the database wrapper currently implemented in our system is written for the generic genome browser database schema using mysql. two other database schemes have been implemented for use in projects on mirna discovery and comparative genomics.

storage of all intermediate data generated during pipeline operation is guaranteed by the failover database that automatically stores any object not stored in the biological database. this may happen for two reasons: firstly, an intermediate object might be of no importance to the end-user querying the biological database, or, secondly, the database wrapper fails to store the object to the biological database for an unexpected reason; in either case, no data is lost.

apart from transporting data in between separate nodes of the system, a pipeline system needs methods to upload new data into the system and retrieve the results afterwards. to upload data into the cyrille <dig> system, specific start nodes are provided allowing the upload of data through the user interface or automatically harvesting data from a file system. the resulting data of the pipeline is stored in a domain specific database, for example the generic genome browser database  <cit> , which is commonly used in genome annotation. the web interface is, in this case, a bonus that helps end-users to access the data.

scheduler
the scheduler is the core of the cyrille <dig> system. based on a pipeline definition  it schedules all jobs for execution, taking mutual dependencies between nodes into account. various tools used in an analysis pipeline require different arrangements of incoming data. for example, node  <dig> in figure  <dig> uses all dna sequences from node  <dig> to create a blast database. the scheduler thus arranges all sequences to be processed by a single job. in contrast, node  <dig> processes each sequence separately in a blast analysis. in this case the scheduler creates as many jobs as there are input sequences. this is illustrated in figure  <dig>  which shows the same pipeline as given in figure  <dig>  but now expanded with detailed information on the objects that are created and the jobs that are scheduled.

scheduler functionality is embedded in the node classes. this modular, object-oriented implementation of a node allows for complex scheduling strategies. a more complex node implemented in the cyrille <dig> system schedules groups of objects which share a common grandparent, for example, all repeats that are predicted by several different repeat detection tools, grouped per bac sequence .

pipeline execution
execution of a pipeline can be considered at two levels: execution of a separate node, and execution of an entire pipeline. a single node in the cyrille <dig> system executes a variable number of distinct jobs. for example, a blast analysis of  <dig> input sequences requires a blast node to execute  <dig> blast jobs. a single blast job consists of several processing steps: retrieve the input sequence  from the biological database; export the sequence as a fasta file; execute blast with the correct parameters; read and parse the resulting blast report to a biomoby representation; write the biomoby formatted blast report to the biological database, and; register the results in the status database.

node operation in cyrille <dig> is performed by executing three different scripts :  data is retrieved from the database;  the tool is executed, and;  the results are stored back in the database. communication with the database is handled by two database connection scripts , which is equivalent to the ensembl runnabledb  <cit> . these two scripts access the database wrapper  and provide generic communication with any database of choice.

a tool wrapper is responsible for the execution of the tool and provides generic interaction with the cyrille <dig> system. tool wrappers are implemented in such a way that they can run standalone, be part of a biomoby web service, or function as a component of the cyrille <dig> system. a tool wrapper is equivalent to a runnable in the ensembl system  <cit> . during execution, the tool wrapper is responsible for steps d, e and f from figure  <dig> 

a further task of the tool wrapper is to register itself in the cyrille <dig> system. registration implies that the tool becomes available through the gui, allowing a pipeline operator to integrate it into a pipeline and allowing the scheduler to correctly schedule jobs for that tool. the process communicates what type of objects are required as input , what parameters are accepted  and with what node type it must be associated. this is implemented in a generic registration method where the wrapper registers all required information into the pipeline database.

in a rapidly evolving field like bioinformatics, it is of great importance that new tools can be implemented quickly. in the cyrille <dig> system this requirement is implemented through modular, object oriented, design of the tool wrapper code. in brief, implementation of a novel tool in the cyrille <dig> system involves the following procedure:  installation and configuration of the new tool on the execution server or cluster;  writing of the biomoby-compatible tool wrapper;  definition of new biomoby objects ;  confirmation of compatibility between object types and the biological database in use, and;  registration of the tool in the pipeline database.

a complete pipeline operates by iteratively running the scheduler and executor. results produced by a tool under control of the executor can result in more jobs to be scheduled by the next scheduler run. if there are no more jobs to be executed for a node and all its parents, it is flagged as finished in the status database. a complete pipeline is finished if all nodes are in the finished state. pipeline iteration can be resumed after new data is uploaded into the pipeline, when a database has been updated  or when the pipeline definition has changed. resumption is accomplished by unflagging the finished state of one or more nodes in a pipeline. this is either done manually  or automatically, for example after a blast database update.

RESULTS
our local implementation of the cyrille <dig> system runs on a dedicated server  and has a  <dig> cpu, sge based linux compute cluster at its disposal. a list of third party tools currently wrapped in the cyrille <dig> system is provided .

in a test run, the cyrille <dig> system analyzed  <dig> arabidopsis bac sequences  randomly downloaded from ncbi using the pipeline shown in figure  <dig>  the analyses resulted in over  <dig>  objects created in over  <dig>  different analyses executed. the results are summarized additional file  <dig>  measurement of the pipeline execution time is not relevant as the bulk of the execution time results from executing the actual tools. as an illustration, however, the analysis of a single bac with the pipeline from figure  <dig> takes approximately an hour to complete on a linux compute cluster with  <dig> cpus .

the cyrille <dig> system is now used routinely for bac annotation in two solanaceous genome sequencing projects in which our group is involved  <cit> . in addition, we run the system in a comparative genomics project of fungal genomes and a second project on the large-scale prediction of micrornas in plant and animal genomes. these last two projects require very high data throughput and employ databases different from the generic genome browser database and thus demonstrate the flexibility of the cyrille <dig> system and its ability to execute complex and computationally demanding pipelines.

discussion
the cyrille <dig> system was developed with the aim of providing an automated, high-throughput, easy-to-use, flexible and extensible bioinformatics workflow management system. among its most notable features are the implementation of a powerful job scheduler module, storage of intermediate data, compatibility with different database types for storage of biological data, a generic tool wrapper module, and uniform data transport and data tracking.

ease-of-use is achieved through implementation of an intuitive user interface with several layers of complexity. a pipeline operator can select from a predefined set of pipelines and nodes to perform complex data analysis tasks while an administrator is able to construct novel, and fine-tune existing, pipelines.

high-throughput operation
the major part of the development effort has been directed towards achieving flexibility and extensibility in architecture and high-throughput operation. in a high-throughput data analysis environment, parallel execution of jobs is important to optimally use the available computational facilities and hence, make pipeline calculation time as short as possible. this requires specific scheduling logic for different node types. the cyrille <dig> scheduler prepares jobs for parallel execution as soon as results from preceding analyses become available. the single node type schedules a job immediately after an input object becomes available. this means that subsequent analyses can already start before the parent node is finished. most pipeline systems implement a scheduling engine able to schedule jobs in parallel  <cit> . an important feature of cyrille <dig> is the modular implementation of the node class allowing a greater variety in scheduling strategies.

parallel scheduling requires parallel execution, which is controlled by the executor. there are many solutions available for the distribution of jobs over a compute cluster, including sun grid engine , condor, openpbs and lsf. for the cyrille <dig> executor, we have chosen to employ sge, which is both stable and able to handle high loads. a port for grid technologies such as condor is under development and will allow the cyrille <dig> system to employ idle windows desktops.

another important aspect in high-throughput pipeline analysis is the storage of intermediate results. if this is implemented, the pipeline system will be able to resume calculations close to the point where it may have stopped after a system failure. this feature becomes important when a pipeline requires a long execution time and hence, the chance of a failure, somewhere in the system, increases. if storage of intermediate data is undesirable, for example because of disproportional usage of storage capacity, it is straightforward to either develop a node type which embeds two or more other nodes and directly transfers the data between the nodes in a single executor run, or to develop a single tool wrapper which executes both steps and behaves as a single tool in the system. in both cases, intermediate data storage is by-passed.

a further advantage of intermediate data storage is that each part of a pipeline can be re-executed when necessary. this is essential when only part of a pipeline needs to be repeated with either different parameter settings, after a database update, or upon the addition of extra nodes to the pipeline. in the current implementation of cyrille <dig>  the system will remove, prior to a rerun, all data that is affected by the update from both the status and biological databases and rerun the necessary analyses. for example, consider the genome annotation pipeline of figure  <dig>  prior to uploading a new version of a sequence, the pipeline operator will flag this sequence, instructing the system to delete all gene predictions and blast hits associated with that sequence. the system will subsequently perform only those analyses on which the changed sequence had an impact.

we have encountered two severe problems during cyrille <dig> development, both related to system overhead: 1) biomoby xml parsing is very time-consuming for large data-sets, and; 2) sge overhead becomes very large for nodes which execute a large amount of small jobs. the import and export of large xml files in general is notoriously slow. in cyrille <dig>  we have solved this problem by circumventing raw xml transport as much as possible. for example, conversion of the data between steps  <dig>   <dig> and  <dig> in the node depicted in figure  <dig>  from raw xml to an internal python object representation of the biomoby xml boosted the performance of this node significantly. using serialized objects might, as a drawback, have an impact on backwards compatibility, specifically if objects are stored in the failover database.

the second major obstacle concerned the overhead involved in executing large numbers of jobs with very short computation time. if each of these jobs is scheduled separately on an sge cluster, the overhead used by sge considerably exceeds the time required for the execution itself. this overhead was significantly reduced by implementing a generic batch mechanism which is able to execute an arbitrary amount of pipeline jobs as a single sge job.

flexibility
in the rapidly evolving field of genome annotation, it is critical that a pipeline management system is flexible and easily extensible. the cyrille <dig> system was designed to allow future incorporation of novel tools, data types and databases in a generic fashion. for example, for a present-day genome annotation project, it is generally sufficient to store all relevant data in a biological database such as the generic genome browser database  <cit> . however, if one would require the inclusion of data such as multiple alignments or 3d protein structures, a different database is required.

the cyrille <dig> system is designed to make the addition of a novel object type or the complete change of the biological database as easy as possible. this is achieved by implementation of the database wrapper as a separate module. addition of a novel data type can be done by adding a 'get', 'store' and 'delete' function for this type of data type to the database wrapper. to create a wrapper for another database schema, a new module must be written with a storage, retrieval and delete function for each object type. this mode of integration of a third-party database with a pipeline system is unique for the cyrille <dig> system. many alternative systems do not use a database for storage of intermediate results, . instead, these systems transport the output of one program directly to the next program and/or store intermediate results as flat files. such an approach is unsuitable for large-scale data analysis. a database system is better suited to keep track of many, possibly millions, of intermediate objects and their mutual relationships. moreover, a database is better adapted to distribute data in a heterogeneous environment. other systems do employ a database for data storage  but each of these is strongly linked to a specific database schema, thus limiting their flexibility.

in the current implementation of cyrille <dig>  the generic genome browser database  <cit>  is used for storage of the genome annotation data with, as an obvious extra, the generic genome browser allowing an end-user easy access to the annotations. implementing cyrille <dig> in different projects, such as comparative genomics and mirna prediction has proven the capability of cyrille <dig> to operate using different databases schemes.

the use of biomoby as a communication standard combined with the storage of standardized object identifiers by the cyrille <dig> system ensures that any object can be handled and tracked by the system, including binary objects such as images  <cit> . other advantages of using biomoby are that it ensures easy integration with the growing body of remote biomoby web services and optimal interconnectivity between nodes. at the same time, it is possible for external users to access the cyrille <dig> tools using any biomoby client if the tools and toolwrappers are placed, with some minor modifications, on a web server.

several systems employ specific embedded scripts to translate the output of one tool to the input of the next  as opposed to using a standardized data format. most analysis tools have a unique in- and output format and thus the number of unique translation steps grows quickly with the number of tools wrapped. this can be mitigated by using uniform data transport such as biomoby, which is used in cyrille <dig>  mowserv  <cit>  and taverna  <cit>  when this system is dealing with biomoby operations. the ensembl system employs a uniform perl data structure to the same end  <cit> .

on a higher level, import and export of the description of a complete pipeline would improve flexibility by allowing the exchange of workflows with other systems. for example, a pipeline developed in taverna could then be executed in cyrille <dig>  or vice versa. there are several candidate languages available such as scufl, used by taverna, or the more widely accepted bpel  <cit> . research is necessary to see if the adaptation of such a standard would be worthwhile for the cyrille <dig> system, both to see if any candidate provides sufficient flexibility as to assess the amount of work necessary to implement such a standard.

CONCLUSIONS
the cyrille <dig> system has been developed to operate in the environment of a high-throughput sequencing facility with a need for robust, automated and high-throughput genome analysis, and easy creation, adaptation and running of pipelines by non-expert users.

most of the pipeline systems that have recently been released were developed as a workbench for bioinformaticians. some systems excel in the way they allow for complex pipelines to be built through a visually appealing but sometimes complex gui . most systems are not suited for automated, high-throughput operation with as obvious exception ensembl  <cit> . ensembl was, however, not designed to be deployed at other sites or execute ad hoc pipelines.

in view of the distinctive functionality and combination of features implemented in the cyrille <dig> system we believe that it is a valuable addition to the array of pipeline systems available and particularly useful in environments that require high-throughput data analysis. in the near future we are planning to expand the cyrille <dig> system in computational workflows for metabolomics data analysis.

availability and requirements
cyrille <dig> is written in python on a linux platform and requires a mysql database server and an apache/mod_python web server. the system expects a rocks linux cluster for execution of analysis tools, although other sge based solutions should work. the source code of the cyrille <dig> system is published under the terms and conditions of the gnu public license and is freely available from .

authors' contributions
mf is the lead developer of the cyrille <dig> system, has implemented most of the core of the system and has drafted this publication. avdb and ed have both contributed to the development of tool wrappers, the database layer, limited work on the core and the manuscript. jdg has aided in implementing the gui. rvh has been the project manager and contributed in discussions, planning and writing of this manuscript. all authors have read and approved the manuscript.

supplementary material
additional file 1
fiers.cyrille <dig> suppl <dig> pdf contains a series of screenshots showing the creation and operation of a small pipeline using the cyrille <dig> system.

click here for file

 additional file 2
fiers.cyrille <dig> suppl <dig> pdf contains a list of tools currently wrapped for use in the cyrille <dig> system.

click here for file

 additional file 3
fiers.cyrille <dig> suppl <dig> pdf contains the results of a test run with the pipeline from figure  <dig> and  <dig> randomly downloaded bacs.

click here for file

 acknowledgements
the development of cyrille <dig> was supported by the centre for biosystems genomics .
