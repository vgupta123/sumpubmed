BACKGROUND
the exact matching of dna sequences to a genome is a special case of the string matching problem. it requires incorporating the known properties or features of the dna sequences and the sequencing technologies, thus, adding additional complexity to the mapping process. in this section, we first give a brief description of a set of features of dna and sequencing technologies. then, we explain how the tools used in this study work and support these features. additionally, we describe the default options setup and show how divergent they are among the tools. finally, we compare the evaluation criteria used in previous studies.

features
● seeding represents the first few tens of base pairs of a read. the seed part of a read is expected to contain less erroneous characters due to the specifics of the ngs technologies. therefore, the seeding property is mostly used to maximize performance and accuracy.

● base quality scores provide a measure on correctness of each base in the read. the base quality score is assigned by a phred-like algorithm  <cit> . the score q is equal to − <dig> log <dig>  where e is the probability that the base is wrong. some tools use the quality scores to decide mismatch locations. others accept or reject the read based on the sum of the quality scores at mismatch positions.

● existence of indels necessitates inserting or deleting nucleotides while mapping a sequence to a reference genome . the complexity of choosing a gap location increases with the read length. therefore, some tools do not allow any gaps while others limit their locations and numbers.

● paired-end reads result from sequencing both ends of a dna molecule. mapping paired-end reads increases the confidence in the mapping locations due to having an estimation of the distance between the two ends.

● color space read is a read type generated by solid sequencers. in this technology, overlapping pairs of letters are read and given a number  out of four numbers  <cit> . the reads can be converted into bases, however, performing the mapping in the color space has advantages in terms of error detection.

● splicing refers to the process of cutting the rna to remove the non-coding part  and keeping only the coding part  and joining them together. therefore, when sequencing the rna, a read might be located across exon-exon junctions. the process of mapping such reads back to the genome is hard due to the variability of the intron length. for instance, the intron length ranges between  <dig> and  <dig>  nt in eukaryotic model organisms  <cit> .

● snps are variations of a single nucleotide between members of the same species. snps are not mismatches. therefore, their locations should be identified before mapping reads in order to correctly identify actual mismatch positions.

● bisulphite treatment is a method used for the study of the methylation state of the dna  <cit> . in bisulphite treated reads, each unmethylated cytosine is converted to uracil. therefore, they require special handling in order not to misalign the reads.

tools’ description
for most of the existing tools , the mapping process starts by building an index for the reference genome or the reads. then, the index is used to find the corresponding genomic positions for each read. there are many techniques used to build the index  <cit> . the two most common techniques are the followings: 

● hash tables: the hash based methods are divided into two types: hashing the reads and hashing the genome. in general, the main idea for both types is to build a hash table for subsequences of the reads/genome. the key of each entry is a subsequence while the value is a list of positions where the subsequence can be found. hashing based tools include the following tools:

gsnap <cit>  is a genome indexing tool. the hash table is built by dividing the reference genome into overlapping oligomers of length  <dig> sampled every  <dig> nucleotides. the mapping phase works by first dividing the read into smaller substrings, finding candidate regions for each substring, and finally combining the regions for all of the substrings to generate the final results. gsnap was mainly designed to detect complex variants and splicing in individual reads. however, in this study, gsnap is only used as a mapper to evaluate its efficiency.

novoalign <cit>  is a genome indexing tool. similar to gsnap, the hash table is built by dividing the reads into overlapping oligomers. the mapping phase uses the needleman-wunsch algorithm with affine gap penalties to find the global optimum alignment.

mrfast and mrsfast <cit>  are genome indexing tools. they build a collision free hash table to index k-mers of the genome. mrfast and mrsfast are both developed with the same method, however, the former supports gaps and mismatches while the latter supports only mismatches to run faster. therefore, in the following, we will use mrsfast for experiments that do not allow gaps and mrfast for experiments that allow gaps. unlike the other tools, mrfast and mrsfast report all of the available mapping locations for a read. this is important in many applications such as structural variants detection.

fangs <cit>  is a genome indexing tool. in contrary to the other tools, it is designed to handle the long reads generated by the  <dig> sequencer.

maq <cit>  is a read indexing tool. the algorithm works by first constructing multiple hash tables for the reads. then, the reference genome is scanned against the tables to find the mapping locations.

rmap <cit>  is a read indexing tool. similar to maq, rmap pre-processes the reads to build the hash table, then the reference genome is scanned against the hash table to extract the mapping locations.

most of the newly developed tools are based on indexing the genome. nevertheless, maq and rmap are included in this study to investigate the effectiveness of our benchmarking tests on evaluating read indexing based tools. in addition, we investigate if there is any potential for the read indexing technique to be used in new tools.

● burrows-wheeler transform :

bwt <cit>  is an efficient data indexing technique that maintains a relatively small memory footprint when searching through a given data block. bwt was extended by ferragina and manzini  <cit>  to a newer data structure, named fm-index, to support exact matching. by transforming the genome into an fm-index, the lookup performance of the algorithm improves for the cases where a single read matches multiple locations in the genome. however, the improved performance comes with a significantly large index build up time compared to hash tables.

bwt based tools include the following:

bowtie <cit>  starts by building an fm-index for the reference genome and then uses the modified ferragina and manzini  <cit>  matching algorithm to find the mapping location. there are two main versions of bowtie namely bowtie and bowtie  <dig>  bowtie  <dig> is mainly designed to handle reads longer than  <dig> bps. additionally, bowtie  <dig> supports features not handled by bowtie. it was noticed that both versions had different performance in the experiments. therefore, both versions are included in this study.

bwa <cit>  is another bwt based tool. the bwa tool uses the ferragina and manzini  <cit>  matching algorithm to find exact matches, similar to bowtie. to find inexact matches, the authors provided a new backtracking algorithm that searches for matches between substring of the reference genome and the query within a certain defined distance.

soap <dig> <cit>  works differently than the other bwt based tools. it uses the bwt and the hash table techniques to index the reference genome in order to speed up the exact matching process. on the other hand, it applies a “split-read strategy”, i.e., splits the read into fragments based on the number of mismatches, to find inexact matches.

in addition to providing different mapping techniques, each tool handles only a subset of the dna sequences and the sequencing technologies features. moreover, there are differences in the way the features are handled, which are summarized in table  <dig>  for instance, bwa, soap, and gsnap accept or reject an alignment based on counting the number of mismatches between the read and the corresponding genomic position. on the other hand, bowtie, maq, and novoalign use a quality threshold  to perform the same function. the quality threshold is different from the mapping quality. the former is the probability of the occurrence of the read sequence given an alignment location while the latter is the bayesian posterior probability for the correctness of the alignment location calculated from all of the alignments found for the read.

pe: paired-end only, mm.: mismatches, qs: base quality score, count: total count of mismatches in the read, as: alignment score, and empty cells mean not supported.

in some cases, the features are partially supported. for example, soap <dig> supports gapped alignment only for paired end reads, while bwa limits the gap size. therefore, considering only one of the above features when comparing between the tools would lead to under- or over-estimation of the tools’ performance.

default options of the tested tools
in general, using a tool’s default options yields a good performance while maintaining a good output quality. most users use the tools with the default options or only tweak some of them. therefore, it is important to understand the effect of using these options and the kind of compromises made while using them. for the nine tools considered in this paper, the most crucial default options are the following: 

● maximum number of mismatches in the seed: the seed based tools use a default value of  <dig> 

● maximum number of mismatches in the read: bowtie <dig>  bwa, and gsnap determine the number of mismatches based on the read length. it is  <dig> for rmap,  <dig> for mrsfast, and  <dig> for soap <dig>  fangs, and mrfast.

● seed length: it is  <dig> for maq,  <dig> for rmap, and  <dig> for bowtie. bwa disables seeding while soap <dig> considers the whole read as the seed.

● quality threshold: it is equal to  <dig> for maq and bowtie while it depends on the read length and the genome size for novoalign.

● splicing: this option is enabled for gsnap.

● gapped alignment: it is enabled for bowtie <dig>  gsnap, bwa, novoalign and maq while it is disabled for soap <dig> 

● minimum and maximum insert sizes for paired-end mapping: the insert size represents the distance between the two ends. the values used for the minimum and the maximum insert sizes are  <dig> and  <dig> for bowtie and maq,  <dig> and  <dig> for bwa and bowtie <dig>   <dig> and  <dig> for soap <dig>  and  <dig> and  <dig> for rmap. mrfast and mrsfast do not have default values for max and min insert sizes.

indeed, as will be shown in the results’ section, having different default values lead to different results for the same data set. hence, using the same values when comparing between the tools is important.

evaluation criteria
in general, the performance of the tools is evaluated by considering three aspects, namely, the throughput or the running time, the memory footprint, and the mapping percentage. the throughput is the number of base pairs mapped per second  while the memory footprint is the required memory by the tool to store/process the read/genome index. the mapping percentage is the percentage of reads each tool maps.

the mapping percentage is further divided into a correctly mapped reads part and an error  part. there have been many definitions suggested for the error in previous studies. for instance, for the simulated reads, the naïve and most used definition for error is the percentage of reads mapped to the incorrect location   <cit> . clearly, this definition is neither sufficient nor computationally correct. figure  <dig> gives an example explaining the drawbacks of this definition. after applying sequencing errors, the read does not exactly match the original genomic location. since the tools do not have any a-priori information for the data, it would be impossible to choose the two mismatches location as the best mapping location over the exact matching one. therefore, the naïve criteria would judge the tool as incorrectly mapping the read if the tool returned either alignment  or  while in fact it picked a more accurate matching.

the naïve definition for the error was further modified by ruffalo et al.  <cit>  to develop a more concrete definition. the authors incorporated the mapping quality information such that a read is correctly mapped if it is mapped to the original genomic location while having a mapping quality greater than a certain threshold. they further categorized the incorrectly mapped reads into incorrectly mapped-strict and incorrectly mapped-relaxed. the incorrectly mapped-strict are the reads that were mapped with a quality higher than the threshold while not mapped to the original genomic location. on the other hand, the incorrectly mapped-relaxed are the reads that were mapped to an incorrect location with a quality higher than the threshold and there is no correct mapping for the read with a mapping quality higher than the threshold. as an example, in figure  <dig>  if the used threshold is  <dig>  then the read would be considered correctly mapped if the tool returned alignment  while it would be considered as incorrectly mapped-strict if the tool returned either alignment  or . on the other hand, if the used threshold is  <dig>  a read would be incorrectly mapped-relaxed if the tool returned alignment . indeed, this is a valuable evaluation criterion, however, many tools, such as soap <dig>  rmap, and bwa, do not use quality scores in the mapping phase. in addition, not all of the tools report the mapping quality.

another definition was introduced by holtgrewe et al.  <cit> . unlike the previous works, the authors tried to find a gold standard for each read, where a gold standard refers to all of the possible matching intervals for each read with a maximum distance k from the read. to enumerate all of the possible matching intervals, the authors used razers to detect the initial seed location for each interval. afterwards, they developed a method to find the boundary of the interval centered at the seed and with a maximum distance k from the read. they named the suggested evaluation method rabema. as an example, a possible interval with k= <dig> would contain alignment  and  in figure  <dig>  accordingly, holtgrewe et al. defined the false negatives as the intervals missed by the mapper and the false positives as the intervals returned by the mapper and not included in the gold standard. however, consisting of seed detection phase and enumeration phase while depending on razers to return seed locations for the matching intervals makes rabema impractical to apply on large genomes and long read lengths, e.g., razers took  <dig> hours to map  <dig> million reads of length  <dig> to the human genome while doubling the running time when increasing the read length from  <dig> to  <dig>  <cit> . therefore, holtgrewe et al. suggested another mode, an oracle mode, which makes use of the original location of simulated reads. the oracle mode uses the original location as the seed location instead of using razers to detect the initial seed locations. however, this method is only suitable in case of a-priori knowledge that the possible mapping locations for a read are around the simulated location  in figure  <dig> would be missed in the oracle mode). nevertheless, after the initial submission of this work, razers <dig>  <cit>  was published; making a significant improvement in rabema running time and elevating the slowness problem. even though the suggested definition for a gold standard quantitatively estimates the sensitivity for each mapper, it suffers from a couple of drawbacks. first, the definition does not take into consideration whether the alignments are violating the mapping criterion for the mapper or not. for instance, in figure  <dig>  the sensitivity of the mapper would increase if it detected alignments , , and . however, if the mapping criterion for the mapper is to allow a maximum of two mismatches, then alignment  should have not been detected by the mapper and should be considered as a wrong alignment or error. second, quality aware based tools, such as bowtie, maq, and novoalign, would be incorrectly evaluated by rabema since they use the quality threshold to accept or reject a read instead of calculating the edit or hamming distance. therefore, they might map a read with more mismatches than the limit allowed by rabema.

methods
benchmark design
in this section, we present the features covered by our benchmarking suite. in addition, we explain how they were previously addressed by the tools we mention in this paper. however, two algorithmic features, namely snps and splicing awareness, are not presented in the results section due to being supported only by one tool. the tests are categorized as follows: 

● mapping options

quality threshold: maq, bowtie, and novoalign use the quality threshold to determine the number of allowed mismatches. therefore, setting a quality threshold is similar to explicitly setting the number of mismatches. however, there is no hard limit on the actual number of mismatches. the impact of varying the quality threshold while finding a mapping between the quality threshold and the number of mismatches has not been studied before.

number of mismatches: changing the number of allowed mismatches affects the percentage of mapped reads. this effect was studied in  <cit> , however, the mismatches were generated uniformly on the genome which does not mimic real mismatches distribution.

seed length: seeding-based tools impose limits on the number of mismatches in the seed part. as a result, increasing or decreasing the length of the seed part affects the percentage of mapped reads. the effect of the seed length has not been studied in details before.

● input properties

read length: the read length varies between 30bps for abi’s solid and illumina’s solexa sequencers up to  <dig> bps for roche’s  <dig>  therefore, the impact of read length should be considered for throughput evaluation. even though the effect of the read length was explored in several studies, the default options were usually used leading to incomparable trade-offs.

paired-end reads: mapping paired reads requires the mapping of both ends within a maximum distance between them. hence, it adds a constraint when finding the corresponding genomic locations.

genome type: the efficiency of most algorithms are tested by using the human genome as the reference. however, each genome has its own properties such as the percentage of repeated regions and ambiguous characters. therefore, using a single genome does not reveal the effect of these properties. to the best of our knowledge, bwa  <cit>  was the only tool to test its performance on a large genome other than the human.

● algorithmic features

gapped alignment: is important for variant discovery due to the ability to detect indel polymorphism  <cit> . bowtie <dig>  gsnap, novoalign, bwa, and mrfast are the only tools to support it for single-end reads while the remaining tools support it for paired-end only. however, from the results provided by the previous studies, it is not obvious how gapped alignment affects the performance of the tools in comparison to allowing only mismatches.

snp awareness: incorporating snp information into mapping allows considering minor alleles as matches rather than mismatches. currently, this feature is provided only by gsnap. it was shown in  <cit>  that integrating snp information affected around 8% of the reads and allowed mapping  <dig> % of unmapped reads.

splicing awareness: reads located across exon-exon junctions would be wrongly aligned using standard alignment algorithms. splicing awareness is only required for certain types of data such as rna-seq data. the only tool that currently supports splicing while performing the mapping phase is gsnap. it was shown in  <cit>  that the alignment yield increased by 8-9% when splicing detection based on known splice junctions was introduced. however, there was only  <dig> - <dig> % increase in case of detecting novel splice junctions.

● scalability

the scalability of the mapping tools may be different under different parallel settings. many tools support multithreading, which is expected to yield linearly increasing speedup with the increase in the number of cpu cores. on the other hand, using multiprocessing is more general and may improve the throughput even for tools that do not support multithreading , where multiprocessing refers to using more than one process in a distributed memory fashion while communicating through a message passing interface.

● accuracy evaluation

each tool is expected to map a set of reads based on its mapping criteria. however, a subset of the reads might not be mapped  due to using heuristics in the mapping algorithm or the default options limitations. moreover, some of the tools map a subset of these reads while violating the mapping criteria.

● rabema evaluation

rabema benchmark enumerates all of the possible matching locations. then, it evaluates whether the tool detected the possible matching locations with the specified error rate or not. therefore, rabema evaluation is a valuable one and helps in adding another perspective when comparing between the tools.

usecase: snp calling
snp calling is the process of detecting genetic variations in a given genome. the genetic variations contribute to the generation of different phenotypes for the same gene, leading to increasing the risk of having complex diseases. therefore, the discovery of snps is a very important process that needs to be done accurately. many tools have been developed to detect snps including ssahasnp  <cit>  and snpdetector  <cit> . these tools were developed to analyze the dna sequences generated using either the sanger or the direct pcr amplification methods. however, with the development of the next generation sequencing technology, new tools are required to analyze the new data  <cit> . the developed new tools work by first mapping sequences to a reference genome, then using statistical analysis methods to extract snps  <cit>  after filtering out low-quality mismatches. therefore, accurately mapping the reads to the reference genome is a very crucial task in the snp calling pipeline.

RESULTS
in this section, we present the results from our benchmarking tests. the experiments were performed on a cluster of quad-core amd opteron cpus at  <dig>  ghz with  <dig> gb of ram. we used soap <dig> v <dig> , bowtie v <dig> . <dig> and v <dig> .0-beta <dig>  bwa v <dig> . <dig>  maq v <dig> . <dig>  rmap v <dig> . <dig>  fangs v <dig> . <dig>  gsnap v2010-07- <dig>  novoalign v <dig> . <dig>  and mrfast and mrsfast v <dig> . <dig> .

performance evaluation: the performance is evaluated by considering two factors, namely, the mapping percentage and the throughput. the mapping percentage is the percentage of reads each tool maps while the throughput is the number of mapped base pairs per second . the throughput is calculated by dividing the number of reads mapped over the running time. for genome indexing based tools, the running time includes only the matching time while it includes the indexing and matching time for read indexing based tools. however, the running time for mrsfast includes also the indexing time even though it is a genome indexing based tool. this is due to the dependence of the sensitivity of mrsfast on the window size used in the indexing phase. therefore, the index is rebuilt in most of the experiments to maintain a full sensitivity for mrsfast.

in addition, the mapping percentage is further divided into the following: 

● correctly mapped reads: the percentage of reads mapped within the mapping criteria.

● error: the percentage of reads mapped while violating the mapping criteria. as shown in the background section, this definition provides another evaluation perspective that was not covered by older definitions.

● amb: the percentage of reads mapped to more than one location with the same number of mismatches. most of the tools can return more than one mapping location for amb reads if desired. however, rmap only reports the number of amb reads while not providing any information regarding the mapping location and the number of mismatches. therefore, we will not be able to report the mismatches distribution for the rmap reported amb reads.

data sets: we evaluated the tools on two types of data sets, namely, synthetic data and real data. the synthetic data set mimics reads generated from genomic sequencing while the real data set is for rna-seq. the data sets are further generated as follows: 

● synthetic data: there is a number of tools available to extract synthetic, fastq format, data sets from a reference genome including wgsim <cit> , dwgsim <cit> , mason <cit> , and art <cit> . wgsim generates reads with uniform error distribution while dwgsim provides a uniformly increasing/decreasing error rate. on the other hand, mason and art mimic the error rates for illumina and  <dig> sequencers. in this study, we are using wgsim and art to generate the synthetic data from the human genome. wgsim helps in providing a fair comparison between the tools by using a uniform error distribution model resulting in the same quality score for each base. therefore, all of the tools can be allowed exactly the same number of mismatches regardless of the technique used to set the maximum number. for wgsim, the reads were generated with  <dig> % snp mutation rate,  <dig> % indel mutation rate, 2% uniform sequencing base error rate, and with a maximum insert size of  <dig>  which are the same parameters used in  <cit> . additionally, dohm et al.  <cit>  showed that the sequencing error rate for illumina changes between  <dig> % for the beginning of the read and  <dig> % at the end of the read. therefore, a uniform sequencing error rate of 2% is acceptable. moreover, according to the error rates and indels rate used by the mason simulator  <cit> , an indel rate of  <dig> % is acceptable. we determined the number of reads to generate using wgsim based on the used tool and the experiment. on the other hand, art does not explicitly allow the user to choose the number of generated reads. art generates reads that cover the whole genome with a given coverage level. therefore, to manage generating  <dig> million reads, we used art to generate reads that cover the whole genome with 1x coverage. then, we randomly selected  <dig> million reads from the output reads.

● to make sure that the results are not affected by different wgsim runs, we generated  <dig> different wgsim data sets and ran a sample of the tools independently on each data set. the sample included bwa, gsnap, bowtie, bowtie <dig>  and soap <dig>  we found that the maximum standard deviation from the average was  <dig>  . since there is no significant change between the runs, we will only carry each experiment once on a single data set.

● real data: there are many types of real data sets such as rna-seq data, chip-seq data, and dna sequences that are used in different applications. it is important in our evaluation process to choose the right data set type to better evaluate the applicability of the tools in the different applications. therefore, we prefer to use rna-seq data sets as they are used in many applications including snp and alternative splicing detection. the used data set consists of  <dig> million reads generated by illumina sequencer after isolating mrna from the spretus mouse colon tissues. the mouse genome version mm <dig> was used as the reference genome. indeed, as will be shown, the tools have similar behavior on both the mouse and the human genomes. therefore, there is no contradiction in using the human genome for generating the synthetic data while the mouse genome is used for the real ones.

first, we present the effect of the default options. the results for this experiment are given in figures  <dig> and  <dig>  figure  <dig> shows the results when using wgsim to generate the synthetic data while figure  <dig> shows the results using art. as stated previously, tools try to use the options that yield a good performance while maintaining a good output quality. for instance, as shown in figure  <dig>  bowtie achieves a throughput of around  <dig> ·105bps/s at the expense of mapping only  <dig> % of the reads. on the other hand, bwa maps 91% of the reads at the expense of having a throughput of  <dig> · <dig> bps/s. additionally, soap and mrsfast  would look like that they provide the smallest mapping. however, percentage they are only allowing  <dig> mismatches while other tools such as mrfast and gsnap are allowing more than  <dig> mismatches. therefore, using only the default options to build our conclusions would be misleading. indeed, further experiments show that bwa obtains a high throughput when allowed to use the same options as bowtie . moreover, bwa achieves a higher throughput than bowtie in other experiments. therefore, it is important to use the same options to truly understand how the tools behave.

in the remaining experiments, unless otherwise stated, the number of mismatches in the seed and in the whole read are fixed to  <dig> and  <dig>  respectively, while the quality threshold is kept at  <dig>  the minimum and maximum insert sizes allowed are  <dig> and  <dig>  respectively. in addition, the splicing, snps, and gapped alignment options are disabled, unless otherwise stated. for the number of reported hits, tools are only allowed to report one location except for mrsfast that does not have this option and report all of the mapping locations. the default values are used for the remaining options.

mapping options
quality threshold is one of the two main metrics used for mismatch tolerance. the other main metric is the explicit specification of the number of mismatches. to compare fairly between the tools, a relationship between the two metrics should be found, which is the main target of this experiment. in this experiment, wgsim is used to generate the data set instead of using art or a real one. the different base quality scores in real data cause quality threshold based tools to allow more mismatches than the other tools. for instance, when allowing a quality threshold of  <dig> and  <dig> mismatches for the remaining tools, bowtie and maq map reads with up to  <dig> mismatches while the other tools are limited to  <dig> . therefore, maq and bowtie had a mapping percentage larger than the other tools, hence, the comparison is not fair. nevertheless, in the following, we show how the quality threshold can be used to mimic the behavior of the explicit specification of the number of mismatches.

for wgsim generated synthetic data, quality thresholds of  <dig>   <dig>   <dig>   <dig>  and  <dig> should correspond to  <dig>   <dig>   <dig>   <dig>  and  <dig> mismatches. to assess our conclusion, we designed an experiment where all tools were allowed a maximum of  <dig> mismatches while using a quality threshold of  <dig>  figure  <dig> shows that the tools map the reads with the same maximum number of mismatches while having similar mapping rates. however, the differences in the mapping rates are due to the pruning of the search space done by the default options for some of the tools. in addition, other tools incorrectly mapped some of the reads causing an increase in the mapping percentage. for instance,  <dig> % of reported hits for maq and soap <dig> are considered as error  while bowtie’s default options limit the allowed number of backtracks to find mismatches. on the other hand, gsnap and mrsfast map around 92% of the reads even though gsnap reports error hits. this is due to being non-seed based tools, thus allowing more mismatches to be found in the first few base pairs. additionally, mrsfast is a full sensitive mapper, therefore, it can detect reads missed by other tools.

number of mismatches: not only does the number of mismatches affect the percentage of mapped reads, but also affects the throughput. in particular, the mapping percentage increases nonlinearly with the number of mismatches. figure  <dig> shows the effect of the number of mismatches in more details using a wgsim generated data set. there is a 20% increase in the percentage of mapped reads when allowing  <dig> mismatches instead of  <dig>  on the other hand, there is less than  <dig> % increase when allowing  <dig> mismatches instead of  <dig>  in addition, the error percentage decreases for large number of mismatches. for instance, soap2’s error percentage is 21% when allowing  <dig> mismatches while it is reduced to 1% when allowing  <dig> mismatches. additionally, mrsfast mapped around  <dig> - <dig> % more reads than the remaining tools since it is a full sensitive mapper. from the throughput point of view, the tools behave differently. for instance, bowtie, maq, rmap, and mrsfast are able to maintain almost the same throughput while the throughput increases for soap <dig> and gsnap and decreases for bwa. the degradation in bwa’s performance is due to exceeding the default number of mismatches leading to excessive backtracking to find mismatch locations.

additionally, we used a data set of  <dig> million reads of length  <dig> generated by art to evaluate the tools. the results for this experiment are shown in figure  <dig>  similar to the wgsim results, the increase in the percentage of mapped reads when allowing  <dig> mismatches instead of  <dig> is larger than the increase when allowing  <dig> mismatches instead of  <dig>  unlike wgsim results, bowtie maintains a higher throughput than bowtie <dig> for the different number of mismatches. this is due to the difference in the read length between wgism and art data sets . moreover, bowtie uses the quality threshold while bowtie <dig> does not.

to further understand the behavior of the tools, the same set of experiments is applied on the mouse mrna real data set. the results given in figure  <dig> show that the error percentage for gsnap still decreases for large number of mismatches. in addition, there is a small reduction in bwa’s throughput for large number of mismatches. interestingly, the throughput for mrsfast is different between the synthetic data and the real data. in the synthetic data set, mrsfast’s throughput is higher than rmap while maintaining the same throughput across the different number of mismatches. on the other hand, on the real data, the throughput decreases with the increase in the number of mismatches. in addition, there is a 7x reduction in the throughput between  <dig> t-mms and  <dig> t-mms. to maintain a full sensitivity for small read lengths while allowing a large number of mismatches, mrsfast requires the use of a small window size when building the index . the smaller the window size, the longer it takes to process the index. additionally, there is a limit on the window size . therefore, mrsfast starts to lose its sensitivity for detecting mapping locations for  <dig> and  <dig> t-mms.

seed length: theoretically, when fixing the number of allowed mismatches in the seed and in the whole read, changing the seed length affects the mapping results. specifically, a shorter seed allows more mismatches in the remaining part of the read to be found. therefore, the percentage of mapped reads would increase even though the throughput would decrease. on the other hand, having a longer seed would result in pruning some parts of the search tree as soon as possible; leading to throughput improvement. the aim of this experiment is to study this trade off. as shown in the results given in figure  <dig> using a wgism data set, the tools behave as expected. however, there are some exceptions. for instance, when increasing the seed length from  <dig> to  <dig> the percentage of mapped reads for soap <dig> and bowtie decreases, however the throughput is not affected. in addition, there is a  <dig> % increase in the percentage of mapped reads for bowtie when increasing the seed length from  <dig> to  <dig>  this behavior is due to the backtracking property that stops once a certain limit is reached. therefore, as a result of having less erroneous bases in the seed part, bowtie can continue more in the depth first search without exceeding the backtracking limit.

we also carried out the same experiment on the real mouse mrna data set. the results given in figure  <dig> show that the same behavior for bowtie is still obtained on real data. however, bowtie has only  <dig> % increase when increasing the seed length from  <dig> to  <dig> instead of the  <dig> % obtained in synthetic data.

input properties
read length: longer reads tend to have more mismatches beside requiring more time to be fully mapped  <cit> . in general, for a fixed number of mismatches, increasing the read length decreases the percentage of mapped reads. therefore, the aim of this experiment is to understand the read length effect. the results in figure  <dig> show that the mapping percentage decreases with the increase in the read length while the error percentage increases. as an example, 95% of fangs’ output for read length  <dig> is error compared to 12% of its output for read length  <dig>  this is due to the increase of the erroneous bases with the increase of the read length. therefore, it becomes harder to map the reads with the specified mapping criteria. in addition, bowtie, bowtie <dig>  and bwa were the only short sequence mapping tools that managed to map long reads. in particular, the max read length was  <dig> for maq,  <dig> for rmap, and  <dig> for gsnap,  <dig> for mrsfast, while soap <dig> took more than  <dig> hours to map the reads with length  <dig> and hence not reported. on the other hand, mrsfast’s run on read length  <dig> was suddenly terminated. this is probably due to the small read length and the large number of mismatches. from the throughput point of view, tools do not maintain the same behavior. for instance, the throughput of bowtie and soap <dig> decreases for long read lengths. this is due to the backtracking property and the split strategy  <cit>  used by bowtie and soap <dig>  respectively, to find inexact matches. moreover, bowtie is better than bowtie <dig> for read lengths  <dig> and  <dig>  on the other hand, even though the throughput of bwa and gsnap increases with the read length, it starts to decrease for read length  <dig> and  <dig>  respectively. gsnap works by combining position lists to create candidate mapping regions. therefore, for long reads, the throughput decreases due to the increase in the work needed to generate and combine position lists. for mrsfast, the throughput increases with the read length since the available mapping locations for a read are less for longer reads in comparison to small ones.

additionally, we carried out the same experiment on synthetic data sets generated by the art tool. we did not carry out the experiment on a real data set due to the lack of proper real data sets that have different read lengths, have exactly the same coverage, generated by the same sequencer, and extracted from the same tissue. the results for this experiment are shown in figure  <dig>  similar to wgsim results, the error percentage increases with the increase in the read length for gsnap and soap <dig>  interestingly, the percentage of mapped reads for bowtie, maq, and novoalign are not significantly affected with the increase in the read length in comparison to the other tools. this is due to the fact that the longer the read is the smaller the quality score becomes for the bases at the end of the reads  <cit> . therefore, bowtie, maq, and novoalign can map the reads with more mismatches while maintaining the same quality threshold.

paired-end: mapping paired-end reads affects the performance of the tools due to the added constraint of mapping both ends within a maximum insert size. therefore, in this experiment, we want to understand how the performance of the tools is affected while mapping paired-end reads instead of single-end ones. the results in figure  <dig>  show that the throughput decreases for all of the tools while mapping paired-end reads, except for bwa which was able to maintain almost the same throughput while maq had a small increase. even though all of the algorithms work by finding mapping locations for each end alone and then finding the best pair, gsnap was the only tool to face a drop by 90% in the throughput. additionally, the percentage of mapped reads is less when mapping paired-end read due to applying the same mapping criteria for single-end reads on paired-end reads.

even though the maximum insert size was  <dig>  tools such as bwa, soap, and gsnap mapped paired-end reads while exceeding the maximum insert size, except for novoalign that explicitly requires the user to set the standard deviation for the insert size.

genome type: to capture the effect of the genome type, we designed an experiment in which the human, chimpanzee, mouse, zebrafish, lancelet, a. mellifera, and c. elegans genomes were used as reference genomes. the sizes of these genomes are  <dig> gbps,  <dig> gpbs,  <dig> gbps,  <dig> gbps,  <dig> gbps,  <dig> gbps, and  <dig> gbps, respectively. theoretically, for genome indexing based tools, the throughput is expected to slightly increase with the decrease in the genome size. however, the results in figure  <dig> show that some tools do not act as expected. for instance, there is a difference in the throughput between the chimpanzee and the human genomes even though their sizes are similar. in addition, soap2’s and novoalign’s throughput decreases significantly for the zebrafish genome while gsnap did not finish its run on the same genome albeit running for two days. the reason for this behavior is the large repetition rate in the zebrafish genome. for instance, while mapping  <dig> million randomly generated reads from the zebrafish genome, around  <dig> reads were mapped to more than  <dig>  locations in comparison to the lancelet with the maximum number of locations is around  <dig>  for only  <dig> read. additionally, mrsfast detects more than  <dig> billions locations when mapping the zebrafish data set while mapping reads to the zebrafish genome where it detected only  <dig> millions when mapping the lancelet data set. hence, for gsnap, the large repetition rates lead to long genomic position lists; resulting in a significant slow down of gsnap. another interesting result is the ability of most of the tools to map more than 96% of the zebrafish data set compared to around 91% of the human and 89% for the lancelet data sets. the large mapping percentage is also due to the large repetition rate. hence, due to synthetically generating the reads, large number of reads are generated from the repeated regions. as a result, the probability of finding a mapping location increases. in addition to the above results, it is also noticed that bowtie scales better than bowtie <dig> on different genomes. moreover, maq’s throughput for the c. elegans genome is larger than novoalign while maintaining a comparable mapping percentage. therefore, read indexing based tools might perform better than some genome indexing based tools for small genomes albeit being very slow for large genomes.

to further understand the behavior of the tools, we generated a data set of  <dig> million reads using art. figure  <dig> shows the results using the art data sets. similar to wgsim results, soap <dig> and novoalign still encounter a significant decrease in the throughput when mapping the zebrafish data set. additionally, bowtie still scales better than bowtie <dig> with the different genomes. interestingly, gsnap finished its run on the zebrafish data set even though it still faces a decrease in the throughput. on the other hand, unlike wgsim results, mrsfast encounters a decrease in the throughput when mapping the zebrafish data set. it is not obvious why mrsfast encounters such a decrease even though its performance on the other genomes remains the same regardless of using wgsim or art.

in general, the throughput of the tools increases when using art instead of wgsim data sets. however, the relative performance between the tools and the different genomes is still the same.

algorithmic features
gapped alignment should improve the mapping percentage albeit decreasing the throughput. we designed an experiment to understand the effect of gapped alignment. tools were used to map synthetically generated reads of length  <dig> to the human genome while allowing one gap of length  <dig>  however, mrfast does not provide any option to limit the gap size. the results in figure  <dig> show that the mapping percentage increases by 4% for soap <dig> and  <dig> % for mrfast in case of gapped alignment, while there is no change for bwa and gsnap. however, there is a drop of 15% and 75% in the throughput for bwa and gsnap, respectively. the decrease for gsnap is due to the overhead added to the algorithm to find pairs of candidate regions that co-localize within a maximum allowed gap size. the algorithm tries to find a crossover between the two regions without exceeding the maximum number of mismatches leading to a significant decrease in the throughput. interestingly, the decrease in the throughput is less for the real data set as shown in figure  <dig>  however, the decrease is still larger than the decrease in the throughput for the remaining tools.

for the real data set, mrsfast  is not included in the results since the minimum allowed window size in the indexing phase does not guarantee a full sensitivity for mrfast.

scalability
in this experiment, we tested the multithreading behavior. in addition, pmap  <cit>  was used to run multiple instances of each tool on a number of processors on a single node to test the multiprocessing effect. pmap is an open-source mpi-based tool that enables parallelization of existing short sequence mapping tools by partitioning the reads and distributing the work among the different processors. a single node was used in the multiprocessing experiment to understand the effect of a good implementation of multithreading. the results for both experiments are given in figure  <dig>  we can observe from the multithreading results that the tools had almost a linear speedup up to  <dig> threads. however, when increasing to  <dig> threads, bowtie was the only tool to achieve 8x speedup. in addition, bwa had a similar speedup in both multithreading and multiprocessing. for the multiprocessing experiment, fangs achieved almost a 6x speedup while there was a small improvement for maq and rmap. for the remaining tools, most of them were able to maintain more than a 5x speedup for  <dig> processors, however this is less than a linear speedup. one reason for this degradation is the overhead of the distribution and merging steps required by distributed memory systems. as expected, we can notice that multithreading provides almost a linear speedup, however, it is limited by the number of cores.

in general, using multiprocessing provides more degrees of freedom by parallelizing tools that do not support multithreading and by making use of the available computational resources.

another important observation is the effect of the indexing method on the total speedup. read indexing based tools did not have any significant speedup in comparison to the genome indexing based ones which had more than 5x speedup. therefore, genome indexing is more efficient in case of designing a read partitioning parallelism based tool.

accuracy evaluation
the aim of this experiment is to evaluate the percentage of reads each tool actually maps out of the set of the mappable reads. a read is mappable if the distance between the read and its original genomic location does not violate the mapping criteria. in this experiment, the reads were generated using art to measure the sensitivity of the tools in case of varying the distribution of mismatches. the used mapping criterion was fixed to five mismatches for bowtie <dig>  soap, gsnap, bwa, mrsfast, and rmap. for the remaining tools, a quality threshold of  <dig> was used. in general, gapped alignment was disabled. the results given in table  <dig> show that bowtie did not map around  <dig> % of the set of the mappable reads  while bowtie <dig> did not map around  <dig> %. moreover, bowtie mapped 93% of the reads while bowtie <dig> only mapped 85%. nevertheless, the sensitivity of both tools can be increased by changing the default options at the expense of significantly decreasing the throughput. interestingly, bwa, soap <dig>  and mrsfast mapped all of the mappable reads without any error.

evaluating the sensitivity of the tools on a data set of  <dig> million reads of length  <dig> generated by art. the numbers are in percentage. the reported mapped percentage is the total percentage of reads mapped by each tool. it is equal to actual mapped +  while reported correct is the total number of correctly mapped reads.

in general, the tools were able to map a percentage of the unmappable reads, however, it was mapped with a large error percentage. for instance, even though gsnap mapped around 3% of the unmappable reads, only  <dig> % of them were correctly mapped. therefore, even though gsnap maps the largest percentage of reads, other tools such as bwa and novoalign are more accurate and precise than gsnap.

it is important to note that the percentage of reads mapped from the unmappable reads is similar to the percentage of incorrectly mapped reads-relaxed given in ruffalo et al. work  <cit> . however, they define a read to be unmappable if it has a mapping quality less than a certain threshold while we consider it as unmappable if it violates the mapping criteria for the tool.

rabema evaluation
the aim of this experiment is to evaluate the tools based on the number of reads with a specified error rate the tool has been able to map. unlike the previous experiment, this experiment does not take into consideration how each tool works. therefore, it is similar to evaluating the efficiency of the different mapping techniques . the experiment is performed on a synthetic data set of length  <dig> extracted from the human genome using art. the maximum allowed error rate was 5%, i.e.,  <dig> mismatches in that case. the results for this experiment are shown in table  <dig>  rabema takes the output sam file from each tool as the input. however, maq and rmap do not create the output in the sam format. therefore, there are not included. additionally, gsnap results are not included since the output gsnap sam file contains messed up quality scores.

rabema evaluation results on the different tools using a data set of  <dig> million reads of length  <dig> extracted from the human genome using art. the maximum allowed error is 5% . #reads is the number of reads expected to be mapped with certain error. the remaining columns for the tools show the percentage of reads detected by each tool out of the #reads. invalid mappings  for bowtie and novoalign are  <dig>  and  <dig>  reads, respectively.

as shown in the results, both novoalign and bowtie are evaluated as mapping invalid reads. this is because rabema does not take the quality scores into consideration and just calculate the edit distance. therefore, from the mismatches perspective, the reads have more than  <dig> mismatches. however, from the quality threshold perspective, they have a quality threshold less than the specified one. therefore, at the end, they are valid mappings.

in general, bwa has been able to detect almost all of the reads with the correct error rate. this suggest that most of the mismatches exist at the end of the read. in addition, the seeding technique is a valid method specially if it can speed up the mapping process.on the other hand, even though soap <dig> is a seed based tool, similar to bwa, it could not detect as much correct reads as bwa. bowtie <dig> missed some of the reads, however, it can detect them by changing its sensitivity at the cost of increasing the running time. on the other hand, mrsfast mapped all of the reads with the correct error rate since it is a full sensitive mapper.

use case: snp calling
the aim of this experiment is to understand how the different mapping techniques affect the quality of snp calling. the tools were used to map an mrna dataset of  <dig> million reads extracted from the spretus mouse strain. then partek  <cit> , a genomic suite developed to analyze ngs data, is used to detect snps. the mouse genome version mm <dig> was used as the reference genome in this experiment. a quality threshold of  <dig> was used for bowtie and novoalign while the remaining tools were allowed  <dig> mismatches. in addition, gapped alignment was enabled for bowtie <dig>  bwa, gsnap, and novoalign. table  <dig> shows the results for this experiment. the snp detection step was done for gsnap and soap <dig> after filtering out the erroneous reads. the log-odd ratio represents how accurate the snp is. the small log-odds ratio for some of the snps is due to either the small number of reads that supports that snp or the mixed genotype calls. we can observe that there is a large number of accurately detected snps. this is expected due to the high divergence of the spretus strain from other mice strains. for the sake of completeness, we are including the whole number of detected snps, however, in our analysis, we focus only on the number of accurately detected snps shown in the last column. the results show that gsnap detected the largest number of accurate snps while novoalign detected the smallest. in addition, more than 94% of the highly accurate snps detected by novoalign were also detected by the other tools . to further understand the reason for the low number of snps detected by bowtie and novoalign, we carried out the same experiment while using a quality threshold of  <dig>  the number of highly accurate snps increased to  <dig> and  <dig> for bowtie and novoalign, respectively. moreover, the reads with more than  <dig> mismatches did not contribute to the increase in the number of snps. this is due to the fact that snps have a high base quality score. therefore, a read with a snp would be sequenced with a small number of errors.

snp calling results when using the different tools. each row represents a different tool while each column shows the number of snps detected with a log-odds ratio, which is a measure of the accuracy of the detected snp, centered around the given values. the larger the log-odds ratio is, the more accurate the detected snp becomes.

CONCLUSIONS
there have been many studies carried out to analyze the performance of short sequence mapping tools and choose the best tool among them. however, the analysis of short sequence mapping tools is still an active problem with many aspects have not been addressed yet. in this work, we provided a benchmarking study for short sequence mapping tools while tackling different aspects that have not been covered by previous studies. we mainly focused on studying the effect of different input properties, algorithmic features, and changing the default options on the performance of the different tools. additionally, we provided a set of benchmarking tests which extensively analyze the performance of the different tools. each of the benchmarking tests stresses on a different aspect. the benchmarking tests were further applied on a variety of short sequence mapping tools, namely, bowtie, bowtie <dig>  bwa, soap <dig>  maq, rmap, gsnap, novoalign, mrsfast , and fangs.

the experiments show that some tools report an error percentage . among these tools are gsnap and soap <dig>  gsnap reported the highest error percentage in the experiments. additionally, the error increases with the read length and it decreases with the the number of mismatches. nevertheless, gsnap was one of the tools which reports the largest mapping percentage in most of the experiments even after filtering out the error reads. the main reason for mapping more reads is allowing any number of mismatches in the seed part. from a real application perspective, gsnap’s filtered output helped in detecting the largest number of snps.

the evaluation of bowtie, bowtie <dig>  bwa, mrsfast, and novoalign show their ability to correctly map the reads. moreover, novoalign mapped the largest percentage of reads, similar to gsnap, specially for highly repeated genomes. however, it maintained the lowest throughput among the genome indexing tools in most of the experiments.

mrsfast’s throughput is highly affected by the read length and the number of mismatches. our experiments show that it is better to use mrsfast for longer reads. it can also be used for short reads but only with a small number of mismatches.

in general, genome indexing based tools performed better than read indexing tools in all of the experiments. however, maq was faster than novoalign for small genomes. therefore there is a potential for read indexing tools to be used for small genomes. in addition to providing the worst performance, read indexing does not provide any significant speedup in case of using read partitioning based parallelism. therefore, the read indexing method is not preferred when designing a new read partitioning mapping tools.

interestingly, the genome type experiment revealed many strengths and weaknesses for the tools. for instance, the performance of soap <dig>  gsnap, and novoalign is highly dependent on the genome type; the throughput decreased significantly for the zebrafish genome. this is due to the large repetition rate on the zebrafish genome. in addition, the tools behaved differently on the human and the chimpanzee genomes albeit having comparable genome sizes. the results of the genome type experiment suggest that the different properties of the genomes affect the performance of the tools. therefore, further investigations are required to understand the different properties of the genomes and their effect on the different mapping techniques.

even though there are differences between the results for the real data sets and the synthetic ones, both experiments are important as they give us a different perspective when comparing between the tools. the control on the number of mismatches for the wgsim synthetic data allows us to know exactly what the throughput of each tool is while looking for exactly the same number of mismatches. therefore, it becomes easier to understand why a tool is faster than another one or why a tool seems to map more reads than the other ones. at the same time, it is important to look at the behavior of the tools in case of real data and real-like synthetic data  to further understand how they behave in the real world. for instance, for the number of mismatches experiment, even though bowtie looks like it maps a percentage of reads similar to the other tools in case of  <dig> t-mms, it actually maps the reads with a maximum of  <dig> t-mms. therefore, the output mappings are more accurate than the other tools.

in general, there is no the-best tool among all of the tools; each tool was the-best in certain conditions. the short sequence mapping problem is still an active problem and new tools are needed to be developed. however, these new tools should be application-specific. by taking the target application into consideration, more accurate results can be obtained. for instance, for genome assembly, we can analyze the reference genome and estimate the number of reads that can be mapped for the different regions  based on the coverage information in the sequencing process. another example for an application with very specific properties is the mapping of rna-seq data which contain short sequences for the exon regions rather than intron regions for the genome. therefore, for well-studied genomes, if a small number of reads where mapped to different intron regions, we can expect them to be wrongly mapped and look for other mapping locations with more number of mismatches or less mapping quality.

availability
links to tools, datasets, parameters used in each individual tool and test, and the code used to verify the tools are available at http://bmi.osu.edu/hpc/software/benchmark/.

competing interests
the authors declare that there are no competing interests.

authors’ contributions
ah and db designed the experiments, ah carried out experiments, wrote the first draft of the manuscript. aet provided and analyzed snp dataset. uvc led the project, helped with the design and interpretation of the experiments, reviewed and revised the manuscript. all authors read and approved the final manuscript.

