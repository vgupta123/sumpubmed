BACKGROUND
the potential of deoxyribonucleic acid  for use as a storage medium of digital data was realised just over a decade ago  <cit> . many promising applications of this emerging field have been proposed, such as long term data storage  <cit>  and genetic tagging  <cit> . it is likely that, with advancements in dna sequencing and synthesising technologies, information embedding in the genome of living organisms will be routine in the near future. to date several data embedding algorithms have been proposed  <cit> . however, as we will see later, none of them fully comply with some recently highlighted biological restrictions. not adhering to these restrictions can potentially be detrimental to the organism hosting the artificial information-carrying dna. here we propose two novel algorithms jointly called biocode, which, unlike any previous ones, produce information-encoded dna more biologically compatible for the host organism, thus improving the robustness of the encoded message. in addition to operating under strict constraints, never dealt with before, they encode information in near optimal ways. this is to the extent that for one such algorithm the embedding rate  is indistinguishable from the optimal theoretical bound.

interest in using dna for information storage  is growing, not surprisingly, as it is a highly compact and potentially durable medium with the ability to make replicas of information costing little energy. stored information is passed from generation to generation when placed anywhere in the genome of asexual organisms. data encoded in dna is subject to errors caused by random mutations in the organism’s dna, but if encoded correctly it may still be retrievable after millions of generations or more  <cit> . encoding information in sexually reproducing organisms is more complicated due to the effects of genetic crossover. however this issue has been tackled by heider et. al  <cit> , who proposed embedding information in mitochondrial dna . in most sexually reproducing species mtdna is inherited from the mother alone, making it an ideal location for data embedding.

another application of robust dna data embedding algorithms is the genetic tagging of organisms. this would be of interest to individuals researching and working with artificial or genetically modified organisms, allowing them to embed “ownership watermarks”. this was the case in one recent, high profile experiment performed by the j craig venter institute . a watermarked dna sequence, representing the researchers’ initials, was embedded in a chemically synthesized bacterial genome  <cit> . a further proposal is the application of dna data embedding for tagging potentially hazardous viruses  <cit> . unique watermarks could identify different laboratories handling viruses, and thus it would be possible to refute claims that some particular institution is the source of a viral outbreak.

despite the different potential applications of dna data embedding, all embedding algorithms should be designed based on some common principles. many of the prior algorithm proposals have been made by researchers concerned primarily with the biological aspects of embedding an artificial dna sequence, but which paid relatively little attention to the coding aspects of the problem. instead we have designed the biocode algorithms keeping in mind not only more stringent biological constraints, but also principles from digital communications. firstly, the information-carrying dna sequence should not hinder the host organisms’ development . secondly, the embedded data should be retrievable as close as possible to a theoretical threshold , determined by the number of generations a message has been transmitted along and the mutation rate between generations. finally, the algorithms should make economical use of dna in terms of data storage, that is, maximise the embeddable payload for a given sequence length. we will demonstrate these properties through an in silico empirical analysis, in conjunction with theoretical estimates of achievable embedding rate.

there exist two distinct regions within the genomes of living organisms: protein-coding  regions and non-protein coding  regions. in the past, ncdna was thought to have no function, however recent research suggests that up to 80% of ncdna may be responsible for regulatory functions  <cit> . in the remaining 20% of ncdna it is safe to assume that dna can be freely overwritten. indeed several authors have performed successful data embedding experiments in vivo in these regions  <cit> . the ncdna data embedding algorithm we propose here is also designed to operate in this non functional 20% of ncdna.

on the other hand pcdna regions are responsible for the encoding of proteins, which are the basic building blocks of life. it is possible to modify pcdna regions to encode information; however the constraints which an algorithm must operate under are more restrictive. the goal of each of the two biocode algorithms presented here is to optimally embed information within each of the two types of dna regions that we have discussed.

prior art
the dna data embedding field was born a little over a decade ago with the seminal paper by clelland et al.  <cit> , in which the authors proposed and implemented a data embedding scheme. alphanumeric data was embedded using a trivial assignment of base groupings to characters. the synthesised dna in this case was embedded in vitro, but not sub-cloned into an organism’s genome. the work of clelland et al. was built upon by wong et al.  <cit> , in which they performed in vivo embedding of data in bacterial ncdna regions. similar to clelland et al’s encoding scheme, a base to alphanumeric translation table was used. two bacteria were selected for embedding, e. coli and d. radiodurans. the latter has the ability to survive in harsh environments such as those containing high levels of ionizing radiation, implying that the encoded message would also be resilient under such conditions.

the first paper to discuss error correction for information encoded in dna was by smith et al <cit> . since any information embedded in dna is replicated from generation to generation, any difference between encoded information may be resolved by examining copies obtained from different organisms. also, there exists genetic machinery in the cell which maintains dna, providing limited error correction. despite such inherent error correction abilities, the use of error correction methods at the encoding stage is required to reliably retrieve information after many generations of a host organism.

arita and ohashi  <cit>  developed an embedding algorithm which operates in pcdna regions. the algorithm encodes binary data and was successfully tested in vivo. the main pitfall of this method is that it requires that the original dna sequence be available at the decoder end in order to decode the embedded message.

one paper of significance was written by heider and barnekow  <cit> , in which they proposed two versions of a data embedding algorithm, entitled “dna-crypt”. the ncdna version of the dna-crypt algorithm is a trivial mapping of bits to bases. the authors also proposed a pcdna version of their algorithm, and went on to test their proposal in vivo <cit> . it was suggested that hamming code be used in conjunction with dna-crypt to increase robustness under mutations, although note that error correction can actually be applied on any dna data embedding method.

the use of repetition coding as an explicit dna data embedding method was first proposed by yachie et al <cit> . the premise behind their algorithm is that errors may be corrected by embedding redundant copies of information throughout an organism’s genome. the authors performed in vivo embedding of binary data in multiple ncdna regions. also included was an in silico analysis of their method, showing the data recovery rate for a varying mutation rate. this work was expanded upon by haughton and balado  <cit> .

the first paper to discuss performance analysis of data embedding algorithms and propose performance bounds was by balado  <cit> . the achievable rate for both ncdna and pcdna under substitution mutations when codons are uniformly distributed was presented. further bounds were proposed by balado and haughton in  <cit> . these are upper bounds on the possible embedding rate  that an algorithm can attain. therefore we will compare the performance of the biocode methods to these bounds.

for more information on dna watermarking the reader is referred to the recent review by heider and barnekow  <cit> .

notation and framework
in this section we introduce the notation necessary for explaining the biocode algorithms. we also present the framework used and a summary of basic biological facts that will be needed to explain the algorithms. sets will be represented by calligraphic letters, for instance s. the cardinality of a set, or the number of elements it contains, is denoted as |s|. elements of sets are represented by lower case letters, such as v∈s. vectors of elements are represented by bold letters, for instance v= .

inherently, dna is a linear digital storage medium whose building blocks are four nucleotide bases, denoted in set notation by x≜{a,c,t,g}. these bases belong to two chemically distinct groups, purines r≜{a,g} and pyrimidines y≜{t,c}. we will represent a dna strand comprising n bases by a vector x= , with xi∈x. a dinucleotide dna sequence is represented by a two-element vector d= . the dna molecule actually consists of two antiparallel strands, and either of the two strands completely defines the other by means of the so-called watson-crick base pairings a– t and g– c. this fact is of importance for the biocode ncdna method, as we will see later.

the dna data embedding problem may be modelled in terms of the communications channel shown in figure  <dig>  the purpose of dna data embedding is to encode a message m= , with mi∈ℳ≜{ <dig> }, within a host dna strand x. this is achieved using a function f, which represents a dna data embedding algorithm. its output is an encoded dna strand y=f, where k is a secret key. since organisms are subject to mutations, any information encoded in their genomes is equally so. this is reflected by y undergoing a probabilistic “mutations channel”, possibly accumulating errors, to give a mutated dna strand z. at the decoder a function d takes z in order to produce an estimate of the original message, m′=d. the embedding key k is a secret shared by the encoder and decoder to ensure that the encoded information is private. as we will see the embedding key may consist of a permutation of a basic translation table, but it may also include a cryptographic key if desired.

for reasons that will become clear next, dna data embedding algorithms which target protein-coding dna manipulate codons, as opposed to individual bases. a codon is a group of three consecutive bases, which we will denote as x^=∈x <dig>  with a vector of codons being for instance x¯=. genes are simply pcdna regions flanked by certain start and stop markers enclosing consecutive codonsa that can be translated into proteins by the genetic machinery. every codon x^ uniquely translates to an amino acid a=aa, where the aa function translates a codon  to an amino acid . using their standard abbreviations, the set of all possible amino acids is a≜{ala, arg, asn, asp, cys, gln, glu, gly, his, ile, leu, lys, met, phe, pro, ser, thr, trp, tyr, val, stp }. stp is included for notational convenience, although it is not an amino acid but just a “translation stop” command. the sequential concatenation of amino acids in a gene produces a protein. the relationship between codons and amino acids, represented by aa, is given by the near-universal genetic code. this is a redundant relationship since |x3|= <dig> but |a|= <dig>  the set of synonymous codons which translate the same amino acid a∈a is denoted sa. the superset of all codons is given by sa, and each subset sa is composed of the codons which translate the same amino acid, ∀a∈a|sa⊂sa. this redundancy is also behind the different codon bias  exhibited by different organisms. codon biases are characteristic frequencies of the appearance of codons associated with each amino acid. as we will see, this built-in redundancy of the genetic code lies at the foundations of all pcdna algorithms, and therefore both the genetic code and codon bias are fundamental to these techniques.

finally, note that taking into account the three bases in a codon and the two antiparallel strands in a dna molecule, there are six different reading frames in which a dna segment could be translated to proteins. a correct reading frame is determined by the presence of a start codon .

constraints of dna data embedding
it is essential that any data embedding process does not harm the functionality of the host organism, that is to say, the information-carrying dna strand y and the original x should be biologically equivalent. in order to develop reliable data embedding algorithms the constraints which enable robust encoding must be clear. this section outlines important biological constraints which should be placed upon dna modifications. the biocode algorithms described in the following section abide by all of these constraints. 

• ncdna constraint: no start codons — a modified ncdna region  should not be mistaken as a pcdna region by the genetic machinery. this implies that start codonsb should not appear in the modifications. to the best of our knowledge biocode ncdna is the only algorithm strictly observing this constraint, however another method does acknowledge it to some extent. this algorithm was used by the jcvi to encode data in the artificially engineered synthetic bacterium and is disclosed in a patent  <cit> . this method does not completely guarantee that start codons will not be created; instead, it is designed such that the probability of start codons appearing is low. moreover, this low likelihood only applies to one of the six possible reading frames of dna, whereas biocode ncdna enforces the constraint in all six frames.

• in any case it might still happen that a modified region which originally did not contain start codons may acquire them due to mutations accumulated over a number of generations. this is clearly a potentially unavoidable scenario for any method.

• pcdna constraints: primary structure preservation — the primary structure, i.e. protein translation, of a gene may not be altered, in effect meaning that aa=aa. algorithms are restricted to encoding information by replacing codons synonymously . this greatly reduces capacity and increases the complexity of pcdna algorithms over ncdna algorithms. codon bias preservation — the second constraint which must be considered concerns the distribution of codons in organisms, or codon bias. there is a growing body of research pointing towards the codon bias usage of pcdna regions dictating the gene expression levels in both eukaryotic and prokaryotic organisms, in particular, the speed at which genes are translated into proteins  <cit> . therefore it is desirable that the codon bias in a given pcdna region be preserved when such a region is modified to embed data. this constraint may be especially important when encoding information extensively throughout an organism’s genome.

• the empirical distribution of codons in a pcdna region is given by its codon bias, which is just a normalised codon count. hence, in practice preserving a codon bias amounts to preserving a codon count. in other words, the codon bias preservation constraint implies that the histogram of the codons in a pcdna region must remain unchanged after the embedding process.

• it should be noted that if the codon composition for a particular amino acid does not vary, i.e. the same codon translates a single amino acid every time in a pcdna region, then any algorithm operating under this constraint cannot encode information using those codons. in practice we have not observed this extreme case and while codon compositions do not appear with equal frequency, they are sufficiently distributed to achieve high embedding rates.

the codon bias preservation constraint has been acknowledged, to some extent, in a dna embedding algorithm created by liss et al.  <cit> . this algorithm encodes information by first determining the frequency of each codon to be used for embedding. codons are assigned to bit values in such a way as to mirror the bit frequencies of the message with the codon usage frequencies. it is a reasonable assumption to expect the binary message to be embedded, m to be approximately uniformly random as any data will appear so when compressed. under the method by liss et al., if we assume the binary message is uniformly random, and there is high variation in codon usage frequencies for an amino acid, the codon bias would not be preserved.

an even more stringent constraint for pcdna embedding is the preservation of codon pairs. a recent study demonstrated that certain codon pairs were preferred in pcdna regions, while others were avoided  <cit> . we have investigated this constraint when combined with the two constraints above and, for the genes used in this study, have determined that no information can be encoded when strictly enforced. in these genes there were no two amino acid pairs with differing codon compositions, meaning that no codon pairs could be swapped while maintaining the primary structure preservation constraint. therefore this constraint will not be considered here. a further issue with this constraint is the preservation of codon pairs in different reading frames. if codon pairs in all reading frames were to be preserved, the dna sequence could not be modified at all.

method
as we will see, both algorithms proposed in this paper operate under conditions which vary depending upon the message encoding progress, and which take into account the aforementioned constraints on dna modification. both algorithms face the problem of statically or dynamically mapping a given set of available symbols  to message bits, and vice versa. for clarity, this common encoding principle which we call graduated mapping will be introduced next, before the actual biocode algorithms are presented.

graduated mapping
given a set of available symbols s, which in general are bases or codons, it is possible to map all of it’s elements to the elements of a second set of binary strings ℳ. obviously both sets must have identical cardinality, denoted by μ=|s|=|ℳ|. let l≜⌊log2μ⌋ denote the minimum length of any binary string in ℳ.

first, let us consider the simplest case, that is, when l= log2μ. in this case ℳ is composed of μ length-l binary strings, arranged in ascending order from zero to μ− <dig>  the other case to consider is when l< log2μ. in this instance, to achieve a higher embedding rate, some of the binary strings in ℳ must be of length ⌊log2μ⌋+ <dig> bits. the first 2l values from s are assigned l-length binary strings, in ascending order from  <dig> to 2l− <dig>  the remaining values from the range 2l+ <dig> to μ are first duplicated with the l-length binary strings corresponding to the range 2l+1−μ+ <dig> to 2l. the strings in the former range are concatenated with a “1”, while the strings in the latter are concatenated with a “0”.

dynamic graduated mapping
we will see that a special situation is the requirement that each of the elements from s be used a specific amount of times due to biological constraints. if an element s∈s has been used as many times as permitted, then it will be removed from s, decreasing μ by one unit. every such removal prompts a remapping of s⇔ℳ in a graduated fashion, whereby ℳ is completely recreated using the new value of μ and the mapping method just described in the paragraph above.

as an example of the method, suppose that s={a,b,c,d,e}, then it would have the following mapping s⇔ℳ={ <dig> , <dig> ,111}. now, if during execution of the algorithm the element d is used as many times as permitted, s becomes s∖d and the set ℳ is remapped as ℳ={ <dig> , <dig> }.

as we will see in the following section, the two biocode algorithms exploit the basic concept of graduated mapping in their own unique ways. notice that the actual permutations used in the mappings may be kept as a secret shared by encoder and decoder, thus implementing the aforementioned secret key that precludes decoding by unauthorised third parties.

biocode ncdna
in this section we introduce biocode ncdna —a method to optimally embed information within ncdna while observing the no start codons constraint. firstly, observe that as |x|= <dig> it is possible to encode information by trivially assigning a two bit sequence to each base. this is the foundation of the ncdna embedding algorithm dna-crypt by heider and barnekow  <cit> , among others. however such a static mapping of bits to dna symbols does not take into account the no start codons constraint discussed in the previous section. using such a mapping it is possible that some particular messages will produce start codons in the information-carrying strand. one might think that simply avoiding messages which translate into start codons would bypass this problem. however, this is far from being a solution because there are three possible reading frames where the genetic machinery might find a start codon, plus three additional reading frames in the antiparallel complementary strand.

in order to address this issue biocode ncdna uses a variable symbol mapping that we describe next. for generality it is assumed that the host dna belongs to a eukaryotic organism, for which the start codons are “atg”, “ctg” and “ttg”, with the complementary codons on the opposite strand being “cat”,“cag” and “caa”. taking the first two bases of these triplets, the following set of special duplets is defined: 

 d≜{at, ct, tt, ca} 

these duplets indicate that the next encoded symbol in a dna sequence is a special case since a start codon may be produced if the wrong symbol is encoded. such a situation is avoided by constantly examining the trailing dinucleotide sequence, d=, where i represents the position of encoding within the information-carrying dna sequence y. if the concatenation of the previous two bases d with the current base yi has the potential to create a start codon , then the algorithm restricts the choice of yi to a subset of bases sd such that no start codon can be produced. otherwise yi can be freely chosen from x. in order to reflect these conditions, a graduated mapping from the subset sd to message bits is used to encode the symbol yi. note that the graduated mapping is different for different values of d, but static for any given d.

a schematic of the algorithm is shown in figure  <dig>  the encoded dna sequence y is constructed by reading the binary message m and at each point examining the previously encoded dinucleotide d. a lookup of table  <dig> is performed using d and the next bit to be encoded m, from the message vector m. the base y∈sd is selected for encoding using m∈ℳd. this mapping is performed by locating m in the set ℳd and choosing the base y from sd at the corresponding position.

given the dinucleotide sequence d the next message base to be encoded is one belonging to the set sd. each bit message found in ℳd corresponds to a base in sd.

biocode ncdna guarantees that no start codon can be created in all reading frames in both sense and anti-sense directions. the algorithm can be easily modified in such a way as to prevent any other codon of choice from appearing. decoding an embedded message is simply the reverse process of encoding, with one additional improvement. since it is not possible for start codons to appear intentionally, if they do arise due to mutations it is possible to detect the corresponding message errors —and even in some cases to correct them.

binary codon equivalency
before introducing biocode pcdna –a method to near optimally embed information within pcdna while observing the primary structure preservation and codon count preservation constraints— we will briefly describe a pcdna data embedding algorithm previously proposed by us, called binary codon equivalency   <cit> . bce can be seen as a particular instance of biocode pcdna when only the primary structure preservation constraint is obeyed —but not the codon count preservation constraint. central to bce is a lookup table containing graduated mappings of codons to bit strings. table  <dig> explicitly shows this mapping, with part  showing the genetic code and part  giving the translated bit sequences. it should be noted that this mapping has been refined since bce was originally disclosed in  <cit> , in order to achieve a higher embedding rate.

 codon to amino acid translation table . underlined are codons which double as start codons.  available binary strings for message encoding. there is a one to one mapping of each binary string in ℳa to a codon in sa, given by the table entries in the same positions.

bce executes as follows: it initiates by translating the sequence of codons, x¯= into its corresponding amino acid sequence a=aa= . the encoded sequence, y¯ is then constructed by traversing a and choosing for each index i a message-dependent codon y^i such that aa=ai. a lookup of table  <dig> is performed to find the bit sequence matching the current message bit m in ℳai. the codon y^i∈sai is selected corresponding to the position of that match.

biocode pcdna
the biocode pcdna algorithm preserves in y¯ not only the primary structure of the original host sequence x¯ —as bce does already— but also its codon count. these two objectives are simultaneously achieved by means of a dynamic adaptation of the strategy followed by bce. we have just seen that in bce the cardinality of the codon set sai corresponding to each amino acid ai is constant for all i= <dig> ,⋯,n, which allows the use of a static lookup table throughout the embedding process. however the additional constraint observed by biocode pcdna requires the cardinality of sa to be varied during the embedding process.

the following is a step by step procedure of the algorithms’ operation made with reference to figure  <dig>  

• amino acid translation — as in bce, the vector of codons, x¯ is converted into a vector of amino acids; a=aa.

• initialize encoding tables — next, for every amino acid, all possible codon types in x¯ which translate that amino acid must be found. given sc is the set of k codons which translate a single amino acid, sc will only contain the codon types which appear in x¯. if all k possible codon compositions are found in x¯, then sc will contain all k codons. for example, given the amino acid glycine we have the corresponding set sg. four codons translate this amino acid which would normally yield sg≜{gga, ggc, ggg, ggt}. however if the codon ggt does not appear in x¯ and all other codons do, then the set will consists of sg≜{gga, ggc, ggg,}. this process of inserting all the codon types into their component amino acid sets continues until all the unique codons in x¯ have been classified. for each amino acid set, a set identical in size is created to contain the corresponding bit mappings. given sc, a corresponding set ℳc is populated using the cardinality μ=|c| and the graduated method described in the previous section. there is then a mapping of sc↦ℳc. sc is contained within a superset of codon sets, sc∈sa. if the full set of  <dig> codons are identified in the pcdna region then the entire amino acid set sa and corresponding bit mappings ℳa would be identical to tables  <dig> and . once sa and ℳa have been initialized for each amino acid, they may be queried to determine the available codons and possible bit sequences that can be encoded. continuing the example above for g≜{gga, ggc, ggg}, the possible bit mappings for g would be ℳg≜{ <dig> ,11}.

• a codon count vector c is then created, which contains the number of times that each codon appears in a pcdna region. this, along with sa and ℳa will be modified as the algorithm progresses.

• table lookup — construction of y¯ begins by examining the first amino acid a <dig> and the first  <dig> bits in the message sequence, . if amino acid a <dig> is represented by the codon set sa <dig> , then the available bit sequences are given by ℳa <dig>  the bit sequence matching the current input is searched for in ℳa <dig>  if {m <dig> m <dig> m3}∉ℳa <dig>  then {m <dig> m2} is located, if {m <dig> m2}∉ℳa <dig> then {m1} is located. the position at which the matching bit sequence is located corresponds to the codon to be selected for embedding from sa <dig>  that is to say, if the k-th element in ℳa <dig> is identical to the current input, then the k-th codon of the same amino acid from sa <dig> is used for encoding.

• decrease codon count — once the codon y^ has been used for encoding, the count for that codon in c is decremented by one.

• adjust tables — if the count for codon y^ reaches zero, then codon y^ is removed from sa. in other words, if a codon has been used as many times as it appeared in the original sequence then that codon can no longer be used for embedding because the budget for that codon has been exhausted. the removal of y^ from sa also prompts a remapping of saa↦ℳaa in a graduated fashion.

• end — the algorithm loops back to the table lookup step, continuing its iteration through a to produce y¯, until the end of m or x¯ has been reached.

decoding is the reverse procedure of embedding. instead of performing a lookup using the message vector, a lookup is performed using codons to retrieve the message vector. all of the tables created for encoding must also be created at the decoder and are modified during execution in the same way. an example of biocode pcdna encoding with step by step procedure is demonstrated in an additional file  <dig>  this includes codon and amino acid statics for x¯ and y¯.

information embedding rate of the biocode algorithms
in this section we analyse the information embedding rate of the biocode algorithms in message bits/base or message bits/codon. in order to do so we will first discuss the embedding rate of the graduated mapping method, which assigns symbols  to bits in both biocode methods. for simplicity we will assume that the message bits are uniformly distributed at random.

the graduated mapping method can achieve a near-optimal rate in terms of bits/symbol . its minimum embedding rate r↓ for a given codebook size μ is: 

  r↓=log2μbits/symbol 

the maximum embedding rate is simply r↑=r↓+ <dig>  therefore the average embedding rate is 

  r=r↓×2r↑−μ2r↓+r↑×2μ2r↑−1bits/symbol 

the equation above may be explained as the weighted average of the lower embedding rate, r↓, and the higher embedding rate, r↑, using as weights the probabilities of those rates being implemented by the encoder. the optimal achievable rate, independent of any method, is given by r= log2μ. there exists one method which attains this rate, called arithmetic encoding  <cit> . however arithmetic encoding presents error propagation issues at the decoder, which make it impossible to implement error correction effectively.

biocode ncdna
there are five states that the biocode ncdna encoder may be in, each of which is given by the trailing dinucleotide. these five states are “at”, “ct”, “tt”, “ca”  and x2∖d. in order to compute the average embedding rate of biocode ncdna we will obtain the steady state probability of the encoder being in each of the different states. the dynamic behaviour of this finite state machine may be modelled by means of the markov chain shown in figure  <dig>  the state transition probabilities associated with this markov chain, which are also given in the figure, can be obtained by examining the probabilities of using bit sequences given by table  <dig>  these transition probabilities can be used in turn to define the 5× <dig> transition probability matrix t≜, with scurrent,snext∈d∪. we wish now to obtain the steady state matrix t∞=limk→∞tk. in order to do this we first compute the diagonal matrix d containing the eigenvalues of t, and a matrix p whose columns contain the corresponding eigenvectors, such that t=p×d×p− <dig>  with this decomposition we can write t∞=limk→∞p×dk×p− <dig>  as k→∞, dk becomes an all-zero matrix, except for the top leftmost element becoming the unity. we can then take the any row vector of t∞ as steady state probability vector. the formula to compute the rate of biocode ncdna is given below, where r is the rate function given by equation . the row elements of t are the marginal probabilities that the previous two bases are the dinucleotide corresponding to that row. these probabilities correspond to the pr part of the formula below. 

  rncdna=∑d∈d∪prr= <dig> bits/base 

this embedding rate is not overly lower than the unconstrained rate of embedding of  <dig> bits/base. however this rate may only be attained when the message is long.

biocode pcdna
the embedding rate of biocode pcdna is more difficult to analyse due to the dynamic nature of the graduate mapping it relies upon. however it was shown in  <cit>  that when the codon distribution is uniform and the host sequence is long the rate of the optimum dna data embedding with codon bias preservation can be approximated by the rate of optimum dna data embedding without this constraint. therefore we will settle for approximating the biocode pcdna embedding rate by the bce rate, assuming that the conditions above hold. the embedding rate of bce is given by the equation below: 

  rbce=∑a∈a|sa|64×r= <dig> bits/codon, 

where we have used expression . in order to see that this rate is near-optimum, observe that the maximum rate —independent of any method— may be calculated using the same formula above by replacing r with log2|sa|. this gives a rate of  <dig>  bits/codon, which is only 3% higher than the bce rate.

mutation channel model
in the following we will discuss the mutations model used to evaluate the performance of the biocode methods. it must be emphasised that most previous authors proposing dna data embedding did not provide decoding performance analyses of their algorithms, either by means of analyses or by means of in silico monte carlo simulations. an exception would be the work of yachie et al. however such analyses are fundamental for understanding the expected performance of dna data embedding methods when used in in vivo environments.

performance analyses are important because the information embedded in the genome of an organism may contain errors caused by mutations accumulated after successive generations of the organism. that is, as shown in figure  <dig>  due to the effect of a “mutations channel” the information-carrying dna sequence  may be transformed into a “noisy” version of it  before reaching the decoding stage. these errors may impair or degrade the decoding of the embedded information, and hence it is fundamental to analyse the algorithms’ performance under mutations.

following the communications simile, the mutations channel causing the errors can be characterised using a probabilistic model. the model used in our analysis will only consider base substitution mutations, which are the most prevalent mutations in the dna of bacteria. in particular such mutations are the overwhelming majority in pcdna regions  <cit> . these mutations randomly replace one base with an alternate base at different loci of a genome, and therefore can be modelled by means of a 4× <dig> transition probability matrix Π≜, where z,y∈x. as a simplification we will also consider that base substitution mutations happen independently at different loci. in reality it may happen that dependent mutations occur, for instance affecting a number of consecutive bases. however such dependencies can be easily broken by any information embedding method by means of a pseudo-random interleaver shared by encoder and decoder.

the simplest —and one of the most commonly used— models of base substitution mutation is the jukes-cantor model of molecular evolution, which assumes that pr=q/ <dig> for z≠y and pr=1−q. therefore q=pr is the base substitution mutation rate. however the mutation model used in our in silico analysis is the more realistic kimura model of  <cit> , whose transition probability matrix is 

  Π=actg1−qγ3qγ3qqγ3q1−qqγ3qγ3qq1−qγ3qqγ3qγ3q1−qgactg 

this model can reflect the higher probability of base transitions  over base transversions  by setting γ< <dig>  the γ parameter is a function of the ratio of transitions to transversions ε, and it is obtained from it as γ=3/). this model becomes the less realistic jukes-cantor model when γ= <dig>  for a more in-depth explanation the reader is directed to  <cit> .

since mutation events occur from parent to child it is natural to model the mutation channel for the number of generations p elapsed between y and z. assuming that Π gives the transition probability matrix for one generation, the model for p generations is easily found as Πp. we denote this straightforward extension as a “cascaded mutations model”.

at most, a mutation model can have nine parameters if it the property of time reversibility is to hold. the kimura model is used in place of models with greater numbers of parameters because of the statistical problem of overfitting. if a mutation model has several parameters, some of which cannot be accurately estimated, the results obtained after many generations will be distorted. reliable estimates of q and γ are available and therefore Πp can be accurately approximated. the kimura model has been proven accurate in predicting the capacity of a dna sequence when compared with a  <dig> parameter model  <cit> .

message bitframe resynchronisation
while performance will only be evaluated under the base substitution mutation channel just described, base errors may also occasionally confuse the decoder into inserting or removing message bits. if this happens the message bitframe common to encoder and decoder can become desynchronised, that is, the same index in m and m′ may no longer refer to the same message bit. we must stress that this issue not confined to biocode, but common to all existing pcdna data embedding algorithms. therefore, the message bitframe must be resynchronised at the decoder, as otherwise the situation above may occasionally lead to a high message bit error.

we will employ two resynchronisation methods in order to deal with bitframe desynchronisation errors: marker codes and watermark codes. these strategies could actually be applied to resynchronise after insertion and deletion mutations on the level of dna, which are not considered in this paper. since they are applied on the bit level, not quaternary, the methods would lack channel information and as such can not decode optimally. incorporating these methods fully for the dna case is no trivial task because the embedding rate per base is not constant when operating under the restriction highlighted in this paper.

marker codes
marker codes were originally proposed by sellers  <cit>  in  <dig>  however they were not referred to as marker codes until much later  <cit> . these codes place a pilot signal at regular intervals in the binary message. the decoder expects the pilot signal to be located at specific points and if not found corrective action is taken. suppose the pilot signal “001” is received by the decoder as “010”, it would infer that a deletion has occurred in the block preceding the pilot. the decoder resynchronises the remainder of the message by inserting a bit in the middle of the erroneous block. marker codes, in the original proposal, are capable of correcting one desynchronisation error per block. they are not, however, designed to correct the block in which the error occurred.

watermark codes
watermark codes are a recently proposed resynchronisation method by davey and mackay that have been shown to achieve a high encoding rate  <cit> . despite their name, they are not related to dna watermarking, but may be applied here to correct bit insertions and deletions. the application a watermark code is as follows: firstly a “watermark” vector w is created which, for the purpose of our simulations was a uniformly random binary vector agreed upon by the encoder and decoder. the sparse function inserts zeros evenly throughout the input binary vector with the position of insertions known to both encoder and decoder. the message vector, m is sparsified and added modulo  <dig> to the watermarked vector, m~=sparse+w, which is then embedded in a dna sequence.

the next step differs in our implementation over davey and mackay’s. under their method, after being transmitted across a channel, the received vector m~′ is processed by the forward backward algorithm to correct insertions and deletions  <cit> . however under our method, after the dna sequence has been decoded, possibly accumulating errors, the watermark decoder processes m~′ by aligning it with w. this is done in a similar manner to the alignment process of the needleman-wunsch algorithm, however here the edit distance is used. one important factor must be incorporated into the alignment scoring; it is impossible for desynchronisation errors to occur in w. differences between m~′ and w, other than desynchronisation errors, are a result of encoding or mutations, which the decoder is unable to distinguish between. therefore, when resolving differences caused by flips between m~′ and w, the values in m~′ are stored as the alignment.

the forward backward algorithm allows for the computation of probabilities which may then be passed to a substitution error correction decoder. the method we employ here does not incorporate the channel transition probabilities in the realignment process and because of this, is not as accurate as the davey and mackay’s algorithm. however, our method is greatly simplified and less computationally complex.

RESULTS
in this section we describe the performance measures used to evaluate the biocode algorithms. these evaluations are performed by means of monte carlo simulations, which implement the cascaded kimura model as the mutations channel.

performance measures
first of all we must establish relevant and objective criterion for evaluation. a very important figure of merit is the “raw” probability of bit error at the decoder , which is the probability that a bit will be incorrectly decoded after transmission across the mutations channel. by “raw” we mean without error correction coding : observe that ecc can be applied to any dna data embedding method in order to enhance performance, but it is the baseline raw probability of bit error that determines the effectiveness of such additional strategies.

when evaluating pb the hamming distance is used as a metric for measuring the distance between two binary strings. the hamming distance is the number of different same index symbols between two vectors, and it can be written using the kronecker’s delta function δ as dh=∑i=0l−1δ, where l is the message length in bits. using this distance the average probability of bit error at the decoder is just 

  pbh=1ldh=1l∑i=0l−1δ. 

if no bitframe resynchronisation is applied, it can happen that pbh is disproportionately high, even though only a few bits might have been inserted or deleted by the mutations channel.

we will also evaluate the potential performance of the biocode algorithms when using optimal error correction coding. this will be done so by means of the mutual information between the message at the encoder  and at the decoder . the mutual information is an information-theoretical measure which indicates the maximum amount of information that a communications system can send through a channel. since the mutual information must always be below the shannon capacity of the channel, we will be able to compare our results with the theoretical capacity limits for dna data embedding computed in previous works  <cit> . in our simulations the mutual information was empirically obtained by comparing one bit of the original message, m, with its estimate after decoding, m′, as follows: 

  i=∑m′∈ℳ∑m∈ℳprlog2prprpr, 

where pr are empirical estimates of these probabilities computed from the monte carlo experiments. we note that i must be scaled from bits/bit to bits/base  or bits/codon .

monte carlo simulations
the parameters used in the cascaded kimura model are q=10− <dig> and γ= <dig> , which are values used in prior work  <cit>  and are based on realistic estimates obtained in  <cit> . the results for biocode ncdna were obtained using messages of length  <dig>  bits. for biocode pcdna the message length varied depending on codon composition and host sequence length. all the graphs compare either the mutual information or probability of bit error  against the number of generations an encoded sequence has been transmitted along.

the biocode ncdna pbh graph shown in figure  <dig>  clearly demonstrates that information can be correctly retrieved up to  <dig> generations of a host organism under the cascaded kimura model. also shown in the graph is biocode ncdna’s performance when the message is first encoded with a watermark code. this yields a significant improvement, allowing for errorless information retrieval up to  <dig> generations. marker codes, in this case, did not decrease pbh. if desynchronisation errors are rare and bit flips common, a marker code may itself cause desynchronisation errors due to the misinterpretation of error types. also, marker codes cannot correct the block in which the desynchronisation error occurred, only resynchronise the remainder of the message. thus if blocks are large relative to the entire message length, pbh may be high.

with error correction against bit flips the pbh, for biocode with a watermark code, could be further reduced for generations beyond  <dig>  at the expense of decreasing the embedding rate. similarly the mutual information plot shows that  <dig>  bits/base may be retrieved up to just beyond  <dig>  generations. figure  <dig> compares the mutual information of biocode ncdna against an optimal bound computed using the blahut-arimoto algorithm , and shows that the algorithm is optimal up to  <dig> generations.

for the empirical analysis of biocode pcdna three different pcdna regions were selected for embedding, two of which were used in prior works. the “ftsz” region c in the b. subtilis genome was used for in vivo data embedding with arita and ohashi’s algorithm  <cit> . the “ypt7” region d, from a species of yeast known as s. cerevisiae, was used for in silico data embedding with the dna-crypt algorithm  <cit> . the other region used, “psd1_197” is a plasmid gene of a bacteria belonging to the shigella genus e, selected for its differing codon composition and larger sequence length.

the pbh analyses of biocode pcdna on the three genes mentioned above, shown in figure  <dig>  clearly shows errorless data retrieval up to  <dig> generations. however, the embedding rate varied significantly, as shown by figure  <dig>  with the rate of the“ypt7” gene  being considerably lower than the other two . an interesting phenomenon of biocode is responsible for this difference, namely that as sequence length increases so to does embedding rate. the “ypt7” gene is only  <dig> bases long, while the “ftsz” and “psd1_ <dig> ” genes are  <dig> bases and  <dig> bases long respectively. in effect, it is more efficient at data storage for greater sequence lengths due to a greater number of possible combinations of codons and positions to choose from.

a theoretical method for computing the optimal embedding rate when observing the primary structure preservation and codon count preservation constraints is described in  <cit> . this bound can be determined by means of a combinatorial analysis of the maximum number of ways codons in a gene may be rearranged while keeping the constraints. figure  <dig> compares this optimal bound with biocode pcdna using the “ftsz” gene.

the remainder of the plots were obtained using the “ftsz” gene for encoding. figure  <dig> shows that when marker and watermark codes are used in conjunction with biocode pcdna they pose a considerable improvement. this is true despite not being capable of correcting flips in the message, which would account for the overwhelming majority of mutations. from this plot it is apparent that the watermark code reduces the pbh more so than marker codes.

it is important to note the gradient of the plots, as they demonstrate that errors incurred from mutations are isolated and do not propagate. if this were not the case the pbh would be greater between  <dig> and  <dig>  figure  <dig> compares the mutual information of the two error correction methods with no code. it clearly shows that the marker code outperforms the watermark code in terms of embedding rate. a more informative view highlighting this improvement is shown in figure  <dig> 

finally, the last set of graphs compare bce with algorithms proposed by other authors. notice that the constraints under which the biocode algorithms operate have never fully been incorporated into any previous embedding method. therefore direct comparisons with other methods are not appropriate . however bce, which may be seen as a particular instance of biocode pcdna, can actually be compared to other pcdna data embedding algorithms. heider and barnekow’s dna-crypt  <cit>  and arita and ohashi’s method  <cit>  are compared to bce. these methods only maintain the primary structure preservation constraint.

bce and dna-crypt perform near identically in terms of pbh , however there is a major gain in embedding rate when using bce, as shown in figure  <dig>  both bce and dna-crypt do not require any side information at the decoder, however arita and ohashi’s algorithm requires the original dna sequence to decode. such knowledge, which is unrealistic in practice, increases the robustness when insertions and deletions are possible. also, since the embedding rate is constant for codons which have at least one other synonymous codon, the effects of de-synchronisation errors are limited, as can be seen by the shape of the mutual information curve in figure  <dig>  notice the similarity in shape shown to that of figure  <dig> for marker and watermark codes.

CONCLUSIONS
in this paper we have introduced the biocode algorithms for embedding information in dna. these novel methods are designed to be more biologically compatible than any previous dna data embedding algorithms, fully adhering to strict constraints. furthermore they lay the foundation for information storage in dna in a way that is both efficient and robust, as we have shown by means of in silico monte carlo simulations. the biocode pcdna algorithm preserves codon statics making it difficult to infer that information has been embedded. this aspect, in addition to biocode pcdna’s near-optimum embedding rate, implies that biocode pcdna is a near-optimum first-order steganographic method. while dna data embedding is currently in its infancy, it is likely that this field will grow considerably as technologies for synthesising and sequencing dna become cheaper and faster. therefore efficient data embedding techniques such as the biocode algorithms can potentially find widespread applicability.

endnotes
apossibly interspersed with noncoding regions  in eukaryotic cells.bcodons which mark the start of a gene in pcdna.cde

competing interests
a patent has been filed for the biocode algorithms in ireland.both authors declare no other competing interests.

authors’ contributions
dh biocode algorithms conception, development and theoretical analysis, software development and simulations, tables and figures preparation, manuscript preparation . fb theoretical limits, manuscript preparation , coordination, research funds collection. both authors read and approved the final manuscript.

supplementary material
additional file 1
this file contains an example of biocode pcdna encoding a message into a dna sequence.

click here for file

 acknowledgements
this publication has emanated from research conducted with the financial support of science foundation ireland under grant number: 09/rfp/cms <dig> 
