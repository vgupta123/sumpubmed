BACKGROUND
the de novo sequence assembly problem is to reconstruct a target sequence from a set of sequence reads. the classical approach to de novo assembly consists of three phases: overlap, layout and consensus. during the overlap phase, suffix-prefix matches among all pairs of sequence reads are computed, and turned into an overlap graph  <cit> . in the layout phase the location of the reads with respect to each other is determined. in the consensus phase the target sequence is reconstructed, by selecting a base for each position.

the introduction of the massively parallel next-generation dna sequencing technologies has led to a considerable increase in the amount of data typically generated by sequencing experiments. for example, as of january  <dig>  the hiseq <dig> sequencer of illumina delivers sets of  <dig> bp reads with a total length of up to  <dig> gbp  <cit> . sequence analysis software tools developed only a few years ago are often unable to deal with such large amounts of short reads: this has led to a gap between the ability to produce sequence data and the capability to assemble and analyze them  <cit> .

the computation of the overlap graph is the most time and space consuming of the three phases, and was considered a bottleneck in the computation. therefore, alternative methods were developed avoiding an explicit overlap computation. an approach which proved to be effective is based on the enumeration of all k-mers of the reads and their representation in a de bruijn graph, as first proposed by  <cit> . this concept is applied in several popular short reads assemblers such as velvet  <cit> , euler-sr  <cit>  and abyss  <cit> .

the de bruijn graph describing the k-mer spectrum of the read set has interesting properties for the solution of the assembly problem, such as the collapsing of different instances of sequence repeats into common paths of the graph. however, reducing short reads into even shorter units compromises the ability of disambiguation of short repeats. myers  <cit>  presented an alternative framework, the assembly string graph. like in the de bruijn graph, repeats still collapse into common graph elements. there are two main advantages of the string graph, compared to the de bruijn graph: at first, it does not require to split the reads into k-mers. secondly, a string graph always retains read coherence, i.e. each path in the string graph represents a valid assembly of the reads.

edena  <cit>  was the first available implementation of a string graph-based assembler. it computes suffix-prefix matches using a suffix array  <cit>  representing all suffixes of the reads. from these, the complete overlap graph is constructed before transitive edges are removed using an algorithm described in  <cit> .

a more space-efficient approach to the string graph construction has been presented in  <cit>  and was implemented in the open source string graph assembler   <cit> . sga computes suffix-prefix matches using an algorithm based on the burrows and wheeler transform , allowing to classify suffix-prefix matches as transitive or irreducible, so that the string graph can directly be constructed.

recently, a compact representation for exact-match overlap graphs has been described in  <cit> , together with a fast construction algorithm, which has been implemented in the string graph-based assembler leap.

in this paper, we present new efficient algorithms for the computation of irreducible suffix-prefix matches and the construction of the assembly string graph. these are implemented in a new string graph based sequence assembler readjoiner. to validate our approach, we compared readjoiner with the current implementations of edena, leap and sga. readjoiner proved to be considerably faster than previous competitors, or uses less memory. in fact, readjoiner is able to handle very large datasets using limited resources: for example, a short reads dataset consisting of  <dig> gbp could be assembled on a single core in  <dig> hours using  <dig> gb ram.

all string graph-based assemblers aim at constructing the same graph: however, the algorithms and data structures employed in edena, leap, sga and readjoiner differ considerably. leap employs a compact representation of the overlap graph, while readjoiner circumvents the construction of the full overlap graph. both edena and sga are based on explicit index structures  representing all suffixes of all reads in the read set, while readjoiner enumerates and sorts only a proper subset of the suffixes of the reads, and efficiently inserts them into buckets, which can be processed independently from each other.

methods
basic definitions
let w be a string of length n of symbols over an alphabet Σ. w denotes the ith symbol of w and w the substring of w from position i to j, 1 ≤ i, j ≤ n. w is the prefix of w ending at position i and w is the suffix of w starting at position j. a substring of w is proper if it is different from w. a substring of w is internal if it is neither a prefix nor a suffix of w.

a read r is a string over the alphabet {a, c, g, t} which is assumed to be sorted by the alphabetical order < such that a < c < g < t. ⊴ denotes the lexicographic order of all substrings of the reads induced by the alphabetical order < . let n be the length of r. the reverse complement of r, denoted by r―, is the sequence r―…r <cit> ―, where a― indicates the watson-crick complement of base a.

computing suffix- and prefix-free read sets
the first step of our approach for assembling a collection of reads is to eliminate reads that are prefixes or suffixes of other reads. here we describe a method to recognize these reads. consider an ordered set r= of reads, possibly of variable length, in which some reads may occur more than once . we assume that, for all i, 1 ≤ i ≤ m, the ith read ri in r is virtually padded by a sentinel symbol $i at the right end and that the alphabetical order < is extended such that a < c < g < t < $1 < $2 < · · · < $m.

we define a binary relation ≺ on r such that ri ≺ rj if and only if i < j. that is, ≺ reflects the order of the reads in the input. r is prefix-free if for all reads r in r there is no r′ in r∖{r} such that r is a prefix of r′. r is suffix-free if for all r in r there is no read r′ in r∖{r} such that r is a suffix of r′.

to obtain a prefix- and suffix-free set of reads we lexicographically sort all reads using a modified radixsort for strings, as described in  <cit> . in this algorithm, the strings to be sorted are first inserted into buckets according to their first character. each bucket is then sorted recursively according to the next character of all reads in the bucket. a bucket always consists of reads which have a common prefix. once a bucket is smaller than some constant, the remaining suffixes of the reads in the bucket are sorted by insertion sort  <cit> .

during the sorting process, the length of the longest common prefix  of two lexicographically consecutive reads is calculated as a byproduct. for two lexicographically consecutive reads r and r′ with an lcp of length ℓ = |r|, we can conclude that r is a prefix of r′. if ℓ < |r′|, then r is a proper prefix of r′ and we mark r. if ℓ = |r′|, then r and r′ are identical and we mark the read which is larger according to the binary relation ≺ .

to handle reverse complements and to mark reads which are suffixes of other reads, one simply applies this method to the multiset r―= where rm+i=ri¯ for all i, 1 ≤ i ≤ m. as r― includes the reverse complements of the reads, the method also marks reads which are suffixes of other reads. this is due to the observation that if read r is a suffix of read r′, then r― is a prefix of r′―.

in a final step of the algorithm one eliminates all reads from r which have been marked. the remaining unmarked reads from r are processed further. the algorithm to compute a suffix- and prefix-free set of reads runs in o time, where λmax is the maximum length of a read and ω is the machine’s word size. as we consider λmax to be a constant , the algorithm runs in o time.

computing suffix-prefix matches
suppose that r is a suffix- and prefix-free set of m reads. let ℓmin >  <dig> be the minimum length parameter. the set spm of suffix-prefix matches  is the smallest set of triples 〈r, r′, ℓ〉 such that r,r′∈r and strings u, v, w exist such that r = uv, r′ = vw, and |v| =ℓ ≥ ℓmin. ℓ is the length of a suffix-prefix match 〈r, r′, ℓ〉 . the suffix-prefix matching problem is to find all suffix-prefix matches. as the reads of length smaller than ℓmin cannot, by definition, contribute any spm, we can ignore them and thus we assume that r only contains reads of length at least ℓmin.

the method to solve the suffix-prefix matching problem presented here consists of two main algorithms. the first algorithm identifies and lexicographically sorts all spm-relevant suffixes, i.e. a subset of all suffixes of all reads from which one can compute all suffix-prefix matches. the second algorithm enumerates these matches given the sorted list of all spm-relevant suffixes.

consider a suffix-prefix match 〈r, r′, ℓ〉 . by definition, the suffix of length ℓ of r exactly matches the prefix of length ℓ of r′. obviously, the suffix of r involved in the match starts at some position j, 2 ≤ j ≤ |r|−ℓmin+ <dig> in r. this implies that r must be at least of length ℓmin +  <dig>  the suffix cannot start at the first position in r, as otherwise r would be a prefix of some other read, contradicting our assumption that r is prefix-free.

to enumerate the set of all suffix-prefix matches of length at least ℓmin, we preprocess all reads and determine all proper suffixes of the reads which may be involved in a suffix-prefix match. more precisely, for all reads r we determine all matching candidates, i.e. all proper suffixes s of r such that the length of s is at least ℓmin and there is a read r′ such that s and r′ have a common prefix of length at least k, where k is an user-defined parameter satisfying k ≤ min{ℓmin,ω2}. there are two reasons for imposing this constraint on k: first, we want to represent a string of length k over an alphabet of size  <dig> in one machine word, thus k ≤ω <dig>  second, the suffixes of the reads from which we take the prefixes of length k have minimum length ℓmin, thus we choose k ≤ ℓmin.

the set of all matching candidates and all reads forms the set of all -spm-relevant suffixes. for simplicity sake, we use the notion spm-relevant suffixes if ℓmin and k are clear from the context. while all spms can be constructed from the spm-relevant suffixes, not all spm-relevant suffixes lead to an spm.

an efficient algorithm for identifying and sorting all spm-relevant suffixes
the first two phases of our algorithm follow a strategy that is borrowed from the counting sort algorithm  <cit> . like this, our algorithm has a counting phase and an insertion phase. however, in our problem, the elements  to be sorted are only determined during the algorithm. moreover, the number of keys  whose occurrences are counted is on the order of the number of elements to be sorted. therefore, in a space efficient solution, it is not trivial to access a counter given a key. we have developed a time and space efficient method to access the counter for a key, exploiting the fact that counting and inserting the spm-relevant suffixes does not have to be done immediately. instead, the items to be counted/inserted are first buffered and then sorted. a linear scan then performs the counting or inserting step.

in contrast to counting sort, our algorithm uses an extra sorting step to obtain the final order of elements pre-sorted in the insertion phase. under the assumption that the maximum read length is a constant , our algorithm runs in o time and space, where n is the total length of all reads. to the best of our knowledge a method employing a similar strategy has not yet been developed for the suffix-prefix matching problem.

we first give a description of our algorithm using string notation. in a separate section, we explain how to efficiently implement the algorithm. in the following, we only consider the reads in the forward direction. however, it is not difficult to extend our method to also incorporate the reverse complements of the reads and we comment on this issue at the end of the methods section.

the initial kmer of some sequence s is the prefix of s of length k. to determine the matching candidates efficiently, we first enumerate the initial k-mers of all reads and store them in a table of size m. this can be done in o time. the notion table size always refers to the number of entries in the table. the next step lexicographically sorts the k-mers in the table in ascending order. this string sorting problem can be transformed into an integer sorting problem  which can be solved by radixsort  <cit>  in o time and o extra working space.

in the next step, a linear scan of the sorted k-mers removes duplicates from the table and counts how many times each k-mer occurs in the table. this scan requires o time. let d ≤ m be the number of different k-mers. these can be stored in a table k of size d.

the counts for the elements in k require another table c of size d. in addition to the duplicate removal and counting, the linear scan of the sorted k-mers constructs two sets p and q, the size of which depends on two user defined parameters k′ ≤ k and k ″≤ k. p is the set of all initial k′-mers of the reads. q is the set of all k-mers r for some r∈r. we assume that elements can be added to p and q in constant time and that membership in these sets can be decided in constant time. thus the linear scan constructs p and q in o time. as p is a subset of a set of size 4k′, p can be stored in 4k′ bits. q requires 4k′′ bits.

up until now, only the initial k-mers of the reads were considered, resulting in a sorted table k of d non-redundant keys , a table c of size d for counting k-mers and two sets p and q. by construction, each count in c is at least  <dig> and the sum of the counts is m. the next task is to enumerate, for all reads r, the suffixes of r at all positions j, 2 ≤ j ≤ |r|−ℓmin+ <dig>  r has |r| − ℓmin such suffixes. for each such suffix s , one extracts two strings v = s and w=s. if v does not occur in p, then v is not a prefix of any read in r and thus s is not a matching candidate and can be discarded. if w does not occur in q,  then w≠r for all reads r∈r and thus s is not a matching candidate and can be discarded. thus p and q serve as filters to efficiently detect suffixes which can be discarded. for read r the suffixes s and corresponding strings v and w can be enumerated in o time. checking membership in p and in q requires constant time. therefore, each read r is processed in o time. thus the enumeration and checking requires o time altogether.

the next task is to process a suffix, say s which has passed the p-filter and the q-filter. that is, v = s ∈ p and w=s∈q holds. one now has to check if u = s occurs in k to verify if s is a matching candidate. if the latter is true, the appropriate counter needs to be incremented. hence this is the counting phase of our algorithm. the simplest way to check the occurrence of u in k, is to perform a binary search, taking u as the key. however, this would require o time for each k-mer passing the filters. this is too slow. using a hash table turned out to be too slow as well and would require too much extra space, which we do not want to afford.

we propose an efficient method that works as follows: store each k-mer s passing the p and the q-filter in a buffer b of fixed size b=dγ for some constant γ >  <dig>  once b is full or all k-mers have been added to b, sort the elements in b in ascending lexicographic order. then perform a binary search in k, but only for the first element in b, say x. as b is sorted, x is the smallest element. the binary search for x in k finds the smallest element in k greater than or equal to x using o time. if such an element occurs in k, say at index e, then simultaneously scan b beginning with the first index and k beginning at index e. for any element in b that is equal to an element in k, say at index i in k, increment the counter in c at the same index.

this simultaneous linear scan of b and  k takes o time and finds all k-mers from b occurring in k. once the scan and the associated increments are done, the buffer is emptied for the next round. suppose that there are in total b∗k-mers that have passed b. thus there are b∗b rounds filling the buffer. each round is associated with a sorting step, a binary search and a linear scan. sorting requires o time using radixsort. this gives a running time of ob∗b)=ob∗b=ob∗b=o)=o. as b∗≤ n:=∑r∈r|r|, the running time is linear in the total length of the reads.

once all reads have been processed, for any initial k-mer u of any read, the following holds: if u is the ith initial k-mer in k, then c is the number of spm-relevant suffixes of which u is a prefix. to prepare for the insertion phase, compute the partial sums of c in an array π of size d +  <dig>  such that π <cit>  = c <cit> , π=π+c for all i, 1 ≤ i ≤ d −  <dig>  and π = π. π is the number of all spm-relevant suffixes. one creates a table s of size g: = π to hold pairs of read numbers and read offsets. as in the counting phase, enumerate all suffixes of reads of length at least ℓmin passing the p- and the q-filter. suppose that s is such a suffix of read number p and with read offset q. let u be the initial k-mer of s. then we store  in a buffer b′ of fixed size b <dig>  we choose this buffer size, as the elements in b′ require twice as much space as the elements in b. as in the counting phase, sort the buffer in lexicographic order of the k-mers it stores, and then process the buffer elements using the k-mer, say u, as a key to determine if u matches some element in k, say at index i. then insert  at index π −  <dig> in s and decrement π.

after all b∗ elements passed the buffer and have been processed, s holds all spm-relevant suffixes  in lexicographic order of their initial k-mers. let u be the ith k-mer in k. then all spm-relevant suffixes with common prefix u are stored in s from index π to π− <dig>  thus s can uniquely be divided into buckets of spm-relevant suffixes with the same initial k-mer. each such bucket can be sorted independently from all other buckets. moreover, each spm-relevant suffix not occurring in the ith bucket, has an initial k-mer different from u and thus cannot have a common prefix of length ≥ ℓmin with the suffixes in the ith bucket. as a consequence, all suffix-prefix matches are derivable from pairs of spm-relevant suffixes occurring in the same bucket. thus, the suffix-prefix matches problem can be divided into d subproblems, each consisting of the computation of suffix-prefix matches from a bucket of spm-relevant suffixes. this problem is considered later.

to sort the ith bucket one extracts the remaining suffixes relevant for sorting the bucket and stores them in a table. this strategy minimizes the number of slow random accesses to the reads. consider the ith bucket and let  be one of the suffixes in the bucket, referring to the suffix of read rp at read offset q. then extract the suffix of rp starting at position q + k. as the maximum read length is considered to be constant, the total size of the remaining suffixes to be stored is o. the remaining suffixes can be sorted using radixsort in o time. an additional linear time scan over the sorted suffixes of the bucket delivers a table l of size π−π− <dig>  such that lj is the length of the longest common prefix of the suffixes s+j−1] and s + j] for all j, 1 ≤ j ≤ π−π− <dig> 

sorting all remaining suffixes and computing the lcp-table l thus requires o space and o∑i=0d−1=o time where βmax is the maximum size of a bucket and g is the total number of spm-relevant suffixes. the bucket of sorted spm-relevant suffixes and the corresponding table l are processed by algorithm  <dig> described after the following implementation section and algorithm  <dig> described in additional file  <dig>  section  <dig> 

all in all, our algorithm runs in o = o time and o space. as we choose k′′ ≤ k′ ∈ o and m, g, and βmax are all smaller than n, the space requirement is o. thus the algorithm for identifying and sorting all -spm-relevant suffixes is optimal.

implementation
we will now describe how to efficiently implement the algorithm described above. an essential technique used in our algorithm are integer codes for k-mers. these are widely used in sequence processing. as we have three different mer-sizes  and dependencies between the corresponding integer codes, we shortly describe the technique here. in our problem, a k-mer always refers to a sequence of which it is a prefix. therefore, we introduce integer codes for strings of length ≥ k: for all strings s of length at least k define the integer code ϕϕk=∑i=1k4k−i, where ϕ is the mapping  uniquely assigning numbers from  <dig> to  <dig> to the bases in the alphabetical order of the bases. note that only the first k symbols of s determine ϕk, which is an integer in the range . for all strings s and s′ of length at least k, s ⊴ s′ implies ϕk ≤ ϕk, where ⊴ denotes the lexicographic order of strings and ≤ denotes the order of integers.

besides ϕk, we use the encodings ϕk′ and ϕϕk′′k for some k′, k ″≤ k. ϕk′ encodes the prefix of s of length k′ and is defined in analogy to ϕk . ϕϕk′′k encodes the suffix s of s of length k″, i.e. ϕϕk′′k=∑i=1k′′4k′′−iϕ. ϕk′ and ϕk′′k can be computed from ϕk according to the following equations:

  ϕk′=ϕk4k−k' 

  ϕk′′k=ϕkmod4k″ 

we implement k-mers by their integer codes. each integer code can be computed in constant time by extracting the appropriate sequence of consecutive bit pairs from a 2bit per base encoding of the read set. in our implementation, we use the representation and the appropriate access functions from the gtencseq software library  <cit> . as k ≤ω <dig> we can store each integer code in an integer of the machine’s word size. we sort m integer codes for the initial k-mers using quicksort, adapting the code from  <cit> . our implementation works without recursion and uses an extra stack of size o to sort m integers. this small additional space requirement is the main reason to choose quicksort instead of radixsort, which is usually more than twice as fast, but requires o extra working space, which we do not want to afford.

the sets p and q are implemented by bit vectors vp and vq of 4k′ and 4k′′ bits, respectively. bit vpq is set if and only if q = ϕk′ for some r∈r. bit vqq is set if and only if q=ϕk′′k for some read r∈r. to obtain the bit index, one computes ϕk′ and ϕk′′k from ϕk using equations  and . equation  can be implemented by a bitwise right shift of  <dig> bits. equation  can be implemented by a bitwise and operation with the integer 22k′′ −  <dig>  thus, given the integer code for s, both ϕk′ and ϕk″k can be computed in constant time. therefore, the sets p and q can be constructed in o time and each access takes constant time.

when determining the k-mer codes in the counting phase and in the insertion phase, we sweep a window of width k over the sequence reads and compute the integer code for the sequence in the current window in constant time.

we implement the counts by a byte array of size d and store counts larger than  <dig> in an additional hash table. additional file  <dig>  section  <dig> gives the details.

the partial sums in table π are bounded by g, the number of spm-relevant suffixes. for large read sets, g can be larger than 232 −  <dig>  however, as the partial sum are strictly increasing, one can implement π by a  <dig> bit integer table ps of size d +  <dig>  such that ps = π mod  <dig> for any i, 0 ≤ i ≤ d and an additional integer table of size 2max{ <dig> log2 g−32}marking the boundaries of carry bits. details are given in additional file  <dig>  section  <dig> 

for the insertion phase we need a representation of the read set , table k , set p and q , table π  bits) and table s of size g. as s holds pairs of read numbers and read offsets, each entry in s is stored compactly in σ=log2 m+log <dig> bits. this would give an integer array of size gσω if we would store s completely. but we do not, as we employ a partitioning strategy, explained next.

although the data structures representing tables s, k, p and π are of different sizes, their access follows the same scheme: suppose that i is the smallest index, such that g2≤ π. roughly half of the suffixes to be inserted in s are placed in buckets of lower order  and the other half are placed in buckets of higher order . the buckets of lower order are associated with the k-mers in k up to index i. hence, for these, one needs table k and ps only up to index i. let s be some suffix of length ≤ ℓmin such that ϕk ≤ k. to apply the p-filter to s, one checks vp at index ϕk4k−k′≤k4k−k′, which is in the first half of vector vp. this strategy, dividing tables s, k, p and π into q =  <dig> parts of roughly the same size, can be generalized to q >  <dig> parts. each part is defined by a lower and an upper integer code and by corresponding lower and upper boundaries referring to sections of the four mentioned tables. partitioning s means to only allocate the maximum space for holding all buckets belonging to a single part.

the four tables that can be split over q parts require h = 2kd + 4k″ + 32 + g σ bits. hence, in the insertion phase, our method requires 2n+4k″+hq bits, where 2n + 4k′′ bits are for the representation of the reads and the set q . as gσ dominates all other terms, h is much larger than 2n + 4k′′ so that the space gain of our partitioning strategy is obvious. as the space required for the insertion phase for any number of parts can be precalculated, one can choose a memory limit and calculate the minimal number of parts such that the limit is not exceeded. in particular, choosing the space peak of the counting phase as a memory limit for the insertion phase allows for balancing the space requirement of both phases. more details on the partitioning technique are given in additional file  <dig>  section  <dig> 

an obvious disadvantage of the partitioning strategy  is the requirement of q scans over the read set. however, the sequential scan over the read set is very fast in practice and only makes up for a small part of the running time of the insertion phase.

the expected size of a bucket to be sorted after the insertion phase is smaller than the average read length. the maximum bucket size  is  <dig> to  <dig> orders of magnitude smaller than d. as we can store ω <dig> bases in one integer of ω bits, the remaining suffixes  can be stored in βmaxλmax−kω+ <dig> integers, where βmax is the maximum size of a bucket and λmax is the maximum length of a read. the additional constant  <dig> is for the length of the remaining suffix, for the read number and the read offset. the sort keys are thus sequences of integers of different length which have to be compared up to the longest prefix of the strings they encode. we use quicksort in which ω <dig> bases are compared using a single integer comparison. as a side effect of the comparison of the suffixes, we obtain the longest common prefix of two compared suffixes in constant extra time, and store this in a table l of the size of the bucket. the suffixes in the bucket and the table l are passed to algorithm  <dig>  described next, and to algorithm  <dig> 

an efficient algorithm for computing suffix-prefix matches from buckets of sorted spm-relevant suffixes
the input to the algorithm described next is a bucket of sorted spm-relevant suffixes, with the corresponding table l, as computed by the algorithm of the previous subsection. consider the ith bucket in s and let hj = s + j] be the jth suffix in this bucket for all j, 0 ≤ j ≤ β −  <dig> where β = π − π is the size of the bucket. by construction, we have hj-1 ⊴ hj, lj ≥ k, and lj is the length of the longest common prefix of hj− <dig> and hj for j, 1 ≤ j ≤ β −  <dig> 

note that the bucket-wise computation does not deliver the lcp-values of pairs of spm-relevant suffixes on the boundary of the buckets. that is, for all i >  <dig>  the length of the longest common prefix of s − 1] and s] is not computed, because s − 1] is the last suffix of the th bucket and s] is the first suffix of the ith bucket. however, as both suffixes belong to two different buckets, their longest common prefix is smaller than k  and therefore not of interest for the suffix-prefix matching problem.

the suffixes occurring in a bucket will be processed in nested intervals, called lcp-intervals, a notion introduced for enhanced suffix arrays by  <cit> . we generalize this notion to table h and l as follows: an interval e.f, 0 ≤ e < f ≤ β −  <dig>  is an lcp-interval of lcp-value ℓ if the following holds:

 •   e=0orle<|, 

 •   lq≥|for all q,e+1≤q ≤f, 

 •   lq=|for at least oneq,e+1≤q ≤f, 

 •   f=β−1orlf+1<|. 

we will also use the notation ℓ −  for an lcp-interval  of lcp-value ℓ. if ℓ −  is an lcp-interval such that w = he is the longest common prefix of the suffixes he, he+ <dig>  …, hf, then  is called the w-interval.

an lcp-interval ℓ′ −  is said to be embedded in an lcp-interval ℓ −  if it is a proper subinterval of ℓ −   and ℓ′ > ℓ. the lcp-interval ℓ −  is then said to be enclosing . if  encloses  and there is no interval embedded in  that also encloses , then  is called a child interval of  and  is the parent interval of . we distinguish lcp-intervals from singleton intervals  for any e′, 0 ≤ e′, ≤ β −  <dig>   represents he′. the parent interval of  is the smallest lcp-interval  with e ≤ e′ ≤ f.

this parent–child relationship of lcp-intervals with other lcp-intervals and singleton intervals constitutes a virtual tree which we call the lcp-interval tree for h and l. the root of this tree is the lcp-interval 0 − . the implicit edges to lcp-intervals are called branch-edges. the implicit edges to singleton-intervals are called leaf-edges. additional file  <dig>  section  <dig> gives a comprehensive example illustrating these notions.

abouelhoda et al.  present a linear time algorithm to compute the implicit branch-edges of the lcp-interval tree in bottom-up order. when applied to a bucket of sorted suffixes, the algorithm performs a linear scan of tables h and l. in the eth iteration, 0 ≤ e ≤ β −  <dig>  it accesses the value le+ <dig> and he. we have non-trivially extended the algorithm to additionally deliver leaf edges. the pseudocode, with some additions in the lines marked as new, is given in algorithm  <dig> . we use the following notation and operations:

 • a stack stores triples  representing an lcp-interval ℓ − . to access the elements of such a triple, say sv, we use the notation sv.lcp , sv.lb  and sv.rb .

 • stack.push pushes an element e onto the stack.

 • stack.pop pops an element from the stack and returns it.

 • stack.top returns a reference to the topmost element of the stack.

 • ⊥ stands for an undefined value.

 • process_leafedge) processes an edge from the lcp-interval itv to the singleton interval representing the suffix rp. firstedge is true if and only if the edge is the first processed edge outgoing from itv.

 • process_branchedge processes an edge from the lcp-interval itv to the lcp-interval itv’. the value itv’.rb is defined and firstedge is true if and only if the edge is the first edge outgoing from itv.

 • process_lcpinterval processes the lcp-interval itv. the value itv.rb is defined.

depending on the application, we use different functions process_leafedge, process_branchedge, and process_lcpinterval.

additional file  <dig>  section  <dig>  explains why algorithm  <dig> also delivers the leaf edges of the lcp-interval tree in the correct bottom-up order.

consider a path in the lcp-interval tree from the root to a singleton interval  representing he′ = rp. let ℓ −  be an lcp-interval on this path, and consider the edge on this path outgoing from ℓ − . if the edge goes to an lcp-interval of, say lcp-value ℓ′, then the edge is implicitly labeled by the non-empty sequence rp. suppose the edge goes to a singleton interval: then the edge is implicitly labeled by the non-empty sequence rp$p. if q + ℓ = |rp|, then rp is the empty string, which implies that the edge to the singleton interval is labeled by the sentinel $p. such an edge is a terminal edge for rp. if the read offset q is  <dig>  we call  a whole-read interval for rp, and the path in the lcp-interval tree from the root to  a whole-read path for rp.

consider a suffix-prefix match 〈 rp, rj, ℓ 〉 , such that the suffix w of rp of length ℓ has a prefix u of length k. recall that u is the common prefix of all suffixes in the ith bucket. due to the implicit padding of reads at their end, the symbol following w as a suffix of rp is $p. by definition, w is also prefix of rj and the symbol in rj following this occurrence of w is different from $p. thus, there is a w-interval  in the lcp-interval tree for h and l.  is on the path from the root-interval to the whole-read leaf interval for rj. moreover, there is a terminal edge for rp outgoing from . vice versa, an lcp-interval of lcp-value ℓ on the path to the whole-read leaf interval for rj and with a terminal edge for rp identifies the suffix-prefix match 〈 rp, rj, ℓ 〉 . this observation about suffix-prefix matches is exploited in algorithm  <dig>  which performs a bottom-up traversal of the lcp-interval tree for h and l, collecting whole-read leaves and terminal edges for lcp-intervals of lcp-value at least ℓmin. more precisely, whenever a whole-read leaf for rp, 1 ≤ p ≤ m, is found , p is appended to the list w. with each lcp-interval itv on the stack used in the bottom-up traversal, an integer itv.firstinw is associated. the elements in w are exactly the read numbers of whole-read leaves collected for itv. the value of itv.firstinw is set whenever the first edge outgoing from itv is detected: if the first edge outgoing from itv is a leaf-edge, no previous whole-read leaf for itv has been processed: thus |w| +  <dig> is the first index in list w where the whole read leaf information  for itv will be stored . if the first edge is a branch-edge to lcp-interval itv′, then the corresponding subset of w for itv′ must be inherited to itv. technically, this is achieved by inheriting the firstinw-attribute from itv′ to itv, see line  <dig> of algorithm  <dig> 

whenever a terminal edge for read rp, outgoing from an interval itv is processed , p is added to the list t. suppose that this terminal edge is outgoing from the lcp-interval itv. the first symbol of the label of the terminal edge is $p. suppose there is a branch-edge outgoing from itv to some lcp-interval itv′. then the first symbol, say a, of the implicit label of this edge must occur more than once. thus it cannot be a sentinel, as these are considered different in the lexicographic ordering of the suffixes. hence the first symbol a is either a, c, g or t. as these symbols are, with respect to the lexicographic order, smaller than the sentinels, the branch-edge from itv to itv’ appears before the terminal edge from itv. hence the terminal edges outgoing from itv′ have been processed in line  <dig>  and so we only need a single list t for the entire algorithm.

as soon as all edges outgoing from itv have been processed, we have collected the terminal edges in t and the whole-read leaves in w. if itv.lcp exceeds the minimum length, algorithm  <dig> computes the cartesian product of t with the appropriate subset of w and processes the corresponding suffix-prefix matches of length itv.lcp in line  <dig>  at this point suffix-prefix matches may be output or post-processed to check for additional constraints, such as transitivity. once the cartesian product has been computed, the elements from t are no longer needed and t is emptied . note that the algorithm empties w once an lcp-interval of lcp-value smaller than ℓmin is processed. after this event, there will only be terminal edges from v-intervals such that the longest common prefix of v and the reads in w is smaller than ℓmin. therefore there will be no suffix-prefix match of the form 〈_, w, ℓ〉 such that ℓ ≥ ℓmin and w is a read represented in w. so the list can safely be emptied.

the lcp-interval tree for h and l contains β leaf-edges. as all lcp-intervals have at least two children, there are at most β −  <dig> branch-edges and β lcp-intervals. as each of the three functions specified in algorithm  <dig> is called once for every corresponding item, the number of functions calls is at most 3β −  <dig>  recall that algorithm  <dig> is applied to each bucket and the total size of all buckets is g. hence there are at most 3g − d calls to the three functions. process_leafedge and process_branchedge run in constant time. the running time of process_lcpinterval is determined by the number of spms processed. assuming that the processing takes constant time, the overall running time of algorithm  <dig> for all buckets is o where z is the number of processed spms.

handling reverse complements of reads
reads may originate from both strands of a dna molecule. for this reason, suffix-prefix matches shall also be computed between reads and reverse complements of other reads. handling the reverse complements of all reads is conceptually easy to integrate into our approach: one just has to process r― instead of r.

the three steps which involve scanning the reads are extended to process both strands of all reads. this does not require doubling the size of the read set representation, as all information for the reverse complemented reads can efficiently be extracted from the forward reads. additional file  <dig>  section  <dig>  shows how to compute the integer codes for the reversed reads from the integer codes of the forward reads in constant time.

the scan of the reverse complemented reads has a negligible impact on the runtime. of course, the size of the table s, k and ps roughly doubles when additionally considering reverse complements.

when computing suffix-prefix matches some minor modifications are necessary: applying algorithm  <dig> to r― finds all spms, including some redundant ones, which we want to omit. this is formalized as follows: an spm〈r,s,l〉∈spm is non-redundant if and only if one of the following conditions is true:

 •   r∈r,s∈r 

 • r∈r,s∈r―,r≺s―

 • r∈r―,s∈r,s≺r―.

for any spm, these conditions can easily be checked in constant time, see algorithm  <dig> .

recognition of transitive and irreducible suffix-prefix matches
for the construction of the string graph, we do not need transitive spms. an spmr,t,l′′ is transitive if and only if there are two spms 〈r, s, ℓ〉 and 〈s, t, ℓ′〉 such that ℓ + ℓ′ = |s|+ ℓ″. figure  <dig> shows a concrete example of a transitive spm. an spm which is not transitive is irreducible.

the following theorem characterizes an spm by a read and a single irreducible spm satisfying a length constraint and a match constraint, see figure  <dig> for an illustration.

theorem  <dig>  let 〈r, t, ℓ″〉 be an spm. then 〈r, t, ℓ″〉 is transitive if and only if there is an s∈r and an irreducible spm 〈s, t, ℓ′〉 such that ℓ′ > ℓ″, |r| − ℓ″ ≥ |s| − ℓ′ and s = r.

the proof of theorem  <dig> can be found in additional file  <dig>  section  <dig> 

if the spm 〈r, t, ℓ″〉 is transitive and 〈s, t, ℓ′〉 is the spm satisfying the conditions of theorem  <dig>  then we say that 〈r, t, ℓ″〉 is derived from 〈s, t, ℓ′〉.

theorem  <dig> suggests a way to decide the transitivity of an spm 〈r, t, ℓ〉: check if there is an irreducible spm 〈s, t, ℓ′〉 from which it is derived. the check involves comparison of up to |s| − ℓ′ symbols to verify if s is a suffix of r. as there may be several irreducible spms from which 〈r, t, ℓ″〉 may be derived, it is necessary to store the corresponding left contexts: for any sequence s and any ℓ′, 1 ≤ ℓ′ < |s|, the left context lc of s is the non-empty string s.

due to the bottom-up nature of the traversal in algorithm  <dig>  the spms involving the different prefixes of a given read are enumerated in order of match length, from the longest to the shortest one. thus, algorithm  <dig> first delivers the irreducible spm 〈s, t, ℓ′〉 from which r,t,l′′ is possibly derived, because l′>l′′.

from theorem  <dig> one can conclude that the first spm, say 〈s, t, ℓ′〉, found on a whole-read path for t is always irreducible. hence, one stores lc. an spm 〈r, t, ℓ″〉 detected later while traversing the same whole-read path for t is classified as transitive if and only if lc is a suffix of lc . if 〈r, t, ℓ″〉 is transitive it is discarded. otherwise, lc must be stored as well to check the transitivity of the spms found later for the same whole-read path. so each spm is either classified as transitive, or irreducible, in which case a left context is stored. to implement this method, we use a dictionary d of left contexts, with an operation lcsearch, which returns true if there is some t ∈ d such that t is a suffix of s. otherwise, it adds s to d and returns false. such a dictionary can, for example, be implemented by a trie  <cit>  storing the left contexts in reverse order. in our implementation we use a blind-trie  <cit> . in additional file  <dig>  section  <dig> we present a modification of algorithm  <dig> to output non-redundant irreducible spms only.

recognition of internally contained reads
at the beginning of the methods section we have shown how to detect reads which are prefixes or suffixes of other reads. when constructing the string graph we also have to discard internally contained reads, which are contained in other reads without being a suffix or a prefix. more precisely, r∈r is internally contained, if a read r′∈r exists, such that r′ = urw for some non-empty strings u and v. in additional file  <dig>  section  <dig>  we show how to efficiently detect internally contained reads.

construction of the assembly string graph
consider a read set r which is suffix- and prefix-free. the assembly string graph  <cit>  is a graph of the relationships between the reads, constructed from spmnr, the set of all non-redundant irreducible spms from spm restricted to reads which are not internally contained.

for each r∈r the graph contains two vertices denoted by r.b and r.e, representing the two extremities of the read. b stands for begin, e stands for end.

for each non-redundant irreducible spm〈r,s,l〉∈spmnr satisfying ℓ ≥ ℓmin, the graph contains two directed edges, defined as follows:

 <dig>  if 〈r,s,l〉∈spmnr there are two edges:

 • r.e → s.e with edge label s

 • s.b → r.b with edge label r¯

 <dig>  if 〈r,s¯,l〉∈spmnr there are two edges:

 • r.e → s.b with edge label s¯

 • s.e → r.b with edge label r¯

 <dig>  if 〈s―,r,l〉∈spmnr there are two edges:

 • r.b → s.e with edge label s

 • s.b → r.e with edge label r

in our implementation of the string graph, vertices are represented by integers from  <dig> to 2m −  <dig>  to construct the graph from the list of non-redundant irreducible spms, we first calculate the outdegree of each vertex. from the counts we calculate partial sums. in a second scan over the list of spms, we insert the edges in an array of size 2ρ, where ρ=|spmnr|. this strategy allows to allocate exactly the necessary space for the edges and to access the first edge outgoing from a vertex in constant time. the array of edges is stored compactly using 2ρ+log2) bits, where λmax is the maximum length of a read. log <dig> bits are used for the destination of an edge . log <dig> bits are used for the length of the edge label.

to output the contigs, we first write references  to a temporary file. once this is completed, the memory for the string graph is deallocated, and the read sequences are mapped into memory. finally, the sequences of the contigs are derived from the references and the contigs are output.

to verify the correctness of our string graph implementation and to allow comparison with other tools, we have implemented the graph cleaning algorithms described in  <cit>  as an experimental feature. more sophisticated techniques, such as the network flow approach described in  <cit> , are left for future work, as the main focus of this paper lies in the efficient computation of the irreducible spms and the construction of the string graph.

RESULTS
the presented methods for constructing the string graph and the subsequent computation of contigs have been implemented in a sequence assembler named readjoiner, which is part of the genometools software suite  <cit> . the readjoiner pipeline consists of three steps:

 • readjoiner prefilter takes a read set in form of one or more fasta-formatted files and removes reads containing ambiguity codes and reads which are prefixes or suffixes of other reads. it outputs the prefiltered reads in the gtencseq-format  <cit> .

 • readjoiner overlap maps the representation of prefiltered reads in memory, enumerates non-redundant irreducible suffix-prefix matches, and stores them on file. the time/space tradeoff for this step can be adjusted by an option specifying the number of parts in which the sorted array of spm-relevant suffixes is computed. alternatively, one can specify a memory limit, according to which the minimum number of parts is determined to not exceed this limit.

 • readjoiner assembly builds the string graph and traverses it to output the contigs.

experimental setup
for our benchmarks, the 64bit genometools binary was compiled by gcc version  <dig> . <dig> using the provided makefile with the option “64bit = yes assert = no amalgamation = yes”. these last two options trigger the build-system to not compile assertions and to generate a single c-code file from which an amalgamation object is compiled, thus allowing for a maximum of inlined code, which in turn is executed faster.

all tests were performed on a computer with a  <dig>  ghz intel xeon e <dig> 4-core processor,  <dig> gb ram, under a 64bit linux operating system, using a single core only.

for memory usage measurements, we monitored the vmhwm  value in the /proc file system  <cit>  associated with the process of each particular program over the time of its execution, including both allocated heap memory and memory made available via the mmap() system call. the running time is the cpu time  as measured using gnu time.

for all runs of readjoiner we used k =  <dig>  k′=max{ <dig> log2n−8} and k″ = k′ −  <dig>  if not stated otherwise, the number of parts in which readjoiner computes the sorted array of spm-relevant suffixes was  <dig>  all programs were run with min =  <dig> .

human genome sequencing simulations
we tested our assembler on simulated error-free sequencing read sets based on human genomic sequences . for each human chromosome we prepared a template sequence by deleting ambiguity symbols. then we simulated reads by pseudo random sampling of the template sequence and its reverse complement, until the desired number of reads was obtained. this was done using the genometools simreads-tool and is the same procedure as used in  <cit> .

from each of the  <dig> human chromosome sequences, we generated a separate read set with 20 × coverage and a constant read length of  <dig> bp. the read set are called c <dig>  c <dig>  …, c <dig>  cx, cy. furthermore, using the entire human genome as template we generated read sets with 20×, 30× and 40× coverage, referred to by hg20×, hg30× and hg40×, respectively. additionally, from chromosome  <dig>  a set of reads of variable length was prepared: the results for this dataset are reported in additional file  <dig>  section  <dig> 

in a first computational experiment, we determined the time vs. space tradeoff of our partitioning strategy, by applying readjoiner to c <dig> with a varying number of parts ranging from  <dig> to  <dig>  the results are shown in figure  <dig> 

the complete readjoiner-pipeline was applied to each of the  <dig> datasets c <dig>  c <dig>  c <dig>  …, c <dig>  cx, cy. we considered the running time as a function of the length of each chromosome from which the dataset was generated and performed a linear regression, which delivered an r2-value of  <dig> . the same was done for the space peak, delivering an r2-value of  <dig> . figure  <dig> shows plots of the time vs. length and space peak vs. length functions.

comparison with other string graph-based assemblers
the 64bit linux binaries of edena  <cit>  were downloaded from  <cit> . we tested version  <dig> . <dig> and version  <dig> dev <dig>  edena  <dig> is an untested version and under active development. in our tests, it required slightly more memory and was significantly slower than edena version  <dig> . <dig>  which we therefore selected for the comparative test. the source code of sga  was obtained from its public github repository  <cit> . the 64-bit linux binary of leap was downloaded from  <cit> .

as edena is based on the original string graph construction method proposed by  <cit> , a comparison to readjoiner allows validating our construction method. table  <dig> reports the performance of edena and readjoiner for the assembly of datasets c <dig>  c <dig> and c <dig>  these and additionally c <dig> were used as benchmark sets in  <cit> . for all three datasets, edena and readjoiner produce exactly the same list of irreducible spms, which allows concluding that the string graphs are identical. the resulting contig sets are almost identical: edena was slightly more stringent in the output of the smallest contigs. readjoiner was 13 − 14× faster than edena and used about 11% of the space used by edena. due to a segmentation fault, edena did not complete the overlap phase for the largest chromosome dataset c <dig> 

results of applying readjoiner  and edena to the datasets c <dig>  c <dig>  c <dig> .

sga  <cit>  is based on the direct string graph construction methods first introduced in  <cit> . currently, to the best of our knowledge, it is the only other open source string graph-based assembler, besides readjoiner. the sga default pipeline consists of the index, overlap and assemble tools: however, memory can be reduced by using sga index, rmdup and fm-merge  <cit> . the parameter d of the sga-index phase allows selecting the number of sequences to be processed at a time: without this parameter, the index phase requires much more memory than other phases. with memory being the most limiting factor in the assembly, we optimized the space peak of sga by gradually reducing the value of d until either the space peak of the index phase was less than the space peak of the other phases, or a further decrease of d did not reduce the space peak. sga’s index construction and overlap calculation can be threaded. however, for a fair comparison we used a single thread. table  <dig> reports the results of running sga and readjoiner for the datasets c <dig>  c <dig>  c <dig> and c <dig>  readjoiner was 19× to 20× faster than sga and used 14% to 23% less space than sga. using overlap and assemble instead of fm-merge, sga became slightly faster but required about  <dig> times more memory . by default, sga is less stringent than readjoiner when computing the contigs from the string graph, thus producing more contigs with a lower n <dig> value. for each of the four datasets, the longest contig produced by sga and readjoiner is identical, and the ng <dig> value of the assembly is comparable.

results of applying readjoiner  and sga to the datasets c <dig>  c <dig>  c <dig>  c <dig> .

leap implements the methods described in  <cit>  to construct a full overlap graph. the efficiency of leap is remarkable, and allowed us to extend the comparison with readjoiner to the hg20× dataset. table  <dig> reports the results when applying readjoiner and leap to the datasets c <dig>  c <dig> and hg20×. additionally, it shows the results for readjoiner on hg30× and hg40× . readjoiner was faster than leap for all datasets with a speedup factor of  <dig>  to  <dig> . furthermore, it required less memory: while the reduction in the space peak was at a maximum for the small datasets , it is still significant  for the hg20× dataset which contains almost two orders of magnitude more reads. in approximately the same time in which leap assembles hg20× , and using less memory, readjoiner was able to assemble the hg30× dataset. readjoiner was also able to assemble the hg40× dataset in  <dig> hours using  <dig> gb ram.

results of applying readjoiner  and leap to the datasets c <dig>  c <dig>  hg20× , hg30× , hg40× . leap was not able to process hg30× and hg40× on the test machine with  <dig> gb ram.

evaluation of assemblies
in order to assess the quality of the assemblies delivered by the different programs, we used the script assess_assembly.pl of the plantagora project  <cit> . the script aligns the contigs to the template sequence from which the reads were sampled, using the nucmer alignment tool  <cit> . several metrics, including the number of unaligned contigs, misassemblies, snps and gaps are reported.

furthermore, assemblies were evaluated using the basic assemblathon  <dig> statistics as defined in  <cit> , including total length of the contigs, length of the longest and shortest contig, n <dig>  l <dig>  ng <dig> and lg <dig>  table  <dig> reports the results of the evaluation of the assemblies of dataset c <dig> 

metrics of the assemblies of the dataset c <dig> as delivered by readjoiner , sga, edena and leap . the metrics are explained in  <cit>  and in  <cit> .

effect of sequencing errors
readjoiner is based on the computation of exact suffix-prefix matches. real-world datasets, however, contain a certain amount of errors. to better assess the effect of sequencing errors on the assembly, we sampled two sets of reads from the escherichia coli k- <dig> genome, each consisting of  <dig> million reads: the first one  is error-free, while in the second read set  sequencing errors were introduced using a  <dig> % position-independent substitution rate.

in order to assess the efficiency of k-mer based error correction , we pre-processed ecoli-with-errors using sga. this constructs an fm-index from the reads set and errors are corrected using sga correct, delivering the read set termed ecoli-sga-corrected. this is further processed by sga filter, after constructing a new fm-index, to eliminate further error-containing reads. this resulting set ecoli-sga-corrected+filtered was assembled using both readjoiner and sga. table  <dig> gives the most important statistics of the readjoiner and sga assemblies of the four different read sets defined here.

n <dig> and ng <dig> values for the readjoiner and sga assemblies of ecoli-without-errors, ecoli-with-errors, ecoli-sga-corrected and ecoli-sga-corrected+filtered.

discussion and 
CONCLUSIONS
in this paper, we presented methods and implementation techniques of a new string graph based assembler, named readjoiner, which is significantly faster or more space efficient than the previous software tools edena  <cit> , sga  <cit>  and leap  <cit> . in particular, readjoiner can handle a set of reads with 40× coverage of the entire human genome  on a machine with  <dig> gb ram.

although the different string graph-based assemblers aim at constructing the same graph, they apply different heuristics to compute a layout from the string graph. the quality of assemblies of simulated datasets was compared using metrics from the plantagora project  <cit>  and the assemblathon  <dig> project  <cit> . in the assemblies of c <dig> delivered by readjoiner, sga and edena there are  <dig> misassembled contigs. in contrast,  <dig> % of the contigs of the leap assembly could not be aligned to the reference and  <dig> % of the aligned contigs were misassembled. the “negative gaps” metric computed by plantagora reflects the amount of overlaps among the contigs. its high value for all tools can be explained by the fact that branching nodes in the string graph start new contigs in which the read corresponding to the branching node is included. additionally considering the “positive gaps” metrics, one can conclude that most contigs were interrupted due to the presence of repetitive sequences, but not due to low coverage.

our main development is a new efficient algorithm to compute all irreducible suffix-prefix matches from which the string graph is constructed. while the basic techniques we use  are mostly well-established in sequence processing, their combination is novel for the considered problem. the different techniques were chosen with the overall goal of performing as few as possible random accesses to large data structures to obtain algorithms with excellent data locality which in turn leads to short run times. for most parts of our method, this goal was achieved, mostly due to the partitioning of the set of spm-relevant suffixes. there are still many random accesses to the representation of the reads, which, however, cannot fully be prevented in an index based approach.

the problem of computing suffix-prefix matches has long been studied in the literature, mostly with the goal of finding, for each pair of reads r and s, the longest suffix-prefix match of r and s. gusfield et al.  <cit>  solved this maximum suffix-prefix matching problem in optimal o time and optimal o space using the suffix tree for all suffixes of m reads of total length n.

ohlebusch and gog  <cit>  present a solution to the same problem with the same time and space complexity using a linear scan of an enhanced suffix array. we do not know of any solution of the maximum suffix-prefix match problem which appropriately handles the reverse complements of the reads. applying the algorithms of  <cit>  or of  <cit>  to the set of all reads and their reverse complements would not guarantee the maximality constraint, as the forward and reverse complement of a read are represented in different locations of the employed index structure.

in edena, suffix-prefix matches are computed using a suffix array. details of the algorithm or the implementation are not published.

like simpson and durbin  <cit> , we replaced the maximality constraint by a minimum length constraint imposed on each suffix-prefix match. the modified problem allows for an algorithm with two important advantages : at first, the algorithm does not require a stack for each of m reads, and still can employ the space and time efficient bottom-up traversal of an lcp-interval tree as presented in algorithm  <dig>  moreover, the algorithm can easily handle reverse complements of the reads and efficient selection of irreducible suffix-prefix matches is possible.

there are two main approaches to the construction of a string graph. the original approach of myers  <cit>  was to first construct a full overlap graph before transitive edges are removed. the resulting string graph contains all information relevant for the layout of the contigs. as the string graph contains much less edges than the overlap graph , the explicit representation of this usually defines the space peak.

an alternative overlap graph representation for exact suffix-prefix matches was introduced in  <cit>  and implemented in the leap software. the basic idea of this approach is to implicitly store many suffix-prefix matches for a set of lexicographically related reads in constant space using an interval representation. this allows for a compact storage of the full overlap graph. the representation does not apply to irreducible spms. in  <cit>  only asymptotic results regarding the space requirement of the compact overlap graph representation are given, and leap does not give any clues on the size of the graph it constructs. so it remains unclear if this representation of the overlap graph is smaller than our representation of the string graph. a comparison of the overall space requirement of leap and readjoiner shows a clear advantage for readjoiner, see table  <dig> for details.

it is worthwhile to note that the contigs output by leap contain many differences with respect to the target sequences they were sampled from. it is not clear to us, whether this is an artifact of the method or an implementation issue.

another efficient way to reduce the space peak for string graph constructions is to recognize transitive spms and prevent their insertion in the graph structure. simpson and durbin  <cit>  developed the first method following this approach and implemented it in the sga software. in this paper, we have described an alternative algorithm, exploiting a property of transitive spms that can easily be checked on a small set of strings.

our comparative tests  indicate that readjoiner is more than one order of magnitude faster than the current sga implementation and uses less space. this may come as a surprise as sga uses a compact index structure based on the bwt, while readjoiner employs techniques known from enhanced suffix arrays, which are usually more space consuming. the space advantage of readjoiner is mainly a result of our partitioning approach applied to the array of spm-relevant suffixes. the partitioning technique leads to a large reduction in the overall memory peak and a small increase in the running time. this can be explained by an improved cache coherence: for a given part, only a small portion of the different tables are accessed. this seems to outweigh the time for the additional passes over the reads.

we see two reasons for the time advantage of readjoiner: at first it employs a suffix selection and sorting method which is specifically tailored for the suffix-prefix matching problem and the given minimum match length ℓmin. in contrast, the bwt employed by sga provides a general string indexing technique that is not optimized for computing spms of an arbitrary but fixed minimum length. secondly, readjoiner computes suffix-prefix matches by a linear scan of two integer tables, which is a very fast operation. in contrast, sga relies on random accesses to the bwt which may take longer for large data sets.

the minimum match length parameter ℓmin is used to restrict the search to the exact spms that are considered to be significant. to balance the required computational resources and the quality of the assembly, one has to carefully choose an appropriate value for ℓmin =  <dig>  a larger value of ℓmin reduces the number of spm-relevant suffixes, and in turn speeds up the computation and reduces the space requirement, but may lead to a poor assembly. interestingly, in our simulations based on reads of length  <dig> bp, we obtained the best assembly results for a relatively large value of ℓmin around  <dig>  however, for a fair benchmarking of the tools and to simplify comparison with previous publications, we have chosen ℓmin =  <dig> 

among the string graph-based assemblers mentioned here, sga is the only one that can distribute parts of the computation across multiple threads. some of the algorithms employed in readjoiner are well suited for a multi-threaded implementation. for example, each bucket of spm-relevant suffixes is sorted independently and the corresponding spms are computed independently of all other buckets. this step only requires random read access to the representation of the reads. a multi-threaded implementation with shared memory access to the reads and buckets which are  evenly distributed over the threads, is expected to provide a considerable speedup within a small amount of additional space.

another important issue for future development is the improvement of the assembly quality for real world data. here further preprocessing steps, in particular quality filtering and error detection are required, as well as the handling of paired read information in the assembly phase.

the present manuscript focuses on the algorithmic approach and implementation of methods for the computation of irreducible suffix-prefix matches and the construction of the string graph. we report our results on error-free datasets: this is in analogy to the first papers describing the methods implemented in sga  <cit>  and leap  <cit> .

several error correction strategies have been applied so far: the classical method was to consider approximative suffix-prefix matches of the reads and to correct the resulting contigs in a consensus phase. with large next-generation datasets, the method of choice consist in k-mer counting, identification of a subset of trusted k-mer, which occur at least a given number of times in the read set, and correction of the reads containing untrusted k-mers  <cit> .

approximative suffix-prefix matching algorithms can be implemented to work on index structures, but the increased search space makes them significantly slower than exact matching algorithms. among the string graph-based assemblers, only sga implements an approximate suffix-prefix matching algorithm: nevertheless, this is not used by default, and the authors recommend using their faster k-mer based error correction method instead  <cit> .

the fact that readjoiner is based on exact suffix-prefix matches makes it sensible to errors. we have demonstrated that using a k-mer based error correction step delivers read sets for which readjoiner delivers assemblies with metrics comparable to sga. we therefore plan to implement a k-mer based error correction for readjoiner, employing techniques similar to those used for computing suffix-prefix matches.

paired-end and mate pairs provide short and long range positional information, which is critical for improving the quality of assembling eukaryotic genomes. the classical approach consists in using this information for connecting contigs into scaffolds either in a post-processing phase, which may be integrated in the assembler software, or using a stand-alone tool, such as bambus  <cit>  or sspace  <cit> . a complementary approach, which we intend to introduce in a future version of our software, is to exploit the pairing information already during the traversal of the string graph, by restricting to paths connecting the mate pairs with a length compatible to the insert size of the library. details of such an approach are given in  <cit> .

availability
the readjoiner software is available as part of the genometools genome analysis package  <cit> , a free, open source collection of bioinformatics software. see http://www.zbh.uni-hamburg.de/readjoiner for more details.

authors’ contributions
gg developed most of the methods, implemented readjoiner, and performed the benchmarks. sk conceived the project and developed the suffix selection and sorting methods. both authors wrote the manuscript and approved its final version.

supplementary material
additional file 1
supplemental material. this document describes implementation techniques for the methods and algorithms described in the main document. moreover, it gives a lemma and a theorem  characterizing transitive spms, and an algorithm to enumerate irreducible and non-redundant suffix-prefix matches. furthermore, a method to recognize internally contained reads is given, as well as results for a benchmark set with reads of variable length. finally, an example of spm-relevant suffixes and their corresponding lcp-interval is presented.

click here for file

 acknowledgements
we would like to thank gordon gremme and sascha steinbiss for developing and maintaining the genometools, which proved to be a powerful software framework for the implementation of readjoiner. furthermore, we thank dirk willrodt and sascha steinbiss for proofreading earlier versions of this manuscript. many thanks to martin frith for pointing out an error in the previous definition of transitive spms.
