BACKGROUND
many phenomena can be represented and interpreted as dynamic networks. these consist of vertices and edges that occur and vanish at different time points  <cit> . global characteristics of a dynamic network’s topology, e.g. its diameter, may vary over time, but also characteristics of individual vertices, such as their centralities. it is essential to take these dynamics into account when one is interested in crucial vertices and subnetworks characterizing the information flow in dynamic networks and their connectivity. the detection of such vertices or subnetworks is important for different research areas like life, social and computer science to understand empirical phenomena like the spread of a disease in a population, the connectivity within and between peer groups or cyber attacks on computer networks .

statistical methods for static networks have been an active and fruitful field for statistical research in the last decades. in recent years the development of probabilistic models for dynamic networks as well as the development of methods for describing key properties of these networks have gained more and more attention  <cit> . for this purpose, a dynamic network is often represented as a dynamic graph consisting of a vertex set v and a temporal edge set e. while some authors  <cit>  define a temporal edge as event between two vertices a and b starting at a particular time point with specific edge duration, others  define a dynamic network as a sequence of static graphs, so called snapshots, consisting of temporal edge sets e
t. the temporal order of the edge set describes the direction of the dynamics. the sequence of snapshots can either consist of static graphs of specific time points, or aggregated static graphs constructed by combining all edges present within a predefined time interval. in many scientific fields, e.g. genetic epidemiology, only static graphs of specific time points are available rather than fully observed dynamic network structures, for example because it is technologically infeasible to determine the exact starting time or duration of an edge between two vertices. based on the representation of a snapshot sequence it is possible to extend vertex measures like closeness and betweenness centrality from static to dynamic network settings. however, it is inappropriate to apply vertex centrality measures for static settings, to quantify the importance of vertices in a dynamic network because the dynamic topology of the network will be neglected  <cit> . this is for example the case when a dynamic network is aggregated into a static graph sequence and then ‘classical’ vertex centralities are calculated without taking into account the structural changes within the network over time. calculating static centrality measures for every vertex of each snapshot and then averaging these values also neglects the the time order of the snapshots. faisal & milenkovic correlated static centrality measures with the time of the respective snapshot to calculate centrality values in dynamic networks  <cit> . however, their approach is not a temporal centrality measure because it does not reflect temporal paths. to address this shortcoming we use the concept of temporal paths necessary to appropriately describe the centrality of a vertex in its chronological sequence .

tang et al. extended static centrality measures for the use in dynamic networks by accounting for shortest temporal paths  <cit> . their approach assumes that all network information within a previously chosen window size is aggregated into one snapshot. kim and anderson  <cit>  modified the representation of a sequence of graph snapshots into a single directed time graph linking each vertex with its successors in time. based on this directed time graph the authors slightly reformulated the centrality measures of  <cit> . another definition of vertex centrality was given for temporal walks  <cit>  that allow to visit edges multiple times per time point instead of once as with shortest temporal paths. this temporal centrality measure can be interpreted as a temporal version of the static katz centrality  <cit> .

while the computation of dynamic network characteristics mainly assumes a fully observed dynamic network, there is a lack of approaches for incomplete graph sequences which pose two major challenges: 
an edge in an observed snapshot could have arisen at an earlier and unknown time point in the past and could last until an unknown time point in the future. hence, starting time and duration of this edge are uncertain.

some edges are unobserved because they occur and vanish in the time interval between two consecutive observed snapshots. such edges are not observed and hence also their influence on the network’s dynamic is difficult to assess.




both cases will affect temporal centrality measures and are likely to occur in real world applications, e.g. when data of gene expression networks are available only at some – maybe unequally spaced – time points  <cit>  or when rapid changes occur within the network  <cit> . while some authors propose metrics to quantify the overall stability of the topology of a dynamic network , the impact on centrality measures due to incomplete information was only investigated for static network settings  <cit> . the development of temporal centrality measures accounting for incompletely observed dynamic networks is still lacking.

our work fills this gap by introducing the problem of incomplete graph sequences and proposing an extensions of the temporal betweenness and closeness centralities of kim & anderson  <cit>  by using additional snapshots in situations of incomplete graph sequences. these added snapshots are copies of observed snapshots and will be referred to as clones in the following. hence we propose the clone temporal betweenness and closeness centrality . the main purpose of adding clones is to allow more moves along a graph sequence and hence to increase the number of identified temporal paths that could not have been found with the originally observed snapshot sequence. we demonstrate in simulation studies and in an application to a real dynamic gene network that our new approach provides simple improved vertex centrality estimates in situations with incomplete graph sequences. we further considered the computational aspect of our new measures. the time complexity for calculating centrality measures in dynamic graphs depends on the number of vertices and edges as well as on the number of snapshots. especially, the calculation of temporal centrality measures based on  temporal paths can be challenging because, unlike static graphs, for dynamic graphs it does not hold that every subpath of a shortest temporal path is again a shortest path. hence, the search for the shortest temporal path has to visit all relevant subsequences of graphs, i.e. starting from every snapshot up to the last snapshot. otherwise the full dynamics of the network will not be considered appropriately in the calculated centrality values  <cit> . to address this time demanding requirement, we propose a novel and easy to implement algorithm called ren . its time complexity is linear in the number of graph snapshots for a fixed number of vertices and edges. this property allows to search for shortest temporal paths in long graph sequences or in a graph sequence that has been augmented by clones. in addition, our simulations suggest that the overall running time of ren benefits from dense and sparse dynamic networks.

methods
let us assume a finite time interval in which a dynamic network has been observed, starting at t
start and ending at t
end, where without loss of generality t
start= <dig> and t
end=t. a dynamic network is represented as a dynamic graph g <dig> td=, where we assume a finite set v of |v| vertices and an edge set e
 <dig> t that can change in the time interval . while we will focus on edge sets e
 <dig> t consisting of temporal undirected edges {a,b}i,j∈e
 <dig> t with a,b∈v that are present in the time interval  with 0≤i<j≤t, it is straightforward to extend our approach to temporal directed edges.

in the following we will present the basic notations to introduce incomplete graph sequences. we will then derive a modified version of the temporal betweenness centrality as an example for our approach using cloned snapshots.

graph sequences and shortest temporal paths
to characterize structural properties of a dynamic network a dynamic graph g <dig> td is commonly discretized into a time ordered sequence of static graphs g=g <dig> g2…,gs with corresponding edge sets e
k for k∈{ <dig> ,…,s}, such that g
k=. each edge set e
k of a snapshot k consists of all edges that are present in a time window w
k of size w≤=t. thus, the number of snapshots is given by s=t/w.

sequences of graph snapshots can be represented as directed time graphs   <cit> . figure  <dig> shows a graph sequence and its adequate dtg. each snapshot g
k in fig. 1
a has a corresponding column d
k of directed edges . hence, every vertex a∈v of g occurs s+ <dig> times in a dtg, indicated by a
 <dig> a
 <dig> …,a
s. the columns d
k of a dtg contain the  edges of the original snapshot representation plus edges from each vertex to itself at the next time point . the latter edges represent halts in a snapshot; all other edges are called hops.
fig.  <dig> directed time graph . a graph sequence g of snapshots in  and its representation as a dtg in . horizontal edges in  indicate halts on a vertex, diagonal edges represent hops. two shortest temporal paths from vertex a to vertex b are marked by red dashed edges





it is possible to formulate an edge sequence connecting vertices along the dtg, as indicated by the red dashed edges in fig. 1
b. we call such sequences temporal paths. they consist of a unique combination of hops and halts. the occurrence of an edge is considered by only allowing either one hop or halt per snapshot k . thus, using the representation as a dtg, a temporal path starting at snapshot k and ending at snapshot n with k,n∈{ <dig> ,…,s},k≤n of a graph sequence g=g <dig> …,gs is defined as an ordered sequence of vertices p
k,n=〈a
k− <dig> …,c
n〉 such that a,c∈v. note that p
k,n starts with index k− <dig> in a dtg.

let pk,n=⋃m=knpk,m, that is the set of all possible temporal paths starting from vertex a at snapshot k and ending in vertex c, at the latest, in snapshot n. note, a temporal path from a to c can end at m≤n. if a path path p
k,m exists, the path length is defined as |p
k,m|=m−k+ <dig>  which is the number of halts and hops needed to travel from vertex a to vertex c in the graph sequence g
k,…,g
m. a shortest temporal path γ
k,m,n is then defined as the path p
k,m∈p
k,n with minimum number m, where c is reached in snapshot m≤n. it’s length is |γ
k,m,n|=m−k+ <dig>  the set Γk,m,n=⋃γk,m,n contains all shortest temporal paths from a to c within the considered sequence g
k,…,g
n. consequently, all shortest temporal paths of Γ
k,m,n have the same path length m−k+ <dig> 

expanding the above notation, γ
k,m,n∈Γ
k,m,n denotes a shortest temporal path that crosses vertex b at snapshot l. therefore, the set Γk,m,n=⋃k<l<mγk,m,n contains all shortest paths from a to c that cross b at some snapshot l.

if a shortest temporal path γ
k,n,n contains the holds and hops of p
l,n we call p
l,n the upper temporal subpath of γ
k,n,n. analogously, if γ
k,n,n contains all edges of p
k,l we call p
k,l a lower temporal subpath of γ
k,n,n. additionally, we simply call every sequence of hops and halts of p
k,n starting at a snapshot l, l>k, and ending at a snapshot m, m<n, a temporal subpath of p
k,n.

in the following we will show that every upper temporal subpath of a shortest temporal path will always be a shortest temporal path itself even if the lower temporal path is not a shortest temporal path.

lemma 1
given a graph sequence g=gk,…,gl,…,gm,…,gn, let γ
k,n,n be a shortest temporal path from a to c that passes vertex b at snapshot l and ends at snapshot n. then, even if the lower temporal path p
k,l is not a shortest temporal path, the upper temporal path p
l,n is a shortest temporal path, i.e. p
l,n=γ
l,n,n.

proof
assume that there exists a temporal path p
l,m from b to c with |p
l,m|<|γ
l,n,n|. then it follows that 
 |γk,n,n|=|pk,l|+|γl,n,n|>|pk,l|+|pl,m|=|pk,m| 


which is contradiction to the assumption that γ
k,n,n is the shortest temporal path from a to c over b at snapshot l. □

note that although all subpaths of shortest paths are again shortest path in a static directed graph  <cit> , this does not hold for a dtg. as a simple example consider a path p
k,n=γ
k,n,n=γ
k,n,n=γ
k,n,n, l<m, from a to c that passes vertex b at snapshots l and m. then, |p
k,l|<|p
k,m| and hence p
k,m is not a shortest path although it is a subpath of γ
k,n.

while the query for  temporal paths is only meaningful in graph sequences with at least two snapshots, the length of a  temporal path can be one, if a and c are connected at the first snapshot of the graph sequence, that is |p
k,n|≥|γ
k,k,n|= <dig> 

incomplete graph sequences
if there is only limited access to s snapshots of time points t∈ , the observed graph sequence g is incomplete. in this situation it might be impossible to determine exactly when an edge occurs and how long it has existed in the network. additionally, incomplete sequences might miss edges in total and thus can lead to unobserved edges. figure  <dig> gives an example of the impact of incomplete graph sequences. although in fig. 2
b the first snapshot g
 <dig> at t= <dig>  correctly captures the occurrence of edge {a,c}, it cannot determine its duration until t= <dig>  the true edge sequence of {a,d} followed by {b,d} cannot be reconstructed because at the next snapshot g
 <dig>  both edges are aggregated into one graph. this masks their chronological order. further, the second occurrence of {b,d} in the time interval  <cit>  is not detected, because the last observation of the dynamic network is g
 <dig> at t= <dig> , and therefore the edge {b,d} is missing in the observed graph sequence. the consequence is that there is no temporal path from a to b in the observed dtg .
fig.  <dig> incomplete graph sequence. an incomplete observed graph sequence in  and its dtg  compared to the true but unobserved dynamic network in . solid boxes in  represent time intervals of the respective edge occurrence within the true dynamics. dashed boxes in  indicate snapshots at specific time points and the green dotted lines mark the corresponding moments in . the sequence of graph snapshots yields the incomplete graph sequence




both, masked edge chronologies and unobserved edges affect the number of observable  temporal paths in a dynamic network.

clone temporal betweenness centrality
in a static network, the betweenness centrality of a vertex b measures how easily b can be avoided when seeking for shortest paths to get from vertex a to c, a≠b≠c∈v. more precisely, it is the ratio between the number of shortest paths from a to c passing b and the total number of shortest paths from a to c. this idea has been extended  <cit>  to graph sequences g=g <dig> …,gs consisting of s snapshots. let σ
k,m,s denote the cardinality of the set of the shortest paths Γ
k,m,s and σ
k,m,s denote the cardinality of Γ
k,m,s for a graph sequence g
k,…,g
s. the temporal betweenness centrality  of vertex b is then defined as: 
  <dig> tbc <dig> s=∑k=1s−1∑a,c∈v∖bσk,m,s>0σk,m,sσk,m,s. 


the second sum in eq.  accounts for all shortest paths starting from vertex a and the first sum ensures that all subsequences starting at a snapshot after k, g
l,…,g
s, l>k, are included in the calculation of this measure. this is necessary to adequately capture the complete dynamic behaviour in the network over time  <cit> . for example, consider a graph sequence with all vertices connected to each other at the first snapshot but with fewer connections at the following snapshots. applying the tbc without summing over all later subsequences will not represent the dynamics after the first snapshots because all shortest temporal paths will be of length one due to the fully connected first snapshot. however, tbc cannot explicitly handle incomplete graph sequences and hence it will miss  temporal paths when calculating a vertex’ centrality.

consider fig.  <dig> and assume that we have only observe the sequence as shown in fig. 2
b; what can then be inferred about the true underlying sequence in fig. 2
a? it is obvious that the edge {a,c} in snapshot g
 <dig> must have occurred before the next observed snapshot g
 <dig>  the edges {a,d} and {b,d} observed in snapshot g
 <dig> on the contrary must have occurred in the dynamic network at a time point between snapshots g
 <dig> and g
 <dig> but we do not know the order of occurrence and thus the possible temporal paths. our proposal is to fill the gap between snapshots with additional snapshots, in order to reveal additional  temporal paths that are likely to exist. these added snapshots are copies of observed snapshots and will be referred to as clones.

definition 1
given a static graph g
k of snapshot k we define clones of g
k as gk,jk such that gk,jk=gk for j
k= <dig> ,…,j
k.

based on definition  <dig> and using the notation gk,jk for gk,jk we can now define a cloned graph sequence.

definition 2
given a original graph sequence g
 <dig> g
 <dig> …,g
s and clones gk,jk with k= <dig> ,…,s and j
k= <dig> ,…,j
k a cloned graph sequence is defined as the ordered sequence g <dig> ,g <dig> ,…,gk,jk,…,gs,js.

augmenting the original graph sequence with clones gk,jk raises the question of how to choose the number of clones j
k per snapshot. this is generally flexible and may vary depending on the application. we propose the following three plausible approaches: 
adding a sufficient number of clones j
k per snapshots k such that any static path in g
k−1∪g
k not presented in g
k− <dig> and g
k alone can be found as a temporal path. this is always possible and depends on the number of different edges between g
k− <dig> and g
k.

adding clones based on assumptions about the expected duration of the occurrence of edges.

if the number of unobserved discrete time points between g
k− <dig> and g
k is known a corresponding number of clones can be added.



b, we constructed the graph sequence presented in fig. 3
a and decided to clone each of its snapshot once, resulting in the graph sequence of fig. 3
b. as shown in fig. 3
c, clones can detect shortest temporal paths that are in fact a true shortest temporal paths . however, cloning compensates only for unobserved edge durations and ordering of occurrences, but it cannot detect unobserved edges and hence also no temporal paths that contain these unobserved edges. furthermore, if cloning overestimates edge durations or the order of occurrence ), it might detect false shortest temporal paths . we call this problem excess of cloning and discuss its implications in more detail in the simulation section.
fig.  <dig> cloned graph sequence. the incomplete observed graph sequence in  is based on the incomplete graph sequence of fig.  <dig>  the first two observed snapshots are cloned as shown in the graph sequence in  and the respective dtg in . green boxes indicate clones. both true temporal paths from a to b  in the original complete graph sequence were found due to cloning . however, a spurious  temporal path was also detected that is not present in the original sequence 




exploiting the idea of cloning snapshots, we extend the tbc of eq.  to a clone temporal betweenness centrality : 
  <dig> ctbc <dig> s=∑k=1s∑jk=1jk∑a,c∈v∖bσk,m,sjk>0σk,m,sjkσk,m,sjk, 


where σk,m,sjk denotes the number of shortest temporal paths from a to c passing b, starting at the j
k-th clone of snapshot k. similarly, σk,m,sjk denotes the total number of shortest paths from a to b starting at the j
k-th clone of snapshot k. the ctbc successively sums the sequence of observed and cloned snapshots starting at the j
k-th clone of snapshot k until the last clone of snapshot s. ctbc is applicable for graph sequences of directed and undirected temporal networks. the idea of cloning snapshots when calculating temporal centrality measures can also easily be applied to other temporal centrality measures like the temporal closeness centrality .

ren: a new algorithm for finding shortest temporal paths
an appropriate algorithm is necessary to calculate the above temporal centrality measures. the summation over all subsequences in eqs.  <dig> and  <dig> can be computationally demanding for long graph sequences because a shortest temporal path in g
k,…,g
s might not be a  temporal path in g
k+ <dig> …,g
s which necessitates a new query. as a consequence, a new search for shortest temporal paths has to be started for each snapshot of the graph sequence g
k,…,g
s. for example, there are two shortest temporal paths starting from vertex a at snapshot  <dig> and ending at vertex b at snapshot  <dig> in fig.  <dig>  both paths have to pass vertex d at snapshot  <dig>  meaning that a temporal path starting at snapshot  <dig> or later cannot be subpath of these shortest temporal paths.

our ren algorithm tackles the problem of consecutive queries by searching for temporal paths in the reversed order of snapshots, defined as g∗=gs,…,g <dig>  a reversed temporal path is defined as pn,k∗=〈cn,…,ak−1〉=revpk,n, where rev is the function that reverses the edge directions in a dtg and therefore the order of the vertices of a temporal path. the basic idea is then to move along all reversed temporal paths starting from a specific vertex c at snapshot s until snapshot  <dig> and to store each descendent vertex b of c and its lowest snapshot number k where b is connected to c by an edge or temporal path. even if there are shortest temporal paths found before reaching the first snapshot it is crucial to move along all reversed temporal paths up to the first snapshot of the considered graph sequence. otherwise shortest temporal paths that start at or near the first snapshot are not found.

in the following, we will prove that the computational time of ren is linear with respect to the number of snapshots s when searching for all shortest temporal paths in g
k,…,g
s, ∀ k∈ . first, we prove that a query along a particular reversed shortest temporal path finds all upper temporal subpaths that are also shortest temporal paths too.

lemma 2
let g
k,…,g
n,k<n, be a graph sequence and let γ
k,n,n′=p
k,n′ be a specific shortest temporal path in Γ
k,n,n. then, moving along the reversed temporal path pn,k∗=revpk,n′ from vertex c to vertex a finds all n−k shortest temporal paths γ
l,n,n′, k≤l<n from any vertex b to vertex c that are upper temporal subpaths of γ
k,n,n′=γ
k,n,n′ and for which b=b
l∈γ
k,n,n′.

proof
a specific shortest temporal path γ
k,n,n′∈Γ
k,n,n is characterised by a unique combination of n−k hops and halts. this temporal path contains then n−k upper temporal subpaths, each starting at a different snapshot k,k+ <dig> …,n− <dig>  for l=k it directly follows that γ
l,n,n,′=γ
k,n,n,′.now, let l=k+ <dig> and let b∈v∖c be a vertex on γ
k,n,n,′, that is it holds γ
k,n,n,′=γ
k,n,n′. applying lemma  <dig> yields that the upper temporal subpath pl,n′ of pk,n′=γk,n,n′ is also a shortest temporal path γ
l,n,n′. this holds for all further l=k+ <dig> …,n− <dig>  i.e. γ
k,n,n′ contains n−k upper temporal subpaths  itself) that are shortest temporal paths.then, it follows that pn,k∗=revpk,n′ contains all reversed upper temporal subpaths pn,l∗=revpl,n′=revγl,n,n′ with k≤l<n. thus, following the reversed upper temporal path pn,k∗ reveals all n−k shortest temporal paths of γ
k,n,n′. □

with lemma  <dig> it is possible to show that one query for all reversed temporal paths starting at vertex c is sufficient to reveal all shortest temporal paths that end at c of a graph subsequence starting at a snapshot at or after k.

theorem 1
let g=gk,…,gn,k<n, be a graph sequence and let Γk,n=⋃l=kn−1⋃m=ln⋃a∈v∖cγl,m,n be the set of all shortest temporal paths that start from any vertex at snapshot l≥k and end in vertex c at snapshot m≤n. further, let pn,k∗=⋃a∈v∖cpn,k∗ be the set of all reversed temporal paths starting from vertex c at snapshot n and ending at any vertex a∈v∖c at snapshot k. then, every shortest temporal path γ
l,m,n∈Γ
k,n is a reversed subpath of a reversed temporal path in pn,k∗ and is therefore obtained by moving along every pn,k∗∈pn,k∗.

proof
every shortest temporal path γ
l,m,n∈Γ
k,n is a subpath of a temporal path in pk,n=⋃a∈v∖cpk,n. then, the set of all reversed temporal paths pn,k∗=revpk,n also includes the set of reversed shortest temporal paths Γk,n∗=revΓk,n.

lemma  <dig> shows for every specific shortest temporal path γ
l,m,m′∈Γ
k,n that the reversed path pm,l∗=revpl,m′=revγl,m,m′ contains all m−l upper subpaths of γ
l,m,m′ that are also shortest temporal paths. finally, because pm,l∗ is a subpath of pn,k∗∈pn,k∗, it will be detected by moving along the reversed temporal paths of pn,k∗. this holds for all a∈v. □

let p <dig> s=⋃k=1s⋃m=ks⋃b∈v∖cpk,m denote the set of all temporal paths starting from any vertex b∈v∖c at a snapshot k and ending in vertex c not later than at snapshot s. the set of all reversed temporal paths starting in vertex c and ending in any vertex b≠c is ps,1∗=revp <dig> s. further, let n
k⊆v∖c be the set of all neighbours of c, i.e. adjacent vertices of c, at snapshot k. by applying theorem  <dig> to all c∈v, ren can be outlined as follows: 
reverse the order of the observed snapshot sequence as g∗=gs,…,g <dig> 

select a start vertex c and set ps,1∗=∅.

for snapshot k=s: find all adjacent vertices b∈n
s. each edge between c and b forms a reversed temporal path ps,s∗=〈cs,bs−1〉 and is stored in the set ps,1∗.

for snapshots k=s− <dig> …,1: 
list all adjacent vertices b∈n
k. each edge between c and b∈n
k forms a reversed temporal path pk,k∗=〈ck,bk−1〉 and is stored in the set ps,1∗. set p
k,k=〈b
k− <dig> c
k〉=γ
k,k,s.

list all vertices a∈v∖{n
k∪c} that are adjacent to any vertex b for which pm,k+1∗∈ps,1∗.

join the reversed temporal paths pk+ <dig> k∗ and pm,k+1∗ at vertex b to obtain the reversed temporal path pm,k∗ and store it in ps,1∗.

set γk,m,s=pk,mmin for mmin=argminm:k<m≤s|pm,k∗|.




repeat steps  <dig> up to  <dig> for all other c∈v.



b gives an example of how ren finds all shortest temporal paths starting at vertex a and ending at vertex b in at least one relevant subsequence of graphs. this is achieved by applying one query for shortest temporal paths only once over the reversed snapshot order for each vertex. the graph sequence is represented as a dtg  and without loss of generality we focus on the shortest temporal paths starting from a
 <dig> and ending at b
 <dig> and show that the algorithm finds all shortest temporal paths for which b is a destination vertex by one linear query. the blue dashed edges indicate steps on a reversed temporal path which are potential edges of a shortest temporal path. red dashed edges indicate shortest temporal paths whenever it was detected by following a reversed temporal path. we start the query from vertex b
 <dig> at snapshot s= <dig> and follow all its reversed temporal paths up to snapshot  <dig> . in column d
 <dig> in image i, vertex b has two adjacent vertices, forming the hob 〈b
 <dig> d
5〉 and the halt 〈b
 <dig> b
5〉. focusing on d
 <dig>  there is one hop 〈d
 <dig> c
4〉 and one halt 〈d
 <dig> d
4〉 in d
 <dig> from snapshot  <dig> to  <dig>  the first reversed temporal path that connects b and a is detected in d
 <dig> via 〈d
 <dig> a
3〉 and according to lemma  <dig> it reveals the shortest temporal path γ
 <dig> ,6=〈a
 <dig> d
 <dig> d
 <dig> b
6〉. the paths p <dig> ∗=〈b <dig> d3〉 in d
 <dig> and p <dig> ∗=〈d <dig> a2〉 in d
 <dig> add up to the shortest temporal path γ
 <dig> ,6=〈a
 <dig> d
 <dig> b
4〉 in fig. 4
b iv. hence, we can infer that any temporal paths from a to b starting before snapshot  <dig> and ending after snapshot  <dig>  are shortest temporal paths. the detection of γ
 <dig> , <dig> has the following implications: further shortest paths starting at a snapshot l< <dig> must end in b
 <dig> or before. this means also that stored edges beyond snapshot  <dig> like 〈c
 <dig> d
5〉 or 〈d
 <dig> d
5〉 cannot be any longer part of further shortest temporal paths. since 〈d
 <dig> d
5〉 is part of γ
 <dig> , <dig>  we concluded that γ
 <dig> , <dig> is not part of a shortest temporal path starting at a snapshot l< <dig>  figure 4
b v and vi complete the query for shortest temporal paths via reversed temporal paths.
fig.  <dig> example for the algorithm procedure of ren. a dtg representation of a graph sequence g=g <dig> …,g <dig> in . the six reversed dtgs in  demonstrate the stepwise query for shortest temporal paths γ
 <dig> l, <dig> from a to b in a successively reversed graph sequence. blue dashed edges indicate hops and halts that potentially are parts of shortest temporal paths. red dashed edges indicate detected shortest temporal paths starting at a specific snapshot l





usually, the time complexity of algorithms for calculating temporal centrality measures based on shortest temporal paths are dominated by the number of snapshots. the authors of the original version of tbc indicate that the time complexity of their algorithm is cubic in the number of snapshots  <cit> . for long graph sequences they therefore propose to use larger window sizes w to discretize the dynamic graph g <dig> td into a reduced number of snapshots. this obviously results in a loss of information affecting the accuracy of the temporal centrality measures. ren improves on this limitation because it requires for each vertex only one search over g∗. thus its time complexity is linear in the number of snapshots. hence, the calculation of centrality measures like tbc becomes feasible in settings with long graph sequences but also for graph sequences with additional snapshots like the proposed ctbc. for example, tbc and ctbc have an overall running time of o using ren. ren’s running time benefits from sparse and dense graphs . while the first is obvious due to the small number of temporal paths, the latter can be explained by step  <dig> of our algorithm. in a dense graph sequence, the number of edges is close to the maximum number of edges for every snapshot, that is most vertices b will be b∈n
k. thus, the expensive search of step  <dig> can be omitted for these vertices.
fig.  <dig> computing time of ren. average time  needed to calculate the ctbc for  <dig> vertices using the ren algorithm. colours indicate graph sequences with different number of snapshots. each snapshot is based on a random erdős-rényi model with graph densities ranging from  <dig>  up to  <dig> . calculations were done on a single core of a  <dig> ghz intel hexacore processor using 8gb memory




if the observed graph sequence is represented as edge list for each snapshot, the space complexity of our algorithm is o|+s·|v|2), where |e|=∑k=1s|ek| denotes the total number of edges in the dynamic network. the second term denotes the space needed to save all temporal paths of the graph sequence. note, in the worst case scenario, i.e. when each snapshot contains a saturated graph, space complexity will be o.

RESULTS
simulation study
we define a group infection network  to compare the performance of the ctbc to the tbc in an incomplete graph sequence setting. a gin contains m∈ℕ subgraphs g,e
),m= <dig> …,m. gins are either undirected or directed, but neither multiple edges between vertices nor loops  are allowed. the probability p of an edge is the sum of a baseline probability τ and the probability τ
+=d
/|e
|, where d
 denotes the degree of a node a∈v
  and |e
| denotes the total number of edges in subgraph m. thus, τ
+ reflects a rich-get-richer principle.

we used the representation of a graph sequence consisting of k= <dig> …,s snapshots to simulate a gin as a dynamic network. the initial gin contains no edges. at snapshot k= <dig> a first vertex is randomly chosen and edges connecting it with any other vertices generated independently with probability p. at snapshots k≥ <dig> all vertices having one or more incident edges are allowed to connect with other vertices of the same subgraph with probability p. after κ·m<s snapshots, κ∈ℕ, a connected vertex is randomly chosen as bridge vertex b. at the next snapshot, only the bridge vertex builds an edge with a vertex from the next subgraph m+ <dig>  meaning that only b has neighbours in v
 and v
. this process is repeated until k=s. edges within a gin remain for λ∈ℕ snapshots and will then vanish. the dynamic of a gin depends on λ, where small values of λ lead to rapid changes in the network structure whereas high values of λ yield slow changes in the dynamic structure. a dynamic gin g is thus defined by seven parameters.

we generated gins containing  <dig> subgraphs, each consisting of  <dig> , <dig>  or  <dig> vertices, given an overall network size of |v|∈ <cit> , respectively. the gin parameters were set to τ= <dig> , κ= <dig> and λ= <dig> ,…, <dig>  i.e. edge durations ranged from 1% to 10% of the total number of snapshots. we simulated  <dig> undirected gins for each combination of parameters and, based on the complete graph sequence of  <dig> snapshots, we calculated the tbc from eq.  <dig> for each vertex. vertices were ranked according to their tbc values to make them comparable across graph sequences with different number of snapshots. ranks of vertices with the same centrality value were averaged. the ranks of the true tbc is our reference in the following comparison.

of each simulated complete graph sequence the incomplete graph sequences were generated by randomly drawing α=10%,20%,…,50% snapshot, i.e. containing  <dig>   <dig>   <dig>   <dig> and  <dig> snapshots. tbc and ctbc  were estimated for each vertex and ranks were assigned according to their respective centrality values. to calculate ctbc, we set the number of clones equal to the number of unobserved snapshots between two observed snapshots, following our third proposed approach regarding the question how to choose the number of clones. this implies a tendency to overestimate the edge duration. as a consequence false temporal paths might be included .

for every simulation run, spearman’s rank correlation coefficient ρ between the ranks based on the true tbc values and the tbc respectively ctbc values of the incomplete graph sequence were computed. a high positive ρ indicates that the centrality measure relying on incomplete information ranks the vertices similar to the true ranks. in addition, the detection rate was assessed, which is the proportion of how often the most important vertex  in the incomplete graph sequences matches the true most important vertex of the complete graph sequence in all simulation runs.

the box plots in fig.  <dig> show the results of the rank correlation ρ for different edge durations λ, observation rate α and network sizes |v|. in all incompleteness scenarios, ctbc outperforms tbc for all λ except for the combination . this could be due to an excess of cloning. as expected, longer edge durations  considerably improve the performance of ctbc compared to tbc. in addition, the results indicate that the improvement is independent of the network size |v| . interestingly, ctbc was strongly correlated  with the true tbc for longer edge durations in settings where at least 40% snapshots were observed, while tbc reached a plateau at a lower correlation. in general, if only α=10% of all snapshots were observed, both methods were weakly correlated with the true tbc, even in situations with an edge duration of λ= <dig> indicating that long edge durations cannot compensate for missing edge observations.
fig.  <dig> spearman’s rank correlation coefficient ρ for tbc and ctbc in an undirected gin scenario. box plots of ρ for tbc  and ctbc  based on different combinations of number of vertices , different proportions of randomly observed snapshots  of the original graph sequence consisting of  <dig> snapshots and different edge durations . the results are based on  <dig> simulation runs for every combination



fig.  <dig> detection rate of the most important vertex based on tbc and ctbc in an undirected gin scenario. detection rate for tbc  and ctbc  based on different combinations of number of vertices , different proportions of randomly observed snapshots  of the original graph sequence consisting of  <dig> snapshots and different edge durations . the results are based on  <dig> simulation runs for every combination




the simulation results for the temporal closeness centrality support our proposal of cloning snapshots, even if the benefit was smaller than for the temporal betweenness centrality, especially regarding the detection rate of the most important vertex .
fig.  <dig> spearman’s rank correlation coefficient ρ for tcc and ctcc in an undirected gin scenario. box plots of ρ for tcc  and ctcc  based on different combinations of number of vertices , different proportions of randomly observed snapshots  of the original graph sequence consisting of  <dig> snapshots and different edge durations . the results are based on  <dig> simulation runs for every combination


fig.  <dig> detection rate of the most important vertex based on tcc and ctcc in an undirected gin scenario. detection rate for tcc  and ctcc  based on different combinations of number of vertices , different proportions of randomly observed snapshots  of the original graph sequence consisting of  <dig> snapshots and different edge durations . the results are based on  <dig> simulation runs for every combination




excess of cloning
as mentioned before, an excess of cloning can introduce false  temporal paths which lead to biased centrality values. in a further simulation study, we evaluated this bias by generating a gin with the given parameters |v|= <dig>  m= <dig>  τ= <dig> , κ= <dig>  s= <dig> and λ= <dig> , <dig>  incomplete graph sequences were sampled assuming an observation rate of α=25%,50%,100%. that means, for example in the scenario α=100% all true snapshots were observed and for each snapshot a specified number of clones were wrongly introduced. as before, true ranks were based on the tbc values for the original graph sequence. for the calculation of ctbc, we fixed the number of clones to n
c= <dig> …, <dig> 
c= <dig> the length of the graph sequence is already doubled. however, the effect of an excess of cloning is less bad for longer edge durations λ.
fig.  <dig> impact of an excess of cloning on spearman’s rank correlation coefficient ρ





the scenarios with lower observation rates show that the correlation values of ctbc are comparable to the values of tbc in settings with shorter edge durations or even larger for longer edge durations – despite the excess of cloning. most important, although the performance of ctbc decreases with additional number of clones, it outperforms tbc even for large n
c.

application to real dynamic networks
we used a real age-related dynamic network to investigate the performance of ctbc compared to tbc in a real world application. the dynamic network was created from a microarray human brain gene expression data set  <cit>  that consists of  <dig> samples obtained from  <dig> individuals between  <dig> and  <dig> years of age. the reader may wish to refer to  <cit>  for more details on the generation of this age-specific protein-protein-interaction network. from the original dynamic network, we selected only genes belonging to the kegg metabolic pathways   <cit>  and their adjacent genes outside this pathway. this dynamic subnetwork contained  <dig>  genes  and  <dig>  temporal edges between  <dig>  different vertex pairs which were connected by an edge at least in  <dig> out of  <dig> time points. overall, the subnetwork contained  <dig> permanent edges that were present at all  <dig> snapshots, but also  <dig>  temporal edges that existed only for one snapshot. disregarding the permanent edges, the subnetwork showed a right skewed distribution of short to long edge durations.

to verify that the subnetwork kept the dynamic behavior of the whole network, we compared both regarding their dynamic edge density, that is the ratio between the observed number of edges at time t and the total number of possible edges at that time point. the dynamic edge density was similar for both networks the original network at all time points.

we used all observed  <dig> time points to calculate the true tbc of the dynamic subnetwork and ranked the vertices according to their tbc value. then we selected every fourth snapshot to build an incomplete graph sequence with nine snapshots. the incomplete graph sequence contained 23% of the original  <dig>  temporal edges that were present in 80% of the original  <dig>  vertex pairs. vertices were ranked according to their tbc and ctbc value estimated in the incomplete graph sequence. ctbc was calculated ten times where the number of clones n
c between snapshots was increased from one to ten.

the performance of tbc and ctbc was measured by the absolute rank difference  that compares the estimated ranks of the incomplete graph sequence to the true ranks of the complete graph sequence. results are summarized in table  <dig>  it can be seen that all versions of ctbc,nc= <dig> …, <dig>  outperformed tbc regarding the median, the first and third quartile as well as the interquartile range of the ard. further, the ard of all ctbc versions showed smaller variability than of tbc. the median of ctbc has its minimum for seven or more clones, while the first and third quartiles are lowest for ctbc . the similarity of ctbc versions with six or more clones per snapshot and their coincident improvement of the ard compared to tbc suggests that ctbc is robust against false positive edges introduced by cloning. we further calculated spearman’s rank correlation coefficient ρ between the true ranks and the estimated ranks by tbc and ctbc. albeit all methods achieved a high positive correlation with the true ranks , ctbc had higher correlation values than tbc in all versions.

ρ
ctbc 
0
.
9
3
ctbc 
0
.
9
3
ctbc 
0
.
9
3
ctbc 
1
5
.
0
4
7
.
0
0
.
9
3
ctbc 
ctbc 
ctbc 
3
4
.
0
ctbc 
3
4
.
0
ctbc 
3
4
.
0
ctbc 
3
4
.
0
ctbcnc was calculated using n
c clones per snapshots. bold numbers indicate the minimum value




since incomplete graph sequences might completely miss some edges, the centrality values of vertices being incident to missing edges can be heavily biased. it is obvious that due to the information loss of these edges even cloning cannot decrease the ard. in the real data example, this is reflected by very high absolute rank differences in all versions of ctbc and tbc, marked as outliers in the box plots .
fig.  <dig> results of the age-related dynamic brain network. box plots of the absolute rank difference for the age-related dynamic brain network. the incomplete graph sequence with  <dig> snapshots was built on every 4th snapshot from the original graph sequence that consisted of  <dig> snapshots in total. the network included  <dig> vertices. ctbc was calculated with different number of clones between snapshots. very high absolute rank differences were caused by unobserved rare edges, that were crucial for the connectivity of  vertices in the dynamic network




discussion and 
CONCLUSIONS
to the best of our knowledge this is the first work that introduced the problem of incomplete graph sequences when calculating temporal centrality measures. our extension of existing temporal centrality measures addresses this problem by adding ‘clones’ of observed snapshots as extra snapshots into the graph sequence. the idea was motivated by real world dynamic networks, where edges occur for shorter and longer time durations rather than only during the specific observed snapshot. furthermore, incomplete graph sequences are the rule rather than the exception in experimental and observational studies, where typically only a few snapshots of the total graph sequence can be obtained due to ethical, technical or financial reasons with varying time length between snapshots.

since the clone temporal centralities augment the original graph sequence by adding snapshots, we needed an algorithm that can handle large graph sequences in reasonable time. with our new algorithm ren   temporal paths can be detected efficiently along a successively by one snapshot reduced graph sequence. the time complexity of the algorithm is linear in the number of snapshots and hence it allows the calculation of temporal centrality measures even in settings with long graph sequences.

using the clone temporal betweenness centrality  as an example for clone temporal centralities, our simulation studies demonstrate a superiority of ctbc relative to the original temporal betweenness centrality   <cit>  with respect to spearman’s ρ and the detection rate of the most important network vertex. we also applied ctbc and tbc to a data set of an age-related gene expression network of the human brain, consisting of edges with shorter and longer durations. the analysis confirmed the better performance of ctbc compared to tbc. both, the results from the simulation study and the real data example showed that the cloned temporal centralities are affected by an excess of cloning, since the true edge durations will tend to be overestimated, which again can result in the detection of false temporal paths. except in data scenarios with short edge durations, cloning still provides better results even if too many clones were introduced in the observed snapshot sequence. there are three intuitive explanations why our approach outperforms the original approach even under an excess of cloning: 
not all wrongly introduced temporal paths due to cloning are shortest temporal paths and hence will not alter the cloned temporal centrality measures that are based on shortest temporal paths.

the original approach does not only miss true shortest temporal paths, it also detects false shortest temporal paths. this is due to the definition of a shortest temporal path: it is the temporal paths with the smallest number of hops and halts of all temporal paths between two vertices. for example, assume that there exist only two temporal paths, starting at a specific snapshot. further, let one of them be a shortest temporal path. if only the longer temporal path can be found - due to the incomplete graph sequence - it will be falsely declared as a shortest temporal path.

if a shortest temporal path is missed, some of its subpaths as well as paths including this shortest temporal path will be missed too. cloning snapshots raises the chance of finding at least some of those temporal paths.




however, while cloning snapshots is easy to implement, it cannot compensate for unobserved edges, resulting in inaccurate centrality values. moreover, our method does not rely on probabilistic models describing the evolution of a dynamic network. hence, we plan to investigate whether using probabilistic models for dynamic networks or exploiting a priori knowledge about the network topology can improve the estimation of temporal centrality measures.

based on our results, we recommend using our clone temporal centrality measures in settings of incomplete graph sequences instead of the original temporal centrality measures. additionally, using ren will improve computational speed in settings of long graph sequences. the r-code of our methods is available upon request from the authors and will be made available on cran.

additional file

additional file  <dig> clone temporal closeness centrality . definition of the clone temporal closeness centrality. 




electronic supplementary material

the online version of this article  contains supplementary material, which is available to authorized users.

