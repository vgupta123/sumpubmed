BACKGROUND
the rna worlds in both experimental and computational fields have recently grown rapidly, and non-coding rnas  have increased their importance in life sciences. one of the most important breakthrough from the experimental side is the high-throughput experiments which have unveiled the existence of many non-protein coding transcripts in various species  <cit> . while function-known ncrnas, which often harbor family-specific conserved secondary structure, such as trnas and mirnas have been intensively studied in detail, no functional annotation has been assigned to a number of known non-protein coding transcripts yet. since experimental assessment whether all known non-protein coding transcripts are functional or not is quite time-consuming, computational screening for finding the ncrnas with conserved secondary structure is an important step for determining not only expressed but also functional transcripts. computational comparative genomics is a powerful approach to identify ncrna candidates with conserved secondary structure from genomic sequences. to date, sequence-alignment-based ncrna finders such as rnaz  <cit> , qrna  <cit>  and evofold  <cit>  have been successfully applied to ncrna discoveries from various complete genomes  <cit> . while these methods are so efficient that they can be applied to genome-scale analysis, sequence-alignment-based methods need a pre-computed alignment as an input data. in other words, they implicitly assume that an adequately accurate rna sequence alignment can be obtained by using pure sequence alignment method  which does not explicitly consider conserved secondary structure. although this assumption is acceptable for the rna sequences with relatively high sequence identity, sequence-alignment-based methods can fail to indentify the ncrnas with low sequence identity; this is because conserved secondary structure should be taken into account to accurately align structured rna sequences which are poorly conserved at sequence level.

finding related structured rna sequences with low sequence identity from genomic sequences is more challenging compared to the case of high sequence identity. this is mainly due to the high computational complexities of structural rna sequence alignment algorithms which explicitly take secondary structure into account . for example, the computational complexities of sankoff's algorithm which is the most basic algorithm for structural rna sequence alignment are o in time and o in space, where n and m are the length and the number of rna sequences to be aligned, respectively  <cit> . even when one performs pairwise alignment, sankoff's algorithm needs o in time and o in space. to improve the computational speed and memory usage of structural rna sequence alignment, various variations of sankoff's algorithm have been intensively studied  <cit> .

so far, dynalign  <cit>  and foldalign  <cit>  which are variations of sankoff's algorithm, have been applied to the pairwise comparative genomics for novel ncrna discoveries <cit> . indeed these 'structure-based' ncrna finders have successfully predicted a number of ncrna candidates with low sequence identities, these calculations needed long computational times and large computational resources. although these programs have been updated recently and the latest versions are faster compared to their older versions, it is still time consuming to apply these programs to genome-scale applications. recently an efficient structural rna sequence alignment algorithm, locarna, has been proposed <cit> . to our knowledge, however, there is no report related to the ncrna discovery by using locarna. since genomic scans by previous structural rna sequence alignment methods are time consuming and need large computational resources in general, further development of efficient and accurate structural rna sequence alignment algorithm is important to accelerate the genome-scale prediction of the ncrnas with low sequence identities. recently, cmfinder, which is structural rna sequence alignment algorithm not for pairwise but for multiple rna sequence alignment, has successfully predicted a number of novel structured rna motifs from the encode regions with low sequence identities  <cit> .

in the present paper, we propose an improved genetic algorithm , cofolga <dig>  for structural rna pairwise alignment which uses the base pairing probabilities  by rnafold <cit>  to evaluate the structural term of the objective function instead of directly using the free energy parameters as its version  <dig> does  <cit> . since the present algorithm is efficient in both time and memory usage, we applied the algorithm to the pairwise comparisons between eukaryotic complete genomes to search for novel ncrna candidates from low sequence identity regions. the rest of the present paper is organized as follows. first we describe the present structural rna sequence alignment algorithm and a strategy for our comparative genomics in the 'methods' section. in the next section, we show the results of the benchmark and the comparison between the present algorithm and previous ones, discussing the performance of our alignment algorithm. finally, we present the detail of the ncrna candidates obtained by the pairwise genome comparisons between s. cerevisiae and other six fungi.

methods
in cofolga <dig> algorithm, we employ a ga to search for the optimal solution of structural rna pairwise alignment. cofolga <dig> is an updated version of the previously proposed ga  <cit>  which performs structural rna pairwise alignment based on minimization of free energy and the ga frameworks proposed in raga  <cit>  . cofolga <dig> runs much faster compared to cofolga1; this is mainly due to the improvement in the formulation of objective function and introduction of a new technique for random alignment generation. in standard ga, various ga operators  are iteratively applied to a population of individuals  to search for the optimal solution with the highest value of a given objective function   <cit> . in the cofolga algorithms, an individual of ga is represented by a pairwise alignment. this is because structural rna sequence alignment problem can be decomposed into sequence alignment and alignment folding, and the optimal alignment folding is uniquely defined for a given alignment. as a result, the conformational space to be explored in the present structural rna pairwise alignment is reduced to that of non-structural pairwise sequence alignment.

the of of cofolga <dig> is represented by the following formula:

  f = s + wp, 

where s is a sequence alignment score, p is a term for consensus secondary structure; w is a parameter for controlling the weights of s and p.

for a given pairwise alignment of rna sequence a and b, the p in equation  <dig> is evaluated as follows.

first an averaged bpp matrix b is constructed:

  bij={/2pkilja≠0andpminjb≠00otherwise. 

in equation  <dig>  bij is the matrix element of b, where i and j indicate the column positions in the pairwise alignment; ki and lj  are the nucleotide positions in sequence a  corresponding to column position i and j in the pairwise alignment, respectively. the bpps of single sequence a and b, pkla and pmnb, are computed by rnafold  <cit> . secondly, the p is evaluated by taking a summation of the elements in matrix b:

  p=∑i<jbij. 

it is noteworthy that equation  <dig> can be applied to any type of pseudoknotted structure without modification. this means that once the bpp matrixes taking pseudoknots into account are given, cofolga <dig> algorithm can perform structural rna sequence alignment of pseudoknotted rnas without an increase of computational costs compared to the case of non-pseudoknotted rnas.

the flowchart of cofolga <dig> algorithm is shown in figure  <dig>  in accordance with the standard ga, first, initialization is done to randomly generate an initial population, and then evaluation and reproduction procedures are iteratively performed to update the population. this iteration stops when the number of iterations reaches a user-defined maximum number or when no improvement has been observed for a user-defined number of iterations.

as mentioned above, cofolga <dig> was developed based on cofolga <dig>  in the following subsections, we will focus on explaining the detail of algorithms newly introduced for cofolga <dig>  algorithmically common parts between the two versions will be briefly explained.

initialization
an initial population of solutions is generated by adding a randomly generated pairwise alignment to the population one by one until the number of individuals reaches a user-defined population size. the random pairwise alignments are computed by using weighted stochastic backtracking . in weighted stochastic backtracking, the randomness of the alignment can be controlled with a 'noise' parameter where larger noise gives more randomized alignment; based on our experience, we used noise =  <dig>  –  <dig>  to obtain random alignments.

in addition to the random alignments, a non-random alignment taking structure information into account  and a non-structural needleman-wunsch alignment  <cit>  can also be included in the initial population through a command line option . when invoked with the '-nrd' option, cofolga <dig> works as a refinement program which improves the two non-random alignments. inclusion of the non-structural alignment improves the quality of the alignments with a relatively high sequence identity. in the default setting of cofolga <dig>  duplicated individuals in one population are not allowed throughout the run.

weighted stochastic backtracking
in the initialization step of the alignment algorithms utilizing ga such as saga  <cit>  and raga  <cit> , it is necessary to generate a number of random alignments. for example, in raga algorithm, random pairwise alignments are computed by using a dynamic programming with added noise  in which random alignments are obtained by adding small random noises to each dp matrix elements  <cit> . since dpan constructs a dp matrix in accordance with non-structural needleman-wunsch algorithm, structural information is completely lacked in such a calculation. to obtain a better initial guess for the structural rna sequence alignment, structural information should be taken into account.

to generate random pairwise alignments which reflect structural information, we developed weighted stochastic backtracking. in this algorithm, first, we construct the dp matrix for a pairwise alignment according to stral algorithm  <cit> . stral algorithm is an efficient structural alignment algorithm, and it was derived from an affine gap version of needleman-wunsch algorithm  <cit> . an essential difference between stral and the needleman-wunsch algorithm is their similarity scoring scheme. in stral algorithm, the following similarity score sij is used when constructing the dp matrix for pairwise alignment instead of the nucleotide substitution matrix d  alone:

  sij=α+dμiaμjb 

  κix=∑k<ipikx,λix=∑k>ipikx, 

  μix=1− 

where sij indicates the similarity score between position i of sequence a and position j of sequence b, and α is the ratio of structure over sequence similarity. nucleotide substitution matrix element d is the substitution score between the ith nucleotide of sequence a and the jth nucleotide of sequence b. in the present study, we used ribosum85- <dig>  <cit>  for d and α =  <dig>  which was taken from the stral paper  <cit> . base paring probability vectors κix, λix, and μix are the probabilities defined for the position i of sequence x  which represent probabilities of being paired upstream, paired downstream, and unpaired, respectively. the affine gap penalties which we used for weighted stochastic backtracking are also taken from the stral paper  <cit> .

after the construction of the dp matrix, we backtrack the dp matrix in accordance with a roulette wheel selection. roulette wheel selection is a selection method frequently used in gas, in which one of all choices is randomly chosen in accordance with the probability proportional to the size of a virtual 'slot' assigned to the choice.

the size of the slots is determined by the following scaling function:

  sloti=noisehmax⁡−hi+noise, 

where index i corresponds to a backtracking path at a node of the dp matrix , hi is the score difference between the current node and the neighboring node for path i, and hmax is the largest hi among h <dig>  h <dig>  and h <dig>  larger noise parameter noise generates a more randomized alignment. a backtracking path is chosen in accordance with backtracking probability πi which is defined as follows:

  πi=sloti/∑i= <dig> ,3sloti 

while backtracking, a real random number ranging from  <dig> to  <dig> is generated at each node and used to select a next path to be backtracked.

in figure  <dig>  the curves drawn by the scaling function are plotted. as can be seen from the figure, higher noise increases the probability to choose low scoring paths, while noise →  <dig> means the optimal alignment. thus, the randomness of weighted stochastic backtracking is controllable through the single parameter noise. it is noteworthy that the principles of weighted stochastic backtracking can easily be applied to any type of dp algorithm, e.g. those of nussinov's algorithm  <cit>  and sankoff's algorithm  <cit> .

evaluation
the of, f in equation  <dig>  of each individual is evaluated in this step, where the alignment score s is calculated by using the ribosum85- <dig>  <cit> . opening and elongation gap penalties are left as free parameters. after the evaluation of the of, the fitness of each individual is computed from the of as fitness = of - , and then a selection probability proportional to the fitness is calculated for each individual. the selection probability is used in reproduction step as the size of virtual slots for the roulette-wheel selection of parent individuals.

reproduction
in reproduction step, half of the population with the lowest ofs is replaced by new child individuals. the child individuals are generated by applying ga operators to the parent individuals randomly selected from the population. we use a modified set of the ga operators taken from cofolga <dig> <cit> , which is comprised of two crossovers  and three mutations . each ga operator is invoked with an equal probability and applied to one or two randomly selected parent individual; the crossovers need two parents, while the other operators are applied to a single parent. selection of parent is performed by roulette-wheel selection where the selection probability of each individual is used as the size of the slots. the ga operators are schematically illustrated in figure  <dig>  crossover operators construct a new alignment by concatenating 'alignment blocks' taken from two parent individuals. gap-block shuffling operator 'shuffles' a gap block  by a random shift size in a random direction. the maximum size of the gap shift is defined by shift size parameter max_shift.

in 'local re-alignment with weighted stochastic backtracking', a randomly selected small region of the alignment is re-aligned using weighted stochastic backtracking. the region to be re-aligned is selected by the following gap-sensitive procedure. first, we initialize ρ =  <dig> for all i, where i indicates the column position of the alignment. secondly, we scan the alignment with a sliding window of w columns. while scanning the alignment, we count the number of gaps in each window and add the number to the ρ whose i is the center of the sliding window. thirdly, a column position k is randomly selected in accordance with the probability proportional to ρ. finally, we define the region to be re-aligned around the k. the width of the region is randomly determined between lmin and lmax. when we meet a trivial case , this operator is rejected and a next ga operator is randomly invoked. in this procedure, the w, lmin and lmax are the parameters to be given by user.

in general, ga has several free parameters such as population size and iteration number which have to be given before execution. to reduce the number of such free parameters, we introduced unification parameter l. this l defines several parameters for the ga operators simultaneously through the following relationships: max_shift = lmax = l and lmin = / <dig> = ⌊l/2⌋. hence once l is given, max_shift, lmax, lmin, and w are determined and only l is left as a free parameter. unification parameter l controls the degree of modification, i.e. larger l leads to a wider search in the conformational space by the mutation operators. it is noted that too large l can cause a slow convergence of the ga.

in the nomenclature of the ga operators, a 'greedy' means that the operator increases the of of the child individual compared to that of its parents. cofolga <dig> uses 'greedy' operators while cofolga <dig> uses 'semi-greedy' operators. the 'greedy' operators of cofolga <dig> reject the child individuals which do not satisfy  > ) while the 'semi-greedy' operators of cofolga <dig> does not. cofolga <dig> does not utilize 'anchor point for mutation operators' which is used in cofolga <dig> to avoid gap insertion into highly conserved regions of an alignment . local cofolga operator  is also not used in cofolga <dig> 

consensus structure prediction by a postprocessing
cofolga <dig> predicts the consensus secondary structure for the final alignment by backtracking in the averaged bpp matrix as a postprocessing of the ga procedures. to more accurately predict a consensus secondary structure based on the alignment computed by cofolga <dig>  it is better to use an alignment folding program such as rnaalifold  <cit>  or pfold  <cit>  as a postprocessing.

measures for assessing alignment quality
the quality of pairwise alignments was assessed with structure conservation index  and sum-of-pairs score . sci and sps were evaluated by rnaz  <cit>  and bali_score.c  <cit> , respectively.

determination of the free parameters
in addition to the population size and maximum iteration number of the ga, cofolga <dig> has six free parameters: cmax, noise, w, gap opening and elongation penalties for s, and l . we optimized these six parameters with fourteen pairwise alignments taken from the k <dig> dataset of bralibase  <dig>   <cit> . the training rna sequences are trnas, 5s rrnas, and srp rnas with high or low sequence identities and high or low scis. for trna, alignments with a moderate sequence identity were also used. the file names of the rna sequences are listed in additional file  <dig>  the parameter space to be explored was represented by a coarse grid and the parameter set corresponding to the grid point which scored the highest  ×  was adopted as the optimal parameter set . throughout this optimization, we used a population size and maximum iteration number fixed to relatively large values,  <dig> and  <dig>  respectively. the results presented at the results and discussion section were obtained with this optimal parameter set. the population size and maximum iteration number are left as free parameters.

benchmark and comparison of alignment quality
we performed an alignment quality benchmark using bralibase  <dig>   <cit>  from which rna sequence pairs and their reference alignments were taken. in addition, we performed performance comparison with other structural and non-structural sequence alignment programs using the benchmark. in the performance comparison, we compared cofolga <dig> with five structural and three non-structural alignment methods. the programs and command line options are summarized in table  <dig>  to perform the comparisons on an equal footing, global alignment mode was used for local alignment programs, foldalign and locarna.

in this table, 'program' and 'version' columns indicate program names and their versions, respectively. in 'command' column, executable file names and options we used are listed. in 'structural?' column, 'yes' indicates structural rna sequence alignment program, and 'no' represents non-structural sequence alignment program. rnaz  <dig>  with a default setting was applied to the alignments provided by mafft and clustalw.  dynalign version  <dig>   was used for the alignment quality benchmark, and dynalign version  <dig>   was used for the ncrna prediction benchmark, where we used the values recommended by dynalign for the other parameters except for the maximum number of structures =  <dig>  the parameters and file names were written in opt_file and used to run dynalign.

benchmark for the sequence pairs with low identities
in addition to the bralibase  <dig>  benchmark, we have performed a benchmark with the sequences which have identities ≤ 40% and lengths of  <dig> to  <dig> nt. the sequences were extracted from the internal transcribed spacer  <dig>  database  <cit> , where the sequences and annotated structures of stramenopiles and "the original  <dig>  sequences and structures"  were used. sequence identities were measured after aligning two its <dig> sequences using mafft . we have performed non-redundant processing with a cutoff of 90%id. as a result, we obtained twenty-five its <dig> sequence pairs ; the average sequence identity of the dataset is 33%. this benchmark was performed for cofolga <dig>  foldalign  <dig> . <dig>  and locarna. since annotated secondary structures are given in the its <dig> database and reference alignments are not provided, the prediction accuracy for this benchmark was measured based on how correctly annotated  base pairs are predicted. the correctness of the predicted base pairs was assessed with the approximated matthews correlation coefficient , cc, proposed by gorodkin et al..

svm classification between true ncrnas and shuffled data
to predict ncrnas on the basis of the pairwise alignment computed by cofolga <dig>  we trained svm by using a svm package software, livsvm   <cit> . the elements of the feature vector for the svm are as follows: of, alignment length, and a, c, and u frequencies of the two sequences. these quantities except for the of were calculated after eliminating all gapped columns of the alignment. the alignments <  <dig> nt were removed from the input before svm processing. this format of the feature vector is taken from the paper describing the ncrna finding by dynalign  <cit> . we use a default kernel , and the prediction result of the svm is outputted as a classification probability. to construct positive training and test datasets, we extracted  <dig>  pairwise alignments from the k <dig> dataset of bralibase <dig>   <cit> . the sequence identity of this dataset ranges from 16% to 75% and the dataset comprises thirtytwo rna families. this original dataset was divided into two sub-datasets in a ratio of 1: <dig> . negative data were generated by removing all gapped columns of the positive alignments and shuffling the gap-free alignments. two negative alignments were generated for each positive alignment, consequently we obtained  <dig>  negatives for training and  <dig>  negatives for test. the shuffling was performed by shuffle-aln.pl  <cit>  with a '-m complete' option. after the training, we obtained a test accuracy of  <dig> %.

visualization of ncrna prediction performance
when the performance of prediction methods depends on their own cutoff value, comparison of the methods becomes not straight forward, since varying the cutoff value leads to a simultaneous change of sensitivity and specificity .

in the present study, we used receiver operating characteristic  curve for visualizing the tradeoff between sensitivity and specificity for a range of cutoff value. the roc curve has been used by uzilov et al. to compare the performance of ncrna finders  <cit> .

roc curve is defined as sensitivity vs false positive rate plot; sensitivity and false positive rate are defined as follows:

  false positive rate==fptn+fp,sensitivity=tptp+fn,specificity=tntn+fp, 

where, tp, fp, tn and fn are the number of true positives, false positives, true negatives and false negatives, respectively. in the case of comparative ncrna prediction, sensitivity indicates how many positive alignments  are correctly predicted as ncrna; false positive rate represents how many negative alignments are misclassified as ncrna. for example, false positive rate = 1% means that one false positive is found when we evaluate  <dig> negative alignments.

genome sequences
the genome sequences  of s. cerevisiae and the contigs of other six fungi  were downloaded at saccharomyces genome database   <cit> . annotated fasta files for s. cerevisiae  were also downloaded at sgd. we masked the genome sequences of s. cerevisiae according to the other_features_genomic.fasta file to remove repetitive sequences from the genome sequences.

pairwise comparison of genomic sequences
to efficiently search for ncrna candidates with low sequence identity, we focused on our scan to the relatively short  low-identity regions located between two regions which are conserved at sequence level. by exploring the regions neighboring such conserved regions, we can expect to find the ncrnas hidden in a conserved synteny. the conserved regions were detected by using wu-blast  <cit>  comparison  between s. cerevisiae and the other fugal genomes. then we constructed 'target regions', which are the regions scanned by cofolga <dig>  as follows. first, the s. cerevisiae genome sequence was divided into intergenic , orf_coding, and rna_ coding sequences in accordance with the annotations in sgd  <cit> . then target region was defined for each divided s. cerevisiae sequence as illustrated in figure  <dig> if the divided sequence overlaps the low-identity region located between the conserved regions. as a result, the target regions which we obtained by the wu-blast comparison cover  <dig> , <dig> bp of the s. cerevisiae genome .

the present approach for generating the target regions is similar to that used in the genome comparison between human and mouse by torarinsson et al.  <cit> . compared to their approach, however, ours is more conservative since it requires the target regions to be sandwiched by two conserved regions, while torarinsson et al. scanned the regions neighboring to singly conserved regions. in other words, our definition is a subset of that of torarinsson et al..

we scanned each target region using a dual sliding window according to the following procedure. let us call the two genome sequences belonging to a target region genome a and genome b. subsequences were generated by moving a sliding window of  <dig> nt with a shift size of  <dig> nt on each genome sequence, and then all-vs-all pairwise alignment between the subsequences of genome a and those of genome b was performed with cofolga <dig>  after the comparison, each pairwise alignment was processed by the trained svm to assign a svm classification probability to discriminate whether the pairwise alignment contains ncrna candidates or not.

RESULTS
convergence test with respect to ga population size and iteration number
to know how the ga population size and iteration number affect the alignment quality, we studied the population size and iteration number dependence of the cofolga2's performance, where we define population size = iteration number to reduce the number of free parameters. figure  <dig> shows the  ×  for the fourteen sequence pairs in additional file  <dig> as a function of population size. as can be seen from the figure, the  ×  is almost saturated between population size  <dig> and  <dig>  based on this observation, we used population size  =  <dig> for the benchmarks and ncrna discovery in the present study.

rna alignment benchmark and performance comparison with other methods
since ga is a sampling method utilizing random number, it is important to know how an initial random number affects the alignment quality. to examine random number dependence of cofolga <dig>  we performed five independent runs for the k <dig> dataset with different initial random numbers. as a result, we confirmed that the differences between the benchmark results due to the difference in initial random number are very small for a wide range of sequence identity .

in the benchmark with the its <dig> dataset, we found that cofolga <dig> showed the best performance .

computational time and memory usage
the computational times  measured for cofolga <dig> and other structural rna sequence alignment methods are shown in figure  <dig>  the computational times were measured with a xeon pc .

for the rna families shorter than approximately  <dig> nt, foldalign showed computational times comparable with cofolga <dig>  for longer rna families, foldalign was much slower than cofolga <dig> except for k_ chan_ res . the computational times of dynalign were in general much longer than the other methods in the present benchmark. in addition, the computational times of foldalign and dynalign were not scaled monotonically with respect to sequence length. this could be due to the pruning algorithm of foldalign and the constraint used in dynalign, i.e. when these accelerators do not work well the programs become slower.

locarna was faster than cofolga <dig> up to approximately  <dig> nt. for longer rna families, however, the computational time of locarna became comparable with or longer than that of cofolga <dig>  e.g. average computational times of cofolga <dig> and locarna for cobalamin  were  <dig>  sec. and  <dig>  sec., respectively.

to examine the memory usage of cofolga <dig>  we performed a structural alignment of two srp _euk _arch rnas, ap <dig>   and ac <dig>   taken from the bralibase  <dig>  k2-dataset . since this computation is one of the largest calculations in the present study, we can estimate the upper bound of the memory usage from the result. consequently, we found that cofolga <dig> needs only  <dig>  mb ram to perform the calculation. this memory usage is smaller than or comparable with those of other latest structural rna sequence alignment methods. according to literature  <cit> , foldalign  <dig> . <dig>  dynalign  <dig> , and locarna  <dig>  need at least  <dig> ,  <dig> , and  <dig>  mb ram, respectively, to align the 5s rrnas with an average sequence length of  <dig>  nucleotides.

svm training results and ncrna prediction benchmark
in figure  <dig>  roc curves by cofolga <dig>  rnaz, and dynalign are plotted. to make the plot, first we ran each alignment program for the svm test data, and then extracted the pairwise alignments satisfying  ≥  <dig> nt and %id ≤ 50%, where the sequence identity based on the bralibase  <dig>  alignments was used. as a consequence, each roc curve was drawn based on approximately  <dig>  rna alignments. in figure  <dig>  "clustalw+rnaz" indicates that an alignment is constructed by clustalw and then the alignment is evaluated by rnaz to predict whether the alignment contains ncrna candidates or not. we used clustalw and mafft to construct input pairwise alignments for rnaz, since clustalw is the standard sequence alignment program and mafft is the best non-structural sequence alignment method in accordance with the previous benchmark performed with bralibase  <dig>   <cit> . in our comparison, we ran dynalign  <dig>   not with the original svm model trained in  <cit> , but with a svm model which was re-trained with the training dataset for the svm model of cofolga <dig>  this is because the original svm model of dynalign was trained with only trna and 5s rrna sequences, and the dynalign with the original svm model showed a poor prediction performance  in our benchmark where more rna families are included. in addition, we did not include foldalign in the ncrna prediction benchmark using bralibase  <dig> , since the ncrna prediction by foldalign needs flanking sequences of a ncrna sequence to obtain a statistical value  <cit> , and the ncrna sequences of bralibase  <dig>  do not have flanking sequences. as can be seen from figure  <dig>  cofolga <dig> outperformed rnaz when sequence identity is lower than 50%. although the re-trained dynalign showed better prediction results compared to cofolga <dig>  dynalign was much slower compared to cofolga <dig> 

when one performs a genomic scan, it is important to use a cutoff value which gives a very low false positive rate, since genome-scale calculations usually process a number of sliding windows containing negative data. to reduce the false positive rate as small as possible, we chose a cutoff psvm =  <dig>  whose sensitivity and false positive rate are  <dig> % and  <dig> %, respectively. cofogla <dig> with this cutoff psvm gives a better false positive rate compared to rnaz .

comparative prediction of yeast ncrnas
we obtained  <dig>  target regions whose average sequence lengths for s. cerevisiae and the other fungi are  <dig> bp and  <dig> bp, respectively. these target regions cover  <dig> , <dig> bp of s.cerevisiae and  <dig> , <dig> bp of the other fungi. after processing the  <dig> , <dig> sequence pairs  by cofolga <dig> and the svm we trained, we obtained  <dig>  pairwise alignments which have svm probabilities ≥  <dig> . the s. cerevisiae sequences of the obtained pairwise alignments were clustered into 'ncrna candidate regions' by a single linkage clustering, where overlapped or neighboring sequences are clustered. the ncrna search in yeast  took approximately twenty days. the obtained candidate regions are summarized in table  <dig>  as shown in the table, we found ncrna candidates at  <dig> intergenic regions,  <dig>  protein-coding regions, and twenty known ncrna regions in the s. cerevisiae genome. based on the total number of alignments processed by cofolga <dig> and the false positive rate  obtained in the benchmark, we estimated the number of false positive alignments =  <dig>  leading to / = 51%. this value is almost same with the corresponding value obtained in the human ncrna finding by cmfinder  <cit> .

the 'int', 'orf', and 'rna' columns indicate the number of ncrna candidate regions for the s. cerevisiae intergenic, orf-coding, and known rna sequences, respectively. in parenthesis, their total length  is shown. the 'organism' column indicates the counterpart of each genome comparison. the 'all' rows are the summary for all genome comparisons after eliminating positional overlaps. pcutoff is a cutoff value for the svm classification probability. in this table, the results for pcutoff =  <dig>  and pcutoff =  <dig>  are shown.

in the present predictions, we obtained  <dig> intergenic regions,  <dig> protein-coding regions, and  <dig> known ncrna regions as ncrna candidates , which overlap at least one of the previous rnaz and qrna predictions; where we classified a candidate as an "overlapped" region if ≥ 10% of the nucleotides of the candidate overlaps an rnaz or qrna prediction. relatively small overlaps between our ncrna candidates and those by rnaz and qrna are not surprising because our method does not require sequence conservation of ncrna candidates while rnaz and qrna directly utilize the sequence similarity between ncrna candidates. for example, the lowest sequence identity in the alignments containing our ncrna candidates was 15% .

the 'rnaz' and 'qrna' columns indicate the number of the present s. cerevisiae ncrna candidates overlapping with those by rnaz  <cit>  and qrna  <cit> , respectively. in parenthesis, the total length  for each region is mentioned. when ≥ 10% of the nucleotides of a ncrna candidate overlaps the rnaz or qrna prediction, we included the ncrna candidate in the overlapped ncrna candidates. the 'cofolga' column indicates the ncrna candidates predicted by cofolga <dig> alone, i.e. novel ncrna candidates obtained in the present study. since the ncrna candidate list of qrna  does not contain strand information, we took only positional overlap into account when we examine the overlaps between the present ncrna candidates and those by qrna.

the target regions we obtained includes  <dig> known ncrnas. of these, eighteen loci were included in the alignments with psvm ≥  <dig> . the detail of the predicted known ncrnas is summarized in additional file  <dig>  an estimated sensitivity for the ncrna prediction calculated based on this observation is approximately 22%. it is noteworthy that cofolga <dig> correctly predicted the strand of fifteen known ncrnas, i.e. correct strand was assigned to approximately 83% of the eighteen known ncrnas. in these strand predictions, we adopted the strand with the highest psvm when psvm ≥  <dig>  was assigned to the both strands.

the number of the predicted ncrna candidates which overlap the loci of experimentally determined transcripts in literature. in parenthesis, the total length  for each region is mentioned. since the transcript list provided by davis et al.  does not contain strand information, we took only positional overlap into account when we examine the overlaps between the present ncrna candidates and the transcripts reported by davis et al..

recently, the ncrnas found in protein-coding regions have been reported. in our prediction, we obtained more than one thousand ncrna candidates in protein-coding regions. in these,  <dig> candidates are predicted at sense strand, and  <dig> candidates were predicted at antisense strand. one ncrna candidate  simultaneously overlaps two protein-coding genes as sense and antisense since these two protein-coding genes overlap each other.

the detail of our prediction results and annotations can be browsed at our web server  <cit>  in which the prediction results are retrieved through mysql queries.

ncrna candidates conserved among multiple sequences
by manually inspecting our prediction results, we found four intriguing examples containing conserved secondary structures across multiple species/sequences which have characteristic secondary structures in spite of their low average sequence identities. figure  <dig> shows the alignment and structure of an intergenic s. cerevisiae sequence and two paralogous sequences of s. mikatae taken from the ncrna candidate sc000056i. since genomic separation between these two s. mikatae sequences are small , these two s. mikatae sequences are a possible ncrna cluster. figure  <dig> shows the s. cerevisiae sequence of an intergenic ncrna candidate  which was found at  <dig>  bp to  <dig>  bp of chromosome  <dig> and aligned with the sequences of s. mikatae and s. paradoxus. as can be seen from figures  <dig> and  <dig>  these ncrna candidates reveal characteristic consensus secondary structures in spite of their low average pair sequence identities .

the ncrna candidate sc000983f is one of the longest regions predicted in the present study. this candidate contains a consensus secondary structure motif shared by three species . in addition to the structure shared by three species, ncrna candidate sc000983f contains a relatively long  secondary structure  conserved between two species . it is noteworthy that almost all sequences contained in sc000983f are antisense sequences. the sequences of s. cerevisiae are antisense sequences of a gene cln <dig> coding g <dig> cyclin which is involved in regulation of the cell cycle, and the sequences of s. kluyveri and s. kudriavzevii are antisense sequences of predicted orfs according to the sgd annotation. these results imply that this ncrna candidate is a functional antisense ncrna with characteristic secondary structures.

the s. cerevisiae sequence of ncrna candidate sc01074f is located at the sense strand of pms <dig>  a verified orf coding an atp-binding protein. the sequences of s. paradoxus and s. bayanus, which overlap the predicted orfs of each genome according to the sgd annotation, are structurally aligned to the s. cerevisiae sense sequence in sc01074f . these sequences are new candidates of functional rna secondary structure within a coding region such as the localization elements of ash <dig> which do not show sequence conservation but harbor conserved rna secondary structure  <cit> . the multiple alignments for sc000056i, sc000383i, sc000983f, and sc001074f were constructed by manual operation  based on the pairwise alignments by cofolga <dig>  since the progressive multiple alignment using cofolga <dig> has not fully tested yet, we didn't benchmark it in this paper. the figures of consensus secondary structure and alignment were drawn by processing the multiple alignments at rnaalifold web server  <cit> .

the examples described in this section  have at least one experimental evidence for their expression according to the tilling array/cdna data in literature  <cit> .

CONCLUSIONS
as can be known from a number of recent papers describing various structural rna sequence alignment programs, it is a difficult problem to find a good rna alignment with low sequence conservation. in the present study, we developed a new efficient ga for constructing structural rna pairwise alignment with a new objective function and random alignment generation algorithm. the new ga is accurate and efficient in both time and memory usage, hence we applied it to the comparative ncrna discovery between s. cerevisiae and related species using a svm trained with the sequences and alignments taken from bralibase  <dig> . as a result, we successfully obtained ncrna candidates located at  <dig> intergenic regions and  <dig>  protein-coding regions including antisense sequences, > 92% of which is novel candidates since they show no overlaps with the genomic positions of the previous predictions and known ncrnas. indeed, our approach is not suitable for identifying all ncrna sequences embedded in a genome, it gives a valuable tool complementary to the sequence-alignment-based ncrna finders such as rnaz and qrna, since the present method often found the ncrna candidates which cannot be found by such sequence-alignment-based ncrna finders. the results of the present study indicate that still a number of structured rna transcripts with significant structural and evolutional signals is hidden in genomic sequences, and further exploration for novel ncrnas using computational methods is inevitable to unveil the rnomics of genomes.

availability and requirements
non-profit, academic users can download and use the executable files at the cofolga <dig> website  <cit> .

supplementary material
additional file 1
the file names of the rna sequence pairs used in the ga parameter determination and memory usage test. the top fourteen files were used for the ga parameter determination and convergence test. the other one  was used only for examining the maximum memory usage.

click here for file

 additional file 2
initial random number dependence of the benchmark result. the benchmark results for the bralibase <dig>  k2-dataset with five different initial random numbers. the results denoted by r =  <dig> are same with those of figure  <dig>  since it is a default value. in addition, this figure includes the result obtained with a larger population size  with r =  <dig> 

click here for file

 additional file 3
known ncrnas predicted in the present comparative genomics. the 'id' column indicates the index assigned for the predicted ncrna candidates in the present study. the 'same/diff' column shows whether the strand of known rnas are correctly predicted or not, where 'same' and 'diff' indicate "strand is correctly predicted" and "not correctly predicted", respectively. for snr <dig> and nme <dig>  both strands are predicted as ncrna candidates. the 'chr.', 'begin', 'end', and 'strand' columns give the genomic positions and strand of the ncrna candidates. the 'rna name', 'sgdid', and 'sgd annotation' columns correspond to ncrna gene names, ids, and annotations given in sgd, respectively.

click here for file

 additional file 4
consensus structure and alignment of a sequence pair taken from ncrna candidate sc000983f. this alignment is composed of a sequence of s. cerevisiae  and a sequence of s. kudriavzevii . the sequence identity of this alignment is 32%.

click here for file

 acknowledgements
this work was partially supported by the ministry of education, science, sports and culture, grant-in-aid for young scientists ,  <dig>  2005– <dig>  grant-in-aid for young scientists ,  <dig>  2007– <dig>  grant-in-aid for scientific research ,  <dig>  2006– <dig>  and a "grant for priority research designated by the president of hirosaki university".
