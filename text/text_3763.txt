BACKGROUND
the overall principles behind the translation of a gene sequence into an active protein structure are theoretically well understood. the sequence of nucleotides that forms a gene is first translated into a sequence of amino acids, based on the genetic code. the corresponding linear chain of amino acids becomes active only after it folds into a three-dimensional shape, the so-called tertiary structure of the protein . however, while we can easily observe experimentally how the linear chain folds, we do not understand the principles underlying that transition. for instance, the rules that reveals the three-dimensional structure of a protein from its amino acid sequence have not yet been unraveled. finding these rules is in fact one of the “holy grails” in molecular biology, namely the protein structure prediction problem  <cit> . efforts to solve this problem currently emphasize protein sequence analysis, as a consequence of the wealth of sequence data that is available. we know the primary sequences of many proteins, with currently more that  <dig> , <dig> sequences in the trembl database  <cit> , we know in some cases the corresponding three-dimensional structures of these proteins, with more than  <dig>  in the protein data bank  <cit> , and we have information on their biological activities, with more  <dig>  sequences that have been annotated in swissprot  <cit>  . however, we are still far from understanding all the information encoded in these databases. in this paper, we address the problem of protein sequence comparison in the context of protein fold recognition, and show that a new string kernel drastically improves the latter compared to traditional methods based on sequence alignment.

amino acids are usually described using a one-letter code, and protein sequences are correspondingly represented as strings of letters. this representation has proved very useful, especially in the context of sequence alignment  <cit>  that is usually performed using string-matching algorithms  <cit> . those methods represent the overwhelming majority of methods used for sequence comparisons in bioinformatics. when comparing two sequences, they proceed in two steps, first the generation of the alignment between the two sequences, then the derivation of a statistical score for that alignment. they rely on a weighting scheme to measure the cost of matching pairs of amino acids. many such weights have been proposed, from substitution matrices derived from evolution models such as the pam matrices  <cit>  and the blosum matrices  <cit> , to matrices that capture physico-chemical properties of amino acids  <cit> . using this score, an alignment is derived following a dynamic programming algorithm, either the local method of smith and waterman  <cit> , or the global method of needleman and wunsch  <cit> . this alignment is then scored by summing the individual weights of the matching pairs of amino acids and adding penalties for the presence of gaps. it should be noted that this score is not a metric in sequence space. statistical methods have been developed to assess the significance of such scores, both for gapped and non-gapped alignments . such statistical scores are widely used for the identification of homologous sequences or for fold recognition. it has been shown however that those scores are efficient for both tasks for sequences with high similarities, but often fail for dissimilar sequences . extensions to pair-wise alignment methods have been proposed to alleviate this problem, such as those based on multiple sequence alignments and profiles  <cit> , and those based on hidden markov models  <cit> . while those show improved sensitivity, they remain prone to the problems related to the construction and use of alignments.

to circumvent the shortcomings of the alignment-based methods described above, many “alignment-free” methods have been proposed over the past three decades . most of these methods compute the frequencies of words of a fixed length, k, also denoted as k-mers or k-grams, depending on the authors. once the frequency distribution functions of such k-mers have been computed for two sequences, the distance between those two sequences is assimilated to the distance between those distributions, using different definitions of distance  <cit> . other methods identify word matches of different lengths  <cit> . one such method, the average common substring approach, identifies for each position i in one sequence the longest substring starting at i that is also present in the other sequence. the average lengths of those substrings over all positions i is a measure of similarity of the two sequences that can be converted into a distance  <cit> . all those methods are based on exact word matches. exact matches however are bound to have limitations, due to strong correlations between amino acids at neighboring positions. a solution to the limitations of exact matches is the spaced seeds method that defines patterns with “match” and possible “don’t care” positions, using the vocabulary introduced by the authors .

another class of alignment-free methods for comparing protein sequences that are directly relevant to this work includes string kernel based methods, originally defined in the context of support vector machines   <cit> . svm are machine learning algorithms that are designed to learn a rule for discrimination from a set of samples with two  labels. this rule can then be applied to predict the label of any new sample. a key element of any svm implementation is the kernel function that is used to quantify the similarity between any pair of samples. the simplest kernel function is the dot product between vectors of features that represent the samples. the first applications of svm with a kernel function that is used to compute the similarity between two protein sequences were based on an extension of the dot product concept. jakkola et al  <cit>  used a generative hidden markov model  on a set of proteins to generate a vector representation of each protein sequence . the kernel is then defined as a dot product between the corresponding fisher vectors. lodhi and colleagues introduced a string kernel that counts the number of occurrences of subsequences of a fixed length in the two strings that are compared  <cit> . the svm-pairwise method  <cit>  consists of describing each sequence with a vector of pairwise similarity scores for all domains in the training set , and defines the kernel to be the dot product between these vector representations. the spectrum kernel  <cit>  and the mismatch kernel  <cit>  measure the similarity between protein sequences by quantifying the number of similar short substrings  they share. these two kernels bear similarity with the word-based alignment-free methods described above. the weighted degree kernels extend those kernels by considering weighted sums of the individual kernels obtained with fixed length k-mers [33
,
34]. the local alignment kernel of saigo et al  <cit>  was designed to mimic the score generated by a smith and waterman pairwise alignment method, with the proper mathematical foundations to guarantee that it is a true kernel. more recently, smale and co-workers expanded the local alignment kernel by considering all possible alignments of k-mers between the two sequences of interest, for all possible k values, ignoring gaps when aligning the k-mers  <cit> . all the kernels listed here , have been tested in classification problems as part of a machine learning algorithm , with various levels of success.

this paper draws from the concept of string kernels listed above. it describes an alignment-free method for protein sequence comparison that is based on the string kernel introduced by smale and collaborators  <cit> . in contrast with the previous studies on string kernels, we do not include at this stage our string kernel into any learning algorithms. instead, we assess directly its ability to classify proteins into structural folds based on sequence information only. we note that the string kernel we consider  depends on two parameters, in addition to the substitution matrix it uses to score matches of pairs of amino acids . we provide an exhaustive analysis of the effects of these two parameters on the performance of the kernel for fold recognition. such an analysis, which is necessary as a first step to improving string kernel methods, was only partially included in the presentations of the equivalent kernels defined by saigo et al  <cit> , and by smale and co-workers  <cit> . in the latter study for example, one parameter, β , was fixed to  <dig> , without further explanation, while the second parameter, k
max, the maximum length of the k-mers considered, is set to a small number for computational considerations. finding how those parameters influence the performance of the kernel is the main focus of this paper. to perform this analysis, we consider different datasets of proteins that belong to different structural folds, as defined by cath  <cit> . these proteins were selected such that their sequences share little sequence similarities. we classified these proteins using the similarity measure provided by the string kernels. the classification is then compared with the corresponding results obtained using the scores of pairwise sequence alignments and the scores of structural alignments of those proteins. ultimately, we have observed that sequence alone provides poor separation of the different folds. we show in contrast that with the right choice of parameters, use of the string kernel similarity measure significantly improves classification accuracy. in addition, we illustrate the use of seqkernel to reconstruct a phylogenic tree of rna polymerases, in line with the current development of alignment-free methods for phylogenomics that are designed to remove problems inherent to  sequence alignments .

the paper is organized as follows. in “methods” section, we describe the string kernel, while in “results and discussion” section we describe the databases we have generated to assess the performance of our string kernel for fold recognition. in the results section, we provide a comprehensive analysis of the parameters that defined the kernel and finally we conclude the paper with a discussion on future developments of the string kernel approach.

methods
a string kernel for alignment-free sequence comparison
the string kernel considered here is inspired by the convolution string kernels introduced by d. haussler  <cit> , adapted by saigo et al  <cit>  as the local alignment kernels, and later by smale and co-workers  <cit> . we provide here the key elements of its construction. readers should refer to the original papers for a more detailed presentation, notably for the proofs of the mathematical properties that are relevant to kernels in general.


notations let x be a finite set of size n. a kernel k is a symmetric function from x×x to ℝ such that the gram matrix g of size n×n defined by g=k is symmetric, positive, and definite. let a be the set of the standard twenty amino acids found in proteins. a protein sequence s is a string of elements from a. we note |s| the length of s.


a kernel for amino acid pairs. let sa be a function from a×a to ℝ, such that s
a measures the similarity of the amino acids i and j, and let sm be the gram matrix associated to sa. examples of sm include the matrices representing the raw data of any blosum matrices  <cit> , namely the raw counts of how often amino acid i is substituted by amino acid j in a set of selected protein sequence alignments that is then normalized by considering its row sums p: 
  <dig> p=∑j=120smsm2=smpp 


we have checked that when sm is a raw count blosum matrix, then s
m <dig> is symmetric, positive, and definite. note that when sm is such a raw count matrix, the corresponding blosum matrix bl is defined as b
l=r
o
u
n
d)), where round is the function that rounds a real number to its nearest integer. given a strictly positive real number β, we define the function k1:a×a→ℝ as: 
  <dig> k1=sm2β 



k
 <dig> is a kernel function on a×a, as long as s
m <dig> is symmetric, positive, definite, and β is strictly positive. the same definition was used in  <cit> .


a kernel for comparing two strings of the same length. let k be a strictly positive integer and let ak be the k-th cartesian power of a. an element of ak is a string of k letters taken from a, it is usually referred to as a k-mer, or a k-gram. let u
k= and υ
k= be two k-mers in ak. the function k2k defined by: 
  <dig> k2k=∏i=1kk <dig> 


is a kernel on ak, the set of all k-mers. we note that k2k is a convolution kernel  <cit> .


a kernel for computing protein sequence similarity. let s= and t= be two protein sequences; both are strings, with s∈an and t∈am. let u
k and υ
k be substrings of length k  of s and t respectively. u
k and υ
k are considered contiguous, i.e. we do not allow gaps. there are therefore n−k+ <dig> and m−k+ <dig> such substrings in s and t, respectively. we define 
  <dig> k3k=∑uk∈s∑υk∈tk2k 


and 
  <dig> k3=∑k=1pk3k. 


where the summation extends to p= min,with n and m the lengths of the two sequences that are compared. finally, we define the correlation kernel k^ <dig> as: 
  <dig> k^3=k3k3k <dig> 


following  <cit>  and  <cit> , we make the following remarks: 
i) the input kernel matrix sm is not a traditional substitution matrix, as it does not involve applying the logarithm function on the probability measures. while the latter is needed to make scores additive, a necessary condition for the use of dynamic programming algorithms in generating pairwise sequence alignment, it is not needed for the string kernel we use here. note that this differs from the local alignment kernel, which is designed to mimic pairwise alignment.

ii) the kernel k
 <dig> is computed as an unweighted sum of the individual kernels k3k that are computed with a fixed k value. we could have considered a weighted sum instead, similar in spirit to the weighted degree kernels  <cit> . we leave this option for future work.

iii) the summation in eq.  <dig> extends to the length of the smallest sequence. this summation can be truncated however to only include k-mers up to a fixed length set to be k
max. this will be discussed in details.

iv) 
k^ <dig> is a kernel as long as s
m <dig> and β  are definite positive, and strictly positive, respectively. note that for any kernel k
 <dig> defined on a×a, we can define a correlation string kernel k^ <dig> 

v) as defined, k^ <dig> does not consider gap penalties, or even gaps. we consider this as an advantage, as it does reduce the number of parameters that defines k^ <dig> 

vi) the string kernel k^ <dig> is a similarity measure in the space of sequences. notice that for all sequences s, k^3= <dig>  this similarity measure can be transformed into a distance measure, using d=k^3+k^3−2k^3=2−2k^ <dig>  d takes values between  <dig> and  <dig> 




implementing the string kernel
equation  <dig> above leads to a simple, naive algorithm for computing the k
 <dig> kernel for two sequences s and t: for any length k, generate all n−k+ <dig> and m−k+1k-mers in s and t, and perform the  corresponding k2k kernel evaluations using eq.  <dig>  such an implementation however would come at a high computing cost, namely o, where n and m are the lengths of s and t and k
max is the longest k-mer considered. we notice however that for any k-mers
u
k and υ
k, we have: 
  <dig> k2k=k2k−1k <dig> 


where u
k− <dig> is the string of length k− <dig> formed from the k− <dig> first components of u
k . this simple recursion formula leads to a more efficient algorithm for computing the string kernel k
 <dig> of order o. we note that this complexity remains large for protein sequence comparison.

datasets of protein sequences
our first dataset includes  <dig>  domains from the cath  <cit>  v <dig>  domains, each with a cath classification. as we focus on protein structure fold prediction, we consider the first three layers of the cath classification, namely, class , architecture , and topology . a set of structures with the same c, a, and t defines a fold. by using a set of structures with significant sequence diversity, we ensure that the data is duplicate-free. such a filter when selecting the sequences also assures that the problem of detecting structural similarity is non-trivial. the  <dig> structures were selected as follows:  randomize the list of  <dig>  cath v <dig>  domains;  start with the first domain on the randomized list, and remove from the list all domains that share significant sequence similarity with it  and - <dig> ).  repeat step  with all domains in the list that have not yet been removed, until there are no domains left for selection. the set of  <dig> domains resulting from this procedure is referred to as cath40e <dig> 

there are  <dig> folds in cath40e <dig>  many of which only include a single representative . to improve statistical analysis and remove possible biases from those folds with a low number of representative, we selected five of the most populated folds in cath40e <dig> as a more specific test set, including at least one fold from each cath class: cath fold  <dig> . <dig>  a fully α fold , cath fold  <dig> . <dig>  a fully β fold , and three alternating α/β folds:  <dig> . <dig>  ,  <dig> . <dig>   and  <dig> . <dig> . the same five folds were previously used in other studies [44
,
45], but with different members as based on a different version of cath. overall, these five folds consist of a total of  <dig> proteins . table  <dig> provides general information about the distributions of proteins in those five folds, while fig.  <dig> illustrates the geometries of those folds, using the structure representatives defined by cath.
fig.  <dig> representatives of the five fold classes in our test set cath <dig>  the arc repressor mutant, subunit a fold  is a common orthogonal helix bundle, found, for example, in the zb domain from the rna editing human enzyme adar <dig> . the immunoglobulin-like fold is a β sandwich, found in many immunoglobulin-like proteins, such as the human mcg protein . the tim barrel is a very common α/β fold, shown in an isomerase of the parasite leishmania mexicana . the α−β plait fold is a two-layer sandwich, shown here in a human nucleoprotein, hnrnp . the rossmann fold is a very common three-layer sandwich fold in the mixed α−β class, found, for example, in the d-amino acic oxydase from rhodotorula toruloides . all images were generated using pymol http://www.pymol.org




anumber of proteins in the fold


bmean  of the lengths of the proteins in the fold




as seen in table  <dig>  the proteins in the five folds included in cath <dig> vary significantly in length. to assess the importance of length differences when computing the string kernel between two sequences, we generated a subset of cath <dig>  cath <dig>  that contains all proteins whose lengths are between  <dig> and  <dig> amino acids. general information about those proteins is available in table  <dig> 

finally, we extracted a second dataset from cath40e <dig> that contains all folds with at least  <dig> representatives, excluding the five folds included in cath <dig>  there are  <dig> of those folds, covering all three classes of proteins, and  <dig> architectures. this dataset contains a total of  <dig> proteins and is referred to as cath <dig> 

roc analysis of protein fold recognition
we quantify the effectiveness of a distance measure in identifying correctly if two sequences correspond to proteins that belong to the same cath group using the receiver operating characteristic  analysis  <cit> . in the following, a “group” may be the class of the sequence , the architecture of the corresponding protein structure, or the topology of the protein structure, as defined by cath. a pair of protein sequences is defined as similar, or “positive”, if the sequences are members of the same group, and “negative” otherwise. all pairs of protein sequences in a dataset are then compared using a similarity measure. for varying thresholds of the measure considered, all pairs that fall below the threshold are assumed to be positive, and all above it are considered negative. the pairs that agree with the assumed standard are then called true positives , while those that do not are deemed false positives . a roc analysis is set to measure the rate of tp as a function of the rate of fp. the “quality” of the similarity measure, namely its ability to separate positive pairs from negative pairs, is then scored using the area under the corresponding curve, namely the auc. an auc score of  <dig> would indicate that all tp are detected first: this is consistent with an ideal measure. an auc score of  <dig>  indicates that tp and fp follow the first diagonal: they therefore appear at the same rate, indicating that the measure is not discerning.

when the number of groups considered is larger than two, we have performed two types of roc analyses. in the first approach, we label a pair of proteins that belong to a given group as positive, independent of the group considered. in this case, an average behavior over all possible groups is derived. in the second approach, only pairs of proteins that belong to a specific group are called positive. this provides a group specific roc analysis.

fold classification experiments
the roc analysis described above ranks the distance measures of pairs of protein sequences and checks if this ranking is consistent with an existing classification; it is not designed to achieve the classification itself. we have expanded the roc analysis to the actual issue of fold recognition by carrying out a second set of experiments. each experiment involves a data set of protein sequences, d, a level of classification with groups, g, and a distance measure, d. we start by dividing randomly the sets of sequences in d into two subsets of approximately equal size. the first subset defines a training set, while the second subset corresponds to the test set. a test sequence is assigned a class by mapping it to the group of its nearest neighbor in the training set. here the nearest neighbor is found by computing first the mean normalized distance between the test sequence and all sequences in the training set that belongs to a given group, for all groups in the training set, and then taking the smallest of those mean distances. the results are gathered in a confusion matrix, c, whose element c corresponds to the number of test sequences from group i that have been classified as belonging to group j. the efficiency of the classifier d is then defined to be the quotient of the trace of the confusion matrix over the sum of all its elements. this quotient corresponds to the percentage of correctly classified sequences.

protein structure comparison
we have used structal  <cit>  to perform geometric alignments of two curves representing two protein structures. structal starts with an initial alignment , and computes the rigid-body transformation that leads to the “best” geometric superimposition of the corresponding residues. it then identifies an optimal alignment for this superposition, using dynamic programming. the new alignment defines a new correspondence, which is used to superimpose the structures again. this procedure is then iterated until it converges to a local optimum that depends on the initial alignment. to alleviate biases due to that dependence, structal repeats the iterative search using several different initial correspondences.

the traditional measure of similarity between two protein structures after optimal alignment is the root mean square displacement of atomic positions, also called crms for coordinate root mean square displacement, computed as: 
  <dig> crms=∑i=1ndistn 


where n is the number of positions in the correspondence, and a
i and b
i are the cartesian positions of two residues a and b from the two structures. the crms however is not a good measure of structural similarity  <cit> . intuitively, a “good” measure of geometric, or structural similarity should favor alignments with many residues that are matched, low crms deviations, and few gaps. unfortunately, these properties are not unrelated. for example, a lower crms deviation can always be achieved by selecting a smaller number of matches. in fact, given the fixed inter-ca distance there is the extreme case of alignments that only include two residues that have crms deviations of exactly zero. also, the addition of gaps may lengthen the alignment without increasing the crms value. different similarity measures have been proposed that attempt to balance these values in different ways. in this work, we have implemented the structural alignment score, sas: 
  <dig> sas=100crmsn, 


originally introduced by the authors of structal  <cit> .

reproducibility
the program seqkernel described above, as well as all the datasets of sequences used in this study are available from the authors upon request.

RESULTS
two proteins with highly similar sequences almost always have similar structures. the reverse, however, is not always true. in a comprehensive analysis of the relationship between sequence similarity and structure similarity, rost  <cit>  has shown that pairs of proteins with similar structures possess, on average, only 8-10% sequence identity. this observation is at the root of the difficulties observed when attempting to classify proteins based on sequence information only. we have tested an alternative method to standard pairwise sequence comparison. we propose to use a string kernel that provides an alignment-free measure of the similarity of two protein sequences. we then use that measure to classify those protein sequences and compare the corresponding classification results with classifications derived from 3d structures and sequences only. our aim is to parameterize the string kernel such that it performs better than sequence alignment based methods, mimicking to some extend the classifications derived from structure. we use cath <dig> and cath <dig> as our main test sets. cath <dig> is a dataset of  <dig> protein sequences that correspdond to the three main classes of cath: one α fold, one β fold, and three α/β folds . cath <dig> was designed in such a way that the sequences of any pair of proteins included have statistically no detectable similarity, by enforcing a fasta  <cit>  ssearch e-value >10− <dig>  cath <dig> is a subset of cath <dig> that contains those proteins whose lengths are limited to a small range, from  <dig> to  <dig> amino acids.

assessing the different protein sequence distances using receiver operator curve  analyses
roc analysis of protein fold recognition based on fasta e-values for pairwise sequence comparison, sas scores for 3d structure comparison using structal , and two conditions for the alignment-free seqkernel comparisons are shown in panels a and b of fig.  <dig> for the datasets cath <dig> and cath <dig>  respectively. these roc analyses are based on averaged behaviors over the five folds included in those two datasets , the seqkernel alignment free method introduced in this paper with two sets of parameters,  ,  , and the 3d structure alignment program structal  to detect fold similarity in two different sets of proteins, cath <dig> , and cath <dig> . “true” relationships are defined according to cath topologies. curves close to the first diagonal  indicate poor performance, while the upper most curves  indicate good performance



anumber of proteins in the fold


bauc based on fasta e-value


cauc based on structal sas score


d and eauc based on seqkernel distance, with =  and = 



anumber of proteins in the fold


bauc based on fasta e-value


cauc based on structal sas score


d and eauc based on seqkernel distance, with =  and = 




the fasta ssearch tool  <cit>  is the implementation of a fast smith and waterman sequence comparison; it measures the similarity between two sequences either using directly the raw score of the alignment, or with a corresponding e-value. we have used the latter as a similarity measure. all ssearch alignments were performed using the blosum <dig> substitution matrix  <cit> , with gap penalties of - <dig>  and - <dig> . the roc curves for this fasta measure are marginally above the first diagonal, with auc scores of  <dig>  for both cath <dig> and cath <dig>  this behavior is expected, as by design all protein pairs in those datasets have little or no sequence similarity. the auc values for the individual folds are very similar, ranging from  <dig>  to  <dig> , with one exception, fold  <dig> . <dig> within the cath <dig> dataset. we note however that this fold only contains  <dig> representatives in this dataset, making it the smallest set of all folds considered here. as such, this result is statistically unreliable.

assignment of structural fold is expected to work best when it is based on 3d structural information. indeed, the roc curves obtained based on the sas structal scores illustrate excellent classification results, with auc scores of  <dig>  and  <dig>  for cath <dig> and cath <dig>  respectively. we note that even with x-ray structure information the classification is not perfect, especially for cath <dig>  this again is not a surprise. cath is a semi-automatic classification of protein structures and some proteins are included in the same class based on more information than structure alone  <cit> . as such, two proteins may belong to the same class even though their structures are loosely similar. in addition, structural alignment programs work with heuristic algorithms and as such may miss the optimal alignment  <cit> . finally, it is possible that a small fully α or fully β protein is found to be similar to an α/β protein, based on local alignment of the helical, or strand regions of the proteins. this is observed for example for proteins in fold  <dig> . <dig> , with an auc of  <dig>  for cath <dig>  that said, structal scores based on x-ray structures still perform remarkably well.

the roc curves based on the alignment free sequence comparisons obtained with seqkernel are intermediate between the fasta and structal curves, for the two sets of parameters considered. clearly, kernel similarity measures improve the classification of proteins into folds, especially for those proteins whose sequences bear little similarity. this improvement is significant, from an overall auc score of  <dig>  for cath <dig> with fasta to auc values between  <dig>  and  <dig>  for cath <dig> with seqkernel, depending on the values given to the parameters k
max and β. similar improvements are observed for cath <dig>  interestingly, the improvements between fasta and seqkernel are not consistent over all types of folds considered. seqkernel performs significantly better for proteins in the α−β class  than for the full α fold  and for the full β fold . of similar interest, there is a discrepancy between the results obtained on cath <dig> and cath793: for the former, a significantly better overall auc is observed when the pair  is set to , while for the latter, a better overall auc is observed when the pair  is set to . in addition, results using = are more consistent over the five folds considered. while differences are expected for different parameter values, the ranking of those parameter values is expected to remain the same on different datasets, especially here as cath <dig> is a subset of cath <dig>  this difference warrants a systematic study of the impact of the kernel parameters on its performance in fold recognition.

understanding the parameters β and kmax for the string kernel seqkernel
the string kernel, seqkernel, considered in this paper depends on two parameters, the coefficients β and k
max. β is a power coefficient, i.e. it is used to compute the hadamard power of the input substitution matrix sm. as it is used in a hadamard power, all strictly positive values for β are possible, as the power matrix remains a gram matrix. the parameter k
max defines the longest k-mers that are considered in the comparison of the two sequences. note that the maximum value for k
max is the size of the smallest sequence. intuitively, using large values for k
max are expected to help as the longer k-mers capture correlations in the protein sequences. however, as described in the implementation section, large k
max values come at a computational cost. we have tested a range of values for β from very small, 10− <dig>  to relatively large,  <dig>  and a range of values for k
max, from  <dig>  to  <dig>  for pairs of values  taken from their respective ranges, we computed the similarity scores for all pairs of proteins in cath <dig> and cath <dig>  and assessed the ability of those scores for fold recognition using roc analysis. the resulting auc scores are reported in fig.  <dig>  note that the higher the auc, the better the performance. in parallel, we also compared the string kernel similarity scores with the corresponding structal sas scores. as structal was found to perform extremely well in the roc analysis , the seqkernel similarity scores should mimic the sas scores for good fold recognition. we therefore computed the pearson’s correlation coefficient pcc between the two sets of values, i.e. similarity scores and sas values, for all pairs of proteins that belong to the same folds. the resulting pcc values are also reported in fig.  <dig>  again, the higher the pcc, the better the performance.
fig.  <dig> parameterizing the string kernel seqkernel. the string kernel defined in this paper is defined by two parameters, β and k
max  we varied those two parameters in the respective ranges  and  <cit> ; for each corresponding pairs of values, we applied the corresponding kernel to compute the similarities of all pairs of proteins in cath <dig> and cath <dig> and checked the rankings of these similarities with the cath classification of the proteins, using a roc analysis. the corresponding auc values are reported in panels a and b, respectively. high values of auc indicate better fold recognition. notice the different behaviors on the two datasets . in panel c and d, we report in parallel the pearson’s correlation coefficients between the kernel similarity measures and the structal sas values, for all pairs of parameters considered. as we assess the performance of seqkernel in fold recognition, the seqkernel values are expected to mimic the sas scores, and therefore the larger the correlation coefficient, the better the performance of seqkernel




the results on the cath <dig> dataset show two different behaviors depending on the β values: for very small β values , all the auc=f curves reach the same plateau with a relatively high value of  <dig> , while for larger values of β , the same curves behave similarly but reach different maxima, with the β values corresponding to these maxima decreasing as k
max increases. interestingly, the results on the cath <dig> dataset are very different: while the same behavior is observed for the large values of β, seqkernel provides poor fold recognition for very small β values. the key difference between the two datasets is that the latter includes proteins that cover a very small range of lengths. the discrepancy in behavior therefore hints to seqkernel being able to pick differences in protein lengths for small β values. indeed, as β→ <dig>  all the values in the kernel k
 <dig> tend to  <dig>  and k
 <dig> becomes a matrix of ones. while this matrix does not correspond to a kernel , it can still be used in practice as input to seqkernel. using this matrix, the semi-kernel k
 <dig> can in fact be computed analytically: 
  <dig> k3=∑k=1kmax 


using this semi-kernel, we found that it performs with an auc of  <dig>  on the classification of the proteins in cath <dig>  this high value of  <dig>  therefore only reflects the differences in the distribution of lengths of the proteins in the five folds. those differences are significant, see table  <dig>  while an interesting observation by itself, this is not the string kernel we are interested in. indeed, eq.  <dig> shows that it is independent of the actual sequences themselves, and only captures length differences; for example, the corresponding correlation semi-kernel takes the value of  <dig> for all pairs of sequences of the same lengths. these results suggest to use a kernel based on larger values of β. figure 3
a and b indicate that any value of k
max is possible, pending that the proper value for β is chosen. we suggest using the pair =. interestingly, the corresponding kernel leads to the same aucs on the two datasets, cath <dig> and cath <dig> .

comparisons of the kernel values with the structal sas values confirm this analysis, see panels c and d in fig.  <dig>  the pcc values between these two measures are found low for small values of β. in such conditions, the kernel was shown to mainly capture lengths, while the structal scores are mostly independent of lengths. for larger values of β, the pcc values reach maxima for the same pairs of values  than the auc values.

choosing the input substitution matrix
there is one other parameter that defines the string kernel seqkernel, namely the input substitution matrix. we compared fold recognition performance as measured by roc analysis of both fasta and seqkernel  on the two datasets cath <dig> and cath <dig> for different input substitution matrices. results are shown in fig.  <dig>  as a reminder, fasta and seqkernel use different matrices as input: fasta uses a blosum-like matrix, while seqkernel uses its own count-based matrix. those two matrices however are mathematically related by a simple log function. we note that there are little variations in the performance of both fasta and seqkernel as we change their input matrices. more surprisingly, seqkernel performs quite well with the identity matrix as input. this indicates that at least for the two datasets considered here, a strict score that does not favor replacement is good enough for fold recognition.
fig.  <dig> choosing the substitution matrix. comparison of the performances of fasta and seqkernel =, as measured by auc values, for different input substitution matrices, namely the blosum <dig> , blosum <dig> , blosum <dig> , and the identity matrices. the two values for fasta and for seqkernel correspond to the two datasets cath <dig> and cath <dig>  respectively




protein fold classification
we extended the roc analyses of our sequence similarity measures to assessing their performances for actual fold recognition by performing a set of computational fold classification experiments. note that we are not interested in establishing a classification for a family of protein structures: rather, we are interested in testing the ability of distance measures based on sequences to assign a protein to the structural class it belongs to. we perform this test using a series of computational experiments. for those experiments, we consider all folds included in cath40e <dig> with at list  <dig> members, excluding the five folds considered in cath <dig>  to eliminate possible biases as seqkernel was parametrized based on these folds. there are  <dig> such folds, for a total of  <dig> proteins, which we refer to as cath <dig>  we consider three levels of classifications for those proteins, as defined by cath: the class level , and at the topology  level . each experiment starts with those proteins, and a choice for the classification level. we pick at random half of the proteins of each group at the level considered, and define them as the training set. the remaining proteins form the test set. the training set is used to define the groups for the distance-based classifiers . the experiment then proceeds by assigning a group to each protein in the test set. a protein is considered successfully classified if it is assigned to its actual cath group . experiments are repeated  <dig>  times and the results averaged to remove potential bias in the choice of proteins that define the folds.

for those fold classification experiments, we considered  <dig> possible distances between protein sequences. as a null reference, we assign a random value between  <dig> and  <dig> for the distance between two proteins. we call this distance random. on the other end of the spectrum, we include results based on the structal sas scores; those results directly reflect structural similarities. the third distance is based on the fasta ssearch e-value. the fourth and fifth distances are computed with seqkernel. as described in the previous section, there seem to be two regimes for seqkernel, based on the values for the parameters β and k
max. we picked one example from each regime, setting  to  and , respectively. the last three distances are based on other string kernels for comparing strings. we considered the subsequence string kernel introduced by lodhi et al  <cit> , subseq, the spectrum string kernel of leslie et al  <cit> , and wdegree, the weighted string kernel of rätsch and colleagues  <cit> . for those last kernel distances, we used the implementations provided in the package harry  <cit> , with default parameters. results of the classification experiments are given in fig.  <dig> 
fig.  <dig> classifying proteins in structural groups based on sequence-based distances. three levels of structural classifications are considered, the c, a, and t levels defined by cath. proteins are classified based on their shortest distance to a known group, where the distance is one of seven sequence-based distances between proteins, a random distance, a fasta-based distance based on alignment, two distances based on the string kernel defined in this work, corresponding to two different parameter settings, = and =, and three other string kernel distances, subseq  <cit> , spectrum  <cit> , and wdegree, a weighted string kernel  <cit> ). we also include results based on the structal sas scores; those results include structural information and should only be considered for reference. the classification accuracy  is computed as the ratio of proteins correctly classified over the total number of test proteins 




results from the reference random distances are on par with what is expected from the numbers of groups at each level of classification considered: 31% at the c level , 9% at the a level , and 3% at the t level . with no surprise, the results based on fasta mirror those random results: as described above, there is no information in the fasta distances by design. also, without surprise, the classifications based on the structal distances between structures are significantly more accurate than those based on sequence only. it is interesting however that even those results are far from perfect. at the c level for example, only 54% of the proteins are correctly classified. most misclassification come from α+β proteins being classified as α or β proteins. this is not unexpected, as structal performs a local structural alignment. the classifications obtained with seqkernel with  set to  are significantly more accurate than those observed with the other sequence-based distances, at least at the architecture and topology levels. this includes the results obtained with seqkernel with  set to , confirming that a somewhat large value for β is preferred. interestingly, the subseq and spectrum string kernels perform better at the class level. it is likely that those two kernels capture the amino acid compositions of the sequences, which have been shown to be good discriminants of the protein structural class   <cit> .

alignment-free phylogeny reconstruction
a large number of biological modeling methods depend on accurate  sequence alignments. protein structure prediction is one of those methods; it relies heavily on fold recognition. in the previous sections, we covered the use of alignment free methods for performing this task, comparing our string kernel seqkernel with alignment-based methods. another important modeling task that relies on sequence alignment is phylogenetic tree inference, a critical step in evolutionary studies. the majority of methods that perform this task follow a two step process, with the construction of a multiple sequence alignment followed by statistical tree inference  <cit> . these methods, though widely used, have known limitations related to uncertainties in the multiple sequence alignment . among all the approaches recently developed to alleviate those limitations, we note the alignment-free methods based on analyses of k-mers in the sequences that are compared  <cit> . as seqkernel provides a mean to quantify the similarity between two sequences using such k-mers, we tested it on a simple toy problem of phylogenetic tree inference originally described by thorne and kishino  <cit> . to illustrate their methods for computing evolutionary distances between protein sequences, they considered  <dig> sequences of the second largest rna polymerase subunit. we have repeated their analysis on the same sequences. these sequences include two eukaryotic pol i sequences, two eukaryotic pol ii sequences, two eukaryotic pol iii sequences, two archaebacterial sequences, a eubacterial sequence, and a chloroplast sequence; they are defined in table  <dig> 
yeast
drosophila megalonaster
yeast
drosophila megalonaster
yeast
drosophila megalonaster
sulfolobus acidocoldarius
methano-bacterium
thermoautotrophicum
escherichia coli
spinacia oleracea



we considered  <dig> different distance matrices between those sequences. the first matrix is the original distance matrix proposed by thorne and kishino. the second matrix is derived from the multiple sequence alignment of those  <dig> sequences, computed with clustal omega  <cit> , and converted into a distance matrix using the program protdist from the software package phylip  <cit> . we used the jones, taylor and thornton model of amino acid change  <cit>  within protdist to compute the distances. the third matrix is based on the bit scores of the sequence alignments generated by ssearch from fasta, computed with blosum <dig> as a substitution matrix and gap penalties of -11/- <dig> for opening/extension, respectively. the fourth and fifth matrices are derived from seqkernel, with two settings for the parameters β and k
max, namely  and . we have built trees based on those five distance matrices using the programs fitch and drawtree from the phylip package  <cit> . fitch is an implementation of the fitch and margoliash  <cit>  method for constructing trees from a distance matrix under the “additive tree model”. in this model, the distance between two sequences is expected to be equal to the sum of branch lengths between the sequences on the tree. these five trees are shown in fig.  <dig> 
fig.  <dig> inferred rna polymerase phylogeny. five different phylogenetic trees were constructed for a group of  <dig> rna polymerases, using five different distance measures between their sequences:  the original distances proposed by thorne and kishino  <cit> ,  distances derived from a multiple sequence alignment of the  <dig> sequences computed with clustal omega  <cit> ,  the bit distances from fasta ssearch tools, and the distances computed with seqkernel with two different settings, namely =  and = . abbreviations for species names are provided in table  <dig>  branches corresponding to eukaryotic sequences are colored red, those for archaebacterial sequences are shown in blue, and the eubacterial and chloroplast sequences are highlighted in orange and green, respectively




with the exception of the tree generated from the distance matrix derived from the seqkernel distances with β and k
max set to  the trees are qualitatively similar to each other. as the  <dig> sequences have approximately the same lengths, and as seqkernel with a small value of β basically captures differences in length, the exception is not surprising. this result however does reinforce our choice for  to . to quantify the differences between the four remaining trees, we first scaled the distance matrices so that all distances ranged between  <dig> and  <dig>  and then regenerated the trees. the resulting trees are then compared with the program treedist, implemented in the software package phylip. treedist is based on the branch score distance of kuhner and felsenstein  <cit>  to evaluate the similarity between two trees. we find that the distances between the original tree of thorne and kishino and the clustal-based, fasta-based, and seqkernel-based trees are  <dig> ,  <dig> , and  <dig> , respectively. note that the distance between the original tree and the seqkernel-based tree when  is set to  is  <dig> . while we cannot assess the meaning of the absolute values of these distances, and the significance of the differences between those values, we do notice that the original thorne and kishino tree resembles most the tree computed with the clustal-based tree, and the tree computed with the method introduced here.

CONCLUSIONS
the amino acid sequence of a protein encodes for its structure and ultimately its function in a cell. as such, sequence comparison remains one of the core tools used in many modeling methods in molecular biology that handle problems such as protein fold recognition and phylogenetic tree inference. we have shown that a string kernel that captures the similarity of all k-mers in two protein sequences provides an alignment-free method for fold recognition and phylogenetic tree reconstruction that performs well when its parameters have been selected appropriately. we refer to this string kernel as seqkernel. it depends on two parameters, β, a power coefficient that modulates the values of the input substitution matrix, and k
max, the maximum lengths of k-mers considered. we have performed a systematic analysis of the impact of those two parameters on the performance of seqkernel in fold recognition experiments involving remote homologs. we have shown that on our test datasets, seqkernel performs remarkably well for very small values of β , independently of k
max. with such small values of β however, seqkernel is basically tuned to capture the difference in lengths of proteins, which is not of interest for fold recognition. we have shown that for larger values of β, there are pairs of values  that provide significant performance in fold recognition. we suggest to use the pair =. interestingly, in the first presentation of a kernel equivalent to seqkernel  <cit> , the authors advocate the use of k
max= <dig>  and referred to β as a mysterious parameter that they fixed to  <dig> , i.e. close to the value of  <dig>  that we propose here.

seqkernel, just like any alignment-based sequence comparison method, depends on a score matrix, also called substitution matrix. such a matrix provides a quantitative measure of the similarities of amino acids. we have shown that seqkernel is not sensitive to the choice of this score matrix, at least on the two datasets cath <dig> and cath <dig> used in this study. we note however that most of the score matrices, such as the blosum matrices considered in this study, have not been optimized for the purpose of fold recognition. there has already been attempts to perform such optimization  <cit> . in future studies, we will explore further the problem of defining an optimal score matrix within the context of seqkernel.

this paper represents work in progress. it is dedicated to the understanding of the parameters that define the string kernel seqkernel as well as to the illustration of its applications in fold recognition problems and phylogenetic tree inference. in the latter, we have only presented a small toy example to highlight that a alignment-free estimate of the distances between protein sequences can perform as well as a method based on multiple sequence alignment. much work remains to be done before seqkernel can become a commodity tool for sequence analysis. the scores computed with seqkernel, while corresponding to a metric, do not include information on significance. the computing time for comparing two sequences using seqkernel is high, suggesting that seqkernel may not be used for large database searches. all the tests performed in this study were related to single domain proteins, or to specific domains within a protein. there is a need to expand the range of applications of seqkernel to multi-domain proteins, as those are more the norm than single-domain proteins. applications to phylogenomics need to be expanded and validated on a much larger scale. all those points will serve as research topics in our future studies.

abbreviations
aucarea under the curve

crmscoordinate root mean square

rocreceiver operator curve

