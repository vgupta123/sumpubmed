BACKGROUND
a growing amount of biomedical data is continuously being produced, resulting largely from the widespread application of high-throughput techniques, such as gene and protein analysis. this growth is accompanied by a corresponding increase of textual information, in the form of articles, books and technical reports. in order to organize and manage these data, several manual curation efforts have been set up to identify entities  and their interactions . the extracted information is then stored in structured knowledge resources, such as medline and swiss-prot. however, manual annotation of large quantities of data is a very demanding and expensive task, being difficult to keep these databases up-to-date. these factors have naturally led to increasing interest in the application of text mining  systems to help perform those tasks. one major focus has been on named entity recognition , a crucial initial step in information extraction, aimed at identifying chunks of text that refer to specific entities of interest. however, biomedical entity names present various characteristics that hinder the identification of those mentions in scientific documents  <cit> :

● many entity names are descriptive ;

● two or more entity names may share one head noun ;

● one entity name with several spelling forms ;

● ambiguous abbreviations .

in an effort to deal with these challenges, several ner systems have been developed for the biomedical domain, using different approaches and techniques that can generally be categorized as being based on rules, dictionaries or machine learning . each approach has different resource requirements and deals differently with the linguistic variability that resulted from the lack of naming standards and the introduction of idiosyncratic names by the scientific community  <cit> . in general, ml-based solutions are better adapted to deal with strong variability and highly dynamic vocabularies, such as in gene and protein names. however, this approach does not directly provide identifiers for the recognized names. thus, normalization must be performed in an extra step in order to relate each name with concept identifiers from curated databases or ontologies. in this case, a concept corresponds to a biological entity present on curated and specialized resources used to represent and map current knowledge. on the other hand, dictionary-based approaches are appropriate to deal with precisely defined vocabularies of names . this approach requires the construction of a unique resource containing most of the identifiers and names of a specific semantic type. however, this presents various challenges, since the necessary information is usually spread over dozens of data sources and unique identifiers are specified on a per-resource basis, which hinders mapping identifiers between heterogeneous databases. moreover, the same name may refer to different concepts, depending on the context in which it occurs. for instance, “nf1” can refer to a disease  or to a protein .

the development of ner and normalization solutions requires the application of multiple techniques, which can be conceptualized as a simple processing pipeline  <cit> :

● input: interpret and filter input data to be processed;

● pre-processing: process the input data in order to simplify the recognition process;

● recognition: identify entity mentions from pre-processed data;

● post-processing: refine generated annotations, solving problems of the recognition process or extending recognized names;

● output: generate a structured output with the final annotations.

each step of the processing pipeline may involve the implementation of various methods to fulfill the associated requirements. due to the specificities of the biomedical domain, methods developed for common english may not provide the best outcomes when used on scientific documents. for instance, in  <cit>  the authors analyzed the application of various tokenizers, concluding that most solutions are too simplistic for real-life biomedical applications. thus, it is important to develop and use methods optimized to deal with the special linguistic characteristics of biomedical terms.

based on the general processing pipeline and considering the requirements of the biomedical domain, various solutions were implemented and used to support and streamline the development of complex biomedical ie solutions. figure  <dig> presents the spectrum of frameworks and tools considering their relative specificity for this domain. the edges of the spectrum represent two contrasting types of solutions:

● general frameworks , which support the development of ie solutions with a pre-defined and general processing pipeline;

● specialized tools , centered on the recognition of specific biomedical entity types and providing end-user features.

uima  <cit>  and gate  <cit>  are examples of frameworks that provide a general solution to support the development of complex ie systems, being independent of the target domain. such goal is achieved by providing a flexible processing pipeline based on a modular infrastructure, enabling problem decomposition and consequent re-utilization of modules. besides the flexibility and re-usage advantages, such solutions also provide a strong infrastructure, such as cluster processing support for large amounts of data. however, due to the high level of abstraction, the development of new solutions may not be as straightforward as expected, requiring some time to correctly understand and have full control over the frameworks’ features. moreover, neither framework provides default modules optimized for the biomedical domain, which are provided by third parties, such as u-compare  <cit>  and jcore  <cit>  for uima. nevertheless, most of those modules are only available through web-services, which is an optimal solution for small experiments but not compatible with large scale and batch processing applications. additionally, users must be careful when using modules from different providers in a single pipeline, since the application of different techniques  among different modules may considerably degrade performance results.

toolkits such as nltk  <cit>  and opennlp  <cit> , on the other hand, are not focused on providing a text processing pipeline, offering instead a multitude of implemented methods that developers can use and combine to build their own pipelines. various features of opennlp are also available as modules for uima, which may simplify the creation of such pipelines. however, these solutions do not provide modules optimized for the biomedical domain. instead, they allow training new modules focused on different goals and domains.

on the opposite edge of the spectrum are specialized ner and normalization tools, whose development was greatly promoted through the organization of challenges such as biocreative  <cit>  and jnlpba  <cit> . dozens of new solutions emerged using the resources provided by these challenges, which allowed a fair and fast comparison of divergent techniques. gimli  <cit>  and banner  <cit>  are examples of ner solutions, and geno  <cit>  and gnat  <cit>  are examples of ner and normalization tools. however, the resources provided by those challenges are too specific and focused on the recognition of particular entity types , generating highly optimized solutions that provide high performance results on tested corpora. ner solutions are typically open-source and publicly available as runnable applications, enabling re-usage of already implemented modules and fast development of new recognition systems. however, there is no explicit processing pipeline and such solutions are not flexible, limiting the addition or removal of processing modules. on the other hand, normalization solutions are mostly not open-source, providing only web-services for remote usage, which is limited for batch processing.

there are also solutions focused on providing annotation of heterogeneous biomedical concepts. for instance, whatizit  <cit> , cocoa  <cit>  and ncbo annotator  <cit>  provide annotations of species, genes and proteins, and disorders, among others concepts. however, since they are provided as web-services, batch processing is limited and desirable functionalities, such as the possibility to configure annotation characteristics or to extend the provided features, are not available. metamap  <cit>  is another tool that provides annotation of heterogeneous concepts, using the umls methathesaurus and a set of rules for extracting text chunks and scoring them as candidates for concept names. matching is performed considering lexical and syntactic rules, generating names variants to cover as much variability as possible. however, such approach makes metamap relatively slow, not being appropriate for real-time use. for instance, it may take several hours to process complex sentences, generating many hundreds of thousands of potential mappings  <cit> . on the other hand, the variability introduced also increases ambiguity, which is a complex problem to solve. moreover, since it is provided as an end-user tool, it is also limited in terms of configurability and extensibility.

considering the current frameworks and tools for the biomedical domain, we believe there is a lack of solutions that combine the advantages of the two edges of the spectrum: modularity, speed, usability and domain optimization. this document presents neji, an open source framework for biomedical concept recognition that provides an automated and flexible processing pipeline that includes built-in methods optimized for the target domain. it supports the application of both machine learning and dictionary-based approaches, automatically combining generated annotations and supporting concept ambiguity. neji also supports known input and output formats, with easy development of new pipelines and modules.

we believe that neji is a positive contribution for the biomedical community, by simplifying the development of complex concept recognition solutions and taking advantage of the most advanced and appropriate methods in an integrated environment focused on fast and high-performance results. as a result, we believe that neji may enhance text mining and knowledge discovery processes, helping researchers in the annotation of millions of documents with dozens of biomedical concepts, in order to infer new biomedical relations and concepts.

in the next section, we give a detailed description of neji’s modular architecture, presenting the core infrastructure, the included modules and its usability. afterwards, neji is evaluated in term of concept annotation accuracy and speed. in the end, we discuss the main advantages and applications of neji.

implementation
the design and implementation of neji was focused on four crucial characteristics: modularity, scalability, speed and usability. in order to achieve modularity, every processing task is performed by an independent module, which can be executed ad-hoc or integrated in a processing pipeline. nonetheless, each module has its own input and output specifications. regarding scalability, the solution should be able to support simultaneous application of dozens of dictionaries and machine-learning models for concept recognition, while at the same time processing large data sets . one of the key features to deal with large data sets and considerably improve processing times is concurrent processing, allowing different cpu cores to process several documents at the same time. additionally, it is also fundamental to take processing speed into consideration when choosing libraries and techniques to perform the different steps. finally, developers and researchers should be able to easily use pre-defined pipelines, implement custom pipelines with provided modules and/or implement new modules respecting previously specified interfaces. moreover, typical processing modules, such as sentence splitting and tokenization, should be part of the framework and available for direct use and/or extension.

a framework with such characteristics should be an added value for the biomedical community, allowing any user to easily develop custom and complex solutions and use them according to their specific goals. additionally, advanced users do not need to deal with various independent tools and libraries, allowing them more time to dedicate to their real goals.

infrastructure
the core component of neji is the pipeline, which allows users to submit various modules for execution following a fifo  strategy. thus, a pipeline is a list of modules that are executed sequentially, considering specific goals and target chunks of text. figure  <dig> illustrates the idea of this modular and flexible architecture. each module is implemented as a custom deterministic finite automaton , with specific matching rules and actions. we used the hierarchical text processing features of monq.jfa  <cit>  to support the pipeline infrastructure and module execution . when a pipeline is executed, the input documents are the input of the first module, and the output of the first module is the input of the second module and so on, until the last module provides the output to a storage resource specified by the user. since different tasks have different requirements, different types of modules are defined:

● tagger: processes the input data and reflects the changes in the same data. for instance, when performing sentence splitting, inline annotations can be provided to reveal the obtained sentences;

● loader: loads information present on the input data into memory. for instance, if inline biomedical name annotations are present in the input text, a loader can be used to load such annotations into memory;

● hybrid: processes input data and store the results in internal memory. inline annotations can also be provided as output. for instance, when performing sentence splitting, it should be useful to provide inline annotations of the sentences and load them into memory. obviously, a tagger and a loader can be used instead, but some processing time is wasted in reading the annotations from the tagger to the loader;

● reader: a tagger that is used to collect data of interest from the input resource;

● writer: a tagger that is used to generate output data to a specific resource.

in order to support default and basic behaviors, neji already provides implementations of the various components, namely tagger, loader, reader, writer, hybrid and pipeline. such architecture allows developers to easily build custom module types or pipelines.

since neji is a framework focused on biomedical concept recognition, it also defines and provides a flexible and complete data structure to represent a corpus. thus, developers do not need to specify their own internal data structures, and they can easily extend the provided data representation. figure  <dig> illustrates the final internal data representation of a corpus with sentences and respective annotations. moreover, since neji supports automatic annotation of heterogeneous biomedical concepts, in which the existence of nested and/or intersected annotations is common, it is important to integrate a data structure that suits such characteristics in the best and most automated way as possible. a tree of annotations is the data structure that better fulfills such requirements, presenting various advantages over typical approaches : a) structured annotations provide enhanced information, since nested and intersected annotations and their respective identifiers are provided; b) the levels of the tree are directly associated with the detail of annotations, the deeper the level the more deeply an annotation is nested and/or intersected in others; c) the consistency of the tree and of the respective annotations can be maintained through automatic algorithms; d) ambiguity problems are clear; and e) filtering annotations can be as simple as pruning the tree. as illustrated in figure  <dig>  each sentence includes a tree of annotations. in order to facilitate the use and management of these trees, as well as for maintaining the consistency of the annotations, the following methods are provided:

● sorted insert: when an annotation is added to the tree, it is automatically put in place, maintaining the tree consistency;

● sorted delete: when an annotation is removed from the tree, all other annotations are put in place in order to keep tree consistency;

● traversal: obtain a list of ordered annotations following typical tree traversal techniques: by level, pre and post-order;

since an annotation without concept identifiers is less informative, it is important to provide an infrastructure that allows each annotation to contain various identifiers. moreover, each identifier should provide complete information regarding its original source and concept type. thus, the following quadruple composes each identifier: source ; identifier ; group ; and sub-group .

modules
with the proposed infrastructure, the conditions to build the required modules for text processing and concept recognition are now met. the presentation of modules follow the processing pipeline previously presented and illustrated in figure  <dig> 

readers
a reader module is used to interpret input data, in order to collect the relevant data and convert it into a format that is readable by the following modules. instead of obtaining the relevant data and storing it into memory, we decided to use a tagger to mark the original input text with regions of interest  tags . thus, the following modules only have to match the roi tags and process the contained text. two different reader modules are already provided, allowing to process xml and raw text. the xml module allows developers to specify the tags of interest. for instance, considering the pubmed xml format, if only titles and abstracts have to be processed, only the content of the tags “articletitle” and “abstracttext” are of interest. on the other hand, the raw reader considers that all the input text is of interest to be processed.

natural language processing
after obtaining the texts of interest, the next fundamental step is to perform sentence splitting, since a sentence is the basic unit of logical thought. this phase presents various complex challenges due to the specific characteristics of scientific biomedical texts  <cit> . thus, we integrated a module to perform sentence splitting taking advantage of the lingpipe  <cit>  library, which contains a sentence splitting model trained on biomedical corpora and presents high-performance results  <cit> . natural language processing  tasks are performed using gdep  <cit> , a dependency parser for the biomedical domain built on top of the genia tagger, which performs tokenization, lemmatization, part-of-speech  tagging, chunking and ner. since we are not interested in the named entities provided by the genia tagger, we removed the module and its dependencies. moreover, we decided to make the tokenizer behavior more consistent, by breaking words containing the symbols “/”, “-” or “.” into multiple tokens, which improved results  <cit> . because gdep combines all the tasks in order to perform dependency parsing, we decoupled the various processing tasks, obviously respecting all task dependencies and resources . thus, for each task, only the required resources  are loaded. for instance, if one needs the pipeline just for dictionary matching, only the tokenization plugin will be loaded and executed. on the other hand, when dependency parsing is required, all the processing tasks are performed and respective information provided. for instance, if a machine-learning model uses tokens, pos and lemmas as features, but not chunks or parsing features, these two tasks are not performed, making the process considerably faster.

concept recognition
as stated before, distinct biomedical concepts require distinct approaches in order to achieve more accurate recognition. thus, neji provides concept recognition using both dictionary and machine learning-based approaches. dictionary matching is offered using a modified version  <cit>  of the dk.brics.automaton  <cit>  library, which provides efficient regular expression matching with deterministic finite automatons . in a simplistic way, dfas are finite state machines that accept or reject finite strings of symbols. thus, a dfa transits from one state to another, depending on the sequence of input symbols, and a string is accepted if its parsing finishes in a state marked as final. considering that each input string of symbols is a name from the dictionary, one can build a dfa to match all names in a dictionary. additionally, each regular expression representing a name from the dictionary is associated with a specific identifier, enabling concept recognition. such approach supports both exact and approximate matching, and performs the recognition of named entities in o time, where n is the size of the document. since a large amount of false positives may be generated using approximate matching, and considering that we are dealing with a general biomedical solution, we decided to use case insensitive exact matching. orthographic variants of names can be generated and provided in the dictionary. even so, it is necessary to pay special attention to terms that are common english words. thus, a list of non-informative words for the biomedical domain  <cit>  is ignored during the matching process. similarly, biomedical names with two characters or fewer are also discarded. however, such a strategy may mean that acronyms of known entity mentions would be missed, which can be overcome by a post-processing module for acronym resolution.

dictionaries are provided in tsv  format with two fields: identifier and list of names. identifiers should follow the format “source:identifier:type:group” and their respective names must be concatenated with a pipe . to allow easy configuration and support dozens of dictionaries, files must be provided in a folder with an additional priority file, which contains the file names of the dictionaries  and defines the priority to be used if a disambiguation method is applied. this simple strategy enables fast, easy and flexible configuration of dictionaries.

in order to optimize the concept recognition results, some directives are followed when applying dictionary matching, assuming that a different dictionary file is used for defining concepts in each semantic group or type:

● considering one dictionary , only the entry with the largest span is matched;

● if two entries with the same text exist, in the same or in different dictionaries, both entries are matched and both identifiers are provided;

the support of machine learning-based solutions is provided through gimli, which uses the conditional random fields  implementation from mallet  <cit>  to recognize various biomedical entity types, and provides high-performance results in two well-known corpora: genetag  <cit>  and jnlpba  <cit> . it also provides a complete set of basic and complex features, serving as a good starting point to develop ner solutions for the biomedical domain. thus, various crf models trained for gimli can also be used in neji, each one focused on a different biomedical concept type. gimli already provides models for the recognition of gene and protein names, trained on genetag, and for the recognition of gene and protein, dna, rna, cell type and cell line names, trained on jnlpba. nonetheless, developers can also use gimli to easily train new models on different corpora and/or focused on different entity types. however, gimli only performs ner, not establishing a relation between chunks of text and unique identifiers from curated databases. thus, we developed a simple and general normalization algorithm based on prioritized dictionaries. following this algorithm, if an identifier is found in the first dictionary, the match is complete and the algorithm finishes. if no match is found in the first dictionary, the second one is used to find a match, and so on. in the end, if no matches are found in the provided dictionaries, the developers can choose to keep or discard the annotation. this configuration works well if the first dictionary contains a list of preferred names, and the remaining contain synonyms for each identifier. using this setting, a mention to “traf2” would be matched in the first dictionary, since this is the preferred symbol for the gene associated with the protein with uniprot accession q <dig>  and the matching process would stop. additionally, “traf2” is also a synonym for the gene “tank” , but since this is defined in a dictionary with lower priority the match would not occur. moreover, this strategy also provides flexibility to users, which only have to generate the various orthographic variants and prioritize them in the dictionaries. regarding the matching approach, if a partial match of the annotation is found in the dictionary, it is accepted as a valid identifier for the complete chunk of text. for instance, if only “brca1” is present in the dictionary, and the annotation “brca <dig> gene” is provided, the identifier of “brca1” is associated with the annotation. conversely, if “brca <dig> gene” is in the dictionary and “brca1” is found in the text, a match is not obtained since “extra” tokens are only considered in the textual mention and not in the dictionary entries. ml models are provided to neji following a similar approach of dictionaries, where a properties file defines the characteristics of each model.

post-processing
neji is also able to integrate post-processing modules, in order to optimize previously generated information. by default, an abbreviation resolution module is provided, in order to extend existing concepts. thus, we adapted a simple but effective abbreviation definition recognizer  <cit> , which is based on a set of pattern-matching rules to identify abbreviations and their full forms. in this way, we are able to extract both short and long forms of each abbreviation in text. if one of the forms is already provided as a concept, the other one is added as a new concept with the identifiers of the existing one. additionally, any further occurrences of that entity are also automatically annotated.

depending on user requirements, it may be useful to filter concept annotations following pre-defined rules. thus, neji provides the ability to remove annotations from the concept tree based on three simple disambiguation strategies:

● by depth: remove annotations from the concept tree that are deeper than a specified depth;

● nested same group: remove concept annotations that are nested on annotations of the same semantic group and with a larger span;

● by priority: remove nested and intersected concept annotations following a prioritized list.

writers
writers are used to store the recognized concepts in external resources, such as files and databases. if the user does not want to provide the result into an external resource, the corpus is programmatically available. neji supports various well-known inline and standoff formats used in the biomedical domain, such as iexml  <cit> , a <dig>  <cit> , conll  <cit>  and json  <cit> . overall, identifiers are provided following the format “source:identifier:type:group”, and using a pipe  to concatenate various identifiers for a single annotation. iexml is an inline annotation format based on xml tags, supporting two levels of detail, i.e. only one annotation nested or intersected in another. moreover, various identifiers can be provided using iexml. both conll and a <dig> support ambiguous and intersected concept annotations. however, complex identifiers are not supported in conll, thus only the semantic group is provided. the output of the a <dig> format can be used with brat  <cit> , in order to visualize and edit the generated annotations. finally, the json format provides all the information contained in the tree, together with the sentence and respective character positions. we also provide our own format, in order to overcome some limitations of other formats regarding nested/intersected annotations and multiple identifiers. it can be seen as an alternative to json, being more readable and understandable by humans. figure  <dig> presents an example of the neji output generated for a sentence. as we can see, each sentence has its own identifier, start and end character positions, and respective text. regarding annotations, an indentation-based approach is used to reflect the tree hierarchy, accompanied with the respective term identifier, start and end character positions, and associated text and identifiers.

parallel processing
in order to simplify the use of the various modules and required resources, we developed a method to manage these resources, which we call context. it automatically loads the resources that are required to run a specific pipeline. thus, researchers do not need to deal with repetitive and time consuming tasks such as loading dictionaries, ml models, parsers and sentence splitters. additionally, we also provide parallel processing of documents through multi-threading support. to accomplish this, the libraries and respective dependencies used were adapted to allow multi-threaded execution, solving some limitations with mallet and gdep. the context also supports multi-threading, by automatically generating the required duplicate resources when necessary. for instance, concurrent annotation of documents using one ml model is not possible, requiring one instance of the ml model for each thread. in order to apply parallel processing, each pipeline must be implemented in a processor, which is a runnable pipeline with context and input and output resources specification. base implementation of a processor is already provided, which simplifies the development of alternative runnable pipelines. a batch is also provided, which performs concurrent processing of input resources using a specific processor and context. considering the typical use case scenario of parallel processing in the biomedical domain, i.e., process files in an input folder and provide the results to an output folder, we developed a batch executor to make the applicability of parallel processing easier. the batch automatically generates the required processor threads to process specific files in a folder. custom arguments for the processors can be also provided, which takes advantage of java reflection.

usage
in order to make the annotation process as simple as possible in typical use cases, neji integrates a simple but powerful command line interface  tool, which is flexible and provides a complete set of features:

● annotate using dictionaries and/or machine-learning models with respective normalization dictionaries;

● various input and output formats. when the xml input format is used, the xml tags should be indicated;

● parsing level customization. by default, neji automatically finds the appropriate parsing level considering the ml model characteristics;

● number of threads customization;

● wildcard input filter to properly indicate the files to process;

● support for compressed and uncompressed files.

the features provided by the cli tool allow annotating a corpus using a simple bash command, such as:

./neji.sh -i input/ -if xml -o output/ -of xml -x abstracttext,articletitle -d resources/dictionaries/ -m resources/models/ -c -t 6

in this example, neji uses six threads to annotate the compressed xml documents in the input folder with the specified dictionaries and machine-learning models, providing the resulting xml documents to the output folder. note that only the text inside the specified tags is annotated. if users do not want to use the provided cli, it is also straightforward to develop a processor and process the documents using the batch helper. first, a processor taking advantage of the pipeline features must be implemented. figure 7:a presents the construction of a complete pipeline processor that produces the same results as the previous bash command, considering a specific context, input and output documents provided in the constructor. afterwards, this pipeline processor must be used to perform batch processing of documents. figure 7:b shows how a context is created considering input models and dictionaries folders, and how a batch is created for specific input and output folders. finally, the batch is executed considering the provided context and all documents are annotated. complete and detailed documentation on how to use the cli tool, build custom processors, and build processing modules is provided in the neji’s web page.

RESULTS
to provide general feedback regarding neji’s reliability as a framework, it is fundamental to evaluate its behavior on real life problems. thus, we believe that such framework should be evaluated considering two key characteristics:

● concept annotation: how is the quality of the produced concept annotations?

● speed: how long it takes to process a specific amount of documents?

accordingly, we collected manually annotated corpora, dictionaries and ml models to take advantage of neji, and compared the achieved performance results with existing solutions.

corpora
our primary analysis was centered on the craft corpus  <cit> , one of the largest publicly available gold standard corpora, which is focused on multiple biomedical concept types with heterogeneous characteristics. the initial release contains a set of  <dig> full-text articles  manually annotated by domain experts, focused on nine biomedical ontologies and terminological resources: chemical entities of biological interest ; cell ontology; entrez gene; gene ontology ; ncbi taxonomy; protein ontology and sequence ontology. overall, it contains almost  <dig> thousand annotations. however, craft does not include anatomical and disorder concepts, which we believe are fundamental to cover the general biomedical concept spectrum. thus, we decided to use two other corpora for concept annotation evaluation. the anem  <cit>  corpus is focused on anatomical entities, using a fine-grained classification system based on the common anatomy reference ontology . the annotated concepts are precisely divided into eleven anatomical class labels, such as “organ”, “tissue”, “cell” and “organism substance”. this corpus is based on  <dig> abstracts and  <dig> full-text extracts  randomly selected from pubmed and from pubmed central , containing  <dig> manually annotated concepts. for testing purposes,  <dig> abstracts and  <dig> full-text extracts are provided, summing together  <dig> annotated concepts. finally, the third was the ncbi disease corpus  <cit> , produced by expert annotators using the unified medical language system  as reference resource and containing disease concepts classified into four class labels: specific disease, disease class, composite mention and modifier. it contains  <dig> abstracts  from pubmed with  <dig> disease mentions. for testing purposes,  <dig> abstracts with  <dig> mentions are provided. in the end, we used the  <dig> full-text articles of the craft corpus, and the test parts of both anem and ncbi corpora, in order to allow direct and fair comparison.

resources
considering the three corpora, we collected the ml models and/or dictionaries described below to recognize biomedical concepts of each type. resources for the ‘disorders’ and ‘anatomy’ types were used for annotating the ncbi disease and anem corpus, respectively, and the remaining were considered for the craft corpus.

● genes and proteins: due to the variability of gene and protein names, their recognition was performed using a ml model trained on genetag. it applies a complete and complex set of features, namely lemmas, pos, chunking, orthographic, local context  and morphological features. lexebi  <cit> , which contains a filtered version of biothesaurus  <cit> , the most complete resource of gene and protein names, is used to perform normalization. the dictionary was further filtered to only include gene and protein names for  <dig> of the most commonly studied species a. two different dictionaries were generated: the first with preferred names and the second with synonyms for each identifier. additionally, for each dictionary a set of orthographic and semantic variants was generated using the lexical variants generation  tool  <cit> , namely: a) derivational, uninflected and inflectional name variants; b) strip ambiguous words, punctuation symbols and plural suffixes; c) known synonyms and variants from biomedical databases; and d) invert names around commas. in the end, four dictionaries were used with the following matching priority: 1) preferred terms; 2) synonyms; 3) preferred terms with variants; and 4) synonyms with variants; a simple filtering of gene and protein identifiers was also applied as a post-processing step, by discarding identifiers associated with species that are not named in the document. thus, if identifiers for human and mouse proteins are provided for a recognized protein name and mice are not referred in the document, the identifier for the mouse protein is removed from the protein annotation.

● chemicals: a dictionary of chemical names was built using the chebi database of molecular entities  <cit> ;

● species: the dictionary provided by linnaeus  <cit>  was extended by adding the entries from the ncbi taxonomy assigned to taxonomical ranks above “species”, that is, from “genus” to “domain”. for each entry, we included the names from ncbi as well as the synonyms obtained from the corresponding concept in the unified medical language system  metathesaurus  <cit> . furthermore, less specific names for species that also appeared as names in higher taxonomical levels, such as the genera “rat” or “mouse”, were filtered and kept only at the highest level, in order to approximate the annotation guidelines used in the craft corpus;

● cells: cell names were compiled from the “cell” and “cell component” semantic types in the umls metathesaurus;

● cellular component, biological process and molecular function: terms for these concept types were obtained from the corresponding sub-ontologies of the gene ontology   <cit> , and expanded with synonyms from the corresponding concepts in the umls metathesaurus. additionally, umls concepts assigned to the umls semantic types “physiologic function”, “organism function”, “organ or tissue function”, “cell function”, “molecular function” and “genetic function” were also included since they identify concepts closely related to biological processes and molecular functions, even if they are not directly mapped to go terms;

● disorders: names and synonyms for abnormalities, dysfunctions, symptoms and diseases were extracted from the metathesaurus. we considered the following umls semantic types assigned to the “disorders” semantic group: “acquired abnormality”, “anatomical abnormality”, “congenital abnormality”, “disease or syndrome”, “mental or behavioral dysfunction”, “neoplastic process”, “pathologic function” and “sign or symptom”;

● anatomy: anatomical entities were extracted from the metathesaurus, considering the following semantic types grouped under the “anatomy” semantic group: “anatomical structure”, “body location or region”, “body part”, “organ, or organ component”, “body space or junction”, “body substance”, “body system”, “cell”, “cell component”, “embryonic structure” and “tissue”. the semantic type “fully formed anatomical structure” was not included, as it contains only a few very general terms, such as “total body” or “whole body structures”. the terms from the “cellular component” sub-ontology in go were also included. additionally, we included the terms from the “neoplastic process” semantic type since this most closely matches the “pathological formation” annotation type included in the anem corpus.

as a filtering step to eliminate inconsistent names and names that would generate a large number of false positives, we rejected names with one or two characters, names starting with a word from a strict list of stopwords , and also any single word name if that word was included in a broader list of stopwords generated from the list of most frequent words in medline. some relevant terms that occur very frequently in medline, such as general names of diseases , gene ontology terms  and species , were removed from this stopword list to allow identifying them in texts.

as can be seen, different resources are used for each of the considered concepts in order to provide the best and most complete results as possible, an approach greatly simplified by neji's modular pipeline. in the end, our dictionaries contain almost  <dig> million concept identifiers with  <dig> million name variants.

concept annotation evaluation
two different evaluation approaches were performed, in order to fully assess the quality of the provided concept names and identifiers:

● named entities: evaluate the quality of the provided text mentions discarding the assigned identifiers;

● normalization: evaluate the quality of the text mentions together with the assigned identifiers.

regarding the evaluation of named entities, five matching techniques were considered:

● exact: annotation is accepted if both left and right sides match with the gold standard annotation;

● left: annotation is accepted if the left side matches;

● right: annotation is accepted if the right side matches;

● shared: annotation is accepted if the left or the right sides match;

● overlap: annotation is accepted if there is any kind of match: exact, nested or intersected.

such matching strategies allow a better understanding of annotation quality, since a non-exact matching does not mean that the correct concept was not recognized. for instance, considering gene and protein names, some systems and/or corpora include the organism name in the concept name and others do not, which remains a point of active discussion among expert annotators. other point of disagreement is the inclusion of the tokens “protein” or “gene” as suffix or prefix, or including greek letters in entity mentions  <cit> . such analysis is also important since various post-ner tasks can be performed even if imprecise names are provided .

the performance results on the various corpora were compared to previously published works to provide fair comparison. however, a complete comparison considering the five matching strategies is not always possible, since these different results are not stated in some works.

regarding normalization and identifiers matching, we also consider two different matching strategies:

● exact: annotation is accepted if one identifier is provided and it matches exactly with the gold standard;

● contains: annotation is accepted if the provided list of identifiers contains the gold standard identifier.

considering both matching strategies allows a more thorough analysis of the validity of the identifiers assigned to each entity mention. this evaluation was performed on the craft corpus, since among the corpora considered in this work, only this one provides concept identifiers.

common evaluation metrics are used to analyze and compare the achieved results: precision ; recall ; and f1-measure . these measures are formulated as follows: p=tptp+fp,r=tptp+fn,f1=2·p.rp+r where tp is the amount of true positives, fp the number of false positives and fn the amount of false negatives. note that the presented results are micro-averaged, meaning that a general matrix of tp, fp and fn values is built from all documents to obtain final precision, recall and f-measure scores.

craft
considering the databases and ontologies used in the annotation of craft, we defined six concept classes: species, cell, cellular component, chemical, gene and protein, and biological processes and molecular functions. biological processes and molecular functions are grouped into a single class, since annotations are provided in a single file. moreover, since gene and protein are provided through entrez gene  and protein ontology , we decided to perform two different evaluations regarding the recognition of named entities: 1) against concepts provided by ez; and 2) against concepts provided by ez and/or pro. the performance on this ner task was compared against the results published by verspoor et al.  <cit> , who presented state-of-the-art results on craft for sentence splitting, tokenization, pos tagging, syntactic parsing and named entity recognition. however, it only presents results for gene and protein recognition, where banner claims the best performing results using a ml model trained on the corpus of the biocreative ii gene mention corpus  <cit> . thus, we decided to also use cocoa and whatizit to compare the achieved performance results. since cocoa concept classes do not match directly to the ones provided in craft, we had to group them together to better fulfill the requirements and to achieve better results:

● species: “organism” and “organism1”

● cell: “cell”

● cellular component: “cellular component”, “location” and “complex”

● chemical: “chemical”

● gene and protein: “protein”, “molecule” and “category”

● biological process and molecular function: “bio process” and “process”

whatizit was used through the “whatizitukpmcall” pipeline, which is used in europe pubmed central  <cit>  to provide species, chemical, gene and protein, cellular component, biological process, molecular function and disorder concept annotations. to match the output with craft, biological process and molecular function annotations were grouped into a single concept class, and disorder annotations were discarded.

figure  <dig> presents the named entity recognition results achieved by neji, whatizit, cocoa and banner on the craft corpus, considering the various matching strategies. as we can see, there are considerable variations between the various matching strategies. for instance, on gene and protein names recognition, neji, whatizit and cocoa perform much better on left matching in comparison to right matching, which confirms the previously referred variability of annotation guidelines, namely regarding the inclusion  of word suffixes in concept names. moreover, neji and cocoa also present better results on right matching on cell recognition, which indicates the presence of word prefixes on the gold standard that are being discarded by the automatic solutions. those facts reflect the high variability of biomedical concept names, with different guidelines being followed by manual annotators and consequent generation of heterogeneous resources. thus, as stated before, such discrepancies should be taken into account when evaluating solutions and corpora that follow different annotation guidelines.

overall, neji presents the best results, with significant improvements on various concept types, namely on concepts associated with go , chemical and gene/protein. in more detail, we can see that neji is the solution that presents overall best recall results without losing precision. additionally, neji also presents a positive constant behavior, with an average variation of 9% of f1-measure between exact and overlap matching. however, whatizit is the most constant solution, with an average variation of 4% of f1-measure. on the other hand, cocoa has the highest variation, with 18% of f1-measure.

neji obtained state-of-the-art results on the recognition of species and cell concepts, with overlap f1-measure results of  <dig> % and  <dig> %, respectively. extending linnaeus dictionaries allowed an improvement of more than 8% of f1-measure on overlap matching, from  <dig> % to  <dig> %. nonetheless, both cocoa and whatizit present competitive results on species, and cocoa also achieved state-of-the-art results on cell identification. neji achieved an f1-measure of  <dig> % on overlap matching in the recognition of cellular component names, which is significantly better than cocoa and whatizt. for instance, a detailed analysis showed that cocoa’s performance is considerably degraded by the presence of terms such as “cell” and “cellular”. regarding gene and protein recognition, neji ml model presents better results than cocoa, banner and whatizit on left, shared and overlap matching. its performance drop on exact and right matching appears to be a consequence of the different annotation guidelines in craft and genetag, which was used to train neji’s ml model. specifically, species names, and suffixes such as “gene” and “protein” are considered as part of the concept name in genetag but not in craft, causing an erroneous evaluation when exact matching is taken into account. considering only the concepts from entrez gene, neji has an improvement of more than 3% of f1-measure on overlap matching against the second best, whatizit. when compared against banner, an improvement of 8% is achieved. regarding entrez gene and/or protein ontology concepts, neji presents an improvement of more than 5% of f1-measure against whatizit and 23% against cocoa, on overlap matching. finally, the results achieved on chemical and biological processes and molecular functions are considerably better than cocoa and whatizit. however, we believe there is margin for progress, by: 1) collecting more name variants to improve the recall for biological processes and molecular functions; and 2) refining existing chemical dictionaries to improve precision.

regarding normalization, previous works have presented performance evaluation results for specific entity types on specifically developed corpora, such as genes and proteins on aimed  <cit>  and/or bioinfer  <cit>  corpora. therefore, we evaluated the entity normalization performance achieved with neji on the craft corpus and compared it to the results obtained using the available pipelines in whatizit, as this is the only freely available system that allows identification of various concept types with identifiers for each recognized concept name.

as presented previously, we combined various resources to collect as much names variants as possible, which results in identifiers from different resources for a single concept type. in some cases, both neji and whatizit use completely different resources than the ones used on craft, such as in genes and proteins. thus, in order to collect the performance results, we first converted the identifiers provided by neji and whatizit to the ones used in the craft corpus. however, this mapping may deliver various problems, such as absent and ambiguous mapping, i.e., one identifier that is mapped to multiple identifiers, that will directly affect the obtained results. table  <dig> presents a detailed analysis of the identifier mapping for cell, gene and protein, and biological process and molecular function concept names, considering the annotations provided by neji and whatizit. uniprot identifiers for genes and proteins were mapped to entrez gene  and protein ontology  identifiers using the mapping provided by uniprot to ez and the mapping provided by pro to uniprot. the umls concept identifiers assigned by neji to cell concept names were mapped to cell ontology  identifiers through the mapping to the foundational model of anatomy  ontology available in cl. however, this mapping is highly limited, since it only covers approximately 30% of cl. finally, the dictionaries used in neji for the recognition of biological process and molecular function concept names include some concepts from various umls semantic types that are not mapped to go entries, as used in the craft corpus.

*only concept names with umls identifiers are considered.

the analysis of table  <dig> shows that only 53% of the identifiers provided by whatizit could be mapped to entrez gene. nonetheless, most of the recognized concept names  were associated to at least one identifier that could be mapped to an entrez gene identifier. on the other hand, all uniprot identifiers provided by neji were mapped to corresponding entrez gene entries. considering the uniprot to pro mapping, only 22% of the identifiers provided by whatizit were successfully mapped, while a pro identifier could be assigned to 78% of the recognized concepts. regarding neji, 95% of the uniprot ids were mapped to pro, and a pro identifier was assigned to 99% of the recognized concepts. various facts contribute to identifier mapping discrepancies between the two systems: 1) neji uses uniprot entries for  <dig> species while whatizit uses the entire uniprot database, resulting in more concept names and much more uniprot identifiers; 2) the version of uniprot used by whatizit may not correspond to the version used for mapping; 3) not all uniprot entries have a corresponding entrez gene entry; and 4) protein ontology does not map to all entries of uniprot. regarding cell identifiers mapping, 64% of the umls identifiers were successfully mapped into cl identifiers, resulting in 91% of the recognized concept names having cl identifiers. finally, since neji uses both go and umls for representing biological process and molecular function concepts, we analyzed the mapping between the provided umls identifiers and corresponding go entries. considering only the annotations that contain umls identifiers, only 32% of the recognized concept names were mapped with go identifiers. overall, considering both umls and go, 81% of the recognized concept names were provided with go identifiers.

figure  <dig> presents the normalization results achieved by neji and whatizit in the craft corpus, after converting the identifiers as explained above, and considering the various strategies for matching the text chunks to the entries in the dictionary and the two identifier matching techniques . overall, neji considerably outperforms whatizit on identifier matching for species, cellular component, chemical and biological process and molecular function concept names, with the exception of gene and protein concepts, where both solutions present similar results. moreover, there is no high variability in identifiers matching when the various dictionary matching strategies are compared, again with the exception of gene and protein concept names. in this case, it is clear from the results that different annotation characteristics between the train and test corpora also have a substantial impact on the normalization performance. on the other hand, there is a significant difference in the results if we require that the correct identifier is returned  or that the correct identifier is included in the returned list of identifiers , highlighting the ambiguity in the concept names recognized in the texts.

neji obtained state-of-the-art results in the recognition of species, with an f1-measure of  <dig> % and no significant variance between ‘exact’ and ‘contains’ matching of identifiers. during the annotation of species in craft, experts were required to assume the closest semantic match, which means that the mention “rat” was annotated as the genus “rattus” , even if from context it is known to be the common laboratory rat species “rattus norvegicus” . such fact considerably affects the performance of whatizit, since it only provides more specific species identifiers. for example, by considering just two of those cases and converting from “rattus”  to “rattus norvegicus”  and “mus”  to “mus musculus” , whatizit results would achieve an f1-measure of  <dig> %, similar to that achieved with neji.

neji presents competitive results on cell concepts normalization, with a small variance between ‘exact’  and ‘contains’ identifier matching . such results represent a small drop when compared with the performance obtained on exact named entities matching . regarding go concept types, namely cellular component, biological process and molecular function, neji considerably outperforms whatizit, again with a small difference between ‘exact’ and ‘contains’ matching of identifiers. considering ‘contains’ matching, neji presents an f1-measure of  <dig> % on cellular component, and  <dig> % of f1-measure on biological process and molecular function. comparing those results with exact named entity matching, they represent an average drop of 8% of f1-measure. the performance on biological process and molecular function is affected by the absent mappings between some umls concepts and go identifiers.

neji also outperforms whatizit on chemical concepts normalization, with an f1-measure of  <dig> % on ‘exact’ and  <dig> % on ‘contains’ identifier matching. the high difference between ‘exact’ and ‘contains’ matching reflects the high ambiguity present on chebi. for instance, the annotation “protein” on craft contains the chebi identifier  <dig> , but the dictionary matching provides both  <dig> and  <dig> identifiers, which corresponds to “protein polypeptide chain” and also contains “protein” as a synonym. the best normalization results were achieved when exact named entity matching was considered, which shows that accepting left, right, shared and overlap matching may degrade normalization performance by leading to more false positives identifiers.

finally, in order to present results for gene and protein concepts, two different evaluations were performed: 1) against entrez gene identifiers; and 2) against protein ontology identifiers. on both evaluations and systems, there is a considerable variation between the various names matching strategies and between ‘exact’ and ‘contains’ identifier matching, a consequence of the cross species ambiguity of gene and protein names. regarding entrez gene, neji and whatizit present low performance results on ‘exact’ identifier matching, achieving f1-measures of  <dig> % and  <dig> %, respectively, when using overlap dictionary matching. when ‘contains’ identifier matching is considered, the performance of neji and whatizit improve considerably, achieving f1-measures of 52% and 42% for overlap dictionary matching, respectively. concerning normalization to protein ontology, the achieved performance results are considerably better, with neji and whatizit achieving f1-measures of  <dig> % and  <dig> %, respectively, for ‘exact’ identifier matching and using overlap dictionary matching. when ‘contains’ matching is considered, both solutions present considerable improvements, with neji achieving  <dig> % of f1-measure and whatizit  <dig> %. evaluating the normalization to both ez and pro, whatizit presented the most constant behavior, a consequence of the different annotation guidelines followed in craft and in the training corpus used to generate the ml model used by neji. however, when all evaluation strategies are considered, neji provides better results.

overall, the presented analysis shows that neji achieves competitive performance results on normalization, presenting small and anticipated performance drops when compared to named entities evaluation. nonetheless, we consider that there is still margin for improvement, namely for chemicals and gene and protein normalization.

anem
to evaluate the recognition of anatomical concepts, we combined all sub-classes of the anem corpus into a single class. as a consequence, the systems are evaluated targeting the general ability to recognize anatomical entities, discarding the capability to classify and distinguish specific sub-anatomical classes. thus, neji is compared with the systems used in  <cit> , i.e. metamap and nersuite, which provide state-of-the-art results on this corpus. nersuite was trained using the training part of the corpus, being optimized for these specific annotation guidelines. cocoa provides anatomical classes following the anem classification approach. thus, we annotated the corpus using cocoa and mapped the respective classes to the single anatomical class. body part concepts provided by cocoa are also mapped to the single class.

figure  <dig> compares the results achieved by neji, cocoa, metamap and nersuite on anem corpus, considering exact, left, right, shared and overlap names matching. overall, there is a significant variation between the various matching techniques, which is observed in all systems. even nersuite has problems to identify the exact names’ boundaries, namely the right boundary. such variation reflects the complexity of inferring the variable boundaries of anatomical names. nonetheless, cocoa is the system that presents better results, with  <dig> % of f1-measure on overlap matching. neji also presents competitive results, with  <dig> % of f1-measure on overlap matching. on the other hand, metamap is the system that performs worst. surprisingly, nersuite does not perform better than neji and cocoa, which may indicate that ml-based solutions are not required for the general recognition of anatomical entities.

ncbi
similarly to the anem corpus, we also combined ncbi sub-classes into a single class, in order to evaluate the general ability to identify names of disorders. the comparison is performed against banner and whatizit. banner was used in  <cit>  to present state-of-the-art results for ml-based solutions in this corpus. although our approach is not ml-based and therefore not trained using the corpus, we believe this comparison is also relevant to provide feedback regarding the overall performance. whatizit was used through the “whatizitdiseaseumlsdict” pipeline.

figure  <dig> compares the named entity recognition results achieved by neji, whatizit and banner on the ncbi corpus. there is also a significant variation between the various matching techniques, namely on right matching. this means that various concepts are not precisely identified due to the presence or absence of word prefixes. for instance, in our case, the gold standard annotation “atrophic benign epidermolysis bullosa” is typically provided just as “epidermolysis bullosa”. even though the text chunk is not correct, it points to a related concept. comparing the two dictionary-based approaches, neji presents significantly better results than whatizit, with an improvement of more than 17% of f1-measure on overlap matching. on the other hand, banner, a ml-based solution trained on this corpus, achieved significantly better results than neji when exact matching is considered. however, the high-performance results obtained with neji when fuzzy matching is used, seem to indicate a mismatch between the terms in the dictionary used and the annotations on this corpus, which may be a consequence of two factors:

● high variability found on more specific concept names and consequently their absence in the dictionary. for instance, the gold mention “attenuated adenomatous polyposis coli” is annotated by neji as “adenomatous polyposis coli”, which are two related but different concepts, since the gold mention is more specific;

● inconsistencies in following the annotation guidelines. for instance, the gold mentions “breast/ovarian cancer” or “breast and ovarian cancer” are annotated as a single concept name. however, umls does not contain such terms, since they point to two different umls concepts.

summarizing, we can argue that neji presents highly competitive results, with significant improvements for some semantic groups, namely species, cell, cellular component, gene and protein, and anatomy.

speed evaluation
one important characteristic of concept recognition solutions is annotation speed, since large data sets may be annotated to collect as much information as possible. to evaluate the annotation speed achievable with neji, various experiments were performed using the craft corpus, which contains  <dig> full-text articles with  <dig> sentences. the documents were processed on a machine with  <dig> processing cores @  <dig>  ghz and 16gb of ram.

the annotation process using the dictionaries and ml model previously described and using  <dig> threads took 124 seconds, which corresponds to processing  <dig> sentences per second. thus, it took  <dig>  seconds on average to process a full text article. considering that medline contains  <dig> millions abstracts  <cit> , and that each abstract contains on average  <dig>  sentences  <cit> , this configuration could annotate the entire medline in five days. since generating the complex features for the ml model and collecting pos and chunking features is resource intensive, we also measured the processing speed without using ml, applying only dictionary matching and tokenization from the nlp module. with this configuration, the craft corpus was processed in 18 seconds, which corresponds to  <dig> sentences/second. thus, a full text article was processed in  <dig>  seconds, and the entire medline could predictably be annotated in 18 hours. to contextualize the achieved results, we compared neji with other existing tools. even though banner applies ml for gene and protein names recognition only, it took more than 9 minutes to annotate craft. on the other hand, the rule-based solution metamap took more than 2 minutes to process a single full-text file. we believe that the presented processing speeds provide a positive contribution to the biomedical community, making annotation of large data sets with dozens of biomedical concepts easily accessible.

discussion
the inherent characteristics, features and performance provided by the neji framework represent various technical and theoretical advantages to end-users, contributing to an improved and faster research in biomedical text mining and information extraction. first of all, the large dictionaries used in our experiments, in combination with the achieved processing speeds, are good indicators of the scalability of the presented solution. additionally, the achieved high-performance results against gold standard corpora show the solution’s reliability. overall, the flexibility, scalability, speed and performance results offered by the proposed framework expedite the processing of the increasing scientific biomedical literature. the features provided greatly simplify ner and normalization tasks, offering annotations for a large number of entity types using both dictionary and machine learning-based approaches. using the state-of-the-art modules incorporated in neji, developers and researchers can bypass normally complex and time-consuming tasks, allowing them to focus on further analysis of these annotations. users can also take advantage of the integrated natural language processing tools, eliminating the need for developing wrappers or integration solutions. the adoption of the same techniques for linguistic processing means that all modules are based on the same consistent information, such as tokens, lemmas, pos tags, chunks and parsing trees. this approach builds an integrated development ecosystem that minimizes cascading errors. for instance, if concept recognition is performed using linguistic information from one parser, and relation extraction is performed afterwards using information provided by another parser, it is hard to keep consistency between the two solutions, since the application of distinct sentence splitting and tokenization techniques provide different and hard to combine interpretations of data. thus, performing all tasks using the same linguistic information will deliver better and more consistent results.

besides using the provided modules directly, researchers may also adapt them or integrate new ones, allowing the construction of specialized processing pipelines for text mining purposes. as presented, neji is ready to be used by users with different levels of expertise. it allows obtaining heterogeneous concepts of several types in a straightforward way, by using the cli tool or by building a pipeline with existing modules. users also have the power to optimize concept recognition for their specific goals, which is achieved by having access to the innovative concept tree. such structure supports both nested and intersected annotations and, combined with the support for multiple identifiers from different semantic groups per concept, enables easy detection of ambiguity problems. additionally, neji also integrates helpers for simple concept disambiguation, merging of nested annotations and selection intersections. if required, users can also develop their own modules, such as readers, writers or wsd. overall, neji was built considering different development configurations and environments: a) as the core framework to support all developed tasks; b) as an api to integrate in your favorite development framework; and c) as a concept recognizer, storing the results in an external resource, and then using your favorite framework for subsequent tasks.

a large and diverse set of annotations can be obtained by processing a large set of documents. such annotations can be exploited in various ways. perhaps, the most straightforward one is to use these annotations together with the provided identifiers and connections to ontologies and other domain resources, to support a semantically enabled literature retrieval system  <cit> . using these annotations, it also becomes simpler to implement a query expansion scheme  <cit> , taking advantage of the ontological relationships between the identified concepts. another use of such annotations is to extract co-occurrence based association metrics between concepts  <cit> . this can also be extended to extracting semantic concept profiles that represent the semantic context in which a given concept occurs, as described in  <cit> . creating these profiles is highly dependent on the annotation of a large set of documents with diverse and rich concepts from various semantic types. co-occurrence and context-based association metrics can in turn be exploited for discovering implicit  concept relations from the literature, therefore supporting hypothesis generation and knowledge discovery.

with this analysis, we show that neji is a good starting point to develop complex biomedical text mining projects, supporting advanced and reliable features and giving users the power to choose the best behaviors considering the complete tree of recognized concepts and their specific goals.

CONCLUSIONS
this article presents neji, an open source and modular framework optimized for general biomedical concept recognition. it was developed considering scalability, flexibility, speed and usability. neji integrates state-of-the-art and optimized solutions for biomedical natural language processing, such as sentence splitting, tokenization, lemmatization, pos tagging, chunking and dependency parsing. concept recognition is supported through dictionary matching and machine learning, integrating features to perform normalization of recognized chunks of text. various known biomedical input and output formats are also supported, namely raw, xml, a <dig> and conll. recognized concepts are stored in an innovative concept tree, supporting nested and intersected concepts with multiple identifiers. such structure provides enriched concept information and gives users the power to decide the best behavior for their specific goals, using the included methods for handling and processing the tree.

we also evaluated neji against a wide variety of biomedical entity types, achieving high-performance results on manually annotated corpora. to the best of our knowledge, the analysis presented constitutes the most comprehensive evaluation of named entity recognition and normalization for such a heterogeneous set of biomedical concept types. additionally, the presented processing speeds make the annotation of large document sets a reality. we also described the simple usage of neji through the integrated cli tool, which allows annotating thousands or millions of documents with a simple bash command. furthermore, we illustrated the simplicity of developing a custom pipeline using existing modules.

we believe that the characteristics and complex features provided by neji fill the gap between general frameworks  and more specialized tools . it streamlines and facilitates biomedical concept recognition, using both dictionary and machine learning-based approaches to extract multiple concept types in an integrated ecosystem. neji simplifies concept recognition tasks in biomedical information extraction, and it can be easily integrated in complex workflows contributing towards more accurate knowledge discovery.

there are already various solutions developed and/or being developed on top of neji, such as: a) a solution to extract gene-drug relations from scientific articles; b) a web-based solution and respective web-services for on-demand biomedical concept recognition  <cit> ; c) an information retrieval solution for knowledge discovery focused on degenerative diseases; and d) an information retrieval system focused on relevant and informative sentences.

availability and requirements
project name: neji

project home page: http://bioinformatics.ua.pt/neji

operating system: platform independent

programming language: java

other requirements: java  <dig>  or higher

license: creative commons attribution-noncommercial-sharealike  <dig>  unported license

any restrictions to use by non-academics: non-commercial use

endnotes
aa. thaliana, b. taurus, c. elegans, c. reinhardtii, d. rerio, d. discoideum, a. mellifera, c. albicans, d. melanogaster, h. sapiens, m. musculus, r. norvegicus, s. cerevisiae, hepatitis c virus, m. pneumoniae, p. falciparum, p. carinii, s. pombe, z. mays, e. coli and x. laevis.

competing interests
the authors declare that they have no competing interests.

authors’ contributions
dc participated in the design and implementation of the framework and drafted the manuscript. sm and jlo conceived the study, participated in its design and coordination and helped to draft the manuscript. all authors read and approved the final manuscript.

acknowledgments
this work was supported by feder through the operational program competitiveness factors - compete and by national funds through fct - foundation for science and technology, in the context of the projects fcomp-01-0124-feder- <dig> , fcomp-01-0124-feder- <dig>  and incentivo/eei/ui0127/ <dig>  s. matos is funded by fct under the ciência <dig> programme.
