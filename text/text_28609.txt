BACKGROUND
recent experiments for chromosome conformation capture  <cit>  can result in graphs of hundreds of thousands interactions between chromosome locations. each edge in such a chromosome conformation graph is associated with a weight corresponding to the frequency at which the interaction occurs, and the edges in the graph can be interpreted as spatial distance constraints between chromosome locations with an appropriate mapping from interaction frequency to distance  <cit> . the information contained in chromosome conformation graphs has been used to embed entire genomes as well as portions of chromosomes at a kilobase-pair resolution in three dimensions  <cit> , and these structures provide first glimpses into how chromosomes take shape within the cell in more detail than what is possible with light microscopy  <cit> . these experiments are also motivated by the potential to associate genome structure with long-range regulation, chromatin accessibility, and somatic copy number alterations  <cit> . embedding chromosome conformation data has become a common practice, and a variety of algorithms have been developed to embed these structures in three dimensions  <cit> . these embedded structures have been used to gain biological insight into how chromatin structure relates to cancer  <cit> , how sequence relates to to structure  <cit> , and to study chromatin territories  <cit> .

our primary objective is to determine whether chromosome conformation data from recent experiments on the budding yeast, fission yeast, and human genomes provide an adequate set of constraints for embedding confidently. underconstrained, floppy substructures of an embedded genome can continuously deform without violating any measured distance constraints, resulting in an infinite number of embeddings consistent with the experimental data. as a pre-processing step before embedding, it is thus desirable to identify non-floppy or rigid substructures within the genome. it is these structures for which we have the most confidence in three-dimensional embeddings provided by optimization methods such as described in  <cit> . rigid regions are not rigid in the sense of being physically frozen. in fact, a rigid region can be asssociated with a variety of unique embeddings consistent with distance constraints in the conformation graph. in addition, chromosome conformation measurements at various time points may reveal other snapshots of chromatin structure, and this ensemble of embeddings can reflect the highly flexible nature of chromatin. in contrast, if a substructure of chromatin is not rigid, the flexibility is simply due to the fact that the region is underconstrained by the experimental measurements. filtering subsequent spatial analyses to consider only those regions that are rigid will help to avoid artifacts created merely by the lack of sufficient constraints to select among consistent, continuously deformable alternatives.

we apply graph rigidity theory  <cit>  to determine the substructures within the genome that are sufficiently constrained to produce a non-floppy embedding in three dimensions. two key features of our technique are that it deals directly with the chromosome conformation graph rather than relying on computing a spatial embedding and that it does not depend on the precise values of the distance constraints. these are both highly desirable properties for assessing the quality of chromosome conformation data for embedding because there is no consensus yet on a mapping from frequency to distance and computing even a single spatial embedding can be computationally very expensive for an entire genome. in order to efficiently assess rigidity on the scale required by the chromosome conformation capture data, we propose a novel, fast algorithm for identifying rigid substructures. this algorithm uses a family of “pebble game” algorithms  <cit>  established for finding rigid substructures in tandem with a novel algorithm using results from rigidity theory  <cit> . under the assumption that the edges in these graphs represent fixed distance constraints, the proposed algorithm guarantees that all subgraphs identified are rigid in three dimensions, although they may not be maximal.

while it could be the case that significant portions of the constraints are floppy and potentially uninformative for embedding, we find that, for even strictly filtered graphs, a large rigid subgraph that spans most — but not all — of the genome. thus, since the region is not underconstrained, the embedded structures of most regions can be more confidently interpreted. this procedure can be applied to any statistical filtering of chromosome conformation data, and we explore the effect of filtering both low-frequency and short-range interactions on the creation of rigidly embeddable structures. most interactions in genome-wide chromosome conformation graphs occur either infrequently or at short genomic distances, and some of these interactions could be a result of experimental noise or arise from incidental, transient interactions. by systematically filtering interactions, we quantify the frequency cutoff at which large rigid components begin to disappear. additionally, we find that the creation of rigid components depends crucially on short-range intra-chromosomal interactions and that the pairing or separation between rigid, subtelomeric regions of chromosomes is consistent with light microscopy data for budding and fission yeast.

RESULTS
algorithms for identifying rigid components
rigid components correspond intuitively to substructures in the embedding that cannot be continuously deformed without violating one or more measured proximities between chromosome locations. formally, a graph of distance constraints is a rigid graph or rigid body in three dimensions if, when the vertices are embedded in generic position in r <dig>  there is no continuous movement of the vertices — aside from a rotation or translation of all vertices — that maintains all the distances between vertices connected by edges. if a graph is not rigid , infinitely many embeddings are possible since there exists at least one continuous movement of vertices that maintains all the distance constraints. a rigid component, or maximally rigid subgraph, is a subset of vertices c for which the subgraph induced by c is rigid and no superset d⊃c exists for which the subgraph induced by d is rigid. we only consider rigid components with  <dig> or more nodes, although vertices with no edges and single edges can be trivial rigid components of size  <dig> and  <dig> respectively.

there are several related notions of rigidity, depending on the types of motions allowed. in a general bar-joint framework, vertices represent universal joints and edges represent fixed-length bars between joints. the double-banana graph  is composed of two rigid components in this framework that rotate around a hinge implied by two joints in the graph. the double-banana can also be represented as a type of bar-joint framework called a body-bar-and-hinge framework where rigid bodies can be connected to one another by fixed-length bars as well as hinges that allow just one rotational degree of freedom between two rigid bodies. the double-banana is also an example of a graph that contains rigid components that share nodes, illustrating the fact that rigid components of a graph do not correspond necessarily to a partition of the vertices in the graph.

no efficient algorithm is known for identifying all rigid components in three dimensions in general bar-joint frameworks. efficient algorithms based on the so-called “pebble games” do exist in two dimensions  <cit>  and for more restricted notions of rigidity in 3-dimensions  <cit> . recently, it has been suggested that a variant of a pebble game algorithm designed for two-dimensional rigidity can be applied to arbitrary bar-joint frameworks in three dimensions  <cit>  with good results for most graphs. while this approach often identifies many rigid components, it also erroneously produces components that are floppy. one such example is the double-banana graph of figure  <dig>  in contrast, efficient, provably correct algorithms exist to find rigid components in body-bar-and-hinge frameworks  <cit> .

we propose an iterative procedure we call body-bar-and-hinge reduction  for more accurately finding rigid components in three dimensions. it begins by gluing together smaller rigid subgraphs and then merges them by reducing the problem to identifying rigid components in the body-bar-and-hinge framework, for which efficient algorithms exist. for graphs close to the minimally rigid threshold , we suggest the use of a hybrid algorithm  that combines the pebble game with the body-bar-and-hinge reduction. in this variant, whenever the pebble game returns a floppy component, algorithm  <dig> is run on the component. the pebble game fails when implied hinges exist such as the one in the double-banana graph  <cit> . in these cases, we observe the pebble game over-estimates the size of the actual rigid components and algorithm  <dig> decomposes this floppy component into rigid subgraphs.

algorithm 1
body-bar-and-hinge reduction let max-triangle and max-vertex be a triangle or vertex in g, respectively, with the largest total degree excluding edges incident to vertices in u. 

1: input: a graph g of distance constraints

2: remove all vertices of degree ≤ 2

3: initialize the list of rigid subgraphs r to the empty list

4: while a t=max-triangle can be found such that t is not fully contained in any component in rdo

5:  while a v=max-vertex with v∉tand at least three edges to t can be found do

6:   add v to t

7:  add t to r

8: while two components ci,cj∈r share three or more vertices do

9:  remove both ciand cjfrom r

10:  add ci∪cj to r

11: let r <dig> be a subset of r such that for each pair ci,cjin r, |ci∩cj|=  <dig> or  <dig> comment: the body-bar-and-hinge framework will be represented by a set of hinges h which contains pairs of rigid bodies that share two vertices and a set of bars b which contains edges that connect rigid bodies.

12: initialize b, h, a set of used hinges uh, and a set of used nodes unto the empty set.

13: for every pair ci,cjin r2do

14: if|ci∩cj|= <dig> and ci∩cj={v,w}∉uhthen

15:  add {ci,cj} to h

16:  add {v,w} to uh

17:  add both v and w to un

18: for all pairs of nodes v,win ci△cjdo

19:  ifg contains an edge between v and w, v∉un, and w∉unthen

20:   add {v,w} to b

21:   add both v and w to un

22: return: the subsets of vertices in g corresponding to the rigid components of the body-bar-and-hinge framework as well as components in r∖r2

algorithm 2
identify rigid components

1: input: a graph g of distance constraints

2: initialize the list of rigid components c to the empty list

3: for every connected component giin gdo

4: let p be the set of components for gireturned by the pebble game algorithm

5: forh∈pdo

6:  if the subgraph induced by h is floppy then

7:   append all components returned by body-bar-and-hinge reduction on the subgraph induced by h to c

8:  else

9:   append h to c

10: return:c

to determine whether a component produced by the pebble game is floppy or rigid , we use the standard rank test of a matrix that encodes a graph of distance constraints given an embedding in r <dig> <cit> . if a random embedding of a graph of distance constraints is rigid, then all generic embeddings are also rigid  <cit> . this fact allows the rigidity of an identified subgraph of distance constraints to be tested via random embeddings, ignoring the precise distances on the constraints.

we construct rigid subgraphs using algorithm  <dig>  which starts greedily from a triangle with the most connections to other vertices not yet in a rigid component. this rigid subgraph is then grown one vertex at a time such that each added vertex connects to at least three vertices in the existing subgraph and has the most connections to other vertices not in the subgraph . by proposition  <dig>  the grown subgraph is rigid. once no vertex can be added, another triangle not contained in an existing component is selected and grown by the same vertex addition allowing reuse of any vertex added in a prior step. once no more triangles can be found, constructed rigid subgraphs that overlap by three or more vertices are merged to form larger rigid subgraphs . proposition  <dig> below guarantees that components merged in this way will be rigid.

proposition 1
if a vertex connects to at least three nodes in a rigid subgraph, then extending the subgraph to include that vertex results in a rigid subgraph. 

proposition 2
if two rigid subgraphs overlap by  <dig> or more nodes, then the union of the subgraphs is rigid .

the resulting subgraphs are merged further by converting them into a body-bar-and-hinge framework as described in lines 11- <dig> of algorithm  <dig> 

proposition 3
algorithm  <dig> returns rigid components.

by propositions  <dig> and  <dig>  the subgraphs produced by the initial greedy phase of algorithm  <dig> are rigid and can be used as bodies. line  <dig> eliminates the possibility that pairs of rigid bodies overlap by exactly one node: this overlap can neither be represented as a hinge between two rigid bodies nor a bar between two distinct vertices. the framework is then constructed by assuring that each hinge connects exactly two rigid bodies that overlap by two vertices. lines 14- <dig> guarantee that whenever a hinge is created between a pair of rigid bodies that overlap by two vertices, that pair of vertices is never used as a hinge again. lines 18- <dig> similarly assure that vertices across two rigid bodies are connected together by bars such that no vertex contains multiple bars. these basic rules construct a body-bar-and-hinge framework where hinges only allow one degree of rotational freedom between two rigid bodies and that bars do not share end points  <cit> . rigid components in this framework directly correspond to rigid components in the original graph. by a theorem of tay  <cit> , a variant of the pebble game can be used to identify rigid components in body-bar-and-hinge frameworks, and this can be done in time quadratic in the number of vertices  <cit> .

although, by proposition  <dig>  the subgraphs produced by algorithm  <dig> are rigid, they may not be maximally rigid subgraphs . this is because certain bar-joint frameworks cannot be represented as body-bar-and-hinge frameworks , and therefore some rigid components may be missed. however, the algorithm proposed here correctly identifies the two rigid components in the double-banana, which are incorrectly merged by the pebble game in three dimensions. figure  <dig> illustrates the technique.

for graphs close to the minimally rigid threshold , algorithm  <dig> may fail to identify the maximal rigid component. in these cases, we propose using a hybrid algorithm  that combines the body-bar-and-hinge reduction with the pebble game algorithm. since the pebble game does not guarantee that the components it returns are rigid, algorithm  <dig> performs matrix rank tests on these components to verify that they are indeed rigid. the bottleneck of algorithm  <dig> is the matrix rank testing of components returned by the pebble game, which takes o time, where m is the number of edges in the graph and n is the number of vertices.

performance of rigid component algorithms
although there is no known algorithm that efficiently identifies all maximally rigid subgraphs of bar-joint frameworks in three dimensions at this scale, for a few small individual chromosomes in budding yeast  at interaction frequency cutoffs of  <dig> ,  <dig> ,  <dig> , and  <dig> % , we observe that algorithm  <dig> finds maximally rigid subgraphs. to verify that we find a maximally rigid subgraph, we performed matrix rank tests on all possible induced subgraphs with more vertices than the largest rigid component identified by algorithm  <dig>  we also compared algorithm  <dig> with a recently proposed slow spring relaxation algorithm  <cit>  and found identical rigid components.

for even a single chromosome, the exhaustive subset testing technique takes hours to days on  <dig> opteron  <dig>  processors and the spring relaxation algorithm takes a similar amount of time on a single processor. a rigidity analysis using these techniques would be infeasible, but algorithm  <dig> can identify rigid components on the entire yeast genome  in minutes on a single processor. this is despite the fact that finding the maximum triangle, which takes o time, is the bottleneck in algorithm  <dig>  on the other hand, finding any triangle in a graph is at most the time complexity of a matrix multiplication  <cit> . if we replace the greedy requirement of finding a maximum triangle and maximum vertex with finding any triangle or vertex that meets the edge connection criteria, we obtain identical results at much lower running times . in addition, when comparing algorithm  <dig> to the pebble game for bar-joint networks, we find identical rigid components for all individual chromosomes in the duan et al. data set. the pebble game algorithm alone runs in similar time to algorithm  <dig>  but doesn’t guarantee rigidity. when rank tests are used to confirm rigidity for the pebble game algorithm, the running times are at least  <dig> times the running times without the rank tests.

rigid components in augmented vs. non-augmented chromosome conformation graphs
augmented chromosome conformation graphs explicitly incopropate constraints to model the linear nature of chromatin . adding constraints between betweeen adjacent fragments can increase the sizes of the rigid components in the graph. for example, in figure  <dig> the addition of these edges causes vertices b, c, and d to form a triangle, which is rigid. vertices not observed in the experiment have degree ≤ <dig> since the edges between adjacent components form a path in the graph. since any vertex of degree ≤ <dig> cannot contribute to a rigid component, vertices not observed in experiment do not change the rigid components in the graph .

the pebble game obtains larger rigid components than algorithm  <dig> when maximally rigid subgraphs are close to the minimum number of edges required for rigidity , and algorithm  <dig> will always find rigid components at least as large as the pebble game since floppy components returned by the pebble game are decomposed into smaller rigid components, and by proposition  <dig>  it will never report a floppy component as rigid. algorithm  <dig> uses the pebble game in two ways: first, a version of it  <cit>  is applied directly to other input network and, after rigidity matrix tests, if any of these components are floppy, algorithm  <dig> is applied using a version of the pebble game to find components on the body-bar-and-hinge network. this version of the pebble game explicitly models the bars and hinges in the body-bar-and-hinge framework. further discussion and demonstrations of the pebble game and its application can be found online  <cit> .

we find that augmented constraints may be useful when embedding the data, but they are not required for obtaining large rigid substructures. even though the augmented chromosome conformation graph can add many new edges , for all genomes, the size of the largest rigid component increases by no more 5% . this suggests that there are enough short-range interactions in the experimental data so that constraints between adjacent fragments are redundant when determining whether the graph is rigid.

the number of vertices  in the largest connected component and the number of vertices in the largest rigid component for genome-wide chromosome conformation graphs  at the  <dig> % interaction frequency cutoff.

effect of low-frequency and short-range interactions on rigid components
running algorithm  <dig> on filtered chromosome conformation data for the fission yeast, budding yeast, and human genomes results in one large rigid component for each genome . we apply stringent filters since most interactions occur very infrequently and we wish to determine the rigidity of the experiments from the most probable highest-confidence interactions. although rigid graphs can be very sparse , denser graphs are more likely to be rigid. however, even after removing more than 98% of the low-frequency interactions, a single large rigid subgraph comprising most of the genome is found. for duan et al. , even after removing  <dig> % of the low-frequency edges, a rigid component with nearly three-fourths of all possible nodes is obtained . the density of this subgraph is nearly one-third the density of the most stringently filtered set of interactions provided by duan et al. and each edge in the subgraph has an observed interaction frequency ≥  <dig>  rigidity analysis directly on their filtered data also produces a single, large rigid component. notably, the fission yeast conformation graph of tanizawa et al. is rigid despite being close to the minimum number of edges required for rigidity: at a cutoff of  <dig> %, there are  <dig> nodes and  <dig>  edges, just  <dig> more edges than are necesssary for the graph to be rigid. this shows that, even after stringent filtering of interactions, there is sufficient data to restrict most of the genome to only a finite set of possible embeddings.

as more low-frequency interactions are removed, the original component breaks apart into multiple rigid components that still span most of the genome . the rigid components are usually subgraphs of connected components of the filtered graph, not entire connected components themselves. figure  <dig> shows the duan et al. embedding colored by the interaction frequency cutoff at which a segment of the genome becomes floppy. even after removing  <dig> % of the low-frequency interactions, nearly one-third of the embedding remains rigid. figure  <dig> highlights rigid components at the  <dig> % interaction-frequency cutoff for the fission yeast genome.

by systematically removing short-range, intra-chromosomal interactions on frequency-filtered graphs , we find that such interactions  are crucial for maintaining a large rigid component comprising most of the genome. figure  <dig>  for example, shows that removing interactions that span ≤ <dig> kbp results in the elimination of nearly all large rigid components. it shows that the rigid embeddability of the chromosome conformation data depends centrally on these short-range contacts to provide a backbone of constraints for genome-wide chromosome conformation data sets. this dependency on short-range interactions holds for all data sets except bau et al. which is targeted to a small region of human chromosome  <dig> and still maintains a large rigid component  even after removing all interactions ≤ <dig> kbp. the fact that both the non-cancer and cancer data sets of bau et al. preserve large rigid components after stringent filtering of short-range interactions may be due to the fact that the bau et al. data set is of higher quality and has larger interaction frequencies for both cell types.

rigid components of a graph filtered for metric distances
an alternative way to filter the experimental data is to keep only those constraints that satisfy the metric properties under some frequency to distance mapping. since chromosome conformation graphs are an aggregation of interactions from millions of cells, each with some conformation of chromatin, it is possible that dense subgraphs resulting from this aggregation are associated with proximities that contradict one another when attempting an embedding. for example, any clique with > <dig> nodes where the distance between any two nodes is required to be the same is impossible to embed in three dimensions. in general, the problem of determining whether a graph of distance constraints can be embedded in three dimensions is np-hard  <cit> . however, one necessary condition for a graph to be embedded in three dimensions is that all interactions satisfy the metric properties.

we therefore also tested a filtering scheme that keeps only sets of edges that satisfy the triangle inequality. this is yet another stringent filtering applied to the data set to test for rigidity. consider a chromosome conformation graph where weights on the edges are defined to be the distance as determined by a frequency to distance mapping  <cit> . we obtain the set of interactions {uv} in the subgraph with lengths equal to the weighted shortest path between u and v; this set satisfies the shortest path metric. the duan et al. subgraph  after this metric filtering still contains  <dig>  vertices and  <dig>  edges and one large rigid component with  <dig>  vertices. therefore, even after including only high-frequency, metric interactions, there is sufficient data to obtain a nondeformable embedding.

discussion
although our primary objective is to determine the extent to which currently available chromosome conformation data is rigid, we additionally choose specific cutoffs  and anecdotally discuss the properties of rigid components in these contexts. for example, the set of rigid components for the two human cell types differ significantly: at a  <dig> % cutoff, the largest rigid component of the cancer cell covers all of chromosomes  <dig>   <dig>  and  <dig>  while the largest rigid component of the healthy cell covers only chromsome  <dig> despite the fact that they each have a similar number of vertices and edges  and 7). cancer and non-cancer cell types are commonly compared in 3c experiments , and assuming this more stringent filter is used for an embedding, this analysis suggests it is possible to confidently embed a much larger portion of the cancer genome than the normal lymphoblastoid genome. while it is desireable to compare the entire structures, structural comparisons can more confidently be made between mutually rigid subsets of the genome at this cutoff, and focusing comparisons on mutually rigid subsets guarantees that the difference between structures is not due to the fact that one or both of them is underconstrained. the large difference in rigid component sets may be due to the fact that the cancer and non-cancer genomes are structurally very different from one another. the bau et al. study establishes this for a small portion of chromosome  <dig> with both chromosome conformation data and microscopy experiments, but there has been no genome-wide structural comparsion of these cell types.

microscopy data also confirms some observed properties for the rigid components in the duan et al. and tanizawa et al. data sets. at the  <dig> % and  <dig> % interaction frequency cutoffs, the larger chromosomes in budding yeast break apart into multiple large rigid components  with subtelomeric regions in different rigid components. this is consistent with the fact that the subtelomeric regions of chromosomes  <dig>   <dig>  and  <dig> are known to be separated from one another and near the nucleolus and nuclear periphery  <cit> . for chromosome  <dig> of budding yeast, a subtelomeric region containing ribosomal dna close to the nucleolous is a part of its own rigid component even at a  <dig> % interaction frequency cutoff  <cit> . for chromosome  <dig> of the fission yeast genome , the subtelomeric regions at each end are part of a single rigid component ) and these regions are also observed in close proximity to one another in microscopy experiments  <cit> .

to capture the space of possible structures, our rigid components algorithm can also be used as input to a recent technique that creates an ensemble of embeddings from chromosome conformation data  <cit> . generating an ensemble of embeddings can be slow on large collections such as  <cit> , and a potential speedup can be achieved by randomly permuting the edges of the input graph passed to the pebble game. this procedure samples the minimimally rigid subgraphs built with the pebble game. although it is unlikely that any embedding represents a structure that existed for any particular cell, multiple minimally rigid structures can be used to determine whether there exist rigid substructures that are consistent across random samplings of the data. if these re-appearing substructures exist, then there is stronger evidence that there exist relatively fixed regions or ‘structural invariants’ which can be more confidently in analyzed spatially.

finally, we find that random graphs produced by applying the configuration model  <cit>  to a chromosome conformation graph generally contain large rigid subgraphs as well. this suggests that the degree distribution of the graphs in these cases are linked to their rigidity.

CONCLUSIONS
recent chromosome conformation experiments provide an abundance of data which, even after applying several filtering strategies, still result in rigid embeddings for most of the budding yeast, fission yeast, and human genomes. this conclusion is independent of any particular algorithm for embedding a structure. the genome-wide graphs we studied are composed of one large rigid component using fewer than 2% of the edges. additionally, we find that short-range interactions are crucial for maintaining the large rigid component.

as data for studying the three-dimensional structure of genomes under a variety of conditions becomes increasingly available, restricting spatial analysis to the high-confidence regions of these structures ensures that conclusions drawn from the structures are not artifacts of a lack of sufficient constraints. the algorithm proposed here efficiently identifies non-deformable, rigid substructures within chromosome conformation graphs by using a variety of results from rigidity theory that guarantee the construction of rigid graphs from rigid subgraphs. graph rigidity is well-suited to assess the quality of chromosome conformation data since the experiments do not currently provide precise distances between chromosome locations, and graph rigidity does not depend on the precise values of the distances in a graph of distance constraints. before performing computationally expensive embeddings of chromsosome conformation data, pre-processing data with the technique described in algorithm  <dig> using any choice of filter quickly isolates regions of the genome for which a sufficient number of constraints exist for an embedding and these subgraphs serve as a basis for embedding chromosome conformation graphs in three dimensions.

