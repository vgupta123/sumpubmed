BACKGROUND
in the biomedical field, a growing amount of data is continuously being produced, resulting largely from the widespread application of high-throughput techniques, such as gene and protein analysis. this growth is accompanied by a corresponding increase of textual information, in the form of articles, books and technical reports. in order to organize and manage these data, several manual curation efforts have been set up to identify, in texts, information regarding entities  and their interactions . the extracted information is stored in structured knowledge resources, such as medline, swiss-prot and genbank. however, manual annotation of large quantities of data is a very demanding and expensive task, making it difficult to keep these databases up-to-date. these factors have naturally led to increasing interest in the application of text mining  systems to help perform those tasks.

one major focus of tm research has been on named entity recognition , a crucial initial step in information extraction, aimed at identifying chunks of text that refer to specific entities of interest. several ner systems have been developed for the biomedical domain, using different approaches and techniques that can generally be categorized as being based on rules, dictionary matching or machine learning . in this study we follow an ml approach, the goal being to train statistical models focused on recognizing specific entity names, using a feature-based representation of the observed data. this presents various advantages over other approaches, such as the recognition of new and short entity names. moreover, ml solutions have been shown to achieve the best results for this specific domain.

various techniques for adapting and optimizing ml-based solutions have been proposed in recent years. these can be categorized into one of the following sub-tasks: pre-processing, feature extraction, modelling, and post-processing. in the initial step, the input data is pre-processed to make it readable by computers and to simplify the recognition process. this sub-task is one of the most important, since every single action will affect the entire system behaviour. tokenisation is a mandatory step, in order to divide natural language texts into discrete and meaningful units. there are several approaches to implement it, depending on the input data and desired output. for instance, tsuruoka et al.  <cit>  keep words that contain a dash as a single token, while leaman and gonzalez  <cit>  create multiple tokens for the same word.

in the feature extraction step, it is important to obtain features that reflect the different characteristics of the sentences and tokens. at the token level, orthographic  <cit>  and morphological  <cit>  features are commonly used in order to extract token formation patterns. it is also common to encode domain knowledge as features  <cit>  using external resources, such as lexicons of gene and protein names. at the sentence level, linguistic  <cit>  and local context features  <cit> , such as windows and conjunctions of features, are used to model the links between tokens.

the ultimate goal is to model the observed data using the features extracted in the previous step, thus creating a probabilistic description of the data classes. this task is accomplished using ml models, which can be classified as being supervised or semi-supervised, depending on unannotated data being used or not. supervised learning, which only uses annotated data, has received most research interest in recent years. consequently, different supervised models have been used on biomedical ner systems, such as conditional random fields   <cit> , support vector machines   <cit>  and maximum entropy markov models   <cit> .

finally, the post-processing stage aims to improve the recognition results, cleaning annotation errors or refining incomplete annotations. the most common methods consist of removing annotations with unmatched parentheses  <cit> , adding the results of abbreviation resolution tools  <cit> , and extending names using a domain dictionary  <cit> .

although several open source solutions aimed at recognizing biomedical names have been proposed in recent years, most present one or more of the following limitations: 

•are focused on a specific corpus and/or biomedical domain;

•do not take advantage of state-of-the-art techniques;

•achieved performance results are deprecated and/or not according to similar closed source solutions;

•not configurable and/or easy to use;

•not easily extensible to new features and/or scalable.

in this article we present gimli, a new open source solution for automatic recognition of biomedical names, namely gene/protein, dna, rna, cell type and cell line names. it extends and optimizes the most advanced state-of-the-art techniques in a simple and easy-to-use tool. by default, gimli already provides high-performance trained models, supporting several known corpora formats. moreover, it also allows easy and flexible development of new solutions focused on different semantic types, as well as training new ml models with different feature sets and characteristics.

implementation
this section presents a detailed description of the resources used and methods implemented, following the workflow of ml-based ner solutions. figure  <dig> illustrates gimli’s architecture, presenting the connections between the various steps.

tools and resources
gimli takes advantage of various publicly available tools and resources. the implementation of conditional random fields for statistical natural language processing is provided by mallet  <cit> . gdep  <cit>  is used for tokenization and linguistic processing, namely lemmatization, part-of-speech tagging, chunking and dependency parsing. in terms of lexical resources, we use biothesaurus  <cit>  for gene and protein names, and biolexicon  <cit>  as the resource for biomedical domain terms.

corpora
there are several publicly available corpora that can be used for training and evaluation of ner systems. to allow direct comparison with other tools, we selected two of the most used corpora: genetag and jnlpba. genetag  <cit>  is composed of  <dig> sentences extracted from medline abstracts, not being focused on any specific domain. it contains annotations of proteins, dnas and rnas , which were performed by experts in biochemistry, genetics and molecular biology. this corpus was used in the biocreative ii challenge  <cit> , providing  <dig> sentences for training and  <dig> sentences for testing. on the other hand, the jnlpba corpus  <cit>  contains  <dig> abstracts extracted from medline using the mesh terms “human”, “bloodcell” and “transcription factor”. the manual annotation of these abstracts was based on five classes of the genia ontology  <cit> , namely protein, dna, rna, cell line, and cell type. this corpus was used in the bio-entity recognition task in bionlp/nlpba  <dig>  <cit> , providing  <dig> abstracts for training and the remaining  <dig> abstracts for testing.

since genetag is not focused on any specific biomedical domain, its annotations are more heterogeneous than those of jnlpba. a brief analysis, considering protein, dna and rna classes, shows that genetag contains almost 65% of unique entity names, as opposed to the 36% found in jnlpba.

pre-processing
in recent years, various tokenisation solutions have been developed for several domains and languages. gimli uses the tokeniser from genia tagger  <cit>   which is developed for biomedical documents and presents state-of-the-art results in this domain. however, words containing the symbols “/”, “-” or “.” are not always split into multiple tokens. when working at the token level, this may create inconsistencies with the human provided annotations, constraining the model learning process and the recognition of some entity names. for instance, consider that “brca-1/2” is taken as one token and that in the gold standard only “brca-1” is tagged as an entity name. in the model training phase, the token “brca-1/2” as well as its local and contextual features will be considered as a “negative”, which will directly affect the final model. thus, we decided to make the tokenizer behaviour more consistent, by breaking words containing the symbols “/”, “-” or “.” into multiple tokens.

to train ml models, each token in the training data must be identified as being part, or not, of an entity name. we use the bio encoding scheme, which is the de facto standard. in this scheme tokens are tagged as being at the beginning , inside  or outside  of an entity name.

features
feature extraction is a crucial ner task, since the predictions will be performed based on the information that they encode. nadeau and sekine  <cit>  present a complete survey on features used in general ner solutions. gimli implements a rich set of features, including orthographic, morphological, linguistic parsing, external resources and local context features. we also propose improvements on various features, in order to optimize their behaviour and performance results.

the purpose of orthographic features is to capture knowledge about word formation. for example, a word that starts with a capital letter could indicate the occurrence of an entity name . figure  <dig> lists the formation patterns used by gimli to extract orthographic features from tokens.

morphological features, on the other hand, reflect common structures and/or sub-sequences of characters among several entity names, thus identifying similarities between distinct tokens. to accomplish this goal, three distinct types of morphological features are considered: suffixes and prefixes, char n-grams and word shape patterns. particular prefixes and suffixes could be used to distinguish entity names. for instance, suffixes like “ase”, “ome” and “gen” frequently occur in gene/protein names  <cit> . a char n-gram is a subsequence of n characters from a given token. this feature type has an identical role to prefixes and suffixes, however it also finds common sub-sequences of characters in the middle of tokens. finally, it is also important to extract the token’s structure. collins  <cit>  proposed a method to generate a sequence of characters to reflect how letters and digits are organized in the token. we extended this idea to support symbols too. thus, three distinct types of word shapes are used by gimli: 

•word shape type i: replace sequence of digits by “*” ;

•word shape type ii: replace each letter, digit and symbol by a morphological symbol .

•word shape type iii: replace each sequence of letters, digits and symbols by a morphological symbol .

the most basic internal feature is the token itself. however, in most cases, morphological variants of words have similar semantic interpretations, which can be considered as equivalent. for this reason, lemmatisation is commonly used to group together all inflected forms of a word, so that they can be analysed as a single item. on the other hand, it is also possible to associate each token with a particular grammatical category based on its definition and context, a procedure called part-of-speech  tagging. moreover, we also use chunking, dividing the text into syntactically correlated chunks of words . the bio encoding format is used to properly indicate the beginning and end of each chunk. for instance, considering two consecutive tokens that make part of a noun phrase chunk, the tag “b-np” is associated with the first token and the tag “i-np” with the second one. in the end, each tag is used as a feature of the respective token.

the previous features provide a local analysis of the sentence. to complement these with information about relations between the tokens of a sentence, we use features derived from dependency parsing. namely, we follow a strategy similar to the one presented by vlachos  <cit> , considering only those dependencies that could indicate the presence of an entity name. thus, we add as features of each token, the lemmas corresponding to each of the following: verbs for which the token acts as subject; verbs for which the token acts as object; nouns for which the token acts as modifier; and the modifiers of that token.

gimli is further optimized by adding biomedical knowledge to its features. to provide this knowledge, dictionaries of specific domain terms and entity names are matched in the text and the resulting tags are used as features. thus, the tokens that make part of a matched term contain a feature that reflect such information. for instance, if the term “brca” is matched, the feature “lexicon=prge” is added to the token. two different types of dictionaries are used in gimli: 

•gene and protein names: biothesaurus is the most complete and up-to-date lexical resource for gene and protein names, containing almost  <dig> million unique names. due to its size, we decided to filter this lexicon considering only human genes and proteins, obtaining almost  <dig> thousand unique names. in the end, this lexicon is used to indicate the presence of curated gene and protein names. since these names could be present in text with small orthographic variations, the matching is performed according the following variation rules, adapted from  <cit> : 

replace white spaces per hyphens, and vice-versa;

remove white spaces and hyphens;

insert an hyphen on letter-digit sequences;

replace roman by arabic numbers, and arabic numbers by greek letters;

add the prefix “h” and the suffix “p” to acronyms

•trigger words: specific domain terms may indicate the presence of biomedical names in the surrounding tokens. instead of using words from training data as proposed in  <cit> , we apply a more general solution, by matching the terms in biolexicon. this lexical resource contains more than two million relevant biomedical terms, including nouns, verbs, adjectives and adverbs .

higher level relations between tokens and extracted features can be established through windows or conjunctions of features, reflecting the local context of each token. the application of windows consists of adding selected features from preceding and succeeding tokens as features of each token. on the other hand, conjunction of features consists of creating new features by grouping together features of the surrounding tokens. for instance, considering the sentence “pharmacologic aspects of neonatal hyperbilirubinemia.” and a {- <dig> } range of tokens, the following features are added to the token “neonatal”: 

•windows: the tokens “of” and “hyperbilirubinemia”;

•conjunctions: the new conjunction feature “of@-1_&_hyperbilirubinemia@1”.

our tests showed that the best results were obtained using conjunctions. however, gimli does not use all of the features to generate conjunctions, since this would become impracticable, generating millions of new features. tsai et al.  <cit>  proposed the use of tokens of the following windows to generate the conjunctions: {- <dig> -1}, {- <dig> -1}, {- <dig> }, {- <dig> } and { <dig> }. to improve the context knowledge, we propose a different approach, using lemmas and pos tags instead of tokens, since lemma conjunctions better reflect the pairwise patterns of words, and the pos tags conjunctions provide grammar-based relations and patterns. following the previous example, instead of the simple token-based conjunction feature, the token “neonatal” now has two conjunction features: pos=in@-1_&_pos=nn@ <dig> and lemma=of@-1_&_lemma=hyperbilirubinemia@ <dig>  the benefits of these choices were confirmed through various experiments.

model
when ml techniques are applied to ner, an algorithm must build a feature and statistical-based representation of target entity names from training data, in order to develop an appropriate response to unseen data. such methodologies are commonly categorized as being supervised or semi-supervised. semi-supervised solutions use both annotated and unannotated data, in order to obtain features of the entity names that are not present in the annotated data. specifically for this task, the usage of unannotated data could contribute to a better abstract learning of the named entities. however, the application of such techniques is computationally heavy and could be implemented as an extension to an equivalent supervised solution. thus, we decided to follow a supervised training approach, through the application of conditional random fields   <cit> . such technique present various advantages over other methods. firstly, crfs avoid the label bias problem  <cit> , a weakness of maximum entropy markov models . additionally, the conditional nature of crfs  relaxes strong independence assumptions required to learn the parameters of a generative model, such as hidden markov models   <cit> . finally, support vector machines  follow a different approach and have been shown to deliver comparable results to crfs  <cit> . however, training complex svm models for ner may take more time  <cit> .

conditional random fields  were first introduced by lafferty et al.  <cit> . assuming that we have an input sequence of observations , and a state variable that needs to be inferred from the given observations , a “crf is a form of undirected graphical model that defines a single log-linear distribution over label sequences  given a particular observation sequence ”  <cit> . this layout makes it possible to have efficient algorithms to train models, in order to learn conditional distributions between yj and feature functions from the observable data. to accomplish this, it is necessary to determine the probability of a given label sequence y given x. first, the model assigns a numerical weight to each feature, and then those weights are combined to determine the probability of yj. such probability is calculated as follows:

  p=1zexp), 

where λj is a parameter to be estimated from training data and indicates the informativeness of the respective feature, z is a normalization factor and fj=∑i=1nfj, where each fj is either a state function s or a transition function t  <cit> .

when considering higher-order models, each label depends on a specific number of o previous labels. thus, the probability will consider not only the previous observation and its features, but o-previous observations and features, which better models dependencies and may provide improved results, depending on the target data and task. however, the training complexity of higher-order models increases exponentially with the pre-defined order o <cit> .

model combination
the most recent results on biomedical ner clearly indicate that better performance results can be achieved by combining several systems with different characteristics. as an example, the top five systems of the biocreative ii gene mention challenge  <cit>  used ensembles of ner systems, combining distinct models or combining models with dictionary and/or rule-based systems. additionally, the application of machine learning-based harmonization solutions have been shown to deliver high improvements in terms of performance results  <cit> .

we propose a new and simple combination strategy based on confidence scores. to achieve this, each model provides a confidence value for the annotations predicted for a given sentence. if the models that produced the overlapping annotations predict the same entity class, we follow a straightforward strategy, selecting the annotations from the model that has the highest confidence score and rejecting the predictions of other model. on the other hand, if we need to combine annotations of models that predict different entity classes , this strategy is extended in order to allow distinct entity types in the same sentence. thus, instead of selecting a single model to provide the predictions for the entire sentence, this choice is made for each annotation in the sentence. when two or more models provide different annotations for the same chunk of text, we select the annotation given by the model with the highest confidence score. if only one model provides an annotation for a chunk of text, that annotation is accepted.

post-processing
in order to solve some errors generated by the crf model, gimli integrates a post-processing module that implements parentheses correction and abbreviation resolution. to perform parentheses correction, the number of parentheses  on each annotation is verified and the annotation is removed if this is an odd number, since it clearly indicates a mistake by the ml model. we also tried to correct the annotations by removing or adding tokens up to the next or previous parenthesis. however, this solution provided worse results than simply removing the annotations.

regarding abbreviation resolution, we adapt a simple but effective abbreviation definition recognizer  <cit> , which is based on a set of pattern-matching rules to identify abbreviations and their full forms. such patterns consider some constraints, namely: a)the first character of the acronym has to be the first character of the first word in the corresponding long form; b) the long form should be longer than the corresponding acronym; and c) the long form should not contain the candidate acronym. in the end, we are able to extract both short and long forms of each abbreviation in text. thus, if one of the forms is annotated as an entity name, the other one is added as a new annotation. additionally, if one of the forms is not completely annotated, gimli expands the annotation boundaries using the result from the abbreviation extraction tool.

RESULTS
to analyse the impact of various techniques and compare the final results with other existing solutions, we use common evaluation metrics: precision  the ability of a system to present only relevant items; recall  the ability of a system to present all relevant items; and f-measure, the harmonic mean of precision and recall. these measures are formulated as follows:

  p=tptp+fp,r=tptp+fn,f1=2p.rp+r, 

where tp is the amount of true positives, fp the number of false positives and fn the amount of false negatives.

preliminary experiments
during the development of gimli, various optimizations and decisions had to be performed to achieve the best possible results. in order to run such experiments, we randomly split the training part of each corpus into training and development sets, using 80% of the data for training and the remaining 20% for development testing. accordingly, from the  <dig> sentences of the training part of genetag,  <dig> sentences are used for training and  <dig> sentences for development testing. regarding jnlpba, considering the  <dig> training abstracts, we now use  <dig> abstracts for training and the remaining  <dig> abstracts for development testing. most experiments on the development stage, namely tokenization and feature set optimization, were performed using first-order crf models with forward  text parsing.

tokenization
to evaluate the impact of the tokenization changes introduced in gimli, we compared the results achieved against the use of the original tokenization. this analysis only applies to the genetag corpus, since jnlpba is provided as tokenized text. using the development set, an improvement of  <dig> % in f-measure was achieved when applying a model trained on tokens provided by our proposed tokenization as compared to using the original version of genia tagger. when applied to the final test set, and considering the alternative annotations provided, the improvement in f-measure is  <dig> %. such results clearly show the positive contribution of our tokenization approach on gimli.

feature set
each feature encodes specific characteristics of target annotations, providing a different contribution in the learning process. in order to evaluate their impact in the recognition performance, we initially grouped features that encode similar information into logical sub-classes for each feature type, as shown in figure  <dig>  we then followed a backward elimination approach to find the best feature set for each entity type, by removing each sub-class from the complete feature set and analysing its impact in the results. although small improvements or drops may not be significant regarding performance improvements, they indicate that adding or removing a specific feature may have an impact on the final performance results, which is relevant when considering the inclusion  of that feature. when such cases occurred, we decided to keep the feature when a small improvement occurred and remove it when a small drop is present. in the end, the features that presented a negative impact when removed from the initial set were included in the final feature set, as indicated in figure  <dig>  for instance, our trigger words approach provides a slight positive impact in the recognition of gene and protein names in genetag, resulting in an f-measure improvement of  <dig> %. however, a negative impact is observed on jnlpba, with a  <dig> % decrease of f-measure. we believe that the obtained results are a consequence of the corpus specificity, since biolexicon terms may point to the presence of entity names that were not considered in the specific corpus and/or entity type.

this approach helps experts to better understand the linguistic characteristics of each entity type on each corpus. thus, the final feature sets seem to reflect the complexity and heterogeneity associated with each entity type and corpus. for instance, the absence of the original tokens for protein, cell line and cell type on jnlpba may indicate less heterogeneity, as the use of lemmatization appears to better reflect and generalize the target names. overall, the feature set required by genetag is more complex than the ones used on jnlpba, discarding the original tokens and some orthographic and morphological features. this is consistent with the idea that the entity names present on genetag are more heterogeneous than those present on jnlpba, as suggested before.

conjunctions vs windows
local context, as encoded in windows or conjunctions of features, has a great impact in recognition performance. we therefore analysed in detail the impact of using these two alternatives, considering basic and improved solutions. thus, four different configurations are considered in our analysis: 

•token conjunctions: form conjunctions as the concatenation of tokens taken from the following windows {- <dig> -1}, {- <dig> -1}, {- <dig> }, {- <dig> } and { <dig> };

•optimized conjunctions: the same windows as the previous configuration but using lemmas and pos tags for the conjunctions, instead of tokens;

•windows tokens: use each token from the window {- <dig> };

•windows optimized: use lemmas, lexicon matching, biomedical concepts matching and tokens in the window {- <dig> }, and all the features in the window {- <dig> }.

this analysis indicates that choosing the right method to encode local context is fundamental, since an untidy decision may deliver considerably worse results. as we can see, the average f-measure differences between the best and worst solutions on genetag and jnlpba are of  <dig> % and  <dig> %, respectively.

model combination analysis
the usual direction to parse a text is from left to right . however, previous studies  <cit>  have shown that parsing the text from right to left  may provide better results, which has been shown to be a consequence of the asymmetric implementation of crf models in mallet  <cit> . additionally, we believe that using crfs with different orders will extract different context based characteristics from text. thus, we decided to train first and second order crf models, considering both forward and backward text parsing.

initial evaluation results on genetag and jnlpba are presented in figure  <dig>  using the previously selected feature set . as we can see, the application of different crf orders and parsing directions provides significant performance differences. for instance, considering rna on jnlpba, the difference between different parsing directions is above 3%, and the difference between different crf orders is approximately 2%. overall, backward models present the best results, which confirms the benefit of using backward text parsing. moreover, due to the different entity names’ heterogeneity existent in both corpora, different model orders are required. on genetag, the best results are achieved using second order models. on the other hand, the best results for protein and cell type on jnlpba are achieved using first order models.

to combine the various models for each class on each corpus, we performed a sequential analysis of the combination results. thus, we first combined the two best models for each class and, if the performance was better than the best model alone, we kept adding models to the two best, in order to find the best set. if the combination result of the two best models was not better than the best model, we tried combining the best model with others, until a better combination was obtained. if the combination did not improve the results, only the model with the best result was used. figure  <dig> presents the results of our analysis. even with the simple combination approach used by gimli, the harmonisation strategy improves the best model results. an average improvement of  <dig> % is verified. overall, the best combination results are achieved by combining the two best performing models. moreover, models with low performance results also contribute to a better model combination, by providing heterogeneity that is not present in other models. for instance, on cell line the best model combination is achieved by adding the worst performing model.

feature contributions
in order to evaluate the overall contribution of some high-end features implemented by gimli, we performed an analysis on both corpora, considering the removal of such features from the best feature set for each entity type. figure  <dig> presents the observed differences, reflecting the features’ contribution. overall, removing conjunctions causes the highest negative impact, considerably reducing the performance results. dependency parsing also contributes positively to the final results, namely on dna and cell line. on the other hand, removing dependency parsing features from rna improves the results. however, this is a consequence of the algorithm to combine the models of different entity types. when evaluated alone, rna recognition presents an f-measure of  <dig> %. removing dependency parsing features, this value drops slightly to  <dig> %, reflecting the positive contribution of such features. as expected, lexicons also provide a positive contribution, increasing the models’ precision. post-processing, on the other hand, introduces just a small positive contribution. for instance, on rna, the absence of post-processing methods does not affect the performance in any way.

performance analysis
to evaluate gimli and understand its behaviour in comparison with existing solutions, we collected the best open and closed source systems for biomedical named entity recognition. figure  <dig> presents a summary description of the systems’ characteristics, comparing them against gimli. overall, we collected a total of  <dig> systems, where seven are open source and five closed source. our study of these systems allowed to identify some current trends of biomedical ner systems: 

•the most used ml model is crf ;

•almost all the discriminative ml models use orthographic, morphological and basic-linguistic  features;

•only  <dig> systems use model combination, all of which are closed source;

•only  <dig> systems use post-processing techniques, where  <dig> are closed source.

• <dig> systems support genetag and  <dig> systems support jnlpba;

•only  <dig> systems support both corpora, where  <dig> are open source;

based on these facts, we can argue that closed source solutions are commonly developed for a specific corpus, being focused on only one specific goal. however, those solutions present the most advanced techniques. on the contrary, open source solutions do not always take advantage of high-end techniques.

figures  <dig> and  <dig> present the results obtained on genetag and jnlpba corpus respectively, comparing gimli against open and closed source systems. on the genetag corpus, gimli outperforms all the open source solutions, achieving an f-measure of  <dig> %. it presents a significant improvement of  <dig> % over the second best system, banner. in comparison with nersuite, gimli presents an improvement of  <dig> %. overall, it presents the best results both on precision and recall. regarding closed source solutions, gimli presents the third best result, with a similar performance as the winner of the biocreative ii gene mention challenge  <cit>  , which uses semi-supervised ml and forward and backward model combination. overall, aiiagmt presents the best result on this corpus . however, the presented solution was prepared specifically for this corpus, applying a complex combination strategy that requires eight different crf models using two different crf frameworks.

considering the jnlpba corpus, gimli outperforms all the open source solutions, achieving an overall f-measure of  <dig> %. it presents a significant improvement of f-measure in comparison with the second best system, genia tagger. compared to the best java-based solution , gimli presents an improvement of  <dig> % of f-measure. it considerably outperforms open source systems in recognition of protein, dna, rna and cell line names. however, it is outperformed in the recognition of cell types. regarding closed source solutions, gimli presents the third best result, with similar results as the winner of the nlpba shared task  <cit>  . when compared with the second best participant of this challenge , gimli presents an overall improvement of  <dig> % of f-measure. nerbio, the best system on this corpus, implements a rule-based post-processing method that was prepared specifically for this corpus. moreover, nerbio presents a very low performance result  on genetag, which could indicate some limitations in adapting this solution to different corpora.

considering a non-blind model combination strategy, as taken by hsu et al.  <cit> , gimli presents slightly better results, achieving an f-measure of  <dig> % on genetag and  <dig> % on jnlpba. such results outperform all the systems that participated on both challenges.

overall, gimli significantly outperforms all the existent open source solutions on both genetag and jnlpba, by simply adapting the feature set used for each corpora and entity type. moreover, it also presents competitive results when compared with similar closed source solutions for both corpora.

speed analysis
the various experiments to check training and tagging speed were performed in a machine with  <dig> processing cores @  <dig>  ghz and 16gb of ram.

the training speed varies with the corpus size, feature set complexity and model order. considering the training parts of both corpora and the final feature set, a second-order crf model takes on average one hour to be trained. on the other hand, a first-order crf model requires on average  <dig> minutes.

in order to check tagging speed and gimli tractability, we developed a simple algorithm to annotate medline abstracts using multi-threading processing. this solution includes input xml parsing, sentence splitting, gimli integration and output generation in xml. it uses a single second-order crf model, but model combination can be easily integrated with reduced speed impact, taking advantage of multi-threaded processing. during this analysis, we considered various configurations of gimli, enabling and disabling the most resource expensive techniques. thus, if users prioritize annotation speed over high performance results, windows can be used instead of conjunctions and dependency parsing can be removed from the workflow. moreover, in order to use the available resources as much as possible, the number of running threads must be inversely proportional to the complexity of the used techniques, since complex techniques require more processing resources. the following results were obtained: 

•conjunctions with dependency parsing:  <dig> threads,  <dig> sentences/second;

•conjunctions without dependency parsing:  <dig> threads,  <dig> sentences/second;

•windows without dependency parsing:  <dig> threads,  <dig> sentences/second.

CONCLUSIONS
this article presents gimli, a new open source and high-performance solution for biomedical named entity recognition on scientific documents, supporting the automatic recognition of gene/protein, dna, rna, cell line and cell type names. gimli implements a machine learning-based solution, taking advantage of conditional random fields. moreover, it supports a rich set of features, including orthographic, morphological, linguistic-based and also domain knowledge features, through the implementation of a lexicon matching technique. additionally, gimli implements advanced conjunctions of features, creating new features based on windows of lemmas and part-of-speech tags. in order to correct mistakes generated by the crf models, gimli also integrates a post-processing module, implementing parentheses correction and abbreviation resolution, aimed at extending incompletely tagged names. finally, gimli also combines several forward and backward models to achieve the best results.

in order to evaluate gimli and compare it against existing systems, we used two well-known corpora: genetag and jnlpba. in the end, it achieved f-measure results of  <dig> % and  <dig> % on each corpora, respectively. these results were compared to the systems that participated in the challenges where the corpora were used, biocreative ii gene mention and nlpba shared task. gimli outperforms all existing open source solutions on both corpora, presenting significant improvements both in results and techniques used.

gimli is an off-the-shelf solution that can be used through two different endpoints, thinking on users with different goals and expertise: 

•command line interface : automatic scripts with easy access to main functionalities, allowing the annotation of documents using provided models, and training new models focused on different entity types, using a configuration file to customize the feature set and model parameters;

•application programming interface : provides complete access to implemented features and associated infrastructure, allowing the easy integration of gimli in complex text mining workflows, by using, extending and/or adapting the provided functionalities.

overall, we believe that gimli provides various characteristics that make it a state-of-the-art solution for biomedical ner: 

•high-end techniques: gimli applies various state-of-the-art techniques and proposes optimizations on various methods, presenting innovative and high-performance alternatives. moreover, it integrates various solutions that are only present on closed source solutions, such as dependency parsing, chunking and model combination;

•flexible: gimli was built thinking on flexibility, founded on a strong infrastructure that allows adding new features and extending or changing existing ones. moreover, gimli offers the only cli that allows feature set and model parameters definition;

•scalable: the internal infrastructure is ready to scale, supporting the development of more complex solutions. moreover, gimli is ready to be used on multi-threaded applications, in order to process millions of documents;

•documentation: we provide complete and detailed documentation of gimli, in order to use both cli and api. together with the associated simplicity and self-explanatory code, we believe that gimli is easy to use, change and extend.

developers and researchers of the biomedical domain, especially text mining experts, can take advantage of the presented characteristics to develop their own ner and/or post-ner applications. gimli reduces the required effort to develop innovative ner solutions, increasing the users’ time to focus on their main goals. thus, it can be used to support the development of various multi-disciplinary solutions: a) ner using different corpora and target entity names, such as disorders and chemicals; b) normalization; c) relation extraction, such as protein-protein interactions; and d) information retrieval.

with the results achieved and the characteristics presented by our system, we strongly believe that gimli is a state-of-the art solution for biomedical named entity recognition, contributing to faster and better research in the field.

future work
although gimli already incorporates various improvements on existing tools, some aspects can be further explored. we are currently investigating other approaches for model combination, considering for example the introduction of domain knowledge information and/or context based harmonisation through the use of dictionaries or machine learning-based solutions  <cit> . as for the recognition of particular entity types such as dna, rna, cell type and cell line, we are working on improving the lexicons in order to achieve better precision. an interesting area to explore is the use of feature induction  <cit>  to automatically extract informative features from texts, in order to improve the feature set and obtain “hidden” characteristics of the tokens. the second technique that could be studied is semi-supervised learning  <cit> , using both annotated and unannotated data in order to extract characteristics of the unlabelled data that could contribute to better recognition of entity name boundaries. regarding the use of gimli, it could be interesting to implement a set of web services to streamline its integration in other tools and disseminate the simple and fast annotation of scientific documents. furthermore, although gimli offers a simple to use command-line application, developing a gui interface could simplify the analysis of the generated annotations.

there are already various solutions being developed on top of gimli, such as: a) a framework for biomedical information extraction supporting ml and dictionary-based methodologies for normalization of biomedical concepts; b) a solution based on semi-supervised ner for gene and protein names recognition; and c) an information retrieval solution for knowledge discovery focused on degenerative diseases.

availability and requirements
•project name: gimli

•project home page:http://bioinformatics.ua.pt/gimli

•operating system: platform independent

•programming language: java

•other requirements: java  <dig>  or higher

•license: creative commons attribution-noncommercial-sharealike  <dig>  unported license

•any restrictions to use by non-academics: non-commercial use

abbreviations
crfs: conditional random fields; hmms: hidden markov models; memms: maximum entropy markov models; ml: machine learning; ner: named entity recognition; pos: part-of-speech; svms: support vector machines

competing interests
the authors declare that they have no competing interests.

authors’ contributions
dc participated in the design and implementation of the system and drafted the manuscript. sm and jlo conceived the study, participated in its design and coordination and helped to draft the manuscript. all authors read and approved the final manuscript.

