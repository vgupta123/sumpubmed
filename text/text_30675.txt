BACKGROUND
small non-coding rna  molecules are dna sequences that are transcribed into rna but are not translated further into protein sequences; rather they mediate their cellular functions as rna molecules. these molecules have been the subject of much interest, as recent studies have shown that they are widespread in a variety of organisms, conserved in evolution, and play essential enzymatic and regulatory roles in many cellular processes. experimentally, these molecules have been difficult to identify because of their small size and generally low abundance. therefore, they were overlooked for many years both in experimental and bioinformatic studies. it is only in the last few years that systematic genome-wide computational and experimental screens were carried out to identify ncrna-encoding genes, both in prokaryotes and eukaryotes  <cit> . ncrna molecules were found to be involved in ribosome rna maturation and modification , replication , protein translocation , gene silencing , and many other functions  <cit> . furthermore, it was suggested  <cit>  that cellular control based on ncrna is a major determinant of the complexity of organisms, especially in higher eukaryotes, as ncrna molecules may offer an additional cellular control mechanism that complements protein-based regulation.

computational identification of ncrna molecules is more difficult than identifying protein coding genes. on the sequence level, to identify protein coding genes in a genome, one can take advantage of the existence of several characteristics or motifs included in all coding sequences such as open reading frames, the three base periodicity of codons and the amino-acid coding preference. in addition, other signs of genes are embedded in the regions flanking the coding sequence, including promoters, enhancer sequences, and others. in general, similar signals have not been identified, and are clearly weaker for ncrnas. on the structural level, ncrna molecules are characterized by a secondary structure that is formed by pairing of complimentary bases  along the single strand molecule. however, it is clear that given a small alphabet of four letters with this pairing potential, many secondary structures are possible even for sequences that do not encode ncrna  <cit> ; thus, it is difficult to recognize ncrnas solely based on their potential to form secondary structure  <cit> .

despite these difficulties, many classes of ncrna have been identified computationally. techniques such as sequence conservation in concert with thermodynamic stability have been successful in computationally identifying ncrna molecules  <cit> . however, identifying ncrna is only part the challenge. as mentioned above, most ncrna are characterized by distinctive secondary structures, which often correspond to their respective functions. thus, given an ncrna sequence, the task of accurately predicting its secondary structure is of utmost importance.

the two main programs that are widely used to predict the structure of single ncrna molecules are mfold  <cit> , and rnafold of the vienna package  <cit> . both programs use a dynamic programming approach to calculate the structure with the minimal free energy   <cit> . the basic algorithm is straightforward and was originally suggested by nussinov  <cit>  to identify the structure with the maximal amount of base pairing. however, the actual implementation for secondary structure prediction of ncrna molecules is more complicated. correct free energy calculation involves many parameters that are relevant to the energy function of a folded rna molecule, including stem energy , the size of loop structures, stacking energy between consecutive pairs of nucleotides, temperature, etc.  <cit> . while these programs are the result of extensive effort and innovation, they often fail to identify the true structure as the prediction with the mfe. for example, a recent review  <cit>  showed that a prediction based on mfe was able to correctly predict the cloverleaf structure of trna in only 30% of cases. in one case, these authors noticed that the correct trna structure was ranked  <dig> in the list of predictions suggested by the rnasubopt  <cit>  program, which is a variant of the basic prediction algorithm and outputs a list of predicted structures which can be ranked by their mfe. a short computational experiment we performed on our dataset  indicates that a list of  <dig> suboptimal structures is likely to contain at least one reasonable prediction. furthermore, if one ranks the list of predictions by their mfe, there is a correlation between the ranking in the list and the probability of a prediction being correct. however, this correlation is rather weak, and it is therefore not usually possible to choose the best prediction on the basis of its mfe. as will be elaborated on below, our method has the ability to identify the correct prediction from within this list.

the difficulties in predicting the structure of a single rna molecule led to the idea that structure predictions may be more accurate if they are based on multiple sequences of a single class of molecules. it is well known that secondary structure is conserved within ncrna families . thus, simultaneous prediction of the structure of a set of related ncrna might reveal the correct common structure for the sequences that comprise a particular family. furthermore, application of a fast comparative prediction algorithm can result in a tool for detecting novel ncrna molecules. such a comparative prediction tool can serve as the core component of a bottom-up clustering algorithm  <cit>  by iteratively expanding an initial seed of ncrna candidates that share a common structure, one can identify additional novel families of ncrna from within a set of ncrna candidates.

several algorithms  <cit>  have been suggested to find a common structure when the sequence alignment is given. for example, rnaalifold  <cit>  combines both thermodynamic stability and sequence covariation by using a dynamic programming approach, in which the energy value that determines the inclusion of a given basepair in the final structure reflects not only the thermodynamic complimentarity value of the basepair, but also the degree of covariance of the nucleotide pair within the set of sequences. in a different version of the problem where the secondary structure of each sequence is either known or predicted, marna  <cit>  and rnaforester  <cit>  can be used to take these individual secondary structure assignments and align them to produce a global multiple structural alignment.

when the sequence alignment or the individual structure assignments are not pre-determined, several programs attempt to solve the problem of simultaneously finding the best alignment and a shared secondary structure by assuming a common structure for groups of ncrna molecules. some programs, such as dynalign  <cit> , and scarna  <cit>  are designed to align and predict the structure of two molecules, while other programs  <cit>  are designed to align and predict the structure of a larger dataset. most of these programs are largely based on some variant of sankoff's dynamic programming algorithm for simultaneously folding and aligning multiple rna sequences  <cit> . sankoff's algorithm considers all possible folds and all possible alignments of the sequences, so while it is thorough, it is prohibitively slow and memory consuming  <cit> . in order to achieve a reasonable run-time, constrained versions of the algorithm have been implemented. for example, the stemloc algorithm  <cit>  essentially uses stochastic context-free grammar  as a scoring scheme for sankoff's algorithm. stemloc has a pre-folding and pre-aligning step which folds each sequence individually and aligns them in pairs based on sequence alone, before implementing the pairwise scfg stage. pmcomp  <cit>  is another variant of sankoff's algorithm, which takes pre-computed basepair probability matrices as input from mccaskill's algorithm  <cit> , and performs pairwise alignments of rna sequences. pmmulti  <cit>  is a wrapper program that does progressive multiple alignments by repeatedly calling pmcomp. foldalignm  <cit>  is a wrapper for the foldalign program, which is largely based on the pmcomp program.

sankoff-based algorithms attempt to simultaneously align the sequences and predict their structure. in a deviation from this concept, rnacast  <cit>  bypasses the need to find a global alignment and focuses on predicting the best secondary structure for each sequence. this is done by predicting 'shapes', which are structures at different levels of abstraction, for each sequence, and then finding a consensus shape that is common to all sequences. for each sequence, the final prediction is the structure with the lowest mfe among all the structures that are mapped to that consensus shape.

our algorithm shares the principle and logic of rnacast in that it looks for structure predictions for each sequence and searches for them from within a list of suboptimal predictions. however, there is a significant difference between our approach and that of rnacast. rnacast depends on the existence of a common 'shape' and assigns these shapes to the same key in a hash table. rnaspa, while operating under the assumption that the sequences have similar structure, does not depend on this assumption and will look for the best path between the predictions even if they are dissimilar. therefore, as will be shown later, rnaspa is able to produce structural predictions even when the data is 'contaminated' with a small numbers of unrelated molecules.

RESULTS
three main problems arise when trying to evaluate the performance of rna secondary structure prediction algorithms. one is establishing the data set on which to evaluate the performance of the algorithm, the second is identifying 'the real structure' against which the predictions are tested and the final issue is choosing the measures to be used when evaluating a comparison between a structure prediction and the 'real structure'.

data sets
one major problem in the field of rna structure prediction is the lack of a good common benchmark that can be used to judge the quality of structural predictions. the bralibase  <cit>  was the first useful resource to address this need. however, bralibase i offers structural information for only small number of single  sequences. bralibase ii, which offers aligned sets of five large families, concentrates on the alignment aspects of the problem; namely, it shows how rna sequences should be aligned relative to each other, but it does not supply a secondary structure for each sequence. bralibase  <dig>   <cit>  includes a larger set of aligned sequences, but again it does not include a structural assignment for each sequence. thus, it is not suitable for testing the validity of our algorithm, which returns a structure prediction for each molecule.

as in many other similar studies , rfam  <cit>  was used as the source for the dataset in this study. rfam version  <dig>   <cit>  is a large collection of ncrna families. the seed alignment of each rfam family contains known representative members of the family as well as a structural assignment, which was hand-curated.

first data set
to enable comparison with previous studies, we used the same families that were used by hamada et al.  <cit> . the dataset includes eight ncrna families: trna, tymovirus/pomovirus trna-like 3' utr element , purine riboswitch , lysine riboswitch , sam riboswitch  , fmn riboswitch  , cobalamin riboswitch , and glms glucosamine-6-phosphate activated ribozyme .

these rna families form a diverse dataset including trna and trna-like molecules, riboswitches and ribozymes. trna molecules have a highly conserved structure from bacteria to man and function in protein translation. the tymo rnas are similar to trna molecules in structure and adenylation at the 3' end, but unlike trna are not aminoacylated. they are present in the 3' utr of viral rnas, and their structure is important for viral replication. riboswitches are composed of a single metabolite-binding aptamer and a single expression platform that function together to regulate genes in response to changing metabolite concentrations. ribozymes are rnas with the ability to act as enzymes and cleave target rna.

these rna families have well-characterized biological functions and possess distinct rna secondary structures. the number of stems of the family members varies from three  to nine  and their length varies from  <dig>  to  <dig>  bps. the average standard deviation of lengths within each family as well as the average sequence identity is detailed in table  <dig>  for comparison with other currently used programs, we randomly selected groups of ten sequences from each family, so that each sequence was selected at most once and so the number of sequences for each family would not exceed  <dig>  all the other sequence groups used for testing various aspects of rnaspa's performance were selected with the same criteria. the eight families with their structural annotations are available .

each family was represented by several non-overlapping datasets . the mcc score is averaged among the datasets of each family. the number of datasets in which the program failed to produce an output appears in brackets. "no data" denotes that the program failed on all datasets. in some cases, stemloc returns a consensus structure for only part of a dataset. therefore, the mcc score reported here only reflects those sequences for which a structure was predicted. see  for raw data.

second data set
as rnacast  is the most similar algorithm to rnaspa, we also directly compared rnaspa against rnacast using the same dataset on which rnacast was evaluated  <cit> . this dataset contains the following families: the transfer trna; the lin <dig> mirna; the 5s ribosomal rna; the signal recognition particle srp rna; ires: the viral internal ribosome entry sites element; the purine riboswitch and the sam riboswitch; the small nuclear rnas: u <dig>  u <dig> and u <dig> 

third data set
this dataset contains  <dig> randomly chosen ssu  rrna sequences . their sequences and structures were downloaded from  <cit> . these sequences range in length from about  <dig> to  <dig> bps. these sequences with their structural annotations are available .

the structural standards
unlike protein structures, where there is a large set  of three dimensional structures determined by the highly accurate experimental methods of x-ray crystallography and nmr, experimental data for both secondary and tertiary structure of rna molecules is very scarce. x-ray structures are available for only a few molecules. for other molecules, cross-linking data and other biochemical studies can provide some information on their secondary structure. for most families of ncrna, the structural information, as provided by rfam and other databases, is based on computational methods such as infernal  <cit> , and thus is not sufficiently reliable as a source for structural 'standards'. for seven of the eight families that constitute the data set used in this study, the secondary structure information provided by rfam is cited as coming from published experimental studies. technically, the secondary structural information in rfam is encoded by the color-coding of complementary regions that forms the stems in each structure, which is equivalent to a string representation of the structure in bracket notation.

measures of accuracy
to evaluate and compare the predictions provided by rnaspa with the 'correct' structure, we used the matthews correlation coefficient  which correlates, on a base by base basis, between the prediction and the correct structure. the mcc measure is used in many studies to evaluate the accuracy of rna secondary structure prediction methods  <cit> . after counting the number of true-positives , true-negatives , false-positives , and false-negatives  for each alignment relative to rfam, mcc provides a measure of accuracy, which is expressed as a number ranging from - <dig> for assignments that are false, around  <dig> for random assignments, and  <dig> for assignments that are all true. note that the single value provided encapsulates all four accuracy measures, and an mcc measure closer to  <dig> denotes higher accuracy.

 mcc=tp⋅tn−fp⋅fn⋅⋅⋅.
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaacqwgnbqtcqwgdbwqcqwgdbwqcqgh9aqpdawcaaqaaiabdsfaujabdcfaqjabgwsixlabdsfaujabd6eaojabgkhitiabdaeagjabdcfaqjabgwsixlabdaeagjabd6eaobqaamaakaaabawaaewaaeaacqwgubavcqwgqbaucqghrawkcqwggbgrcqwgqbauaiaawicacaglpaaacqghfly1daqadaqaaiabdsfaujabdcfaqjabgucariabdaeagjabd6eaobgaayjkaiaawmcaaiabgwsixpaabmaabagaemivaqlaemota4kaey4kasiaemoraykaemiuaafacagloagaayzkaagaeyyxic9aaewaaeaacqwgubavcqwgobgtcqghrawkcqwggbgrcqwgobgtaiaawicacaglpaaaasqabaaaaogaeiola4caaa@638f@ 

the four true/false/positive/negative parameters were counted, similar to  <cit>  as follows: in the case of left and right brackets at the exact same position, we add  <dig> to tp. if rnaspa agrees with the rfam annotation that there is no stem at a certain base, we add  <dig> to tn. if rnaspa predicts a basepair while rfam determines that both bases do not participate in any pair, we add  <dig> to fp, and conversely, if rfam indicates that two bases form a pair and rnaspa predicted neither, we add  <dig> to fn. finally, rnaspa and rfam may agree that a base participates in a base-pairing, but disagree as to the identity of the binding partner. in this case, both fp and fn are incremented by  <dig> 

the rank of the 'correct' structures within the list of suboptimal structures
we present here a polynomial time algorithm and its implementation, which performs well for ncrna structure prediction. the algorithm builds on the ability of the vienna package's rnasubopt to include at least one structure close to the 'true' structure in the set of suboptimal solutions that it suggests. thus, it is important to first evaluate the improvement that our method offers compared with directly using the results of rnasubopt. first we analyzed, for our dataset, the accuracy of the predictions of rnasubopt. rnasubopt has two modes of operation: 'complete enumeration'  that enumerates all structures within a predefined range of the mfe structure and 'boltzmann sampling'  that samples the space of suboptimal structures following a boltzmann distribution of their mfe. unless mentioned otherwise, rnasubopt was run in the 'complete enumeration' mode in the experiments described below. a comparison between these two modes is shown in table  <dig>  the 'complete enumeration' mode performed better on shorter sequences and the 'boltzmann sampling' mode performed better on longer sequences. this can be explained by the nature of these two modes. the two modes trade density for diversity. within a given energy range in the complete enumeration mode, shorter sequences yield a diverse set of suboptimal structures, but as the length increases an increasing number of suboptimal structures with only minor differences are suggested and therefore sampling becomes more important. we ranked the  <dig> structures predicted by rnasubopt for each sequence in two ways: by their mcc score , and by their mfe . then, we looked at the structure with the best/worst mcc score and found its position in the mfe ranked list. averaged results for each dataset are shown in figure  <dig>  the results show that, on average, the structures with the best mcc scores tend to originate from predictions with better mfes than those with worse mcc scores. however, these values have very large standard deviations, and thus the correlation is not reliable. note further that among all the datasets the average mfe-based ranking for the structure with the best mcc score was equal to or greater than  <dig>  thus, the mfe alone cannot identify the 'correct' formations, and we resorted to a comparative approach.

the time columns indicate the average run-time in seconds per sequence for the corresponding modes of running rnasubopt. the 'complete enumeration' mode performed better on shorter sequences  and the 'boltzmann sampling' mode performed better on longer sequences . see  for raw data.

algorithm outline
the algorithm we present here, rnaspa , aims to predict the secondary structure of a set of ncrna molecules using a novel approach. the algorithm is presented schematically in figure  <dig>  the input for our algorithm is a set of n unaligned sequences: s <dig>  s <dig>  s <dig> ..., sn. the first stage uses the vienna package rnasubopt program  <cit>  to suggest a large number of possible structures for each sequence in the set. at the end of the first stage, each si sequence has v predicted structures: si <dig> si <dig> si <dig> ...,siv
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaacqwgtbwudaqhaawcbagaemyaakgabagaegymaedaaogaeiilawiaem4uam1aa0baasqaaiabdmgapbqaaiabikdayaaakiabcycasiabdofatnaadaaaleaacqwgpbqaaeaacqaizawmaagccqggsaalcqgguaglcqgguaglcqgguaglcqggsaalcqwgtbwudaqhaawcbagaemyaakgabagaemovayfaaaaa@41dd@ including the optimal structure and v- <dig> suboptimal structures. in the second stage, each sij
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaacqwgtbwudaqhaawcbagaemyaakgabagaemoaaogaaaaa@30c0@ is assigned as a vertex in a graph. conceptually, the v alternative structures of each sequence si form a layer of vertices in the graph, and the layers are piled one on top of the other . each of the vertices belonging to si is connected by a directed weighted edge to the vertices of si+ <dig>  which is the adjacent layer below. the weight assignment for each edge is calculated based on the similarity between the two alternative structures that it connects. at the end of the second stage, the construction of the graph is completed ). the resulting graph is a directed acyclic graph . in the third stage, we compute the shortest path in the graph by a breadth-first traversal from the top  to bottom  in a linear time in the number of edges. we consider a path in the graph to be the sum of its component edges. the shorter a path is in this graph, the greater is the similarity between the vertices forming the path. in other words, the shortest path represents a set of predicted structures, one predicted structure for each sequence that forms the best compromise between the different structure predictions. this is true because similar secondary structures yield edges with a lower weight.

in the final stage of the algorithm, we address the relaxation we have employed by comparing only structures of adjacent sequences. it is reasonable to suggest that a different ordering of the sequences could have produced a different shortest path yielding a different set of proposed structures. to partially compensate for this relaxation the above procedure  is reiterated several times, each with a different input sequence order. each run results in a new  proposed path. the shortest paths are re-ranked based on the 'sum-of-pairs' value. the ranking is performed by going over the n2
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaadawcaaqaaiabd6gaunaabmaabagaemoba4maeyoei0iaegymaedacagloagaayzkaaaabagaegomaidaaaaa@33de@  vertices that form the shortest path and summing up the similarity between each of the pairs  ). after that, we choose the best of the shortest paths proposed . the program outputs a secondary structure prediction for each of the sequences.

string and tree edit distance
as each layer of v vertices is compared to its adjacent layer, yielding o comparisons, the bottleneck of our algorithm is how rapidly it can compare two structures, and how many times it must do so. rna secondary structure can be represented in several ways from a simple string in bracket notation, to an enriched string representing structural features like loops and bulges, or even as a complex tree structure. many metrics have been developed to calculate the pairwise distance between rna secondary structures. m. höchsmann gives an extensive overview on rna structure comparison methods in  <cit> . one common metric is the hausdorff distance  which was used by zuker  <cit>  to filter redundant structures in the mfold program. the hd between two rna structures is the maximal distance between each basepair in one structure and its nearest neighbour basepair in the other structure. the linear calculation time of the hd measure makes it useful for coarse similarity detection. the obvious disadvantage of hd is that it reflects the most extreme dissimilarity between the structures, making it blind to small-but-many dissimilarities.

another common approach is to represent the rna secondary structures as a string in bracket notation and to compare them using needleman-wunsch's global alignment algorithm  <cit>  which runs in o time. the major flaw in using this string edit-distance  approach is that brackets are not treated as a single unit. a simple example can illustrate the potential problem in using string ed for bracket notation. consider three strings:

a = ....., b = ..., and c = .......

where a bracket represents matched base and a dot represents an un-matched base.

the ed of {a, b} is  <dig> mismatches, and the ed of {a, c} is  <dig>  however, in both cases the molecular process is the same; the fourth base has changed its basepair partner, in b the base pairing is between bases  <dig> and  <dig> and in c it is between bases  <dig> and  <dig> 

representing rna secondary structures as a tree enables a more sensitive comparison of structures, as bases that are paired are treated as an inseparable unit. however, a tree-based approach is considerably slower. tai  <cit>  was the first to introduce the tree ed metric. zhang and shasha  <cit>  suggested an o
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaacqwgpbwtdaqadaqaaiabdsfaunaadaaaleaacqaixaqmaeaacqaiyagmaagccqwgubavdaqhaawcbagaegomaidabagaegomaidaaagccagloagaayzkaaaaaa@35f2@ time algorithm. the fastest known algorithm for tree ed is bounded by o  <cit> . in our method, we used string ed instead of tree ed in order to improve the run-time for the weight assignment to the edges of the graph. to determine if this heuristic is legitimate, we used the program rnadistance  <cit> , which is part of the vienna package, to calculate tree ed. we calculated the tree ed between all pairs of the  <dig> members of the lysine dataset, and compared the results with the simple global alignment distance using weights of one for all edit operations. figure  <dig> shows that the tree and string ed are highly correlated. the correlation coefficient between the two datasets is  <dig> . remarkably, we found little difference between the results obtained using the string or tree edit comparisons. our results strongly indicate that the benefit of tree ed is minimal, especially given the expensive run-time.

accelerating string edit distance
while string ed is much faster than tree ed, it still requires quadratic run-time. in practice, the run-time can be significantly reduced. as detailed above, each layer of vertices in the dag is calculated based on the previous  layer. for our application, when calculating a given layer, we need only the best {vertex plus edge} value from the vertices and their edges located in the layer above. therefore, we initially limit the ed dynamic programming procedure to allow only k  mistakes . this is done easily by filling only the 2k-wide-diagonal. note that this calculation requires time kn rather than n <dig>  if none of the upper vertices has an ed of k or less, k is multiplied by two and the procedure reiterates. in practice, this simple heuristic reduces the run-time without losing accuracy. moreover, while examining an upper vertex, one can forfeit the ed calculation for this vertex and skip to its neighbour if the value of this vertex plus the minimal expected score of the ed  is greater  than the value already obtained for the bottom vertex . in practice, these heuristics allow for a reduction of about 25% in the running time.

the run-time of rnaspa
we observed that it is not necessary to compare, in the first stage of the algorithm, each of the n sequences  against all the other sequences . instead, each sequence is compared with only one other, arbitrarily chosen, sequence. we show below that the internal order of the sequences that are to be compared has only a marginal effect on the accuracy of the predicted structures. this observation enabled us to approach this problem by using a linear time  graph algorithm technique to search for the shortest path in a dag.

the algorithm uses two adjustable parameters: the number of suboptimal alignments for each sequence , which we can afford to leave quite large, and the number of different sequence orderings or arrangements analyzed before choosing the best alignment.

the algorithm run-time is kept to a reasonable polynomial: o where n is the number of sequences, l is the length of the sequences, s is the number of samples from the sequence's order permutation space, and v is the number of suboptimal structures proposed for each sequence. as n and s are relatively small, the run-time is dominated mostly by l <dig> – the time needed to fold a sequence by rnasubopt, and v2l <dig> the time needed to calculate the edges of the graph. note that because the edges of the graph are only conceptual, they are calculated and immediately used, and therefore need not be maintained in memory.

rnaspa favours 'correct' structures
for each sequence, we took the  <dig> structure predictions suggested by rnasubopt and calculated the worst, average, and best mcc scores for these structures. we then compared them with the mcc score of the prediction selected by our rnaspa algorithm. the results, averaged over each family, are shown in figure  <dig>  the results show that the structures suggested by rnaspa are clearly better than the average of the predicted structures, and in most cases are very close to the best possible structure that is present in the set of rnasubopt predictions. thus, in a very reasonable running time, our method is capable of extracting from rnasubopt the most accurate structures.

sampling the permutation space of the sequence order
we first tested the robustness of our algorithm to the arbitrary order of the sequences chosen. we randomly chose a set of five sequences from each family. we ran rnaspa on all 5! =  <dig> order permutations to measure the variation of the accuracy level as a function of the sequence order. we used  <dig> suboptimal structures for each sequence. figure  <dig> shows that while some permutations show a significant deviation from the typical mcc score, most permutations exhibit similar results; thus, it is unlikely that a particular randomly selected order will yield the poorest results. nevertheless, as described above, in order to reduce the probability of choosing an order that will yield a poor prediction, for each run we used several arbitrary fixed orders and calculated the shortest path for each of them. the winning solution was the solution with the lowest sum-of-pairs value between all the secondary structures comprising its shortest path. figure  <dig> shows that selecting the winning permutation based on the sum-of-pairs of the predictions comprising the shortest path is an improvement over using the permutation with the shortest path. the fact that the algorithm is based on calculating paths in linear time, and only in the final stage is a quadratic time sum-of-pair score calculated, enables the algorithm to scale, in practice, almost linearly with the number of sequences.

the effect of various parameters on rnaspa performance
we next measured the effect of our major parameter, the number of suboptimal solutions considered for each sequence, on the performance of rnaspa. results are shown in figure  <dig>  as expected, a larger set of suboptimal solutions tested yields better accuracy. however, it seems that about  <dig> vertices are sufficient, as the accuracy level doesn't increase substantially if the number of vertices is further increased.

the second parameter used by rnaspa is the number of samplings performed on the space of permutations of the order of the sequences. as we illustrated above, comparing the sequences in an arbitrary order is likely to yield an average mcc score. however, our results suggested that performing a small number of samplings on the order permutation space is sufficient to ensure reliable results. on the other hand, it is difficult to identify the optimal order, as the search space is exponential in the number of sequences. in practice, the optimal result offers only a small improvement over the typical performance of the algorithm, while it demands exponential time as there are n! possible permutations, where n is the number of sequences. the contribution of the number of samplings to the accuracy level is illustrated in figure  <dig>  with small sample size, the mcc score improves as the number of samples taken increases, but it reaches limiting returns when the number of samples exceeds four. the diminishing improvement can be explained by the fact that only a small fraction of the order permutations need to be re-sampled in order to significantly improve their score.

we also checked how the number of sequences in a set influences the accuracy of rnaspa and its running time. as figure  <dig> illustrates, the performance  generally improves as the set size increases from  <dig> to about  <dig> or  <dig>  for larger sets, the accuracy is not affected by set size. note that the run-time is close to linear in the number of sequences.

comparison with other programs
we compared our method with four state-of-the-art programs: stemloc   <cit> , pmmulti  <cit> , foldalignm  <dig> . <dig>  <cit> , and rnacast . by default, rnaspa was used with  <dig> suboptimal structures of each sequence, and  <dig> samplings of the permutation space. stemloc was configured with nf =  <dig>  we also ran stemloc with nf =  <dig> but the results did not show a clear improvement and the running time was about  <dig> fold slower . pmmulti, foldalignm, and rnacast were run with their default parameters. the results, based on correlation of the mcc score to the rfam annotation, which was used as a 'gold standard', are shown in table  <dig>  in our trials, each the four programs  failed to produce results for at least one of the datasets of the eight families. for two families, cobalamin and glms, pmmulti and foldalignm failed and could not produce an output due to limitations on sequence length and memory requirements, respectively. rnacast failed to give a prediction in at least one dataset for seven of the eight families because it couldn't find a common structure. rnaspa was able to handle all the datasets. the performance varied for the different families, but overall, rnaspa performed better than the four other programs. for three out of the eight families, it provided the best mcc scores.

we measured the run-time of the programs. table  <dig> shows their performance under the same configuration used in table  <dig>  we also wanted to explore the relation between the run-time and the length of the sequences in the dataset. we used a set of five ssu rrna sequences and we measured the run-time for increasingly longer windows. figure  <dig> illustrates rnaspa's ability to outperform other programs both in terms of the effect that increasing sequence size has on the runtime and its ability to run on long sequences. all computations were performed on an intel xeon  <dig>  ghz cpu with  <dig> gb ram running linux.

for all datasets, except glms which did not yield results, the runtime of rnacast was less than one second. rnaspa always ran faster than pmmulti and foldalignm. in four of eight families it ran faster than stemloc and its overall running time is better than stemloc's run-time.

the results show that rnacast and rnaspa, the two non sankoff-based programs, offer the best combination of performance and runtime. rnacast was significantly faster. in order to further compare the accuracy of rnaspa and rnacast, we performed an additional test using the same data set that was initially used to evaluate rnacast  <cit> . the results, shown in table  <dig>  show that while both programs performed well, the accuracy of rnaspa was somewhat higher than that of rnacast  for seven out of ten families. an important difference between rnaspa and rnacast is that the rnacast program must be able to find a consensus shape in order to process a dataset, while rnaspa will always return a structural prediction. to evaluate the implications of this difference, we examined the ability of rnaspa and rnacast to handle a contaminated dataset. frequently, a set of sequences may be 'contaminated' by one or more sequences that do not actually belong to the same family. we took the  <dig> families mentioned in table  <dig> and randomly picked an additional sequence from another family and added it to the dataset . the results in table  <dig> illustrate that with a contamination of a single sequence, rnacast was unable to process six out of the ten families, while rnaspa was able to produce results in all runs.

rnacast was run using four different configurations. rnacast parameters that were used: -t sets the shape type . shape type defines the level of abstraction from most accurate to most abstract . -c sets the energy range . for seven out the ten families rnaspa gave better results. see  for raw data.

contaminated datasets were constructed by adding a single randomly picked sequence from a different family to each family tested. rnaspa was able to produce good results for all families while rnacast was unable to find a consensus structure for six of the ten families in a contaminated dataset. see  for raw data.

robustness of rnaspa to contaminated datasets
we further investigated the extent to which the performance of rnaspa can withstand the effects of contaminated data. specifically in our algorithm, a sequence that has a very different set of potential suboptimal structures would break the path into two detached components. as one would expect, a contaminated set reduces the performance of the algorithm. however, rnasubopt's worst mcc score serves as a 'safety net' in these cases. figure  <dig> shows the performance of the algorithm when two different datasets  were mixed together in varying proportions starting with a set of ten lysine sequences, followed by a set of nine lysine and one purine, then eight lysine and two purine, and so on. the results show that our method is quite robust to this kind of contamination, although, as expected, as the number of sequences that do no belong to the family increases, there is a negative effect on the performance.

discussion
to illustrate the advantage of the shortest path approach, we review two alternative straightforward approaches for the task of comparative prediction of secondary structures, using suboptimal predictions. it is easy to see that an optimal solution would involve using weighted edges to connect each of the vertices of the dag with the vertices on the other layers and then finding the minimum edge-weighted clique  of size of n – the number of sequences. the run-time would be exponential, as mewc is an np-hard problem  <cit> , although heuristic approaches can be used to reduce the run-time in practice. the second approach is based on a polynomial time greedy bottom-up upgma-like algorithm. the idea is to find the most 'similar' pair of sequences  and then 'merge' the pair and reiterate the procedure. this algorithm demands quadratic time in the number of sequences, making it feasible. however, there are quite a few pitfalls of the latter algorithm. the merging process of two structures might favour a third structure that does not resemble either of the original two. moreover, the initial pairs, although having the best score, might prove a poor starting point leading to a weak overall solution.

rnaspa, unlike the latter algorithm, uses a different relaxation. the time complexity is reduced from exponential to linear  by a heuristic that imposes order on the list of sequences. as the order we impose is arbitrary, and as each different order yields a different solution, the algorithm is not guaranteed to find the optimal solution. however, we have demonstrated  that by sampling a relatively small number of arbitrary orders, an order close to the optimal can be found. the process of finding the shortest path gives an equal weight to each potential structure, yielding a solution that is the best compromise for all. of course, this advantage comes with a price; each sequence  is compared with only one other sequence. in this context, it is important to note, that the comparison process of sequences a to b and b to c, retains a great deal of information on the relation between a to c. for two edges between ai to bj and bj to ck we can be sure that an edge between ai and ck will be less or equal in weight to the two edges. therefore, the weight of the shortest path is a lower bound of the overall similarity. the process of finding the shortest path indirectly harnesses these transitive relations.

why is the string ed sufficient for rnaspa? it is important to remember that only similar structures are of interest. we have shown in figure  <dig> a correlation of  <dig>  between tree ed and string ed. we also showed in that figure that the correlation between the results that had tree ed less than or equal to ten, is even better:  <dig> . we can explain this very high correlation by suggesting that similar structures have, in many cases, the same topology . in this case, tree and string ed are highly correlated. when the topology is different, in many cases, stems  need to be relocated or created; therefore, there are many letters/nodes that are involved in the 'correction' procedure, thus the overall similarity is poor, and usually not relevant.

rnacast and rnaspa follow the same logic of investigating the space of suboptimal structures. rnacast is extremely fast and thus should be used in cases when speed is important. on the other hand, rnaspa performed a little better in our benchmarks. however, the greater advantage of rnaspa over rnacast is its ability to address 'contaminated' data, i.e. situations in which not all sequences share the common structure, as described in table  <dig>  note that this is not only a problem with an artificial experiment. looking at table  <dig>  one can notice that rnacast failed several times to produce an output for several datasets of the same family of ncrna, probably due to the fact that it did not find a common shape for all sequences. another advantage of rnaspa is its ability to address longer sequences. using ssu rrna as an example, we were able to run the program on sequences of length  <dig> bps, where as rnacast was not able, at least in its current public version, to address such lengths.

inspired by the power of abstraction of rna structures that was demonstrates by rnacast, we suggest an application that might help in finding unknown ncrna families hiding within a large set of ncrna candidates  <cit> . similar to rnacast, many suboptimal abstract shapes are can be generated for each sequence. then, the abstract shapes of all the sequences in the set can be sorted, clustering together different sequences that share the same abstract shape. each set of sequences sharing the same abstract shape is a potential ncrna family. initial results produced by a prototype program that we developed confirmed the speed and feasibility of this direction.

an interesting application of algorithms like rnacast and rnaspa that are based on looking for common structures in the pile of suboptimal structures might be in predicting the secondary structure of riboswitches  <cit> . those are a class of ncrna molecules that can adapt more than one possible structure, usually upon interaction with different ligands. as suggested in  <cit> , a set of riboswitches can be identified if it has two consistent suboptimal structures, each for a different conformation of the riboswitch, that are present for all  of the sequences. rnaspa can be modified to find such cases by looking for the two shortest paths in the graph. we note however that this is not trivial as the second best path is likely to be a variation of the first path rather than a totally different path. one possibility to address this problem is to eliminate from the graph all the nodes that participate in the first path and other similar nodes before looking for the second path. similar issues have been addressed when looking into suboptimal sequence alignments  <cit> .

CONCLUSIONS
we note that current rna secondary structure prediction algorithms are still far away from producing consistent satisfactory predictions. however, within the set of currently available programs our approach is fast, simple and on average performs better than other secondary structure prediction methods. rnaspa relies heavily on the long-standing work of the vienna package team, their knowledge and available applications, and further extends its performance. we intend to use our tool as a component of a wider clustering algorithm to identify novel families of ncrna from a set of ncrna candidates.

availability and requirements
project name: rnaspa

supplementary information: 

operating systems: unix, linux.

programming language: c/c++.

restrictions on non-academic use: none.

authors' contributions
yh developed the core idea of the algorithm and implemented it. td tested the implementation extensively and helped in comparing the performance of rnaspa to that of other programs. sm provided advice about the biological applications of the algorithm, and ru suggested approaches to evaluate the algorithm and demonstrate its performance. all authors read and approved the final manuscript.

note added in proof
the foldalignm program offers two versions, one is based on foldalign matrices and   the other on mccaskill matrices. we unfortunately arbitrarily have chosen to use the   foldalign based version. we later became aware by the authors that the version  that uses the mccaskill matrices runs much faster. thus, the results presented here   reflect only the performance of the slower version and not the real performance of the   foldalignm method.

supplementary material
additional file 1
sets of ten sequences. random non-overlapping sets of ten sequences.

click here for file

 additional file 2
sets of five sequences. random non-overlapping sets of five sequences.

click here for file

 additional file 3
sequences and structures. the eight families and the rrna ssus family with their rfam annotated structure.

click here for file

 additional file 4
contaminated sets. the dataset used from the supplementary data of: jens reeder and robert giegerich: consensus shapes: an alternative to the sankoff algorithm for rna consensus structure prediction. bioinformatics  <dig> 21: 3516– <dig>  a contaminated version of each family was constructed by adding a randomly chosen sequence from a different family to each family. the first sequence of each set is the impostor.

click here for file

 additional file 5
click here for file

 additional file 6
click here for file

 additional file 7
click here for file

 additional file 8
click here for file

 acknowledgements
we want to thank the anonymous referees for their very valuable remarks and suggestions. we thank inna myslyuk for graphical assistance. sm and ru acknowledge support from the israeli ministry of science under grant 3/ <dig> 
