BACKGROUND
while phylogenetic studies in the pre-genome era primarily focused on dna or protein sequence differences among organisms, informative comparisons can in fact be made at various organizational levels. higher-level evolutionary events of relevance to phylogenetics include inversion, transposition, deletion, insertion and duplication. phylogenetic analyses of whole genomes that model these types of events are proving to be extremely useful in elucidating the evolutionary relationships among organisms  <cit> . since the pioneering papers of sankoff  <cit> , genome rearrangement data has attracted increasing attention from both biologists and computer scientists as a new type of data for phylogenetic analysis and comparative genomics.

during the past several years, computer scientists have been able to make substantial progress in genome rearrangement research. with solutions for inversion distance  <cit>  and inversion median  <cit> , we were able to estimate phylogenies and ancestral genomes based on inversions. the main software packages for reconstructing the inversion  phylogeny are grappa  <cit>  and mgr  <cit> . their basic optimization tool is an algorithm for computing the inversion  median of three genomes.

much of the research on genome rearrangement has focused on organellar genomes, such as mitochondrial  <cit>  and chloroplast genomes  <cit> . grappa and mgr have been applied successfully to chloroplast genomes in which inversion is the most important event. in other datasets , transpositions are viewed as more likely, although their relative preponderance with respect to inversions is unknown.

existing methods can still be applied when transposition is the dominant event. for example, given genome  <dig>   <dig> ⋯, n, a transposition acts on three indices i, j, k  resulting in a genome:  <dig> ⋯, , ,⋯, k, i, ,⋯, j, ,⋯, n, which can also be obtained by using three inversions: one inversion acts on indices i, k, followed by one acts on indices i, k - j + i -  <dig> and another one acts on k - j + i, k. based on the above observation, it is possible to estimate the transposition distance by inversions and use distance-based method  to reconstruct the phylogeny. we can also apply grappa or mgr to obtain the phylogeny, using either breakpoint median solver or inversion median solver. however, since the evolutionary model is mismatched, their performance on transposition datasets is questionable, as indicated by our experimental results shown in the next section. in this paper, we introduce a new method to solve the transposition median problem and use it to infer phylogenies and ancestral genomes from datasets where transposition is the only event. the new method  is an extension of grappa and is available free from .

genome rearrangements
we represent a genome as a signed ordering of n genes, and each gene i is given an orientation that is either positive, written i, or negative, written -i. genomes can evolve through events such as inversions, transpositions and transversions, as well as other events. when transposition is the only event, the sign of each gene is irrelevant and can be ignored. let g be the genome with signed ordering of  <dig>   <dig> ⋯, n. an inversion  between indices i and j , transforms g to a new genome with linear ordering

  <dig>   <dig> ⋯, , -j, -,⋯, -i, ,⋯, n 

a transposition on genome g acts on three indices i, j, k, with i ≤ j and k ∉ , picking up the interval i, ,⋯, j and inserting it immediately after k. thus genome g is replaced by :

  <dig> ⋯, , ,⋯, k, i, ,⋯, j, ,⋯, n 

an transversion is a transposition followed by an inversion of the transposed subsequence; it is also called an inverted transposition.

there are additional events for multiple-chromosome genomes, such as translocation , fission  and fusion .

distance computation
given two genomes g <dig> and g <dig>  we define the edit distance d as the minimum number of events required to transform one genome into the other.

the breakpoint distance  <cit>  is not a direct evolutionary distance measurement. a breakpoint in g <dig> is defined as an ordered pair of genes  such that i and j are adjacent in g <dig> but not in g <dig>  the breakpoint distance is simply the number of breakpoints in g <dig> relative to g <dig> 

when only inversions are allowed, the edit distance is the inversion distance. hannenhalli and pevzner  <cit>  developed a mathematical and computational framework for signed gene-orders and provided a polynomial-time algorithm to compute the edit distance between two signed gene-orders under inversions; bader et al.  <cit>  later showed that this edit distance can be computed in linear time. however, computing the inversion distance is np-hard in the unsigned case  <cit> .

the transposition distance is the minimum number of transpositions needed. computing the transposition distance is of unknown complexity and after  <dig> years of research, the best available method is only a  <dig> -approximation  <cit> .

yancopoulos et al.  <cit>  proposed a "universal" double-cut-and-join  operation that accounts for inversions, translocations, fissions and fusions, resulting in a new genomic distance that can be computed in linear time. a dcj operation makes a pair of cuts and proceeds to reglue cut ends, which can yield an inversion, a fission, a fusion, and a translocation. combining two dcj operations can create a block interchange and sometime a transposition. although there is no direct biological evidence for dcj operations, these operations are very attractive because it provides a unifying model for genome rearrangement  <cit>  and it is simple to compute the dcj distance.

median problem of three
the median problem on three genomes is to find a single genome that minimizes the sum of pairwise distances between itself and each of the three given genomes. this problem is computationally very hard even for the simplest breakpoint distance  <cit> .

the breakpoint median problem can be transformed into a special instance of the well-studied traveling salesperson problem  <cit> , hence can be solved relatively efficient. the inversion median problem is to find a median genome that minimizes the summation of inversion distances on the three edges. two exact median solvers have been proposed, all using a branch-and-bound strategy. caprara's solver  <cit>  is based on an extension of the breakpoint graph, while the one developed by siepel and moret  <cit>  runs a direct search. using the inversion median has dramatically improved the accuracy of genome rearrangement analysis  <cit> . two heuristic methods, mgr  <cit>  and revoluzer  <cit> , are also proposed to improve the speed of inversion median, at a sacrifice of accuracy. zhang et al. later improved caprara's inversion median solver so that it can handle the dcj distance  <cit> .

phylogenetic reconstruction from genome rearrangements
reconstructing phylogenies from genome rearrangement data is computationally much harder than from sequence data. for example, finding the minimum number of evolutionary events given a fixed tree can be done in linear time if the leaves are labeled with dna or protein sequences, whereas such task for genome rearrangement data is np hard even when the tree has only three leaves.

methods for reconstructing trees based on genome rearrangement data include distance-based methods , maximum parsimony methods based on encodings  <cit> , and direct optimization methods. the latter, pioneered by sankoff and blanchette  <cit>  in their package bpanalysis and improved by grappa  <cit>  and mgr, is the most accurate method. besides returning a phylogeny, these three methods can also give an estimate of ancestral gene orders, which will have great utility for biologists interested in the process of genome rearrangement.

RESULTS
we examine the performance of the new grappa-tp through two simulation studies: the first study is to measure the accuracy of the inferred median genome  compared to the true ancestor, using datasets of three input genomes; the second is to measure the accuracy of the inferred phylogeny compared to the true tree, using datasets of  <dig> genomes. all the experiments are conducted on a linux cluster with  <dig> intel xeon cpus, but each cpu works independently on a test task.

accuracy of ancestor inference for three genomes
we first examine the quality of grappa-tp in inferring ancestor genomes. in our simulation study, each genome has  <dig> or  <dig> genes, spanning the range from mitochondria to chloroplast.

we create each dataset by first generating a tree with three leaves and assigning its three edges with different lengths. the length  of each edge is sampled from a uniform distribution on the set { <dig> r,...,  <dig> r}, where r is the expected number of evolutionary events . in this experiment, we use r =  <dig> ~ <dig>  where r =  <dig> is considered easy and r =  <dig> is very difficult especially for datasets with  <dig> genes. the gene orders on the leaves are generated by first assigning the identity permutation  <dig>   <dig> ⋯, n  to the root, then evolving the permutation down the tree, applying along each edge a number of transpositions equal to the assigned edge length.

given an estimated ancestor gene order gm, we can use the breakpoint distance between gm and g <dig> as a measurement of how close the inferred ancestor is to the true ancestor. for each dataset, we obtain the estimated ancestors by using the following five methods: grappa-tp , dcj median solver , mgr, breakpoint median solver  and inversion median solver . we repeat  <dig> times for each setting and the averages of the results are reported.

as indicated in the later section, grappa-tp uses a simple distance estimator to conduct a randomized search, and we may need to repeat several times to obtain the smallest distance, hence the number of repeats may have impact on its performance. to assess the impact, we compare grappa-tp using two numbers of repeats:  <dig> and  <dig>  and report the results in figure  <dig>  surprisingly this figure shows that the impact of number of repeats is very small, even when the genomes are getting distant .

accuracy of phylogeny inference
we also test the performance of grappa-tp on phylogeny analysis. we first define our measure for the accuracy of reconstructed trees. given an inferred tree, we compare its topological accuracy by computing false negatives and false positives with respect to the true tree. for every tree there is a natural association between every edge and the bipartition on the leaf set induced by deleting the edge from the tree. let t be the true tree and let t' be the inferred tree. an edge e in t is "missing" in t' if t' does not contain an edge defining the same bipartition; such an edge is called a false negative . the false negative rate is the number of false negative edges in t' with respect to t divided by the number of internal edges in t. external edges  are not counted because these edges are trivial to recover and must present in every tree with the same set of leaves. the false positive  rate is defined similarly, by swapping t and t'. the robinson-foulds  rate is thus defined as the average of the fn and fp rates. in this study, we generate uniformly random tree by randomly picking a tree from all possible trees – there are  ×  × ⋯ ×  <dig> trees for n taxa. we use trees with n =  <dig> and  <dig> genes, which is the number of genes in mitochondrial genomes. we choose r =  <dig>   <dig> and  <dig> to vary the level of difficulty, where r =  <dig> is considered very hard for these datasets. for each combination of parameters, we generate  <dig> datasets and report the average results.

in our experiments, each dataset is tested using seven methods: grappa-tp , grappa using inversion median , grappa using breakpoint median , mgr, nj using transposition distances , nj using inversion distances  and nj using breakpoint distances . we cannot test our dcj median here because the scoring procedure of grappa-dcj generates some median problem instances that are too difficult for it to run. figure  <dig> shows the results; we place a line at the 5% error level, the typical threshold of acceptability for accuracy in phylogenetic reconstruction  <cit> .

we make the following two observations.

first, nj has remarkably good performance when the genomes are close , but its accuracy quickly drops when the genomes are getting distant, especially when it uses inversion and breakpoint distances. since nj is guaranteed to be accurate when the distance between any pair of genomes is very close to the true distance, the good result of tp-nj also suggests that our distance estimator is valid when the genomes are close.

second, grappa-tp always returns highly accurate trees, although its performance is slightly worse than tp-nj for r =  <dig>  the accuracy of grappa-tp is also very stable and does not suffer when the genomes are relatively distant. using breakpoint and inversion median solvers  again give very bad results, even for easy datasets of r =  <dig>  the results clearly show the importance of model match in genome rearrangement analysis. one should also note that unlike the results in median accuracy, using breakpoint medians in phylogenetic analysis has better performance than using inversion medians. more research in the future is needed to determine the factors contribute to this discrepancy.

although the number of genomes is relatively small in this test, the high accuracy of grappa-tp makes it ideal as a base method for the dcm-grappa developed by tang et al.  <cit> , hence can be easily extended to handle several hundred genomes.

CONCLUSIONS
in this paper, we present our new method to handle transpositions and report experimental results on simulated datasets. although grappa-tp uses a brute-force distance estimator, it remains very accurate for transposition phylogeny. our studies suggest that model match is very important in both ancestor inference and phylogenetic reconstruction. the main problem of grappa-tp is of course the accuracy and running time of its distance estimator, and a fast and exact method to compute transposition distance is always desirable.

