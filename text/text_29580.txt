BACKGROUND
the ab initio protein folding problem concerns the prediction of the three dimensional functional state, i.e., the native fold, of a protein given only its sequence information. a successful method for solving this problem would have far reaching implications in many fields including structural biology, genetics and medicine. current laboratory techniques for protein structure determination are both costly and time consuming. in the current era of high throughput sequencing, it is infeasible to rely exclusively on time and labor-intensive experimental structure determination techniques, such as x-ray crystallography and nuclear magnetic resonance, for characterizing the protein products of newly discovered genes; there is a clear need for effective and efficient computational protein structure prediction programs. however, even for simplified protein models that use lattices to discretize the conformational space, the ab initio protein structure prediction problem has been shown to be np
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaat0uy0hwztfgdpnwy1egaryqthrhal1wy0l2yhvdaiqaacqwfnevtcqqgqbauaaa@3961@-hard  <cit> , and a polynomial-time algorithm is therefore unlikely to exist.

one of the most prevalently studied abstractions of the ab initio protein structure prediction problem is dill's hydrophobic polar  model. many algorithms have been formulated to address the protein folding problem using two dimensional  and three dimensional  hp models on a variety of lattices . in this study, we restrict our attention to those hp models that embed all protein folds into the 2d square lattice or the 3d cubic lattice. many of these algorithms can be classified primarily as construction based  algorithms, which determine folds by sequentially placing residues onto the lattice. among these, the pruned enriched rosenbluth method   <cit>  has been particularly successful in finding optimal conformations for standard benchmark sequences in both 2d and 3d. perm is a monte carlo based chain growth algorithm that iteratively constructs partial conformations; it is heavily based on mechanisms for pruning unfavourable folds and for enriching promising partial conformations, to facilitate their further exploration.

despite being one of the most successful algorithms for ab initio protein structure prediction in the 2d and 3d hp models, perm – like all other currently known algorithms for this problem – is not dominant in every instance. in the work of shmygelska and hoos  <cit>  it was shown that perm has great difficulty folding proteins which have a hydrophobic core located in the middle and not at one of the ends of the sequence, as is the case when the core is formed from interacting termini. we note that an earlier version of perm  <cit> , capable of initiating search at non-terminus positions, was previously proposed and may be more effective in folding these types of sequences. however, to the best of our knowledge, no comparison has been made with the most recent version of perm or other protein folding algorithms.

shmygelska and hoos proposed an ant colony optimization algorithm, aco-hppfp- <dig>  which employs both construction and local search phases on complete conformations  <cit> . ant colony optimisation  is a population-based stochastic search method for solving a wide range of combinatorial optimisation problems. aco is based on the concept of stigmergy – indirect communication between members of a population through interaction with the environment. from the computational point of view, aco is an iterative construction search method in which a population of simple agents  repeatedly constructs candidate solutions to a given problem instance; this construction process is probabilistically guided by heuristic information on the problem instance as well as by a shared memory containing experience gathered by the ants in previous iterations of the search process   <cit> . the aco-hppfp- <dig> algorithm combines a relatively straight-forward application of the general aco method to the 2d and 3d hp protein structure prediction problem with specific local search procedures that are used to optimize the conformations constructed by the ants.

in the 2d case, aco-hppfp- <dig> was shown to be competitive with perm on many benchmark instances and dominant on proteins whose hydrophobic core is located in the middle of the sequence. other attempts at the problem use local search methods on complete conformations, including the gtabu algorithm  <cit> . this method utilizes the generic tabu search algorithm from the human guided search  framework  <cit> . gtabu was shown to find conformations with the lowest known energy for several benchmark instances in the 2d case. this was primarily made possible by using a newly introduced neighbourhood consisting of so-called pull moves, which is also utilized in our work.

in addition to perm, many other monte carlo algorithms have been devised to address the problem of ab initio protein structure prediction using lattice models  <cit> . a class of monte carlo methods known as generalized ensemble algorithms have been shown to be particularly effective for more complex lattices and for the off-lattice case  <cit> . classical monte carlo search methods for protein structure prediction typically sample conformations according to the boltzmann distribution in energy space. in generalized ensemble algorithms, random walks in other dimensions, such as temperature, can also be realized. this is the case for replica exchange monte carlo  algorithms, which maintain many independent replicas of potential solutions, i.e., protein conformations. each replica is set at a different temperature and locally runs a markov process sampling from the boltzmann distribution in energy space. a random walk in temperature space is achieved by periodic exchanges of conformations at neighbouring temperatures. remc appears to have been discovered independently by various researchers  <cit>  and is also known as parallel tempering, multiple markov chain monte carlo and exchange monte carlo search. remc has been shown to be highly effective in high dimensional search problems with rugged landscapes containing many local minima. initially this was demonstrated in an application to spin glass systems  <cit> . remc has also been applied to the off-lattice protein folding problem  <cit> . furthermore, it was previously used for folding proteins on the 2d square lattice in a study by irbäck  <cit>  and to the face-centred cubic lattice in the work of gront et al  <cit> . however, to the best of our knowledge, no extensive study of the remc algorithm in the hp model on the cubic lattice has been undertaken. the remainder of this paper is structured as follows. first, we formally introduce the hydrophobic polar model and describe in detail the two search neighbourhoods  utilized later in this work. next, we present the general remc method followed by the three instantiations we have developed for the 2d and 3d hp protein folding problem. then, we report results from a comparative empirical performance analysis of our new algorithms vs perm and aco-hppfp- <dig>  the respective computational experiments are run on standard benchmark instances as well as on two new sequence sets, which we introduced to evaluate the performance of remc when folding long sequences and sequences which have a provably unique optimal structure. we also report results from experiments involving proteins with termini interacting to form a hydrophobic core. next, we compare the performance of our new remc algorithms with that of gtabu. a discussion follows, in which we report empirical results regarding the effects of various parameters on the performance of our new algorithms. we close with a high-level summary of our major findings and a brief discussion of potential future work.

the hydrophobic polar model
the hydrophobic polar  model was first introduced by dill in  <dig>  <cit> . in this model, amino acids are classified as either h  or p . informally, a sequence of h's and p's is embedded into a lattice structure. a valid conformation of the sequence corresponds to a self-avoiding walk on the lattice. borrowing the terminology used by lau and dill  <cit> , we define connected neighbours as any two residues k and k +  <dig> that are adjacent along the given sequence, and topological neighbours as residues adjacent in topological space  that are not also connected neighbours. the energy of a conformation can be calculated as the number of h-h contacts between topological neighbours. this is illustrated in figure  <dig>  which shows a conformation with energy - <dig> .

formally, for a sequence s ∈ Σn with Σ = {h, p} and n = |s|, we define a conformation ci ∈ cs to have energy e, where cs is the set of all valid self-avoiding walks on some lattice l for sequence s, and e is given by the following equation:

 e=∑j=1n−1∑k=j+1nnjk, withnjk={−1if j and k are both h residuesand topological neighbours;0otherwise.
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaafaqadegabaaabagaemyraukaeiikagiaem4yam2aasbaasqaaiabdmgapbqabagccqggpaqkcqgh9aqpdaaewbqaamaaqahabagaemota40aasbaasqaaiabdqgaqjabdugarbqabagccqggsaalcqqggaaicqqg3bwdcqqgpbqacqqg0badcqqgobaaasqaaiabdugarjabg2da9iabdqgaqjabgucariabigdaxaqaaiabd6gaubqdcqghris5aawcbagaemoaaomaeyypa0jaegymaedabagaemoba4maeyoei0iaegymaedaniabgghildaakeaacqwgobgtdawgaawcbagaemoaaomaem4aasgabeaakiabg2da9maaceqabaqbaeaabmgaaaqaaiabgkhitiabigdaxaqaaiabbmgapjabbagamjabbccagiabdqgaqjabbccagiabbggahjabb6gaujabbsgakjabbccagiabdugarjabbccagiabbggahjabbkhayjabbwgaljabbccagiabbkgaijabb+gavjabbsha0jabbigaojabbccagiabbieaijabbccagiabbkhayjabbwgaljabbohazjabbmgapjabbsgakjabbwha1jabbwgaljabbohazbqaaaqaaiabbggahjabb6gaujabbsgakjabbccagiabbsha0jabb+gavjabbchawjabb+gavjabbygasjabb+gavjabbeganjabbmgapjabbogajjabbggahjabbygasjabbccagiabb6gaujabbwgaljabbmgapjabbeganjabbigaojabbkgaijabb+gavjabbwha1jabbkhayjabbohazjabcuda7aqaaiabicdawaqaaiabb+gavjabbsha0jabbigaojabbwgaljabbkhayjabbeha3jabbmgapjabbohazjabbwgaljabc6cauaaaaiaawuhaaaaaaaa@aee6@ 

in this model, we search for a conformation c* that minimizes the objective energy function e. such a conformation is considered a solution and is also called a ground-state conformation of the given protein sequence. however, many instances of the hp protein folding problem exhibit solution degeneracy, i.e., have more than one minimum-energy conformation. in this sense, our definition of ground-state conformation does not imply a unique solution, but simply one that satisfies the following equation:

 e = min{e | ci ∈ cs} 

although ground-state structures in this model typically do not closely resemble the known native conformations of the respective proteins, a close correspondence has been observed in some cases  <cit> ; this is particularly true for higher resolution lattices such as the face-centred cubic lattice.

generally, simplified models, such as the ones considered here, are widely considered to be useful in studying certain aspects of protein folding and structure prediction, including the formation of conformations exhibiting a hydrophobic core  <cit> .

search neighbourhoods
local search methods  are based on the idea of iteratively improving a given candidate solution by exploring its local neighbourhood. in the protein folding problem as it is presented here, the neighbourhood of a conformation can be thought to consist of slight perturbations of the respective structure. the neighbourhoods  used in solving this problem specify a perturbation as a feasible change from a current conformation c at time t to a valid conformation at time t +  <dig>  thus, the neighbourhood of a conformation c is a set of valid conformations c' that are obtained by applying a specific set of perturbations to c. in this study we consider two such neighbourhoods, the so-called vshd moves and pull move neighbourhoods, for both, the 2d and 3d hp models.

vshd moves
vshd moves, as we will refer to them in this study, appeared early on in the simulation of polymer chains by verdier and stockmayer  <cit> . in this early work, only single residue moves were used, and the single residue end and corner moves were introduced. that work was later critiqued in a study by hilhorst and deutch  <cit> , which also introduced the two residue crankshaft move. gurler et al. combined all three types of moves into one search neighbourhood  <cit> , which we call the vshd neighbourhood.

end moves
for a chain of length n, an end move can be performed on residue  <dig> or residue n. the residue is pivoted relative to its connected neighbour to a free position adjacent to that neighbour. this mechanism ensures that the chain remains connected. if more than one valid position is free, one is chosen uniformly at random. for instance, in figure 2a, residue  <dig> could be moved to two possible positions on the lattice. generally, for the 2d and 3d hp model, there are up to  <dig> and  <dig> possible moves for each of the two end residues, respectively.

corner moves
a corner move can potentially be performed on any residue excluding the end residues. for a corner move to be possible, the two connected neighbours of some residue i must be mutually adjacent to another, unoccupied position on the lattice. note that for both, the 2d square and the 3d cubic lattices, any two residues i -  <dig> and i +  <dig> can share at most one adjacent lattice position. when this situation occurs, a corner is formed by residues i -  <dig>  i and i +  <dig>  if the mutually adjacent position is empty, residue i can be moved to it. this is illustrated in figure 2b for the 2d case. overall, in 2d as well as in 3d, there are at most n -  <dig> possible corner moves for any conformation of a n-residue chain.

crankshaft moves
a crankshaft move can occur if some residue i is part of a u-shaped bend in the chain, as shown in figure 2c. referring to this figure, the crankshaft move can be performed in 2d if positions i' and i + 1' are empty. crankshaft moves in 2d always involve a 180° rotation of a u-shaped structure consisting of four connected neighbours on the chain. the 3d case is handled analogously, except that the motif is rotated by either 90° or -90°, provided the appropriate positions are empty. . note that in the figure, the same crankshaft move can be initiated from residue i and i +  <dig> 

pull moves
pull moves have been introduced relatively recently by lesh et al.  <cit> , who used them in the context of a generic tabu search algorithm for the 2d hp protein folding problem. in the following, we will briefly introduce the central idea behind this type of move. for a formal treatment of the pull move neighbourhood and the proof of its completeness , the reader is directed to the original paper by lesh et al.  <cit> .

suppose at time t for some residue i there is an empty lattice position labeled l which is adjacent to residue i +  <dig> and diagonally adjacent to i. further consider a position mutually adjacent to l and i, labeled c. using this labeling, a square is formed by residues i, i +  <dig>  l and c, as illustrated in figure 3a. a pull move can only proceed if c is either empty or occupied by residue i -  <dig> 

the simplest case occurs when c is occupied by residue i -  <dig>  in which case the entire move consists of moving residue i to location l. note that this move, which is illustrated in figure 3a, is equivalent to the previously introduced corner move. when c is not occupied by residue i -  <dig>  i is moved to l and i -  <dig> is moved to c. if residue i -  <dig> is adjacent to position c, this second operation completes the pull move. this case is illustrated in figure 3b.

if, however, residue i -  <dig> is adjacent to position c, the chain is still not in a valid conformation at this point, and in this case, the following procedure is used. using the notation by lesh et al.  <cit> , starting with residue j = i -  <dig>  let , yj) = , yj+2) until a valid conformation has been found or residue  <dig> has been moved. informally speaking, residues are successively pulled into positions that have just been vacated  until a valid conformation has been obtained or one end of the chain is reached. figure 3c illustrates this situation where residues i to i -  <dig> were pulled successively, until the valid conformation shown on the right was obtained. note that pull moves have been described as pulling from residue i down to residue  <dig>  if needed. pulling in the opposite direction is equivalent and also valid.

when they introduced pull moves, lesh et al. claimed that the resulting neighbourhood could be generalized to the 3d case. however, to the best of our knowledge no algorithm implementing pull moves for the 3d case has been published. for the 2d case, valid choices of l and c are restricted to a single plane. the generalization to 3d can consider choices of l and c in any plane containing both i and i + 1; in the case of the 3d cubic lattice, there are two such planes. in our study presented here, we have implemented this generalization of pull moves in the context of a standard remc algorithm, which will be described in the following.

replica exchange monte carlo search
in the following, we provide a brief introduction to replica exchange monte carlo search. for an in-depth description of the algorithm including its historical aspects, the reader is referred to the review of extended ensemble monte carlo algorithms by iba  <cit> , which also provides details related to simulated tempering  <cit>  and replica monte carlo search  <cit> .

replica exchange monte carlo  search maintains χ independent replicas of a potential solution. each of the χ replicas has an associated temperature value . each temperature value is unique and the replicas are numbered such that t <dig> <t <dig> < ... <tχ. in our description of the algorithm, we will label the χ conformations maintained by the algorithm at any given time with the replica numbers  and always associate temperature tj with replica j . thus, the exchange of replicas is equivalent to  the swap of replica labels.

each of the χ replicas independently performs a simple monte carlo search at the respective temperature setting. the transition probability from some current conformation c to an alternative conformation c' is determined using the so-called metropolis criterion such that

 pr:={1if Δe≤ <dig> e−Δetotherwise.
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaaiegacqwfqbaucqwfybgccqggbbwwcqwgjbwycqghsgircuwgjbwygaqbaiabc2fadjabcqda6iabg2da9maaceqabaqbaeqabigaaaqaaiabigdaxaqaaiabbmgapjabbagamjabbccagiabfs5aejabdweafjabgsmijkabicdawiabcycasaqaaiabdwgalnaacaaaleqabawaasaaaeaacqghsislcqqhuoarcqwgfbqraeaacqwgubavaaaaaagcbagaee4ba8maeeidaqnaeeiaagmaeeyzaumaeeocainaee4dacnaeeyaakmaee4camnaeeyzaumaeiola4caaagaay5eaaaaaa@5770@ 

where Δe : = e - e is the difference in energy between conformations c' and c, and t denotes the temperature of the replica.

we can represent the current state of the extended ensemble of all χ replicas as a vector c : =  shown below, where cj is the conformation of replica j, which  runs at temperature tj. during replica exchange, temperature values of neighbouring replicas are swapped with a probability proportional to their energy and temperature differences. an exchange of temperatures, and therefore a relabeling of replicas, affects the state of the extended ensemble c. therefore, we define an exchange between two replicas i and j more generally as a transition of the current ensemble state c to an altered state c'. we define l = i, the current label or replica number, for all ci. the probability of a transition from ensemble state c to state c' by exchanging replicas i and j is defined as:

 pr:=pr:={1Δ≤0e−Δotherwise.
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaafaqabegadaaabaacbigae8huaalae8ncainaei4wasfcbmgae43yammaeyokh4qaf43yammbauaacqggdbqxaeaacqgg6agocqgh9aqpaeaacqwfqbaucqwfybgccqggbbwwcqwgsbabcqggoaakcqwgjbwydawgaawcbagaemyaakgabeaakiabcmcapiabgszirkabdygasjabcicaoiabdogajnaabaaaleaacqwgqbgaaeqaaogaeiykakiaeiyxa0fabaaabagaeiooaojaeyypa0dabawaaiqabeaafaqaaegacaaabagaegymaedabagaeuildqkaeyizimqaegimaadabagaemyzau2aawbaasqabeaacqghsislcqqhuoaraaaakeaacqqgvbwbcqqg0badcqqgobaacqqglbqzcqqgybgccqqg3bwdcqqgpbqacqqgzbwccqqglbqzcqgguaglaaaacagl7baaaaaaaa@64ae@ 

the value Δ is the product of the energy difference and inverse temperature difference:

 Δ : =  - e). 

where βi=1ti
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaaiigacqwfyogydawgaawcbagaemyaakgabeaakiabg2da9maalaaabagaegymaedabagaemivaq1aasbaasqaaiabdmgapbqabaaaaaaa@34a3@ is the inverse of the temperature of replica i.

potential replica exchanges are only performed between neighbouring temperatures, since the acceptance probability of the exchange drops exponentially as the temperature difference between replicas increases.

our remc algorithms
details of our implementation of remc search are presented in the 'methods' section. we have experimented with three variants of the remc algorithm for both the 2d and 3d case, which differ only in the neighbourhoods used in the subsidiary monte carlo local search procedure. remcvshd folds protein sequences using exclusively the vshd neighbourhood. likewise, remcpm is based on the pull move neighbourhood. our third variant, remcm, makes use of a hybrid neighbourhood that allows both, pull moves and vshd moves to be performed; more precisely, in each local search step, the pull move neighbourhood will be used with probability ρ  and otherwise, the vshd neighbourhood will be used.

RESULTS
to evaluate the performance of our remc algorithms we directly compared results against those for two state-of-the-art folding algorithms, aco-hppfp- <dig> and perm. in the same manner in which the parameters for remc remain fixed for all experiments, the perm and aco-hppfp- <dig> parameters have been fixed to the values suggested by their authors. the parameter values for aco-hppfp- <dig> have been taken from shmygelska and hoos  <cit> , and those for perm were optimized by p. grassberger and his group and pre-configued in the code kindly provided to us. for all runs of perm, the parameter settings β : =  <dig> and q : =  <dig>  were used  <cit> .

in our experiments we conducted a number of runs with a given energy or cpu time cut-off on a standard set of benchmark instances for both the 2d and 3d hp protein folding problems. furthermore, several new benchmark sets were created to evaluate the performance of remc on long, biologically inspired sequences as well as on sequences with provably unique optimal conformations. a direct comparison between aco-hppfp- <dig> and perm has been previously reported by shmygelska and hoos  <cit> . in this earlier work it has been shown through experiments on artificially designed as well as on known biological sequences that perm has inherit difficulties with folding proteins where the termini interact in the formation of the hydrophobic core. here, we performed analogous experiments to determine the performance differences between aco-hppfp- <dig>  perm and our remc algorithms for these cases. we further tested our 2d algorithms using the pull move neighbourhood, remcm and remcpm, against the first algorithm based on this neighbourhood, gtabu, by means of a computational experiment analogous to that performed by lesh et al.  <cit> .

results for standard benchmark sequences
there are eleven benchmark sequences for the 2d hp model and ten for the 3d hp model. this benchmark set, in whole or in part, has been used extensively in the literature  <cit> . a complete listing of the 2d and 3d sequences can be found in table  <dig>  to evaluate performance differences between aco-hppfp- <dig>  perm and our remc algorithms, we follow the experimental protocol established by shmygelska and hoos  <cit> .

2d and 3d standard benchmark collection which can be found in  <cit> . these sequences can be found originally amongst  <cit> . as presented in  <cit> , hi and pi indicate a string of i consecutive h's and p's; likewise i indicated an i-fold repetition of string s.

every run was performed independently with a unique random seed. in the 2d case, for sequences of length n ≤  <dig>   <dig> independent runs were performed; for  <dig> <n ≤  <dig>   <dig> runs; and for n >  <dig>   <dig> runs. in the case of 3d,  <dig> independent runs were performed for each sequence. results for aco-hppfp- <dig> and perm were taken from the study of shmygelska and hoos  <cit> , which used the same experimental environment and protocol. expected run-times for perm are computed as texp=2⋅−1
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaacqwg0baddawgaawcbagaemyzaumaemieagnaemicaahabeaakiabg2da9iabikdayiabgwsixpaabmaabawaasaaaeaacqaixaqmaeaacqwg0baddawgaawcbagaegymaedabeaaaagccqghrawkdawcaaqaaiabigdaxaqaaiabdsha0naabaaaleaacqaiyagmaeqaaaaaaogaayjkaiaawmcaamaacaaaleqabagaeyoei0iaegymaedaaaaa@426f@, where t <dig> and t <dig> are the average run-times when folding from the n-terminus and c-terminus of the given protein sequence, respectively; as noted by shmygelska and hoos, the performance of perm often varies substantially between folding directions  <cit> .

results for the 2d case are listed in table  <dig>  all algorithms show similar running times for the first three benchmark sequences . for sequences s1- <dig> to s1- <dig>  remcvshd exhibited the worst performance; however, the other two variants of remc, both utilizing pull moves, perform better than aco-hppfp- <dig> for all instances. perm shows better performance than remcm and remcpm for sequence s1- <dig>  on average, it also solves s1- <dig> faster than remcpm. in every other case, however, remcpm and remcm outperform perm, often by a significant factor. of particular note is the fact that the variants using pull moves solve sequence s1- <dig> in a matter of cpu seconds compared to  <dig> cpu hours required on average by perm . sequence s1- <dig> has a symmetric core formed by extensive interactions between the two termini; the difficulty of sequences with interacting termini for perm has been previously demonstrated by shmygelska and hoos  <cit> . the second-hardest instance for perm, s1- <dig>  is solved on average  <dig>  times faster by remcm and nearly  <dig> times faster by remcpm. the other benchmark sequence with  <dig> residues, s1- <dig>  is solved approximately  <dig> times faster by both pull move variants. overall, on the eleven benchmark instances the performance of perm is matched or exceeded in  <dig> and  <dig> cases by remcpm and remcm, respectively.

details on runs can be found in the text. results for perm and aco-hppfp- <dig> are reproduced from  <cit> . in all instances, remcvshd reports the worst running times followed by aco-hppfp- <dig>  remcm outperforms perm in  <dig> of  <dig> instances and remcpm reports better times than perm in  <dig> of  <dig> instances. details of the experimental protocol can be found in the text.

in the 3d case , the general performance trend is similar. all remc variants report superior running times to aco-hppfp- <dig> in every case, as does perm. furthermore, perm outperforms remcvshd in each case, often by a significant factor. however, the generalization of pull moves to the 3d case has lead to a substantial increase in the performance of remc. for only one sequence, s2- <dig>  does perm outperform remcpm and remcm . remc using pull moves shows significantly better performance than perm on s2- <dig>  s2- <dig> and s2- <dig>  where a five- to twenty-fold increase in performance is observed. for the other instances, remcpm and remcm match or outperform perm by a small margin.

details on runs can be found in the text. results for perm and aco-hppfp- <dig> have been reproduced from  <cit> . all variants of remc outperform aco-hppfp- <dig>  remcm and remcpm match or outperform perm in  <dig> of  <dig> instances. details of the experimental protocol can be found in the text.

remcpm and remcm also outperform other algorithms found in the literature. shmygelska and hoos compared perm and aco-hppfp- <dig> against other methods with previously published results on the standard benchmark sets  <cit> . for the 2d square lattice, this comparison included the genetic algorithm of unger and moult  <cit> , the evolutionary monte carlo algorithm of liang and wong  <cit> , and the multi-self-overlap ensemble algorithm of chikenji et al.  <cit> . furthermore, a previous application of replica exchange monte carlo search  on the 2d square lattice  <cit>  has failed to reach ground-state configurations for the two largest standard benchmark sequences   <cit> . for the 3d cubic lattice, the hydrophobic zipper algorithm  <cit> , the constraint-based hydrophobic core construction method  <cit> , the core-directed chain growth algorithm  <cit>  and the contact interactions algorithm  <cit>  were considered. considering these previously published results in combination with the results reported here, remcpm and remcm both perform better than any of the earlier methods mentioned above in terms of the energy of the conformations found or the cpu time required for reaching a given energy level .

due to their superior performance, only the remcpm and remcm algorithms were considered in the remainder of our study.

characteristic performance of remc
prompted by the results on sequence s1- <dig>  we decided to further investigate to which extent remc using pull moves can fold proteins with interacting termini in their cores substantially more effectively than perm. to that end, we used three additional sequences that had been shown to be difficult for perm by shmygelska and hoos  <cit> ; these sequences are listed in supplemental table  <dig> . these sequences and the corresponding mean run-times for each algorithm  are reported in table  <dig>  for all four instances, both remc variants outperform aco-hppfp- <dig> by factors ranging from  <dig> to  <dig>  in the case of b50- <dig>  remcpm and remcm easily outperform perm  when the latter is folding from both directions or from the c-terminus; however, when folding from the n-terminus, perm slightly outperforms remcpm .

results for perm and aco-hppfp- <dig> are reproduced from  <cit> . in all instances, remc finds optimal conformations relatively easily compared with the other algorithms. remc does not demonstrate an inherit difficulty folding sequences when conformations involve hydrophobic cores confined to one end of the sequence or the case involving both ends. for every instance,  <dig> independent runs were conducted of  <dig> cpu hour each. in cases where not every run reached the same energy value after  <dig> hour, the expected run-time to reach the energy value shown in the table was calculated using the equation detailed by parkes and walser  <cit> .

for b50- <dig>  remc beats all variants of perm by more than two orders of magnitude. as b50- <dig> involves significant interaction between both termini, the folding direction of perm appears to be inconsequential. this is not the case for d- <dig>  when folding from the c-terminus, perm has no difficulty folding the sequence within  <dig> cpu second, as a significant part of the c-terminus forms the hydrophobic core of this protein. this performance is matched by both remc algorithms. however, when folding from the n-terminus, perm requires a mean run-time of over one cpu hour. the d- <dig> sequence is highly symmetric in its core formation. perm reports the worst run-times of all algorithms in this instance with a mean run-time of over  <dig>  cpu hours in the best case. this is more than  <dig> times worse than either of the remc algorithms. overall, these results clearly indicate that, compared to perm, remc is much more effective in finding low-energy structures whose termini interact to form hydrophobic cores.

it has also been previously demonstrated that aco-hppfp- <dig> provides a larger range of relative h-h contact order values than perm when analyzing the ensemble of folds obtained from multiple independent runs on the same sequence  <cit> , where the ensemble contains the first optimal conformation encountered in each of the independent runs. the relative h-h contact order measures the average separation of hydrophobic-hydrophobic contacts and is formally defined as

 coh−h:=1l⋅n∑i<j−1|i−j|,
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaacqwgdbwqcqwgpbwtdawgaawcbagaemisagkaeyoei0iaemisageabeaakiabcqda6iabg2da9maalaaabagaegymaedabagaemibawmaeyyxictaemoba4gaamaaqafabawaaqwaaeaacqwgpbqacqghsislcqwgqbgaaiaawea7cagliwoaasqaaiabdmgapjabgyda8iabdqgaqjabgkhitiabigdaxaqab0gaeyyeiuoakiabcycasaaa@49b6@ 

where l is the number h-h contacts, n is the number of hydrophobic residues, and i and j are hydrophobic residues in contact that are not neighbours in the chain. this measure can be employed to compare the quantity and diversity of structures returned by one or more algorithms. since identical conformations have the same relative h-h contact order value, the number of unique structures in a set is bounded from below by the number of unique contact order values. furthermore, a larger range of relative contact order values is indicative of a more diverse set of structures.

in the 3d case, the remc algorithms also find a more diverse set of ground-state structures than aco-hppfp- <dig> and perm. remcm and remcpm return  <dig> and  <dig> unique values, respectively, compared to  <dig> found by aco-hppfp- <dig> and  <dig> by perm. furthermore, remc finds conformation with larger relative contact order values than aco-hppfp- <dig> and perm; the largest values are  <dig>  for remcm,  <dig>  for remcm,  <dig>  for aco-hppfp- <dig> and  <dig>  for perm.

results for longer sequences
to evaluate how remc's performance scales with sequence length, a new, biologically motivated test set was constructed. all sequences were taken from the protein data bank and have length between  <dig> and  <dig> residues at a sequence similarity of less than 10%. sequences were translated into hp strings based on the rasmol hydrophobicity classification scale  <cit> , except for non-standard amino acid symbols, such as x and z, which were skipped . the resulting hp sequences are listed in supplemental table  <dig> . as aco-hppfp- <dig> scaled poorly with sequence length on the benchmark sequences compared with perm and remc, it has been omitted from this evaluation. perm was run in both directions for each instance.

for each sequence, ten independent runs were conducted for each algorithm in both 2d and 3d. runs were terminated after  <dig> cpu minutes on our reference machine, and the best energy was recorded. figure  <dig> shows the best and mean energy values for remcm plotted against the respective performance metrics for perm; the best energy value corresponds to the lowest energy value found amongst all independent runs, while the mean energy value we report is the average of the best energies found in each independent run. in the 2d case , perm finds a better energy value for one sequence and finds the same best energy values for two others. in the remaining seven cases, remcm finds superior conformations. for every sequence, remcm achieves better mean energy values than perm.

in the 3d case , the performance difference is more pronounced. remc finds better conformations on average and in the best case for every sequence. considering the best conformations found among the ten independent runs for each algorithm and for each initial direction in the case of perm, remcm reaches significantly lower energies; the same holds with respect to average energy values. remcpm achieves similar performance in all cases .

results for sequences with unique ground-state conformations
further experiments were conducted on three classes of sequences with unique ground-state conformations in the 2d hp model on the square lattice. in  <dig>  aichholzer et al. identified and proved that a class of sequences uniquely fold into structures dubbed z-structures  <cit> . later, gupta et al. proposed a tile set used to design constructible structures for the inverse protein folding problem. of these constructible structures, the authors proved that the sequences associated with linear structures with no bends  and linear structures with one bend  uniquely fold into the designed conformation  <cit> . examples of these structures are shown in figure  <dig>  we constructed a new test set comprising ten sequences of increasing length for each of these classes of sequences and list them in supplemental table  <dig> . to evaluate the performance of perm and remc on these test sequences, we performed  <dig> independent runs per sequence, each with a cut-off time of  <dig> cpu hour. perm was run in both directions, and in the case where neither direction finds the  lowest energy, the expected run-time is reported for the best energy found.

the mean run-times for the z-structures is reported in table  <dig>  remc finds the unique conformation of each sequence relatively easily with a worst case mean run-time of  <dig> cpu seconds. perm's performance, on the other hand, scales very poorly with sequence length, and the algorithm is unable to find the optimal energy for the four longest sequences.

the z-structures proposed in  <cit>  are easy for remc to fold when compared with perm. after z- <dig>  perm is unable to find the unique optimal conformation in any of the  <dig> independent runs conducted. when only one folding direction of perm finds the optimal conformation, we report the mean run-time of that direction, denoting this in the table with a †. when best energies found by permt1
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaacqqgqbaucqqgfbqrcqqgsbgucqqgnbqtdawgaawcbagaemidaq3aasbaawqaaiabigdaxaqabaaaleqaaaaa@33f5@ and permt2
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaacqqgqbaucqqgfbqrcqqgsbgucqqgnbqtdawgaawcbagaemidaq3aasbaawqaaiabikdayaqabaaaleqaaaaa@33f7@ differed , the best energy by either is reported and the run-time is omitted. for every instance,  <dig> independent runs were conducted of  <dig> cpu hour each. in cases where not every run reached the same energy value after  <dig> hour, the expected run-time to reach the energy value shown in the table was calculated using the equation detailed by parkes and walser  <cit> .

the l <dig> structures turned out to be much more difficult to solve for remc . neither perm nor remc are able to find the optimal conformation for l0- <dig> or l0- <dig>  although remcm finds lower-energy conformations than perm in both cases. perm finds the same sub-optimal solution as remcpm for l0- <dig> in significantly less time. for all other instances, both remc variants dominate perm by finding either lower energy conformations or by requiring less run-time for reaching the same energy values.

the l0-structures proposed in  <cit>  are hard for both remc and perm to fold. after l0- <dig>  perm is unable to find the unique optimal conformation in any of the  <dig> independent runs conducted. remc is unable to find the ground-state conformation for l0- <dig> and l0- <dig>  however, remcm finds better sub-optimal conformations than perm in both instances. when only one folding direction of perm finds the optimal conformation, we report the mean run-time of that direction, denoting this in the table with a †. when best energies found by permt1
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaacqqgqbaucqqgfbqrcqqgsbgucqqgnbqtdawgaawcbagaemidaq3aasbaawqaaiabigdaxaqabaaaleqaaaaa@33f5@ and permt2
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaacqqgqbaucqqgfbqrcqqgsbgucqqgnbqtdawgaawcbagaemidaq3aasbaawqaaiabikdayaqabaaaleqaaaaa@33f7@ differed , the best energy by either is reported and the run-time is omitted. for every instance,  <dig> independent runs were conducted of  <dig> cpu hour each. in cases where not every run reached the same energy value after  <dig> hour, the expected run-time to reach the energy value shown in the table was calculated using the equation detailed by parkes and walser  <cit> .

the l <dig> structures are the hardest for all algorithms considered here . for the three longest sequences, both remc algorithms find the same sub-optimal solutions as perm, but perm reaches these only for one folding direction. for the other instances, remc consistently finds the optimal conformation significantly faster than perm.

the l1-structures proposed in  <cit>  are the most difficult stable structures for remc to fold. both perm and remc are unable to find the optimal conformations for l1-3- <dig>  l1-5- <dig>  and l1-8- <dig> after  <dig>  one hour runs. perm also did not find the optimal conformation for l1-3- <dig>  when only one folding direction of perm finds the optimal conformation, we report the mean run-time of that direction, denoting this in the table with a †. when best energies found by permt1
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaacqqgqbaucqqgfbqrcqqgsbgucqqgnbqtdawgaawcbagaemidaq3aasbaawqaaiabigdaxaqabaaaleqaaaaa@33f5@ and permt2
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaacqqgqbaucqqgfbqrcqqgsbgucqqgnbqtdawgaawcbagaemidaq3aasbaawqaaiabikdayaqabaaaleqaaaaa@33f7@ differed , the best energy by either is reported and the run-time is omitted. for every instance,  <dig> independent runs were conducted of  <dig> cpu hour each. in cases where not every run reached the same energy value after  <dig> hour, the expected run-time to reach the energy value shown in the table was calculated using the equation detailed by parkes and walser  <cit> .

comparison with gtabu
the variants of remc utilizing pull moves significantly outperform remcvshd for the 2d and 3d hp models. this clearly demonstrates the effectiveness of the pull move neighbourhood. to address the question to which extent the remc search strategy contributes to the excellent performance of remcpm and remcm, we compared the performance of these algorithms with that of gtabu, the first algorithm for the hp model to use pull moves. in their paper describing gtabu and pull moves, lesh et al. reported performance results for the standard benchmark sequences s1- <dig> to s1- <dig>  <cit> . to ensure the comparability of results, we used the same experimental protocol as lesh et al. for evaluating our remc algorithms on these sequences. two hundred independent runs were performed for each sequence and the rate of successful completion  after  <dig> minutes and  <dig> minutes was reported.

lesh et al. pointed out that the performance of their implementation of gtabu could be improved by a factor of  <dig> to  <dig> through relatively straightforward optimizations. furthermore, gtabu was evaluated on different hardware . therefore, optimistically assuming our hardware is three times faster and gtabu performance could be improved by a factor of five, we also report run-times for gtabu if it were faster by a factor of fifteen.

discussion
in all experiments reported so far, the parameters of the remc algorithms have remained fixed at the values listed in the 'methods' section. these parameter sets were chosen separately for the 2d case and for the 3d case using the automatic algorithm configuration tool of hutter et al.  <cit> , which performs a local search in parameter space to optimize a given performance criterion . attempts to manually configure the algorithm parameters failed to produce settings as robust as those found by the automated tool. experiments using manually tuned parameter configurations yielded performance results that were biased in favour of either short or long sequences.

to better understand the impact of parameter settings on the performance of our remc algorithms, we performed a series of additional experiments, in which we varied one parameter at a time, while leaving all others fixed at their default values , i.e.,  : =  in 2d and  : =  in 3d, where ϕ is the number of local steps in a monte carlo search, τmin, and τmax, are the minimum and maximum temperature values respectively, χ is the number of replicas to simulate and ρ is the probability of performing a pull move.

two test sequences were selected from the standard benchmark set for this purpose. the first sequence, s1- <dig>  was selected for the 2d case as it does not involve significant interaction of the sequence termini in hydrophobic core formation. we did not choose a sequence with a symmetric optimal fold, such as s1- <dig>  since in that case, remc always appeared to find an optimal conformation fast , irrespectively of the parameter settings used. for the 3d case, sequence s2- <dig> was chosen. neither sequence demands extensive cpu time to solve, therefore  <dig> independent runs were conducted for each parameter value being evaluated. in the following, we always report the mean run-time required for reaching the target energy level. results for remcvshd have been omitted, because they are always significantly inferior to those achieved by remcm and remcpm.

number of replicas
a particularly important parameter of any remc algorithm is the number of replicas, i.e., the number of conformations on which monte carlo search is concurrently performed. in the literature, the use of χ : = n
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaadagcaaqaaiabd6eaobwcbeaaaaa@2dec@ replicas has been suggested, where n is the number of degrees of freedom within the system  <cit> .

to test the specific effect of this parameter within the context of protein folding in the hp model with our current implementation, we conducted experiments on s1- <dig> and s2- <dig> using  <dig>   <dig>   <dig>   <dig>   <dig>   <dig>   <dig>   <dig> and  <dig> replicas. as stated above, all other parameters remained fixed including the minimum and maximum temperature, set to  <dig> and  <dig>  respectively. formally, when evaluating the performance for replicas χ the temperature of replica k,  <dig> ≤ k ≤ χ, was determined by the uniform linear function

 t:=160+⋅220−160χ−1
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaacqwgubavcqggoaakcqwgrbwacqggpaqkcqgg6agocqgh9aqpcqaixaqmcqai2agncqaiwaamcqghrawkcqggoaakcqwgrbwacqghsislcqaixaqmcqggpaqkcqghfly1dawcaaqaaiabikdayiabikdayiabicdawiabgkhitiabigdaxiabiada2iabicdawaqaaggaciab=d8ajjabgkhitiabigdaxaaaaaa@4824@ 

temperature distribution
we now focus our attention on the effect of temperature values on run-time. the probability distributions that control the acceptance of conformations during the monte carlo search depend directly on the temperature settings for each replica ; similarly, the probability for performing replica exchanges depends on the temperature difference between neighbouring replicas . generally, a replica with a higher temperature value will accept a worsening move with a higher probability than a replica at a lower temperature. hence, at higher temperatures, the search process is less likely to stagnate in local minima of the energy landscape. at the same time, however, lower temperatures are required for exploring promising regions effectively. therefore, there is a trade-off between search diversification and intensification that is controlled by the temperature values used by the replicas. while our algorithms support arbitrary assignments of temperature values to each replica, in all experiments conducted in this study we have chosen simple linear temperature distributions over replicas, in which the temperature values are obtained by uniform linear interpolation between a minimum and a maximum temperature value. furthermore, we have chosen to fix the minimum temperature to  <dig> in all cases; at this value, significantly worsening moves are accepted with a probability near zero while exchanges between the neighbouring temperature are still possible when reasonable values are chosen. for a thorough discussion on the use of exponential temperature distributions and the general effect of temperature distribution on performance, the reader is referred to the work of iba  <cit>  and mitsutake et al.  <cit> . the results reported in figure  <dig> suggest a clear relationship between maximum temperature and mean run-time in both, the 2d case  and the 3d case . in the 2d case, run-time is poor at both extremes of the temperature range. when temperature values are too low, the algorithm gets trapped in local minima regions for extended periods of time; likewise, higher temperatures make it difficult for the algorithm to effectively optimize promising conformations. the default parameter value of  <dig> seems a reasonable choice for both remcm and remcpm. in the case of 3d, it seems that run-time scales worse as temperature is increased.

number of mc steps
the parameter φ specifies the number of monte carlo steps performed by each replica between any two  replica exchanges. to determine the effect of this parameter on the run-time of our remc algorithms, we conducted experiments using a number of values ranging from  <dig> to  <dig> mc steps between replica exchanges.

probability of performing pull moves
in remcm, a parameter ρ is used to specify the probability of using the pull move  neighbourhood in any given search step. figure  <dig> illustrates how the value of ρ affects the performance of the algorithm in the 2d case  and 3d case . note that for ρ =  <dig>  remcm becomes identical to remcvshd, and for ρ =  <dig>  remcm behaves exactly like remcpm. as can be expected based on the results previously shown for all three algorithms, low settings of ρ result in substantially weaker performance than high settings; for the instances considered here, there were no significant performance differences for ρ ≥  <dig> .

CONCLUSIONS
in this work we have demonstrated the effectiveness of an extended ensemble algorithm, replica exchange monte carlo search, when applied to the protein structure prediction problem for the hp model on the two dimensional square lattice and the three dimensional cubic lattice. a direct comparison with two state-of-the-art algorithms, aco-hppfp- <dig> and perm, on a standard set of benchmark sequences has shown that when using the pull move neighbourhood, remc performs exceptionally well. in the 2d case, remc ties or outperforms aco-hppfp- <dig> on every problem instance we studied. furthermore, the performance of remcm matches or exceeds that of perm on ten out of the eleven benchmark instances.

in 3d, we have shown that remc outperforms aco-hppfp- <dig> on all commonly studied benchmark instances. moreover, remc variants based on pull moves find ground-state conformations as fast or faster than perm for nine of ten instances and with a mean run-time of  <dig>  cpu seconds on the remaining instance .

we have demonstrated that in the context of remc search, using pull moves – as opposed to vshd moves only – results in substantial performance improvements. we have also shown that by combining pull moves and vshd moves into a hybrid search neighbourhood, better  performance can be obtained in some cases. at the same time, the use of remc search also contributes to the overall effectiveness of our new algorithms, as can be seen from the fact that our remc algorithms using pull moves performs better than the gtabu algorithms, which is also based on the pull move neighbourhood. while gtabu introduced pull moves on the square lattice,  our study is the first to use pull moves on a 3-dimensional lattice model.

remc proved to be very effective in folding proteins whose hydrophobic cores are formed by interacting termini, such as s1- <dig> from the standard benchmark set – a class of sequences that are very difficult for perm. similarly, we have shown that remc finds ground-state conformations for sequences with provably unique optimal structures more effectively than perm. we also presented evidence indicating that when applied to sequences with degenerate ground-states, remc finds a larger and more diverse set of ground-state conformations in both 2d and 3d. finally, we have demonstrated that remc performs better than perm on long biological sequences , which suggests that remc's performance scales quite well with sequence length. we expect, however, that for very long sequences it may be beneficial to use a chain-growth method to generate a compact conformation from which remc search is started. overall, we have demonstrated that remc algorithms using the pull move neighbourhood show excellent performance on the hp model. considering the generality of remc and the possibility of adapting the concept of pull moves to more complex lattice structures, we see much promise in developing similar algorithms for models that can represent protein structure more accurately.

