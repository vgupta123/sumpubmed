BACKGROUND
seed design for dna sequence alignment
comparing nucleic acid sequences is one of the most important tasks in computational biology. although many sequence alignment algorithms have been designed, the rapid increase in size of genome databases continues to present alignment algorithms with the challenge of finding good alignments  efficiently.

seeded alignment is the dominant technique for large-scale genomic sequence comparisons, and blastn  <cit>  is the most popular implementation of it. in blastn, exact matches of w contiguous residues between sequences are identified and then extended into alignments by dynamic programming. more recent work extends blastn's contiguous match heuristic to find more general patterns of conservation, which are commonly called seeds. seeds have been used not only for large-scale local alignment but also as anchor points in whole-genome and multiple sequence alignment algorithms  <cit> .

it has been shown  <cit>  that seed design is important to the sensitivity and specificity of seeded alignment. to improve on traditional contiguous seeds used in, e.g., blastn  <cit> , spaced seeds were proposed, initially as part of the flash indexed search tool  <cit> . a spaced seed spanning s bases requires matching bases at only a subset of the positions { <dig> , ..., s - 1}. patternhunter  <cit>  used a carefully designed spaced seed based on a simple i.i.d. alignment model to increase sensitivity. mandala  <cit>  built a dfa to evaluate the sensitivity of spaced seeds under a κth-order markov model; a more accurate hidden markov model was used in  <cit> . algorithms for multi-seed design are described in  <cit> . all of the seeds mentioned above distinguish only between matched and mismatched residue pairs. in this paper, we call them basic seeds.

the blastz alignment program  <cit>  adopted the optimal spaced seed designed by patternhunter. in order to increase sensitivity, they allowed a transition mutation  at any one of the inspected positions in patternhunter's seed. we generalize this definition to arbitrary seeds allowing transition mutations at fixed positions, which we call transition seeds.

in blastp  <cit> , a protein alignment contains a seed match if the sum of scores of three consecutive amino acid pairs starting from some offset in the alignment exceeds a specified threshold. the individual score of each residue pair comes from a scoring matrix m modeling the rate of evolutionary change. we apply blastp-like seeds to dna sequence comparison by computing the sum of the scores in the positions inspected by a basic seed. these seeds are called score seeds. score seeds can also implement the inexact seeds used in blat  <cit>  and chaos  <cit> .

score seeds are a special type of vector seed  <cit>  using only binary vectors.  <cit>  observed that most vector seeds that empirically worked well had binary seed vectors. thus, we do not focus on a general vector seed's performance in this work. we note that transition seeds could also be represented by vector seeds with a carefully designed seed vector and threshold.

motivation for our work
although none of the above seed types is novel, there is an absence of practical guidance to picking good seeds due to a lack of detailed performance comparison among basic, transition, and score seeds. the purpose of this work is to compare the above-mentioned seed types in a common experimental framework, and to derive practical guidance for choosing an appropriate seed heuristic for seeded alignment in genomic dna.

a comparison of seeds must consider both sensitivity to biologically meaningful alignments and specificity, which affects the computational cost of using a seed. less stringent seeds, e.g. seeds that allow transition mutations as well as matches, are likely to yield better sensitivity, but at a significant cost in specificity. although some recent works on multiple simultaneous seed design  <cit>  have been aware of this tradeoff, they do not perform systematic evaluations to judge whether less stringent seeds confer a net benefit to seeded alignment, that is, whether they are consistently more sensitive for given specificity. this work summarizes both sensitivity and specificity of seeds using receiver operating characterstic  curves. we also consider, where appropriate, other issues affecting the computational cost of seeds.

as part of our work, we must design seeds; that is, we must choose particular seeds or sets of seeds that maximize performance among many seeds or sets of the same type. seed design requires efficient computation of seed sensitivity and, at times, specificity. methods for efficiently computing the sensitivity of a basic seed have been reported in several papers  <cit> . an efficient algorithm was used to compute sensitivity of score seeds in  <cit> . yass  <cit>  computed the sensitivity of a single transition seed. in this work, we extend our mandala seed design software  <cit>  to compute the sensitivities of transition seeds and score seeds. we also develop methods to estimate a seed's specificity where direct measurement of this quantity is computationally prohibitive. previous work  <cit>  computed seed specificity based on a simple i.i.d. background sequence model. to ensure a biologically more appropriate comparison, we compute specificity based on a more informative markov sequence model.

to evaluate a seed's sensitivity, we use a set of alignments representing the type of sequence similarity to be found. while many previous papers  <cit>  have focused on designing seeds for coding dna regions, we are also interested in designing seeds for noncoding dna alignment because comparative analysis between noncoding regions discloses important information about genome evolution and functional features  <cit>  and is the basis of modern whole-genome alignment tools  <cit> . we therefore focus our study on seed performance in alignments biased strongly toward noncoding dna, though we also consider the extent to which results in these alignments generalize to a more traditional coding-heavy test set.

the remainder of this work is organized as follows. after describing our methods, we present experimental results on the relative sensitivities and computational costs of different types of seed. we conclude by identifying lessons drawn from our experiments and indicate directions for future work.

formal definitions of seeds
a basic seed π is defined to be an ordered list of indices {x <dig> ... xw} with x <dig> =  <dig>  two sequences s and t exhibit a seed match at offsets i and j if, for  <dig> ≤ k ≤ w, s = t. the number of inspected positions w is the weight of π, while the distance s = xw +  <dig> is its span. for a position j with  <dig> ≤ j ≤ s, if j  {x <dig> ... xw}, then yi is a "don't care position" that could be a match or mismatch.

a transition seed πz with span s is defined to be a pair of ordered lists of distinct indices:  with x <dig> =  <dig> or z <dig> =  <dig>  w ≤ s and m ≤ s. two sequences s and t exhibit a transition seed match at offsets i and j if two conditions are satisfied: 1) for  <dig> ≤ k ≤ w, s = t; 2) for  <dig> ≤ k ≤ m, either s = t, or the two residues are both purines or both pyrimidines. we call each xi a match position and each zi a transition position. for any position yi, if yi <s, yi  x and yi  z, it is a "don't care position" that could be a match, a transition, or a transversion. the number of inspected match positions w is the match weight of πz. the number of transition positions m is the transition weight of πz. the span of a transition seed is max +  <dig> 

a score seed is defined by a pair <π, t>, where π is a basic seed and t is a score threshold. let π = {x <dig> ... xw} with x <dig> =  <dig>  two sequences s and t exhibit a score seed match at offsets i and j if, for  <dig> ≤ k ≤ w, ∑k ci+xk,j+xk ≥ t. here, ci+xk,j+xk is the score for the residue pair . the individual score of every pair comes from a scoring matrix m. the weight w and span s of a score seed are defined by its underlying basic seed π.

a set of multiple simultaneous seeds Π = {π <dig> ... πn} contains n seeds of the same type. a seed set Π matches an alignment if at least one component seed from Π matches this alignment. based on this definition, the transition seed used in blastz alignment  <cit>  is actually a set of  <dig> transition seeds, each with w =  <dig> and m =  <dig>  the seeds differ from each other in only one position. we call this set a blastz seed, which is a special case of multiple transition seeds. because multiple score seed design is a somewhat different problem from regular seed design  <cit> , we will focus only on sets of transition seeds.

methods
seed sensitivity and specificity
a seed's sensitivity is the probability that a biologically meaningful alignment contains a match to the seed. in our experiments, a seed's sensitivity is measured by the fraction of a set of known alignments that contain the match to a specified seed.

because seed design requires evaluating the sensitivities of hundreds or thousands of candidate seeds, we need a more efficient way to estimate sensitivity in order to search for optimal seeds or seed sets. the mandala seed design software  <cit>  contains efficient estimation procedures for basic seeds. for this work, we have extended mandala to compute the sensitivity of a seed in a probabilistic alignment model ℳ
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufebsjuyzl2yd9gzlbvynv2caerbwvmckfmbhbqedmvetj2bsbwenfgdovwbhrxajfwnhbqeg0uy0hwztfgdpnwy1aqee0evguee0jxyaibaieydoi=bh8vipeydi8qiw7rqqrffpeea0xe9lq=jc9vqaqpepm0xbbg8faspyrqj0=yi0lxdbba9pge9qqff0dxdhuk9fr=xfr=xfrpiwzqaaeaabigaaiaacaqabeaadaqacqaaaoqaagwaaiab=ntinbaa@3aa6@ that includes information other than simply the distribution of matches and mismatches. these extensions use mandala's dfa-based sensitivity evaluator. for a transition seed, we create a three-symbol dfa whose size is at most s3s - w - m2m, where s, w, and m are the seed's span, match weight, and transition weight respectively. if the number of different values in a score matrix m is d, a d-symbol dfa can be built to evaluate the sensitivity of a score seed. when dynamic programming becomes expensive, i.e. for seeds with large span but small weight , we resort to monte carlo methods to estimate sensitivity, as described in  <cit> .

the false positive rate  of a seed, which is complementary to its specificity, is the probability that a seed match occurs at some position purely by chance. for single basic and transition seeds with moderate weights, we can efficiently compute fp rates directly by counting seed matches between pairs of unrelated sequences. this computation is effectively the same as using the seed to perform a similarity search, which can be done efficiently in practice. however, this direct counting approach becomes computationally quite expensive for sets of seeds, as we must make certain not to count hits to two seeds in a set as two distinct hits to the set.

our current implementation of hit counting for score seeds is also computationally expensive, which poses a problem for designing such seeds. setting a score seed's threshold t to obtain a target fp rate requires evaluation of multiple thresholds, and computing the fp rates for these thresholds by direct counting proved burdensome in practice. these considerations led us to seek more efficient, though slightly less accurate, computational strategies to estimate fp rates for score seeds and sets of transition seeds.

we estimate fp rates using a probabilistic model ℳ
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufebsjuyzl2yd9gzlbvynv2caerbwvmckfmbhbqedmvetj2bsbwenfgdovwbhrxajfwnhbqeg0uy0hwztfgdpnwy1aqee0evguee0jxyaibaieydoi=bh8vipeydi8qiw7rqqrffpeea0xe9lq=jc9vqaqpepm0xbbg8faspyrqj0=yi0lxdbba9pge9qqff0dxdhuk9fr=xfr=xfrpiwzqaaeaabigaaiaacaqabeaadaqacqaaaoqaagwaaiab=ntinbaa@3aa6@b that characterizes alignments between a pair of unrelated, random sequences. alignments in model ℳ
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufebsjuyzl2yd9gzlbvynv2caerbwvmckfmbhbqedmvetj2bsbwenfgdovwbhrxajfwnhbqeg0uy0hwztfgdpnwy1aqee0evguee0jxyaibaieydoi=bh8vipeydi8qiw7rqqrffpeea0xe9lq=jc9vqaqpepm0xbbg8faspyrqj0=yi0lxdbba9pge9qqff0dxdhuk9fr=xfr=xfrpiwzqaaeaabigaaiaacaqabeaadaqacqaaaoqaagwaaiab=ntinbaa@3aa6@b arise from two independent sequences, each of which is modeled by a kth-order markov process. the alignment model can be computed from the two underlying sequence models by multiplying their corresponding terms as follows:

pr| ... )

= pr × pr.

the next section shows how this model is used to estimate false positive rates.

computation of fp rates
efficient computation of false positive rates, particularly for score seeds, is computationally nontrivial. here, we describe a dynamic programming algorithm, inspired by altschul's computation of sum score frequencies in ncbi blast  <cit> , that computes fp rates for score seeds when ℳ
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufebsjuyzl2yd9gzlbvynv2caerbwvmckfmbhbqedmvetj2bsbwenfgdovwbhrxajfwnhbqeg0uy0hwztfgdpnwy1aqee0evguee0jxyaibaieydoi=bh8vipeydi8qiw7rqqrffpeea0xe9lq=jc9vqaqpepm0xbbg8faspyrqj0=yi0lxdbba9pge9qqff0dxdhuk9fr=xfr=xfrpiwzqaaeaabigaaiaacaqabeaadaqacqaaaoqaagwaaiab=ntinbaa@3aa6@b takes the form of kth-order markov model with k >  <dig>  the same algorithm can be simplified to compute fp rates for other types of seed. we then extend our computation to deal with sets of seeds. finally, we quantify how well our estimates of seeds' fp rates approximate the actual rates using a sample of randomly chosen seeds of several types.

fp rate for a score seed
the fp rate of a score seed <π,t> is the probability that, at a fixed position in a pair of unrelated sequences, the total score of the positions inspected by π is at least t. let a
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbamrthrhal1wy0l2yhvtyaehbnfgdovwbhrxajfwnaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabawaaegaeaaakeaaimaacqwfaefqaaa@3821@ be the sequence alphabet; alignments of unrelated sequences are described by a |a
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbamrthrhal1wy0l2yhvtyaehbnfgdovwbhrxajfwnaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabawaaegaeaaakeaaimaacqwfaefqaaa@3821@|2-symbol kth-order markov model ℳ
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufebsjuyzl2yd9gzlbvynv2caerbwvmckfmbhbqedmvetj2bsbwenfgdovwbhrxajfwnhbqeg0uy0hwztfgdpnwy1aqee0evguee0jxyaibaieydoi=bh8vipeydi8qiw7rqqrffpeea0xe9lq=jc9vqaqpepm0xbbg8faspyrqj0=yi0lxdbba9pge9qqff0dxdhuk9fr=xfr=xfrpiwzqaaeaabigaaiaacaqabeaadaqacqaaaoqaagwaaiab=ntinbaa@3aa6@b. for any residue pair b ∈ a
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbamrthrhal1wy0l2yhvtyaehbnfgdovwbhrxajfwnaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabawaaegaeaaakeaaimaacqwfaefqaaa@3821@ <dig>  its score m is given by a substitution matrix m.

the following algorithm computes the probability that, at any fixed offset in the alignment, the total score across all positions inspected by π is at least t. let δ be a residue pair string of length k. for each position j from  <dig> to s , define pj to be the probability that the total score of the inspected positions up to j is θ, and that the last k +  <dig> residue pairs ending at position j form the string δ·b. according to this definition, the residue pair at position j is b. the fp rate we want to compute is ∑θ≥t ∑δ·b∈k ps, where k is the set of all the residue pair strings of length min.

it remains to compute pj we first define low to be the smallest score in the matrix m and high to be the largest such score. let δ·b be a residue pair string with length k' = min. if j ∈ {x <dig> ... xw} we have

pj=pr⁡×∑b0∈a2pj- <dig>      
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbamrthrhal1wy0l2yhvtyaehbnfgdovwbhrxajfwnaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabawaaegaeaaakeaacqwgqbaudawgaawcbagaemoaaogabeaakiabcicaoggaciab=h7axjabcycasiab=r7akjabgwsixlabdkgaijabcmcapiabg2da9igbccfaqjabckhayjabcufabjabdkgaijabcyha8jab=r7akjabc2fadjabgena0oaaqafabaacbigae4huaa1aasbaasqaaiab+pgaqjab+1catgqaaiab9fdaxaqabaaabagaemoyai2aasbaawqaaiabicdawaqabawccqghiiizimaacqafaefqdaahaaadbeqaaiab9jdayaaaasqab0gaeyyeiuoakiabcicaoiab=h7axjab=jhitiab=x5anhgaaiab7tfabjab+jgaijab91fadjabcycasiabdkgainaabaaaleaacqaiwaamaeqaaogaeyyxictae8htdqmaeiykakiaeiola4iaaczcaiaaxmaadaqadaqaaiabigdaxagaayjkaiaawmcaaaaa@7214@

otherwise,

pj=pr⁡×∑b0∈a2pj− <dig>      
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbamrthrhal1wy0l2yhvtyaehbnfgdovwbhrxajfwnaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabawaaegaeaaakeaacqwgqbaudawgaawcbagaemoaaogabeaakiabcicaoggaciab=h7axjabcycasiab=r7akjabgwsixlabdkgaijabcmcapiabg2da9igbccfaqjabckhayjabcufabjabdkgaijabcyha8jab=r7akjabc2fadjabgena0oaaqafabawexlmbbxgbcf2cpn2qvrwzqf2zlnharcgvljhzh5wyagqbciaa+bfadawgaawcbagaa4naaiab=jhitgqaaiab9fdaxaqabaaabagaemoyai2aasbaawqaaiabicdawaqabawccqghiiizimaacqafaefqdaahaaadbeqaaiab9jdayaaaasqab0gaeyyeiuoakiabcicaoiab=h7axjabcycasiabdkgainaabaaaleaacqaiwaamaeqaaogaeyyxictae8htdqmaeiykakiaeiola4iaaczcaiaaxmaadaqadaqaaiabikdayagaayjkaiaawmcaaaaa@75c3@

the probability pr is given by the model ℳ
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufebsjuyzl2yd9gzlbvynv2caerbwvmckfmbhbqedmvetj2bsbwenfgdovwbhrxajfwnhbqeg0uy0hwztfgdpnwy1aqee0evguee0jxyaibaieydoi=bh8vipeydi8qiw7rqqrffpeea0xe9lq=jc9vqaqpepm0xbbg8faspyrqj0=yi0lxdbba9pge9qqff0dxdhuk9fr=xfr=xfrpiwzqaaeaabigaaiaacaqabeaadaqacqaaaoqaagwaaiab=ntinbaa@3aa6@. equations  and  give the general case of the recurrence; for j <k +  <dig>  δ·b is a residue pair string of length j, and there is no prior residue  <dig> on the right-hand side. we initialize the recurrence by computing p <dig> directly for all residue pairs b ∈ a
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbamrthrhal1wy0l2yhvtyaehbnfgdovwbhrxajfwnaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabawaaegaeaaakeaaimaacqwfaefqaaa@3821@ <dig> 

we need to calculate pj for  <dig> ≤ j ≤ s. for each j, suppose the number of matching positions up to j is π. then θ is bounded by the closed interval . thus, the fp rate of the score seed with weight w and span s under a kth-order markov model can be computed in time Θk+1s). the actual computational cost can be decreased substantially by observing that pj is zero for many values of θ, since the different score values in score matrix m are not successive integers. in addition, for a specified threshold t, the lowest possible score sum θ at position j is t - )·high. thus, we only need to compute pj with θ bounded by the closed interval .

fp rate for multiple simultaneous seeds
we may compute the fp rate of a set of basic or transition seeds using the inclusion-exclusion method. let Π = {π <dig> ... πn} be a set of basic seeds or transition seeds. we are interested in the probability that at least one seed from Π yields a match. if more than one seed hits at the same position, only one hit is counted in the total number of seed hits. the inclusion-exclusion method is used to calculate the false positive rate fpΠ as follows:

fpΠ=∑ifpπi−∑i,jfpπi+πj+∑i,j,kfpπi+πj+πk…     
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaacqwgmbgzcqwgwbacdawgaawcbagaeuiodafabeaakiabg2da9maaqafabagaemozaymaemicaa3aasbaasqaaggaciab=b8awnaabaaameaacqwgpbqaaeqaaawcbeaaaeaacqwgpbqaaeqaniabgghildgccqghsisldaaeqbqaaiabdagamjabdchawnaabaaaleaacqwfapacdawgaaadbagaemyaakgabeaaliabgucariab=b8awnaabaaameaacqwgqbgaaeqaaawcbeaaaeaacqwgpbqacqggsaalcqwgqbgaaeqaniabgghildgccqghrawkdaaeqbqaaiabdagamjabdchawnaabaaaleaacqwfapacdawgaaadbagaemyaakgabeaaliabgucariab=b8awnaabaaameaacqwgqbgaaeqaasgaey4kasiae8hwda3aasbaawqaaiabdugarbqabaaaleqaaaqaaiabdmgapjabcycasiabdqgaqjabcycasiabdugarbqab0gaeyyeiuoakiablaciljaaxmaacawljawaaewaaeaacqaizawmaiaawicacaglpaaaaaa@6940@

where fpπ is the fp rate for seed π, and the combined seed πi + πj matches at a given position if and only if both πi and πj match at that position. for basic seeds, πi + πj is actually the union of all the inspected positions of πi and πj. for a transition seed πi =  with span si and a transition seed πj =  with span sj, πi + πj is a transition seed with span max. each position k,  <dig> ≤ k ≤ max, is a match position if k ∈ xi or k ∈ xj. otherwise, it is a transition position if k ∈ zi or k ∈ zj. k is a "don't care" if neither of the previous two conditions is satisfied. for example, the union of two transition seeds  and  is .

the inclusion-exclusion method can be combined with a hashing strategy to estimate the fp rate for multiple simultaneous seeds without using a background markov model. however, the union of two or more transition seeds usually has a large weight , which still incurs a large cost for direct counting. in this case, we can use the first term of equation  to estimate the seed set's fp rate, since the remaining the terms are much smaller than it.

comparison of predicted vs. actual fp rates
we used the predicted fp rate to design a score threshold for a score seed. in addition, in order to estimate the error introduced by only using the first term in equation  when computing the actual fp rate for a set of transition seeds, we evaluate each other term in equation  using the theory prediction. thus, we need to quantify how well our model-based estimates predict score seeds and transition seeds' actual fp rate in real dna. we randomly generated  <dig> samples of each type of transition seed with w + m =  <dig> and  <dig> and then counted the seed matches on randomly chosen pairs of human and mouse genomic dna sequences, with a typical length of  <dig> megabases. we compared the measured and estimated false positive rates for our sampled seeds on these pairs of sequences.

a similar comparison was conducted for score seeds under the score matrix mnc described below in the results section. since direct counting for a score seed may take hours to complete in our implementation, the error distribution for these seeds reflects only  <dig> random underlying basic seeds, rather than  <dig> 

searching for an optimal set of transition seeds
as part of our comparative analysis, we wish to evaluate sets of simultaneous transition seeds. we therefore modified mandala to find sets of such seeds with maximal sensitivity for a fixed weight. it has been shown that finding an optimal set of seeds is np-hard  <cit> . for this reason, most existing works rely either on exhaustive search  <cit> , local search techniques  <cit> , approximations  <cit>  or other heuristics  <cit>  to find globally or locally optimal seeds. it is not practical to exhaustively search for an optimal transition seed with a big span. thus we extend the local search strategy for basic seed design  <cit>  to seek a locally optimal set of transition seeds with maximal span smax.

let a transition seed πz = {{x <dig> ... xw}, {z <dig> ... zm}} be the current seed. the local neighborhood of πz is the set of all seeds π′z
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaaiigacuwfapacgaqbamaabaaaleaacqwg6bgeaeqaaaaa@3025@ that differ from πz in exactly one of the choices x <dig> ... xw or z <dig> ... zm. let y = { <dig> ... smax - 1} - πz be the set of all "don't care" positions. to generate a seed π′z
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaaiigacuwfapacgaqbamaabaaaleaacqwg6bgeaeqaaaaa@3025@, one of three operations is allowed: swapping some match position xi with some transition position zj, swapping some xi with some "don't care" position yk ∈ y, or swapping some zj with some yk. the only restriction is that position  <dig> cannot be a "don't care". using this neighborhood structure and the probability calculations described above for transition seeds, we employ hill climbing with random restarts in seed space to find a near-optimal seed. to design a set of simultaneous transition seeds Πz, we extend the neighborhood definition to encompass all sets Π′z
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaacuqhgoaugaqbamaabaaaleaacqwg6bgeaeqaaaaa@2fdf@ in which one transition seed π′zi∈Π′z
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabaqabegadaaakeaaiigacuwfapacgaqbamaabaaaleaacqwg6bgecqwgpbqaaeqaaogaeyici4safuiodalbauaadawgaawcbagaemoeaohabeaaaaa@3641@ differs from the corresponding πzi ∈ Πz in a single position.

construction of test alignment set
we need a set of alignments on which to evaluate seed sensitivity. many previous papers  <cit>  have derived alignments from abundant sources of coding dna, such as ests. in this work, however, we also wish to investigate the ability of seeds to detect alignments in noncoding dna, in particular in regions of long-range noncoding sequence orthology in eukaryotes. we therefore constructed a test set, based on alignments of two mammalian genomes, that is biased against inclusion of alignments involving coding dna.

ideally, existing seeded alignment tools should not be directly applied to extract alignments for our test set, since any seed used by these tools would have perfect sensitivity to these alignments and would therefore introduce a strong bias. for example, brejova et al. observed that their direct use of blastp made all the alignments in their training set contain the default blastp seed  <cit> . however, direct application of the smith-waterman algorithm  <cit>  to sample alignments from noncoding regions between a pair of large genomes is not computationally feasible. we therefore combine seed heuristics and dynamic programming such that rigorous, seed-free dynamic programming is only applied on small sequence blocks.

our construction procedure is as follows. it takes as input a pair of genomes and produces a set of ungapped local alignments, or high-scoring segment pairs .

 <dig>  extract orthologous pairs of regions from the human and mouse genomes according to a provided synteny table from the ucsc genome browser  <cit> .

 <dig>  remove from these regions any dna annotated as coding for protein, according to the twinscan gene structure predictor  <cit>  and the known genes. also, remove low-complexity dna and known interspersed repeats.

 <dig>  apply a seeded alignment tool on every pair of orthologous regions to extract gapped local alignments between them. we use a karlin-altschul e-value of  <dig>  to keep more potential hsps.

 <dig>  from the gapped local alignments for each region pair, chain together a subset of alignments whose total score is maximized under the following constraints: 1) between any two alignments in the subset, one alignment's starting indices in two sequences cannot be smaller than another alignment's ending indices. 2) all the alignments in the subset must have the same orientation. this subset can be obtained using, e.g., the longest increasing subsequence algorithm given in  <cit> .

 <dig>  create small blocks  within each pair of regions that cover the optimal chain obtained in step  <dig>  to avoid missing hsps at block boundaries, adjacent blocks overlap slightly.

 <dig>  for every block created in step  <dig>  apply an ungapped version of the sim algorithm  <cit>  to extract all hsps in the block with e-value ≤  <dig> .

fig.  <dig> illustrates a set of blocks created by the above procedure.

RESULTS
in this section, we compare the sensitivities and fp rates of different types of seed on sets of dna sequence alignments. we work principally with our set of noncoding-biased alignments, described in the previous section, but we also measure performance on a set of est-derived alignments, which has a stronger coding bias.

the experimental framework and data sources are described in detail in appendix  <dig>  all the seeds tested below were designed by the mandala software using a markov alignment model ℳ
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufebsjuyzl2yd9gzlbvynv2caerbwvmckfmbhbqedmvetj2bsbwenfgdovwbhrxajfwnhbqeg0uy0hwztfgdpnwy1aqee0evguee0jxyaibaieydoi=bh8vipeydi8qiw7rqqrffpeea0xe9lq=jc9vqaqpepm0xbbg8faspyrqj0=yi0lxdbba9pge9qqff0dxdhuk9fr=xfr=xfrpiwzqaaeaabigaaiaacaqabeaadaqacqaaaoqaagwaaiab=ntinbaa@3aa6@ inferred from the test set. although mandala does not guarantee global optimality of the seeds it chooses, the seeds are locally near-optimal given their design constraints.

we illustrate the behaviors of different seed types using roc curves to facilitate comparing the sensitivities of different seeds at the same fp rate . we report empirically measured sensitivities and fp rates for all seed types. however, as described above, we only used the first term of equation  to compute the fp rates for transition seed sets, since a fully empirical rate computation proved computationally difficult. fortunately, for the seed sets studied here, each component seed tends to inspect different groups of positions  <cit> , and so their union has a much larger weight than any individual seed. hence, the first term of equation  indeed dominates. by estimating each term of equation  using the dynamic programming method, we estimate that this simplification introduces at most 10% error in our fp rates for transition seed sets.

performance of transition seeds on noncoding test set
we first investigated how the transition weight m and the set size n affect the performance of transition seeds. according to our definitions of w and m for transition seeds, a transition position allows twice as many base pairs as a match position. thus, the transition seeds with same value of w+m/ <dig> have comparable specificity. we first designed experiments to investigate the sensitivity/specificity tradeoff by increasing m while keeping w + m/ <dig> unchanged. secondly, we did experiments using multiple transition seeds.

fig.  <dig> compares the performance of two types of single transition seeds with m =  <dig>  and m =  <dig>  as well as two transition seeds, four transition seeds, and one blastz seed. on our test set, increasing the number n of simultaneous transition seeds used significantly improves seed performance, with the roc curves for larger n dominating those for smaller n. these results are consistent with those observed for basic seeds in previous work . comparison between single transition seeds with m =  <dig> and m =  <dig> shows that increasing m for fixed n + m/ <dig> also improves seed performance.

the blastz seed tested in fig.  <dig> introduces only a single transition; however, the position of that transition is not fixed, in contrast to the other seeds tested in this experiment. our results indicate that allowing such "freedom of movement" is highly effective: the single blastz seed performed at least as well as a pair of seeds with fixed transitions, and its performance approaches that of four such seeds. moreover, as we discuss below, there are algorithmic reasons to prefer the blastz seed in practice.

performance of score seeds on noncoding test set
recall that a score seed is a pair <π, t>, where π is a basic seed and t is a score threshold. the score of a residue pair comes from a score matrix m. in this section, we investigate the impact of the matrix m on the performance of a score seed and attempt to evaluate which properties of alignments this matrix should capture to optimize its sensitivity/specificity tradeoff.

design of score matrices
in similarity search, the matrix m distinguishes the alignments being sought based on their unusual residue composition. we constructed matrices that captured three increasingly refined models of this composition, to quantify which signals were most important to score seed performance.

first, we designed our own symmetric score matrix mnc, based on the log-likelihood ratio methodology described in  <cit> . suppose model ℳ
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufebsjuyzl2yd9gzlbvynv2caerbwvmckfmbhbqedmvetj2bsbwenfgdovwbhrxajfwnhbqeg0uy0hwztfgdpnwy1aqee0evguee0jxyaibaieydoi=bh8vipeydi8qiw7rqqrffpeea0xe9lq=jc9vqaqpepm0xbbg8faspyrqj0=yi0lxdbba9pge9qqff0dxdhuk9fr=xfr=xfrpiwzqaaeaabigaaiaacaqabeaadaqacqaaaoqaagwaaiab=ntinbaa@3aa6@ describes the distribution of residue pairs for an alignment. for each ordered pair of residues i and j, pr⁡ℳ
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbamrthrhal1wy0l2yhvtyaehbnfgdovwbhrxajfwnaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabawaaegaeaaakeaacyggqbaucqggybgcdawgaawcbaacdagae83mh0eabeaakiabcicaoiabdmgapjabcycasiabdqgaqjabcmcapaaa@3fa6@ is the frequency of the pair  in model ℳ
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufebsjuyzl2yd9gzlbvynv2caerbwvmckfmbhbqedmvetj2bsbwenfgdovwbhrxajfwnhbqeg0uy0hwztfgdpnwy1aqee0evguee0jxyaibaieydoi=bh8vipeydi8qiw7rqqrffpeea0xe9lq=jc9vqaqpepm0xbbg8faspyrqj0=yi0lxdbba9pge9qqff0dxdhuk9fr=xfr=xfrpiwzqaaeaabigaaiaacaqabeaadaqacqaaaoqaagwaaiab=ntinbaa@3aa6@. let

pℳ=pr⁡ℳ+pr⁡ℳ.     
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbamrthrhal1wy0l2yhvtyaehbnfgdovwbhrxajfwnaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabawaaegaeaaakeaaiegacqwfqbaudawgaawcbaacdagae43mh0eabeaakiabcicaoiabdmgapjabcycasiabdqgaqjabcmcapiabg2da9maaxababagagiiuaalaeiocaihaleaacqgfzestaeqaaogaeiikagiaemyaakmaeiilawiaemoaaomaeiykakiaey4kasyaacbeaeaacyggqbaucqggybgcasqaaiab+ntinbqabagccqggoaakcqwgqbgacqggsaalcqwgpbqacqggpaqkcqgguaglcawljagaaczcamaabmaabagaeginaqdacagloagaayzkaaaaaa@575e@

suppose further that ℳ
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufebsjuyzl2yd9gzlbvynv2caerbwvmckfmbhbqedmvetj2bsbwenfgdovwbhrxajfwnhbqeg0uy0hwztfgdpnwy1aqee0evguee0jxyaibaieydoi=bh8vipeydi8qiw7rqqrffpeea0xe9lq=jc9vqaqpepm0xbbg8faspyrqj0=yi0lxdbba9pge9qqff0dxdhuk9fr=xfr=xfrpiwzqaaeaabigaaiaacaqabeaadaqacqaaaoqaagwaaiab=ntinbaa@3aa6@b describes the distribution of pairs in a random alignment, and define

llr=log⁡.     
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufkttlearuwrp9mdh5mbpbiqv92aaexatlxbi9gbamrthrhal1wy0l2yhvtyaehbnfgdovwbhrxajfwnaebbnrfifhhdyfgasaach8aky=wiffydh8gipec8eeeu0xxdbba9frfj0=oqffea0dxdd9vqai=hguq8kuc9pgc9s8qqaq=dirpe0xb9q8qilsfr0=vr0=vr0dc8meaabaqaciaacagaaeqabawaaegaeaaakeaacqwgmbatcqwgmbatcqwgsbgucqggoaakcqwgpbqacqggsaalcqwgqbgacqggpaqkcqgh9aqpcyggsbabcqggvbwbcqggnbwzcqggbbwwcqwgqbaudawgaawcbaacdagae83mh0eabeaakiabcicaoiabdmgapjabcycasiabdqgaqjabcmcapiabc+caviabdcfaqnaabaaaleaacqwfzestdawgaaadbaacbigae4nyaigabeaaasqabagccqggoaakcqwgpbqacqggsaalcqwgqbgacqggpaqkcqggdbqxcqgguaglcawljagaaczcamaabmaabagaegynaudacagloagaayzkaaaaaa@5d7f@

a score matrix can be formed from the llr values by multiplying them by a suitably large constant and rounding the results to integers. our matrix mnc was derived using probabilities estimated from our test alignments and the underlying sequences; it is given in table  <dig> 

we then designed two simplified matrices that used more limited information about the alignments to be found. matrix m <dig>  which follows the existing practice of ncbi blastn, uses only the overall probability of residue matches to recognize meaningful alignments; that is, all its diagonal entries are the same, as are all its off-diagonal entries. matrix mz elaborates on m <dig> by assigning separate scores to matches, transitions, and transversions, but does not distinguish between all residue pairs as does the full mnc.

impact of score matrices on score seed performance
we compared the performance, on our noncoding test set, of score seeds based on the matrices mnc, mz, and m <dig>  we used a common, optimized basic seed π as the underlying seed for all score seeds with a given weight. although π was not optimized individually based on different matrices, experiments showed that doing so did not improve performance vs. using a single common seed for all matrices.

the specificity of a score seed is determined in part by its score threshold. the thresholds for seeds under mz were set such that at most one transition and no transversion was allowed among the inspected positions; hence, these score seeds behave equivalently to blastz seeds. the thresholds for seeds using m <dig> and mnc were set so as to obtain roughly comparable fp rates to the corresponding seeds using mz. these choices resulted in score seeds with practically useful fp rates.

fig.  <dig> gives the results of our comparison. score seeds based on the matrix mz, which distinguishes transitions from transversions, dominated seeds based on m <dig>  exhibiting superior sensitivity at comparable specificity. because the underlying basic seeds were unchanged, the increase in performance is attributable to the extra information in matrix mz. in contrast, score seeds using the full matrix mnc exhibited performance indistinguishable from that of seeds using mz.

we infer that, with respect to our test set and choices of threshold, the extra information captured by the more complex mnc does not yield extra benefits for score seed design, vs. simply using the transition/transversion distinction encoded in mz. while we might observe different results with substantially less stringent score thresholds, these thresholds would likely result in fp rates too high for the resulting score seeds to be useful in practice.

comparison to coding-biased dna – est sequence alignments
our results thus far have been obtained using a data set biased against alignments of coding sequences. to test whether these results apply to a data set with the opposite bias, we repeated the experiments of the last two sections on a set of alignments between human and mouse expressed sequence tags . these alignments are by definition of transcribed dna and contain a large proportion of coding dna.

fig.  <dig> reports results from the comparison of basic, transition, and blastz seeds, while fig.  <dig> reports results for the comparison of score seeds. in contrast to our previous results, we found that blastz and transition seeds conferred no benefit over the same number of basic seeds, and that the mz matrix did not improve on the simpler m <dig> matrix. hence, our seeds appeared to behave qualitatively differently on coding dna alignments.

to explain the different results for our two alignment sets, we must look to the statistical properties of their constituent hsps. firstly, est alignments were better conserved overall  than noncoding alignments , blunting the advantage of any seed design that relies on information at non-matching positions. second, among all non-matching positions in the est alignments, 62% were transversions, vs. 38% transitions. the corresponding numbers for the noncoding test set were 40% transversions and 60% transitions. hence, we expect that seed design strategies intended to exploit the higher frequency of transitions in conserved regions will fail for the est alignment set, in which this signal is absent! these observations agree with and generalize those of  <cit>  for a single transition seed.

computational costs of blastz vs. transition seeds
the initial stage of seeded alignment search tools usually relies on a hashing strategy to detect all seed matches. for a basic seed, a query of size l  generates a hash table containing Θ entries, corresponding to the sets of residues inspected by the seed at each position of the query. a search using n simultaneous basic seeds need n such hash tables. as n increases, the storage for these tables, as well as the cost of checking several tables when searching at each position of a database, may become prohibitively large.

a neighborhood strategy may be used to build hash tables for score seeds. for every offset in l, besides the original table entry extracted from the query, an entry is also created for each string that initiates a seed match with the query. all the strings that initiate a seed match with a given string constitute a neighborhood of that string. blastp's hash lookup stage provides one example of this well-known strategy. if the average neighborhood size for a single query offset is k, the number of entries in the hash table is Θ. dynamic programming can be used to estimate the average neighborhood size based on the weight w of a score seed, the score matrix m, and the score threshold t. blastz seeds can be accommodated as a special case of this neighborhood strategy.

a neighborhood strategy can also be used to build hash tables for transition seeds. however, a more space- and time-efficient indexing method exists for seeds with transitions in fixed positions. by using an encoding of nucleotides for which a/t and c/g differ in the same bit position , we can avoid neighborhood generation altogether for these seeds.

in a high-performance dna similarity search application, much time is spent simply hashing the query. profiling ncbi blastn during a search of the human genome against a moderately large  query sequence shows that roughly half the search is spent finding seed matches. hence, a performance comparison between a search using several hash tables and one using a single, denser table will favor the latter, provided one approach does not generate vastly more false positive seed matches than the other. in the case of one blastz seed  vs. four transition seeds , we found above that these two designs have roughly comparable false positive rates; hence, a comparison of computational cost will favor the blastz seed.

discussion and 
CONCLUSIONS
seed design is an important aspect of seeded alignment. a good seed should exhibit a good tradeoff between sensitivity and specificity on the sequence alignments of interest, as well as being compatible with an overall efficient search implementation. in this work, we have evaluated the relative performance of different types of seed – basic, transition, blastz, and score – on sets of alignments biased both toward and against conserved coding dna. our results should help to guide designers of seeded alignment tools in navigating the large space of possible search heuristics.

we draw from our results several qualitative observations for designing seeds for use in genomic dna comparisons.

 <dig>  to detect alignments in primarily noncoding regions, allowing transitions in a seed, rather than just matches and mismatches, significantly improves a seed's performance.

 <dig>  when transitions represent an important signal, allowing them to occur at any position of the seed, rather than fixing them, confers a substantial cost/sensitivity advantage.

 <dig>  using a score seed with a matrix that distinguishes almost every base pair, such as mnc, appears to confer no benefit over a blastz seed in finding noncoding alignments.

 <dig>  when transitions are not an important signal for recognizing alignments, the above results do not apply. in particular, alignments of ests, which are biased in favor of coding dna, do not appear to exhibit this signal.

overall, our work emphasizes the importance of designing a seeded alignment strategy to fit the search objective, using appropriate design tools and representative test sets of alignments. for dna, knowing the relative frequencies of transitions and transversions is particularly important to the design process.

as part of this work, we have extended our mandala seed design software to design transition and blastz-style seeds. table  <dig> gives optimized blastz seeds for several common search weights as produced by our software.

seeded alignment heuristics are important not only for database search applications, such as blast, but also for whole-genome and multiple sequence alignment tools. currently, pairwise seeded alignment is used to construct anchors  <cit>  around which to build larger or multiple alignments. alternatively, one could use seed-like heuristics to recognize significant similarities in three or more sequences at once, using the results to build a more accurate set of anchors. designing such heuristics is an interesting problem for future work.

authors' contributions
jb designed the original mandala software, and both authors contributed significantly to its implementation. ys is responsible for the experiments and extensions described in this paper. all authors read and approved the final manuscript.

appendix 1: experimental framework
we derived our noncoding-biased test set from alignments between the human and mouse genomes. both genomes , along with synteny and known gene tables, were downloaded from the ucsc genome browser  <cit> . seed performance was compared on alignments between annotated synteny blocks in these genomes. we removed interspersed repeats, low complexity dna, and twinscan-annotated coding dna from these regions before comparison. about  <dig>  million ungapped hsps  were extracted by the procedure described in the methods section. hsp lengths ranged from  <dig> to  <dig> base pairs with an average of  <dig>  percent identities ranged from 50% to 100% with an average of 74%.

to obtain coding-biased alignments, we followed a procedure similar to that used in  <cit> , using human and mouse est sequences from ncbi genbank. to maintain a tractable problem size, we used two sets of ests, released in march  <dig>  that contain all new or revised human and mouse est sequences within  <dig> days before the release date. there are  <dig> human est sequences and  <dig> mouse est sequences in these two sets. we applied an ungapped version of the sim program to derive all the ungapped alignments with a score threshold  <dig> between all pairs of human est sequences and mouse est sequences under a scoring system with +1/- <dig> for match/mismatch. about  <dig>  million hsps with average length  <dig> base pairs were derived, with an average identity of 77%.

from our hsps on noncoding regions, we trained a first-order markov alignment model ℳ
 mathtype@mtef@5@5@+=feaafiart1ev1aaatcvaufebsjuyzl2yd9gzlbvynv2caerbwvmckfmbhbqedmvetj2bsbwenfgdovwbhrxajfwnhbqeg0uy0hwztfgdpnwy1aqee0evguee0jxyaibaieydoi=bh8vipeydi8qiw7rqqrffpeea0xe9lq=jc9vqaqpepm0xbbg8faspyrqj0=yi0lxdbba9pge9qqff0dxdhuk9fr=xfr=xfrpiwzqaaeaabigaaiaacaqabeaadaqacqaaaoqaagwaaiab=ntinbaa@3aa6@. for coding hsps, it is more appropriate to use a nonstationary markov model or hmm  <cit>  so that the codon structure can be incorporated into the model. however, since our current seed design tool mandala does not yet support nonstationary markov models for transition seeds, we simply trained a third-order markov model on est alignments. the background model used to estimate fp rates was computed by combining two third-order markov sequence models trained on the human and mouse genomes, respectively.

