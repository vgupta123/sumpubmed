BACKGROUND
noncoding rnas , which function directly as rnas without translating into proteins, play diverse and important biological functions  <cit> . many types of ncrnas function through both their sequences and secondary structures, which are defined by interactions between watson-crick and wobble base pairs. pseudoknot is a functionally important structural motif in ncrna secondary structures. in pseudoknots, bases in loop regions can form base pairs with bases outside the stem loop. in a graphical representation where arcs connect base pairs, pseudoknot-free secondary structures only contain parallel or nested base pairs while pseudoknot structures allow "crossing" base pairs, shown by an example in figure  <dig> a.

it is already known that pseudoknots play important functions in telomerase rna, tmrna, rrna, some riboswitches, some protein-biding rnas, viral ribosomal frameshifting signals, etc  <cit> . different research groups  <cit>  have shown that the pseudoknot structure in the telomerase rna is essential for telomerase activity. gilley and blackburn  <cit>  experimentally demonstrated that disruptions of the pseudoknot base pairing within the telomerase rna from tetrahymena thermophila prevent the stable assembly in vivo of an active telomerase. they further concluded that the pseudoknot topology rather than sequence is critical for an active telomerase. similarly, biologists reported that the pseudoknots in tmrna are highly important for protein biding, tmrna maturation, and proper folding of the trna-like domain  <cit> . currently,  <dig>  sequences in  <dig> ncrna seed families of rfam  <dig>   <cit>  contain pseudoknots. with the advances of sequencing technologies and structure predictions, more pseudoknot structures are expected to be revealed.

because the functions of ncrnas are determined by both the sequence and structure, successful ncrna homology search tools must consider both sequence and structural conservations. existing ncrna search tools can be divided into two categories. one is commonly referred to "known ncrna search", which aims to detecting homologs of ncrnas with annotated secondary structures. the second category includes tools for identifying novel ncrna genes. this work belongs to the first category and focuses on ncrnas containing pseudoknots.

for pseudoknot free ncrnas, the state-of-the-art search method is based on stochastic context-free grammars , which can accurately model the evolutionary changes of both the sequences and structures of a group of homologous ncrnas. commonly used general and specialized known ncrna search tools such as infernal  <cit> , rsearch  <cit> , and trnascan-se  <cit>  are all based on scfg. in conjunction with the ncrna family database rfam, infernal has been successfully applied to classify query sequences into different types of ncrna. however, scfgs are not able to model pseudoknot. thus, the implementations of scfg by infernal neglect pseudoknots in the structures. for example, although rf <dig>  has four pseudoknots, its scfg only models the knot-free structures, shown in figure  <dig> b. as a result, infernal could misclassify sequences as members of families containing pseudoknots. in addition, infernal has high computational cost, limiting its usage in large-scale data sets, such as those generated by the next-generation sequencing technologies.

more complicated grammars such as context-sensitive grammars   <cit>  exist to faithfully model pseudoknots. however, the computational cost of the parsing algorithms of a csg is even higher than using a cfg. besides csgs, other grammars such as parallel communicating grammar systems  <cit> , rna pseudoknot grammars  <cit> , tree adjoining grammars   <cit> , and multiple context-free grammars  <cit>  have been proposed to model pseudoknot structures. these work described the grammars and associated parsing algorithms. however, they have not been widely used in pseudoknot search in large-scale databases. first, although the parsing algorithms are polynomial, their cubic or even higher time or memory complexity  <cit>  limits their large-scale applications. second, these methods were designed for and tested on secondary structure derivation rather than homology search. in order to conduct large-scale homology search, local parsing algorithms are needed. as there are no source codes or executable implementations of these grammars, it is not clear whether they can be automatically applied to known ncrna search including pseudoknots.

in this work, we design an efficient pseudoknot search algorithm for all types of pseudoknots. our method is based on a set of carefully chosen simple sub-structures , which do not contain pseudoknots or bifurcations. the time complexity of the parsing and probability computation algorithms for an scfg including the cyk, the inside, and the outside algorithm will be significantly reduced when the secondary structure does not contain any bifurcation  <cit> . thus, these simple sub-structures can be searched efficiently using existing implementations of scfgs. for multiple sub-structures extracted from one ncrna family, we choose a set of sub-structures according to their sizes and false positive  rates in order to maximize the search performance. these chosen sub-structures will be used in a progressive search. our experimental results show that our tool competes favorably with other pseudoknot search methods.

related work
brown and wilson  <cit>  proposed an rna pseudoknot search method using intersections of scfgs. both brown's method and our approach try to decompose pseudoknot into knot-free structures for scfg modeling. there are two major differences. first, our sub-structures are not only knot-free, but also bifurcation free, which enables faster search. second, while brown and wilson's method focused on the model construction and parsing algorithm, we focus on choosing an optimal set of sub-structures to optimize the search performance. the model construction and the parsing algorithms can be conveniently implemented using infernal, which has gone through extensive testing.

structural motifs similar to sub-structures have been used as filters to speed up infernal. fastr  <cit>  relies on stem-loops -stack) that do not contain bulge or interior loops to search for ncrnas. weinberg et al.  <cit>  use more flexible structural motifs based on sub-cms and profile hmms for ncrna classification. smith  <cit>  used a decision tree to organize partial scfg models for fast ncrna search. currently, these filters are only designed and tested for speeding up scfg search.

available pseudoknot search tools include rnav  <cit>  and rnatops  <cit> . rnatops designs a graph model for rna pseudoknots and solves the structure sequence alignment by graph optimization. rnav is a profile based rna secondary structure variation search program that detects distant ncrna structural homologs, which might be missed by rnatops.

the chain filter designed by zhang et al.  <cit>  consists of a collection of short conserved words in an ncrna family. in our work, we use a collection of simple sub-structures for pseudoknot search. similar to zhang et al.'s work, we find that using a collection of simple structures can achieve a good tradeoff between sensitivity and false positive rate during search.

approach
there are two components in the method. the first component is the design of a set of sub-structures to represent an ncrna family. the second component is a progressive search strategy using the designed sub-structures. different regions of an ncrna sequence have different sequence and structural conservations. well-conserved structural and sequence motifs tend to yield better search performance than poorly conserved motifs. our approach sorts sub-structures extracted from different regions according to their lengths and predicted fp rates in order to choose a set of sub-structures with the optimal search performance.

for a chosen set of sub-structures, we conduct a progressive search according to a pre-determined order. during the progressive search, one sub-structure is only applied to regions containing matches to all previous sub-structures. a sequence is classified into the pseudoknot family if and only if 1) it passes the score thresholds of all the chosen sub-structures; 2) the position relationship between matched substrings is consistent with the relationship between the sub-structures. thus the false positive rate of the chosen set of sub-structures is bounded by the product of the false positive rates of all component sub-structures. the pipeline of the approach is illustrated in figure  <dig> 

sub-structure derivation
in order to use scfg-based models for pseudoknot search, we decompose a pseudoknot structure into simple sub-structures. each sub-structure contains at least one stem, which includes a set of stacking base pairs allowing short bulge and interior loops. a full secondary structure of an ncrna family can be decomposed into multiple stems. combinations of stems define different sub-structures. figure  <dig> shows all five simple sub-structures derived from the given pseudoknot.

we describe a method to systematically extract all simple sub-structures from a pseudoknot. in the first step, all stems are extracted and sorted in increasing order of their starting positions . second, we build a bit table r of size n by n for n stems extracted from the first step. for each cell r, if stem i and stem j are nested, r = 1; otherwise, r =  <dig>  table r provides us information about whether given stems can form one sub-structure. given the stem set and their relationship table r, we use pseudocode in algorithm  <dig> to extract all simple sub-structures. in the pseudocode, hx is the set of sub-structures containing x stems. thus, the union of hx for x =  <dig> to n consists of all simple sub-structures for a given secondary structure. the number of sub-structures depends on the number of nested stems. suppose the average number of nested stems inside a stem is n. the total number of sub-structures is o.

algorithm  <dig> extractsubstructures input: a secondary structure containing pseudoknots output: all simple sub-structures

1:   for each stem i =  <dig> to n do

2:      /* h: a sub-structure containing a set of stems */

3:      h = {i}

4:      h <dig> = h <dig> ∪{h}

5:   end for

6:   for l =  <dig> to n do

7:      hl = Ø

8:      for each sub-structure h ∈ hl- <dig> do

9:         for each stem i ∉ h do

10:            /* h is the ith stem in a sub-structure h */

11:            if r and r ... and r, i] then

12:            /* construct a new sub-structure h' */

13:            h' = h∪{i}

14:            hl = hl ∪{h'}

15:            end if

16:         end for

17:      end for

18:   end for

19:   output all sub-structures h = h <dig> ∪h <dig> ∪ ... ∪hn

algorithm  <dig> only outputs the combination of stems. for each stem  in a sub-structure, we add loop and flanking regions using the following three rules. let the 5' and 3' ends of the outmost base pair in a sub-structure be i <dig> and i <dig>  respectively. thus, i <dig> <i <dig> 

• rule 1: add all single-stranded regions including bulge and internal loops between i <dig> and i <dig> 

• rule 2: except the base pairs inside the chosen stems in a sub-structure, all other base pairs will be treated as single-stranded regions.

• rule 3: extend the flanking single-stranded regions to the left of i <dig> and to the right of i <dig> until the first base pair in other sub-structures.

search performance of different sub-structures
each sub-structure can be conveniently modeled by an scfg. as different sub-structures are derived from regions with different sequence and structural conservations, their corresponding scfgs have different performance in database search. in this section, we use an example to illustrate this. we built scfgs for eight sub-structures derived from rf <dig>  and evaluated the sensitivity, fp rates, and running time of the eight scfgs when applying them to a to a  <dig>  m maize genome . the sensitivity and fp rates of different sub-structures from the same family can be compared using true positive  hits and fp hits respectively, because the condition positive and condition negative sets are the same for all sub-structures derived from the same family. for any scfg mi, let the set of matched sequences be hit. let the set of true pseudoknot sequences be s, which are the sequences in seed families containing pseudoknots in rfam. the number of true positive and fp matches of a sub-scfg is |hit∩s| and |hit\s|, respectively. we summarized the tp hits and fp matches of eight scfgs under different score thresholds in figure  <dig>  in addition, the search times are included for the score thresholds corresponding to the highest sensitivity. it is clear that different scfgs have highly search performance. during a progressive search using a series of sub-structures, the number of matches of the preceding sub-structure determines the search space of the current sub-structure. thus, the total search time depends on both the fp hits and the model running time, which is heavily affected by the model length. in order to maximize the search efficiency, it is important to sort all candidate sub-structures according to their fp rates. when the fp rates of two or more sub-structures are similar , we prefer shorter models because they incur less search times.

sort sub-structures according to their e-values
there are two methods to calculate the fp rates of sub-structures. theoretically, by assuming a background model for random sequences and applying the cyk algorithm  <cit> , we can directly calculate the probability that a random sequence matches an scfg model. empirically, we can apply the scfgs to a large annotated sequence database and record the number of fp matches. however, as it is more important to compare the fp rates of different sub-structures than knowing their exact values, it is not necessary to directly calculate fp rates. by assuming that the scfg alignment scores for random sequences follow an exponential distribution, as implemented by infernal, we can use e-values of the designed score cutoffs to sort all sub-structures.

for an alignment score and a database size, an e-value indicates how many random hits a user can expect to see with the same or better score in a random sequence database of similar size. thus, e-value indicates fp hits when it can be computed accurately. currently, we are using the e-value calculation method provided by infernal. although the assumed score distribution is not accurate, we found that the estimated e-values allow us to compare fp rates of different sub-structures with high accuracy. in order to estimate e-value, infernal generates a set of n random sequences whose gc content depends on the covariance model. these n random sequences then are aligned against the model. in this process, all searching result with score >  <dig> will be considered as hits. scores of the top x hits are assumed to follow an exponential distribution with two parameters, μ and λ. the maximum likelihood approach is then taken to fit scores of hits into an exponential distribution.

 e=db*e-λ 

where db is adjusted database size and is defined as

 db=dbtargetdbsizerandom. 

in the e-value computation, μ and λ are parameters trained in infernal. sc is the score for which one needs to calculate e-value. dbtarget is the size of target database. dbrandom is the number of random sequences generated for curve fitting. at last, randhit is the number of random sequences found by the covariance model. we can directly obtain μ and λ from each calibrated covariance model, which is built for a sub-structure. with these two parameters available, we can use the above equation to compute e-values for given scores.

our experiments show that although the change of e-values does not scale with the change of the fp rates, the order of e-values is highly consistent to the order of fp rates for all  <dig> families we tested. only for scfgs with similarly small fp rates, their e-values cannot accurately reflect their order. table  <dig> presents an example. it is worth noting that we also considered to use the average entropy to sort the sub-structures. however, our experiments show that there is no systematic relationship between entropy-based measurements and the fp rates of sub-structures.

choose sub-structures for progressive search
during a progressive search based on multiple sub-structures, the final sensitivity is bounded by the lowest sensitivity of all sub-structures. the final search time and fp rates heavily depend on the order of applying these sub-structures. let the final array of sub-structures be sub=, where hi will be applied before hj if i <j. let the size of the original database be l. for a sub-structure hi, let ti and fpi be its search time per hit and fp rate, respectively. the final fp rate is bounded by ∏i=1nfpi. the final search time is roughly t=l∑i=1nti, where l∏j=1i-1fpj is roughly the search space for the sub-structure hi. minimizing t requires the accurate computation of ti or quantification of the relationship between ti and fpi, which is not known as a priori. although infernal provides estimated running time, it can be quite different from the true running time. according to the equations, it is clear that we should apply short sub-structures with small fp rates before long sub-structures with high fp rates. thus we develop a greedy algorithm to generate a set of sub-structures for progressive search based on our empirical observations.

we split sub-structures into short group and long group, which contain short and long sub-structures respectively. for each group of sub-structures, we sort the sub-structures according to their e-values and apply a greedy algorithm to choose a set of sub-structures for search. the main steps of the greedy algorithm are outlined below, starting from the short group:

 <dig>  in each iteration, choose the sub-structure with the smallest e-value. remove it and append it to the final sub-structure list sub.

 <dig>  remove any remaining sub-structure in both groups that only contains stems in this sub-structure.

 <dig>  repeat the first step until all stems are covered by one chosen sub-structure or the e-values of all remaining sub-structures are bigger than a pre-determined cutoff .

if sub has not included all stems, we apply the same process to the long group and append the chosen sub-structures to sub. we require all stems covered by the chosen sub-structures in order to ensure the representation of the annotated pseudoknot structure. it is possible that this constraint will exclude homologous ncrnas that lack annotated stem loop structures. currently, we use size  <dig> as the threshold to divide sub-structures into the short and the long group.

implementation
for each sub-structure, we train an scfg-based model based on the corresponding alignment in the training data using infernal. let the scfgs trained from n sub-structures of an ncrna family sub= be Π=, where mi represents a single scfg. a sequence can be classified into the corresponding family if the following conditions are satisfied. first, the sequence contains matches to all designed scfgs in Π. scfg match will be defined in the following text. second, for every pair of strings that match two scfgs, their position relationship must be consistent with the annotated relationship between two scfgs in the underlying ncrna family. there are three types of position relationship between two sub-structures: parallel, nested, and cross-over. cross-over indicates existence of pseudoknots.

we determine scfg match using score thresholds. for all sequences in the training set, its alignment score with a given scfg is computed. the minimum score of all the seed sequences is used as the score threshold. this score cutoff is similar to the nc  bit score thresholds used in hmmer  <cit>  or infernal. when the training data contains a good representation of the family member sequences, the computed score threshold can ensure a high sensitivity during homology search. if the training set only contains close homologs of this ncrna family, the designed cutoff may be too high for remotely related homologs.

experimental 
RESULTS
in order to test the performance of our tool for pseudoknot search in sequence databases, we conducted two experiments. first, we examined the automatically classified pseudoknot sequences in rfam. second, we applied it to part of the maize genome. on the same data set, we compared our tool with rnav, rnatops, and infernal.

pseudoknot sequences in rfam
because cfg cannot model pseudoknots, the implementations of stochastic cfg , covariance models  in rfam neglect pseudoknots in the structures. as a result, tools that use scfg for ncrna search such as infernal could misclassify sequences as members of pseudoknot families. each rfam family contains a seed sequence set and a full sequence set. while the seed sequence set contains manually validated homologous sequences, the full sets are automatically produced using scfg-based search against rfamseq database  <cit> . thus, some of the sequences in the full set may not contain pseudoknot structures that are annotated in the seed sequences. we examined the full member set of the  <dig> ncrna families containing pseudoknots in rfam using our tool. many families contain dozens of sequences that lack the annotated pseudoknot structures. for all those sequences that cannot be matched by our tool, we also utilized the infernal alignments and a rna stem finding tool rnamotif  <cit>  to double check whether the base pairs in pseudoknot structures are missing. the scfg alignments output by infernal contains annotations of all base pairs that do not form pseudoknots. by comparing the annotated base pairs and the consensus secondary structure of the seed alignments, we can extract the regions that should form pseudoknots. then, we applied rnamotif to output all stems of size at least two in the chosen regions. failing to output any stems validated our findings that these sequences do not have the annotated pseudoknots. the results are summarized in table  <dig>  although homologous ncrnas may not share the same set of stems, simply ignoring pseudoknots without knowing their impacts on the function can introduce a large number of false members. in particular, it was already experimentally shown that pseudoknot structures are vital to the functions of some types of ncrnas  <cit> . for these well-studied pseudoknot structures, it is important to include them during homology search.

data set preparation
we created a simulated data set based on a contiguous 22-mb region of the maize genome  <cit> . the annotation of the 22-mb region does not contain any hit to the  <dig> pseudoknot families in rfam. in order to evaluate the sensitivity of pseudoknot search tools, we randomly chose  <dig>  out of  <dig>  seed sequences from  <dig> pseudoknot families and inserted them in the 22-mb region. the remaining seed sequences are used as the training data. in order to examine the fp rate of scfg-based tools, we also created  <dig>  sequences without pseudoknots. specifically, for each of the  <dig>  seed sequences, we altered the bases to disrupt the base pairs that can form pseudoknots. similarly rnamotif is applied again to ensure these sequences lose the annotated pseudoknot structure. these modified  <dig>  sequences and the original 22-mb region of the maize genome constitute the negative training data. any hit to them is an fp hit. note that by changing the bases, the modified sequences might share lower sequence similarity to the trained model and thus pose an easier case for all tools. even so, our experimental results still show that different tools exhibit highly difference performance on this data set. thus, we feel this data set is a reasonable test set.

there are two major advantages of using this simulated data set for testing pseudoknot search tools. first, as the 22-mb region of the maize genome does not harbor any reported ncrna that contains pseudoknots, we can measure the empirical fp rates of pseudoknot search tools with higher reliability than using simulated sequences, which are usually generated using a simple i.i.d. model or low-order markov model. in particular, the maize genome contains a high percentage of repeats and low-complexity regions, which could not be simply simulated and can pose a challenge for ncrna search as warned by the rfam website . second, using thousands of seed members of the pseudoknot families provides us adequate test data for evaluating the sensitivity.

besides using the seed sequences of rfam, we also considered another pseudoknot sequence database pseudobase  <cit> . this database contains  <dig> rna sequences with pseudoknot structures. a majority of them are sub-strings of rfam seed sequences. thus, we choose to use rfam seed sequences as the true label.

results and comparisons
in order to separate the training set and the test set, we removed the sequences that were inserted in the maize genome from the seed alignments. for the alignments composed of the remaining sequences, we trained the full covariance model and the models for the sub-structures. we used the designed sub-structure sets for pseudoknot search. we evaluated the performance of pseudoknot search tools using three metrics: the sensitivity, fp hits, and running time. for each ncrna family represented by an scfg m , let hit be the set of output sequences by a search tool. let s be the set of true pseudoknot sequences, which, in this data set, includes seed sequences of each pseudoknot family. the sensitivity is thus defined as:

 sensitivity=|hit∩s||s| 

any output that does not overlap with true pseudoknot sequences is a false positive hit. the number of fp hits of a search tool on one family is computed as:

 fphits=|hit\s| 

we report the fp hits instead of the fp rates for two reasons. first, the condition negative set is family specific and thus is the same for all search tools for a given family. second, the size of the condition negative set is mainly determined by the size of the genome minus the size of all true pseudoknot sequences. for a large genomic sequence, the fp rate becomes very small and cannot reflect the difference between different tools.

on the same dataset, we run rnav, rnatops, and infernal  <dig> . <dig>  of the three, rnav and rnatops are designed for pseudoknot search. for infernal and sub-structure, no hidden markov model-based filtration was used in order to maximize the sensitivity. other parameters were set as default for infernal. we used the default parameters to run rnav and rnatops. all experiments were run on the main cluster of the high performance computing center on campus . each experiment was allocated four cpu days at most. there are  <dig> families and  <dig> families that failed rnav and rnatops, respectively. the search jobs for those families were killed by the cluster after four cpu days. no results were produced. thus we could not report the results for those families. rnaptops output results for  <dig> families by the end of the allocated time.

the performance of these four tools is recorded in table  <dig>  the results show that our tool is significantly faster than rnatops and rnav. for a majority of families, the running time is smaller than half an hour. a closer examination reveals that 99% of the running time is attributed to the first sub-structure, which is expected. of the six families for which rnav successfully generated outputs, they all have the sensitivity of  <dig> , equal to the sensitivity of sub-structure based search. of the  <dig> families for which rnatops reported results,  <dig> of them have equal sensitivity to ours.  <dig> family yields slightly better sensitivity than ours while other  <dig> families have significantly worse sensitivity. thus, overall, our search achieves higher sensitivity than rnav and rnatops. in addition, sub-structure based search tool incurs lower fp rate than rnatops and rnav. table  <dig> shows that rnatops yields low fp hits. of the  <dig> families, rnatops has the same number of fp hits as ours for only one family and significantly more fp hits for the rest. in particular, rnatops outputs over  <dig>  hits for  <dig> families.

bold font is applied to the highest sensitivity, the lowest fp hit, or the shortest running time for each rna family. the empty cells indicate that the corresponding tools did not generate any output within  <dig> cpu days.

we compared the sensitivity, fp hits, and running time of infernal and our tool in figure  <dig>  figure  <dig>  and figure  <dig> using x-y scatter plots. as infernal and our tool generate the same sensitivity or other metrics for some families, we use the bubble plot to visualize the number of the same data points. as expected, infernal is highly sensitive. however, it reported dozens of hits on the pseudoknot-free sequences which we inserted as false positive sequences. for all families, infernal reported equal or more fp hits than our tool. in addition, it is generally slower than sub-structure-based tool. out of  <dig> rna families, sub-structure-based tool has shorter running time on  <dig> families. for  <dig> families, it yields 10x speed up over infernal.

there is no significant difference in the sensitivity between infernal and sub-structure-based tool when the average sequence length in a family is not too long. infernal has better sensitivity on longer and more complicated rna families including rf <dig>  rf <dig>  rf <dig>  and rf <dig>  the major reason behind our worse sensitivity on the long families is that we use sub-structure that cover every stem. thus, we only classify sequences that have all characterized stems from the underlying structure. however, some remote homologs may lose base pairs in stems during evolution. thus while we guarantee to find sequences that have the same structures as the annotated pseudoknots, we can miss some homologs, leading to lower sensitivity for some families.

CONCLUSIONS
although infernal is highly sensitive in known ncrna search, caution must be taken when applying infernal to ncrna families containing pseudoknots. in this work, we designed a pseudoknot search method based on a set of carefully chosen sub-structures. these sub-structures do not contain pseudoknots or bifurcations. scfgs can be conveniently built on them and searched with high efficiency. in order to minimize the overall fp rate and the running time, we sorted sub-structures according to their lengths and their e-values for designed trusted cutoff  bit score thresholds. we designed a greedy algorithm to choose a set of sub-structures and applied the progressive search to minimize search time. our experimental results showed that our tool competes favorably with rnav and rnatops, both of which have been used for pseudoknot search in large databases. this work provides a complementary pseudoknot search tool to existing scfg-based knot-free ncrna search methods.

currently our tool only reports homologous ncrnas with the same number of characterized stems as the training data. as a result, some true homologs that have lost one or multiple stems will be ignored. as part of the future work, we plan to incorporate available rna-seq data for remote homology search.

competing interests
the authors declare that they have no competing interests.

authors' contributions
ys proposed the original idea and algorithms. ys and cy both contibuted to experiment design. cy conducted the experiments and implemented the algorithms. both authors read and approved the final manuscript.

declarations
the publication costs for this article were funded by nsf dbi- <dig> and ios- <dig> 

this article has been published as part of bmc bioinformatics volume  <dig> supplement  <dig>  2013: selected articles from the eleventh asia pacific bioinformatics conference : bioinformatics. the full contents of the supplement are available online at http://www.biomedcentral.com/bmcbioinformatics/supplements/14/s <dig> 

