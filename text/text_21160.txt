BACKGROUND
the term 'grid' was coined in the mid-1990s and designates distributed computing infrastructures for science and engineering  <cit> . today, grids seek to provide seamless, scalable, high-performance and secure mechanisms for locating and negotiating access to remote and possibly heterogeneous resources  <cit> . the specific goal underlying the grid concept is coordinated resource sharing and problem solving in dynamic, multi-institutional virtual organizations  <cit> .

computational biology applications with large memory and cpu requirements have been a significant driving force behind grid development  <cit> . however, the discovery mode of many computational biology initiatives which favours the autonomous use of rapid prototyping environments by small groups or even individual researchers, which does not bode well with the predominant, heavier, distributed computational infrastructures available. in this regard it is useful to recall the context of their development and in particular the eroding distinction between data and computational grids.

some grid middleware has evolved to bind data resources scattered across a network into a unified environment to make it appear to the user as if all the data is stored locally on that user's desktop . computational grids, on the other hand, provide the ability to perform computations remotely, possibly in parallel, without the user having to know anything about networking and communication between the computers . majority of grids today act as both data and computational grids  <cit> .

particularly illustrative examples of working grid systems for computational biology are folding@home, north carolina biogrid, cabig, and mygrid. the goal of folding@home is understanding protein folding, protein aggregation, and related diseases by utilizing idle cpu cycles  over a collection of computers  <cit> . nc biogrid combines computing and data resources into a unified environment for genomic research   <cit> . cabig is the cancer biomedical informatics grid, it is made up of network of individuals and institutions to enable the sharing of data and tools for cancer research  <cit> . another example of the grid that is being used in bioinformatics is mygrid  <cit> . mygrid is an infrastructure specifically designed to support biological applications. it provides access to analysis tools  or database services thus making it a diverse service grid. although the above implementations are excellent examples of the working bioinformatics grids, their scope is far beyond the scope of the solution proposed in this report, and most importantly none of these grids allow for distribution of user-defined libraries on remote machines at runtime, which is the main goal of mgrid.

matlab is a particularly popular computing environment for rapid prototyping  <cit> . the potential advantages of building a distributed computing capability in matlab were reflected by the development of over twenty infrastructures to distribute and/or parallelize matlab  <cit> . some examples are: multimatlab, matlabmpi, matlab*g, distributed computing toolbox. most of the existing tools require an underlying parallel library or language, such as message passing interface   <cit> , parallel virtual machine pvm  <cit> , or a communication technology like jini  <cit>  or alice  <cit> . the installation and configuration of such environments often require a significant level of system administration knowledge and makes systems less secure. also, message-passing and shared-memory tools are designed to work best on a local area network , for example on a cluster of machines. these tools are not easily extensible to span across large heterogeneous wide area networks  such as the internet  <cit> . moreover, none of these environments allow for distribution of user-defined matlab libraries.

it is noteworthy that our method relying on code distribution is not proposed in strict alternative to message passing. quite the opposite, there is no fundamental reason why they cannot be mixed.

some environments only allow for coarse-grained parallelization, i.e. at the functional level or only parallelization of matrix operations and for-loops  <cit> . for example, the distributed computing toolbox  <cit>  is a matlab native toolbox that enables users to execute independent parallel algorithms on a set of machines simultaneously. this library, which works together with the distributed computing engine, requires jini technology to facilitate communication between computers that comprise a distributed computing environment. jini is a java based software and thus requires installation of the java specific runtime environment and jini servers on all machines. once again, the distributed computing toolbox does not allow for the dynamic distribution of the user code.

the differentiating characteristic of mgrid is indeed user code distribution. while this report focuses on a proof-of-concept of matlab implementation of code distribution, the concept itself is general and can be embedded in other programming environments. mgrid allows unique user code to be dynamically migrated to heterogeneous computers, i.e. it allows for user-defined matlab commands and libraries of functions needed to execute those commands, and run-time variables, to be passed to the remote machines automatically. this involves run-time allocation of resources, such as, available cpu cycles, memory, and user code and data distribution.

a reliable file transfer capability is provided by gridftp which could be used for transferring the necessary user code in mgrid. using gridftp for our purposes would require the installation of both the gridftp client on the client machines and the gridftp server on the worker systems. furthermore, the worker machines must also have the globus toolkit installed. the authors believe that these installation requirements are overly complicated and have decided to implement a simpler solution using php  <cit>  and hyper text transfer protocol .

a second feature of mgrid is support for parallel remote matlab command execution. thus, mgrid includes the ability to distribute computations in parallel, although in a basic sense, i.e. what is commonly called "embarrassingly parallel" computations  <cit> . in the code distribution by mgrid this is achieved by coarse-grained parallelization, at the function level.

the specific goal of this research was to advance the automatic distribution of algorithms written in matlab by developing a library for distributed computing on blade servers at the bioinformatics core of the nhlbi proteomics center at musc. the original motivation was to speed the reverse engineering of biological networks using s-systems  <cit>  by allowing numerical decoupling of the ensuing system of coupled differential equations  <cit> . the bioinformatics justification and likely usefulness of the code distribution scheme proposed here is a reflection of the particular need to systemically integrate a variety of data and models  <cit>  which themselves may change in structure and even in purpose over time. furthermore, tackling the systems biology challenge is increasingly not just a matter of coping with large amounts and large variety of data and applications but also of testing alternative theoretical foundations. consequently, the challenge that mgrid seeks to address is the creation of a user-friendly programming environment tailored to rapid prototyping such that algorithm and theory development could share a common programming environment.

implementation
the 'm' in mgrid
the letter 'm' in mgrid refers to matlab, a programming environment by mathworks inc.  <cit> , the implementation language of the mgrid software and also the language of the code being distributed. the choice of matlab to implement code distribution is a reflection of its popularity for rapid prototyping of scientific and engineering applications. the combination of user-friendliness and support for high end applications makes it a natural choice for the implementation of grid computing through code distribution. nevertheless, it should also be noted that matlab is a commercial product witch raises a cost barrier to access and scaling up the proposed implementation. nevertheless, there are free, open-source, matlab-like tools available  onto which the implementation described here can be easily ported. other then the language itself, this is an open source, freely distributed tool .

matlab was chosen for being the most complete of these environments and for the availability of implementations for all the major operating systems. the same is true for the other components of mgrid â€“ apache web server package and its php module. therefore, the grid computing implementation described here is truly platform independent. finally, this is also the environment of choice for training in scientific computing and computational statistics in academia.

connectivity
at the heart of every grid is a network that links together distributed resources. it is important to note that mgrid uses the standard http protocol which runs on top of tcp/ip, which facilitates interoperability, extensibility and portability of the software. tcp/ip also provides reliable delivery of the data, as it automatically detects errors and requests retransmission until all data is received. mgrid uses the apache web server  <cit>  to establish communication with contributing computers, and php  <cit> to structure the data transferred between participating computers.

mgrid architecture
the full mgrid implementation includes dedicated mediating server machines to manage the client requests and select the best available workers, following a semi-hierarchical architecture . this architecture consists of two master servers  that can independently decide which worker to send a given request to, based on user requirements for cpu speed, available ram, and workload.

the master servers are defined as a redundant set of two machines that maintain balanced workload distribution among workers in mgrid . the main and backup systems maintain identical information on the availability of the worker machines to be targeted by remote calls. global eval function geval initially communicates with the main master server. a request will always go to the same main server. the backup master will be contacted only in the case of the main server not responding to the client's request, thus preventing any downtime of the mgrid. the mgrid will be temporarily unavailable in the case of both the main and the backup master servers being down simultaneously. after geval receives the worker ip address it sends the job request to that worker.

addition of workers to the mgrid requires a request to be sent  to both master servers so that a consistent view of the worker states is maintained. master servers have a check mechanism to prevent multiple additions of the same worker to the mgrid if volunteer command is executed more then once. thus repeated executions of the volunteer command will have no effect on the masters.

master servers maintain workload information on the workers by periodically polling the workers about the number of their available cpu cycles. this is done by crontab calling a php script update_busyinfo.php, which in turn contacts all the workers to get the workload information by calling a php script busyinfo.php on remote machines. the information returned includes cpu idle time, amount of available memory, and processor speed. based on the results returned by each worker, the workload of each worker is accurately updated. if a worker becomes unavailable, then all three of the above resources are set to zero, and that particular worker will no longer be considered for incoming requests. also, after a particular server assigns a job to a worker the workload information stored on that master server is updated by incrementing the record of the worker's workload by a constant load percentage. a load percentage of 15% empirically found to be sufficient for the purpose of statically estimating the expected workload increase on that computer and thus making it no longer the least busy worker.

the basic call to mgrid is mediated by the function geval  that selects a main master server from a list of two candidate mgrid master server machines. a message is then sent to the chosen master server requesting the ip address of the current 'best' available worker known. upon receiving the ip address of the best available worker, geval, packs all the information necessary for the command to execute successfully on the remote machine:

â€¢ converts this command to a string, encoded in a format appropriate for use within a unified resource locator 

â€¢ encodes any workspace variables

â€¢ encodes client toolbox

geval then calls the reval procedure, which is responsible for data transfer to the remote worker and collection of the results after worker complete the assigned jobs.

the task of adding the master server to the mgrid needs to be performed before any other components are installed, as both client and worker installations require the address of two master servers to which they relay their requests and accept reassignments to worker machines. on the contrary, as mentioned before, dynamic accommodation of new participants is provided by the master servers so the constellation of worker machines available to the master servers for assignment of incoming jobs, can be changed at anytime without interruption of ongoing jobs or submission of new jobs. two additional functions distinguish master servers from the workers: add_worker.php and get_worker.php. the first function, add_worker.php, allows a new worker machine to be added to the grid. this function verifies that the worker is accessible via http  protocol and that it is ready to accept the remote jobs. function get_worker.php is used by mgrid to provide client with the ip address of the current best available worker.

at this time mgrid does not incorporate a client-control system. control is managed by the network configuration, currently mgrid is located behind a university firewall preventing outside access. anyone within the university can be an mgrid client. virtual private network  can be set up to enhance security by utilizing data tunnelling and encryption to work over the internet.

RESULTS
user-defined code distribution
user code distribution is the defining feature of mgrid, allowing a user to provide and operate a new function or a library of functions that is not kept on the grid itself. mgrid supports client functionality to pack the user's unique code and variables, transfer them over a network to a remote worker machine where they are unpacked and evaluated. this makes mgrid a desirable tool for scientists that write their own functions and want them to be executed on one or more remote computers without having to install those functions on all of the machines participating in the mgrid. this is a convenient and more secure feature than process distribution, because it eliminates the need to require that users have permissions to install or write files on the distributed computers. it also eliminates having to propagate every small user code changes to all of the machines.

a client can issue a command to a specific worker machine, possibly passing local work space variables and functions or entire matlab toolboxes necessary for computation. in this basic remote evaluation mode of operation , the worker machine autonomously handles the request, makes results available to the client and then removes the client code from its hard drive, following a standard client-server model  <cit> . mgrid automatically handles the entire process such that user specification of parallel execution does not depend on the code, unlike other parallel environments like mpi or pvm  <cit>  that require users to learn a parallel programming language in order to write code that can be run in parallel.

mgrid provides a fully parallel configuration where the user simply has to list the multiple commands to be executed in an array. both the selection of worker machines and code distribution are automatically mediated by mgrid. of course, for parallel execution, the multiple matlab commands given by the user have to be independent of each other  <cit> .

client side of mgrid
in order to access an existing mgrid infrastructure, a potential client needs only to have a small matlab toolbox and learn how to use three new commands. as any other matlab function, these functions can be inserted anywhere into other scripts and functions in order to have the corresponding input argument command expression evaluated by mgrid.

using mgrid
from the user's perspective, the toolbox is simple to install  and use. it runs on windows, macintosh and linux systems. clients wanting to utilize mgrid on a computer with a current copy of matlab, must perform the following steps:

 <dig>  download 'mgrid client toolbox.

 <dig>  start using mgrid.

the toolbox comes with a text file, masterservers, listing the ip addresses of the two mgrid servers  available to that user. this text file can be generated by the system manager and made available to the users as a separate download or the user can edit its contents to include the correct ip addresses for the target mgrid server installation.

client toolbox functions
there are only three functions that need to be learned to use mgrid, though the client toolbox consists of approximately twenty:

geval â€“ global eval procedure, evaluates command on remote machine participating in mgrid .

worksp â€“ matlab script, packs workspace variables into one structured variable wksp .

uworksp â€“ matlab script, places fields of the structured variable result_ into workspace .

because of the simple design of mgrid, the user is required to read very little documentation in order to begin writing parallel matlab computations. therefore, the user manual is minimal.

return variables
after the completion of a geval procedure one structured variable, result_, is returned to the client with the new variables or new values of original variables. the return value should be assigned to the variable result_ if the use of the script uworksp to automatically unpack the values to the client's local workspace, is desired.

server side of mgrid
the configuration of an mgrid facility requires the configuration of master server and worker machines. both are fairly simple to follow. the worker configuration in particular is designed to be accessible to the average matlab user wanting to contribute a machine to a local mgrid infrastructure. this requires minimal system administration expertise. at this time, automated server side installers are only provided for linux machines. client side is platform independent. a worker can be a client of mgrid at the same time.

adding a worker to the mgrid
to ensure that mgrid can dynamically accommodate new participants across different platforms, the worker side toolbox includes a function to mediate volunteering their cpu-cycles: any computer with a copy of matlab and a web server can be made a worker without interruption or reconfiguration of ongoing processes. the automatic configuration of a new worker consists of three easy steps:

 <dig>  download the 'mgrid worker toolbox'.

 <dig>  execute the workerconfig script. upon completion the matlab function todoprocessor will be running as a background process.

 <dig>  execute the volunteer command from matlab, upon completion check for either an error or success message displayed. once a success message is displayed, the worker system is ready to accept remote jobs.

a script for automatic apache web server configuration is available for linux computers. the script is geared towards the default installation and configuration of apache. if some user modifications are present, the script may not be able to perform all of its tasks. the user then will have to make sure that apache is running and is able to access users' public_html directories manually.

a todopr is a startup script that is added to the list of jobs started upon boot up of the computer to automate the process of restarting todoprocessor in case of a shutdown or reboot of the machine. todoprocessor can also be stopped, started and restarted manually by executing the todopr shell script manually with proper arguments.

worker toolbox functions
there are two important functions in the worker toolbox:

volunteer â€“ requests that the current computer be added to the workers pool on the master servers. this function should be executed after the installation of the toolbox.

todoprocessor â€“ executes commands that arrive from remote machines. see display of the help file bellow.

function todoprocessor is a service started automatically at computer boot time. it locates newly arrived requests, starts the execution of the requests, updates the status of the request to 'running', and finally when request is completed it makes results available to the client.

adding a master server to the mgrid
as for the worker side toolbox, the automatic installation scripts provided for the master side toolbox were written specifically for computers running the linux operating system and the apache web server. equivalent versions for other combinations of other operating system / web server should be straight forward. the automatic configuration consists of three easy steps:

 <dig>  download the 'mgrid master server toolbox'.

 <dig>  execute the masterconfig script. upon completion the matlab function todoprocessor will be running as a background process. at this time the master is ready to issue ip addresses for the best available workers.

 <dig>  execute the volunteer command from matlab, upon completion check for the display of either an error or success message. when a success message is displayed, the worker component of the system is ready to accept remote jobs.

the masterconfig script is built on top of the workerconfig and has additional functionality necessary for the master server configuration. thus any master server has the full functionality of the worker and is added to the pool of worker machines by the volunteer command. if a master is not intended to participate also as a worker, then step  <dig> should be omitted. a master can also be removed from the pool of workers at any time by manually removing its ip address from the workers file and stopping the todoprocessor by executing the todopr script with the option stop .

discussion
this paper presents an easy-to-use, configurable, distributed system that allows for parallel matlab user code distribution. the main objective was to allow users to execute exclusive matlab code, possibly in parallel, on a remote, perhaps more powerful, machines with minimal learning curve. to use mgrid, the user, familiar with the simple matlab programming language, only needs to learn a single new command, the global eval procedure , described in this paper. the implementation, which is based on two redundant master servers that hand down the jobs submitted to a fluid set of worker machines , further contributes to the user not having to be at all aware about the resources recruited to support distributed execution. furthermore, committing new workers to mgrid is, like the code distribution itself, entirely web-based and automated through the execution of a single automatic command.

although the initial specific motivation for the development of mgrid was to assist in experimenting with parallelizing data collocation schemes for numerical decoupling of systems of differential equations describing metabolic networks the use of code distribution was found to have a more general applicability. consequently, mgrid was developed, as described here, with a wider range of scientific and engineering applications, within and beyond bioinformatics. although the implementation described is specific to the matlab programming environment, it is simple enough to be readily portable to its open-source publicly licensed clones such as octave and freemat  <cit>  and to matlab-like environments such as euler, tela or scilab.  <cit> . the remaining software components of mgrid, apache and php, are themselves mainstream open-source public license applications. the future development of mgrid is hereby opened to the community by releasing it under gnu general public license  and will likely include a version for octave and freemat and a graphical user interface  with time information and various statistics on current remote executions to assist in identifying optimal load balancing schemes. some modifications to the installation scripts are also immediately anticipated to tailor the installation to the particular design of the operating system â€“ for example implementing todoprocessor as a sysv init script .

it is immediately apparent that the proposed implementation requires fast communication among participanting machines. therefore, mgrid is not suitable for speeding up processes that would run in a few seconds on a single machine. a more suitable scenario is the one where the execution of an algorithm takes a long time to complete, thus justifying the migration of the libraries to different computers. figure  <dig> displays the execution time for the identification of the density distribution using parzen kernels for different sizes of the resulting matrix. mgrid was used to distribute this computation among two and later among three computers. the results were compared with a sample run where no distribution was used at all. parzen kernels superimpose gaussian "hat" distributions to determine the density distribution for a scatter plot. this is a very convenient alternative to discretizing the scale and representing the histogram of frequencies. the computation of this kernel consists of centering a gaussian "hat" on each available point in the scatter plot. each individual "hat" has unitary volume so the superimposed distribution can simply be divided by the number of points to get a unitary density distribution. the illustration described here applies the parzen kernel to a replicate series of microarrays with the purpose of identifying a reference conditional cumulative distribution to access the statistical significance of observed differential expression. the rationale for this empirical solution to statistical modeling was recently illustrated by one of the authors for a proteomics dataset  <cit> . the superimposition of gaussian hats is an additive procedure that can be independently computed in parallel. as can be seen from figure  <dig>  even computations that take several minutes to complete, can benefit greatly from using mgrid. in this case, the speedup in execution time of the parallel algorithm on three computers is  <dig> . this speedup is slightly less then the theoretical maximum of three, due to the overhead of user-code transfer time and remote request assembly time. computations that can be formulated as a composition of independently computed parallel results, as exemplified by the suprapositioning of parzen kernels illustrated above, often occurs in computational biology applications. the applications typically include multiple, independent, time consuming operations such as querying public databases, non-linear regression, and numerical simulations.

CONCLUSIONS
distribution of user-defined matlab toolboxes and rapid prototyping of many coarse-grained parallel applications can now be done with a single easy-to-use matlab command. the implementation is made available as a suite of three matlab toolboxes, collectively described as mgrid, with client, master and worker implementations. multiple roles can be assigned to the same machine. because mgrid utilizes only matlab, light-weight php scripts and apache web server the installation and configuration are very simple. moreover, the web-based infrastructure of mgrid allows for it to be easily extensible over the internet.

the implementation of mgrid is being made freely available under a gnu general public license  <cit> , where contributions for further development are invited, particularly in regards to developing a version that relies entirely on public license components. a particular note regarding copyright issues is warranted for implementations relying on mathworks inc. matlab environment  <cit> . the prototype described here relies on a set of machines served by the same concurrent license manager. for more distributed implementations attention should be paid to the details of the particular license agreement associated with the purchase. in that regard porting the implementation to octave, freemat or porting the code distribution environment to support other advanced programming languages such as python may be an alternative worth exploring. considering the fact that all the communication is done via php scripts, modifications to accommodate more languages will be minimal.

availability and requirements
the client, worker and master mgrid toolboxes are made freely available with open source at .

the code distribution toolbox was developed and tested for matlab version  <dig>  release  <dig>  php  <dig> and apache http  server version  <dig> . <dig>  the client side toolbox distributed is operating system independent and uses only native functions of matlab, itself available for linux, solaris, windows and macos  <cit> . the worker and master server toolboxes were developed for linux os. accordingly, the automatic configuration scripts for those two toolboxes are only guaranteed to work for that choice of os and web server. however, both apache and php are widely available in equally open source and freely distributed implementations for other operating systems. similarly, porting the automatic configuration scripts for other web-servers should be straight forward.

authors' contributions
yvk performed software development  and elaboration of manuscript. jsa developed the original concept and drafted the implementation layout.

